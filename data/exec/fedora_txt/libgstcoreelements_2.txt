__gmon_start__
__cxa_finalize
_Jv_RegisterClasses
gst_base_transform_get_type
gst_type_register_static_full
_gst_debug_category_new
g_type_class_peek_parent
g_type_check_class_cast
gst_caps_get_type
dcgettext
g_param_spec_boxed
g_object_class_install_property
__gst_debug_min
gst_buffer_set_caps
gst_mini_object_ref
gst_debug_log
gst_caps_ref
gst_caps_make_writable
gst_caps_do_simplify
gst_caps_is_fixed
gst_caps_unref
gst_caps_is_empty
gst_buffer_is_metadata_writable
gst_buffer_create_sub
gst_pad_set_caps
gst_pad_get_allowed_caps
g_return_if_fail_warning
g_type_check_instance_cast
gst_caps_intersect
gst_caps_replace
g_type_name
gst_value_set_caps
gst_value_get_caps
gst_caps_new_any
gst_element_get_type
gst_element_class_set_details_simple
gst_static_pad_template_get
gst_element_class_add_pad_template
gst_element_register
gst_plugin_desc
gst_base_src_get_type
_gst_debug_register_funcptr
g_param_spec_enum
g_param_spec_int
g_enum_register_static
g_param_spec_boolean
g_param_spec_string
gst_pad_get_type
gst_buffer_get_type
gst_marshal_VOID__OBJECT_OBJECT
g_signal_new
g_threads_got_initialized
gst_mini_object_unref
g_free
g_thread_functions_for_glib_use
gst_buffer_new
g_malloc
memset
g_random_int_range
g_snprintf
gst_mini_object_get_type
g_strdup_printf
g_object_notify
g_signal_emit
gst_util_dump_mem
gst_base_src_is_live
g_strlcpy
g_malloc0
gst_element_get_clock
gst_clock_get_time
gst_element_get_base_time
gst_object_unref
g_assertion_message_expr
__stack_chk_fail
gst_event_get_structure
gst_structure_to_string
g_strdup
g_type_check_instance_is_a
g_value_set_boolean
g_value_set_string
g_value_set_int
g_value_set_enum
g_value_get_boolean
gst_base_src_set_live
g_value_get_enum
g_value_get_int
gst_base_sink_get_type
_gst_element_error_printf
gst_core_error_quark
gst_element_message_full
gst_push_src_get_type
gst_uri_handler_get_type
g_type_add_interface_static
lseek
gst_poll_remove_fd
gst_poll_add_fd
gst_poll_fd_ctl_read
__fxstat
gst_uri_get_protocol
sscanf
gst_poll_wait
__errno_location
g_strerror
gst_resource_error_quark
gst_buffer_new_and_alloc
gst_poll_set_flushing
gst_poll_free
gst_poll_new
gst_poll_fd_ctl_write
gst_pad_set_query_function
gst_pad_query_default
gst_query_parse_position
gst_query_set_position
gst_query_set_formats
gst_uri_construct
g_str_has_prefix
g_strconcat
gst_uri_get_location
g_path_is_absolute
g_param_spec_uint
fflush
fseeko
ftello
gst_event_parse_new_segment
gst_format_get_name
fwrite
fclose
fopen
__fbufsize
setvbuf
g_value_set_uint
g_value_get_string
g_value_get_uint
gst_base_sink_set_sync
gst_uri_handler_new_uri
g_param_spec_ulong
g_type_register_static
mmap
gst_mini_object_new
madvise
munmap
g_value_set_ulong
g_value_get_ulong
getpagesize
g_param_spec_float
rand
gst_util_uint64_scale_int
g_usleep
gst_clock_new_single_shot_id
gst_clock_id_wait
gst_clock_id_unref
gst_segment_to_running_time
gst_structure_new
gst_object_get_type
gst_message_new_element
gst_element_post_message
gst_event_new_new_segment
gst_pad_event_default
g_value_peek_pointer
gst_value_get_mini_object
g_value_set_float
g_value_get_float
gst_base_transform_set_passthrough
g_cclosure_marshal_VOID__VOID
g_param_spec_uint64
g_queue_pop_head
g_queue_is_empty
g_queue_free
g_value_set_uint64
g_value_get_uint64
gst_segment_init
gst_pad_new_from_static_template
gst_pad_set_chain_function
gst_pad_set_activatepush_function
gst_pad_set_event_function
gst_pad_set_link_function
gst_pad_set_getcaps_function
gst_pad_set_bufferalloc_function
gst_element_add_pad
g_queue_new
gst_pad_get_peer
gst_pad_query
gst_query_parse_latency
gst_query_set_latency
gst_pad_push_event
gst_object_get_parent
gst_flow_get_name
gst_pad_start_task
gst_segment_set_last_stop
gst_event_parse_new_segment_full
gst_segment_set_newsegment_full
gst_event_get_type
gst_pad_pause_task
gst_pad_push
gst_buffer_make_metadata_writable
gst_event_type_get_name
gst_pad_is_linked
gst_pad_stop_task
gst_pad_alloc_buffer
gst_pad_peer_get_caps
g_queue_push_tail
gst_pad_set_active
gst_element_remove_pad
gst_pad_new_from_template
g_object_set_qdata_full
gst_pad_activate_push
gst_pad_proxy_setcaps
gst_pad_set_setcaps_function
gst_pad_proxy_getcaps
gst_pad_set_activatepull_function
gst_pad_set_checkgetrange_function
gst_pad_set_getrange_function
g_object_get_qdata
g_list_foreach
gst_object_ref
gst_pad_pull_range
gst_element_iterate_src_pads
gst_iterator_foreach
gst_iterator_free
gst_event_new_eos
gst_pad_check_pull_range
gst_pad_activate_pull
g_quark_from_static_string
gst_marshal_VOID__UINT_BOXED
g_list_free
gst_caps_copy
g_value_set_boxed
gst_pad_set_activate_function
gst_pad_use_fixed_caps
gst_element_get_state
gst_stream_error_quark
g_assertion_message
g_list_append
gst_type_find_helper_for_buffer
gst_buffer_join
gst_caps_is_any
gst_pad_query_duration
gst_type_find_helper_get_range
gst_pad_is_active
gst_data_queue_flush
g_object_unref
g_list_delete_link
gst_data_queue_set_flushing
gst_data_queue_new
g_signal_connect_data
gst_pad_set_internal_link_function
gst_pad_set_element_private
gst_pad_get_element_private
gst_data_queue_limits_changed
gst_data_queue_pop
g_list_prepend
gst_data_queue_push
gst_data_queue_is_empty
gst_data_queue_is_full
gst_data_queue_get_level
libgstbase-0.10.so.0
libgstreamer-0.10.so.0
libgobject-2.0.so.0
libgthread-2.0.so.0
libgmodule-2.0.so.0
libdl.so.2
libglib-2.0.so.0
librt.so.1
libpthread.so.0
libc.so.6
libgstcoreelements.so
/usr/lib64
GLIBC_2.2.5
GLIBC_2.4
%z""
%r""
%j""
%b""
%Z""
%R""
%J""
%B""
%:""
%2""
%*""
%"""
%z!"
%r!"
%j!"
%b!"
%Z!"
%R!"
%J!"
%B!"
%:!"
%2!"
%*!"
%"!"
%z "
%r "
%j "
%b "
%Z "
%R "
%J "
%B "
%: "
%2 "
%* "
%" "
=h&"
ATSubH
ffff.
="%"
t$ H
d$ L
l$(L
t$0H
=2#"
=;""
ffffff.
X([A
l$ L
d$(L
l$0H
l$ L
d$(L
l$0H
\$ H
l$(L
d$0L
l$8L
t$@H
fffff.
ffffff.
AUATI
4$E1
\$ H
([]A\A]
l$ H
fffff.
tHv&
fffff.
AVAUATUSH
U Hi
d$`H
\$ H
[]A\A]A^A_
\$ H
d$`H
l$ H
\$ H
l$(L
d$01
l$8L
t$@H
\$ H
l$(L
d$0L
l$8L
t$@H
\$ H
l$(L
d$0L
l$8L
t$@H
\$ H
l$(L
d$0L
l$8L
t$@H
\$ H
l$(L
d$0L
l$8L
t$@H
\$ H
l$(L
d$0L
l$8L
t$@H
\$ H
l$(L
d$0L
l$8L
t$@H
ffff.
l$ L
d$(L
l$0L
t$8L
|$@H
l$ L
d$(L
t$8L
|$@H
l$ L
d$(L
t$8L
|$@1
l$ L
d$(1
l$0L
t$8L
|$@H
l$ L
d$(L
l$0L
t$8L
|$@H
AVAUATUH
\$ H
\$ H
0[]A\A]A^
AVAUI
ATUH
d$PH
[]A\A]A^
d$PH
ffff.
l$ H
fff.
l$ H
l$ L
d$(L
l$0H
l$ L
d$(L
l$0H
\$ H
l$(L
d$0L
l$8L
t$@H
\$ H
l$(L
d$0L
l$8L
t$@H
\$ H
l$(L
d$0L
l$8L
t$@H
\$ H
l$(L
d$0L
l$8L
t$@H
l$(H
\$ L
d$0L
l$8L
t$@H
ffff.
\$ H
l$(L
d$0L
l$8L
t$@H
fff.
d$ H
D$8I
fff.
D$(%
D$0H
fff.
AVAUATSH
[A\A]A^
ffff.
AVAUATUSH
D$ H
D$ M
[]A\A]A^A_
l$ L
d$(L
l$0H
ffffff.
l$ L
d$(L
l$0H
l$ L
d$(L
l$0H
\$ H
l$(L
d$0L
l$8L
t$@H
\$ H
l$(L
d$0L
l$8L
t$@H
D$8%
l$ L
d$(L
l$0H
fff.
ATSH
D$ H
\$8H
l$@L
d$HL
l$PH
\$ H
\$ H
l$(L
d$0L
l$8L
t$@H
fff.
ffff.
fff.
	tfH
d$ H
ffffff.
d$ H
\$8H
l$@L
d$HL
l$PH
L$4L
L$ L
D$(1
D$4H
t$(I9
\$ H
l$(L
d$0L
l$8L
t$@H
l$ L
d$(L
l$0H
AUATUSH
([]A\A]
[]A\A]
l$ L
d$(L
l$0H
l$ H
d$(L
l$0H
l$ H
d$(L
l$0H
l$ H
d$(L
l$0H
\$ H
l$(L
d$0L
l$8L
t$@H
\$ H
l$(L
d$0L
l$8H
t$@H
ffff.
	tfH
d$ H
d$ H
[A\A
ATSH
fff.
l$0H
\$(L
d$8L
l$@L
t$HL
|$PH
ffffff.
l$ 1
d$(L
l$0L
t$8L
|$@H
l$ L
d$(L
l$0L
t$8L
|$@H
|$xA
l$0H
\$(L
d$8L
l$@H
t$HL
|$PH
x	I9
T$@v:H
D$HI
\$hH
l$pL
d$xL
D$PI
T$@D
D$PH
T$8L
\$0H
l$ H
\$0L
T$8I9
H9l$P
D$HL
H9\$P
T$8L
T$8I
D$PH
T$8L
T$8L
D$@L
L$ H
H9D$Pv]
+H9D$Pw
h@I)
ffff.
D$0H
D$8%
l$ L
d$(1
l$0H
l$ L
d$(L
l$0H
l$ L
d$(L
l$0H
l$ L
d$(L
l$0H
l$ L
d$(L
l$0H
l$ L
d$(L
l$0H
\$ H
l$(L
d$01
l$8L
t$@H
\$ H
l$(L
d$0L
l$8L
t$@H
\$ H
l$(L
d$0L
l$8H
t$@H
fff.
ffff.
AUATI
 [A\A]
X0[A
AVAUI
ATUSH
D$@H
D$8H
D$ 1
[]A\A]A^A_
%=l!
l$HD
D$@H
D$8H
D$ 1
E(Hc
T$xH
D$p,
T$hH
D$X,
D$`H
D$PI
T$8H
t$0H
D$@,
D$(,
D$HH
D$ H
="z!
D$p,
D$xH
D$hI
T$HH
D$X,
D$@,
D$`H
T$8H
D$PH
D$(,
D$0H
D$ H
=1w!
D$hL
T$pH
T$`I
\$XI
\$PH
T$HH
T$@I
D$8I
D$0H
T$(H
T$ I
=it!
=zs!
ffffff.
5;\!
\$ H
l$(L
d$0L
l$8L
t$@H
t$ H
 uNH
t$ H
ffff.
\$ H
l$(L
d$0L
l$8L
t$@H
\$ H
l$(L
d$0L
l$8L
t$@H
\$ H
l$(L
d$0L
l$8L
t$@H
\$ H
l$(L
d$0L
l$8L
t$@H
\$ H
l$(L
d$0L
l$8L
t$@H
l$(H
\$ L
d$0L
l$8L
t$@H
ffff.
\$ H
l$(L
d$0L
l$8L
t$@H
=gc!
ffff.
=$h!
AUATUSH
%\R!
[]A\A]
ATUSH
=Vb!
[]A\A]A
%9M!
fffff.
l$ L
d$(L
l$0L
t$8L
|$@H
l$ L
d$(L
l$0L
t$8L
|$@H
D$lI
D$lD
L$8M
D$0H
l$`H
D$ H
\$PL
T$HD
L$(D
D$hI
D$hL
L$PM
D$HH
\$`L
D$8H
L$@D
t$0D
D$pI
D$pH
D$`D
L$XL
t$HM
D$PH
\$0D
\$(D
T$ H
D$|I
D$|D
L$0M
D$(H
=0Y!
t$`L
l$PH
\$HD
\$@D
T$ H
D$xI
D$xL
L$HM
D$@H
\$`L
D$0H
T$8D
t$(D
L$`L
D$XM
T$PD
t$@A
D$HH
\$(D
\$ D
ffff.
=gQ!
AWAVAUATUSH
L$(D
D$ I
|$`L
t$XL
l$PL
l$@D
\$8D
h[]A\A]A^A_
h[]A\A]A^A_A
=.O!
ffffff.
T$(H
L$ H
t$0L
D$ H
t$4H
T$(L
\$8H
l$@L
d$HL
l$PH
L$ H
T$(L
H)D$(H
T$(L
H)D$(
=bN!
fffff.
%U9!
fff.
=dL!
d$ L
l$(L
t$0H
=BK!
L$8H
t$0D
D$(I
T$@D
l$ D
\$PH
l$XL
d$`L
l$hL
t$pH
=)G!
D$ H
\$0H
l$8L
d$@H
L$0H
T$8H
t$DL
L$(L
D$@H
D$ H
T$@H
t$DL
fffff.
=/E!
D$tH
D$tH
D$0D
D$`H
|$XL
t$PL
l$HD
d$@D
\$8D
\$xH
%|.!
=:B!
AWAVAUATUSH
D$pv5H
=5A!
=&@!
L$(D
D$ I
|$`L
t$XL
l$PL
\$@D
\$8D
x[]A\A]A^A_
L$`H
L$ H
|$XL
t$PL
l$HD
\$8D
\$0D
=e<!
L$(H
|$`L
t$XL
l$PL
\$@D
\$8D
=3;!
L$(D
D$ I
|$`L
t$XL
l$PL
\$@D
\$8D
H;0t
T$pv6H
t	H;
x[]A\A]A^A_A
=n6!
T$pv;H
=%6!
H;0t
=05!
fff.
l$ H
|$ H
ffffff.
D$0D
L$ A
|$`L
t$XL
l$PL
l$@D
\$8D
\$hH
l$pL
d$xL
l$pH
\$hL
d$xL
ffffff.
=:,!
L$ D
D$`H
|$PL
t$HD
l$@D
d$8H
D$XH
\$0D
T$(H
D$lH
D$pH
D$xH
D$lH
L$ D
D$`H
D$pI
|$@D
l$8D
\$0D
T$(H
D$XH
D$xH
D$PH
D$HH
L$(D
D$`H
|$PL
d$HH
D$XH
l$@D
\$8D
T$0H
=z(!
L$(D
D$`H
|$PL
d$HH
D$XH
l$@D
\$8D
T$0H
L$ D
D$`H
|$@D
l$8D
\$0D
T$(H
D$XH
D$PH
D$HH
ffff.
AWAVAUATUSH
D$pA
\$|L
D$|H
[]A\A]A^A_
L$@D
D$8I
L$ D
\$PH
T$HD
l$0A
=m!!
=y !
D$xH
D$xH
D$`D
D$ I
|$XL
t$PL
\$@D
\$8D
D$`D
D$ I
|$XL
t$PL
\$@D
\$8D
t$pH
D$`D
D$ I
\$@L
|$XL
t$PL
l$HD
\$8D
ffff.
d$ H
uKH9
d$ H
X0[A
l$ L
t$(L
|$0H
w@I;
ffffff.
AWAVI
AUATUSH
T$4I
9D$4
D$(H
[]A\A]A^A_
T$ H
D$ H
H t4H
L$ H
D$ H
|$ A
=Q	!
l$ L
d$(L
l$0H
l$ L
t$(L
|$0H
d$ H
l$ L
d$(L
l$0L
t$8L
|$@H
ffff.
l$ L
d$(L
l$0L
t$8L
|$@H
|$ H
l$ L
d$(L
l$0L
t$8L
|$@H
l$ L
d$(L
l$0L
t$8L
|$@H
l$ L
d$(L
l$0L
t$8L
|$@H
AWAVAUATUSH
T$4H
L$(L
L$(L
D$ H
T$4H
[]A\A]A^A_
D$ H
L$(H
T$4H
D$DA;
D$DA;
D$ H
AWAVI
AUATSH
D$(H
D$ H
0[A\A]A^A_
ffffff.
l$ L
d$(L
l$0H
l$ H
d$(L
l$0H
l$ H
d$(L
l$0H
\$ H
l$(L
d$0L
l$8L
t$@H
l$ H
d$(L
l$0H
@ H)D$
t$ H
ffffff.
fffff.
fffff.
AUATI
[]A\A]
fff.
t$$1
\$(H
l$0L
d$8L
l$@L
t$HL
|$PH
D$8H
T$(I
D$8H
t^s4L
\$8H
l$@L
d$HL
l$PL
t$XL
|$`H
VtwA
T$4H
D$(t
L$49
|$(1
D$ 1
D$ H
D$ M
ffff.
tssAI
\$8H
l$@L
d$HL
l$PH
T$4H
L$49
|$(1
fffff.
d$ H
|$8H
\$8H
l$@L
d$HL
l$PL
t$XL
|$`H
T$ H
t$0H
T$ H
L$4L
D$(L
D$(H
L$49
|$(1
AVAUATSH
[A\A]A^
ffff.
[]A\
ffffff.
D$8I
D$0A
T$ H
D$(A
\$@H
l$HL
d$PH
ffff.
ffff.
AWAVAUI
ATUH
[]A\A]A^A_
[]A\A]A^A_
[]A\A]A^A_A
AWAVAUATUH
[]A\A]A^A_
d$ H
l$(H
\$ L
d$0L
l$8L
t$@H
\$ H
l$(L
d$0L
l$8L
t$@H
l$ 	
d$(H
l$0H
l$ L
d$(1
l$0H
AVAUATUSH
([]A\A]A^A_
L$@D
t$0M
T$HD
t$(D
\$XH
l$`L
d$hL
l$pL
t$xL
t$ M
\$8H
l$@L
d$HL
l$PL
t$XL
|$`H
\$8H
l$@L
d$HL
l$PL
t$XL
|$`H
T$8H
L$0H
t$DH
D$ L
L$(L
D$@H
T$@H
t$DL
\$HH
l$PL
d$XL
l$`H
AWAVAUATA
T$PH
T$8H
Vt6E1
L$@L
|$PL
D$@H
t$(I
X[]A\A]A^A_
ffffff.
AWAVAUI
ATUSH
[]A\A]A^A_
taL9k
t$ H
t	H;
D$ I
fff.
\$ H
T$0I
|$0H
l$@H
\$8L
d$HL
l$PL
t$XL
|$`H
|$0H
fff.
t$(I
l$0H
\$(L
d$8L
l$@L
t$HL
|$PH
AWAVAUATUSH
|$ E1
;D$ w
8[]A\A]A^A_
AWAVAUATI
D$PH
;D$T
D$8I
D$0A
D$ A
x[]A\A]A^A_
tZ;D$`wT
x[]A\A]A^A_
l$ L
d$(L
l$0L
t$8L
|$@H
l$ L
d$(L
l$0L
t$8L
|$@H
\$ H
l$(L
d$0L
l$8L
t$@H
l$(H
\$ L
d$0L
l$8L
t$@H
GstCapsFilter
capsfilter element
capsfilter
gstreamer-0.10
Filter caps
gstcapsfilter.c
Have unfixed output caps %P
out_caps != NULL
gstcapsfilter.c:174
set new caps %P
gstcapsfilter.c:158
Generic
Restrict the possible allowed capabilities (NULL means ANY). Setting this property takes a reference to the supplied GstCaps object.
Input buffer already has caps (implicitely fixed)
Have fixed output caps %P to apply to buffer with no caps
Creating sub-buffer and setting caps
%s: invalid %s id %u for "%s" of type `%s' in `%s'
David Schleef <ds@schleef.org>
Pass data without modification, limiting formats
gst_capsfilter_prepare_buf
gst_capsfilter_set_property
coreelements
standard GStreamer elements
0.10.19
LGPL
gstreamer
Fedora Core gstreamer package
fakesrc
fakesink
fdsrc
fdsink
filesrc
identity
filesink
typefind
multiqueue
http://download.fedora.redhat.com/fedora
GstFakeSrc
fakesrc element
gst_fake_src_finalize
gst_fake_src_set_property
gst_fake_src_get_property
GstFakeSrcDataType
Data allocation method
GstFakeSrcSizeType
How to determine buffer sizes
sizetype
Minimum buffer size
sizemin
Maximum buffer size
sizemax
parentsize
GstFakeSrcFillType
filltype
Datarate
datarate
Sync
sync
pattern
The last status message
last-message
Silent
silent
Signal handoffs
signal-handoffs
Dump
dump
Can activate in push mode
Can activate push
can-activate-push
Can activate in pull mode
Can activate pull
can-activate-pull
Is this a live source
is-live
gst_fake_src_is_seekable
gst_fake_src_start
gst_fake_src_stop
gst_fake_src_event_handler
gst_fake_src_get_times
gst_fake_src_create
%u:%02u:%02u.%09u
none
last_message
gstfakesrc.c
pre handoff emit
post handoff emit
src->parent
gstfakesrc.c:574
GST_IS_FAKE_SRC (object)
not yet implemented
gstfakesrc.c:502
Fake Source
Allocate data
allocate
Subbuffer data
subbuffer
Send empty buffers
fixed
random
Leave data as malloced
nothing
Fill buffers with zeros
zero
Fill buffers with random crap
pattern-span
Size of parent buffer for sub-buffered allocation
How to fill the buffer, if at all
Timestamps buffers with number of bytes per second (0 = none)
Sync to the clock to the datarate
Don't produce last_message events
Send a signal before pushing the buffer
Dump buffer contents to stdout
True if the element cannot produce data in PAUSED
fakesrc: dunno how to allocate buffers !
get      ******* > (%5d bytes, timestamp: %s, duration: %s, offset: %li, offset_end: %li, flags: %d) %p
event   ******* E (type: %d, %s) %p
!GST_OBJECT_FLAG_IS_SET (object, GST_BASE_SRC_STARTED)
Erik Walthinsen <omega@cse.ogi.edu>, Wim Taymans <wim@fluendo.com>
Push empty (no data) buffers around
Fixed size buffers (sizemax sized)
Random sized buffers (sizemin <= size <= sizemax)
Fill buffers with pattern 0x00 -> 0xff
Fill buffers with pattern 0x00 -> 0xff that spans buffers
gst_fake_src_create
gst_fake_src_create_buffer
gst_fake_src_get_property
gst_fake_src_set_property
GstFakeSink
fakesink element
gst_fake_sink_set_property
gst_fake_sink_get_property
GstFakeSinkStateError
Generate a state change error
State Error
state_error
Last Message
num-buffers
preroll-handoff
gst_fake_sink_change_state
gst_fake_sink_event
gst_fake_sink_preroll
gst_fake_sink_render
gstfakesink.c
preroll   ******* 
gstfakesink.c:315
gstfakesink.c:274
Black hole for data
Fake Sink
No state change errors
null-to-ready
ready-to-paused
paused-to-playing
playing-to-paused
paused-to-ready
ready-to-null
The message describing current status
Send a signal before unreffing the buffer
Number of buffers to accept going EOS
chain   ******* < (%5d bytes, timestamp: %s, duration: %s, offset: %li, offset_end: %li, flags: %d) %p
Erroring out on state change as requested
Erik Walthinsen <omega@cse.ogi.edu>, Wim Taymans <wim@fluendo.com>, Mr. 'frag-me-more' Vanderwingo <wingo@fluendo.com>
Fail state change from NULL to READY
Fail state change from READY to PAUSED
Fail state change from PAUSED to PLAYING
Fail state change from PLAYING to PAUSED
Fail state change from PAUSED to READY
Fail state change from READY to NULL
gst_fake_sink_render
gst_fake_sink_preroll
gst_fake_sink_change_state
GstFdSrc
fdsrc element
fd://0
gstfdsrc.c
lseek returned %li
Updating to fd %d
fd://%d
marking fd %d as seekable
marking fd %d as NOT seekable
gst_fd_src_start
gst_fd_src_stop
gst_fd_src_unlock
gst_fd_src_unlock_stop
gst_fd_src_is_seekable
gst_fd_src_get_size
gst_fd_src_do_seek
gst_fd_src_create
read %li
Read buffer of size %li
Error during select
Select stopped
Read 0 bytes. EOS.
read on file descriptor: %s.
Error reading from fd
No longer flushing
Flushing
system error: %s
gstfdsrc.c:323
gstfdsrc.c:307
Read from a file descriptor
Source/File
Filedescriptor Source
An open file descriptor to read from
select on file descriptor: %s.
state ready or lower, updating to use new fd
state above ready, not updating to new fd yet
Erik Walthinsen <omega@cse.ogi.edu>
gst_fd_src_update_fd
gst_fd_src_create
gst_fd_src_do_seek
gst_fd_src_unlock_stop
gst_fd_src_unlock
gst_fd_src_start
gst_fd_src_set_property
GstFdSink
fdsink element
gstfdsink.c
gst_fd_sink_render
gst_fd_sink_start
gst_fd_sink_stop
gst_fd_sink_unlock
gst_fd_sink_unlock_stop
wrote %d bytes, %d left
fdsink->fd >= 0
GST_IS_FD_SINK (object)
Sink/File
Filedescriptor Sink
gst_fd_sink_query
File descriptor "%d" is seekable
File descriptor "%d" is not valid.
File descriptor "%d" is a pipe
An open file descriptor to write to
going into select, have %d bytes to write
writing %d bytes to file descriptor %d
Error while writing to file descriptor "%d".
Write data to a file descriptor
gst_fd_sink_check_fd
gst_fd_sink_unlock_stop
gst_fd_sink_unlock
gst_fd_sink_start
gst_fd_sink_render
gst_fd_sink_get_property
gst_fd_sink_set_property
GstFileSink
filesink element
file://localhost/
file://
Location of the file to write
File Location
location
GstFileSinkBufferMode
The buffering mode to use
Buffering mode
buffer-mode
Buffering size
buffer-size
gst_file_sink_start
gst_file_sink_stop
gst_file_sink_render
gst_file_sink_event
gstfilesink.c
Flush failed: %s
Seeking failed: %s
writing %u bytes at %lu
closed file
Error closing file "%s".
warning: setvbuf failed: %s
opened file %s, seekable %d
gstfilesink.c:285
gstfilesink.c:263
Thomas <thomas@apestaart.org>
Write stream to a file
File Sink
gst_file_sink_query
Default buffering
default
Fully buffered
Line buffered
line
Unbuffered
unbuffered
Changing the `location' property on filesink when a file is open not supported.
Size of buffer in number of bytes for line or full buffer-mode
Seeking to offset %lu using fseeko
Ignored NEWSEGMENT, no seek needed
Ignored NEWSEGMENT event of format %u (%s)
Error while seeking in file "%s".
Error while writing to file "%s".
change buffer size %d to %d, mode %d
No file name specified for writing.
Could not open file "%s" for writing.
gst_file_sink_event
gst_file_sink_do_seek
gst_file_sink_render
gst_file_sink_close_file
gst_file_sink_open_file
GstFileSrc
filesrc element
gstfilesrc.c
File-descriptor
Location of the file to read
mmap() Block Size
mmapsize
Touch mapped region read data
touch
Use mmap to read data
use-mmap
sequential
gst_file_src_finalize
gst_file_src_start
gst_file_src_stop
gst_file_src_is_seekable
gst_file_src_get_size
gst_file_src_create
GstMmapBuffer
warning: madvise failed: %s
offset >= 0
warning: munmap failed: %s
Reading %d bytes
unexpected end of file.
non-regular file hits EOS
opening file %s
using mmap for file
No such file "%s"
Could not get info on "%s".
"%s" is a directory.
File "%s" is a socket.
gstfilesrc.c:404
GST_IS_FILE_SRC (object)
gstfilesrc.c:369
File Source
setting location in wrong state
File-descriptor for the file being mmap()d
Size in bytes of mmap()d regions
Touch mmapped data regions to force them to be read from disk
Whether to use mmap() instead of read()
Whether to use madvise to hint to the kernel that access to mmap pages will be sequential
Optimise for sequential mmap access
mapping region %08llx+%08lx from file into memory
mapped region %08lx+%08lx from file into memory at %p
mmap (0x%08lx, %d, 0x%lx) failed: %s
attempting to map a small buffer at %lu+%d
not on page boundaries, resizing to map to %lu+%d
freeing mmap()d buffer at %lu+%u
unmapped region %08lx+%08lx at %p
attempting to read %08lx, %08lx, %08lx, %08lx
read buf %lu+%u lives in current mapbuf %u+%u, creating subbuffer of mapbuf
read buf %lu+%u starts in mapbuf %u+%u but ends outside, creating new mmap
read buf %lu+%d starts before mapbuf %d+%d, but overlaps it
searching for mapbuf to cover %lu+%d
read buf %lu+%d crosses a %d-byte boundary, creating a one-off
read buf %lu+%d in new mapbuf at %lu+%d, mapping and subbuffering
readsize smaller then mapsize %08x %d
disabling seeking, not in mmap mode and lseek failed: %s
No file name specified for reading.
Could not open file "%s" for reading.
invalid mapsize, must be a multiple of pagesize, which is %d
Read from arbitrary point in a file
gst_file_src_set_location
gst_file_src_create_mmap
gst_file_src_map_small_region
gst_file_src_map_region
gst_mmap_buffer_finalize
gst_file_src_create_read
gst_file_src_start
gst_file_src_get_property
gst_file_src_set_property
GstIdentity
identity element
gst_identity_set_property
gst_identity_get_property
Sleep time
sleep-time
Error after N buffers
Error After
error_after
Drop Probability
drop_probability
Single Segment
single-segment
Synchronize to pipeline clock
Synchronize
Check For Perfect Stream
check-perfect
check-imperfect-timestamp
check-imperfect-offset
gst_identity_finalize
gst_identity_event
gst_identity_transform_ip
gst_identity_start
gst_identity_stop
gstidentity.c
prev-duration
prev-timestamp
cur-offset-end
cur-offset
cur-duration
cur-timestamp
prev-offset-end
prev-offset
(NULL)
n_param_values == 2
gstidentity.c:720
gstidentity.c:664
Microseconds to sleep between processing
The Probability a buffer is dropped
(Re)timestamps buffers with number of bytes per second (0 = inactive)
Timestamp buffers and eat newsegments so as to appear as one segment
Verify that the stream is time- and data-contiguous. This only logs in the debug log.  This will be deprecated in favor of the check-imperfect-timestamp/offset properties.
Send element messages if timestamps and durations do not match up
Check for discontiguous timestamps
Send element messages if offset and offset_end do not match up
Check for discontiguous offset
Buffer not time-contiguous with previous one: prev ts %u:%02u:%02u.%09u, prev dur %u:%02u:%02u.%09u, new ts %u:%02u:%02u.%09u (expected ts %u:%02u:%02u.%09u, delta=%c%u:%02u:%02u.%09u)
Buffer not data-contiguous with previous one: prev offset_end %li, new offset %li
can't check time-contiguity, no timestamp and/or duration were set on previous buffer
can't check data-contiguity, no offset_end was set on previous buffer
can't check offset contiguity, no offset and/or offset_end were set on previous buffer
Failed after iterations as requested.
dropping   ******* (%s:%s)i (%d bytes, timestamp: %u:%02u:%02u.%09u, duration: %u:%02u:%02u.%09u, offset: %li, offset_end: % li, flags: %d) %p
chain   ******* (%s:%s)i (%d bytes, timestamp: %u:%02u:%02u.%09u, duration: %u:%02u:%02u.%09u, offset: %li, offset_end: % li, flags: %d) %p
event   ******* (%s:%s) E (type: %d, %s) %p
Pass data without modification
gst_identity_transform_ip
gst_identity_check_perfect
gst_identity_check_imperfect_timestamp
gst_identity_check_imperfect_offset
marshal_VOID__MINIOBJECT
?GstQueue
queue_dataflow
gst_queue_set_property
gst_queue_get_property
underrun
running
overrun
pushing
Current level (kB)
current-level-bytes
Current level (buffers)
current-level-buffers
Current level (ns)
current-level-time
Max. size (kB)
max-size-bytes
Max. size (buffers)
max-size-buffers
Max. size (ns)
max-size-time
Min. threshold (kB)
min-threshold-bytes
Min. threshold (buffers)
min-threshold-buffers
Min. threshold (ns)
min-threshold-time
GstQueueLeaky
leaky
gst_queue_finalize
gst_queue_change_state
gstqueue.c
finalizing queue
gstqueue.c:1430
gstqueue.c:1383
Simple data queue
gst_queue_chain
gst_queue_sink_activate_push
gst_queue_handle_sink_event
gst_queue_link_sink
gst_queue_getcaps
gst_queue_bufferalloc
gst_queue_src_activate_push
gst_queue_link_src
gst_queue_handle_src_event
gst_queue_handle_src_query
got event %p (%d)
queue linking source pad
not starting task reason %s
configured NEWSEGMENT %Q
retrieved event %p from queue
the queue is empty
queue is not empty
dropping UNEXPECTED buffer %p
dropping UNEXPECTED event %p
exit because we are flushing
pause task, reason:  %s
got EOS from upstream
loop stopped
refusing event, we are EOS
queue is not full
exit because we received EOS
leak != NULL
Not Leaky
downstream
dataflow inside the queue element
Current amount of data in the queue (bytes)
Current number of buffers in the queue
Current amount of data in the queue (in ns)
Max. amount of data in the queue (bytes, 0=disable)
Max. number of buffers in the queue (0=disable)
Max. amount of data in the queue (in ns, 0=disable)
Min. amount of data in the queue to allow reading (bytes, 0=disable)
Min. number of buffers in the queue to allow reading (0=disable)
Min. amount of data in the queue to allow reading (in ns, 0=disable)
Where the queue leaks, if at all
(%s:%s) signal DEL: %u of %u-%u buffers, %u of %u-%u bytes, %lu of %lu-%lu ns, %u items
(%s:%s) signal ADD: %u of %u-%u buffers, %u of %u-%u bytes, %lu of %lu-%lu ns, %u items
initialized queue's not_empty & not_full conditions
dropping query in %s format, don't know how to adjust value
starting task as pad is linked
sink %u:%02u:%02u.%09u, src %u:%02u:%02u.%09u
last_stop updated to %u:%02u:%02u.%09u
retrieved buffer %p from queue
Unexpected item %p dequeued from queue %s (refcounting problem?)
(%s:%s) wait for ADD: %u of %u-%u buffers, %u of %u-%u bytes, %lu of %lu-%lu ns, %u items
(%s:%s) received ADD wakeup: %u of %u-%u buffers, %u of %u-%u bytes, %lu of %lu-%lu ns, %u items
(%s:%s) received ADD: %u of %u-%u buffers, %u of %u-%u bytes, %lu of %lu-%lu ns, %u items
Could not mark buffer as DISCONT
got UNEXPECTED from downstream
pushing pushable event %s after UNEXPECTED
pushed EOS event %p, return UNEXPECTED
exit because we have no item in the queue
not starting task as pad is not linked
Unexpected item %p added in queue %s (refcounting problem?)
(%s:%s) received flush start event: %u of %u-%u buffers, %u of %u-%u bytes, %lu of %lu-%lu ns, %u items
(%s:%s) received flush stop event: %u of %u-%u buffers, %u of %u-%u bytes, %lu of %lu-%lu ns, %u items
not re-starting task as pad is not linked
(%s:%s) after flush: %u of %u-%u buffers, %u of %u-%u bytes, %lu of %lu-%lu ns, %u items
refusing event, we are flushing
received buffer %p of size %d, time %u:%02u:%02u.%09u, duration %u:%02u:%02u.%09u
queue is full, leaking buffer on upstream end
queue is full, leaking item %p on downstream end
Unknown leaky type, using default
queue is full, waiting for free space
(%s:%s) wait for DEL: %u of %u-%u buffers, %u of %u-%u bytes, %lu of %lu-%lu ns, %u items
(%s:%s) received DEL wakeup: %u of %u-%u buffers, %u of %u-%u bytes, %lu of %lu-%lu ns, %u items
(%s:%s) received DEL: %u of %u-%u buffers, %u of %u-%u bytes, %lu of %lu-%lu ns, %u items
exit because task paused, reason: %s
exit because we received UNEXPECTED
Leaky on upstream (new buffers)
Leaky on downstream (old buffers)
gst_queue_finalize
gst_queue_set_property
gst_queue_init
gst_queue_handle_src_query
gst_queue_handle_src_event
gst_queue_link_src
gst_queue_loop
gst_queue_push_one
gst_queue_locked_dequeue
apply_buffer
update_time_level
apply_segment
gst_queue_src_activate_push
gst_queue_handle_sink_event
gst_queue_locked_flush
gst_queue_locked_enqueue
gst_queue_chain
GstTee
tee element
gst_tee_finalize
gst_tee_set_property
gst_tee_get_property
The number of source pads
Num Src Pads
num-src-pads
Has Sink Loop
has-sink-loop
Has Chain
has-chain
GstTeePullMode
Behavior of tee in pull mode
Pull mode
pull-mode
gst_tee_request_new_pad
gst_tee_release_pad
gsttee.c
releasing pad
requesting pad
src%d
gst_pad_proxy_setcaps
gst_pad_proxy_getcaps
gst_tee_src_activate_pull
gst_tee_src_check_get_range
gst_tee_src_get_range
data != NULL
Starting to push buffer %p
pad already pushed with %s
Replacing ret val %d with %d
pad list changed
received error %s
received buffer %p
handled buffer %s
gsttee.c:366
gsttee.c:333
1-to-N pipe fitting
Tee pipe fitting
tee-push-data
gst_tee_buffer_alloc
gst_tee_sink_activate_push
gst_tee_chain
using pad %s:%s for alloc
finding pad for alloc
try alloc on pad %s:%s
got return value %d
pad list changed, restart
we have a buffer on pad %s:%s
Never activate in pull mode
never
single
If the element should spawn a thread (unimplemented and deprecated)
If the element can operate in push mode
Tee cannot operate in push mode with has-chain==FALSE
warning failed to activate request pad
chain        ******* (%s:%s)t (%d bytes, %lu) %p
Pushing buffer %p yielded result %s
Cannot activate in pull mode, pull-mode set to NEVER
Cannot activate multiple src pads in pull mode, pull-mode set to SINGLE
Failed to %sactivate sink pad in pull mode
tee will never implement has-sink-loop==TRUE
Only one src pad can be active in pull mode
gst_tee_release_pad
gst_tee_request_new_pad
gst_tee_handle_buffer
clear_pads
gst_tee_src_check_get_range
gst_tee_src_activate_pull
gst_tee_chain
gst_tee_sink_activate_push
gst_tee_buffer_alloc
gst_tee_find_buffer_alloc
GstTypeFindElement
type finding element
gst_type_find_element_dispose
minimum
maximum
have_type
gsttypefindelement.c
found caps %P
gsttypefindelement.c:316
gsttypefindelement.c:293
TypeFind
gst_type_find_element_setcaps
gst_type_find_element_chain
sending cached %s event
 and pushing cached buffers
stopping typefinding%s
got %s event in mode %d
Got EOS and no type found yet
Stream contains no data.
Can't typefind empty stream
Saving %s event to send later
Pushing store: %d
starting typefinding
gst_type_find_element_set_property
gst_type_find_element_get_property
detected capabilities in stream
minimum probability required to accept caps
probability to stop typefinding (deprecated; non-functional)
gst_type_find_element_change_state
Benjamin Otte <in7y118@public.uni-hamburg.de>
Finds the media type of a stream
gst_type_find_element_activate
gst_type_find_element_handle_event
gst_type_find_element_activate_src_pull
gst_type_find_element_checkgetrange
gst_type_find_element_getrange
gst_type_find_element_src_event
gst_type_find_handle_src_query
upstream only supports push mode, while downstream element only works in pull mode, erroring out
%s cannot work in push mode. The operation is not supported with this source element or protocol.
Downstream pad %s:%s has no chainfunction, and the upstream element does not support pull mode
not enough data for typefinding yet (%u bytes)
no caps found with %u bytes of data, waiting for more data
found caps %P, but probability is %u which is lower than the required minimum of %u
waiting for more data to try again
Skipping typefinding, using caps from upstream buffer: %P
Could not query upstream length!
gst_type_find_element_have_type
gst_type_find_element_handle_event
stop_typefinding
gst_type_find_element_send_cached_events
gst_type_find_element_chain
gst_type_find_element_chain_do_typefinding
gst_type_find_element_setcaps
gst_type_find_element_activate
start_typefinding
GstMultiQueue
multiqueue element
gst_multi_queue_set_property
gst_multi_queue_get_property
Extra Size (kB)
extra-size-bytes
Extra Size (buffers)
extra-size-buffers
Extra Size (ns)
extra-size-time
gst_multi_queue_finalize
gst_multi_queue_release_pad
gstmultiqueue.c
Waking up singlequeue %d
name : %s
Creating GstSingleQueue id:%d
sink%d
gst_multi_queue_chain
gst_multi_queue_sink_event
gst_multi_queue_getcaps
gst_multi_queue_bufferalloc
gst_multi_queue_src_event
gst_multi_queue_src_query
Returning pad %s:%s
flush %s queue %d
SingleQueue %d : pausing task
SingleQueue %d
CHECKING sq->srcresult: %s
no parent
GST_IS_PAD (pad)
Single Queue %d is full
Checking Queue %d
Queue %d is empty
Queue %d is filled
gstmultiqueue.c:434
gstmultiqueue.c:401
Multiple data queue
Amount of data the queues can grow if one of them is empty (bytes, 0=disable)
Amount of buffers the queues can grow if one of them is empty (0=disable)
Amount of time the queues can grow if one of them is empty (in ns, 0=disable)
gst_multi_queue_request_new_pad
queue %d: visible %u/%u, bytes %u/%u, time %lu/%lu
That pad doesn't belong to this element ???
gst_multi_queue_sink_activate_push
gst_multi_queue_get_internal_links
gst_multi_queue_src_activate_push
GstSingleQueue [%d] created and pads added
Couldn't send query because we have no peer
SingleQueue %d : waking up eventually waiting task
SingleQueue %d : starting task
inspecting sq:%d , nextid:%d, oldid:%d, srcresult:%s
sq:%d is not waiting - ignoring
Highid is now : %u, lowest non-linked %u
queue %d, sink %u:%02u:%02u.%09u, src %u:%02u:%02u.%09u
queue %d, last_stop updated to %u:%02u:%02u.%09u
queue %d, configured NEWSEGMENT %Q
SingleQueue %d : trying to pop an object
SingleQueue %d : newid:%d , oldid:%d
queue %d sleeping for not-linked wakeup with newid %u and highid %u
queue %d woken from sleeping for not-linked wakeup with newid %u and highid %u
BEFORE PUSHING sq->srcresult: %s
SingleQueue %d : Pushing buffer %p with ts %u:%02u:%02u.%09u
SingleQueue %d : Pushing event %p of type %s
Unexpected object in singlequeue %d (refcounting problem?)
AFTER PUSHING sq->srcresult: %s
SingleQueue[%d] task paused, reason:%s
Getting caps from the peer of this pad
SingleQueue %d : received flush start event
SingleQueue %d : received flush stop event
SingleQueue %d : Enqueuing event %p of type %s with id %d
SingleQueue %d : exit because task paused, reason: %s
SingleQueue %d : about to enqueue buffer %p with id %d
Single Queue %d is empty, Checking other single queues
queue %d is filled, bumping its max visible to %d
All queues are empty, signalling it
Another queue is empty, bumping single queue %d max visible to %d
A queue is filled, signalling overrun
Edward Hervey <edward@fluendo.com>
gst_multi_queue_release_pad
gst_multi_queue_request_new_pad
gst_single_queue_new
gst_multi_queue_src_query
gst_multi_queue_src_activate_push
gst_single_queue_flush
gst_multi_queue_loop
gst_single_queue_push_one
apply_buffer
update_time_level
apply_segment
compute_high_id
wake_up_next_non_linked
gst_multi_queue_get_internal_links
gst_multi_queue_getcaps
gst_multi_queue_sink_event
gst_multi_queue_chain
single_queue_underrun_cb
single_queue_overrun_cb
single_queue_check_full
libgstcoreelements.so.debug
.shstrtab
.note.gnu.build-id
.gnu.hash
.dynsym
.dynstr
.gnu.version
.gnu.version_r
.rela.dyn
.rela.plt
.init
.text
.fini
.rodata
.eh_frame_hdr
.eh_frame
.ctors
.dtors
.jcr
.data.rel.ro
.dynamic
.got
.got.plt
.data
.bss
.gnu_debuglink
