@@B 
&)$	55B
S'-V1l
"UD2
j%EJ
xuoj
Bu?zY8C
rNt,
np/L
bA%G
ja{0
]/j(qq'
8H6o
__gmon_start__
_fini
_ITM_deregisterTMCloneTable
_ITM_registerTMCloneTable
__cxa_finalize
_Jv_RegisterClasses
arch_query_cpu_definitions
error_set
qemu_clock_warp
cpu_get_clock
gettimeofday
cpu_get_icount
abort
use_icount
monitor_fdset_dup_fd_add
monitor_fdset_dup_fd_find
monitor_fdset_get_fd
monitor_fdset_dup_fd_remove
monitor_get_fd
qemu_get_vm_name
qemu_mutex_lock_iothread
qemu_mutex_unlock_iothread
migrate_add_blocker
migrate_del_blocker
monitor_cur_is_qmp
monitor_printf
monitor_vprintf
monitor_print_filename
monitor_protocol_event
monitor_set_error
cur_mon
qemu_register_reset
qemu_unregister_reset
qemu_set_fd_handler2
slirp_update_timeout
slirp_select_fill
slirp_select_poll
sysbus_get_default
vm_stop
vmstate_register_with_alias_id
vmstate_unregister
g_free
vcard_emul_delete_key
vcard_make_response
vcard_get_current_applet_private
vcard_response_new_bytes
realloc
memcpy
vcard_emul_rsa_op
vcard_response_new
__assert_fail
cac_card_init
vcard_set_type
g_malloc
vcard_new_applet
vcard_set_applet_private
vcard_add_applet
vevent_new
vreader_reference
vcard_reference
vevent_delete
vreader_free
vcard_free
vevent_queue_init
qemu_mutex_init
qemu_cond_init
vevent_queue_vevent
qemu_mutex_lock
qemu_cond_signal
qemu_mutex_unlock
vevent_wait_next_vevent
qemu_cond_wait
vevent_get_next_vevent
vcard_buffer_response_new
vcard_buffer_response_delete
vcard_reset
vcard_emul_reset
vcard_delete_applet
vcard_new
vcard_get_atr
vcard_emul_get_atr
vcard_set_atr_func
vcard_find_applet
memcmp
vcard_applet_get_aid
vcard_select_applet
vcard_process_applet_apdu
vcard_get_buffer_response
vcard_set_buffer_response
vcard_get_type
vcard_get_private
vreader_new
g_strdup
vreader_card_is_present
vreader_get_id
vreader_set_id
vreader_get_name
vreader_get_private
vreader_power_on
vreader_power_off
vreader_xfr_bytes
vcard_apdu_new
vcard_process_apdu
vcard_response_delete
vcard_apdu_delete
vreader_list_get_first
vreader_list_get_next
vreader_list_delete
vreader_list_get_reader
vreader_get_reader_list
vreader_get_reader_by_id
vreader_get_reader_by_name
strcmp
vreader_add_reader
vreader_remove_reader
vreader_queue_card_event
vreader_insert_card
vreader_init
PK11_FreeSlot
PK11_ReferenceSlot
CERT_DupCertificate
PK11_FindKeyByDERCert
vcard_emul_type_select
vcard_init
PK11_FindGenericObjects
PK11_GetNextGenericObject
PK11_ReadRawAttribute
CERT_GetDefaultCertDB
CERT_NewTempCertificate
SECITEM_FreeItem
CERT_DestroyCertificate
PORT_Strdup
SECMOD_WaitForAnyTokenEvent
PK11_IsPresent
PORT_GetError
PK11_GetSlotSeries
PK11_GetSlotName
__ctype_b_loc
SECKEY_DestroyPrivateKey
PK11_SignatureLen
PK11_DoesMechanism
memset
PK11_FindPrivateKeyFromCert
PK11_PubDecryptRaw
PK11_Sign
vcard_emul_get_login_count
vcard_emul_login
PK11_Authenticate
PK11_Logout
vcard_emul_force_card_remove
vcard_emul_force_card_insert
vcard_emul_init
NSS_Init
PK11_SetPasswordFunc
PK11_FindSlotByName
PK11_FindCertFromNickname
SECMOD_GetDefaultModuleListLock
SECMOD_GetDefaultModuleList
SECMOD_GetReadLock
PK11_IsRemovable
PK11_IsHW
SECMOD_ReleaseReadLock
SECMOD_GetInternalModule
stderr
fwrite
PR_CreateThread
SECMOD_LoadUserModule
SECMOD_DestroyModule
PORT_SetError
vcard_emul_replay_insertion_events
vcard_emul_options
vcard_emul_type_from_string
g_strndup
pstrcpy
vcard_emul_usage
strcasecmp
vcard_response_new_data
vcard_response_new_status_bytes
socket_set_cork
setsockopt
qemu_madvise
__errno_location
qemu_open
strstart
qemu_parse_fd
fcntl
ftruncate64
qemu_close
qemu_write_full
qemu_socket
qemu_set_cloexec
qemu_accept
accept4
qemu_send_full
send
qemu_recv_full
recv
qemu_set_version
qemu_get_version
fips_set_state
fopen64
fgetc
fclose
fips_get_state
__ctype_toupper_loc
pstrcat
strlen
stristart
qemu_strnlen
strpadcpy
mktimegm
qemu_fls
qemu_fdatasync
buffer_is_zero
fcntl_setfl
strtosz_suffix_unit
strtod
__isnan
modf
strtosz_suffix
strtosz
parse_uint
strtoull
parse_uint_full
strtol
pow2floor
uleb128_encode_small
g_assertion_message_expr
uleb128_decode_small
use_rt_clock
clock_gettime
g_malloc0
g_strdup_vprintf
error_set_errno
strerror
g_strdup_printf
error_copy
error_is_set
error_get_class
error_get_pretty
error_free
error_propagate
qemu_get_thread_id
syscall
qemu_daemon
qemu_oom_check
__fprintf_chk
qemu_memalign
posix_memalign
qemu_vmalloc
getpagesize
qemu_vfree
qemu_set_block
qemu_set_nonblock
qemu_pipe
pipe2
qemu_utimens
utimensat
utimes
__xstat64
pthread_mutexattr_init
pthread_mutexattr_settype
pthread_mutex_init
pthread_mutexattr_destroy
qemu_mutex_destroy
pthread_mutex_destroy
pthread_mutex_lock
qemu_mutex_trylock
pthread_mutex_trylock
pthread_mutex_unlock
pthread_cond_init
qemu_cond_destroy
pthread_cond_destroy
pthread_cond_signal
qemu_cond_broadcast
pthread_cond_broadcast
pthread_cond_wait
qemu_sem_init
qemu_sem_destroy
qemu_sem_post
qemu_sem_timedwait
sem_trywait
qemu_sem_wait
qemu_thread_create
pthread_attr_init
sigfillset
pthread_sigmask
pthread_create
pthread_attr_destroy
pthread_attr_setdetachstate
qemu_thread_get_self
pthread_self
qemu_thread_is_self
qemu_thread_exit
pthread_exit
qemu_thread_join
pthread_join
trace_print_events
trace_event_set_state
trace_backend_init
trace_backend_init_events
fgets
librt.so.1
libiscsi.so.1
libz.so.1
libgfapi.so.0
libgfrpc.so.0
libgfxdr.so.0
librbd.so.1
librados.so.2
libcurl.so.4
libuuid.so.1
libaio.so.1
libssl3.so
libsmime3.so
libnss3.so
libnssutil3.so
libplds4.so
libplc4.so
libnspr4.so
libpthread.so.0
libdl.so.2
libgthread-2.0.so.0
libglib-2.0.so.0
libc.so.6
__stack_chk_fail
_edata
__bss_start
_end
libcacard.so.0
GLIBC_2.2
NSS_3.9.3
NSS_3.4
NSS_3.5
NSS_3.3
NSS_3.12
NSS_3.9.2
NSS_3.2
GLIBC_2.1
GLIBC_2.3.2
GLIBC_2.0
GLIBC_2.1.3
GLIBC_2.4
GLIBC_2.10
GLIBC_2.6
GLIBC_2.3
GLIBC_2.3.4
GLIBC_2.9
L$,1
d$$[^
d$([
d$ [^_
d$([
t$0e
d$$[^
VtqvO
d$,[^_]
UWVS
l$`e
D$<1
v;<R
|$<e3=
d$L[^_]
L$,9
D$<e3
L$,t]
t$8e
d$$[^
t$8e
d$$[^
d$$[^
UWVS
L$L1
D$Iy
;|$8
|$Le3=
d$\[^_]
UWVS
|$He
[^_]
t$0e
d$$[^
d$([
t$0e
d$ [^_
UWVS
d$,[^_]
d$ [^_
UWVS
[^_]
t$0e
d$$[^
UWV1
l$De
d$,[^_]
UWVS
l$Xe
D$,1
T$,e3
[^_]
t$0e
d$$[^
l$4e
d$ ^_]
t$4e
d$ [^_
D$ e
|$0e
d$ [^_
L$4e
d$$[^
T$$e
UWVS
d$,[^_]
T$$e
L$0e
d$$[^
L$0e
d$$^_
UWVS
|$He
[^_]
t$0e
d$ [^_
t$0e
d$ [^_
d$([
T$ e
T$$e
D$ e
UWVS
d$,[^_]
d$$[^
UWVS
l$Xe
D$,1
L$,e3
d$<[^_]
D$ e
D$ e
UWVS
d$,[^_]
D$0e
d$([
UWVS
d$,[^_]
UWVS
|$@e
d$,[^_]
UWVS
d$,[^_]
UWVS
|$@e
d$,[^_]
UWVS
t$@e
to9p
d$,[^_]
T$0e
d$([
UWVS
d$,[^_]
d$([
D$0e
d$([
t$0e
d$$[^
[^_]
T$0e
D$L1
T$,tV
|$Le3=
d$\[^_]
UWVS
D$,e
L$<1
L$<e3
d$L[^_]
l$@e
[^_]
D$8e
d$([
UWVS
D$,1
D$,e3
d$<[^_]
d$$[^
d$$[^
d$,[^_]
d$$[^
UWVS
[^_]
D$09
T$$u
+|$0
|$$9
;L$0
L$,u
;L$<
tR~/=1
UWVS
d$,[^_]
f%{&f
d$([
D$4e
d$ [^_
d$$[^
d$ [^_
UWVS
D$ e
D$\1
L$\e3
d$l[^_]
L$<9H
D$(t
d$ [^_
UWVS
[^_]
+D$$
tw<,u
d$([
UWVS
L$pe
D$<1
T$<e3
d$L[^_]
d$([
UWVS
[^_]
|$0e
d$ [^_
t$@e
d$,[^_]
D$0e
;L$<
d$ [^_
d$ [^_
UWVS
D$@e
;L$L
d$,[^_]
d$,[^_]
t$0e
t3r!
d$$[^
UWVS
l$De
L$@f
d$,[^_]
vz<@t
t$0e
d$$[^
t$0e
d$$[^
UWVS
t$Pe
D$,1
T$,e3
d$<[^_]
tsr1
D$,1
T$,e3
d$8[
T$0e
L$4t)
d$$[^
UWVS
l$De
d$,[^_]
4$t6
d$ [^_
l$He
d$,[^_]
UWVS
t$@e
d$,[^_]
UWVS
D$,1
L$,e3
d$<[^_]
l$Xe
D$,1
T$,e3
d$<[^_]
l$Xe
D$,1
T$,e3
d$<[^_]
d$$[^
[^_]
D$ e
T$(~.
UWVS
|$He
d$,[^_]
UWVS
|$@e
d$,[^_]
L$ e
UWVS
|$Pe
T$,1
D$,e3
d$<[^_]
L$ e
gfff
T$ e
d$([
D$0e
d$ [^_
|$4e
d$ [^_
UWVS
D$\1
t$L9
|$\e3=
d$l[^_]
D$,1
L$,e3
d$8[
d$([
UWVS
T$\e
D$,1
D$(9
|$,e3=
d$<[^_]
d$$[^
d$$[^
T$@e
L$,1
T$,e3
d$8[
L$$e
UWVS
l$Te
D$,1
T$Xt3
D$,e3
d$<[^_]
UWVS
T$Te
D$,1
L$\tC
D$,e3
d$<[^_]
D$ e
t$0e
d$$[^
T$4e
d$([
d$([
d$([
D$0e
d$([
t$De
D$,1
T$,e3
d$0[^_
t$0e
d$$[^
D$0e
d$([
d$$[^
d$$[^
d$$[^
d$ [^_
UWVS
[^_]
|$0e
d$ [^_
d$([f
d$([f
d$([
d$([f
d$([
d$([f
d$([f
d$([f
d$([
d$([f
d$([f
d$([f
t$@e
D$,1
iL$(
T$$)
|$ ~s
L$,e3
d$0[^_
t$0e
d$$[^
UWVS
[^_]
t$ e
t$ e
d$([
d$ [^_
d$([
d$([
UWVS
D$,<#t
<-tq
[^_]
Not supported
only QEMU supports file descriptor passing
libcacard/cac.c
applet_private
pki_applet->cert != ((void *)0)
cac_applet_pki_process_apdu
cac_applet_pki_reset
libcacard/event.c
vevent_queue_tail
vevent_queue_vevent
libcacard/vcard.c
channel < 4
vcard_select_applet
libcacard/vreader.c
card_status == VCARD_DONE
vreader_xfr_bytes
libcacard/vcard_emul_nss.c
buffer_size == signature_len
buffer_size == signature.len
pad_len < 4
atr != ((void *)0)
sql:/etc/pki/nssdb
E-Gate 0 0
soft=
use_hw=
hw_type=
hw_params=
library=libcoolkeypk11.so name=Coolkey
known bad coolkey version - see https://bugzilla.redhat.com/show_bug.cgi?id=802435
emul args: comma separated list of the following arguments
 db={nss_database}               (default sql:/etc/pki/nssdb)
 use_hw=[yes|no]                 (default yes)
 hw_type={card_type_to_emulate}  (default CAC)
 hw_param={param_for_card}       (default "")
 soft=({slot_name},{vreader_name},{card_type_to_emulate},{params_for_card},
       {cert1},{cert2},{cert3}    (default none)
  {nss_database}          The location of the NSS cert & key database
  {card_type_to_emulate}  What card interface to present to the guest
  {param_for_card}        Card interface specific parameters
  {slot_name}             NSS slot that contains the certs
  {vreader_name}          Virtual reader name to present to the guest
  {certN}                 Nickname of the certificate n on the virtual card
These parameters come as a single string separated by blanks or newlines.
Unless use_hw is set to no, all tokens that look like removable hardware
tokens will be presented to the guest using the emulator specified by
hw_type, and parameters of hw_param.
If more one or more soft= parameters are specified, these readers will be
presented to the guest
vcard_emul_get_atr
vcard_emul_rsa_op
VCARD_NSSCAC
libcacard/card_7816.c
*response != ((void *)0)
!"VCARD_DIRECT: applet failure"
vcard7816_vm_process_apdu
vcard_process_apdu
/dev/fdset/
/proc/sys/crypto/fips_enabled
1.4.2
uleb128_encode_small
strtosz_suffix_unit
buffer_is_zero
util/cutils.c
len % (4 * sizeof(long)) == 0
mul >= 0
n <= 0x3fff
_util/error.c
*errp == ((void *)0)
%s: %s
error_set_errno
error_set
Failed to allocate memory: %s
Failed to allocate %zu B: %s
qemu: %s: %s
qemu_thread_join
qemu_thread_create
qemu_sem_wait
qemu_sem_timedwait
qemu_sem_post
qemu_sem_destroy
qemu_sem_init
qemu_cond_wait
qemu_cond_broadcast
qemu_cond_signal
qemu_cond_destroy
qemu_cond_init
qemu_mutex_unlock
qemu_mutex_lock
qemu_mutex_destroy
qemu_mutex_init
warning: cannot print the trace events with the current backend
error: operation not supported with the current backend
warning: cannot set the state of a trace event with the current backend
error: -trace events=...: option not supported by the selected tracing backend
error: -trace file=...: option not supported by the selected tracing backend
error: closing file '%s': %s
error: could not open trace events file '%s': %s
error: trace event '%s' does not exist
;*2$" 
stapsdt
qemu
qemu_memalign
4@%edi 4@%esi 4@%eax
stapsdt
qemu
qemu_vmalloc
4@%esi 4@%eax
stapsdt
qemu
qemu_vfree
4@%eax
libcacard.so.0.0.0.debug
7zXZ
kdL~V}0
A3"s
S' 4'Q
:etq
fQMz
g^r.
a2XD
`3h6sZ
?Sc!
QRx+2
\S.zt
.shstrtab
.note.gnu.build-id
.gnu.hash
.dynsym
.dynstr
.gnu.version
.gnu.version_r
.rel.dyn
.rel.plt
.init
.text
.fini
.rodata
.stapsdt.base
.eh_frame_hdr
.eh_frame
.init_array
.fini_array
.jcr
.data.rel.ro
.dynamic
.got
.data
.probes
.bss
.note.stapsdt
.gnu_debuglink
.gnu_debugdata
