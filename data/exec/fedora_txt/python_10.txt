__gmon_start__
_ITM_deregisterTMCloneTable
_ITM_registerTMCloneTable
__cxa_finalize
_Jv_RegisterClasses
free
PyArg_ParseTupleAndKeywords
PyEval_SaveThread
plugin_flush
PyEval_RestoreThread
PyMem_Free
_Py_NoneStruct
PyArg_ParseTuple
plugin_log
PyGILState_Ensure
PyString_FromString
PyObject_CallFunction
PyGILState_Release
PyErr_Print
PyErr_Clear
PyTuple_New
PyFloat_FromDouble
PyBool_FromLong
__isnanf
plugin_get_ds
PyList_New
PyExc_TypeError
PyErr_Format
__snprintf_chk
PyObject_GetAttrString
PyUnicodeUCS4_AsEncodedString
PyString_AsString
PyCallable_Check
malloc
__strdup
plugin_register_complex_read
PyErr_SetString
plugin_register_flush
plugin_register_notification
plugin_register_write
plugin_register_log
PyExc_RuntimeError
plugin_unregister_flush
plugin_unregister_notification
plugin_unregister_write
plugin_unregister_read
plugin_unregister_log
strcmp
PyErr_Fetch
PyErr_NormalizeException
PyObject_Str
PyObject_Size
strlen
PyObject_CallFunctionObjArgs
Py_Finalize
Py_IsInitialized
PyEval_InitThreads
sigemptyset
sigaddset
pthread_sigmask
plugin_thread_create
plugin_unregister_shutdown
sigaction
PyEval_AcquireThread
PyImport_ImportModule
stdin
PyRun_InteractiveLoopFlags
PyEval_ReleaseThread
raise
pause
strcasecmp
PyUnicodeUCS4_SetDefaultEncoding
cf_util_get_string
PyList_Insert
Py_Initialize
PyType_Ready
PyLong_Type
PySys_SetArgv
PyList_SetSlice
Py_InitModule4
PyModule_AddObject
PyModule_AddIntConstant
PyModule_AddStringConstant
sstrncpy
PyLong_FromUnsignedLongLong
PyList_SetItem
PyErr_Occurred
PyInt_FromLong
PyLong_FromLongLong
PyDict_New
meta_data_toc
_Py_ZeroStruct
_Py_TrueStruct
meta_data_type
meta_data_get_string
PyDict_SetItemString
meta_data_get_signed_int
meta_data_get_unsigned_int
meta_data_get_double
meta_data_get_boolean
module_register
plugin_register_complex_config
plugin_register_init
plugin_register_shutdown
PyObject_Repr
PyString_Concat
PyString_ConcatAndDel
PyDict_Size
PySequence_Size
plugin_dispatch_notification
hostname_g
cdtime
PyDict_Items
PyList_Size
meta_data_create
PyType_IsSubtype
PyLong_AsUnsignedLongLong
PyFloat_Type
PyFloat_AsDouble
meta_data_add_double
PyLong_AsLongLong
meta_data_add_signed_int
meta_data_add_boolean
PyNumber_Check
PyNumber_Long
meta_data_add_string
meta_data_add_unsigned_int
plugin_get_interval
PyNumber_Float
plugin_write
meta_data_destroy
plugin_dispatch_values
libpython2.7.so.1.0
libdl.so.2
libc.so.6
__stack_chk_fail
python.so
GLIBC_2.1.3
GLIBC_2.4
GLIBC_2.3.4
GLIBC_2.0
D$<1
L$<e3
d$D[^
d$$[^
d$$[^
d$$[^
d$$[^
d$$[^
d$ [^_
[^_]
UWV1
D$<1
T$<e3
d$L[^_]
d$0[^_
T$(tx
T$(t]
d$0[^_
D$df
[^_]
[^_]
[^_]
l$,1
[^_]
|$,1
UWVS
D$$e
D$<1
9|$(tm
D$<e3
d$L[^_]
UWVS
D$(e
D$L1
T$Le3
d$\[^_]
d$ [^_
UWVS
d$,1
[^_]
UWVS
D$l1
T$le3
d$|[^_]
D$L1
L$Le3
d$T[^
d$ [^_
D$l1
T$le3
d$p[^_
D$|1
T$|e3
D$,1
z'u%
L$,e3
d$<[^_]
d$$[^
D$x1
UWVS
D$,1
BW u^
L$,e3
d$<[^_]
UWVS
[^_]
UWVS
D$,1
L$,e3
d$<[^_]
d$$[^
d$$[^
d$$[^
d$$[^
d$ [^_
d$ [^_
UWVS
9l$ 
;|$$
;|$(
d$L[^_]
9l$ 
D$,u
d$L[^_]
T$0t;
T$0t
UWVS
loca
lhos
t$X1
9|$X
[^_]
UWVS
loca
lhos
T$x9
L$ht
t$T1
9|$T
[^_]
|etiet
NONO
gauge
counter
derive
unknown
absolute
Dataset %s not found
python.%s
__module__
python.%p
O|dOet
O|Oet
NamelessException
__name__
shutdown callback
python
init callback
readline
interactive session init
<stdin>
python initialization
path
collectd
LOG_DEBUG
LOG_INFO
LOG_NOTICE
LOG_WARNING
LOG_ERROR
NOTIF_FAILURE
NOTIF_WARNING
NOTIF_OKAY
DS_TYPE_COUNTER
DS_TYPE_GAUGE
DS_TYPE_DERIVE
DS_TYPE_ABSOLUTE
Interactive
Encoding
setting default encoding
LogTraces
traceback
format_exception
ModulePath
Import
importing module
Module
loading module
flush callback
notification callback
write callback
read callback
plugin
timeout
identifier
interval
name
debug
info
notice
warning
error
get_dataset
unregister_log
unregister_init
unregister_config
unregister_read
unregister_write
unregister_notification
unregister_flush
unregister_shutdown
callback needs a be a callable object.
This function needs a string or a callable object as its only parameter.
Unable to unregister %s callback '%s'.
Unhandled python exception in %s: %s: %s
python: Plugin loaded but not configured.
python: Error creating thread for interactive interpreter.
python: Interactive interpreter exited, stopping collectd ...
python plugin: Unable to convert "%s" to a python object.
python plugin: Unable to prepend "%s" to python module path.
python plugin: Error importing module "%s".
python plugin: Ignoring unknown config key "%s".
python plugin: Found a configuration for the "%s" plugin, but the plugin isn't loaded or didn't register a configuration callback.
cpy_write_callback: Unknown value type %d.
value building for write callback
(knN
0O|OOO
argument 1 must be str
<collectd.Config node 
<collectd.Config root node 
parent
values
children
collectd.Config
|etetetetetd
|etetetetetetdi
(type=
,type_instance=
,plugin=
,plugin_instance=
,host=
,time=
|etOetetetetddO
,interval=
,values=
,meta=
type not set
,severity=
,message=
Cannot delete this attribute
building meta data
et|etOetetetetdiO
values must be list or tuple
unknown data type %d for %s
meta must be a dict
type
message
plugin_instance
type_instance
host
time
severity
meta
destination
dispatch
collectd.Unsigned
collectd.Signed
collectd.Notification
collectd.Values
collectd.PluginData
error dispatching notification, read the logs
type %s needs %d values, got %i
error dispatching values, read the logs
;*2$"
register_shutdown(callback[, data][, name]) -> identifier
Register a callback function for collectd shutdown.
'callback' is a callable object that will be called once collectd is
    shutting down.
'data' is an optional object that will be passed back to the callback
    function if it is called.
'name' is an optional identifier for this callback. The default name
    is 'python.<module>'.
    Every callback needs a unique identifier, so if you want to
    register this callback multiple time from the same module you need
    to specify a name here.
'identifier' is the full identifier assigned to this callback.
The callback function will be called with no parameters except for
    data if it was supplied.
register_flush(callback[, data][, name]) -> identifier
Register a callback function for flush messages.
'callback' is a callable object that will be called every time a plugin
    requests a flush for either this or all plugins.
'data' is an optional object that will be passed back to the callback
    function every time it is called.
'name' is an optional identifier for this callback. The default name
    is 'python.<module>'.
    Every callback needs a unique identifier, so if you want to
    register this callback multiple time from the same module you need
    to specify a name here.
'identifier' is the full identifier assigned to this callback.
The callback function will be called with two or three parameters:
timeout: Indicates that only data older than 'timeout' seconds is to
    be flushed.
id: Specifies which values are to be flushed.
data: The optional data parameter passed to the register function.
    If the parameter was omitted it will be omitted here, too.
register_notification(callback[, data][, name]) -> identifier
Register a callback function for notifications.
'callback' is a callable object that will be called every time a notification
    is dispatched.
'data' is an optional object that will be passed back to the callback
    function every time it is called.
'name' is an optional identifier for this callback. The default name
    is 'python.<module>'.
    Every callback needs a unique identifier, so if you want to
    register this callback multiple time from the same module you need
    to specify a name here.
'identifier' is the full identifier assigned to this callback.
The callback function will be called with one or two parameters:
notification: A copy of the notification that was dispatched.
data: The optional data parameter passed to the register function.
    If the parameter was omitted it will be omitted here, too.
register_write(callback[, data][, name]) -> identifier
Register a callback function to receive values dispatched by other plugins.
'callback' is a callable object that will be called every time a value
    is dispatched.
'data' is an optional object that will be passed back to the callback
    function every time it is called.
'name' is an optional identifier for this callback. The default name
    is 'python.<module>'.
    Every callback needs a unique identifier, so if you want to
    register this callback multiple time from the same module you need
    to specify a name here.
'identifier' is the full identifier assigned to this callback.
The callback function will be called with one or two parameters:
values: A Values object which is a copy of the dispatched values.
data: The optional data parameter passed to the register function.
    If the parameter was omitted it will be omitted here, too.
register_read(callback[, interval][, data][, name]) -> identifier
Register a callback function for reading data. It will just be called
in a fixed interval to signal that it's time to dispatch new values.
'callback' is a callable object that will be called every time something
    is logged.
'interval' is the number of seconds between between calls to the callback
    function. Full float precision is supported here.
'data' is an optional object that will be passed back to the callback
    function every time it is called.
'name' is an optional identifier for this callback. The default name
    is 'python.<module>'.
    Every callback needs a unique identifier, so if you want to
    register this callback multiple time from the same module you need
    to specify a name here.
'identifier' is the full identifier assigned to this callback.
The callback function will be called without parameters, except for
data if it was supplied.
register_config(callback[, data][, name]) -> identifier
Register a callback function for config file entries.
'callback' is a callable object that will be called for every config block.
'data' is an optional object that will be passed back to the callback
    function every time it is called.
'name' is an optional identifier for this callback. The default name
    is 'python.<module>'.
    Every callback needs a unique identifier, so if you want to
    register this callback multiple time from the same module you need
    to specify a name here.
'identifier' is the full identifier assigned to this callback.
The callback function will be called with one or two parameters:
config: A Config object.
data: The optional data parameter passed to the register function.
    If the parameter was omitted it will be omitted here, too.
register_init(callback[, data][, name]) -> identifier
Register a callback function that will be executed once after the config.
file has been read, all plugins heve been loaded and the collectd has
forked into the background.
'callback' is a callable object that will be executed.
'data' is an optional object that will be passed back to the callback
    function when it is called.
'name' is an optional identifier for this callback. The default name
    is 'python.<module>'.
    Every callback needs a unique identifier, so if you want to
    register this callback multiple time from the same module you need
    to specify a name here.
'identifier' is the full identifier assigned to this callback.
The callback function will be called without parameters, except for
data if it was supplied.
register_log(callback[, data][, name]) -> identifier
Register a callback function for log messages.
'callback' is a callable object that will be called every time something
    is logged.
'data' is an optional object that will be passed back to the callback
    function every time it is called.
'name' is an optional identifier for this callback. The default name
    is 'python.<module>'.
    Every callback needs a unique identifier, so if you want to
    register this callback multiple time from the same module you need
    to specify a name here.
'identifier' is the full identifier assigned to this callback.
The callback function will be called with two or three parameters:
severity: An integer that should be compared to the LOG_ constants.
message: The text to be logged.
data: The optional data parameter passed to the register function.
    If the parameter was omitted it will be omitted here, too.
Unregisters a callback. This function needs exactly one parameter either
the function to unregister or the callback identifier to unregister.
flush([plugin][, timeout][, identifier]) -> None
Flushes the cache of another plugin.
get_dataset(name) -> definition
Returns the definition of a dataset specified by name.
'name' is a string specifying the dataset to query.
'definition' is a list of 4-tuples. Every tuple represents a 
    data source within the data set and its 4 values are the 
    name, type, min and max value.
    'name' is a string.
    'type' is a string that is equal to either DS_TYPE_COUNTER,
        DS_TYPE_GAUGE, DS_TYPE_DERIVE or DS_TYPE_ABSOLUTE.
    'min' and 'max' are either a float or None.
This function sends a string to all logging plugins.
This is a tuple of child nodes. For most nodes this will be
empty. If this node represents a block instead of a single line of the config
file it will contain all nodes in this block.
This is a tuple (which might be empty) of all value, ie words
following the keyword in any given line in the config file.
Every item in this tuple will be either a string or a float or a bool,
depending on the contents of the configuration file.
This is the keyword of this item, ie the first word of any
given line in the config file. It will always be a string.
This represents the parent of this node. On the root node
of the config tree it will be None.
This represents a piece of collectd's config file.
It is passed to scripts with config callbacks (see "register_config")
and is of little use if created somewhere else.
It has no methods beyond the bare minimum and only exists for its
data members
This is a long by another name. Use it in meta data dicts
to choose the way it is stored in the meta data.
This is a long by another name. Use it in meta data dicts
to choose the way it is stored in the meta data.
The Notification class is a wrapper around the collectd notification.
It can be used to notify other plugins about bad stuff happening. It works
similar to Values but has a severity and a message instead of interval
and time.
Notifications can be dispatched at any time and can be received with register_notification.
Some kind of description what's going on and why this Notification was generated.
The severity of this notification. Assign or compare to
NOTIF_FAILURE, NOTIF_WARNING or NOTIF_OKAY.
A Values object used for dispatching values to collectd and receiving values from write callbacks.
write([destination][, type][, values][, plugin_instance][, type_instance][, plugin][, host][, time][, interval]) -> None.  Dispatch a value list.
Write this instance to a single plugin or all plugins if 'destination' is obmitted.
This will bypass the main collectd process and all filtering and caching.
Other than that it works similar to 'dispatch'. In most cases 'dispatch' should be
used instead of 'write'.
dispatch([type][, values][, plugin_instance][, type_instance][, plugin][, host][, time][, interval]) -> None.  Dispatch a value list.
Dispatch this instance to the collectd process. The object has members
for each of the possible arguments for this method. For a detailed explanation
of these parameters see the member of the same same.
If you do not submit a parameter the value saved in its member will be submitted.
If you do provide a parameter it will be used instead, without altering the member.
These are the meta data for this Value object.
It has to be a dictionary of numbers, strings or bools. All keys must be
strings. int and long objects will be dispatched as signed integers unless
they are between 2**63 and 2**64-1, which will result in a unsigned integer.
You can force one of these storage classes by using the classes
collectd.Signed and collectd.Unsigned. A meta object received by a write
callback will always contain Signed or Unsigned objects.
These are the actual values that get dispatched to collectd.
It has to be a sequence (a tuple or list) of numbers.
The size of the sequence and the type of its content depend on the type
member your types.db file. For more information on this read the types.db
man page.
If the sequence does not have the correct size upon dispatch a RuntimeError
exception will be raised. If the content of the sequence is not a number,
a TypeError exception will be raised.
The interval is the timespan in seconds between two submits for
the same data source. This value has to be a positive integer, so you can't
submit more than one value per second. If this member is set to a
non-positive value, the default value as specified in the config file will
be used (default: 10).
If you submit values more often than the specified interval, the average
will be used. If you submit less values, your graphs will have gaps.
This is an internal class that is the base for Values
and Notification. It is pretty useless by itself and was therefore not
exported to the collectd module.
The name of the plugin that read the data. Setting this
member to an empty string will insert "python" upon dispatching.
The type of this value. This type has to be defined
in your types.db. Attempting to set it to any other value will
raise a TypeError exception.
Assigning a type is mandetory, calling dispatch without doing
so will raise a RuntimeError exception.
The hostname of the host this value was read from.
For dispatching this can be set to an empty string which means
the local hostname as defined in the collectd.conf.
This is the Unix timestap of the time this value was read.
For dispatching values this can be set to 0 which means "now".
This means the time the value is actually dispatched, not the time
it was set to 0.
python.so.debug
7zXZ
 _/g
G:wk
;&1G
e*=(w'
ci[|
Y6^$tV
%#n:
3{>GR
?c<S
8'q+
m_'/=
W;T7
vN$`c
qz<jB
_S[mN
M&Sc
s/%}
.shstrtab
.note.gnu.build-id
.gnu.hash
.dynsym
.dynstr
.gnu.version
.gnu.version_r
.rel.dyn
.rel.plt
.init
.text
.fini
.rodata
.eh_frame_hdr
.eh_frame
.init_array
.fini_array
.jcr
.data.rel.ro
.dynamic
.got
.data
.bss
.gnu_debuglink
.gnu_debugdata
