|dQ{
__gmon_start__
_fini
_ITM_deregisterTMCloneTable
_ITM_registerTMCloneTable
__cxa_finalize
_Jv_RegisterClasses
dec_new
enif_priv_data
enif_alloc_resource
enif_alloc
dec_init
__assert_fail
dec_destroy
enif_free
dec_error
enif_make_int
enif_make_tuple
dec_curr
dec_top
dec_push
memcpy
dec_pop
dec_string
int_from_hex
unicode_from_pair
utf8_len
utf8_validate
enif_make_new_binary
unicode_to_utf8
enif_make_sub_binary
dec_number
__errno_location
__memcpy_chk
strtol
strtod
enif_make_long
enif_make_double
__stack_chk_fail
make_empty_object
enif_make_list
enif_make_new_map
make_object
enif_get_list_cell
enif_make_map_put
enif_make_list_cell
make_array
decode_iter
enif_make_badarg
enif_inspect_binary
enif_get_resource
enif_is_list
should_yield
enif_is_empty_list
memcmp
decode_init
enif_make_resource
enif_release_resource
get_bytes_per_iter
enif_compare
make_error
JsonNumState
JsonState
enif_realloc_binary
enif_is_binary
enif_is_atom
enif_get_atom
utf8_to_unicode
utf8_esc_len
unicode_uescape
enc_new
enif_alloc_binary
memset
enc_init
enc_destroy
enif_release_binary
enc_error
enc_obj_error
make_obj_error
enc_result
enif_make_binary
enc_done
enc_map_to_ejson
enif_get_map_size
enif_map_iterator_create
enif_map_iterator_next
enif_map_iterator_get_pair
stderr
fwrite
encode_iter
enif_is_identical
enif_get_tuple
enif_get_long
__snprintf_chk
strlen
enif_get_double
double_to_shortest
enif_is_map
encode_init
enif_open_resource_type
nif_init
int_to_hex
enif_make_existing_atom
enif_make_atom
make_ok
enif_get_uint
enif_consume_timeslice
_ZNK17double_conversion23DoubleToStringConverter20ToShortestIeeeNumberEdPNS_13StringBuilderENS0_8DtoaModeE
_Unwind_Resume
__gxx_personality_v0
_ZN17double_conversion6Bignum21DivideModuloIntBignumERKS0_
_ZN17double_conversion6Bignum16MultiplyByUInt32Ej
_ZN17double_conversion6Bignum11PlusCompareERKS0_S2_S2_
_ZN17double_conversion10BignumDtoaEdNS_14BignumDtoaModeEiNS_6VectorIcEEPiS3_
ceil
_ZN17double_conversion6BignumC1Ev
_ZN17double_conversion6Bignum12AssignUInt64Em
_ZN17double_conversion6Bignum9ShiftLeftEi
_ZN17double_conversion6Bignum17AssignPowerUInt16Eti
_ZN17double_conversion6Bignum7CompareERKS0_S2_
_ZN17double_conversion6Bignum12AssignUInt16Et
abort
_ZN17double_conversion6Bignum12AssignBignumERKS0_
_ZN17double_conversion6Bignum16MultiplyByUInt64Em
_ZN17double_conversion6BignumC2Ev
_ZNK17double_conversion6Bignum7BigitAtEi
_ZN17double_conversion6Bignum5ClampEv
_ZNK17double_conversion6Bignum9IsClampedEv
_ZN17double_conversion6Bignum6SquareEv
_ZNK17double_conversion6Bignum11ToHexStringEPci
_ZN17double_conversion6Bignum4ZeroEv
_ZN17double_conversion6Bignum15AssignHexStringENS_6VectorIKcEE
_ZN17double_conversion6Bignum5AlignERKS0_
_ZN17double_conversion6Bignum9AddBignumERKS0_
_ZN17double_conversion6Bignum9AddUInt64Em
_ZN17double_conversion6Bignum14SubtractBignumERKS0_
_ZN17double_conversion6Bignum15BigitsShiftLeftEi
_ZN17double_conversion6Bignum20MultiplyByPowerOfTenEi
_ZN17double_conversion6Bignum19AssignDecimalStringENS_6VectorIKcEE
_ZN17double_conversion6Bignum13SubtractTimesERKS0_i
_ZN17double_conversion16PowersOfTenCache36GetCachedPowerForBinaryExponentRangeEiiPNS_5DiyFpEPi
_ZN17double_conversion16PowersOfTenCache32GetCachedPowerForDecimalExponentEiPNS_5DiyFpEPi
_ZN17double_conversion16PowersOfTenCache19kMaxDecimalExponentE
_ZN17double_conversion16PowersOfTenCache19kMinDecimalExponentE
_ZN17double_conversion16PowersOfTenCache24kDecimalExponentDistanceE
_ZN17double_conversion5DiyFp8MultiplyERKS0_
_ZN17double_conversion23DoubleToStringConverter19EcmaScriptConverterEv
__cxa_guard_acquire
__cxa_guard_release
_ZNK17double_conversion23DoubleToStringConverter19HandleSpecialValuesEdPNS_13StringBuilderE
memmove
_ZNK17double_conversion23DoubleToStringConverter31CreateExponentialRepresentationEPKciiPNS_13StringBuilderE
_ZNK17double_conversion23DoubleToStringConverter27CreateDecimalRepresentationEPKciiiPNS_13StringBuilderE
_ZN17double_conversion23DoubleToStringConverter13DoubleToAsciiEdNS0_8DtoaModeEiPciPbPiS4_
_ZN17double_conversion8FastDtoaEdNS_12FastDtoaModeEiNS_6VectorIcEEPiS3_
_ZN17double_conversion13FastFixedDtoaEdiNS_6VectorIcEEPiS2_
_ZNK17double_conversion23DoubleToStringConverter7ToFixedEdiPNS_13StringBuilderE
_ZNK17double_conversion23DoubleToStringConverter13ToExponentialEdiPNS_13StringBuilderE
_ZNK17double_conversion23DoubleToStringConverter11ToPrecisionEdiPNS_13StringBuilderE
_ZN17double_conversion23StringToDoubleConverter12StringToIeeeEPKciPib
_ZN17double_conversion6StrtodENS_6VectorIKcEEi
_ZN17double_conversion6StrtofENS_6VectorIKcEEi
libstdc++.so.6
libgcc_s.so.1
libc.so.6
_edata
__bss_start
_end
GCC_3.0
CXXABI_1.3
GLIBC_2.14
GLIBC_2.4
GLIBC_2.3.4
GLIBC_2.2.5
5"Q!
%$Q!
%"Q!
%zP!
%rP!
%jP!
%bP!
%ZP!
%RP!
%JP!
%BP!
%:P!
%2P!
%*P!
%"P!
%zO!
%rO!
%jO!
%bO!
%ZO!
%RO!
%JO!
%BO!
%:O!
%2O!
%*O!
%"O!
%zN!
%rN!
%jN!
%bN!
%ZN!
%RN!
%JN!
%BN!
%:N!
%2N!
%*N!
%"N!
%zM!
%rM!
%jM!
%bM!
%ZM!
%RM!
%JM!
%BM!
%:M!
%2M!
%*M!
%"M!
fffff.
fffff.
=iK!
fffff.
9CpH
fffff.
ATUI
[]A\H
HcGtH
fff.
AUATA
HcWt
[]A\A]
`@Ic
HcSpH
HcStH
cpA9
~)Hc
9SpH
HcSt
HcGtH
@80u
HcG`H
AWAVI
AUATA
w`E1
KXHc
[]A\A]A^A_
S`Hc
;CdD
u`A)
KPIc
\t%Hc
AWAV1
AUATE1
D$81
KPHc
KPHc
K`D)
KPHc
KPHc
KPHc
KPHc
KPHc
KPHc
t$8dH34%(
H[]A\A]A^A_
9"uI
K`D)
9"u$
K`D)
fff.
u$S1
AWAVI
AUATUSH
D$(1
d$ L
L$ H
L$(dH3
8[]A\A]A^A_
d$ H
L$ H
ffff.
AUATUSH
([]A\A]
AWAVAUATA
D$h1
D$8t2H
L$hdH3
x[]A\A]A^A_
l$@H
L$ H
|$ H
|$ H
L$0H
L$8H
D$(H
D$0HcG`I
H;D$@
w8L)
|$ HcW`H
|$ HcW`H
D$ Hcp`H
|$ HcW`H
|$ 1
|$ HcW`H
t$0H
|$ 1
D$ H
t$(L
L$ Hcy`H
|$ H
T$(H
t$0H
D$(H
D$0H
|$ 1
t$0H
|$ 1
|$ 1
D$0H
t$(H
|$ H
|$ H
H;D$@
|$ 1
t$0H
D$8H
t$(L
T$0H
t$8H
T$0H
t$8H
D$0H
|$ 1
D$ H
|$ H
|$ H
D$ H
Hcp`H
P8L)
t$8L
L$8H
D$ H
|$ H
|$ H
AVAUATU
D$81
L$8dH3
@[]A\A]A^
D$ 1
D$(H
AUATUSH
HcG$
9k$H
[]A\A]
[]A\A]
AWAVAUATUSH
dH34%(
[]A\A]A^A_
t$0H
ffffff.
fffff.
fffff.
hH;7t
AWAVI
AUATI
D$h1
d$0L
t$(L
l$ L
L$(H
L$hdH3
x[]A\A]A^A_
AWAVAUATI
D$x1
L$xdH3
[]A\A]A^A_
L$8H
|$8H
D$8I
|$@I
t$HH
D$`H
t$@H
D$hH
D$8H
H+l$
t$@L
D$8H
|$HH
t$@L
t$HH
l$8D
D$8H
|$HH
t$@L
t$HH
|$8H
D$8H
H+t$
D$8H
|$HH
|$HH
l$8H
trueH
t$HH
T$PL
t$PH
L$XH
T$4H
l$8H
D$XH
|$8H
l$8H
T$@H
t$HH
T$8H
D$@H
T$XH
D$@H
t$HH
T$PL
T$@H
t$HH
T$8H
D$@H
t$PH
|$HH
D$8H
|$HH
l$8H
fals
l$8H
nullH
|$8H
|$8H
t$HH
t$Hu
t$HH
l$8H
|$8H
|$8H
D$8H
D$8H
D$8I
D$@I
t$HH
T$8H
l$`I
 wNH
T$ I
T$ I
T$ H
t$@I
t$HH
D$hH
 wKH
D$ H
T$pH
T$PH
|$8H
T$PH
|$8H
D$XH
|$8H
D$4H
l$XH
t$HH
D$XH
D$XH
D$XH
T$PL
T$ H
t$PH
D$XH
|$8H
l$8H
T$HH
|$8H
t$HH
t$HL
t$HH
T$@H
t$HH
t$HH
l$8H
D$HH
D$ H
D$(t0H
t$pH
t$pH
t$ H
D$(H
T$HH
|$8H
T$HH
|$8H
fff.
AVAUATUI
D$(1
L$(dH3
0[]A\A]A^
ffff.
ATUH
[]A\
ffffff.
ffffff.
t?H9
fff.
fffff.
ffff.
ATUI
[]A\
AUATI
dH34%(
([]A\A]
t$hH
fff.
D$X1
|$ H
D$8e
HcT$
L$XdH3
HcD$
x!;D$
HcT$
HcT$
x2;T$
HcD$
ffff.
AWAVAUATUSH
~Ff.
}aHc
[]A\A]A^A_
AWAVAUATUSH
t$8H
L$0L
;D$8
\$0E
D$8A
[]A\A]A^A_
\$@L
t$ H
|$ H
D9D$
;D$0
t$ H
9T$8
D$(A
L$@L
;D$0
|$ D
|$ H
D$8H
\$(1
|$@AVD
L$@L
;D$0
|$ H
;T$0
fff.
fff.
AWAVAUATI
uNA9
D9D$
Lct$
D9D$
([]A\A]A^A_
D9D$
fff.
ATUA
[]A\
[]A\
fffff.
AUATI
[]A\A]
[]A\A]
[]A\A]
AWAVAUATI
[]A\A]A^A_
D;l$
[]A\A]A^A_
]A\A]A^A_
fffff.
fffff.
fff.
AUATI
[]A\A]
~]Hc
ATUI
[]A\
ATUH
~JHc
[]A\
fff.
ATUA
D$81
)D$ 
D$8dH3
@[]A\
D$8dH3
[]A\
fffff.
AWAVA
AUATI
<4A9
D;t$
uXE9
	wcH
[]A\A]A^A_
fffff.
AWAVAUATUS
]A\A]A^A_
[]A\A]A^A_
AUATUSH
[]A\A]
}vIc
[]A\A]
[]A\A]
AWAVAUATI
[]A\A]A^A_
[]A\A]A^A_
[]A\A]A^A_
G?AUATI
Vw:H
[]A\A]
fff.
t$fH
[]A\
[]A\
[]A\
xP;C
AWAVAUATUSH
.Mch
gfff
([]A\A]A^A_
AWAVA
AUATE
[]A\A]A^A_
~iHcC
[]A\A]A^A_
[]A\A]A^A_
.tJIcA
D;l$
}~Hc
x19C
x ;C
AVAUA
ATUA
[]A\A]A^
zVuT
[]A\A]A^
L$@f
L$@f
L$@f
L$@f
D$@f
fffff.
ATUSH
D$81
D$ L
d$(PL
L$,L
;K |8
t$8dH34%(
@[]A\
xF;E
AUATfH
dH34%(
[]A\A]
D$ L
L$,L
IcD$
A;D$
AVAUI
ATUH
D$ L
L$,L
HcL$,XZA9
dH34%(
[]A\A]A^
xpA;E
D$ L
d$(1
L$,L
fff.
AWAVfI
AUATI
wv,H
dH3<%(
[]A\A]A^A_
D$ L
d$(PL
L$,L
HcT$,XY9
A;u$D
A;M(
HcT$
AWAVAUATI
[]A\A]A^A_
	w_A
D8|$
D8<$
u*L9
D8<$
$u,f
u'H9
u%L9
D3L$
0xN9
}JHc
AWAVAUATUSH
|$`H
D$hD
t$xH
D$pH
D$pH
D$xL
tzLc
tcLc
tLLc
t5Lc
L9|$
D+D$L
[]A\A]A^A_
|$PH
T$XH
l$xH
D$pH
D$pH
T$XH
D$8H
J@;L$x
L$,H
T$ L
D$xH
D$0H
L$,;L$
toIc
tVIc
t=Ic
t$Ic
L9T$
t$ E1
|$8H9
42H9
H9D$
L$pD
t$ I
L$8L
D94$@
u)Mc
D+D$H
t$ L
D$pH
AVSA
uoD9
}jHc
u@D9
}eHc
0xR9
}NHc
ATUSH
[]A\A]L
[]A\A]
AUATUA
]A\A]A^
[]A\A]A^
xvA9
xLA9
~GLc
AWAVH
ATUS
hImdT
4<Hcu
[]A\A]A^A_
[]A\A]A^A_
fffff.
AWAVAUATI
[]A\A]A^A_
ffff.
AWAVAUATUSH
~4E1
0u3A
[]A\A]A^A_
:0u(f.
4/E1
D;|$
^	tsMc
t^Mc
tIMc
t4Mc
[]A\A]A^A_
AWAVAUATUSH
L$`L
D$ dH
\$(Hcl$
[]A\A]A^A_
L$8D9(
t$@D
t5A)
t$PL
D$PH
D$0H
t$0A
|$ H
t$(H
AWAVAUATUSH
L$`L
D$ dH
[]A\A]A^A_
L$8D;(
|$ H
t$@H
|$0A9
t5A)
t$PL
D$PH
T$01
L$8A
.5wH
T$0A
c_src/decoder.c
invalid_literal
true
false
invalid_string
invalid_number
invalid_json
internal_error
internal_object_error
invalid_trailing_data
invalid_internal_state
truncated_json
d->i <= d->len && "mismatched binary lengths"
d->st_data[d->st_top-1] == val && "popped invalid state."
0 == 1 && "Unbalanced object pairs."
make_object
dec_pop
dec_init
c_src/encoder.c
bad map size
bad iterator create
bad get pair
invalid_object_member
invalid_object_member_arity
invalid_object_member_key
invalid_ejson
invalid_object
    
      
        
          
            
              
e->shiftcnt >= 0 && "Invalid shift count."
enc_shift
bignum
bignum_e
bigdbl
partial
uescape
pretty
force_utf8
bytes_per_iter
return_maps
use_nil
$object_ref$
$array_ref$
decoder
encoder
jiffy
beam.vanilla
nif_decode_init
nif_decode_iter
nif_encode_init
nif_encode_iter
0123456789ABCDEF
Y@c_src/double-conversion/utils.h
strlen(buffer_.start()) == static_cast<size_t>(position_)
length == 0 || (length > 0 && data != __null)
!is_finalized() && position_ < buffer_.length()
0 <= index && index < length_
!is_finalized()
T& double_conversion::Vector<T>::operator[](int) const [with T = char]
char* double_conversion::StringBuilder::Finalize()
int double_conversion::StringBuilder::position() const
double_conversion::Vector<T>::Vector(T*, int) [with T = char]
c_src/double-conversion/bignum-dtoa.cc
*decimal_point == -requested_digits
count >= 0
v > 0
!Double(v).IsSpecial()
f == v
significand != 0
estimated_power >= 0
buffer[(*length) - 1] != '9'
buffer[(*length) -1] != '9'
T& double_conversion::Vector<T>::operator[](int) const [with T = char]
void double_conversion::GenerateCountedDigits(int, int*, double_conversion::Bignum*, double_conversion::Bignum*, double_conversion::Vector<char>, int*)
void double_conversion::BignumToFixed(int, int*, double_conversion::Bignum*, double_conversion::Bignum*, double_conversion::Vector<char>, int*)
void double_conversion::GenerateShortestDigits(double_conversion::Bignum*, double_conversion::Bignum*, double_conversion::Bignum*, double_conversion::Bignum*, bool, double_conversion::Vector<char>, int*)
void double_conversion::InitialScaledStartValuesPositiveExponent(uint64_t, int, int, bool, double_conversion::Bignum*, double_conversion::Bignum*, double_conversion::Bignum*, double_conversion::Bignum*)
int double_conversion::NormalizedExponent(uint64_t, int)
void double_conversion::BignumDtoa(double, double_conversion::BignumDtoaMode, int, double_conversion::Vector<char>, int*, int*)
=c_src/double-conversion/bignum.cc
other.bigits_[other.used_digits_ - 1] >= ((1 << kBigitSize) / 16)
BigitLength() == other.BigitLength()
accumulator == 0
number > 0
a.IsClamped()
b.IsClamped()
c.IsClamped()
used_digits_ >= 0
exponent_ >= 0
other.IsClamped()
bigit_pos >= 0
LessEqual(other, *this)
shift_amount < kBigitSize
shift_amount >= 0
0 <= digit && digit <= 9
base != 0
power_exponent >= 0
exponent_ <= other.exponent_
other.used_digits_ > 0
void double_conversion::Bignum::SubtractTimes(const double_conversion::Bignum&, int)
void double_conversion::Bignum::BigitsShiftLeft(int)
void double_conversion::Bignum::Align(const double_conversion::Bignum&)
static int double_conversion::Bignum::PlusCompare(const double_conversion::Bignum&, const double_conversion::Bignum&, const double_conversion::Bignum&)
static int double_conversion::Bignum::Compare(const double_conversion::Bignum&, const double_conversion::Bignum&)
int double_conversion::SizeInHexChars(S) [with S = unsigned int]
bool double_conversion::Bignum::ToHexString(char*, int) const
uint16_t double_conversion::Bignum::DivideModuloIntBignum(const double_conversion::Bignum&)
void double_conversion::Bignum::AssignPowerUInt16(uint16_t, int)
void double_conversion::Bignum::Square()
void double_conversion::Bignum::MultiplyByPowerOfTen(int)
void double_conversion::Bignum::SubtractBignum(const double_conversion::Bignum&)
void double_conversion::Bignum::AddBignum(const double_conversion::Bignum&)
T& double_conversion::Vector<T>::operator[](int) const [with T = const char]
uint64_t double_conversion::ReadUInt64(double_conversion::Vector<const char>, int, int)
T& double_conversion::Vector<T>::operator[](int) const [with T = unsigned int]
double_conversion::Vector<T>::Vector(T*, int) [with T = unsigned int]
c_src/double-conversion/cached-powers.cc
0 <= index && index < kCachedPowersLength
min_exponent <= cached_power.binary_exponent
cached_power.binary_exponent <= max_exponent
kMinDecimalExponent <= requested_exponent
requested_exponent < kMaxDecimalExponent + kDecimalExponentDistance
*found_exponent <= requested_exponent
requested_exponent < *found_exponent + kDecimalExponentDistance
static void double_conversion::PowersOfTenCache::GetCachedPowerForDecimalExponent(int, double_conversion::DiyFp*, int*)
static void double_conversion::PowersOfTenCache::GetCachedPowerForBinaryExponentRange(int, int, double_conversion::DiyFp*, int*)
-;eU
U1(\Q
mSx@
b}$l
~)p$w
11eU%
z^KD
c_src/double-conversion/double-conversion.cc
length == static_cast<size_t>(static_cast<int>(length))
static_cast<size_t>(n) <= strlen(s)
!is_finalized() && position_ + n < buffer_.length()
length <= digits_after_point - (-decimal_point)
length - decimal_point <= digits_after_point
mode == SHORTEST || mode == SHORTEST_SINGLE || requested_digits >= 0
mode == SHORTEST || mode == SHORTEST_SINGLE
decimal_rep_length <= requested_digits + 1
decimal_rep_length <= precision
number < ((int64_t)1 << kSignificandSize)
static_cast<int64_t>(static_cast<double>(number)) == number
-max_exponent / 2 <= exponent && exponent <= max_exponent / 2
**current == *substring
c != '\0'
Infinity
length != 0
exponent < 1e4
digits_after_point > 0
number != 0
buffer_pos < kBufferSize
current != end
tail_pointer != __null
double double_conversion::RadixStringToIeee(const char*, const char*, bool, bool, double, bool, const char**) [with int radix_log_2 = 3]
double double_conversion::RadixStringToIeee(const char*, const char*, bool, bool, double, bool, const char**) [with int radix_log_2 = 4]
bool double_conversion::ConsumeSubString(const char**, const char*, const char*)
double double_conversion::StringToDoubleConverter::StringToIeee(const char*, int, int*, bool)
double_conversion::Vector<T>::Vector(T*, int) [with T = char]
static void double_conversion::DoubleToStringConverter::DoubleToAscii(double, double_conversion::DoubleToStringConverter::DtoaMode, int, char*, int, bool*, int*, int*)
bool double_conversion::DoubleToStringConverter::ToPrecision(double, int, double_conversion::StringBuilder*) const
bool double_conversion::DoubleToStringConverter::ToExponential(double, int, double_conversion::StringBuilder*) const
bool double_conversion::DoubleToStringConverter::ToShortestIeeeNumber(double, double_conversion::StringBuilder*, double_conversion::DoubleToStringConverter::DtoaMode) const
void double_conversion::DoubleToStringConverter::CreateDecimalRepresentation(const char*, int, int, int, double_conversion::StringBuilder*) const
void double_conversion::DoubleToStringConverter::CreateExponentialRepresentation(const char*, int, int, double_conversion::StringBuilder*) const
void double_conversion::StringBuilder::AddSubstring(const char*, int)
int double_conversion::StrLength(const char*)
T& double_conversion::Vector<T>::operator[](int) const [with T = char]
void double_conversion::StringBuilder::AddCharacter(char)
c_src/double-conversion/fast-dtoa.cc
number < (1u << (number_bits + 1))
c_src/double-conversion/diy-fp.h
c_src/double-conversion/ieee.h
(kMinimalTargetExponent <= w.e() + ten_mk.e() + DiyFp::kSignificandSize) && (kMaximalTargetExponent >= w.e() + ten_mk.e() + DiyFp::kSignificandSize)
scaled_w.e() == boundary_plus.e() + ten_mk.e() + DiyFp::kSignificandSize
low.e() == w.e() && w.e() == high.e()
kMinimalTargetExponent <= w.e() && w.e() <= kMaximalTargetExponent
f_ != 0
value() > 0.0
rest < ten_kappa
!IsSpecial()
boundary_plus.e() == w.e()
low.f() + 1 <= high.f() - 1
f_ >= other.f_
rest <= unsafe_interval
fractionals < one.f()
Sign() > 0
T& double_conversion::Vector<T>::operator[](int) const [with T = char]
bool double_conversion::RoundWeedCounted(double_conversion::Vector<char>, int, uint64_t, uint64_t, uint64_t, int*)
bool double_conversion::DigitGenCounted(double_conversion::DiyFp, int, double_conversion::Vector<char>, int*, int*)
bool double_conversion::Grisu3Counted(double, int, double_conversion::Vector<char>, int*, int*)
bool double_conversion::RoundWeed(double_conversion::Vector<char>, int, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t)
void double_conversion::DiyFp::Subtract(const double_conversion::DiyFp&)
void double_conversion::BiggestPowerTen(uint32_t, int, uint32_t*, int*)
bool double_conversion::DigitGen(double_conversion::DiyFp, double_conversion::DiyFp, double_conversion::DiyFp, double_conversion::Vector<char>, int*, int*)
double_conversion::DiyFp double_conversion::Single::AsDiyFp() const
void double_conversion::Single::NormalizedBoundaries(double_conversion::DiyFp*, double_conversion::DiyFp*) const
void double_conversion::DiyFp::Normalize()
double_conversion::DiyFp double_conversion::Double::AsDiyFp() const
double_conversion::DiyFp double_conversion::Double::AsNormalizedDiyFp() const
bool double_conversion::Grisu3(double, double_conversion::FastDtoaMode, double_conversion::Vector<char>, int*, int*)
bool double_conversion::FastDtoa(double, double_conversion::FastDtoaMode, int, double_conversion::Vector<char>, int*, int*)
c_src/double-conversion/fixed-dtoa.cc
-128 <= exponent && exponent <= 0
64 < -exponent && -exponent <= 128
fractionals >> 56 == 0
(accumulator >> 32) == 0
T& double_conversion::Vector<T>::operator[](int) const [with T = char]
void double_conversion::UInt128::Multiply(uint32_t)
void double_conversion::FillFractionals(uint64_t, int, int, double_conversion::Vector<char>, int*, int*)
c_src/double-conversion/strtod.cc
exponent < PowersOfTenCache::kDecimalExponentDistance
PowersOfTenCache::kDecimalExponentDistance == 8
buffer.length() + exponent <= kMaxDecimalPower + 1
buffer.length() + exponent > kMinDecimalPower
buffer.length() <= kMaxSignificantDecimalDigits
buffer[buffer.length() - 1] != '0'
read_digits == trimmed.length()
exponent <= PowersOfTenCache::kMaxDecimalExponent
f1 <= f2 && f2 <= f3 && f3 <= f4
(f1 != f2 && f2 == f3 && f3 == f4) || (f1 == f2 && f2 != f3 && f3 == f4) || (f1 == f2 && f2 == f3 && f3 != f4)
0 < exponent
to <= length_
double_conversion::DiyFp double_conversion::Single::UpperBoundary() const
float double_conversion::Strtof(double_conversion::Vector<const char>, int)
int double_conversion::CompareBufferWithDiyFp(double_conversion::Vector<const char>, int, double_conversion::DiyFp)
double_conversion::DiyFp double_conversion::Double::UpperBoundary() const
void double_conversion::DiyFp::Normalize()
double_conversion::DiyFp double_conversion::AdjustmentPowerOfTen(int)
bool double_conversion::DiyFpStrtod(double_conversion::Vector<const char>, int, double*)
uint64_t double_conversion::ReadUint64(double_conversion::Vector<const char>, int*)
bool double_conversion::DoubleStrtod(double_conversion::Vector<const char>, int, double*)
double_conversion::Vector<T>::Vector(T*, int) [with T = const char]
void double_conversion::CutToMaxSignificantDigits(double_conversion::Vector<const char>, int, char*, int*)
double_conversion::Vector<T> double_conversion::Vector<T>::SubVector(int, int) [with T = const char]
T& double_conversion::Vector<T>::operator[](int) const [with T = const char]
vH7B
W4vC
;*3$"
zPLR
jiffy.so.debug
7zXZ
]Aw[
^l1uB
`kY[
q05?u
#[5|k
u^vZ
E]!|
3(^c
0<^Y
EaEi
"t:zbm	?
z9pI<+
{6O)f
~@{mL
I^OQ/:iGe
\r2QZVF
$DWi
\pZ9#
.shstrtab
.note.gnu.build-id
.gnu.hash
.dynsym
.dynstr
.gnu.version
.gnu.version_r
.rela.dyn
.rela.plt
.init
.text
.fini
.rodata
.eh_frame_hdr
.eh_frame
.gcc_except_table
.init_array
.fini_array
.jcr
.data.rel.ro
.dynamic
.got
.data
.bss
.gnu_debuglink
.gnu_debugdata
