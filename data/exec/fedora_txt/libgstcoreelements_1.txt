__gmon_start__
_ITM_deregisterTMCloneTable
_ITM_registerTMCloneTable
__cxa_finalize
_Jv_RegisterClasses
gst_base_transform_set_gap_aware
gst_caps_new_any
g_type_class_peek_parent
gst_caps_get_type
dcgettext
g_param_spec_boxed
g_object_class_install_property
_gst_debug_register_funcptr
__gst_debug_min
gst_buffer_is_metadata_writable
gst_buffer_create_sub
gst_buffer_set_caps
gst_debug_log
gst_mini_object_ref
gst_caps_ref
gst_caps_make_writable
gst_caps_do_simplify
gst_caps_is_fixed
gst_caps_is_empty
gst_pad_set_caps
gst_pad_get_allowed_caps
g_return_if_fail_warning
gst_caps_to_string
gst_caps_unref
_gst_element_error_printf
gst_stream_error_quark
gst_element_message_full
g_free
g_mutex_lock
g_mutex_unlock
gst_caps_can_intersect
gst_pad_peer_accept_caps
gst_caps_intersect
gst_caps_replace
gst_structure_id_set_value
gst_element_class_set_details_simple
gst_static_pad_template_get
gst_element_class_add_pad_template
g_type_name
gst_value_set_caps
gst_value_get_caps
gst_caps_is_any
gst_base_transform_suggest
gst_caps_get_structure
gst_structure_get_name_id
gst_caps_copy
gst_structure_foreach
g_once_init_enter
g_intern_static_string
gst_base_transform_get_type
gst_type_register_static_full
g_once_init_leave
_gst_debug_category_new
gst_element_register
gst_plugin_desc
gst_buffer_new
g_malloc
gst_mini_object_unref
gst_event_get_structure
gst_structure_to_string
g_strdup_printf
g_object_notify_by_pspec
g_strdup
gst_base_src_set_format
g_value_get_enum
g_value_get_int
g_value_get_boolean
gst_base_src_set_live
g_param_spec_enum
g_param_spec_int
g_enum_register_static
g_param_spec_boolean
g_param_spec_string
gst_format_get_type
gst_pad_get_type
gst_buffer_get_type
g_signal_new
g_random_int_range
memset
gst_util_dump_mem
g_signal_emit
g_malloc0
g_snprintf
stpcpy
gst_base_src_is_live
g_strlcpy
gst_element_get_clock
gst_clock_get_time
gst_element_get_base_time
gst_object_unref
g_value_peek_pointer
g_value_get_object
gst_value_get_mini_object
gst_base_src_get_type
g_type_check_instance_is_a
g_value_set_enum
g_value_set_boolean
g_value_set_string
g_value_set_int
gst_base_sink_set_sync
gst_event_parse_sink_message
gst_core_error_quark
gst_base_sink_get_type
g_param_spec_uint64
gst_poll_wait
gst_structure_new
gst_message_new_element
gst_element_post_message
gst_buffer_try_new_and_alloc
__errno_location
g_strerror
gst_resource_error_quark
gst_poll_set_flushing
gst_poll_free
gst_poll_remove_fd
gst_poll_add_fd
gst_poll_fd_ctl_read
__fxstat64
gst_base_src_set_dynamic_size
lseek64
g_value_get_uint64
gst_uri_get_protocol
__isoc99_sscanf
g_strstr_len
gst_query_set_uri
gst_poll_new
g_value_set_uint64
gst_push_src_get_type
gst_uri_handler_get_type
g_type_add_interface_static
gst_pad_set_query_function
gst_pad_query_default
gst_query_parse_position
gst_query_set_position
gst_query_set_formats
gst_event_parse_new_segment
gst_format_get_name
gst_poll_fd_ctl_write
fflush
fseeko64
ftello64
fwrite
fclose
fopen64
__fbufsize
setvbuf
g_param_spec_uint
g_value_set_uint
gst_filename_to_uri
g_str_has_prefix
gst_uri_get_location
g_path_is_absolute
g_strconcat
g_value_get_uint
g_value_get_string
getpagesize
g_param_spec_ulong
g_type_class_adjust_private_offset
madvise
munmap
g_object_notify
gst_uri_handler_new_uri
g_filename_from_uri
g_error_free
g_value_set_ulong
g_value_get_ulong
g_type_register_static_simple
mmap64
gst_mini_object_new
gst_segment_init
gst_pad_new_from_static_template
gst_pad_set_event_function
gst_pad_use_fixed_caps
gst_element_add_pad
gst_pad_get_parent_element
gst_element_iterate_sink_pads
gst_iterator_next
gst_iterator_free
gst_pad_push_event
gst_iterator_resync
gst_iterator_foreach
gst_pad_set_active
gst_element_remove_pad
gst_pad_alloc_buffer
gst_object_get_parent
gst_pad_peer_get_caps_reffed
gst_pad_get_pad_template_caps
gst_event_parse_new_segment_full
gst_segment_set_newsegment_full
gst_segment_set_last_stop
gst_segment_to_running_time
gst_buffer_make_metadata_writable
gst_pad_push
gst_flow_get_name
gst_event_new_new_segment_full
gst_element_release_request_pad
g_object_new
gst_pad_set_chain_function
gst_pad_set_getcaps_function
gst_pad_set_bufferalloc_function
gst_element_get_type
g_param_spec_float
gst_event_new_new_segment
gst_pad_event_default
gst_clock_id_unschedule
gst_clock_id_unref
g_value_set_float
g_value_get_float
rand
gst_util_uint64_scale_int
g_usleep
gst_clock_new_single_shot_id
gst_clock_id_wait
gst_object_ref
gst_pad_peer_query
gst_query_parse_latency
gst_query_set_latency
gst_iterator_new_single
gst_pad_new
gst_pad_set_iterate_internal_links_function
g_slice_alloc
g_mutex_init
g_cond_init
g_param_spec_object
gst_object_replace
g_cond_broadcast
gst_tag_list_free
gst_pad_set_acceptcaps_function
g_type_register_static
g_param_spec_int64
gst_tag_list_get_type
g_value_set_int64
g_value_set_boxed
g_value_set_object
g_mutex_clear
g_slice_free1
g_cond_clear
g_cond_wait
gst_event_parse_tag
gst_tag_list_merge
gst_pad_is_linked
gst_pad_new_from_template
gst_pad_set_setcaps_function
gst_pad_proxy_getcaps
gst_pad_proxy_setcaps
g_cclosure_marshal_VOID__VOID
g_cond_signal
gst_data_queue_flush
g_object_unref
g_list_delete_link
gst_data_queue_set_flushing
gst_pad_set_element_private
gst_pad_get_element_private
gst_pad_get_peer
gst_pad_query
gst_pad_pause_task
gst_pad_start_task
gst_pad_stop_task
gst_buffer_list_get_type
gst_event_get_type
gst_buffer_list_iterate
gst_buffer_list_iterator_next
gst_buffer_list_iterator_next_group
gst_pad_peer_get_caps
gst_data_queue_is_empty
gst_data_queue_is_full
gst_data_queue_get_level
gst_data_queue_limits_changed
g_list_insert_before
gst_data_queue_new_full
gst_pad_set_activatepush_function
g_static_rec_mutex_lock
g_static_rec_mutex_unlock
g_list_foreach
gst_message_new_buffering
gst_data_queue_push
gst_data_queue_pop
gst_event_type_get_name
g_queue_pop_head
g_queue_push_tail
gst_pad_set_link_function
g_queue_init
g_queue_clear
gst_event_new_eos
gst_pad_query_peer_duration
g_slice_alloc0
gst_event_new_seek
gst_buffer_new_and_alloc
fread
ferror
feof
gst_buffer_list_foreach
gst_message_set_buffering_stats
g_slice_free_chain_with_offset
freopen64
g_queue_is_empty
gst_pad_set_chain_list_function
gst_pad_set_activatepull_function
gst_pad_set_getrange_function
gst_pad_set_checkgetrange_function
g_timer_new
g_timer_destroy
g_value_dup_string
gst_query_parse_buffering_range
gst_query_add_buffering_range
gst_query_set_buffering_percent
gst_query_set_buffering_range
gst_query_set_buffering_stats
g_timer_elapsed
g_mkstemp
fdopen
remove
g_timer_start
gst_buffer_list_get
gst_pad_push_list
g_timer_continue
g_timer_stop
g_object_get_qdata
gst_element_iterate_src_pads
g_object_set_qdata_full
gst_pad_activate_push
gst_pad_pull_range
gst_pad_check_pull_range
gst_pad_activate_pull
g_quark_from_static_string
gst_pad_set_activate_function
gst_element_get_state
g_list_append
gst_mini_object_replace
gst_type_find_helper_for_buffer
gst_buffer_join
gst_query_new_uri
gst_query_parse_uri
strlen
gst_pad_is_active
gst_pad_query_duration
gst_type_find_helper_get_range_ext
gst_type_find_helper_for_extension
gst_marshal_VOID__UINT_BOXED
g_value_dup_boxed
libgstbase-0.10.so.0
libgstreamer-0.10.so.0
libxml2.so.2
libm.so.6
libgobject-2.0.so.0
libgthread-2.0.so.0
libgmodule-2.0.so.0
libglib-2.0.so.0
libdl.so.2
libpthread.so.0
libc.so.6
__stack_chk_fail
libgstcoreelements.so
GLIBC_2.2
GLIBC_2.0
GLIBC_2.1.3
GLIBC_2.4
GLIBC_2.1
GLIBC_2.7
UWVS
d$<[^_]
UWVS
T$p1
[^_]
[^_]
UWVS
[^_]
UWVS
d$<[^_]
d$$[^
UWVS
|$\tt
d$<[^_]
d$<[^_]
UWVS
d$L[^_]
d$L[^_]
9D$<
d$@[^_
D$ d
d$@[^_
UWVS
d$<[^_]
D$,t|
UWVS
d$<[^_]
[^_]
d$0[^_
d$$[^
UWVS
D$Xe
|$L1
[^_]
UWVS
|$Tt*
d$,[^_]
[^_]
d$@[^_
d$@[^_
UWVS
d$<[^_]
UWVS
D$Le
[^_]
D$L1
T$Xu
UWVS
|$de
D$<1
L$<e3
d$L[^_]
UWVS
D$8tu
d$L[^_]
D$ a
d$L[^_]
d$L[^_]
d$0[^_
d$0[^_
d$0[^_
d$0[^_
d$0[^_
d$0[^_
d$0[^_
d$0[^_
d$0[^_
d$0[^_
d$0[^_
d$0[^_
d$0[^_
d$0[^_
d$0[^_
d$0[^_
d$0[^_
UWVS
d$<[^_]
d$$[^
d$4[^
d$4[^
UWVS
|$Tt*
d$,[^_]
[^_]
d$@[^_
d$@[^_
d$0[^_
UWVS
d$\[^_]
D$Hc
|$\x&
D$l%
[^_]
UWVS
d$L[^_]
d$L[^_]
D$8c
d$$[^
UWVS
D$L1
8ft,
L$Le3
d$\[^_]
D$|1
\$|e3
UWVS
d$L[^_]
d$L[^_]
UWVS
[^_]
D$ 5
d$L1
[^_]
UWVS
d$<[^_]
d$<[^_]
d$<[^_]
d$@[^_
d$@[^_
UWVS
[^_]
d$ [^_
D$\%
[^_]
D$ e
UWVS
d$L[^_]
D$ 9
[^_]
D$ *
D$ >
d$$[^
T$0e
d$ [^_
UWVS
L$l1
|$le3=
d$|[^_]
D$ H
UWVS
D$L1
L$Le3
d$\[^_]
UWVS
|$\tt
d$<[^_]
d$<[^_]
d$,[^_]
8ft%
d$ [^_
UWVS
|$\tx
d$<[^_]
d$@[^_
d$@[^_
L$<tg
d$@[^_
UWVS
D$l1
L$le3
d$|[^_]
D$ g
D$ `
UWVS
[^_]
d$L[^_]
UWVS
[^_]
[^_]
UWVS
[^_]
d$L1
[^_]
d$ [^_
d$$[^
|$0e
d$ [^_
d$0[^_
d$0[^_
d$0[^_
d$0[^_
d$0[^_
UWVS
d$<[^_]
[^_]
UWVS
d$,[^_]
d$,1
[^_]
D$@1
[^_]
UWVS
d$<[^_]
d$<[^_]
d$<[^_]
d$<[^_]
d$@[^_
d$@[^_
d$ [^_
d$$[^
UWVS
L$<vT
d$L[^_]
D$|1
L$|e3
d$<1
[^_]
[^_]
D$L1
|$Le3=
d$\[^_]
d$@[^_
d$@[^_
UWVS
d$<[^_]
d$<[^_]
d$<[^_]
d$<[^_]
d$<[^_]
d$<[^_]
d$<[^_]
d$<[^_]
UWVS
T$8u-
d$L[^_]
d$L[^_]
d$L[^_]
d$L[^_]
d$L[^_]
d$ [^_
d$ [^_
UWVS
|$`1
[^_]
|$d1
D$ c
[^_]
[^_]
\$4)
\$<1
\$4)
\$<1
D$0+D$8
^0+L$8
d$\[^_]
d$\[^_]
UWVS
l$L1
D$Xun
D$`1
x^u<
[^_]
D$ c
[^_]
T$d1
9l$Ls_
|$T9|$d
9L$Hr
|$X9l$d
l$L)
9|$p
l$L9
T$X9
T$P9T$p
3T$X	
T$T9T$l
9D$h
T$T9T$lw
9D$hw
$+T$P
Z0+L$P
D$ ^
UWVS
D$\%
[^_]
D$ &
D$ -
UWVS
D$(e
D$<1
D$,1
T$<e3
d$L[^_]
D$(1
UWVS
d$,[^_]
d$,1
[^_]
d$ [^_
UWVS
[^_]
UWVS
[^_]
UWVS
D$|1
T$|e3
[^_]
UWVS
T$L	
[^_]
d$$[^
d$ [^_
d$ [^_
UWVS
[^_]
d$@[^_
d$@[^_
d$0[^_
UWVS
|$te
D$L1
L$Le3
d$\[^_]
d$ [^_
d$0[^_
d$0[^_
d$$[^
UWVS
|$Tt*
d$,[^_]
[^_]
L$Le
[^_]
UWVS
[^_]
D$x,
D$h,
D$X,
D$H,
D$8,
D$(,
D$x,
D$h,
D$X,
D$H,
D$8,
D$(,
d$@[^_
d$@[^_
[^_]
UWVS
[^_]
D$41
[^_]
D$41
UWVS
D$Pt_
[^_]
D$H!
#D$H
9T$hvy
T$T#T$\
9T$T
9L$lf
T$T#T$\
9L$\
D$T#D$\
D$xc
D$tc
D$\c
D$`c
UWVS
[^_]
UWVS
[^_]
D$,(
D$((
d$0[^_
D$8c
d$4[^
UWVS
t$H9
|$T9
|$T)
t$8+
[^_]
|$<1
d$|1
[^_]
|$L)
UWVS
d$,[^_]
d$,[^_]
d$,[^_]
UWVS
d$<[^_]
d$ 1
UWVS
[^_]
[^_]
d$4[^
d$0[^_
d$0[^_
d$0[^_
d$0[^_
d$0[^_
UWVS
[^_]
[^_]
d$0[^_
d$0[^_
d$0[^_
d$0[^_
d$$[^
d$@[^_
UWVS
D$d1
[^_]
UWVS
tU;l$dtO
L$l!
;l$`
[^_]
D$`1
L$`9L$d
;PPt
;D$\r
;T$Xv
T$h!
;l$`
9L$h
9|$t
D$X!
D$X!
D$xc
UWVS
D$Te
[^_]
D$T1
T$Xt*
UWVS
d$,[^_]
d$,[^_]
UWVS
|$\tt
d$<[^_]
d$<[^_]
UWVS
l$dt*
d$<[^_]
d$<[^_]
T$,u
UWVS
d$<[^_]
d$<[^_]
d$<[^_]
d$@[^_
d$@[^_
UWVS
[^_]
D$t1
UWVS
[^_]
UWVS
[^_]
D$8c
UWVS
[^_]
d$ [^_
UWVS
[^_]
d$0[^_
d$0[^_
d$0[^_
d$0[^_
d$ [^_
d$$[^
UWVS
d$<[^_]
d$<[^_]
d$<[^_]
d$<[^_]
d$@[^_
d$@[^_
d$0[^_
UWVS
[^_]
UWVS
L$$!
L$,!
d$<[^_]
T$,9T$$v
9T$Tr
d$@[^_
9T$X
d$@[
UWVS
d$L[^_]
d$L[^_]
d$0[^_
d$01
d$L[^_]
d$L[^_]
UWVS
d$<	
[^_]
UWVS
#T$`
;L$\r
;T$`f
D$h#D$|
[^_]
tc;T$hr
t$|#t$h
D$xc
D$tc
;L$|
D$dc
D$dc
D$pc
UWVS
9T$L
d$\[^_]
[^_]
UWVS
[^_]
d$ [^_
d$ [^_
d$ [^_
d$ [^_
UWVS
T$\1
L$0vJ
L$L9
D$\e3
d$l[^_]
UWVS
L$l9
[^_]
UWVS
D$\1
D$X1
L$\e3
d$l[^_]
D$41
UWVS
d$<[^_]
d$0[^_
d$0[^_
d$$[^
D$l1
T$H	
D$DtD
L$Lk
D$le3
d$|[^_]
kD$`d1
D$P9
+D$@
[^_]
d$|[^_]
D$\c
D$Xc
D$Pc
D$hc
D$dc
D$@!
D$<te
d$\[^_]
D$Hc
UWVS
d$\[^_]
D$|1
D$|e3
[^_]
UWVS
[^_]
9L$P
9L$X
L$\!
D$\9D$Xr&
D$`t!
9D$Xw,r
9T$\s$!
D$P;
D$h!
D$d!
D$xc
D$tc
D$hc
D$tc
D$pc
D$dc
D$\#D$X
;HPt
D$dc
D$hc
UWVS
[^_]
d$@[^_
d$@[^_
UWVS
D$,e
D$\1
D$0	
L$<	
l$Lt
|$\e3=
d$l[^_]
T$T+
|$P1
UWVS
[^_]
d$`[^_
L$H!
D$H9
|(~"
T$L)
d$|[^_]
d$|[^_]
D$`c
D$\c
D$Tc
D$lc
D$hc
[^_]
d$<[^_]
UWVS
[^_]
UWVS
[^_]
d$|1
[^_]
d$|1
[^_]
UWVS
d$,[^_]
d$ [^_
UWVS
d$<[^_]
d$0[^_
d$$[^
D$p!
d$\[
d$\[
D$Hc
D$Lc
[^_]
[^_]
D$<1
D$<e3
d$L[^_]
d$`[^_
UWVS
d$|[^_]
UWVS
[^_]
D$xc
D$tc
UWVS
|$pv>
[^_]
|$lft
|$lV
L$pt
;jPt
d$@[^_
d$@[^_
;T$D
[^_]
9|$D
d$\1
d$l[^_]
|$d9
l$`w
D$<;~
d$L[^_]
d$L[^_]
d$0[1
UWVS
d$|1
[^_]
D$\c
D$Xc
D$hc
D$dc
D$L1
D$Le3
d$T[^
UWVS
[^_]
[^_]
|$0)
d$L[
d$L[
w.s&
9l$4r
L$<t
;T$P
D$x	
D$l1
9T$\
t$X)
D$P	
D$P	
+D$p
T$X9
t$p9x
D$`+T$p
D$l1
9T$\
T$\1
9D$X
L$x;L$P
[^_]
L$h)L$d)L$l
9D$X
|$\9
D$X9
T$P1
+D$X
D$p9Q
T$\r
;D$Pv
t$X1
t$p9
D$l1
D$x	
UWVS
[^_]
t$|1
|$Dw*s"
;t$8v
T$8	
L$<t
9D$D
9t$@
UWVS
[^_]
d$l[^_]
d$l[^_]
D$Lc
D$Hc
D$Xc
D$Tc
D$p!
d$\[
d$\[
D$Lc
D$Hc
D$L1
D$Le3
d$\[^_]
D$8c
D$4c
[^_]
9L$Xw
D$|)
D$l1
D$(d
9|$ |
kL$ d
L$(ti
D$le3
d$|[^_]
|$ 9
|$4w
D$(9
D$(9
9T$ 
9L$(r
t$ 1
9D$(
|$49
d$$[^
d$$[^
d$([
[^_]
D$X	
|$x1
T$\9
D$Xw
L$\;N
L$X;N
|$|)|$x
B,;z0
|$X	
D$X1
;D$Xv
+D$`
T$h	
9L$d
9|$`
;L$t
T$p9
9T$\w!
T$p9T$X
T$d9T$\w
T$`9T$X
9L$\
T$l+D$`
|$d9
|$`9
9L$\w
9|$Xr%1
T$l+D$`
+D$`
|$|)
L$\;N
L$X;N
|$|)|$x
[^_]
9|$X
D$ ?
D$ 8
[^_]
D$ E
|$|)|$x
UWVS
d$<[^_]
d$0[^_
d$ [^_
UWVS
d$<[^_]
UWVS
[^_]
d$$[^
;J,w
UWVS
d$<[^_]
[^_]
UWVS
D$8e
[^_]
T$Df
+D$0
l$@i
d$0iL$4@B
d$l[^_]
D$Hc
d$|[^_]
zwuu
D$Pc
[^_]
D$<vJ
D$@1
UWVS
[^_]
UWVS
[^_]
UWVS
[^_]
[^_]
[^_]
UWVS
;PPt
;PPt
[^_]
|$pV
[^_]
UWVS
[^_]
[^_]
[^_]
[^_]
[^_]
T$Xw
UWVS
D$Xc
D$Tc
D$hc
D$dc
d$@[^_
D$ T
d$@[^_
El9D$H
El9D$H
[^_]
d$l[
UWVS
[^_]
UWVS
[^_]
UWVS
D$H;El
d$\[^_]
d$\[^_]
UWVS
D$,1
t7r}
L$,e3
d$<[^_]
UWVS
d$,[^_]
d$,[^_]
UWVS
[^_]
[^_]
[^_]
UWVS
[^_]
t$ 9
d$01
d$0[^_
UWVS
[^_]
[^_]
[^_]
9D$Pu
UWVS
d$<[^_]
UWVS
d$<[^_]
d$ [^_
d$$[^
d$@[^_
d$@[^_
D$<1
L$<e3
d$L[^_]
)t$0
d$0[^_
T$(t|
d$<[^_]
D$\1
D$\e3
d$l[^_]
DD$L
T$DtY
UWVS
D$L1
T$Le3
d$\[^_]
T$D9
D$ 2
D$ :
UWVS
D$L1
L$Le3
d$\[^_]
T$D9
D$ A
D$ -
UWVS
[^_]
[^_]
D$<1
|$<e3=
d$L[^_]
UWVS
D$l1
D$Td
L$le3
d$|[^_]
D$T9
D$Td
D$Xt
D$T;
UWVS
d$L[^_]
d$0[^_
d$0[^_
d$0[^_
d$0[^_
d$0[^_
d$$[^
d$ [^_
d$ [^_
d$0[^_
d$0[^_
d$0[^_
d$0[^_
d$@[^_
d$@[^_
UWVS
d$,[^_]
UWVS
D$Tt1
[^_]
UWVS
[^_]
d$$[^
d$$[^
UWVS
|$\tt
d$<[^_]
d$<[^_]
UWVS
d$<[^_]
d$<[^_]
d$@[^_
d$@[^_
UWVS
[^_]
UWVS
d$,[^_]
u|;\$
UWVS
[^_]
[^_]
[^_]
[^_]
UWVS
[^_]
[^_]
[^_]
[^_]
Restrict the possible allowed capabilities (NULL means ANY). Setting this property takes a reference to the supplied GstCaps object.
Filter caps do not completely specify the output format
Input buffer already has caps (implicitly fixed)
Creating sub-buffer and setting caps
Have fixed output caps %P to apply to buffer with no caps
Cannot choose caps. Have unfixed output caps %P
David Schleef <ds@schleef.org>
Pass data without modification, limiting formats
%s:%d: invalid %s id %u for "%s" of type '%s' in '%s'
gstreamer-0.10
Filter caps
gst_capsfilter_transform_caps
gst_capsfilter_transform_ip
gst_capsfilter_accept_caps
gst_capsfilter_prepare_buf
Output caps are unfixed: %s
gstcapsfilter.c
out_caps != NULL
can intersect: %d
peer accept: %d
input:     %P
filter:    %P
intersect: %P
Generic
property
set new caps %P
we had negotiated caps %P
not settings any suggestion
copied structure fields
different structure names
no negotiated caps
suggesting new caps %P
capsfilter element
capsfilter
GstCapsFilter
gst_capsfilter_set_property
gst_capsfilter_transform_caps
gst_capsfilter_accept_caps
gst_capsfilter_prepare_buf
gst_capsfilter_prepare_buf
coreelements
standard GStreamer elements
0.10.36
LGPL
gstreamer
Fedora GStreamer package
2012-02-20
fakesrc
fakesink
fdsrc
fdsink
funnel
identity
input-selector
output-selector
queue2
filesink
typefind
multiqueue
valve
http://download.fedoraproject.org
(NULL)
not yet implemented
gstfakesrc.c
GstFakeSrcDataType
Data allocation method
GstFakeSrcSizeType
How to determine buffer sizes
sizetype
Minimum buffer size
sizemin
Maximum buffer size
sizemax
parentsize
GstFakeSrcFillType
filltype
Datarate
datarate
Sync
sync
pattern
The last status message
last-message
Silent
silent
Signal handoffs
signal-handoffs
Dump
dump
Can activate in push mode
Can activate push
can-activate-push
Can activate in pull mode
Can activate pull
can-activate-pull
Is this a live source
is-live
Format
format
gst_fake_src_is_seekable
gst_fake_src_start
gst_fake_src_stop
gst_fake_src_event_handler
gst_fake_src_get_times
gst_fake_src_create
Fake Source
none
media4
discont
incaps
delta_unit
media1
media2
media3
pre handoff emit
post handoff emit
n_param_values == 3
fakesrc element
GstFakeSrc
GST_IS_FAKE_SRC (object)
Leave data as malloced
nothing
Fill buffers with zeros
zero
Fill buffers with random crap
random
pattern-span
Send empty buffers
fixed
Allocate data
allocate
Subbuffer data
subbuffer
event   ******* (%s:%s) E (type: %d, %s) %p
!GST_OBJECT_FLAG_IS_SET (object, GST_BASE_SRC_STARTED)
Size of parent buffer for sub-buffered allocation
How to fill the buffer, if at all
Timestamps buffers with number of bytes per second (0 = none)
Sync to the clock to the datarate
Don't produce last_message events
Send a signal before pushing the buffer
Dump buffer contents to stdout
True if the element cannot produce data in PAUSED
The format of the segment events
Erik Walthinsen <omega@cse.ogi.edu>, Wim Taymans <wim@fluendo.com>
Push empty (no data) buffers around
fakesrc: dunno how to allocate buffers !
create   ******* (%s:%s) (%u bytes, timestamp: %s, duration: %s, offset: %lli, offset_end: %lli, flags: %d %s) %p
Fill buffers with pattern 0x00 -> 0xff
Fill buffers with pattern 0x00 -> 0xff that spans buffers
Fixed size buffers (sizemax sized)
Random sized buffers (sizemin <= size <= sizemax)
gst_fake_src_set_property
gst_fake_src_get_property
marshal_VOID__MINIOBJECT_OBJECT
gst_fake_src_create
gstfakesink.c
GstFakeSinkStateError
Generate a state change error
State Error
state-error
Last Message
num-buffers
preroll-handoff
gst_fake_sink_change_state
gst_fake_sink_event
gst_fake_sink_preroll
gst_fake_sink_render
Black hole for data
Fake Sink
preroll   ******* 
fakesink element
GstFakeSink
No state change errors
null-to-ready
ready-to-paused
paused-to-playing
playing-to-paused
paused-to-ready
ready-to-null
chain   ******* (%s:%s) (%u bytes, timestamp: %s, duration: %s, offset: %lli, offset_end: %lli, flags: %d %s) %p
message ******* (%s:%s) M (type: %d, %s) %p
Erroring out on state change as requested
The message describing current status
Send a signal before unreffing the buffer
Number of buffers to accept going EOS
Erik Walthinsen <omega@cse.ogi.edu>, Wim Taymans <wim@fluendo.com>, Mr. 'frag-me-more' Vanderwingo <wingo@fluendo.com>
Fail state change from NULL to READY
Fail state change from READY to PAUSED
Fail state change from PAUSED to PLAYING
Fail state change from PLAYING to PAUSED
Fail state change from PAUSED to READY
Fail state change from READY to NULL
marshal_VOID__MINIOBJECT_OBJECT
gst_fake_sink_change_state
gst_fake_sink_preroll
gst_fake_sink_render
fd://0
timeout
gst_fd_src_start
gst_fd_src_stop
gst_fd_src_unlock
gst_fd_src_unlock_stop
gst_fd_src_is_seekable
gst_fd_src_get_size
gst_fd_src_do_seek
gst_fd_src_query
gst_fd_src_create
gstfdsrc.c
read %i
poll on file descriptor: %s.
read on file descriptor: %s.
poll returned %d
GstFdSrcTimeout
Failed to allocate %u bytes
Read buffer of size %i
Error during poll
Poll stopped
Read 0 bytes. EOS.
Error reading from fd
No longer flushing
Flushing
fd://%d
Updating to fd %d
Setting size to fd %llu
marking fd %d as seekable
marking fd %d as NOT seekable
Read from a file descriptor
Source/File
Filedescriptor Source
size=
size=%llu
checking uri %s
found ?
parsing size failed
found size %llu
lseek returned %lli
system error: %s
fdsrc element
GstFdSrc
An open file descriptor to read from
Post a message after timeout microseconds (0 = disabled)
doing poll, timeout %u:%02u:%02u.%09u
fdset %p, old_fd %d, new_fd %d
poll timeout set to %u:%02u:%02u.%09u
state ready or lower, updating to use new fd
state above ready, not updating to new fd yet
Erik Walthinsen <omega@cse.ogi.edu>
gst_fd_src_uri_set_uri
gst_fd_src_set_property
gst_fd_src_update_fd
gst_fd_src_start
gst_fd_src_unlock
gst_fd_src_unlock_stop
gst_fd_src_do_seek
gst_fd_src_create
gst_fd_sink_query
gst_fd_sink_render
gst_fd_sink_start
gst_fd_sink_stop
gst_fd_sink_unlock
gst_fd_sink_unlock_stop
gst_fd_sink_event
gstfdsink.c
File descriptor %d is a pipe
fdsink->fd >= 0
wrote %d bytes, %d left
Error during select
Select stopped
Sink/File
Filedescriptor Sink
fdsink element
GstFdSink
An open file descriptor to write to
File descriptor %d is not valid: %s
File descriptor %d is seekable
going into select, have %d bytes to write
select on file descriptor: %s.
Error while writing to file descriptor %d: %s
writing %d bytes to file descriptor %d
Write data to a file descriptor
Error while seeking on file descriptor %d: %s
File descriptor %d to seek to position %llu
File descriptor %d failed to seek to position %llu
Ignored NEWSEGMENT event of format %u (%s)
gst_fd_sink_render
gst_fd_sink_render
gst_fd_sink_check_fd
gst_fd_sink_start
gst_fd_sink_unlock
gst_fd_sink_unlock_stop
gst_fd_sink_do_seek
gst_fd_sink_event
Seeking to offset %llu using fseeko
Error while seeking in file "%s".
Error while writing to file "%s".
Ignored NEWSEGMENT, no seek needed
No file name specified for writing.
Could not open file "%s" for writing.
change buffer size %u to %u, mode %d
Size of buffer in number of bytes for line or full buffer-mode
Append to an already existing file
Thomas Vander Stichele <thomas at apestaart dot org>
Changing the `location' property on filesink when a file is open is not supported.
gstfilesink.c
Flush failed: %s
Seeking failed: %s
writing %u bytes at %llu
Error closing file "%s".
closed file
warning: setvbuf failed: %s
opened file %s, seekable %d
Location of the file to write
GstFileSinkBufferMode
The buffering mode to use
Buffering mode
buffer-mode
Buffering size
buffer-size
Append
append
gst_file_sink_start
gst_file_sink_stop
gst_file_sink_query
gst_file_sink_render
gst_file_sink_event
Write stream to a file
File Sink
filename : %s
uri      : %s
file://localhost/
file://
filesink element
GstFileSink
Default buffering
default
Fully buffered
Line buffered
line
Unbuffered
unbuffered
gst_file_sink_set_location
gst_file_sink_open_file
gst_file_sink_close_file
gst_file_sink_render
gst_file_sink_do_seek
gst_file_sink_event
File-descriptor for the file being mmap()d
Size in bytes of mmap()d regions
Touch mmapped data regions to force them to be read from disk
Whether to use mmap() instead of read()
Whether to use madvise to hint to the kernel that access to mmap pages will be sequential
Optimise for sequential mmap access
Read from arbitrary point in a file
freeing mmap()d buffer at %llu+%u
unmapped region %08lx+%08lx at %p
Changing the `location' property on filesrc when a file is open is not supported.
Invalid URI '%s' for filesrc: %s
Invalid hostname '%s' for filesrc
invalid mapsize, must be a multiple of pagesize, which is %d
mmap (0x%08lx, %d, 0x%llx) failed: %s
mapping region %08llx+%08lx from file into memory
mapped region %08lx+%08lx from file into memory at %p
attempting to map a small buffer at %llu+%d
not on page boundaries, resizing to map to %llu+%d
attempting to read %08lx, %08lx, %08lx, %08lx
read buf %llu+%u lives in current mapbuf %u+%u, creating subbuffer of mapbuf
read buf %llu+%u starts in mapbuf %u+%u but ends outside, creating new mmap
read buf %llu+%d starts before mapbuf %d+%d, but overlaps it
searching for mapbuf to cover %llu+%d
read buf %llu+%d crosses a %d-byte boundary, creating a one-off
read buf %llu+%d in new mapbuf at %llu+%d, mapping and subbuffering
readsize smaller then mapsize %08x %d
Reading %d bytes at offset 0x%llx
No file name specified for reading.
Could not open file "%s" for reading.
disabling seeking, not in mmap mode and lseek failed: %s
File-descriptor
Location of the file to read
mmap() Block Size
mmapsize
Touch mapped region read data
touch
Use mmap to read data
use-mmap
sequential
gst_file_src_start
gst_file_src_stop
gst_file_src_is_seekable
gst_file_src_get_size
gst_file_src_create
gst_file_src_query
File Source
gstfilesrc.c
warning: madvise failed: %s
warning: munmap failed: %s
localhost
Invalid URI '%s' for filesrc
filesrc element
GstFileSrc
GST_IS_FILE_SRC (object)
GstMmapBuffer
offset >= 0
No such file "%s"
Could not get info on "%s".
"%s" is a directory.
File "%s" is a socket.
opening file %s
using mmap for file
gst_mmap_buffer_finalize
gst_file_src_uri_set_uri
gst_file_src_set_location
gst_file_src_set_property
gst_file_src_set_property
gst_file_src_get_property
gst_file_src_start
gst_file_src_create_read
gst_file_src_map_region
gst_file_src_map_region
gst_file_src_map_small_region
gst_file_src_create_mmap
Error iterating sinkpads
gstfunnel.c
gst_funnel_dispose
gst_funnel_request_new_pad
gst_funnel_release_pad
gst_funnel_change_state
releasing pad
received buffer %p
handled buffer %s
N-to-1 pipe fitting
Funnel pipe fitting
GstFunnelPad
direction
name
gst_funnel_sink_chain
gst_funnel_sink_event
gst_funnel_sink_getcaps
gst_funnel_sink_buffer_alloc
requesting pad
funnel element
GstFunnel
sink%d
Got buffer without segment, setting segment [0,inf[
Could not push out newsegment event
Olivier Crete <olivier.crete@collabora.co.uk>
gst_funnel_sink_chain
gst_funnel_request_new_pad
gst_funnel_release_pad
gst_funnel_src_event
Microseconds to sleep between processing
The Probability a buffer is dropped
(Re)timestamps buffers with number of bytes per second (0 = inactive)
Timestamp buffers and eat newsegments so as to appear as one segment
Verify that the stream is time- and data-contiguous. This only logs in the debug log.  This will be deprecated in favor of the check-imperfect-timestamp/offset properties.
Send element messages if timestamps and durations do not match up
Check for discontiguous timestamps
Send element messages if offset and offset_end do not match up
Check for discontiguous offset
gst_identity_prepare_output_buffer
Pass data without modification
%s   ******* (%s:%s) (%u bytes, timestamp: %s, duration: %s, offset: %lli, offset_end: % lli, flags: %d %s) %p
Buffer not time-contiguous with previous one: prev ts %u:%02u:%02u.%09u, prev dur %u:%02u:%02u.%09u, new ts %u:%02u:%02u.%09u (expected ts %u:%02u:%02u.%09u, delta=%c%u:%02u:%02u.%09u)
Failed after iterations as requested.
Buffer not data-contiguous with previous one: prev offset_end %lli, new offset %lli
can't check time-contiguity, no timestamp and/or duration were set on previous buffer
can't check data-contiguity, no offset_end was set on previous buffer
can't check offset contiguity, no offset and/or offset_end were set on previous buffer
Sleep time
sleep-time
Error after N buffers
Error After
error-after
Drop Probability
drop-probability
Single Segment
single-segment
Synchronize to pipeline clock
Synchronize
Check For Perfect Stream
check-perfect
check-imperfect-timestamp
check-imperfect-offset
gst_identity_change_state
gst_identity_event
gst_identity_transform_ip
gst_identity_start
gst_identity_stop
unlock clock wait
gstidentity.c
n_param_values == 2
cur-offset-end
cur-offset
cur-duration
cur-timestamp
prev-offset-end
prev-offset
prev-duration
prev-timestamp
dropping
identity element
GstIdentity
marshal_VOID__MINIOBJECT
gst_identity_change_state
gst_identity_event
gst_identity_check_imperfect_offset
gst_identity_check_imperfect_timestamp
gst_identity_check_perfect
gst_identity_transform_ip
Apeer latency min %u:%02u:%02u.%09u, max %u:%02u:%02u.%09u, live %d
total latency min %u:%02u:%02u.%09u, max %u:%02u:%02u.%09u, live %d
Pad is linked (to %s:%s), returning peer caps
gst_selector_pad_iterate_linked_pads
Synchronize inactive streams to the running time of the active stream
running time: %u:%02u:%02u.%09u
using start/stop of %u:%02u:%02u.%09u
setting stop_time to %u:%02u:%02u.%09u
setting start_time to %u:%02u:%02u.%09u
Checking acceptcaps of srcpad peer
templ->direction == GST_PAD_SINK
The currently active tags on the pad
If the pad is currently active
Make an inactive pad return OK instead of NOT_LINKED
Julien Moutte <julien@moutte.net>, Jan Schmidt <thaytan@mad.scientist.com>, Wim Taymans <wim.taymans@gmail.com>
Not selected, performing fallback allocation
Not selected, return NOT_LINKED
Waiting for active streams to advance. %u:%02u:%02u.%09u >= %u:%02u:%02u.%09u
Waited for active streams to advance. %u:%02u:%02u.%09u >= %u:%02u:%02u.%09u
received end time %u:%02u:%02u.%09u
received start time %u:%02u:%02u.%09u
pushing close NEWSEGMENT update %d, rate %lf, applied rate %lf, format %d, %lli -- %lli, time %lli
Buffers arrived before NEWSEGMENT event
pushing pending NEWSEGMENT update %d, rate %lf, applied rate %lf, format %d, %lli -- %lli, time %lli
Pad not active, discard buffer %p
We are flushing, discard buffer %p
configured NEWSEGMENT update %d, rate %lf, applied rate %lf, format %d, %lli -- %lli, time %lli
An input stream selector element
gstinputselector.c
Pad not linked, returning ANY
Getting caps of srcpad peer
gst_input_selector_getcaps
gst_input_selector_query
gst_input_selector_event
The number of sink pads
Number of Pads
n-pads
The currently active sink pad
Active pad
active-pad
Sync Streams
sync-streams
gst_input_selector_block
gst_input_selector_switch
switch already blocked
no active pad while blocking
setting active pad to %s:%s
New active pad is %P
Releasing pad %s:%s
Deactivating pad %s:%s
gst_selector_pad_event
gst_selector_pad_getcaps
gst_selector_pad_acceptcaps
gst_selector_pad_chain
gst_selector_pad_bufferalloc
Creating new pad %d
GstSelectorPad
Running time of stream on pad
Running time
Tags
tags
Active
Always OK
always-ok
return_value != NULL
n_param_values == 1
N-to-1 input stream selector
Input selector
Activating pad %s:%s
received alloc
getting active pad
Marking discont buffer %p
Forwarding buffer %p
received tags %P
forwarding event
self->blocked == TRUE
n_param_values == 4
GstInputSelector
gst_input_selector_marshal_INT64__VOID
gst_input_selector_marshal_VOID__OBJECT_INT64_INT64
gst_selector_pad_event
gst_selector_pad_getcaps
gst_selector_pad_acceptcaps
gst_input_selector_wait_running_time
gst_selector_pad_chain
gst_input_selector_activate_sinkpad
gst_selector_pad_bufferalloc
gst_input_selector_request_new_pad
gst_input_selector_request_new_pad
gst_input_selector_release_pad
gst_input_selector_block
gst_selector_pad_get_running_time
gst_input_selector_set_active_pad
gst_input_selector_switch
gst_input_selector_getcaps
gst_input_selector_query
using pad %s:%s for alloc
gstoutputselector.c
fallback buffer alloc
buffer alloc finished: %s
switching to pad %P
resending latest buffer
switch failed, pad not linked
pushing buffer to %P
src%d
Currently active src pad
Resend latest buffer
resend-latest
Pad negotiation mode
pad-negotiation-mode
1-to-N output stream selector
Output selector
replacing pending switch
pad already active
gst_output_selector_chain
Output stream selector
GstOutputSelector
None
setting last stop %u:%02u:%02u.%09u
newsegment handling failed in %P
Resend latest buffer after a switch to a new pad
GstOutputSelectorPadNegotiationMode
The mode to be used for pad negotiation
gst_output_selector_request_new_pad
gst_output_selector_release_pad
Stefan Kost <stefan.kost@nokia.com>
gst_output_selector_handle_sink_event
gst_output_selector_buffer_alloc
gst_output_selector_set_property
gst_output_selector_request_new_pad
gst_output_selector_release_pad
gst_output_selector_switch
gst_output_selector_chain
gst_output_selector_handle_sink_event
gst_output_selector_buffer_alloc
underrun
overrun
Max. size (kB)
max-size-bytes
Max. size (buffers)
max-size-buffers
Max. size (ns)
max-size-time
Extra Size (kB)
extra-size-bytes
Extra Size (buffers)
extra-size-buffers
Extra Size (ns)
extra-size-time
Use buffering
use-buffering
Low percent
low-percent
High percent
high-percent
Sync By Running Time
sync-by-running-time
gst_multi_queue_release_pad
gst_multi_queue_change_state
Waking up singlequeue %d
gstmultiqueue.c
flush %s queue %d
SingleQueue %d : pausing task
SingleQueue %d
Single Queue %d is full
Checking Queue %d
Queue %d is empty
Queue %d is filled
gst_multi_queue_chain
gst_multi_queue_sink_event
gst_multi_queue_getcaps
gst_multi_queue_acceptcaps
gst_multi_queue_bufferalloc
gst_multi_queue_src_event
gst_multi_queue_src_query
Returning pad %s:%s
name : %s (id %d)
Creating GstSingleQueue id:%d
Multiple data queue
buffering %d percent
filled %d percent
CHECKING sq->srcresult: %s
multiqueue element
GstMultiQueue
Max. amount of data in the queue (bytes, 0=disable)
Max. number of buffers in the queue (0=disable)
Max. amount of data in the queue (in ns, 0=disable)
Amount of data the queues can grow if one of them is empty (bytes, 0=disable) (NOT IMPLEMENTED)
Amount of buffers the queues can grow if one of them is empty (0=disable) (NOT IMPLEMENTED)
Amount of time the queues can grow if one of them is empty (in ns, 0=disable) (NOT IMPLEMENTED)
Emit GST_MESSAGE_BUFFERING based on low-/high-percent thresholds
Low threshold for buffering to start
High threshold for buffering to finish
Synchronize deactivated or not-linked streams by running time
gst_multi_queue_request_new_pad
queue %d: visible %u/%u, bytes %u/%u, time %llu/%llu
That pad doesn't belong to this element ???
Couldn't send query because we have no peer
SingleQueue %d : waking up eventually waiting task
SingleQueue %d : starting task
inspecting sq:%d , next_time:%u:%02u:%02u.%09u, last_time:%u:%02u:%02u.%09u, srcresult:%s
High time is now : %u:%02u:%02u.%09u, lowest non-linked %u:%02u:%02u.%09u
sq:%d is not waiting - ignoring
inspecting sq:%d , nextid:%d, oldid:%d, srcresult:%s
Highid is now : %u, lowest non-linked %u
Accept caps from the peer of this pad
Getting caps from the peer of this pad
Single Queue %d is empty, Checking other single queues
queue %d is filled, bumping its max visible to %d
All queues are empty, signalling it
Another queue is empty, bumping single queue %d max visible to %d
A queue is filled, signalling overrun
gst_multi_queue_sink_activate_push
gst_multi_queue_iterate_internal_links
gst_multi_queue_src_activate_push
GstSingleQueue [%d] created and pads added
Edward Hervey <edward@fluendo.com>
queue %d, sink %u:%02u:%02u.%09u, src %u:%02u:%02u.%09u
queue %d, last_stop updated to %u:%02u:%02u.%09u
SingleQueue %d : about to enqueue buffer %p with id %d
SingleQueue %d : exit because task paused, reason: %s
we are EOS, dropping buffer, return UNEXPECTED
queue %d, configured NEWSEGMENT %Q
queue %d sleeping for not-linked wakeup with newid %u, highid %u, next_time %u:%02u:%02u.%09u, high_time %u:%02u:%02u.%09u
queue %d woken from sleeping for not-linked wakeup with newid %u, highid %u, next_time %u:%02u:%02u.%09u, high_time %u:%02u:%02u.%09u
SingleQueue %d : Pushing buffer %p with ts %u:%02u:%02u.%09u
Unexpected object in singlequeue %d (refcounting problem?)
SingleQueue %d : trying to pop an object
SingleQueue %d : newid:%d , oldid:%d
BEFORE PUSHING sq->srcresult: %s
SingleQueue %d : Pushing event %p of type %s
AFTER PUSHING sq->srcresult: %s
SingleQueue[%d] task paused, reason:%s
SingleQueue %d : received flush start event
SingleQueue %d : received flush stop event
SingleQueue %d : Enqueuing event %p of type %s with id %d
we are EOS, dropping event, return FALSE
single_queue_check_full
single_queue_overrun_cb
single_queue_underrun_cb
gst_multi_queue_chain
gst_multi_queue_sink_event
gst_multi_queue_getcaps
gst_multi_queue_acceptcaps
wake_up_next_non_linked
compute_high_id
apply_segment
update_buffering
update_time_level
apply_buffer
gst_single_queue_push_one
compute_high_time
gst_multi_queue_loop
gst_single_queue_flush
gst_multi_queue_src_activate_push
gst_multi_queue_src_query
gst_single_queue_new
gst_multi_queue_request_new_pad
gst_multi_queue_release_pad
Can't adjust query in %s format, don't know how to adjust value
starting task as pad is linked
(%s:%s) signal DEL: %u of %u-%u buffers, %u of %u-%u bytes, %llu of %llu-%llu ns, %u items
sink %u:%02u:%02u.%09u, src %u:%02u:%02u.%09u
pushing accum newsegment event
not starting task as pad is not linked
(%s:%s) received flush start event: %u of %u-%u buffers, %u of %u-%u bytes, %llu of %llu-%llu ns, %u items
(%s:%s) signal ADD: %u of %u-%u buffers, %u of %u-%u bytes, %llu of %llu-%llu ns, %u items
(%s:%s) received flush stop event: %u of %u-%u buffers, %u of %u-%u bytes, %llu of %llu-%llu ns, %u items
(%s:%s) after flush: %u of %u-%u buffers, %u of %u-%u bytes, %llu of %llu-%llu ns, %u items
not re-starting task as pad is not linked
refusing event, we are flushing
initialized queue's not_empty & not_full conditions
Current amount of data in the queue (bytes)
Current number of buffers in the queue
Current amount of data in the queue (in ns)
Min. amount of data in the queue to allow reading (bytes, 0=disable)
Min. number of buffers in the queue to allow reading (0=disable)
Min. amount of data in the queue to allow reading (in ns, 0=disable)
Where the queue leaks, if at all
last_stop updated to %u:%02u:%02u.%09u
Unexpected item %p dequeued from queue %s (refcounting problem?)
retrieved buffer %p from queue
queue is full, leaking item %p on downstream end
received buffer %p of size %d, time %u:%02u:%02u.%09u, duration %u:%02u:%02u.%09u
Unknown leaky type, using default
(%s:%s) wait for DEL: %u of %u-%u buffers, %u of %u-%u bytes, %llu of %llu-%llu ns, %u items
(%s:%s) received DEL wakeup: %u of %u-%u buffers, %u of %u-%u bytes, %llu of %llu-%llu ns, %u items
(%s:%s) received DEL: %u of %u-%u buffers, %u of %u-%u bytes, %llu of %llu-%llu ns, %u items
queue is full, leaking buffer on upstream end
queue is full, waiting for free space
Could not mark buffer as DISCONT
exit because task paused, reason: %s
exit because we received UNEXPECTED
(%s:%s) wait for ADD: %u of %u-%u buffers, %u of %u-%u bytes, %llu of %llu-%llu ns, %u items
(%s:%s) received ADD wakeup: %u of %u-%u buffers, %u of %u-%u bytes, %llu of %llu-%llu ns, %u items
(%s:%s) received ADD: %u of %u-%u buffers, %u of %u-%u bytes, %llu of %llu-%llu ns, %u items
streaming task paused, reason %s (%d)
got UNEXPECTED from downstream
pushing pushable event %s after UNEXPECTED
pushed EOS event %p, return UNEXPECTED
exit because we have no item in the queue
dataflow inside the queue element
Leaky on upstream (new buffers)
Leaky on downstream (old buffers)
gstqueue.c
got event %p (%d)
queue linking source pad
not starting task reason %s
configured NEWSEGMENT %Q
pushing real newsegment event
loop stopped
got EOS from upstream
Apply segment on srcpad
refusing event, we are EOS
finalizing queue
running
pushing
Current level (kB)
current-level-bytes
Current level (buffers)
current-level-buffers
Current level (ns)
current-level-time
Min. threshold (kB)
min-threshold-bytes
Min. threshold (buffers)
min-threshold-buffers
Min. threshold (ns)
min-threshold-time
GstQueueLeaky
leaky
Don't emit queue signals
gst_queue_chain
gst_queue_sink_activate_push
gst_queue_handle_sink_event
gst_queue_link_sink
gst_queue_getcaps
gst_queue_acceptcaps
gst_queue_bufferalloc
gst_queue_src_activate_push
gst_queue_link_src
gst_queue_handle_src_event
gst_queue_handle_src_query
Simple data queue
retrieved event %p from queue
the queue is empty
queue is not full
exit because we received EOS
Internal data flow error.
queue is not empty
dropping UNEXPECTED buffer %p
dropping UNEXPECTED event %p
exit because we are flushing
pause task, reason:  %s
queue_dataflow
GstQueue
Not Leaky
downstream
queue_capacity_change
gst_queue_set_property
gst_queue_finalize
gst_queue_locked_enqueue_buffer
gst_queue_leak_downstream
gst_queue_chain
gst_queue_locked_enqueue_event
gst_queue_locked_flush
gst_queue_handle_sink_event
gst_queue_src_activate_push
gst_queue_push_newsegment
apply_segment
update_time_level
apply_buffer
gst_queue_locked_dequeue
gst_queue_push_one
gst_queue_loop
gst_queue_link_src
gst_queue_handle_src_event
gst_queue_handle_src_query
gst_queue_init
found range for %llu: [%llu-%llu]
range [%llu-%llu] (rb [%llu-%llu]), reading %llu current range? %s
updating max_reading_pos from %llu to %llu
buffer %u in group %u has size %u
buffer %u in group %u has ts %u:%02u:%02u.%09u duration %u:%02u:%02u.%09u
(%s:%s) signal ADD: %u of %u buffers, %u of %u bytes, %llu of %llu ns, %llu items
insert before range %p, offset %llu
reading %llu, writing %llu, level %llu
(%s:%s) wait for ADD: %u of %u buffers, %u of %u bytes, %llu of %llu ns, %llu items
(%s:%s) received ADD wakeup: %u of %u buffers, %u of %u bytes, %llu of %llu ns, %llu items
(%s:%s) received ADD: %u of %u buffers, %u of %u bytes, %llu of %llu ns, %llu items
(%s:%s) signal DEL: %u of %u buffers, %u of %u bytes, %llu of %llu ns, %llu items
looking for offset %llu, len %u
switching ranges, do seek to range position
we have a range %p, offset %llu, writing_pos %llu
Need more data (%llu bytes more)
requested data is within range, wait for data
ring buffer full, reading ring-buffer-max-size %llu bytes
EOS hit but read %llu bytes that we have
EOS hit and we don't have any requested data
protecting cached data [%llu-%llu]
Reading %d bytes from offset %llu
Getting range: offset %llu, length %u
received NEWSEGMENT update %d, rate %lf, applied rate %lf, format %d, %lli -- %lli, time %lli
(%s:%s) wait for DEL: %u of %u buffers, %u of %u bytes, %llu of %llu ns, %llu items
(%s:%s) received DEL wakeup: %u of %u buffers, %u of %u bytes, %llu of %llu ns, %llu items
(%s:%s) received DEL: %u of %u buffers, %u of %u bytes, %llu of %llu ns, %llu items
Error while writing to download file.
Removing range: offset %llu, wpos %llu
advancing offsets from %llu (%llu) to %llu (%llu)
writing %u bytes to range [%llu-%llu] (rb wpos %llu)
checking merge with next range %llu < %llu
wrote %u bytes to %llu (%u bytes remaining to write)
gst_queue2_src_checkgetrange_function
Estimate the bitrate of the stream to calculate time level
Low threshold for buffering to start. Only used if use-buffering is True
High threshold for buffering to finish. Only used if use-buffering is True
File template to store temporary files in, should contain directory and XXXXXX. (NULL == disabled)
Location to store temporary files in (Deprecated: Only read this property, use temp-template to configure the name template)
Remove the temp-location after use
Max. amount of data in the ring buffer (bytes, 0 = disabled)
setting temp-template property in wrong state
Erik Walthinsen <omega@cse.ogi.edu>, Wim Taymans <wim.taymans@gmail.com>
max bytes %u, rb size %llu, cur bytes %u
dropping query in %s format, don't know how to adjust value
range starting at %lli and finishing at %lli
rates: out %f, time %u:%02u:%02u.%09u
rates: in %f, time %u:%02u:%02u.%09u
rates: period %f, in %llu, global period %f
Could not create temp file "%s".
no temp file, cannot activate pull mode
writing buffer %u in group %u of size %u bytes
create_write() returned FALSE, bailing out
retrieved buffer list %p from queue
dropping UNEXPECTED buffer list %p
queue is empty, waiting for new data
Unexpected item %p added in queue %s (refcounting problem?)
Unexpected event of kind %s can't be added in temp file of queue %s 
total size of buffer list: %u bytes
gstqueue2.c
no range for %llu
**y**
  n  
ts now %u:%02u:%02u.%09u
upstream size: %lli
got event %p (%s)
find range for %llu
reusing range %llu-%llu
new range %llu-%llu
Seeking to %llu
Reading %u bytes from %llu
cur_level.bytes %u (max %llu)
not found in any range
wait for data
waiting for add
read %u bytes
non-regular file hits EOS
%u bytes left to read
we have a read error
adjusting length downto %d
read beyond end of file
deactivating push mode
clean queue ranges
init queue ranges
flushing temp file
Writing %u bytes to %llu
merging ranges %llu
writing %u bytes
gst_queue2_chain
gst_queue2_chain_list
gst_queue2_sink_activate_push
gst_queue2_handle_sink_event
gst_queue2_getcaps
gst_queue2_acceptcaps
gst_queue2_bufferalloc
gst_queue2_src_activate_pull
gst_queue2_src_activate_push
gst_queue2_get_range
gst_queue2_handle_src_event
gst_queue2_handle_src_query
Use Rate Estimate
use-rate-estimate
Temporary File Template
temp-template
Temporary File Location
temp-location
Remove the Temporary File
temp-remove
Max. ring buffer size (bytes)
ring-buffer-max-size
gst_queue2_change_state
gst_queue2_handle_query
Queue 2
doing peer query
peer query success
query buffering
buffering forwarded to peer
estimated %lli, left %lli
duration %lli, writing %lli
failed peer query
rates: period %f, out %llu
No Temp directory specified.
opening temp file %s
opened temp file %s
temp file was already open
deactivating pull mode
closing temp file
we have EOS
received flush start event
received flush stop event
queue is flushing
received buffer list %p
queue2_dataflow
GstQueue2
gst_queue2_set_temp_template
gst_queue2_set_property
gst_queue2_finalize
gst_queue2_close_temp_location_file
gst_queue2_chain
gst_queue2_is_filled
gst_queue2_wait_free_space
gst_queue2_chain_buffer_or_buffer_list
gst_queue2_chain_list
gst_queue2_sink_activate_push
update_in_rates
gst_queue2_create_write
buffer_list_create_write
gst_queue2_locked_enqueue
gst_queue2_flush_temp_file
gst_queue2_locked_flush
gst_queue2_handle_sink_event
clean_ranges
init_ranges
gst_queue2_open_temp_location_file
gst_queue2_src_activate_pull
gst_queue2_dequeue_on_unexpected
update_buffering
update_out_rates
buffer_list_apply_time
apply_buffer_list
apply_segment
update_time_level
apply_buffer
buffer_list_calc_size
gst_queue2_locked_dequeue
gst_queue2_push_one
gst_queue2_loop
gst_queue2_src_activate_push
update_cur_pos
gst_queue2_read_data_at_offset
debug_ranges
add_range
perform_seek_to_offset
find_range
gst_queue2_have_data
gst_queue2_create_read
gst_queue2_update_upstream_size
gst_queue2_get_range
gst_queue2_handle_src_event
gst_queue2_handle_src_query
gst_queue2_init
>(knN
	@Tee cannot operate in push mode with has-chain==FALSE
chain-list   ******* (%s:%s)t %p
chain        ******* (%s:%s)t (%d bytes, %llu) %p
Pushing item %p yielded result %s
there are no pads, return not-linked
warning failed to activate request pad
Cannot activate in pull mode, pull-mode set to NEVER
Cannot activate multiple src pads in pull mode, pull-mode set to SINGLE
Failed to %sactivate sink pad in pull mode
tee will never implement has-sink-loop==TRUE
Tried to set alloc pad %s which is not my pad
If the element should spawn a thread (unimplemented and deprecated)
If the element can operate in push mode
The pad used for gst_pad_alloc_buffer
Only one src pad can be active in pull mode
gsttee.c
Starting to push %s %p
pad already pushed with %s
pad list changed
Replacing ret val %d with %d
received error %s
received list %p
handled list %s
try alloc on pad %s:%s
we have a buffer on pad %s:%s
finding pad for alloc
got return value %d
pad list changed, restart
gst_pad_proxy_setcaps
gst_pad_proxy_getcaps
gst_tee_sink_acceptcaps
gst_tee_buffer_alloc
gst_tee_sink_activate_push
gst_tee_chain
gst_tee_chain_list
gst_tee_src_activate_pull
gst_tee_src_check_get_range
gst_tee_src_get_range
The number of source pads
Num Src Pads
num-src-pads
Has Sink Loop
has-sink-loop
Has Chain
has-chain
GstTeePullMode
Behavior of tee in pull mode
Pull mode
pull-mode
Allocation Src Pad
alloc-pad
gst_tee_request_new_pad
gst_tee_release_pad
1-to-N pipe fitting
Tee pipe fitting
tee-push-data
tee element
GstTee
Never activate in pull mode
never
single
gst_tee_set_property
gst_tee_src_activate_pull
gst_tee_src_check_get_range
gst_tee_request_new_pad
gst_tee_release_pad
gst_tee_find_buffer_alloc
gst_tee_buffer_alloc
gst_tee_sink_activate_push
gst_tee_chain
gst_tee_handle_data
gst_tee_chain_list
gst_type_find_element_setcaps
gst_type_find_element_chain
sending cached %s event
gsttypefindelement.c
 and pushing cached buffers
stopping typefinding%s
Stream contains no data.
Can't typefind empty stream
got %s event in mode %d
Got EOS and no type found yet
Saving %s event to send later
handling buffer in mode %d
Pushing store: %d
finding extension of %s
found extension %s
failed to query peer uri
could not parse the peer uri
starting typefinding
find type in pull mode
Already managed to typefind !
minimum
maximum
force caps
force-caps
have-type
found caps %P, probability=%u
TypeFind
type finding element
GstTypeFindElement
gst_type_find_element_activate
gst_type_find_element_handle_event
gst_type_find_element_activate_src_pull
gst_type_find_element_checkgetrange
gst_type_find_element_getrange
gst_type_find_element_src_event
gst_type_find_handle_src_query
%s cannot work in push mode. The operation is not supported with this source element or protocol.
Downstream pad %s:%s has no chainfunction, and the upstream element does not support pull mode
upstream only supports push mode, while downstream element only works in pull mode, erroring out
not enough data for typefinding yet (%u bytes)
no caps found with %u bytes of data, waiting for more data
found caps %P, but probability is %u which is lower than the required minimum of %u
waiting for more data to try again
Skipping typefinding, using caps from upstream buffer: %P
could not find uri extension in %s
Could not query upstream length!
detected capabilities in stream
minimum probability required to accept caps
probability to stop typefinding (deprecated; non-functional)
force caps without doing a typefind
gst_type_find_element_have_type
gst_type_find_element_change_state
Benjamin Otte <in7y118@public.uni-hamburg.de>
Finds the media type of a stream
gst_type_find_element_have_type
gst_type_find_get_extension
start_typefinding
gst_type_find_element_activate
gst_type_find_element_setcaps
gst_type_find_element_chain_do_typefinding
gst_type_find_element_chain
gst_type_find_element_send_cached_events
stop_typefinding
gst_type_find_element_handle_event
gst_valve_getcaps
gst_valve_chain
gst_valve_event
gst_valve_buffer_alloc
Drop buffers and events
drop
Valve element
gstvalve.c
GstValve
Whether to drop buffers and events or let them through
Drops buffers and events or lets them through
;*2$"
libgstcoreelements.so.debug
7zXZ
T5{|pz=
H^aE?
}rf7
:eS~
HO0K
!f:'
-xx_
Xtm1
CG|.
L9'-
XeVqK
pK&]
yoHr
Qn^Zf
3Tu42{
~;~-]
wM|\l#}
jb|]l7
pA<S
[AvQ
91R7e8
2sIr
~>eY
Bum+-n
#@1$H
g<<h
 :)L
K"Q6
(5sc2
u-Pc
{ff:&
f-	0
iHdI0
b/Jo
I.GOE
Z,_Pa
4{m6
P#pu_
>QU'
,d23y
h|+f
(DFsO
k;(eQv
o^IA
M>i$qP{
-|%L
^o&j
*$01
KZQd
tSLF*
.mz@
~XY%sS
us=B`|
k~by
6D @\
i|]l
L&sV}
(r!x0	2
M2me(
+l>i
+Uw1
NHx%
<<f-
.shstrtab
.note.gnu.build-id
.gnu.hash
.dynsym
.dynstr
.gnu.version
.gnu.version_r
.rel.dyn
.rel.plt
.init
.plt.got
.text
.fini
.rodata
.eh_frame_hdr
.eh_frame
.init_array
.fini_array
.jcr
.data.rel.ro
.dynamic
.got.plt
.data
.bss
.gnu_debuglink
.gnu_debugdata
