FlP9Y
	H	 
rUVW
)Vr8
l72%
	Gl.
E1:]
nD	BE
Z.kX
__gmon_start__
_fini
_ITM_deregisterTMCloneTable
_ITM_registerTMCloneTable
__cxa_finalize
_Jv_RegisterClasses
xdr_Ganglia_extra_data
xdr_string
xdr_Ganglia_value_types
xdr_enum
xdr_Ganglia_metadata_message
xdr_array
xdr_u_int
xdr_Ganglia_metric_id
xdr_bool
xdr_Ganglia_metadatadef
xdr_Ganglia_metadatareq
xdr_Ganglia_gmetric_ushort
xdr_u_short
xdr_Ganglia_gmetric_short
xdr_short
xdr_Ganglia_gmetric_int
xdr_int
xdr_Ganglia_gmetric_uint
xdr_Ganglia_gmetric_string
xdr_Ganglia_gmetric_float
xdr_float
xdr_Ganglia_gmetric_double
xdr_double
xdr_Ganglia_msg_formats
xdr_Ganglia_metadata_msg
xdr_Ganglia_value_msg
xdr_Ganglia_25metric
xdr_pointer
become_a_nobody
getpwnam
getuid
setuid
err_quit
debug_msg
debug_level
stderr
__vfprintf_chk
fputc
set_debug_msg_level
get_debug_msg_level
update_pidfile
fopen
fscanf
fclose
umask
unlink
getpid
__fprintf_chk
getpgid
err_msg
__errno_location
strerror
slurpfile
read
realloc
err_ret
malloc
timediff
update_file
gettimeofday
skip_whitespace
__ctype_b_loc
skip_token
getenv
snprintf
dotconf_warning
__vsnprintf_chk
__stack_chk_fail
dotconf_substitute_env
strlen
__strdup
strncat
dotconf_register_options
dotconf_callback
dotconf_continue_line
fgets
strcpy
dotconf_get_next_line
dotconf_get_here_document
__xstat
memset
strncmp
dotconf_invoke_command
dotconf_read_arg
dotconf_find_command
dotconf_set_command
calloc
sscanf
dotconf_free_command
dotconf_handle_command
dotconf_command_loop_until_error
dotconf_command_loop
dotconf_create
access
strncasecmp
dotconf_cleanup
dotconf_is_wild_card
dotconf_wild_card_cleanup
dotconf_find_wild_card
strncpy
dotconf_strcmp_from_back
dotconf_question_mark_match
dotconf_star_match
dotconf_handle_star
__strncpy_chk
opendir
readdir
strstr
__strcat_chk
__snprintf_chk
strcmp
__strcpy_chk
dotconf_handle_wild_card
closedir
dotconf_handle_question_mark
daemon_proc
stdout
fflush
fputs
__syslog_chk
ganglia_quiet_errors
err_quiet
err_verbose
err_sys
err_dump
abort
strtol
strchr
gexec_errno
strtod
llist_add
gexec_cluster_free
gexec_cluster
g_tcp_socket_connect
XML_ParserCreate
time
XML_SetElementHandler
XML_SetUserData
XML_GetBuffer
XML_ParserFree
g_tcp_socket_delete
XML_ParseBuffer
llist_sort
XML_GetErrorCode
XML_ErrorString
XML_GetCurrentLineNumber
memcpy
datum_new
datum_free
hash_create
pthread_rdwr_init_np
hash_get_flags
hash_set_flags
hashval
__ctype_tolower_loc
hash_keycmp
hash_insert
pthread_rdwr_wlock_np
pthread_rdwr_wunlock_np
hash_lookup
pthread_rdwr_rlock_np
pthread_rdwr_runlock_np
hash_delete
hash_destroy
hash_walkfrom
hash_foreach
g_gethostbyname
inet_aton
gethostbyname_mutex
pthread_mutex_lock
pthread_mutex_unlock
g_gethostbyaddr
g_inetaddr_new
g_inetaddr_ref
g_inetaddr_unref
g_inetaddr_delete
g_inetaddr_get_port
g_inetaddr_set_port
g_inetaddr_is_multicast
g_inetaddr_get_interface_to
socket
getsockname
g_inetaddr_list_interfaces
ioctl
llist_remove
llist_search
llist_print
my_inet_ntop
pthread_mutex_init
pthread_cond_init
pthread_cond_wait
pthread_cond_signal
pthread_cond_broadcast
g_tcp_socket_new
g_tcp_socket_server_new_interface
setsockopt
g_tcp_socket_server_new
g_tcp_socket_server_accept
__fdelt_chk
select
apr_sockaddr_info_get
apr_socket_create
apr_socket_opt_set
apr_socket_bind
apr_socket_close
apr_socket_addr_get
apr_sockaddr_vars_set
if_nametoindex
apr_socket_connect
apr_gethostname
apr_sockaddr_ip_buffer_get
apr_inet_ntop
memmove
create_udp_client
create_udp_server
create_tcp_server
apr_socket_listen
join_mcast
apr_pool_create_ex
apr_os_sock_get
apr_pool_destroy
create_mcast_client
apr_mcast_hops
create_mcast_server
apr_strnatcasecmp
Ganglia_default_collection_groups
build_default_gmond_configuration
apr_pstrdup
apr_pstrcat
Ganglia_pool_create
libgmond_apr_lib_initialized
apr_initialize
apr_terminate
Ganglia_pool_destroy
Ganglia_gmond_config_create
cfg_tilde_expand
cfg_init
cfg_parse
cfg_parse_buf
Ganglia_udp_send_channels_create
cfg_size
apr_array_make
apr_array_push
cfg_getnsec
cfg_getstr
cfg_getint
cfg_getbool
Ganglia_udp_send_message
apr_socket_send
Ganglia_metric_create
apr_palloc
apr_table_make
Ganglia_metadata_send_real
apr_table_elts
__ctype_toupper_loc
strcasecmp
xdrmem_create
Ganglia_metadata_send
Ganglia_value_send_real
Ganglia_value_send
Ganglia_metric_send
Ganglia_metric_destroy
check_value
Ganglia_metric_set
Ganglia_metadata_add
apr_table_add
cstr_to_slope
slope_to_cstr
has_wildcard
cfg_error
strrchr
apr_temp_dir_get
apr_psprintf
apr_file_mktemp
fnmatch
apr_file_puts
cfg_include
apr_file_close
libdl.so.2
libnsl.so.1
libpcre.so.1
libexpat.so.1
libconfuse.so.0
libapr-1.so.0
libpthread.so.0
libc.so.6
__cxa_atexit
_edata
__bss_start
_end
libganglia-3.3.7.so.0
/usr/lib64
GLIBC_2.3.2
GLIBC_2.2.5
GLIBC_2.14
GLIBC_2.15
GLIBC_2.4
GLIBC_2.3.4
GLIBC_2.3
fffff.
ffff.
ffffff.
t$(H
T$0H
L$8L
D$@L
L$Ht7
)D$P
)L$`
)T$p
[]A\
AUATUSH
HcT$
[]A\A]A^A_
ffffff.
ffff.
ffff.
[]A\
fff.
|$ L
L$ L
AVAUATUSH
l$ H
}trH
[]A\A]A^A_
H+T$
fff.
Hco(H
gfff
Hck(H
ffffff.
ATUSH
[]A\
ATUH
\$0H
t]Hc
[]A\A]
fff.
AVAUATUSH
D$0H
T$(H
|$(L
l$(H
L;t$
 t:E
l$(E
[]A\A]A^A_
D$(A
l$(A
D$(H
AUE1
ATUSH
]A\A]A^H
[]A\A]A^A_
AWAVAUI
C Hc
H+t$
C Ic
8 ~`A
([]A\A]A^A_
H+t$
ffff.
t$(1
A9\$(
|$ A\
fffff.
AVAUL
ATUH
D$0H
t$(H
|$(L
d$(M
d$(E1
C Ic
T$(H
L$0H
T$8H
|$0H
|$0M
[]A\A]A^A_
t$0H
|$0I
t$ H
fff.
fffff.
AWAVI
uOLct$
[]A\A]A^A_
Lct$
fff.
AUATI
[]A\A]
[]A\A]
AUATUH
tPE9
|)Ic
;.u$
[]A\A]
[]A\A]A^
AWAVI
AUATUH
u*Ic
[]A\A]A^A_
AWAVI
AUATUSH
|$PH
t$8dH
|$8B
|$8H
t$ H
L$@D
D9D$L
D$XH
D$ I
;T$@
D$ H
L$8H
|$0H
|$0H
t$0H
|$0L
D$xH
L$pH
T$hH
T$ xD
t$gL
D$xH
L$pH
T$hH
t$pH
L$8H
|$0L
T$PH
|$0H
L$PL
D$PH
[]A\A]A^A_
|$0Ic
D$PL
D$0H
L$PD
t$pH
<?t 
AVAUI
ATUH
|$(H
T$8D
9L$@Hc
T$89T$D
D$HL
t$pL
L$(H
t$0H
|$ H
t$ H
|$ L
D$hH
L$`H
T$XH
t$WL
D$hL
L$`H
t$`H
[]A\A]A^A_
L$(H
t$0L
|$ H
|$ H
LcD$D
|$ H
D$ H
D$WL
L$ H
t$`H
fffff.
D$8H
L$0H
T$(H
t$'H
t$'L
D$8H
L$0H
|$(H
\$HH
l$PL
d$XL
l$`L
t$hL
|$pH
D$XH
ffff.
t$(H
T$0H
L$8L
D$@L
L$Ht7
)D$P
)L$`
)T$p
ffffff.
t$(H
T$0H
L$8L
D$@L
L$Ht7
)D$P
)L$`
)T$p
ffff.
t$(H
T$0H
L$8L
D$@L
L$Ht7
)D$P
)L$`
)T$p
t$(H
T$0H
L$8L
D$@L
L$Ht7
)D$P
)L$`
)T$p
t$(H
T$0H
L$8L
D$@L
L$Ht7
)D$P
)L$`
)T$p
fff.
8Ou%
l$ L
t$(L
|$0H
|$@L
unresolvH
unspecifH
fffff.
[]A\
[]A\
l$ L
t$(L
|$0H
fff.
ATUH
[]A\A]
[]A\A]
fff.
fff.
tnUSH
fff.
AWAVI
AUATI
[]A\A]A^A_
AUATI
[]A\A]
[]A\A]
AVAUATI
]A\A]A^
]A\A]A^
AUATE1
t`f.
[]A\A]
ffffff.
AWAVAUI
ATUSH
[]A\A]A^A_
AWAVI
AUATUSH
[]A\A]A^A_
d$ L
l$(L
t$0H
l$ H
fff.
D$(1
T$(dH3
\$0H
l$8L
d$@H
fffff.
ffff.
D$(1
T$(dH3
AUATUSH
D$81
toLc
D$ H
D$(1
t5Lcl$
T$8dH3
@[]A\A]A^
D$(I
t8H9
ffff.
[]A\A]
[]A\A]
ATUH
fff.
ATUH
fff.
fff.
fff.
D$(1
T$(dH3
AVAUATUH
[]A\A]A^
l$ L
d$(L
l$0H
l$HH
\$@L
d$PH
L$$1
fff.
|$ H
t$ H
HcJ(
ffff.
|$ 1
L$ H
|$(E1
T$0H
D$8H
T$P1
L$0A
D$0t,H
T$P1
L$01
L$@A
l$ L
t$(L
|$0H
fff.
t$ H
l$ H
l$ H
ffffff.
AWAVAUATUSH
t$ H
|$0H
|$(A
D9t$8H
|$ H
t$0H
|$H1
|$HA
T$<H
D$(H
X[]A\A]A^A_
T$<H
~wLc
A;\$
l$ L
d$(L
l$0L
t$8L
|$@H
ATUS
AWAVAUATUH
T$`H
T$hH
T$pH
T$xH
D$PH
D$HH
t$@H
[]A\A]A^A_
D$PH
D$HL
D$HH
AWAVAUATUH
D$HH
D$PE9e
t$pH
t$@H
[]A\A]A^A_
D$HH
ffff.
fffff.
fff.
T$PD
T$XI
\$(H
l$0L
d$8L
l$@H
$t{H
$tUH
$t/H
<[tS
!<*t-<?t)H
!tjH
T$0I
gmond.tmI
p.XXXXXXH
T$(H
t$ H
D$(H
T$(H
user '%s' does not exist
exiting. setuid '%s' error
Must be root to setuid to "%s"
daemon already running: %s pid %ld
Error writing pidfile '%s' -- %s
slurpfile() open() error on file %s
slurpfile() read() error on file %s
slurpfile() read() buffer overflow on file %s
update_file() got an error from slurpfile() reading %s
.ADC_INCLUDEPATH
%s:%ld: 
Unbalanced '{'
Unterminated here-document!
Unknown Config-Option: '%s'
%s%s%s
Include
IncludePath
[dotconf] Parse error. Unexpected end of file at line %ld in file %s
[emerg] could not stat currently read file (%s)
Missing argument to option '%s'
Error opening configuration file '%s'
Error occured while processing wildcard %c
Filename is '%s'
Cannot open %s for inclusion.
IncludePath is '%s'
Absolute filename too long (>%d)
Error occured while attempting to process %s for inclusion.
IncludePath is '%s'
: %s
CLUSTER
LOCALTIME
METRIC
cpu_num
load_one
load_five
load_fifteen
proc_run
proc_total
cpu_user
cpu_nice
cpu_system
cpu_idle
cpu_wio
gexec
Connected to socket %s:%d
Created the XML Parser
Got the XML Buffer
Read %d bytes of data
gexec_cluster() XML_ParseBuffer() error at line %d:
hash_create size = %d
hash->size is %d
hash->node[i] malloc error
hash malloc error in hash_create()
hash->node malloc error. freeing hash.
tcp_listen() setsockopt() SO_REUSEADDR error
tcp_listen() setsockopt() SO_KEEPALIVE error
tcp_listen() setsockopt() TCP_NODELAY error
Warning: your operating system does not support IPV6_V6ONLY!
This means that you are also listening to IPv4 traffic on port %d
This IPv6=>IPv4 mapping may be a security risk.
/* Each metrics module that is referenced by gmond must be specified and
   loaded. If the module has been statically linked with gmond, it does
   not require a load path. However all dynamically loadable modules must
   include a load path. */
modules {
  module {
    name = "core_metrics"
  module {
    name = "cpu_module"
    path = "modcpu.so"
  module {
    name = "disk_module"
    path = "moddisk.so"
  module {
    name = "load_module"
    path = "modload.so"
  module {
    name = "mem_module"
    path = "modmem.so"
  module {
    name = "net_module"
    path = "modnet.so"
  module {
    name = "proc_module"
    path = "modproc.so"
  module {
    name = "sys_module"
    path = "modsys.so"
/* The old internal 2.5.x metric array has been replaced by the following
   collection_group directives.  What follows is the default behavior for
   collecting and sending metrics that is as close to 2.5.x behavior as
   possible. */
/* This collection group will cause a heartbeat (or beacon) to be sent every
   20 seconds.  In the heartbeat is the GMOND_STARTED data which expresses
   the age of the running gmond. */
collection_group {
  collect_once = yes
  time_threshold = 20
  metric {
    name = "heartbeat"
/* This collection group will send general info about this host every
   1200 secs.
   This information doesn't change between reboots and is only collected
   once. */
collection_group {
  collect_once = yes
  time_threshold = 1200
  metric {
    name = "cpu_num"
    title = "CPU Count"
  metric {
    name = "cpu_speed"
    title = "CPU Speed"
  metric {
    name = "mem_total"
    title = "Memory Total"
  /* Should this be here? Swap can be added/removed between reboots. */
  metric {
    name = "swap_total"
    title = "Swap Space Total"
  metric {
    name = "boottime"
    title = "Last Boot Time"
  metric {
    name = "machine_type"
    title = "Machine Type"
  metric {
    name = "os_name"
    title = "Operating System"
  metric {
    name = "os_release"
    title = "Operating System Release"
  metric {
    name = "location"
    title = "Location"
/* This collection group will send the status of gexecd for this host
   every 300 secs.*/
/* Unlike 2.5.x the default behavior is to report gexecd OFF. */
collection_group {
  collect_once = yes
  time_threshold = 300
  metric {
    name = "gexec"
    title = "Gexec Status"
/* This collection group will collect the CPU status info every 20 secs.
   The time threshold is set to 90 seconds.  In honesty, this
   time_threshold could be set significantly higher to reduce
   unneccessary  network chatter. */
collection_group {
  collect_every = 20
  time_threshold = 90
  /* CPU status */
  metric {
    name = "cpu_user"
    value_threshold = "1.0"
    title = "CPU User"
  metric {
    name = "cpu_system"
    value_threshold = "1.0"
    title = "CPU System"
  metric {
    name = "cpu_idle"
    value_threshold = "5.0"
    title = "CPU Idle"
  metric {
    name = "cpu_nice"
    value_threshold = "1.0"
    title = "CPU Nice"
  metric {
    name = "cpu_aidle"
    value_threshold = "5.0"
    title = "CPU aidle"
  metric {
    name = "cpu_wio"
    value_threshold = "1.0"
    title = "CPU wio"
  /* The next two metrics are optional if you want more detail...
     ... since they are accounted for in cpu_system.
  metric {
    name = "cpu_intr"
    value_threshold = "1.0"
    title = "CPU intr"
  metric {
    name = "cpu_sintr"
    value_threshold = "1.0"
    title = "CPU sintr"
  */
collection_group {
  collect_every = 20
  time_threshold = 90
  /* Load Averages */
  metric {
    name = "load_one"
    value_threshold = "1.0"
    title = "One Minute Load Average"
  metric {
    name = "load_five"
    value_threshold = "1.0"
    title = "Five Minute Load Average"
  metric {
    name = "load_fifteen"
    value_threshold = "1.0"
    title = "Fifteen Minute Load Average"
/* This group collects the number of running and total processes */
collection_group {
  collect_every = 80
  time_threshold = 950
  metric {
    name = "proc_run"
    value_threshold = "1.0"
    title = "Total Running Processes"
  metric {
    name = "proc_total"
    value_threshold = "1.0"
    title = "Total Processes"
/* This collection group grabs the volatile memory metrics every 40 secs and
   sends them at least every 180 secs.  This time_threshold can be increased
   significantly to reduce unneeded network traffic. */
collection_group {
  collect_every = 40
  time_threshold = 180
  metric {
    name = "mem_free"
    value_threshold = "1024.0"
    title = "Free Memory"
  metric {
    name = "mem_shared"
    value_threshold = "1024.0"
    title = "Shared Memory"
  metric {
    name = "mem_buffers"
    value_threshold = "1024.0"
    title = "Memory Buffers"
  metric {
    name = "mem_cached"
    value_threshold = "1024.0"
    title = "Cached Memory"
  metric {
    name = "swap_free"
    value_threshold = "1024.0"
    title = "Free Swap Space"
collection_group {
  collect_every = 40
  time_threshold = 300
  metric {
    name = "bytes_out"
    value_threshold = 4096
    title = "Bytes Sent"
  metric {
    name = "bytes_in"
    value_threshold = 4096
    title = "Bytes Received"
  metric {
    name = "pkts_in"
    value_threshold = 256
    title = "Packets Received"
  metric {
    name = "pkts_out"
    value_threshold = 256
    title = "Packets Sent"
/* Different than 2.5.x default since the old config made no sense */
collection_group {
  collect_every = 1800
  time_threshold = 3600
  metric {
    name = "disk_total"
    value_threshold = 1.0
    title = "Total Disk Space"
collection_group {
  collect_every = 40
  time_threshold = 180
  metric {
    name = "disk_free"
    value_threshold = 1.0
    title = "Disk Space Available"
  metric {
    name = "part_max_used"
    value_threshold = 1.0
    title = "Maximum Disk Space Used"
include ("/etc/ganglia/conf.d/*.conf")
/* This configuration is as close to 2.5.x default behavior as possible
   The values closely match ./gmond/metric.h definitions in 2.5.x */
globals {
  daemonize = yes
  setuid = yes
  user = ganglia
  debug_level = 0
  max_udp_msg_len = 1472
  mute = no
  deaf = no
  allow_extra_data = yes
  host_dmax = 86400 /*secs. Expires (removes from web interface) hosts in 1 day */
  host_tmax = 20 /*secs */
  cleanup_threshold = 300 /*secs */
  gexec = no
  send_metadata_interval = 0 /*secs */
 * The cluster attributes specified will be used as part of the <CLUSTER>
 * tag that will wrap all hosts collected by this instance.
cluster {
  name = "unspecified"
  owner = "unspecified"
  latlong = "unspecified"
  url = "unspecified"
/* The host section describes attributes of the host, like the location */
host {
  location = "unspecified"
/* Feel free to specify as many udp_send_channels as you like.  Gmond
   used to only support having a single channel */
udp_send_channel {
  #bind_hostname = yes # Highly recommended, soon to be default.
                       # This option tells gmond to use a source address
                       # that resolves to the machine's hostname.  Without
                       # this, the metrics may appear to come from any
                       # interface and the DNS names associated with
                       # those IPs will be used to create the RRDs.
  mcast_join = 239.2.11.71
  port = 8649
  ttl = 1
/* You can specify as many udp_recv_channels as you like as well. */
udp_recv_channel {
  mcast_join = 239.2.11.71
  port = 8649
  bind = 239.2.11.71
  retry_bind = false
/* You can specify as many tcp_accept_channels as you like to share
   an xml description of the state of the cluster */
tcp_accept_channel {
  port = 8649
/* Channel to receive sFlow datagrams */
#udp_recv_channel {
#  port = 6343
/* Optional sFlow settings */
#sflow {
# udp_port = 6343
# accept_vm_metrics = yes
# accept_jvm_metrics = yes
# multiple_jvm_instances = no
# accept_http_metrics = yes
# multiple_http_instances = no
# accept_memcache_metrics = yes
# multiple_memcache_instances = no
Configuration file '%s' not found.
Your default configuration buffer failed to parse. Exiting.
udp_send_channel mcast_join=%s mcast_if=%s host=%s port=%d
udp_send_channel: bind and bind_hostname are mutually exclusive, both parameters can't be specified for the same udp_send_channel
Unable to join multicast channel %s:%d. Exiting
Unable to create UDP client for %s:%d. Exiting.
  msg.Ganglia_metadata_msg_u.gfull.metric_id.name: %s
  msg.Ganglia_metadata_msg_u.gfull.metric_id.host: %s
wrong number of arguments to cfg_include()
unable to create a temporary file %s
failed to process include file %s
Parse error for '%s'
NULL
udp_send_channel
host
mcast_join
mcast_if
bind_hostname
SPOOF_HOST
SPOOF_HEARTBEAT
heartbeat
float
double
string
uint8
uint16
uint32
zero
positive
negative
both
unspecified
/dev/shm
%s/%s
include ('
processed include file %s
invalid include path
cluster
globals
udp_recv_channel
tcp_accept_channel
collection_group
include
modules
sflow
owner
latlong
location
daemonize
setuid
ganglia
debug_level
max_udp_msg_len
mute
deaf
allow_extra_data
host_dmax
host_tmax
cleanup_threshold
send_metadata_interval
module_dir
override_hostname
override_ip
tags
family
inet4
retry_bind
interface
timeout
metric
collect_once
collect_every
time_threshold
module
udp_port
accept_vm_metrics
accept_http_metrics
multiple_http_instances
accept_memcache_metrics
multiple_memcache_instances
accept_jvm_metrics
multiple_jvm_instances
default
allow
access
name_match
value_threshold
title
language
enabled
params
param
action
mask
value
;*3$"
libganglia-3.3.7.so.0.0.0.debug
7zXZ
UhE5
WpEH
}RlJ
kAEU
8G(%
@f!l'jg
o{}.ap
	qZ>i
iI&,
Y</B
M$,wCs\0
]	[!
rX7"
.shstrtab
.note.gnu.build-id
.gnu.hash
.dynsym
.dynstr
.gnu.version
.gnu.version_r
.rela.dyn
.rela.plt
.init
.text
.fini
.rodata
.eh_frame_hdr
.eh_frame
.init_array
.fini_array
.jcr
.data.rel.ro
.dynamic
.got
.got.plt
.data
.bss
.gnu_debuglink
.gnu_debugdata
