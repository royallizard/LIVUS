r@P!A
P @H
$B`2
A\59
2T?'
zD23$
WO/ki
=}KIt,
kUZq
C'{q
N|%`LMf
@I^1D
r^*gF
|B%=vTu
Vqxg0?
[f(r
+IZ4(^
	i/R
l4?78
2SlG
aXqB
:]]^(
R^;$
y<1J
e*\w9$
XImu
*LSv
e]Y*
__gmon_start__
_fini
_ITM_deregisterTMCloneTable
_ITM_registerTMCloneTable
__cxa_finalize
_Jv_RegisterClasses
gegl_node_add_child
g_object_unref
gegl_node_get_producer
gegl_graph
gegl_node_get_type
g_object_new
gegl_node_get_pad
gegl_node_get_output_proxy
gegl_node_connect_to
gegl_node
g_type_check_instance_cast
g_object_get
g_object_freeze_notify
g_object_class_find_property
g_value_init
g_type_value_table_peek
g_object_set_property
g_value_unset
g_object_thaw_notify
gegl_node_connect_from
g_assertion_message_expr
g_type_name
g_log
gegl_node_get_debug_name
gegl_apply_op_valist
gegl_buffer_get_type
g_type_check_instance_is_a
g_return_if_fail_warning
g_object_ref
gegl_node_new_child
gegl_operation_point_filter_get_type
gegl_buffer_get_format
gegl_buffer_get_extent
gegl_buffer_new
gegl_node_link_many
gegl_node_process
gegl_buffer_copy
gegl_apply_op
gegl_filter_op_valist
gegl_filter_op
gegl_render_op_valist
gegl_render_op
g_type_class_peek_parent
g_type_class_adjust_private_offset
g_type_check_class_cast
g_param_spec_int
g_object_class_install_property
g_param_spec_double
g_param_spec_string
g_param_spec_boolean
gegl_config_get_type
g_once_init_enter
g_intern_static_string
g_type_register_static_simple
g_once_init_leave
g_value_set_boolean
g_value_set_double
g_value_set_int
g_value_set_string
g_value_get_boolean
g_value_get_double
g_value_get_int
g_value_dup_string
g_sprintf
g_setenv
g_getenv
gegl_cl_init
_setjmp
__longjmp_chk
gegl_cpu_accel_get_support
gegl_cpu_accel_set_use
gegl_dot_util_add_node
g_string_append_printf
gegl_node_get_pads
gegl_pad_is_output
g_string_append
gegl_pad_get_name
gegl_node_get_operation
gegl_operation_list_properties
gegl_node_get_property
g_value_transform
strlen
gegl_pad_is_input
gegl_dot_util_add_connection
gegl_connection_get_source_node
gegl_connection_get_sink_node
gegl_connection_get_source_pad
gegl_connection_get_sink_pad
gegl_dot_util_add_node_sink_edges
gegl_node_get_sinks
gegl_node_get_children
g_strdup
g_slist_free
gegl_to_dot
g_string_new
gegl_dot_visitor_get_type
gegl_dot_visitor_set_string_to_append
gegl_visitable_get_type
gegl_visitor_get_type
gegl_visitor_bfs_traverse
g_string_free
gegl_dot_node_to_png
g_get_tmp_dir
g_build_filename
g_file_set_contents
g_strdup_printf
system
gegl_dot_node_to_png_default
g_type_class_add_private
g_type_instance_get_private
gegl_pad_get_depends_on
gegl_pad_get_type
gegl_sampler_type_get_type
g_enum_register_static
gegl_abyss_policy_get_type
gegl_ripple_wave_type_get_type
gegl_warp_behavior_get_type
gegl_swap_dir
g_str_equal
g_file_test
g_mkdir_with_parents
g_get_user_cache_dir
gegl_get_option_group
g_option_group_new
g_option_group_add_entries
g_option_group_set_parse_hooks
gegl_init
g_option_context_new
g_option_context_set_ignore_unknown_options
g_option_context_set_help_enabled
g_option_context_set_main_group
g_option_context_parse
g_option_context_free
g_error_free
gegl_config
strtol
strchr
gegl_ticks
g_type_init
gegl_instrument
g_object_set
babl_init
setlocale
bindtextdomain
bind_textdomain_codeset
g_dir_open
g_pattern_spec_new
g_pattern_match_string
g_dir_read_name
g_pattern_spec_free
g_dir_close
kill
g_unlink
gegl_module_db_new
gegl_module_db_load
g_get_user_data_dir
gegl_exit
gegl_tile_storage_cache_cleanup
gegl_tile_cache_destroy
gegl_operation_gtype_cleanup
gegl_extension_handler_cleanup
babl_exit
gegl_buffer_stats
gegl_tile_backend_ram_stats
gegl_tile_backend_file_stats
gegl_tile_backend_tiledir_stats
gegl_instrument_utf8
g_printf
gegl_buffer_leaks
getpid
gegl_get_version
gegl_get_debug_enabled
gegl_debug_flags
strrchr
strcmp
babl_ticks
g_slice_alloc0
g_malloc
_gegl_float_epsilon_equal
gegl_rectangle_set
gegl_rectangle_intersect
gegl_rectangle_copy
gegl_rectangle_bounding_box
gegl_rectangle_contains
gegl_rectangle_equal
gegl_rectangle_equal_coords
gegl_rectangle_is_empty
gegl_rectangle_infinite_plane
gegl_rectangle_is_infinite_plane
gegl_rectangle_dump
g_print
gegl_rectangle_get_type
g_boxed_type_register_static
gegl_malloc
gegl_free
gegl_lookup_new_full
g_malloc0
gegl_lookup_new
gegl_lookup_free
gegl_node_get
g_hash_table_lookup
g_markup_parse_context_get_position
g_list_append
gegl_param_file_path_get_type
g_type_is_a
gegl_node_set
g_hash_table_insert
g_path_is_absolute
realpath
gegl_color_get_type
gegl_curve_get_type
gegl_path_get_type
g_ascii_strtod
g_type_class_peek
g_enum_get_value_by_nick
gegl_path_new
gegl_path_parse_string
g_list_prepend
gegl_curve_new
g_markup_error_quark
g_error_new
gegl_curve_add_point
gegl_node_get_input_proxy
g_list_delete_link
g_markup_escape_text
strncmp
g_ascii_dtostr
g_enum_get_value
g_snprintf
gegl_path_to_string
gegl_curve_num_points
gegl_curve_get_y_bounds
gegl_curve_get_point
g_string_insert_c
gegl_node_get_num_sinks
gegl_pad_get_connected_to
gegl_pad_get_node
g_object_get_data
gegl_node_new_from_xml
g_str_hash
g_hash_table_new_full
g_list_free
g_markup_parse_context_new
g_markup_parse_context_parse
g_markup_parse_context_free
g_hash_table_destroy
g_list_foreach
gegl_node_new_from_file
g_path_get_dirname
g_file_get_contents
gegl_node_to_xml
g_hash_table_new
g_hash_table_foreach
gegl_matrix3_copy
g_memdup
gegl_matrix3_new
gegl_matrix3_get_type
gegl_matrix3_identity
gegl_matrix3_equal
gegl_matrix3_is_identity
gegl_matrix3_copy_into
gegl_matrix3_is_scale
gegl_matrix3_is_translate
gegl_matrix3_determinant
gegl_matrix3_invert
gegl_matrix3_multiply
gegl_matrix3_originate
gegl_matrix3_transform_point
gegl_matrix3_parse_string
strstr
gegl_matrix3_to_string
g_file_enumerate_children
g_file_enumerator_next_file
g_file_info_get_name
g_file_get_child
g_file_delete
gegl_tile_backend_tiledir_get_type
gegl_tile_backend_get_type
g_file_new_for_commandline_arg
g_file_make_directory
g_file_query_info
g_file_info_get_file_type
g_output_stream_close
gegl_tile_mark_as_stored
gegl_tile_get_data
gegl_tile_backend_get_tile_size
g_file_replace
g_output_stream_get_type
g_output_stream_write_all
gegl_tile_new
g_file_read
g_input_stream_get_type
g_input_stream_read_all
g_input_stream_close
g_param_spec_pointer
g_cclosure_marshal_VOID__BOXED
g_signal_new
gegl_buffer_signals
gegl_tile_handler_get_type
gegl_tile_lock
gegl_tile_unlock
g_signal_emit_by_name
g_static_mutex_get_mutex_impl
g_mutex_lock
g_slist_remove
gegl_tile_backend_ram_get_type
gegl_tile_storage_new
g_object_set_data_full
g_mutex_unlock
gegl_tile_backend_file_get_type
_gegl_buffer_drop_hot_tile
gegl_tile_unref
gegl_buffer_backend
gegl_tile_source_get_type
g_value_set_pointer
gegl_tile_backend_get_format
gegl_tile_storage_get_type
gegl_tile_handler_set_source
g_signal_connect_data
babl_format
gegl_buffer_sample_cleanup
gegl_cl_is_accelerated
gegl_buffer_cl_cache_invalidate
gegl_buffer_flush
gegl_bt
gegl_buffer_set_extent
gegl_buffer_new_ram
gegl_buffer_new_for_backend
gegl_tile_backend_get_extent
gegl_buffer_create_sub_buffer
gegl_tile_storage_cached_release
g_slist_prepend
gegl_buffer_set_format
babl_format_get_bytes_per_pixel
g_value_get_pointer
gegl_buffer_is_shared
gegl_buffer_try_lock
gegl_tile_backend_file_try_lock
gegl_buffer_lock
g_usleep
gegl_buffer_unlock
gegl_tile_backend_file_unlock
gegl_buffer_set_unlocked
babl_fish
babl_process
gegl_buffer_cl_cache_flush
gegl_buffer_set
gegl_buffer_get_unlocked
memset
babl_format_get_type
babl_type
gegl_buffer_get
gegl_buffer_get_abyss
gegl_buffer_sample
gegl_sampler_gtype_from_enum
gegl_sampler_prepare
gegl_sampler_get
gegl_buffer_iterator_new
gegl_buffer_iterator_add
gegl_buffer_iterator_next
gegl_buffer_clear
gegl_buffer_set_pattern
gegl_buffer_set_color
gegl_color_get_pixel
gegl_buffer_dup
g_array_append_vals
g_array_new
gegl_buffer_iterator_stop
g_slice_free1
gegl_buffer_cl_iterator_add_2
gegl_cl_color_babl
gegl_cl_get_iter_width
gegl_cl_get_iter_height
g_malloc0_n
gegl_cl_color_supported
gegl_buffer_cl_iterator_add
gegl_buffer_cl_iterator_next
gegl_clEnqueueMapBuffer
gegl_clEnqueueBarrier
gegl_cl_get_command_queue
gegl_clEnqueueUnmapMemObject
gegl_buffer_cl_cache_new
gegl_cl_color_conv
gegl_clCreateBuffer
gegl_buffer_cl_cache_get
gegl_cl_get_context
gegl_clFinish
gegl_clReleaseMemObject
gegl_buffer_cl_cache_release
gegl_buffer_cl_iterator_new
g_slice_alloc
gegl_buffer_cl_cache_flush2
g_list_remove
gegl_buffer_linear_new
gegl_buffer_linear_new_from_data
gegl_tile_new_bare
gegl_tile_set_data_full
gegl_tile_handler_cache_insert
gegl_buffer_linear_open
g_object_set_data
gegl_buffer_linear_close
write
gegl_tile_entry_new
gegl_tile_entry_destroy
gegl_buffer_header_init
babl_get_name
gegl_buffer_save
open64
g_list_sort
__errno_location
g_strerror
lseek64
gegl_buffer_read_header
gegl_buffer_read_index
g_list_reverse
gegl_buffer_open
gegl_buffer_load
g_mutex_new
g_param_spec_object
gegl_cache_signals
gegl_cache_get_type
g_value_set_object
g_object_get_property
g_signal_lookup
g_signal_handler_find
g_signal_handler_disconnect
g_value_get_object
gegl_region_rectangle
gegl_region_subtract
gegl_region_destroy
g_idle_remove_by_data
g_mutex_free
gegl_region_new
gegl_cache_invalidate
g_signal_emit
gegl_cache_computed
gegl_region_union_with_rect
gegl_sampler_get_type
g_value_dup_object
gegl_sampler_set_buffer
gegl_sampler_get_ptr
gegl_sampler_get_from_buffer
gegl_sampler_get_from_mipmap
gegl_sampler_type_from_string
gegl_sampler_lohalo_get_type
gegl_sampler_cubic_get_type
gegl_sampler_linear_get_type
gegl_sampler_nearest_get_type
gegl_buffer_sampler_new
gegl_sampler_get_context_rect
g_malloc_n
g_realloc_n
gegl_region_copy
gegl_region_get_clipbox
gegl_region_get_rectangles
gegl_region_offset
gegl_region_intersect
gegl_region_union
gegl_region_shrink
gegl_region_xor
gegl_region_empty
gegl_region_equal
gegl_region_point_in
gegl_region_rect_in
gegl_region_spans_intersect_foreach
gegl_region_dump
gegl_tile_ref
gegl_tile_dup
gegl_tile_is_stored
gegl_tile_void
gegl_tile_store
gegl_tile_set_data
gegl_tile_set_rev
gegl_tile_get_rev
gegl_tile_set_unlock_notify
gegl_tile_storage_signals
gegl_tile_handler_chain_get_type
g_source_remove
gegl_tile_handler_cache_get_type
gegl_tile_handler_empty_new
gegl_tile_handler_zoom_new
gegl_tile_handler_chain_add
gegl_tile_handler_chain_bind
g_timeout_add_full
gegl_tile_backend_set_extent
gegl_tile_backend_peek_storage
g_hash_table_unref
fsync
g_hash_table_remove
g_hash_table_get_keys
ftruncate64
access
g_file_monitor_file
g_queue_remove
g_queue_push_head
g_queue_foreach
g_queue_pop_tail
g_queue_peek_head_link
g_queue_delete_link
g_queue_get_length
gegl_tile_handler_cache_new
gegl_tile_cache_init
g_queue_new
g_queue_free
gegl_tile_handler_chain_get_first
g_type_check_instance_is_fundamentally_a
gegl_tile_handler_empty_get_type
gegl_tile_handler_log_get_type
babl_format_get_n_components
gegl_tile_handler_zoom_get_type
gegl_id_pool_new
g_array_sized_new
gegl_id_pool_free
g_array_free
gegl_id_pool_add
gegl_id_pool_remove
gegl_id_pool_lookup
gegl_datafiles_check_extension
g_ascii_strcasecmp
gegl_datafiles_read_directories
g_get_home_dir
g_strsplit
g_strfreev
__xstat64
g_type_module_get_type
g_cclosure_marshal_VOID__VOID
g_module_error
g_dgettext
gegl_module_get_type
g_module_close
gegl_module_modified
gegl_module_set_load_inhibit
gegl_module_state_name
dcgettext
gegl_module_info_new
gegl_module_info_copy
gegl_module_info_free
gegl_module_query_module
g_module_symbol
g_module_open
gegl_module_new
gegl_module_register_type
g_type_from_name
g_type_module_register_type
g_cclosure_marshal_VOID__OBJECT
g_signal_handlers_disconnect_matched
gegl_module_db_get_type
g_path_get_basename
gegl_module_db_set_load_inhibit
gegl_module_db_get_load_inhibit
g_module_supported
gegl_module_db_refresh
g_utf8_casefold
gegl_extension_handler_register
gegl_extension_handler_register_saver
gegl_extension_handler_get
gegl_extension_handler_get_saver
gegl_operation_get_type
g_type_register_static
gegl_operation_create_pad
gegl_pad_set_param_spec
gegl_pad_set_node
gegl_node_add_pad
gegl_operation_process
gegl_operation_context_take_object
gegl_operation_get_bounding_box
gegl_operation_get_invalidated_by_change
gegl_operation_get_required_for_output
gegl_operation_get_cached_region
gegl_operation_attach
gegl_operation_prepare
gegl_operation_get_source_node
gegl_operation_source_get_bounding_box
gegl_operation_gtype_from_name
g_type_class_ref
g_object_class_list_properties
g_type_class_unref
gegl_operation_detect
gegl_operation_set_format
gegl_operation_get_format
gegl_operation_get_name
gegl_operation_invalidate
gegl_node_invalidated
gegl_operation_list_keys
g_hash_table_size
gegl_operation_class_set_key
gegl_operation_class_set_keys
gegl_operation_set_key
gegl_operation_class_get_key
gegl_operation_get_key
gegl_operation_area_filter_get_type
gegl_operation_filter_get_type
gegl_node_detect
gegl_operation_context_get_source
gegl_operation_context_get_target
gegl_operation_composer_get_type
gegl_operation_composer3_get_type
babl_backtrack
gegl_node_set_property
gegl_operation_meta_get_type
gegl_operation_meta_redirect
gegl_operation_meta_property_changed
gegl_can_do_inplace_processing
gegl_operation_point_composer_get_type
gegl_operation_point_composer3_get_type
gegl_operation_source_get_type
gegl_pad_get_format
gegl_operation_point_render_get_type
gegl_operation_sink_get_type
gegl_operation_sink_needs_full
gegl_operation_temporal_get_type
gegl_operation_temporal_get_frame
gegl_operation_temporal_set_history_length
gegl_operation_temporal_get_history_length
gegl_operation_context_set_need_rect
gegl_operation_context_get_result_rect
gegl_operation_context_set_result_rect
gegl_operation_context_get_need_rect
gegl_operation_context_set_property
g_slist_find_custom
g_value_reset
g_value_copy
gegl_operation_context_get_value
gegl_operation_context_get_property
gegl_operation_context_remove_property
gegl_operation_context_new
gegl_operation_context_destroy
g_value_take_object
gegl_operation_context_set_object
gegl_operation_context_get_object
gegl_node_get_cache
gegl_operation_context_get_level
g_type_children
gegl_list_operations
g_slist_length
strcpy
g_slist_sort
gegl_operation_calc_need_rects
gegl_node_get_context
gegl_node_set_need_rect
gegl_connection_new
gegl_connection_destroy
gegl_connection_set_source_node
gegl_connection_set_sink_node
gegl_connection_set_sink_pad
gegl_connection_set_source_pad
gegl_visitor_visit_node
g_type_add_interface_static
gegl_node_has_pad
gegl_node_get_input_pads
gegl_node_remove_pad
gegl_node_find_property
gegl_node_get_bounding_box
gegl_prepare_visitor_get_type
gegl_visitor_dfs_traverse
gegl_have_visitor_get_type
gegl_finish_visitor_get_type
gegl_eval_mgr_apply
g_cond_signal
gegl_node_new_processor
gegl_processor_work
gegl_node_add_context
gegl_node_emit_computed
gegl_node_blit
g_thread_pool_push
g_cond_wait
gegl_eval_mgr_new
gegl_processor_set_rectangle
g_thread_pool_new
g_cond_new
gegl_node_get_name
gegl_node_dump_depends_on
gegl_node_remove_context
gegl_node_get_consumers
gegl_pad_get_connections
gegl_node_set_name
g_strconcat
gegl_pad_set_name
gegl_node_remove_child
gegl_node_get_parent
gegl_node_get_num_children
gegl_node_get_nth_child
g_slist_nth_data
gegl_node_remove_children
g_slist_copy
gegl_node_disconnect
gegl_pad_disconnect
g_slist_foreach
gegl_pad_connect
gegl_node_link
gegl_node_insert_before
g_signal_handlers_block_matched
gegl_node_set_valist
g_object_new_valist
gegl_node_create_child
g_value_get_string
gegl_node_get_valist
gegl_node_new
gegl_visitor_visit_pad
gegl_pad_get_param_spec
gegl_pad_get_num_connections
g_param_spec_get_name
gegl_pad_set_format
g_direct_equal
g_direct_hash
gegl_visitable_depends_on
gegl_visitable_accept
gegl_visitor_reset
g_hash_table_remove_all
gegl_visitor_get_visits_list
g_queue_pop_head
g_queue_push_tail
g_type_interface_add_prerequisite
g_type_interface_peek
gegl_need_visitor_get_type
gegl_debug_rect_visitor_get_type
gegl_eval_visitor_get_type
gegl_eval_mgr_get_type
gegl_processor_get_type
g_object_notify
g_slice_copy
g_ascii_formatd
g_scanner_get_next_token
g_scanner_cur_value
g_scanner_new
g_scanner_input_text
g_scanner_destroy
g_ascii_table
g_ascii_xdigit_value
gegl_color_set_pixel
gegl_color_set_rgba
gegl_color_get_rgba
gegl_color_new
gegl_param_color_get_type
g_param_type_register_static
gegl_param_spec_color_get_default
g_type_parent
gegl_param_spec_color
g_param_spec_internal
gegl_param_spec_color_from_string
qsort
gegl_curve_default_curve
gegl_curve_set_point
gegl_curve_calc_value
gegl_curve_calc_values
gegl_param_curve_get_type
gegl_param_spec_curve
g_cclosure_marshal_VOID__POINTER
gegl_path_signals
gegl_path_is_empty
gegl_path_get_n_nodes
gegl_path_get_node
__sprintf_chk
gegl_path_set_matrix
gegl_path_get_matrix
gegl_path_foreach
gegl_path_freeze
gegl_path_add_type
gegl_path_add_flattener
gegl_path_get_path
gegl_path_list_destroy
gegl_path_get_bounds
gegl_path_insert_node
gegl_path_replace_node
gegl_path_remove_node
gegl_path_append
gegl_path_thaw
gegl_path_foreach_flat
gegl_path_get_flat_path
gegl_path_clear
gegl_path_list_append
gegl_path_new_from_string
gegl_path_point_lerp
gegl_path_point_dist
gegl_path_get_length
gegl_path_calc
gegl_path_calc_values
gegl_path_closest_point
gegl_param_path_get_type
gegl_param_spec_path
gegl_param_double_get_type
g_param_spec_types
gegl_param_spec_double
gegl_param_int_get_type
gegl_param_spec_int
gegl_param_string_get_type
g_utf8_validate
gegl_param_spec_string
gegl_param_spec_file_path
gegl_param_multiline_get_type
gegl_param_spec_multiline
gegl_param_enum_get_type
gegl_param_spec_enum
g_type_fundamental
gegl_param_spec_enum_exclude_value
gegl_cl_errstring
gegl_cl_get_platform
gegl_cl_get_device
gegl_cl_get_local_mem_size
gegl_clGetPlatformIDs
gegl_clGetPlatformInfo
gegl_clGetDeviceIDs
gegl_clGetDeviceInfo
gegl_clCreateContext
gegl_clCreateContextFromType
gegl_clCreateCommandQueue
gegl_clCreateProgramWithSource
gegl_clBuildProgram
gegl_clGetProgramBuildInfo
gegl_clCreateKernel
gegl_clSetKernelArg
gegl_clGetKernelWorkGroupInfo
gegl_clEnqueueWriteBuffer
gegl_clEnqueueReadBuffer
gegl_clEnqueueCopyBuffer
gegl_clEnqueueReadBufferRect
gegl_clEnqueueWriteBufferRect
gegl_clEnqueueCopyBufferRect
gegl_clCreateImage2D
gegl_clEnqueueWriteImage
gegl_clEnqueueReadImage
gegl_clEnqueueCopyImage
gegl_clEnqueueCopyBufferToImage
gegl_clEnqueueCopyImageToBuffer
gegl_clEnqueueNDRangeKernel
gegl_clEnqueueMapImage
gegl_clReleaseKernel
gegl_clReleaseProgram
gegl_clReleaseCommandQueue
gegl_clReleaseContext
gegl_cl_color_compile_kernels
g_set_error
gegl_cl_compile_and_build
libgmodule-2.0.so.0
libgio-2.0.so.0
libgobject-2.0.so.0
libgthread-2.0.so.0
libglib-2.0.so.0
libbabl-0.1.so.0
libpthread.so.0
libc.so.6
__stack_chk_fail
_edata
__bss_start
_end
libgegl-0.2.so.0
GLIBC_2.2
GLIBC_2.0
GLIBC_2.3.4
GLIBC_2.11
GLIBC_2.1
GLIBC_2.3
GLIBC_2.1.3
GLIBC_2.4
d$,[^_]
UWVS
[^_]
UWVS
D$(e
[^_]
D$Df
[^_]
UWVS
d$<[^_]
d$<[^_]
UWVS
D$he
L$<1
L$<e3
d$L[^_]
UWVS
;(t@
d$<[^_]
d$<[^_]
UWVS
;(t@
[^_]
[^_]
d$@[^_
d$$[^
d$$[^
d$0[^_
d$0[^_
d$0[^_
d$0[^_
d$0[^_
d$0[^_
d$0[^_
d$0[^_
d$0[^_
d$0[^_
UWVS
[^_]
d$ [^_
UWVS
T$\1
t$$1
9l$0
L$,v
D$\e3
d$l[^_]
UWVS
d$<[^_]
d$<[^_]
UWVS
d$,[^_]
d$ [^_
d$ [^_
UWVS
d$,[^_]
d$,[^_]
UWVS
[^_]
[^_]
UWVS
d$,[^_]
d$ [^_
8yu&
UWVS
[^_]
T$,t>
T$,t'
T$,u*
UWVS
[^_]
d$,[^_]
[^_]
UWVS
[^_]
UWVS
d$,[^_]
d$ [^_
UWVS
[^_]
UWVS
d$<[^_]
d$<1
[^_]
D$,)
D$P)
d$<[^_]
UWVS
d$<[^_]
T$(uF
d$<[^_]
d$<[^_]
T$,t
\$$9
d$<[^_]
UWVS
[^_]
[^_]
[^_]
D$$9
L$(9J
L$,9J
D$09B
d$([
d$([
UWVS
D$P1
d$,[^_]
d$([
|$4e
d$ [^_
t$De
D$,1
D$,e3
d$4[^
d$<[^_]
d$<[^_]
d$<[^_]
d$<[^_]
T$,t
d$L[^_]
D$<f
d$,[^_]
d$,[
L$,to1
;|$(u
d$<[^_]
UWVS
t$@tU
d$,[^_]
L$@e
D$,1
9t$,u
D$$;
D$,1
9t$,u
[^_]
D$L1
9t$Lu
D$t1
\$T|*
9l$(u
D$<9D$X
D$L1
9t$Lu
D$81
;t$\u
UWVS
d$<[^_]
D$D1
9t$Du
9t$Du
D$D1
9l$Du
[^_]
L$D1
9t$Du
9t$Du
9t$Du
UWVS
t$(e
D$L1
L$Le3
d$\[^_]
UWVS
D$,1
T$,e3
d$<[^_]
D$,1
T$,e3
d$0[^_
D$\1
T$\e3
d$`[^_
D$\1
T$\e3
d$d[^
D$\1
T$\e3
d$d[^
t$pe
D$\1
D$\e3
d$d[^
UWVS
[^_]
UWVS
D$,1
D$,e3
d$<[^_]
D$(u
UWV1
[^_]
d$ [^_
UWVS
d$<[^_]
D$l1
|$le3=
d$p[^_
d$ [^_
d$ [^_
[^_]
UWVS
t$`e
L$<1
|$<e3=
d$L[^_]
;l$8
;t$8
T$(tq
UWVS
d$<[^_]
d$<[^_]
UWVS
d$<[^_]
d$<[^_]
d$8[
d$0[^_
d$ [^_
d$ [^_
UWVS
d$<[^_]
d$<[^_]
[^_]
d$([
UWVS
d$<[^_]
UWVS
;*t}
[^_]
@D+F<
@H+F@
@D+F<
@H+F@
)D$P
(D$`
D$4;Ft
UWVS
T$(t#
d$<[^_]
T$,ua
T$,;
T$,u4
T$,;
F$[^
|$te
D$\1
)D$@
L$\e3
d$`[^_
|$de
D$L1
)D$0
L$Le3
d$P[^_
D$l1
)D$P
L$le3
d$|[^_]
UWVS
;(t@
d$<1
[^_]
d$<[^_]
[^_]
UWVS
[^_]
[^_]
UWVS
d$<[^_]
UWVS
d$,[^_]
d$,[^_]
9D$D
9|$H
D$<1
+l$09
9D$`
9\$l
D$`1
+T$l
L$<9L$4
t$,9t$@
T$|+l$h
+D$,
9D$4~]9t$@~W
|$L9D$H~C
9D$D
L$09L$P
D$4+D$<
L$,9L$@
[^_]
l$8)
|$8)
T$<9T$4
T$,9T$@
+l$h
+L$,
l$L9L$4
9T$@
9\$H~
9\$D
t$ds$1
d$$[^
d$$[^
[^_]
9D$X
9t$h
l$t9
L$P9
9T$8
T$,9T$0
L$P)
\$H+D$(
9D$0
9l$8
D$<9D$X
9D$h
D$0f
9D$p
9T$`
l$x9
L$X9
9t$(
T$09T$,
\$L+D$(
9D$,
9l$8
D$@9D$`
9D$p
L$(9L$8~V
D$,9D$0~L
9t$0~2
+D$,9D$8
T$@9T$`
D$0+D$,
t$(9t$8
D$D)
|$t9D$8~
D$,9D$0~
9|$0~
+D$,9D$8
|$D)
D$09D$,~S
T$89T$(}I
9l$,~/
t$<+D$09D$8
t$h9t$D
D$,+D$0
\$(9\$8
T$X9
|$,9
+D$0
9L$P
L$0~
t$8r
D$H)
t$H9D$L
|$x9L$,
\$89
9t$,
+D$09D$8
|$H)
9D$X
9L$h
l$t9
L$T9
9T$8
|$,9|$0
L$H+D$(
9D$0
9l$8
D$<9D$X
9D$h
T$(9T$8~V
D$,9D$0~L
9t$0~2
+D$,9D$8
t$@9t$`
D$0+D$,
L$(9L$8
D$D)
|$t9D$8~
D$,9D$0~
9|$0~
+D$,9D$8
|$D)
t$Hsv1
9|$P
d$4[^
d$4[^
FD[^
UWVS
d$\[^_]
T$0t
;uXtT
d$\[^_]
t$(9
T$(t	9z
UWVS
L$,e
D$L1
t$|t0
L$,t
;(tl
L$,uL
D$Le3
d$\[^_]
;(t*
T$,u
UWVS
d$,[^_]
d$,[^_]
UWVS
D$$e
|$|1
D$0f
|$H1
9t$ }
t$<9D$D
D$|e3
[^_]
D$,e
[^_]
UWVS
[^_]
D$T9B4
d$,[^_]
d$,[^_]
D$,1
D$,e3
d$<[^_]
A\;X4t6
[^_]
Z8;X8
\$,u
+A<+
+A@+
D$(1
D$,f
d$<[^_]
UWVS
@49G
d9E|
OD}\
L$0;O0
D$T)
D$D9
R\;B4
D$X+D$T
L$L9
L$@)
+D$\
L$8)
L$89
T$0;W0
D$0+D$@
d$l[^_]
UWVS
+T$ 9
+T$ 9
T$ 9V
d$<[^_]
d$<[^_]
d$8[
UWVS
D$D@9
T$@9/
L$X)
D$L1
D$D@9
9T$T
t$X1
9t$T
D$<1
D$H@9
[^_]
D$@@9
UWVS
l$0t#
[^_]
L$0tj
d$([
UWVS
[^_]
UWVS
D$l1
9H(u
L$<t
D$Xug
T$le3
d$|[^_]
D$81
UWVS
D$$e
D$L1
D$,u
D$Le3
d$\[^_]
UWVS
d$l[^_]
UWVS
[^_]
UWVS
T$(u
O$9M
O(9M
O,9M
O09M
d$<[^_]
G(9B
Od9J
W\;B4
;J8tB
UWVS
d$<[^_]
9T$Tt!
l$T9)u
d$,[^_]
|$<e
D$|1
GEGL
D$|e3
[^_]
UWVS
D$l1
D$Xf
D$4+D$8
D$X)
D$H+D$\
l$0f
D$0)
T$,3F
T$,3V
D$le3
d$|[^_]
D$<1
|$,'
|$<e3=
d$L[^_]
UWVS
l$@e
?GEGLt$
d$,[^_]
[^_]
UWVS
d$l[^_]
UWVS
d$L[^_]
d$,[^_]
d$,[
d$ [^_
d$ [^_
d$0[^_
d$0[^_
d$0[^_
d$0[^_
d$0[^_
d$0[^_
UWVS
d$<[^_]
d$<[^_]
d$<[^_]
d$<[^_]
d$<[^_]
d$<[^_]
UWVS
l$Te
D$,1
D$,e3
d$<[^_]
UWVS
T$,u+
d$<[^_]
UWVS
|$de
D$<1
D$<e3
d$L[^_]
)D$ 
d$ [^_
d$ [^_
d$ [^_
UWVS
;(tI
;(t:
[^_]
[^_]
d$$[^
d$$[^
UWVS
[^_]
UWVS
[^_]
[^_]
UWVS
D$\1
D$T@
D$X@
+D$,
+D$$)
|$\e3=
d$l[^_]
D$$9
D$T@
D$X@
N +D$,
UWVS
t$pe
D$L1
V\;T$t
D$D@
D$H@
+T$,
|$t)
t$t+\$$)
t$Le35
d$\[^_]
N`;L$x
9L$t
Nh9L$x
D$D@
D$H@
+D$,
UWVS
D$l1
D$0~:
L$,9
D$d@
D$h@
+L$0
+D$<
L$H)
+|$8
+|$,
|$le3=
d$|[^_]
9L$L
D$d@
D$h@
+T$0
V +L$<
t'r5
UWVS
[^_]
[^_]
[^_]
d$@[^_
UWVS
l$T9
L$$1
t$h)
T$T;T$\
[^_]
d$ [^_
d$ [^_
|$Ne
D$l1
D$le3
d$p[^_
d$0[^_
d$0[^_
d$ [^_
d$ [^_
d$ [^_
d$0[^_
d$0[^_
d$ [^_
d$ [^_
[^_]
d$ [^_
d$ [^_
UWVS
[^_]
UWVS
9l$,
d$<[^_]
\$8;L$h
;|$p
\$0}R
D$x9D$t|x
;L$h
d$L[^_]
L$8;D$<
UWVS
|$P9D$\
;t$X
;D$,
9t$Xtg
d$<[^_]
D$h9D$d
;|$X
;l$`
9\$d
;D$,
9T$$
9L$d
;D$,
9L$h
9L$$
9\$h
;|$X
t	;h
;D$$
9|$X
d$<[^_]
9L$h
;l$`
t	;x
;D$$
9l$`
9T$h
}R;P
UWVS
|$P9D$\
;t$X
;D$,
9t$Xtg
d$<[^_]
t$\9D$d
;|$XtJ;t$`tD
9L$X
;|$Xu
;|$X
;D$(
9|$X
;D$,
9L$(|T
;D$,
9T$XtG
d$<[^_]
[^_]
D$$9|$$
T$,9T$(
T$89
T$09
l$$9
\$$;t$,
9|$$
L$L9
d$\[^_]
T$09
L$D9N
|$x9
UWVS
D$8tm
[^_]
[^_]
UWVS
t$8tU
[^_]
[^_]
UWVS
D$Te
|$,1
D$,e3
d$<[^_]
d$,[^_]
UWVS
t$Htu
d$,[^_]
xnu_
d$,[^_]
d$,[^_]
UWVS
[^_]
[^_]
UWVS
[^_]
89:uP
(9*u"
[^_]
tV9J
~Q;J
t$(9r
9t$(|:
9t$(}
9t$(}C
UWVS
|$ 9
|$ 9
\$$|
|$$9|$
\$$9\$
d$<[^_]
[^_]
UWVS
l$de
D$<1
t+;C
D$<e3
d$L[^_]
D$h1
vQ;s
9|$h
D$,1
9|$(
D$,e3
d$0[^_
UWVS
d$,[^_]
9]P}
d$,[^_]
UWVS
w(;~(
~,t;
[^_]
UWVS
E$t}
d$,[^_]
UWVS
d$<[^_]
[^_]
d$(1
d$$[^
d$$[^
d$0[^_
d$ [^_
d$ [^_
UWVS
d$,[^_]
UWVS
d$<[
d$ [^_
d$ [^_
d$ [^_
UWVS
d$,[
d$0[^_
d$0[^_
d$0[^_
d$0[^_
d$0[^_
d$0[^_
d$0[^_
d$0[^_
d$0[^_
d$0[^_
[^_]
B 9A 
d$ [^_
d$ [^_
3L$,
d$<[
d$<1
[^_]
9T$4
D$8r w
9D$0v
G$9F$uU
[^_]
d$ [^_
d$ [^_
UWVS
d$L[^_]
[^_]
D$41
d$L1
[^_]
d$L[^_]
d$L1
[^_]
T$<1
T$<1
UWVS
D$<1
L$<e3
d$L[^_]
UWVS
d$<[^_]
d$<[^_]
UWVS
d$<[^_]
d$<[^_]
d$H[
[^_]
d$0[^_
d$0[^_
d$ [^_
d$ [^_
UWVS
t$pe
L$L1
L$Le3
d$\[^_]
d$H[
d$$[^
d$ [^_
d$ [^_
UWVS
[^_]
UWVS
d$<[^_]
d$<[^_]
UWVS
d$<[^_]
d$<[^_]
|$,1
L$,e3
d$<[^_]
0;t$$t
0;t$$t
d$ [^_
d$ [^_
UWVS
d$,[^_]
UWVS
[^_]
UWVS
L$(;O
L$4;
d$L[^_]
L$4;t$<
[^_]
D$41
[^_]
L$(;O
L$4;
d$<[^_]
d$ [^_
d$ [^_
UWVS
[^_]
[^_]
UWVS
d$,[^_]
d$ [^_
d$ [^_
UWVS
L$dt0
d$<[^_]
T$,tE
T$(t
d$<[^_]
UWVS
[^_]
UWVS
d$<[^_]
d$<1
[^_]
d$ [^_
d$ [^_
D$4e
[^_]
D$ttQ
D$pt
;|$0u
)\$P
9D$0
9D$0
T$,1
\$0;l$,t1
\$@;D$L
|$,1
t$(;|$,u
;L$(
;t$(
L$@	
YD$P
9t$lw
l$H9
;\$d
D$0~m
48~7
\$0;D$8u
\$H9D$d
d$ [^_
d$ [^_
UWVS
[^_]
tN9P
UWVS
[^_]
UWVS
L$ e
8~tF
T$Hu
[^_]
UWVS
d$<[^_]
d$ 1
d$ [^_
d$ [^_
9~,t
UWVS
t$`e
D$<1
L$<e3
d$L[^_]
UWVS
|$`e
D$<1
L$<e3
d$L[^_]
UWVS
E t 
[^_]
d$$[^
UWVS
d$L[^_]
d$ [^_
>:tK
d$,[
d$,1
[^_]
d$$[^
d$$[^
UWVS
<$t=
d$,[^_]
d$,[^_]
L$ 1
UWVS
[^_]
[^_]
|$4t
d$ [^_
[^_]
UWVS
[^_]
d$$[^
D$<1
T$<e3
d$D[_
UWVS
[^_]
[^_]
UWVS
T$,u-
d$<1
[^_]
d$<[^_]
[^_]
\$0e
d$([
t$@e
L$,1
L$,e3
d$4[^
UWVS
|$Pe
D$,1
t$\t#
T$,e3
d$<[^_]
D$Pe
|$<1
t$Xt2
\$<e3
d$@[^_
D$@e
|$,1
t$,e35
d$0[^_
\$0e
d$([
UWVS
d$,[^_]
d$,[^_]
d$$[^
d$ [^_
d$ [^_
d$ 1
UWVS
d$,[^_]
d$,[^_]
d$,1
[^_]
d$ 1
d$ 1
d$ [
UWVS
d$,[1
[^_]
d$,1
UWVS
[^_]
[^_]
d$ [^_
d$ [^_
UWVS
UWVS
[^_]
[^_]
UWVS
D$\1
)T$<)D$@
L$\e3
d$l[^_]
UWVS
d$,[^_]
t$Pe
D$,1
L$,e3
d$<[^_]
UWVS
[^_]
[^_]
[^_]
[^_]
[^_]
d$ [^_
d$ [^_
UWVS
d$,[^_]
t$`e
D$<1
)D$ 
L$<e3
d$L[^_]
UWVS
[^_]
[^_]
T$(9
[^_]
[^_]
d$ [^_
d$ [^_
d$ [^_
UWVS
T$,9
[^_]
[^_]
d$ [^_
d$ [^_
L$$e
D$L1
D$Le3
d$\[^_]
d$ [^_
d$ [^_
UWVS
d$,[^_]
UWVS
d$,[
UWVS
d$<[^_]
[^_]
[^_]
T$,9
UWVS
L$l1
L$le3
d$|[^_]
d$ [^_
d$ [^_
[^_]
[^_]
UWVS
[^_]
[^_]
[^_]
d$ [^_
d$ [^_
d$ [^_
d$ [^_
UWVS
D$0e
D$\1
9D$8
L$\e3
d$l[^_]
UWVS
[^_]
d$ [^_
d$ [^_
d$ [^_
UWVS
[^_]
d$,1
d$ [^_
d$ [^_
d$ [^_
l$@ul
[^_]
[^_]
d$ [^_
d$ [^_
d$ [^_
d$ [^_
D$,1
D$,e3
d$0[^_
UWVS
l$|e
T$L1
|$Le3=
d$\[^_]
UWVS
;L$d
d$L[^_]
d$([
d$([
UWVS
d$<[^_]
d$<[^_]
d$ [^_
UWVS
d$,[
d$,[^_]
UWVS
|$te
T$L1
D$Le3
d$\[^_]
UWVS
D$,1
T$,e3
[^_]
UWVS
D$ e
D$L1
L$Le3
d$\[^_]
)D$0
D$,1
D$(1
9t$(w
D$,e3
d$<[^_]
UWVS
[^_]
UWVS
D$$u2
D$(t
[^_]
UWVS
d$<[^_]
D$,1
L$,e3
d$0[^_
|$Xe
D$<1
D$<e3
d$@[^_
UWVS
[^_]
UWVS
d$,[^_]
d$,[^_]
UWVS
|$de
D$<1
D$<e3
d$L[^_]
UWVS
[^_]
[^_]
UWVS
d$,[
[^_]
d$,[
UWVS
D$\1
D$\e3
d$l[^_]
d$0[^_
UWVS
[^_]
[^_]
d$$[^
d$ 1
UWVS
9T$0
D$,1
,9l$ 
T$49T$0
[^_]
T$49T$0
t$@f
d$0[^_
d$0[^_
d$0[^_
d$0[^_
d$0[^_
d$ 1
d$,1
[^_]
[^_]
UWVS
[^_]
UWVS
d$,[^_]
d$,[^_]
UWVS
d$<[^_]
D$\1
D$ u
d$<[^_]
UWVS
[^_]
T$$t
[^_]
UWVS
;(t@
[^_]
;*t 
[^_]
d$<[
UWVS
;(tb
[^_]
[^_]
UWVS
d$,[^_]
UWVS
;0t@
d$<1
[^_]
;0t%
[^_]
d$,[^_]
;t$,t8
d$<[^_]
UWVS
[^_]
d$,1
d$,[
UWVS
|$Xt$
T$,u4
d$<[^_]
[^_]
UWVS
;(t@
[^_]
[^_]
UWVS
;8t?
[^_]
[^_]
UWVS
|$te
D$L1
;(t<
D$Le3
d$\[^_]
d$L[^_]
d$L[^_]
d$,[^_]
UWVS
|$(e
[^_]
t$\1
D$H1
t$\1
D$H1
UWVS
[^_]
[^_]
UWVS
d$L[^_]
d$L[^_]
d$L[1
d$L[^_]
d$L[^_]
UWVS
d$,[^_]
d$,[^_]
T$,e
T$,uG
[^_]
UWVS
t$Pe
D$,1
|$,e3=
d$<[^_]
D$,1
L$,e3
d$0[^_
d$$[^
UWVS
[^_]
UWVS
;(t@
d$,[^_]
d$,[^_]
4$t$
d$,[^_]
d$([
d$,[^_]
d$<[^_]
d$$[^
d$$[^
UWVS
d$<[^_]
d$<[^_]
UWVS
d$<[^_]
d$<[^_]
UWVS
l$`e
D$<1
D$<e3
d$L[^_]
D$(t_
UWVS
d$,[^_]
d$,[^_]
UWVS
t$Te
D$,1
D$,e3
d$<[^_]
d$ [^_
d$ [^_
UWVS
[^_]
d$ [^_
d$ [^_
d$$[^
d$$[^
UWVS
D$\1
+D$0
T$\e3
d$l[^_]
+D$0
UWVS
[^_]
UWVS
D$\1
D$\e3
d$l[^_]
D$(t
+D$(
d$ [^_
d$ [^_
d$ [^_
d$ [^_
UWVS
|$Pe
D$,1
D$,e3
d$<[^_]
d$ [^_
d$ [^_
UWVS
D$$e
D$L1
+D$,
D$Le3
d$\[^_]
d$ [^_
d$ [^_
d$4[^
d$ [^_
d$$[^
d$$[^
UWVS
d$L[^_]
d$L[^_]
d$L[^_]
d$L[^_]
d$L[^_]
UWVS
D$\1
D$\e3
d$l[^_]
UWVS
d$<[^_]
d$<[^_]
d$<[^_]
d$<[^_]
G tD
UWVS
D$(e
D$\1
9D$,}n
|$\e3=
d$l[^_]
d$$1
d$$[^
d$ [^_
[^_]
D$<1
T$<e3
d$L[^_]
D$$~E
D$(;|$$
x!;|$$
d$$[^
d$$[^
UWVS
d$<[^_]
d$<[^_]
UWVS
D$\1
D$\e3
d$l[^_]
T$Htb
T$4tb
L$01
9|$<
|$@1
9l$8u
UWVS
l$8t
[^_]
[^_]
UWVS
l$8t
[^_]
[^_]
d$4[^
d$4[^
UWVS
[^_]
d$ [^_
d$$[^
d$0[^_
d$0[^_
UWVS
d$,[^_]
d$$[^
d$$[^
d$ [^_
D$<1
T$<e3
d$@[^_
d$8[
d$8[
d$ [^_
d$0[^_
d$ [^_
UWVS
9t$du
d$<[^_]
UWVS
[^_]
d$([
D$$D
d$4[^
d$0[^_
d$0[^_
UWVS
D$,t7
d$<[^_]
D$<1
D$<e3
d$L[^_]
UWVS
L$8e
D$<1
D$,9
|$,1
T$,9
8L$+t,
t$<e35
d$L[^_]
L$(e
D$,1
|$,e3=
d$<[^_]
\$,1
	v-<-t)
t$,e35
d$<[^_]
d$$[^
d$$[^
UWVS
[^_]
[^_]
D$\1
T$\e3
d$l[^_]
UWVS
|$8t/
[^_]
UWVS
[^_]
[^_]
d$,[^_]
UWVS
d$,[^_]
D$|1
D$|e3
[^_]
D$6%
D$6%
D$6%
D$6%
PHt4
UWVS
d$,[^_]
UWVS
d$,[1
UWVS
UWVS
D$$e
D$\1
|$ L
T$ t+
D$\e3
d$l[^_]
,T$ 
T$Pt
UWVS
|$8t?
[^_]
UWVS
D$,1
|$Xu	
t$,e35
d$<[^_]
D$Xe
D$\tg
D$L1
[^_]
<MtB<m
<Ltz1
<lt81
|$ 9|$,w
D$<@
[^_]
D$<1
`<Lul
D$<e3
d$L[^_]
UWVS
D$4e
D$\1
D$,1
<st(<L
T$\e3
d$l[^_]
UWVS
l$\1
D$01
D$\e3
d$l[^_]
UWVS
D$0u9
d$\[^_]
T$01
d$\[^_]
d$\[^_]
d$([
D$<1
D$0`
T$<e3
d$D[_
d$T[^
D$<1
D$0D
T$<e3
d$D[_
d$4[^
D$<1
D$0<
T$<e3
d$D[_
|$0e
d$ [^_
d$ [^_
D$<1
D$0<
T$<e3
d$D[_
|$0e
d$ [^_
d$ [^_
D$<1
D$0<
T$<e3
d$D[_
|$0e
d$ [^_
d$ [^_
D$<1
D$04
T$<e3
d$D[_
UWVS
[^_]
[^_]
UWVS
[^_]
UWVS
d$<1
[^_]
d$<[^_]
UWVS
D$(e
D$\1
L$\e3
d$l[^_]
D$41
9T$,
;D$0
t$8t
UWVS
L$<1
L$<e3
d$L[^_]
D$41
t$(1
;l$(u
D$0tH
[^_]
UWVS
[^_]
UWVS
D$8e
D$L1
L$Le3
d$\[^_]
input
gegl-operation
GEGL-gegl-c.c
%s: %s
%s:%s has no property named: '%s'
%s: property (%s of operation class '%s' is not writable
gegl_node
GEGL-gegl-apply.c
GEGL_IS_BUFFER (buffer)
gegl:buffer-source
gegl:write-buffer
gegl:buffer-sink
GEGL_IS_BUFFER (source_buffer)
GEGL_IS_BUFFER (target_buffer)
gegl_render_op_valist
gegl_render_op
gegl_node_set_props
gegl_apply_op_valist
gegl_apply_op
default tile width for created buffers.
default tile height for created buffers.
the number of pixels processed simultaneously by GEGL.
quality/speed trade off 1.0 = full quality, 0.0=full speed
the error tolerance babl operates with
where gegl stores it's swap files
Number of concurrent evaluation threads
%s:%d: invalid %s id %u for "%s" of type '%s' in '%s'
Tile width
tile-width
Tile height
tile-height
size of cache in bytes
Cache size
Chunk size
Quality
babl error
babl-tolerance
Swap
Try to use OpenCL
Use OpenCL
use-opencl
GeglConfig
property
GEGL-gegl-config.c
BABL_TOLERANCE
Mb`?
?GenuineIntel
AuthenticAMD
CentaurHauls
CyrixInstead
Geode by NSC
op_%p [fontsize="10" label="
%s |
<%s>%s
shape="record"];
%s=%s | 
op_%p:%s -> op_%p:%s;
GEGL
gegl-dot.dot
dot -o %s -Tpng %s
GEGL-gegl-dot.c
/tmp/node.png
subgraph cluster_%s%p { graph [ label="%s %p" fontsize="10" ranksep="0.3" nodesep="0.3"]; node [ fontsize="10" ];
digraph gegl { graph [ rankdir = "BT" fontsize = "10" ];
Error executing GraphViz dot program
GeglDotVisitor
GEGL-gegl-dot-visitor.c
self->priv->string_to_append != NULL
gegl_dot_visitor_visit_node
gegl_dot_visitor_visit_pad
GeglSamplerType
GeglAbyssPolicy
GeglRippleWaveType
GeglWarpBehavior
grow
shrink
swirl-cw
swirl-ccw
erase
smooth
sine
sawtooth
none
nearest
lohalo
GEGL_SWAP
gegl-0.2
Show GEGL Options
gegl
GEGL-gegl-init.c
GEGL_QUALITY
GEGL_CACHE_SIZE
GEGL_CHUNK_SIZE
GEGL_TILE_SIZE
GEGL_THREADS
GEGL_USE_OPENCL
babl_init
gegl_init
/usr/share/locale
UTF-8
GEGL_PATH
/usr/lib
plug-ins
Makefile
load modules
fast
good
best
global_time == 0
gegl_exit
GEGL_DEBUG_BUFS
GEGL_DEBUG_TIME
%i-*
<float>
gegl-swap
Where GEGL stores it's swap
<uri>
gegl-cache-size
<megabytes>
gegl-tile-size
<widthxheight>
gegl-chunk-size
pixel count
gegl-quality
<quality>
gegl-threads
<threads>
Tried to use %i threads max is %i
# This is a generic makefile for GEGL operations. Just add .c files,
# rename mentions of the filename and opname to the new name, and it should 
# compile. Operations in this dir should be loaded by GEGL by default
# If the operation being written depends on extra libraries, you'd better
# add a dedicated target with the extra bits linked in.
CFLAGS  += `pkg-config gegl --cflags`  -I. -fPIC
LDFLAGS += `pkg-config gegl --libs` -shared
SHREXT=.so
CFILES = $(wildcard ./*.c)
SOBJS  = $(subst ./,,$(CFILES:.c=$(SHREXT)))
all: $(SOBJS)
%$(SHREXT): %.c $(GEGLHEADERS)
	@echo $@; $(CC) $(CFLAGS) $(LDFLAGS) -o $@ $< $(LDADD)
clean:
	rm -f *$(SHREXT) $(OFILES)
EEEEeEeek! %i GeglBuffers leaked
babls error tolerance, a value beteen 0.2 and 0.000000001
How much memory to (approximately) use for caching imagery
Default size of tiles in GeglBuffers
The count of pixels to compute simultaneously
The quality of rendering a value between 0.0(fast) and 1.0(reference)
The number of concurrent processing threads to use
gegl_post_parse_hook
?gegl-instrument.c:186
%s tab overflow %i>%i
GEGL-gegl-instrument.c
parent
Total time: %.3fs
%5.1f%%
other
gegl_instrument
>r && s
GEGL-gegl-utils.c
%d, %d, %d
GeglRectangle
gegl_free
gegl_rectangle_is_empty
gegl_rectangle_equal_coords
gegl_rectangle_equal
gegl_rectangle_contains
4DE?ref
XML Parse error %i:%i: %s
GEGL-gegl-xml.c
property %s not found for %s
%s/%s
./%s
true
TRUE
string
image
gegl:nop
graph
params
param
curve
ymin
ymax
curve-point
curve not instantiated
link
links
stack
launcher
launchers
destination
gegl:clone
gegl:layer
filter
tree
layers
pd->param && pd->iter
<param name='
</param>
<params>
false
<curve ymin='
' ymax='
<curve-point x='
' y='
</curve>
</params>
&#10;
<clone ref='
clone%i
composite_op
opacity
<layer
 name='%s'
 x='%s'
 y='%s'
 opacity='%s'
 src='%s'
<node
</node>
gegl_parse_xml
xmldata != NULL
Unable to read file: %s
path
<gegl>
</gegl>
Unable to obtain absolute path for parameter %s
operation desired unknown parapspec type for %s
eek, haven't cleared previous param
Expected attribute '%s' in element '%s'
we haven't cleared previous curve
Could not instantiate operation '%s'
%s: serialization of %s properties not implemented
<?xml version='1.0' encoding='UTF-8'?>
xml_param_start
xml_param
xml_attr
gegl_node_new_from_file
end_element
gegl_node_new_from_xml
GeglMatrix3
translate
matrix
matrix(
The base path for this backing file for a buffer
GEGL-gegl-tile-backend-tiledir.c
command < GEGL_TILE_LAST_COMMAND && command >= 0
leaked: %i chunks (%f mb)  peak: %i (%i bytes %fmb))
standard::*
%i-%i-%i
GeglTileBackendTileDir
bytes_read == tile_size
gegl-tile-backend-tiledir.c
bytes_written == tile_size
gio_entry_write
gio_entry_read
gegl_tile_backend_tiledir_command
size of a single pixel in bytes.
total amount of pixels in image (width x height)
local origin's offset relative to source origin
A custom tile-backend instance to use
URI to where the buffer is stored
Buffer statistics: allocated:%i deallocated:%i balance:%i
not enough data to have a tile source for our buffer
peculiar abyss dimensions: %i,%i %ix%i
avoiding creating buffer of size: %ix%i returning an empty buffer instead.
tried to set format of different bpp on buffer
pixel-size
px-size
pixel width of buffer
pixel height of buffer
pixel width of abyss
abyss-width
pixel height of abyss
abyss-height
abyss-x
abyss-y
shift-x
shift-y
babl format
height of a tile
width of a tile
changed
GeglBuffer
GEGL-gegl-buffer.c
storage-cache-item
RGBA float
backend == buffer->backend
GEGL_IS_BUFFER(buffer)
waiting to aquire buffer..
buffer->lock_count >=0
gegl_buffer_unlock
gegl_buffer_create_sub_buffer
gegl_buffer_get_extent
gegl_buffer_set_extent
gegl_buffer_constructor
gegl_buffer_get_tile
GEGL-gegl-buffer-access.c
rect
GEGL_IS_BUFFER (src)
GEGL_IS_BUFFER (dst)
color
didn't get tile, trying to continue
gegl_buffer_dup
gegl_buffer_set_color
gegl_buffer_clear
gegl_buffer_copy
gegl_buffer_sample_cleanup
gegl_buffer_sample
gegl_buffer_get_abyss
gegl_buffer_get
gegl_buffer_get_unlocked
gegl_buffer_set
gegl_buffer_flush
?GEGL-gegl-buffer-iterator.c
too many iterators (%i)
%i==%i != 0==%i
res == result
i->iterators > 0
roi.width != 0 && roi.height != 0
%s called on finished buffer iterator
gegl_buffer_iterator_next
iterator_buf_pool_release
gegl_buffer_tile_iterator_init
FALSE
gegl-buffer-cl-iterator.c
buffer == NULL
i->tex_op[no][j] == NULL
i->tex_buf[no][j] == NULL
GEGL-gegl-buffer-cl-iterator.c
i->tex_buf[no][j] && i->tex_op[no][j]
gegl_buffer_cl_iterator_next
gegl_buffer_cl_iterator_add_2
e->used >= 0
GEGL-gegl-buffer-cl-cache.c
e->used == 0
gegl_buffer_cl_cache_invalidate
gegl_buffer_cl_cache_release
got a NULL extent
GEGL-gegl-buffer-linear.c
linear-buffers
linear-tile
tile == NULL
gegl-buffer-linear.c:236
EEeeek! %s
!!!!!! sharing a linear buffer!!!!!
buffer->tile_width <= buffer->tile_storage->tile_width
buffer->tile_height == buffer->tile_storage->tile_height
gegl_buffer_linear_open
gegl_buffer_linear_new_from_data
allocated_pos == info->offset
GEGL-gegl-buffer-save.c
%s: Could not open '%s': %s
info->tile_size % 16 == 0
data
info->offset == entry->offset
%s%c
%i %ibpp
%ix%i
info->offset == info->header.next
write_block
gegl_buffer_save
failed seeking to %i
GEGL-gegl-buffer-load.c
Magic is wrong! %s
failed seeking
header
skipping unknown type of entry flags=%i
babl_format_get_bytes_per_pixel (info->format) == info->header.bytes_per_pixel
gegl_buffer_load
R'G'B'A u8
GeglNode
computed
invalidated
GeglCache
GeglBuffer::x
GeglBuffer::y
GeglBuffer::width
GeglBuffer::height
GEGL-gegl-cache.c
GEGL_IS_CACHE (self)
rect != NULL
The GeglNode to cache results for
gegl_cache_computed
GeglSampler
GEGL_IS_SAMPLER (self)
GEGL-gegl-sampler.c
bilinear
bicubic
RaGaBaA float
Input pad, for image buffer input.
sampler->context_rect[0].width <= maximum_width_and_height
sampler->context_rect[0].height <= maximum_width_and_height
sampler->context_rect[level].width <= maximum_width_and_height
sampler->context_rect[level].height <= maximum_width_and_height
level >= 0 && level < GEGL_SAMPLER_MIPMAP_LEVELS
gegl_sampler_get_from_mipmap
gegl_sampler_get_from_buffer
gegl_sampler_get_ptr
gegl_sampler_set_buffer
gegl_sampler_prepare
?catmullrom
formula
B-spline parameter
C-spline parameter
GeglSamplerCubic
B-spline type (cubic | catmullrom | formula) 2c+b=1
UUUUUU
?GEGL-gegl-sampler-linear.c
GeglSamplerLinear
GEGL-gegl-sampler-nearest.c
GeglSamplerNearest
GeglSamplerLohalo
@pExtents->y1 < pExtents->y2
GEGL-gegl-region-generic.c
pExtents->x1 < pExtents->x2
pReg->numRects <= pReg->size
y1 < y2
r->x1 < r->x2
x1 < r1->x2
rectangle != NULL
n_rectangles != NULL
source1 != NULL
source2 != NULL
region1 != NULL
region2 != NULL
spans != NULL
GeglRegion %p:
  { %d, %d, %dx%d },
pNextRect[-1].x1 < pNextRect[-1].x2
gegl_region_spans_intersect_foreach
gegl_region_rect_in
gegl_region_point_in
gegl_region_equal
gegl_region_empty
gegl_region_xor
miSubtractO
miSubtractNonO1
gegl_region_subtract
miUnionO
miUnionNonO
gegl_region_union
miSetExtents
miIntersectO
gegl_region_intersect
gegl_region_shrink
gegl_region_offset
gegl_region_destroy
gegl_region_union_with_rect
gegl_region_get_rectangles
gegl_region_get_clipbox
gegl_region_copy
gegl_region_rectangle
strange tile lock count: %i
GEGL-gegl-tile.c
unlocked a tile with lock count == 0
Unimplemented %s %i, %i, %i, %p
GEGL-gegl-tile-source.c
GeglTileSource
gegl_tile_source_command_eek
GeglTileStorage
Tile width in pixels
Tile height in pixels
GeglTileBackend
GEGL-gegl-tile-backend.c
backend->priv->format
Size of the tiles linear buffer in bytes
Size of a single pixel in bytes
backend->priv->tile_width > 0 && backend->priv->tile_height > 0
constructor
gegl buffer index writing problems for %s
next_allocation == self->offset
existing->tile.offset == item->tile.offset
unable to seek to tile in buffer: %s
unable to read tile data from self: %s (%d/%d bytes read) %s
unable to write tile data to self: %s (%d/%d bytes written)
tried to unlock unlocked buffer
GEGL-gegl-tile-backend-file.c
self->i != -1
self->o != -1
unable to seek in buffer
GeglTileBackendFile
self->file
gegl_tile_backend_file_load_index
gegl_tile_backend_file_constructor
gegl_tile_backend_file_write_block
gegl_tile_backend_file_ensure_exist
gegl_tile_backend_file_command
:GEGL-gegl-tile-backend-ram.c
GeglTileBackendRam
gegl_tile_backend_ram_command
The tilestore to be a facade for
GeglTileHandler
GEGL-gegl-tile-handler.c
GeglTileHandlerCache
cache-handler tile balance not zero: %i
GEGL-gegl-tile-handler-cache.c
gegl-tile-handler-chain.c
GeglTileHandlerChain
GEGL-gegl-tile-handler-chain.c
gegl_tile_handler_chain_command
GeglTileHandlerEmpty
(%s %p %p %i
(%s %p %p %i
GeglTileHandlerLog
idle
is_cached
exist
flush
refetch
last command
eeek
zoom->backend
GEGL-gegl-tile-handler-zoom.c
GeglTileHandlerZoom
get_tile
>id_pool != NULL
GEGL-gegl-id-pool.c
id_pool->array != NULL
id < id_pool->array->len
gegl_id_pool_lookup
gegl_id_pool_add
gegl_id_pool_free
GEGL-gegldatafiles.c
extension != NULL
path_str != NULL
loader_func != NULL
gegl_datafiles_read_directories
gegl_datafiles_check_extension
Module '%s' load error: %s
GEGL-geglmodule.c
GeglModule
Unloading module '%s'
gegl_module->module != NULL
GEGL_IS_MODULE (module)
info != NULL
gegl_module_query
Loading module '%s'
gegl_module_register
gegl_module->filename != NULL
gegl_module->module == NULL
Skipping module '%s'
Module error
Loaded
Load failed
Not loaded
state >= GEGL_MODULE_STATE_ERROR && state <= GEGL_MODULE_STATE_NOT_LOADED
module ABI version does not match op not loaded, to get rid of this warning remove (clean/uninstall) .so files in GEGLs search path.
gegl_module_query() returned NULL
Missing gegl_module_query() symbol
Missing gegl_module_register() symbol
gegl_module_register() returned FALSE
gegl_module_info_free
gegl_module_info_copy
gegl_module_state_name
gegl_module_set_load_inhibit
gegl_module_modified
gegl_module_query_module
gegl_module_new
gegl_module_load
gegl_module_unload
remove
module-modified
GeglModuleDB
GEGL_IS_MODULE_DB (db)
GEGL-geglmoduledb.c
module_path != NULL
gegl_module_db_refresh
gegl_module_db_load
gegl_module_db_get_load_inhibit
gegl_module_db_set_load_inhibit
No %s for extension "%s", falling back to "%s"
GEGL-gegl-extension-handler.c
loader
gegl:magick-load
saver
gegl:png-save
kilroy was at What The Hack (%p, %s)
%s: aborting, no associated node. This method should only be called after the operation is associated with a node.
%s Eeek: processing 0px rectangle
Operation '%s' has no get_bounding_box() method
klass->get_required_for_output
operation && operation->node && input_pad_name
GEGL-gegl-operation.c
GeglOperation
GEGL_IS_OPERATION (self)
param_spec != NULL
GEGL_IS_OPERATION (operation)
gegl-operation.c:159
input_pad != NULL
input_region != NULL
GEGL_IS_NODE (node)
klass->attach
gegl_pad_get_node (pad)
%s: returns NULL
gegl_operation_invalidate
gegl_operation_get_name
gegl_operation_get_format
gegl_operation_set_format
gegl_operation_detect
gegl_operation_get_source_node
gegl_operation_prepare
gegl_operation_attach
gegl_operation_get_required_for_output
gegl_operation_get_invalidated_by_change
gegl_operation_process
gegl_operation_create_pad
GeglOperationAreaFilter
Output pad for generated image buffer.
Auxiliary image buffer input pad.
requested processing of %s pad on a composer
GEGL-gegl-operation-composer.c
%s received NULL input and aux
Output
Input
GeglOperationComposer
Second auxiliary image buffer input pad.
GEGL-gegl-operation-composer3.c
%s received NULL input, aux, and aux2
aux2
GeglOperationComposer3
requested processing of %s pad on a filter
GEGL-gegl-operation-filter.c
klass->process
shouldn't happen
GeglOperationFilter
gegl_operation_filter_process
spec
GEGL-gegl-operation-meta.c
GeglOperationMeta
GEGL_IS_OPERATION_META (self)
gegl_operation_meta_property_changed
gegl_node_copy_property_property
GeglOperationPointComposer
GEGL-gegl-operation-point-composer.c
GeglOperationPointComposer3
GEGL-gegl-operation-point-composer3.c
GeglOperationPointFilter
gegl has-forked
out_format
gegl-operation-point-render.c
GeglOperationPointRender
GEGL-gegl-operation-point-render.c
gegl_operation_point_render_process
GEGL-gegl-operation-sink.c
GeglOperationSink
gegl_operation_sink_process
Gegl Source '%s' does not override %s()
requested processing of %s pad on a source operation
GEGL-gegl-operation-source.c
GeglOperationSource
gegl_operation_source_process
get_bounding_box
RGB u8
GeglOperationTemporal
using frame %i
%i > priv->count(%i), using frame %i
self
GEGL-gegl-operation-context.c
context != NULL
format != NULL
!strcmp (padname, "output")
%s: node %s has no pad|property named '%s'
didn't find property %s for %s
%s: No paramspec found for pad '%s' on "%s"
no format for %s presuming RGBA float
gegl_operation_context_get_target
gegl_operation_context_take_object
gegl_operation_context_get_property
gegl_operation_context_set_property
gegl_operation_context_set_result_rect
gegl_operation_context_set_need_rect
GEGL-gegl-operations.c
input_pad_name != NULL
GEGL_IS_NODE (operation->node)
gegl_operation_set_need_rect
The associated GeglOperation instance
The type of associated GeglOperation
Do not cache the result of this operation, the property is inherited by children created from a node.
%s: Can't find sink property %s of %s
%s: Can't find source property %s of %s
child->priv->parent == self || child->priv->parent == NULL
%s: Didn't find pad '%s' of '%s'
Failed to set operation type %s, using a passthrough op instead
The failing op was 'gegl:nop' this means that GEGL was unable to locate any of it's
plug-ins. Try making GEGL_PATH point to the directory containing the .so|.dll
files with the image processing plug-ins, optionally you could try to make it
point to the operations directory of a GEGL sourcetree with a build.
%s: property '%s' of operation class '%s' is not readable
self->is_graph || GEGL_IS_OPERATION (self->operation)
Operation Object
Operation Type
Do not cache
dont-cache
The name of the node
Name
GEGL_IS_NODE (self)
GEGL-gegl-node.c
GEGL_IS_PAD (pad)
property_name != NULL
value != NULL
GraphNode
context_id != NULL
roi != NULL
(none)
%s '%s' %p
%s %p
sink_pad_name
source_pad_name
GeglNode %p depends on:
  %s
didn't find context %p for %s
%s: no such pad %s for %s
output_pad != NULL
GEGL_IS_NODE (child)
child->priv->parent == NULL
proxynop-
%p %s
GEGL_IS_NODE (sink)
sink_pad_name != NULL
self == sink
self == source
proxynop-output
GEGL_IS_NODE (source)
source_pad_name != NULL
GEGL_IS_NODE (dest)
GEGL_IS_NODE (to_be_inserted)
notify
op_class
operation != NULL
Eeek!
G_IS_OBJECT (self)
gegl_node_get_output_proxy
gegl_node_get_input_proxy
gegl_node_create_child
gegl_node_get_children
gegl_node_get_nth_child
gegl_node_get_num_children
gegl_node_get_parent
gegl_node_remove_child
gegl_node_add_child
gegl_node_remove_children
gegl_node_set_name
gegl_node_get_name
gegl_node_get_cache
gegl_node_get_consumers
gegl_node_insert_before
gegl_node_add_context
gegl_node_remove_context
gegl_node_process
gegl_node_get_debug_name
gegl_node_set_need_rect
gegl_node_find_property
gegl_node_get_property
gegl_node_set_property
gegl_node_get_valist
gegl_node_set_valist
gegl_node_get
gegl_node_set
gegl_node_blit
gegl_node_link_many
gegl_node_link
gegl_node_get_sinks
gegl_node_get_num_sinks
gegl_node_find_connection
gegl_node_disconnect
gegl_node_pads_exist
gegl_node_connect_from
gegl_node_invalidated
gegl_node_remove_pad
gegl_node_add_pad
gegl_node_get_input_pads
gegl_node_get_pads
gegl_node_get_pad
gegl_node_disconnect_sinks
gegl_node_disconnect_sources
gegl_node_set_operation_object
gegl_node_set_op_class
GeglPad
self->connections == NULL
GEGL-gegl-pad.c
GEGL_IS_PAD (self)
GEGL_IS_PAD (sink)
GEGL_IS_PAD (source)
sink->connections == NULL
sink == gegl_connection_get_sink_pad (connection)
gegl_pad_get_format
gegl_pad_set_format
gegl_pad_set_node
gegl_pad_get_connected_to
gegl_pad_get_node
gegl_pad_get_num_connections
gegl_pad_get_connections
gegl_pad_disconnect
gegl_pad_connect
gegl_pad_set_param_spec
gegl_pad_get_param_spec
finalize
The identifier for the evaluation context
visitable already in visitor's hash table
evaluation-id
GEGL-gegl-visitor.c
visit_info
GeglVisitor
GEGL_IS_VISITOR (self)
set_discovered
get_discovered
set_shared_count
get_shared_count
set_visited
get_visited
gegl_visitor_get_visits_list
GeglVisitable
GEGL_IS_VISITABLE (interface)
GEGL-gegl-visitable.c
gegl_visitable_accept
GeglNeedVisitor
	have: %ix%i %i,%i
	need: %ix%i %i,%i
	result: %ix%i %i,%i
	refs: %i
GEGL-gegl-debug-rect-visitor.c
GeglDebugRectVisitor
GeglEvalMgr
GEGL_IS_EVAL_MGR (self)
GEGL-gegl-eval-mgr.c
root
gegl_eval_mgr_new
gegl_eval_mgr_apply
GEGL-gegl-eval-visitor.c
GeglEvalVisitor
eval-visitor encountered a NULL buffer passed from: %s.%s-[%p]
GeglFinishVisitor
defined-region
GeglHaveVisitor
GEGL-gegl-prepare-visitor.c
prepare
GeglPrepareVisitor
gegl_prepare_visitor_visit_node
The GeglNode to process (will saturate the provider's cache if the provided node is a sink node)
The rectangle of the region to process.
query progress; 0.0 is not started, 1.0 is done.
Size of chunks being rendered (larger chunks need more memory to do the processing).
GEGL_IS_OPERATION (node->operation)
Prepared to process a sink operation, but it had no "input" pad connected!
rectangle
progress
chunksize
GeglProcessor
GEGL-gegl-processor.c
processor->input != NULL
gegl_node_new_processor
render_rectangle
gegl_processor_render
gegl_processor_set_rectangle
gegl_processor_set_node
gegl_processor_progress
?%1.4f
rgb(%s, %s, %s)
rgba(%s, %s, %s, %s)
GeglColor
GEGL-gegl-color.c
rgba
GEGL_IS_COLOR (color)
pixel
GEGL_IS_COLOR (self)
GeglParamColor
black
silver
gray
white
maroon
purple
fuchsia
green
lime
olive
yellow
navy
blue
teal
aqua
A String representation of the GeglColor
Parsing of color string "%s" into GeglColor failed! Using transparent cyan instead
gegl_color_get_rgba
gegl_color_set_rgba
gegl_color_get_pixel
gegl_color_set_pixel
;GEGL-gegl-curve.c
GeglCurve
index < priv->points->len
GeglParamCurve
gegl_curve_set_point
gegl_curve_get_point
GEGL-gegl-path.c
GeglPath
EEek! no path
didn't find [%c]
EEEK
stroking uninitialized path
GeglParamPath
rel move to
rel line to
rel curve to
sentinel
end of instructions
control point type %c already exists
parsing of data %i items not implemented
can't compute length for instruction: %c
can't stroke for instruction: %i
gegl_path_list_append_item
@GeglParamDouble
GeglParamint
GeglParamString
GeglParamFilePath
GeglParamMultiline
GeglParamEnum
G_TYPE_IS_ENUM (enum_type)
GEGL-gegl-paramspecs.c
g_enum_get_value (enum_class, default_value) != NULL
GEGL_IS_PARAM_SPEC_ENUM (espec)
g_enum_get_value (G_PARAM_SPEC_ENUM (espec)->enum_class, value) != NULL
gegl_param_spec_enum_exclude_value
gegl_param_spec_enum
libOpenCL.so
clGetPlatformIDs
GEGL-gegl-cl-init.c
symbol gegl_##func is NULL
clGetPlatformInfo
clGetDeviceIDs
clGetDeviceInfo
clCreateContext
clCreateContextFromType
clCreateCommandQueue
clCreateProgramWithSource
clBuildProgram
clGetProgramBuildInfo
clCreateKernel
clSetKernelArg
clGetKernelWorkGroupInfo
clCreateBuffer
clEnqueueWriteBuffer
clEnqueueReadBuffer
clEnqueueCopyBuffer
clEnqueueReadBufferRect
clEnqueueWriteBufferRect
clEnqueueCopyBufferRect
clCreateImage2D
clEnqueueWriteImage
clEnqueueReadImage
clEnqueueCopyImage
clEnqueueCopyBufferToImage
clEnqueueCopyImageToBuffer
clEnqueueNDRangeKernel
clEnqueueBarrier
clFinish
clEnqueueMapBuffer
clEnqueueMapImage
clEnqueueUnmapMemObject
clReleaseKernel
clReleaseProgram
clReleaseCommandQueue
clReleaseContext
clReleaseMemObject
success
device not found
device not available
compiler not available
mem object allocation failure
out of resources
out of host memory
profiling info not available
mem copy overlap
image format mismatch
image format not supported
build program failure
map failure
invalid value
invalid device type
invalid platform
invalid device
invalid context
invalid queue properties
invalid command queue
invalid host ptr
invalid mem object
invalid image size
invalid sampler
invalid binary
invalid build options
invalid program
invalid program executable
invalid kernel name
invalid kernel definition
invalid kernel
invalid arg index
invalid arg value
invalid arg size
invalid kernel args
invalid work dimension
invalid work group size
invalid work item size
invalid global offset
invalid event wait list
invalid event
invalid operation
invalid gl object
invalid buffer size
invalid mip level
invalid global work size
cl_data->program = gegl_clCreateProgramWithSource(gegl_cl_get_context(), 1, &program_source, &length, &errcode)
OpenCL error in %s, Line %u in file %s
Error:%s
errcode = gegl_clGetProgramBuildInfo(cl_data->program, gegl_cl_get_device(), CL_PROGRAM_BUILD_LOG, 0, NULL, &s)
errcode = gegl_clGetProgramBuildInfo(cl_data->program, gegl_cl_get_device(), CL_PROGRAM_BUILD_LOG, s, msg, NULL)
cl_data->kernel[i] = gegl_clCreateKernel(cl_data->program, kernel_name[i], &errcode)
invalid image format descriptor
RGBA u8
R'G'B' u8
R'G'B'A float
Y'CbCrA float
YA float
Y u8
Y float
rgbau8_to_rgbaf
rgbaf_to_rgbau8
rgbaf_to_ragabaf
ragabaf_to_rgbaf
rgbau8_to_ragabaf
ragabaf_to_rgbau8
rgbaf_to_rgba_gamma_f
rgba_gamma_f_to_rgbaf
rgbau8_to_rgba_gamma_f
rgba_gamma_f_to_rgbau8
rgbaf_to_ycbcraf
ycbcraf_to_rgbaf
rgbau8_to_ycbcraf
ycbcraf_to_rgbau8
rgbu8_to_rgbaf
rgbaf_to_rgbu8
yu8_to_yf
rgbaf_to_yaf
yaf_to_rgbaf
rgbau8_to_yaf
yaf_to_rgbau8
rgbaf_to_rgba_gamma_u8
rgba_gamma_u8_to_rgbaf
rgbaf_to_rgb_gamma_u8
rgb_gamma_u8_to_rgbaf
rgba_gamma_u8_to_ragabaf
ragabaf_to_rgba_gamma_u8
rgb_gamma_u8_to_ragabaf
ragabaf_to_rgb_gamma_u8
rgba_gamma_u8_to_yaf
yaf_to_rgba_gamma_u8
rgb_gamma_u8_to_yaf
yaf_to_rgb_gamma_u8
/* This is almost a copy-paste from babl/base conversion functions in RGBA space */      
                                                                                         
/* Alpha threshold used in the reference implementation for                              
 * un-pre-multiplication of color data:                                                  
 *                                                                                       
 * 0.01 / (2^16 - 1)                                                                     
 */                                                                                      
#define BABL_ALPHA_THRESHOLD 0.0f                                                        
                                                                                         
float linear_to_gamma_2_2 (float value)                                                  
{                                                                                        
  if (value > 0.0030402477f)                                                             
    return 1.055f * native_powr (value, (1.0f/2.4f)) - 0.055f;                           
  return 12.92f * value;                                                                 
}                                                                                        
                                                                                         
float gamma_2_2_to_linear (float value)                                                  
{                                                                                        
  if (value > 0.03928f)                                                                  
    return native_powr ((value + 0.055f) / 1.055f, 2.4f);                                
  return value / 12.92f;                                                                 
}                                                                                        
__kernel void rgbau8_to_rgbaf (__global const uchar4 * in,                               
                               __global       float4 * out)                              
{                                                                                        
  int gid = get_global_id(0);                                                            
  float4 in_v  = convert_float4(in[gid]) / 255.0f;                                       
  float4 out_v = in_v;                                                                   
  out[gid] = out_v;                                                                      
}                                                                                        
__kernel void rgbaf_to_rgbau8 (__global const float4 * in,                               
                               __global       uchar4 * out)                              
{                                                                                        
  int gid = get_global_id(0);                                                            
  float4 in_v  = in[gid];                                                                
  float4 out_v = in_v;                                                                   
  out[gid] = convert_uchar4_sat_rte(255.0f * out_v);                                     
}                                                                                        
__kernel void rgbaf_to_ragabaf (__global const float4 * in,                              
                                __global       float4 * out)                             
{                                                                                        
  int gid = get_global_id(0);                                                            
  float4 in_v = in[gid];                                                                 
  float4 out_v;                                                                          
  out_v   = in_v * in_v.w;                                                               
  out_v.w = in_v.w;                                                                      
  out[gid] = out_v;                                                                      
}                                                                                        
                                                                                         
__kernel void ragabaf_to_rgbaf (__global const float4 * in,                              
                                __global       float4 * out)                             
{                                                                                        
  int gid = get_global_id(0);                                                            
  float4 in_v  = in[gid];                                                                
  float4 out_v;                                                                          
  out_v = (in_v.w > BABL_ALPHA_THRESHOLD)? in_v / in_v.w : (float4)(0.0f);               
  out_v.w = in_v.w;                                                                      
  out[gid] = out_v;                                                                      
}                                                                                        
__kernel void rgbau8_to_ragabaf (__global const uchar4 * in,                             
                                 __global       float4 * out)                            
{                                                                                        
  int gid = get_global_id(0);                                                            
  float4 in_v  = convert_float4(in[gid]) / 255.0f;                                       
  float4 out_v;                                                                          
  out_v   = in_v * in_v.w;                                                               
  out_v.w = in_v.w;                                                                      
  out[gid] = out_v;                                                                      
}                                                                                        
                                                                                         
__kernel void ragabaf_to_rgbau8 (__global const float4 * in,                             
                                 __global       uchar4 * out)                            
{                                                                                        
  int gid = get_global_id(0);                                                            
  float4 in_v  = in[gid];                                                                
  float4 out_v;                                                                          
  out_v = (in_v.w > BABL_ALPHA_THRESHOLD)? in_v / in_v.w : (float4)(0.0f);               
  out_v.w = in_v.w;                                                                      
  out[gid] = convert_uchar4_sat_rte(255.0f * out_v);                                     
}                                                                                        
__kernel void rgba_gamma_u8_to_ragabaf (__global const uchar4 * in,                      
                                        __global       float4 * out)                     
{                                                                                        
  int gid = get_global_id(0);                                                            
  float4 in_v  = convert_float4(in[gid]) / 255.0f;                                       
  float4 tmp_v;                                                                          
  tmp_v = (float4)(gamma_2_2_to_linear(in_v.x),                                          
                   gamma_2_2_to_linear(in_v.y),                                          
                   gamma_2_2_to_linear(in_v.z),                                          
                   in_v.w);                                                              
  float4 out_v;                                                                          
  out_v   = tmp_v * tmp_v.w;                                                             
  out_v.w = tmp_v.w;                                                                     
  out[gid] = out_v;                                                                      
}                                                                                        
                                                                                         
__kernel void ragabaf_to_rgba_gamma_u8 (__global const float4 * in,                      
                                        __global       uchar4 * out)                     
{                                                                                        
  int gid = get_global_id(0);                                                            
  float4 in_v  = in[gid];                                                                
  float4 tmp_v;                                                                          
  tmp_v = (in_v.w > BABL_ALPHA_THRESHOLD)? in_v / in_v.w : (float4)(0.0f);               
  tmp_v.w = in_v.w;                                                                      
  float4 out_v;                                                                          
  out_v = (float4)(linear_to_gamma_2_2(tmp_v.x),                                         
                   linear_to_gamma_2_2(tmp_v.y),                                         
                   linear_to_gamma_2_2(tmp_v.z),                                         
                   tmp_v.w);                                                             
  out[gid] = convert_uchar4_sat_rte(255.0f * out_v);                                     
}                                                                                        
__kernel void rgb_gamma_u8_to_ragabaf (__global const uchar  * in,                       
                                       __global       float4 * out)                      
{                                                                                        
  int gid = get_global_id(0);                                                            
  float3 in_v  = convert_float3(vload3 (gid, in)) / 255.0f;                              
  float4 tmp_v;                                                                          
  tmp_v = (float4)(gamma_2_2_to_linear(in_v.x),                                          
                   gamma_2_2_to_linear(in_v.y),                                          
                   gamma_2_2_to_linear(in_v.z),                                          
                   1.0f);                                                                
  float4 out_v;                                                                          
  out_v   = tmp_v * tmp_v.w;                                                             
  out_v.w = tmp_v.w;                                                                     
  out[gid] = out_v;                                                                      
}                                                                                        
                                                                                         
__kernel void ragabaf_to_rgb_gamma_u8 (__global const float4 * in,                       
                                       __global       uchar  * out)                      
{                                                                                        
  int gid = get_global_id(0);                                                            
  float4 in_v  = in[gid];                                                                
  float4 tmp_v;                                                                          
  tmp_v = (in_v.w > BABL_ALPHA_THRESHOLD)? in_v / in_v.w : (float4)(0.0f);               
  tmp_v.w = in_v.w;                                                                      
  float4 out_v;                                                                          
  out_v = (float4)(linear_to_gamma_2_2(tmp_v.x),                                         
                   linear_to_gamma_2_2(tmp_v.y),                                         
                   linear_to_gamma_2_2(tmp_v.z),                                         
                   tmp_v.w);                                                             
  vstore3 (convert_uchar3_sat_rte(255.0f * out_v.xyz * out_v.w), gid, out);              
}                                                                                        
__kernel void rgbaf_to_rgba_gamma_f (__global const float4 * in,                         
                                     __global       float4 * out)                        
{                                                                                        
  int gid = get_global_id(0);                                                            
  float4 in_v  = in[gid];                                                                
  float4 out_v;                                                                          
  out_v = (float4)(linear_to_gamma_2_2(in_v.x),                                          
                   linear_to_gamma_2_2(in_v.y),                                          
                   linear_to_gamma_2_2(in_v.z),                                          
                   in_v.w);                                                              
  out[gid] = out_v;                                                                      
}                                                                                        
__kernel void rgba_gamma_f_to_rgbaf (__global const float4 * in,                         
                                     __global       float4 * out)                        
{                                                                                        
  int gid = get_global_id(0);                                                            
  float4 in_v  = in[gid];                                                                
  float4 out_v;                                                                          
  out_v = (float4)(gamma_2_2_to_linear(in_v.x),                                          
                   gamma_2_2_to_linear(in_v.y),                                          
                   gamma_2_2_to_linear(in_v.z),                                          
                   in_v.w);                                                              
  out[gid] = out_v;                                                                      
}                                                                                        
__kernel void rgbau8_to_rgba_gamma_f (__global const uchar4 * in,                        
                                      __global       float4 * out)                       
{                                                                                        
  int gid = get_global_id(0);                                                            
  float4 in_v  = convert_float4(in[gid]) / 255.0f;                                       
  float4 out_v;                                                                          
  out_v = (float4)(linear_to_gamma_2_2(in_v.x),                                          
                   linear_to_gamma_2_2(in_v.y),                                          
                   linear_to_gamma_2_2(in_v.z),                                          
                   in_v.w);                                                              
  out[gid] = out_v;                                                                      
}                                                                                        
__kernel void rgba_gamma_f_to_rgbau8 (__global const float4 * in,                        
                                      __global       uchar4 * out)                       
{                                                                                        
  int gid = get_global_id(0);                                                            
  float4 in_v  = in[gid];                                                                
  float4 out_v;                                                                          
  out_v = (float4)(gamma_2_2_to_linear(in_v.x),                                          
                   gamma_2_2_to_linear(in_v.y),                                          
                   gamma_2_2_to_linear(in_v.z),                                          
                   in_v.w);                                                              
  out[gid] = convert_uchar4_sat_rte(255.0f * out_v);                                     
}                                                                                        
__kernel void rgbaf_to_ycbcraf (__global const float4 * in,                              
                                __global       float4 * out)                             
{                                                                                        
  int gid = get_global_id(0);                                                            
  float4 in_v  = in[gid];                                                                
  float4 out_v;                                                                          
                                                                                         
  float3 rgb = (float3)(linear_to_gamma_2_2(in_v.x),                                     
                        linear_to_gamma_2_2(in_v.y),                                     
                        linear_to_gamma_2_2(in_v.z));                                    
                                                                                         
  out_v = (float4)( 0.299f    * rgb.x + 0.587f    * rgb.y + 0.114f    * rgb.z,           
                   -0.168736f * rgb.x - 0.331264f * rgb.y + 0.5f      * rgb.z,           
                    0.5f      * rgb.x - 0.418688f * rgb.y - 0.081312f * rgb.z,           
                   in_v.w);                                                              
  out[gid] = out_v;                                                                      
}                                                                                        
__kernel void ycbcraf_to_rgbaf (__global const float4 * in,                              
                                __global       float4 * out)                             
{                                                                                        
  int gid = get_global_id(0);                                                            
  float4 in_v  = in[gid];                                                                
  float4 out_v;                                                                          
                                                                                         
  float4 rgb = (float4)(1.0f * in_v.x + 0.0f      * in_v.y + 1.40200f    * in_v.z,       
                        1.0f * in_v.x - 0.344136f * in_v.y - 0.71414136f * in_v.z,       
                        1.0f * in_v.x + 1.772f    * in_v.y + 0.0f        * in_v.z,       
                        0.0f);                                                           
                                                                                         
  out_v = (float4)(linear_to_gamma_2_2(rgb.x),                                           
                   linear_to_gamma_2_2(rgb.y),                                           
                   linear_to_gamma_2_2(rgb.z),                                           
                   in_v.w);                                                              
  out[gid] = out_v;                                                                      
}                                                                                        
__kernel void rgbau8_to_ycbcraf (__global const uchar4 * in,                             
                                 __global       float4 * out)                            
{                                                                                        
  int gid = get_global_id(0);                                                            
  float4 in_v  = convert_float4(in[gid]) / 255.0f;                                       
  float4 out_v;                                                                          
                                                                                         
  float4 rgb = (float4)(linear_to_gamma_2_2(in_v.x),                                     
                        linear_to_gamma_2_2(in_v.y),                                     
                        linear_to_gamma_2_2(in_v.z),                                     
                        0.0f);                                                           
                                                                                         
  out_v = (float4)( 0.299f    * rgb.x + 0.587f    * rgb.y + 0.114f    * rgb.z,           
                   -0.168736f * rgb.x - 0.331264f * rgb.y + 0.5f      * rgb.z,           
                    0.5f      * rgb.x - 0.418688f * rgb.y - 0.081312f * rgb.z,           
                   in_v.w);                                                              
  out[gid] = out_v;                                                                      
}                                                                                        
__kernel void ycbcraf_to_rgbau8 (__global const float4 * in,                             
                                 __global       uchar4 * out)                            
{                                                                                        
  int gid = get_global_id(0);                                                            
  float4 in_v  = in[gid];                                                                
  float4 out_v;                                                                          
                                                                                         
  float4 rgb = (float4)(1.0f * in_v.x + 0.0f      * in_v.y + 1.40200f    * in_v.z,       
                        1.0f * in_v.x - 0.344136f * in_v.y - 0.71414136f * in_v.z,       
                        1.0f * in_v.x + 1.772f    * in_v.y + 0.0f        * in_v.z,       
                        0.0f);                                                           
                                                                                         
  out_v = (float4)(gamma_2_2_to_linear(rgb.x),                                           
                   gamma_2_2_to_linear(rgb.y),                                           
                   gamma_2_2_to_linear(rgb.z),                                           
                   in_v.w);                                                              
  out[gid] = convert_uchar4_sat_rte(255.0f * out_v);                                     
}                                                                                        
__kernel void rgbu8_to_rgbaf (__global const uchar  * in,                                
                              __global       float4 * out)                               
{                                                                                        
  int gid = get_global_id(0);                                                            
  uchar3 in_v;                                                                           
  float4 out_v;                                                                          
  in_v = vload3 (gid, in);                                                               
  out_v.xyz = convert_float3(in_v) / 255.0f;                                             
  out_v.w   = 1.0f;                                                                      
  out[gid]  = out_v;                                                                     
}                                                                                        
__kernel void rgbaf_to_rgbu8 (__global const float4 * in,                                
                              __global       uchar  * out)                               
{                                                                                        
  int gid = get_global_id(0);                                                            
  float4 in_v  = in[gid];                                                                
  uchar3 out_v = convert_uchar3_sat_rte(255.0f * in_v.w * in_v.xyz);                     
  vstore3 (out_v, gid, out);                                                             
}                                                                                        
__kernel void yu8_to_yf (__global const uchar * in,                                      
                         __global       float * out)                                     
{                                                                                        
  int gid = get_global_id(0);                                                            
  float in_v  = convert_float (in[gid]) / 255.0f;                                        
  float out_v;                                                                           
  out_v = in_v;                                                                          
  out[gid] = out_v;                                                                      
}                                                                                        
  /* source: http://www.poynton.com/ColorFAQ.html */                                     
  #define RGB_LUMINANCE_RED    (0.212671f)                                               
  #define RGB_LUMINANCE_GREEN  (0.715160f)                                               
  #define RGB_LUMINANCE_BLUE   (0.072169f)                                               
__kernel void rgbaf_to_yaf (__global const float4 * in,                                  
                            __global       float2 * out)                                 
{                                                                                        
  int gid = get_global_id(0);                                                            
  float4 in_v  = in[gid];                                                                
  float2 out_v;                                                                          
                                                                                         
  float luminance = in_v.x * RGB_LUMINANCE_RED +                                         
                    in_v.y * RGB_LUMINANCE_GREEN +                                       
                    in_v.z * RGB_LUMINANCE_BLUE;                                         
                                                                                         
  out_v.x = luminance;                                                                   
  out_v.y = in_v.w;                                                                      
                                                                                         
  out[gid] = out_v;                                                                      
}                                                                                        
__kernel void yaf_to_rgbaf (__global const float2 * in,                                  
                            __global       float4 * out)                                 
{                                                                                        
  int gid = get_global_id(0);                                                            
  float2 in_v  = in[gid];                                                                
  float4 out_v = (float4) (in_v.x, in_v.x, in_v.x, in_v.y);                              
                                                                                         
  out[gid] = out_v;                                                                      
}                                                                                        
__kernel void rgbau8_to_yaf (__global const uchar4 * in,                                 
                             __global       float2 * out)                                
{                                                                                        
  int gid = get_global_id(0);                                                            
  float4 in_v  = convert_float4(in[gid]) / 255.0f;                                       
  float2 out_v;                                                                          
                                                                                         
  float luminance = in_v.x * RGB_LUMINANCE_RED +                                         
                    in_v.y * RGB_LUMINANCE_GREEN +                                       
                    in_v.z * RGB_LUMINANCE_BLUE;                                         
                                                                                         
  out_v.x = luminance;                                                                   
  out_v.y = in_v.w;                                                                      
                                                                                         
  out[gid] = out_v;                                                                      
}                                                                                        
__kernel void yaf_to_rgbau8 (__global const float2 * in,                                 
                             __global       uchar4 * out)                                
{                                                                                        
  int gid = get_global_id(0);                                                            
  float2 in_v  = in[gid];                                                                
  float4 out_v = (float4) (in_v.x, in_v.x, in_v.x, in_v.y);                              
                                                                                         
  out[gid] = convert_uchar4_sat_rte(255.0f * out_v);                                     
}                                                                                        
__kernel void rgba_gamma_u8_to_yaf (__global const uchar4 * in,                          
                                    __global       float2 * out)                         
{                                                                                        
  int gid = get_global_id(0);                                                            
  float4 in_v  = convert_float4(in[gid]) / 255.0f;                                       
  float4 tmp_v;                                                                          
  tmp_v = (float4)(gamma_2_2_to_linear(in_v.x),                                          
                   gamma_2_2_to_linear(in_v.y),                                          
                   gamma_2_2_to_linear(in_v.z),                                          
                   in_v.w);                                                              
  float2 out_v;                                                                          
                                                                                         
  float luminance = tmp_v.x * RGB_LUMINANCE_RED +                                        
                    tmp_v.y * RGB_LUMINANCE_GREEN +                                      
                    tmp_v.z * RGB_LUMINANCE_BLUE;                                        
                                                                                         
  out_v.x = luminance;                                                                   
  out_v.y = tmp_v.w;                                                                     
                                                                                         
  out[gid] = out_v;                                                                      
}                                                                                        
__kernel void yaf_to_rgba_gamma_u8 (__global const float2 * in,                          
                                    __global       uchar4 * out)                         
{                                                                                        
  int gid = get_global_id(0);                                                            
  float2 in_v  = in[gid];                                                                
  float4 tmp_v = (float4) (in_v.x, in_v.x, in_v.x, in_v.y);                              
                                                                                         
  float4 out_v;                                                                          
  out_v = (float4)(linear_to_gamma_2_2(tmp_v.x),                                         
                   linear_to_gamma_2_2(tmp_v.y),                                         
                   linear_to_gamma_2_2(tmp_v.z),                                         
                   tmp_v.w);                                                             
  out[gid] = convert_uchar4_sat_rte(255.0f * out_v);                                     
}                                                                                        
__kernel void rgb_gamma_u8_to_yaf (__global const uchar  * in,                           
                                   __global       float2 * out)                          
{                                                                                        
  int gid = get_global_id(0);                                                            
  float3 in_v  = convert_float3(vload3 (gid, in)) / 255.0f;                              
  float4 tmp_v;                                                                          
  tmp_v = (float4)(gamma_2_2_to_linear(in_v.x),                                          
                   gamma_2_2_to_linear(in_v.y),                                          
                   gamma_2_2_to_linear(in_v.z),                                          
                   1.0f);                                                                
  float2 out_v;                                                                          
                                                                                         
  float luminance = tmp_v.x * RGB_LUMINANCE_RED +                                        
                    tmp_v.y * RGB_LUMINANCE_GREEN +                                      
                    tmp_v.z * RGB_LUMINANCE_BLUE;                                        
                                                                                         
  out_v.x = luminance;                                                                   
  out_v.y = tmp_v.w;                                                                     
                                                                                         
  out[gid] = out_v;                                                                      
}                                                                                        
__kernel void yaf_to_rgb_gamma_u8 (__global const float2 * in,                           
                                   __global       uchar  * out)                          
{                                                                                        
  int gid = get_global_id(0);                                                            
  float2 in_v  = in[gid];                                                                
  float4 tmp_v = (float4) (in_v.x, in_v.x, in_v.x, in_v.y);                              
                                                                                         
  float4 out_v;                                                                          
  out_v = (float4)(linear_to_gamma_2_2(tmp_v.x),                                         
                   linear_to_gamma_2_2(tmp_v.y),                                         
                   linear_to_gamma_2_2(tmp_v.z),                                         
                   tmp_v.w);                                                             
  vstore3 (convert_uchar3_sat_rte(255.0f * out_v.xyz * out_v.w), gid, out);              
}                                                                                        
__kernel void rgbaf_to_rgba_gamma_u8 (__global const float4 * in,                        
                                      __global       uchar4 * out)                       
{                                                                                        
  int gid = get_global_id(0);                                                            
  float4 in_v  = in[gid];                                                                
  float4 out_v;                                                                          
  out_v = (float4)(linear_to_gamma_2_2(in_v.x),                                          
                   linear_to_gamma_2_2(in_v.y),                                          
                   linear_to_gamma_2_2(in_v.z),                                          
                   in_v.w);                                                              
  out[gid] = convert_uchar4_sat_rte(255.0f * out_v);                                     
}                                                                                        
__kernel void rgba_gamma_u8_to_rgbaf (__global const uchar4 * in,                        
                                      __global       float4 * out)                       
{                                                                                        
  int gid = get_global_id(0);                                                            
  float4 in_v  = convert_float4(in[gid]) / 255.0f;                                       
  float4 out_v;                                                                          
  out_v = (float4)(gamma_2_2_to_linear(in_v.x),                                          
                   gamma_2_2_to_linear(in_v.y),                                          
                   gamma_2_2_to_linear(in_v.z),                                          
                   in_v.w);                                                              
  out[gid] = out_v;                                                                      
}                                                                                        
__kernel void rgbaf_to_rgb_gamma_u8 (__global const float4 * in,                         
                                     __global       uchar  * out)                        
{                                                                                        
  int gid = get_global_id(0);                                                            
  float4 in_v  = in[gid];                                                                
  float4 tmp_v;                                                                          
  uchar3 out_v;                                                                          
  tmp_v = (float4)(linear_to_gamma_2_2(in_v.x),                                          
                   linear_to_gamma_2_2(in_v.y),                                          
                   linear_to_gamma_2_2(in_v.z),                                          
                   in_v.w);                                                              
  out_v = convert_uchar3_sat_rte(255.0f * tmp_v.w * tmp_v.xyz);                          
  vstore3 (out_v, gid, out);                                                             
}                                                                                        
__kernel void rgb_gamma_u8_to_rgbaf (__global const uchar  * in,                         
                                     __global       float4 * out)                        
{                                                                                        
  int gid = get_global_id(0);                                                            
  uchar3 in_v;                                                                           
  float3 tmp_v;                                                                          
  float4 out_v;                                                                          
  in_v = vload3 (gid, in);                                                               
  tmp_v = convert_float3(in_v) / 255.0f;                                                 
  out_v = (float4)(gamma_2_2_to_linear(tmp_v.x),                                         
                   gamma_2_2_to_linear(tmp_v.y),                                         
                   gamma_2_2_to_linear(tmp_v.z),                                         
                   1.0f);                                                                
  out[gid] = out_v;                                                                      
}                                                                                        
;*2$"8
libgegl-0.2.so.0.199.1.debug
7zXZ
~ps#
	n4Dq
iC}D
HKPSi
:8z6
hg F
:taMcp
{0r[
y11\
/kCs
0L(,
$D+(y]
%c[>
@  t@
 X0?
h>ic/;7VFqE
,G|2C
XKb=
)Y|1
[=O}
_AnT14F
^Wk~
-!J`
&xg84
Ev@&
:TSY2
U2B$
~uY!
!/D0Q
b&,u
sN$Y
rTx&ql3
YNe7P
	|\,I
1s3n
>XQ\
VBoW6
:1#q
3v!3
o(h/
H},3
gxaxX
Dl6s
\R%9
1+Ba
I	-%
ic"&
~iI5
+{~2
Y.kf
tnw@
L:4ER
MD{l|
7o$*
*dZ.
6WIC
eoxS
QO>$I
7Cuc
56*2
jALQ
;DL/
,6,/
Rkpx
BqE4*
@)25
Wx;wy
2?Atkn<
F#PU
	w]G
]&U 
UpV Ao
P6@	
o=Ha
.shstrtab
.note.gnu.build-id
.gnu.hash
.dynsym
.dynstr
.gnu.version
.gnu.version_r
.rel.dyn
.init
.plt
.plt.got
.text
.fini
.rodata
.eh_frame_hdr
.eh_frame
.init_array
.fini_array
.jcr
.data.rel.ro
.dynamic
.data
.bss
.gnu_debuglink
.gnu_debugdata
