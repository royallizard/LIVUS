(T~@Lp
A6@X
||%M
__gmon_start__
_init
_fini
__cxa_finalize
_Jv_RegisterClasses
value_get_as_float
workbook_date_conv
datetime_value_to_g
value_new_error_NUM
get_yieldmat
g_date_compare
yearfrac
value_new_float
g_return_if_fail_warning
value_new_error_VALUE
goal_seek_initialize
goal_seek_newton
goal_seek_point
goal_seek_bisection
g_date_get_month
g_date_get_year
g_date_subtract_months
g_date_get_day
g_date_is_last_of_month
g_date_add_days
go_coupdaybs
go_coupdaysnc
go_coupdays
pow1p
pow1pm1
collect_floats_value
g_free
value_get_as_int
get_vdb
datetime_value_to_serial
value_new_error_DIV0
g_date_is_leap_year
annual_year_basis
value_is_zero
go_coup_cd
days_between_basis
g_date_add_months
ceil
float_range_function
log1p
floor
get_mduration
go_finite
value_peek_string
get_duration
log10
go_pow10
get_cumprinc
get_cumipmt
value_get_as_checked_bool
go_format_default_date
value_set_fmt
datetime_g_to_serial
get_amorlinc
get_amordegrc
go_plugin_depends
go_plugin_header
financial_functions
libm.so.6
libc.so.6
_edata
__bss_start
_end
plugin.so
GLIBC_2.2.5
5BI!
%DI!
%BI!
%:I!
%2I!
%*I!
%"I!
%zH!
%rH!
%jH!
%bH!
%ZH!
%RH!
%JH!
%BH!
%:H!
%2H!
%*H!
%"H!
%zG!
=HG!
ATSubH
=8E!
=oC!
%l(!
='(!
fffff.
t$0H
\$HH
l$PL
d$XL
l$`L
t$hL
|$pH
|$ H
t$ H
\$0H
l$8L
d$@L
l$HL
t$PH
ffffff.
l$ H
D$ H
z8s6
ATUH
[]A\
l$ H
l$0D
l$(H
D$ H
D$(f
ffff.
AUATUSH
 []A\A]A^
[]A\A]A^
^D$0
D$@D)
\L$H
D$@f
YL$8
YL$ 
^L$@
^L$0
YL$8H
P[A\A]
YL$@
XD$8
^L$0
YL$8H
P[A\A]
fff.
\C 1
ATUH
d$PH
T$0H
T$0H
\$@H
`[]A\
`[]A\
ffff.
\$HH
l$PH
D$8f
YT$8
\$8H
l$@H
D$ f
L$ 1
YL$(
YT$(
YL$ 
YD$(
L$,M
D$ H
\$0H
l$8L
d$@L
l$HL
t$PH
L$(M
D$,;D$(
9l$,
D$xH
l$pH
ffffff.
([A\
d$ H
d$ f
D$0H
D$ H
L$(f
.L$0wb
L$0f
.D$ s6
ffff.
l$ H
d$ H
fff.
d$ H
d$ H
d$ H
\$ I
\$8H
l$@L
d$HL
l$PL
t$XL
|$`H
l$ L
l$0H
l$ L
d$(L
l$0H
ffff.
l$ L
d$(L
l$0L
t$8L
l$ L
d$(L
l$0L
t$8L
|$@H
ffff.
l$ L
l$ L
d$(L
l$0H
ffffff.
|$ 1
d$ L
l$(L
t$0H
l$(L
d$ L
l$(L
t$0H
l$(L
ffff.
l$ L
l$ L
d$(L
l$0H
l$PH
|$@H
\$hH
l$pL
d$xL
D$0H
.L$(
$yoH
.L$ w3
YL$(
YL$ 
L$<L
D$0H
\$@H
l$HL
d$PL
l$XL
t$`H
D$<E
XT$(
T$(~Hf
XT$ 
L$ f
D$(f
YD$ 
^D$ 
D$0f
d$ H
D$(H
D$(H
\$8E
T$8E
L$8E
AUATUSH
[]A\A]A^
D$(L
D$(H
^D$ 
[]A\A]A^
l$0L
D$8L
D$8H
D$(H
[]A\A]A^
ffff.
T$ f
^D$ H
ffffff.
D$ H
D$(H
L$0H
ffff.
D$ H
D$ H
YL$ 
([]f
d$ D
\$8H
l$@L
d$HL
l$PL
t$XL
|$`H
fffff.
D$4H
T$@H
l$pL
T$@H
t$`L
.D$ 
D$`H
\$0H
*\$0
\T$(
YL$(
D$4H
T$@H
l$pL
T$@H
t$`L
D$`H
\$0H
*L$0
YD$(
AVAUM
T$8H
T$(A
|$@L
|$@L
|$@L
^L$H
XL$x
L$`f
.L$p
^D$p
t$@H
|$8L
YD$pH
|$@L
YD$pL
|$8L
YD$p
^D$p
^L$p
^L$p
^L$x
^D$x
^D$p
XT$hf
^D$H
[]A\A]A^A_
\C(1
D$$H
T$0H
l$`L
T$0H
t$PL
T$0H
\$@H
fffff.
D$(H
u/z-
D$ f
YT$(
YD$ f
\L$0
XL$(f
^D$ H
\$(H
l$0H
\$(H
l$0H
ffffff.
D$ f
YL$ 
\D$ 
ATUH
T$ L
d$@H
P[]A\
T$ H
\$0H
fffff.
ffff.
ffffff.
l$@H
T$ H
T$ H
\$0H
P[]A\
\L$ 
XL$ H
8[]f
\L$0
XL$0
8[]f
\L$ 
XL$ H
8[]f
\L$0
XD$0H
d$ L
l$(L
t$0H
d$ L
t$0H
d$ L
l$(L
t$0H
d$ L
t$0H
d$0H
\$ H
\$HH
l$PL
d$XL
l$`H
fffff.
d$ H
d$ H
|$0L
\$HH
l$PL
d$XL
l$`L
t$hL
|$pH
\$ L
|$0L
\$HH
l$PL
d$XL
l$`L
t$hL
|$pH
\$ L
D$0f
D$ f
D$8f
YD$0
L$(f
\D$(
L$ H
D$ f
YD$0f
ATUSH
D$8f
D$@f
D$8E1
\D$0f
D$H9
D$Hu
\D$@
[]A\
fff.
ATUS
D$@f
XL$H
XD$P
\D$(
XD$ 
\D$X
t$(f
.t$P
\$0f
L$8f
D$HH
`[]A\
X\$0
XD$(
u#z!
$$~?
^\$8
u#z!
$$~+f
YT$8
ffffff.
 []A\
ffffff.
 []A\
^L$(
^T$(
L$ f
D$ f
XL$8
L$8w
D$HH
XD$0
YL$ 
XL$8
XD$@
D$ f
XL$@
^D$(H
L$HH
XL$0
YT$ f
fffff.
d$@L
l$HL
YL$ 
Y\$ 
X\$(H
fff.
YD$ 
YD$ 
XD$ 
v != NULL
goffice
gnumeric
1.8.2
accrint
ffffff|f
accrintm
issue,maturity,rate,par,basis
amordegrc
amorlinc
coupdaybs
fff|fb
coupdays
coupdaysnc
coupncd
coupnum
couppcd
cumipmt
cumprinc
dollarde
fractional_dollar,fraction
dollarfr
decimal_dollar,fraction
effect
rate,nper
euro
currency
euroconvert
n,source,target
rate,nper,pmt,pv,type
fvschedule
pv,schedule
g_duration
rate,pv,fv
intrate
rate,per,nper,pv,fv,type
values,guess
ispmt
rate,per,nper,pv
mduration
mirr
nominal
rate,pmt,pv,fv,type
rate,values
oddfprice
fffffffff
oddfyield
oddlprice
oddlyield
rate,nper,pv,fv,type
ppmt
pricedisc
pricemat
rate,nper,pmt,fv,type
fff|fff
nper,pmt,pv,fv,type,guess
received
cost,salvagevalue,life
cost,salvagevalue,life,period
tbilleq
settlement,maturity,discount
tbillprice
tbillyield
settlement,maturity,pr
fffff|ff
xirr
AA|f
values,dates,guess
xnpv
rate,values,dates
yielddisc
yieldmat
munG
value_get_freq
issue,first_interest,settlement,rate,par,frequency,basis
cost,purchase_date,first_period,salvage,period,rate,basis
settlement,maturity,frequency,basis,eom
rate,nper,pv,start_period,end_period,type
cost,salvage,life,period,month
cost,salvage,life,period,factor
settlement,maturity,pr,redemption,basis
settlement,maturity,coup,yield,frequency,basis
settlement,maturity,investment,redemption,basis
settlement,maturify,coupon,yield,frequency,basis
values,finance_rate,reinvest_rate
settlement,maturity,issue,first_coupon,rate,yld,redemption,frequency,basis
settlement,maturity,issue,first_coupon,rate,pr,redemption,frequency,basis
settlement,maturity,last_interest,rate,yld,redemption,frequency,basis
settlement,maturity,last_interest,rate,pr,redemption,frequency,basis
settlement,maturity,rate,yield,redemption_price,frequency,basis
settlement,maturity,discount,redemption,basis
settlement,maturity,issue,rate,yield,basis
settlement,maturity,investment,discount,basis
cost,salvage,life,start_period,end_period,factor,switch
settlement,maturity,rate,price,redemption_price,frequency,basis
settlement,maturity,issue,rate,pr,basis
@FUNCTION=ACCRINT
@SYNTAX=ACCRINT(issue,first_interest,settlement,rate,par,frequency[,basis])
@DESCRIPTION=ACCRINT calculates the accrued interest for a security that pays periodic interest.
@issue is the issue date of the security.  @first_interest is the first interest date of the security.  @settlement is the settlement date of the security.  The settlement date is always after the issue date (the date when the security is bought). @rate is the annual rate of the security and @par is the par value of the security. @frequency is the number of coupon payments per year.
Allowed frequencies are:
  1 = annual,
  2 = semi,
  4 = quarterly.
@basis is the type of day counting system you want to use:
  0  US 30/360
  1  actual days/actual days
  2  actual days/360
  3  actual days/365
  4  European 30/360
* If @issue date, @first_interest date, or @settlement date is not valid, ACCRINT returns #NUM! error.
* The dates must be @issue < @first_interest < @settlement, or ACCRINT returns #NUM! error.
* If @rate <= 0 or @par <= 0 , ACCRINT returns #NUM! error.
* If @basis is omitted, US 30/360 is applied.
* If @basis < 0 or @basis > 4, ACCRINT returns #NUM! error.
* If @issue date is after @settlement date or they are the same, ACCRINT returns #NUM! error.
@EXAMPLES=
@SEEALSO=ACCRINTM
@FUNCTION=ACCRINTM
@SYNTAX=ACCRINTM(issue,maturity,rate[,par,basis])
@DESCRIPTION=ACCRINTM calculates and returns the accrued interest for a security from @issue to @maturity date.
@issue is the issue date of the security.  @maturity is the maturity date of the security.  @rate is the annual rate of the security and @par is the par value of the security. If you omit @par, ACCRINTM applies $1,000 instead.  @basis is the type of day counting system you want to use:
  0  US 30/360
  1  actual days/actual days
  2  actual days/360
  3  actual days/365
  4  European 30/360
* If @issue date or @maturity date is not valid, ACCRINTM returns #NUM! error.
* If @rate <= 0 or @par <= 0, ACCRINTM returns #NUM! error.
* If @basis is omitted, US 30/360 is applied.
* If @basis < 0 or @basis > 4, ACCRINTM returns #NUM! error.
* If @issue date is after @maturity date or they are the same, ACCRINTM returns #NUM! error.
@EXAMPLES=
@SEEALSO=ACCRINT
@FUNCTION=AMORDEGRC
@SYNTAX=AMORDEGRC(cost,purchase_date,first_period,salvage,period,rate[,basis])
@DESCRIPTION=AMORDEGRC: Calculates depreciation for each accounting period using French accounting conventions.   Assets purchased in the middle of a period take prorated depreciation into account.  This is similar to AMORLINC, except that a depreciation coefficient is applied in the calculation depending on the life of the assets.
Named for AMORtissement DEGRessif Comptabilite
@cost The value of the asset.
@purchase_date The date the asset was purchased.
@first_period The end of the first period.
@salvage Asset value at maturity.
@period The length of accounting periods.
@rate rate of depreciation as a percentage.
@basis is the type of day counting system you want to use:
  0  US 30/360
  1  actual days/actual days
  2  actual days/360
  3  actual days/365
  4  European 30/360
* If @basis is omitted, US 30/360 is applied.
* If @basis is not in between 0 and 4, #NUM! error is returned.
@EXAMPLES=
AMORDEGRC(2400,DATE(1998,8,19),DATE(1998,12,30),300,1,0.14,1) = 733
@SEEALSO=AMORLINC
@FUNCTION=AMORLINC
@SYNTAX=AMORLINC(cost,purchase_date,first_period,salvage,period,rate[,basis])
@DESCRIPTION=AMORLINC: Calculates depreciation for each accounting period using French accounting conventions.   Assets purchased in the middle of a period take prorated depreciation into account.
Named for AMORtissement LINeaire Comptabilite.
@cost The value of the asset.
@purchase_date The date the asset was purchased.
@first_period The end of the first period.
@salvage Asset value at maturity.
@period The length of accounting periods.
@rate rate of depreciation as a percentage.
@basis is the type of day counting system you want to use:
  0  US 30/360
  1  actual days/actual days
  2  actual days/360
  3  actual days/365
  4  European 30/360
* If @basis is omitted, US 30/360 is applied.
* If @basis is not in between 0 and 4, #NUM! error is returned.
@EXAMPLES=
AMORLINC(2400,DATE(1998,8,19),DATE(1998,12,31),300,1,0.15,1) = 360
@SEEALSO=AMORDEGRC
@FUNCTION=COUPDAYBS
@SYNTAX=COUPDAYBS(settlement,maturity,frequency[,basis,eom])
@DESCRIPTION=COUPDAYBS returns the number of days from the beginning of the coupon period to the settlement date.
@settlement is the settlement date of the security.
@maturity is the maturity date of the security.
@frequency is the number of coupon payments per year.
@eom = TRUE handles end of month maturity dates special.
Allowed frequencies are: 1 = annual, 2 = semi, 4 = quarterly, 6 = bimonthly, 12 = monthly.
@basis is the type of day counting system you want to use:
  0  MSRB 30/360 (MSRB Rule G33 (e))
  1  actual days/actual days
  2  actual days/360
  3  actual days/365
  4  European 30/360
  5  European+ 30/360
(See the gnumeric manual for a detailed description of these bases).
* If @frequency is invalid, COUPDAYBS returns #NUM! error.
* If @basis is omitted, MSRB 30/360 is applied.
* If @basis is invalid, #NUM! error is returned.
@EXAMPLES=
COUPDAYBS (DATE(2002,11,29),DATE(2004,2,29),4,0) = 89
COUPDAYBS (DATE(2002,11,29),DATE(2004,2,29),4,0,FALSE) = 0
@SEEALSO=
@FUNCTION=COUPDAYS
@SYNTAX=COUPDAYS(settlement,maturity,frequency[,basis,eom])
@DESCRIPTION=COUPDAYS returns the number of days in the coupon period of the settlement date.
@settlement is the settlement date of the security.
@maturity is the maturity date of the security.
@frequency is the number of coupon payments per year.
@eom = TRUE handles end of month maturity dates special.
Allowed frequencies are: 1 = annual, 2 = semi, 4 = quarterly, 6 = bimonthly, 12 = monthly.
@basis is the type of day counting system you want to use:
  0  MSRB 30/360 (MSRB Rule G33 (e))
  1  actual days/actual days
  2  actual days/360
  3  actual days/365
  4  European 30/360
  5  European+ 30/360
(See the gnumeric manual for a detailed description of these bases).
* If @frequency is invalid, COUPDAYS returns #NUM! error.
* If @basis is omitted, MSRB 30/360 is applied.
* If @basis is invalid, #NUM! error is returned.
@EXAMPLES=
COUPDAYS (DATE(2002,11,29),DATE(2004,2,29),4,0) = 90
COUPDAYS (DATE(2002,11,29),DATE(2004,2,29),4,0,FALSE) = 90
COUPDAYS (DATE(2002,11,29),DATE(2004,2,29),4,1,FALSE) = 91
@SEEALSO=
@FUNCTION=COUPDAYSNC
@SYNTAX=COUPDAYSNC(settlement,maturity,frequency[,basis,eom])
@DESCRIPTION=COUPDAYSNC returns the number of days from the settlement date to the next coupon date.
@settlement is the settlement date of the security.
@maturity is the maturity date of the security.
@frequency is the number of coupon payments per year.
@eom = TRUE handles end of month maturity dates special.
Allowed frequencies are: 1 = annual, 2 = semi, 4 = quarterly, 6 = bimonthly, 12 = monthly.
@basis is the type of day counting system you want to use:
  0  MSRB 30/360 (MSRB Rule G33 (e))
  1  actual days/actual days
  2  actual days/360
  3  actual days/365
  4  European 30/360
  5  European+ 30/360
(See the gnumeric manual for a detailed description of these bases).
* If @frequency is invalid, COUPDAYSNC returns #NUM! error.
* If @basis is omitted, MSRB 30/360 is applied.
* If @basis is invalid, #NUM! error is returned.
@EXAMPLES=
COUPDAYSNC (DATE(2002,11,29),DATE(2004,2,29),4,0) = 1
COUPDAYSNC (DATE(2002,11,29),DATE(2004,2,29),4,0,FALSE) = 89
@SEEALSO=
@FUNCTION=COUPNCD
@SYNTAX=COUPNCD(settlement,maturity,frequency[,basis,eom])
@DESCRIPTION=COUPNCD returns the coupon date following settlement.
@settlement is the settlement date of the security.
@maturity is the maturity date of the security.
@frequency is the number of coupon payments per year.
@eom = TRUE handles end of month maturity dates special.
Allowed frequencies are: 1 = annual, 2 = semi, 4 = quarterly, 6 = bimonthly, 12 = monthly.
@basis is the type of day counting system you want to use:
  0  MSRB 30/360 (MSRB Rule G33 (e))
  1  actual days/actual days
  2  actual days/360
  3  actual days/365
  4  European 30/360
  5  European+ 30/360
(See the gnumeric manual for a detailed description of these bases).
* If @frequency is invalid, COUPNCD returns #NUM! error.
* If @basis is omitted, MSRB 30/360 is applied.
* If @basis is invalid, #NUM! error is returned.
@EXAMPLES=
COUPNCD (DATE(2002,11,29),DATE(2004,2,29),4,0) = 30-Nov-2002
COUPNCD (DATE(2002,11,29),DATE(2004,2,29),4,0,FALSE) = 28-Feb-2003
@SEEALSO=
@FUNCTION=COUPNUM
@SYNTAX=COUPNUM(settlement,maturity,frequency[,basis,eom])
@DESCRIPTION=COUPNUM returns the numbers of coupons to be paid between the settlement and maturity dates, rounded up.
@settlement is the settlement date of the security.
@maturity is the maturity date of the security.
@frequency is the number of coupon payments per year.
@eom = TRUE handles end of month maturity dates special.
Allowed frequencies are: 1 = annual, 2 = semi, 4 = quarterly. 6 = bimonthly, 12 = monthly.
@basis is the type of day counting system you want to use:
  0  MSRB 30/360 (MSRB Rule G33 (e))
  1  actual days/actual days
  2  actual days/360
  3  actual days/365
  4  European 30/360
  5  European+ 30/360
* If @frequency is other than 1, 2, 4, 6 or 12, COUPNUM returns #NUM! error.
* If @basis is omitted, MSRB 30/360 is applied.
* If @basis is not in between 0 and 5, #NUM! error is returned.
@EXAMPLES=
COUPNUM (DATE(2002,11,29),DATE(2004,2,29),4,0) = 6
COUPNUM (DATE(2002,11,29),DATE(2004,2,29),4,0,FALSE) = 5
@SEEALSO=
@FUNCTION=COUPPCD
@SYNTAX=COUPPCD(settlement,maturity,frequency[,basis,eom])
@DESCRIPTION=COUPPCD returns the coupon date preceding settlement.
@settlement is the settlement date of the security.
@maturity is the maturity date of the security.
@frequency is the number of coupon payments per year.
@eom = TRUE handles end of month maturity dates special.
Allowed frequencies are: 1 = annual, 2 = semi, 4 = quarterly, 6 = bimonthly, 12 = monthly.
@basis is the type of day counting system you want to use:
  0  MSRB 30/360 (MSRB Rule G33 (e))
  1  actual days/actual days
  2  actual days/360
  3  actual days/365
  4  European 30/360
  5  European+ 30/360
(See the gnumeric manual for a detailed description of these bases).
* If @frequency is invalid, COUPPCD returns #NUM! error.
* If @basis is omitted, MSRB 30/360 is applied.
* If @basis is invalid, #NUM! error is returned.
@EXAMPLES=
COUPPCD (DATE(2002,11,29),DATE(2004,2,29),4,0) = 31-Aug-2002
COUPPCD (DATE(2002,11,29),DATE(2004,2,29),4,0,FALSE) = 29-Nov-2002
@SEEALSO=
@FUNCTION=CUMIPMT
@SYNTAX=CUMIPMT(rate,nper,pv,start_period,end_period,type)
@DESCRIPTION=CUMIPMT returns the cumulative interest paid on a loan between @start_period and @end_period.
* If @rate <= 0, CUMIPMT returns #NUM! error.
* If @nper <= 0, CUMIPMT returns #NUM! error.
* If @pv <= 0, CUMIPMT returns #NUM! error.
* If @start_period < 1, CUMIPMT returns #NUM! error.
* If @end_period < @start_period, CUMIPMT returns #NUM! error.
* If @end_period > @nper, CUMIPMT returns #NUM! error.
* If @type <> 0 and @type <> 1, CUMIPMT returns #NUM! error.
@EXAMPLES=
@SEEALSO=
@FUNCTION=CUMPRINC
@SYNTAX=CUMPRINC(rate,nper,pv,start_period,end_period,type)
@DESCRIPTION=CUMPRINC returns the cumulative principal paid on a loan between @start_period and @end_period.
* If @rate <= 0, CUMPRINC returns #NUM! error.
* If @nper <= 0, CUMPRINC returns #NUM! error.
* If @pv <= 0, CUMPRINC returns #NUM! error.
* If @start_period < 1, CUMPRINC returns #NUM! error.
* If @end_period < @start_period, CUMPRINC returns #NUM! error.
* If @end_period > @nper, CUMPRINC returns #NUM! error.
* If @type <> 0 and @type <> 1, CUMPRINC returns #NUM! error.
@EXAMPLES=
@SEEALSO=
@FUNCTION=DB
@SYNTAX=DB(cost,salvage,life,period[,month])
@DESCRIPTION=DB calculates the depreciation of an asset for a given period using the fixed-declining balance method.  @cost is the initial value of the asset.  @salvage is the value after the depreciation.
@life is the number of periods overall.  @period is the period for which you want the depreciation to be calculated.  @month is the number of months in the first year of depreciation.
* If @month is omitted, it is assumed to be 12.
* If @cost = 0, DB returns #NUM! error.
* If @life <= 0, DB returns #NUM! error.
* If @salvage / @cost < 0, DB returns #NUM! error.
@EXAMPLES=
@SEEALSO=DDB,SLN,SYD
@FUNCTION=DDB
@SYNTAX=DDB(cost,salvage,life,period[,factor])
@DESCRIPTION=DDB returns the depreciation of an asset for a given period using the double-declining balance method or some other similar method you specify.
@cost is the initial value of the asset, @salvage is the value after the last period, @life is the number of periods, @period is the period for which you want the depreciation to be calculated, and @factor is the factor at which the balance declines.
* If @factor is omitted, it is assumed to be two (double-declining balance method).
* If @life <= 0, DDB returns #NUM! error.
@EXAMPLES=
@SEEALSO=SLN,SYD
@FUNCTION=DISC
@SYNTAX=DISC(settlement,maturity,par,redemption[,basis])
@DESCRIPTION=DISC calculates and returns the discount rate for a security. @settlement is the settlement date of the security.
@maturity is the maturity date of the security.  @par is the price per $100 face value of the security.  @redemption is the redemption value per $100 face value of the security.
@basis is the type of day counting system you want to use:
  0  US 30/360
  1  actual days/actual days
  2  actual days/360
  3  actual days/365
  4  European 30/360
* If @settlement date or @maturity date is not valid, DISC returns #NUM! error.
* If @basis is omitted, US 30/360 is applied.
* If @basis < 0 or @basis > 4, DISC returns #NUM! error.
* If @settlement date is after @maturity date or they are the same, DISC returns #NUM! error.
@EXAMPLES=
@SEEALSO=
@FUNCTION=DOLLARDE
@SYNTAX=DOLLARDE(fractional_dollar,fraction)
@DESCRIPTION=DOLLARDE converts a dollar price expressed as a fraction into a dollar price expressed as a decimal number.
@fractional_dollar is the fractional number to be converted. @fraction is the denominator of the fraction.
* If @fraction is non-integer it is truncated.
* If @fraction <= 0, DOLLARDE returns #NUM! error.
@EXAMPLES=
@SEEALSO=DOLLARFR
@FUNCTION=DOLLARFR
@SYNTAX=DOLLARFR(decimal_dollar,fraction)
@DESCRIPTION=DOLLARFR converts a decimal dollar price into a dollar price expressed as a fraction.
* If @fraction is non-integer it is truncated.
* If @fraction <= 0, DOLLARFR returns #NUM! error.
@EXAMPLES=
@SEEALSO=DOLLARDE
@FUNCTION=DURATION
@SYNTAX=DURATION(settlement,maturity,coup,yield,frequency[,basis])
@DESCRIPTION=DURATION calculates the duration of a security.
@settlement is the settlement date of the security.
@maturity is the maturity date of the security.
@coup The annual coupon rate as a percentage.
@yield The annualized yield of the security as a percentage.
@frequency is the number of coupon payments per year. Allowed frequencies are: 1 = annual, 2 = semi, 4 = quarterly. @basis is the type of day counting system you want to use:
  0  US 30/360
  1  actual days/actual days
  2  actual days/360
  3  actual days/365
  4  European 30/360
* If @frequency is other than 1, 2, or 4, DURATION returns #NUM! error.
* If @basis is omitted, US 30/360 is applied.
* If @basis is not in between 0 and 4, #NUM! error is returned.
@EXAMPLES=
@SEEALSO=G_DURATION,MDURATION
@FUNCTION=EFFECT
@SYNTAX=EFFECT(r,nper)
@DESCRIPTION=EFFECT calculates the effective interest rate from a given nominal rate.
Effective interest rate is calculated using this formula:
    (1 + @r / @nper) ^ @nper - 1
where:
@r = nominal interest rate (stated in yearly terms)
@nper = number of periods used for compounding
* If @rate < 0, EFFECT returns #NUM! error.
* If @nper <= 0, EFFECT returns #NUM! error.
@EXAMPLES=
For example credit cards will list an APR (annual percentage rate) which is a nominal interest rate.
For example if you wanted to find out how much you are actually paying interest on your credit card that states an APR of 19% that is compounded monthly you would type in:
=EFFECT(.19,12) and you would get .2075 or 20.75%. That is the effective percentage you will pay on your loan.
@SEEALSO=NOMINAL
@FUNCTION=EURO
@SYNTAX=EURO(currency)
@DESCRIPTION=EURO converts one Euro to a given national currency in the European monetary union.
@currency is one of the following:
    ATS	(Austria)
    BEF	(Belgium)
    DEM	(Germany)
    ESP	(Spain)
    EUR	(Euro)
    FIM	(Finland)
    FRF	(France)
    GRD	(Greek)
    IEP	(Ireland)
    ITL	(Italy)
    LUF	(Luxembourg)
    NLG	(Netherlands)
    PTE	(Portugal)
* If the given @currency is other than one of the above, EURO returns #NUM! error.
@EXAMPLES=
EURO("DEM") returns 1.95583.
@SEEALSO=
@FUNCTION=EUROCONVERT
@SYNTAX=EUROCONVERT(n,source,target)
@DESCRIPTION=EUROCONVERT converts the currency value @n of @source currency to a target currency @target. Both currencies are given as three-letter strings using the ISO code system names.  The following currencies are available:
    ATS	(Austria)
    BEF	(Belgium)
    DEM	(Germany)
    ESP	(Spain)
    EUR	(Euro)
    FIM	(Finland)
    FRF	(France)
    GRD	(Greek)
    IEP	(Ireland)
    ITL	(Italy)
    LUF	(Luxembourg)
    NLG	(Netherlands)
    PTE	(Portugal)
* If the given @source or @target is other than one of the above, EUROCONVERT returns #VALUE! error.
@EXAMPLES=
EUROCONVERT(2.1,"DEM","EUR") returns 1.07.
@SEEALSO=EURO
@FUNCTION=FV
@SYNTAX=FV(rate,nper,pmt[,pv,type])
@DESCRIPTION=FV computes the future value of an investment. This is based on periodic, constant payments and a constant interest rate. The interest rate per period is @rate, @nper is the number of periods in an annuity, @pmt is the payment made each period, @pv is the present value and @type is when the payment is made.
* If @type = 1 then the payment is made at the beginning of the period.
* If @type = 0 it is made at the end of each period.
@EXAMPLES=
@SEEALSO=PV,PMT,PPMT
@FUNCTION=FVSCHEDULE
@SYNTAX=FVSCHEDULE(principal,schedule)
@DESCRIPTION=FVSCHEDULE returns the future value of given initial value after applying a series of compound periodic interest rates. The argument @principal is the present value; @schedule is an array of interest rates to apply. The @schedule argument must be a range of cells.
@EXAMPLES=
Let us assume that the cells A1, A2, ..., A5 contain interest rates 0.11, 0.13, 0.09, 0.17, and 0.03.  Then
FVSCHEDULE(3000,A1:A5) equals 4942.7911611.
@SEEALSO=PV,FV
@FUNCTION=G_DURATION
@SYNTAX=G_DURATION(rate,pv,fv)
@DESCRIPTION=G_DURATION calculates number of periods needed for an investment to attain a desired value. This function is similar to FV and PV with a difference that we do not need give the direction of cash flows e.g. -100 for a cash outflow and +100 for a cash inflow.
* If @rate <= 0, G_DURATION returns #DIV0 error.
* If @fv = 0 or @pv = 0, G_DURATION returns #DIV0 error.
* If @fv / @pv < 0, G_DURATION returns #VALUE error.
@EXAMPLES=
@SEEALSO=PPMT,PV,FV,DURATION,MDURATION
@FUNCTION=INTRATE
@SYNTAX=INTRATE(settlement,maturity,investment,redemption[,basis])
@DESCRIPTION=INTRATE calculates and returns the interest rate of a fully vested security.
@settlement is the settlement date of the security.  @maturity is the maturity date of the security. @investment is the price of the security paid at @settlement date and @redemption is the amount to be received at @maturity date.
@basis is the type of day counting system you want to use:
  0  US 30/360
  1  actual days/actual days
  2  actual days/360
  3  actual days/365
  4  European 30/360
* If @settlement date or @maturity date is not valid, INTRATE returns #NUM! error.
* If @basis is omitted, US 30/360 is applied.
* If @basis < 0 or @basis > 4, INTRATE returns #NUM! error.
* If @settlement date is after @maturity date or they are the same, INTRATE returns #NUM! error.
@EXAMPLES=
If you had a bond with a settlement date of April 15, 2000, maturity date September 30, 2000, investment of $100,000, redemption value $103,525, using the actual/actual basis, the bond discount rate is:
=INTRATE(36631, 36799, 100000, 103525, 1) which equals 0.0648 or 6.48%
@SEEALSO=RECEIVED, DATE
@FUNCTION=IPMT
@SYNTAX=IPMT(rate,per,nper,pv[,fv,type])
@DESCRIPTION=IPMT calculates the amount of a payment of an annuity going towards interest.
Formula for IPMT is:
IPMT(PER) = -PRINCIPAL(PER-1) * INTEREST_RATE
where:
PRINCIPAL(PER-1) = amount of the remaining principal from last period
* If @fv is omitted, it is assumed to be 0.
* If @type is omitted, it is assumed to be 0.
@EXAMPLES=
@SEEALSO=PPMT,PV,FV
@FUNCTION=IRR
@SYNTAX=IRR(values[,guess])
@DESCRIPTION=IRR calculates and returns the internal rate of return of an investment.  This function is closely related to the net present value function (NPV).  The IRR is the interest rate for a series of cash flows where the net preset value is zero.
@values contains the series of cash flows generated by the investment.  The payments should occur at regular intervals.  The optional @guess is the initial value used in calculating the IRR.  You do not have to use that, it is only provided for the Excel compatibility.
* This function is Excel compatible.
@EXAMPLES=
Let us assume that the cells A1:A8 contain the numbers -32432, 5324, 7432, 9332, 12324, 4334, 1235, -3422.  Then
IRR(A1:A8) returns 0.04375. 
@SEEALSO=FV,NPV,PV
@FUNCTION=ISPMT
@SYNTAX=ISPMT(rate,per,nper,pv)
@DESCRIPTION=ISPMT function returns the interest paid on a given period.
* If @per < 1 or @per > @nper, ISPMT returns #NUM! error. 
@EXAMPLES=
@SEEALSO=PV
@FUNCTION=MDURATION
@SYNTAX=MDURATION(settlement,maturity,coupon,yield,frequency[,basis])
@DESCRIPTION=MDURATION returns the Macauley duration for a security with par value 100.
@basis is the type of day counting system you want to use:
  0  MSRB 30/360 (MSRB Rule G33 (e))
  1  actual days/actual days
  2  actual days/360
  3  actual days/365
  4  European 30/360
  5  European+ 30/360
* If @settlement or @maturity are not valid dates, MDURATION returns #NUM! error.
* If @frequency is other than 1, 2, or 4, MDURATION returns #NUM! error.
* If @basis is omitted, MSRB 30/360 is applied.
* If @basis is invalid, #NUM! error is returned.
@EXAMPLES=
@SEEALSO=DURATION,G_DURATION
@FUNCTION=MIRR
@SYNTAX=MIRR(values,finance_rate,reinvest_rate)
@DESCRIPTION=MIRR function returns the modified internal rate of return for a given periodic cash flow. 
@EXAMPLES=
@SEEALSO=NPV
@FUNCTION=NOMINAL
@SYNTAX=NOMINAL(r,nper)
@DESCRIPTION=NOMINAL calculates the nominal interest rate from a given effective rate.
Nominal interest rate is given by a formula:
@nper * (( 1 + @r ) ^ (1 / @nper) - 1 )
where:
@r = effective interest rate
@nper = number of periods used for compounding
* If @rate < 0, NOMINAL returns #NUM! error.
* If @nper <= 0, NOMINAL returns #NUM! error.
@EXAMPLES=
@SEEALSO=EFFECT
@FUNCTION=NPER
@SYNTAX=NPER(rate,pmt,pv[,fv,type])
@DESCRIPTION=NPER calculates number of periods of an investment based on periodic constant payments and a constant interest rate.
The interest rate per period is @rate, @pmt is the payment made each period, @pv is the present value, @fv is the future value and @type is when the payments are due. If @type = 1, payments are due at the beginning of the period, if @type = 0, payments are due at the end of the period.
* If @rate <= 0, NPER returns #DIV0 error.
@EXAMPLES=
For example, if you deposit $10,000 in a savings account that earns an interest rate of 6%. To calculate how many years it will take to double your investment use NPER as follows:
=NPER(0.06, 0, -10000, 20000,0)returns 11.895661046 which indicates that you can double your money just before the end of the 12th year.
@SEEALSO=PPMT,PV,FV
@FUNCTION=NPV
@SYNTAX=NPV(rate,v1,v2,...)
@DESCRIPTION=NPV calculates the net present value of an investment generating periodic payments.  @rate is the periodic interest rate and @v1, @v2, ... are the periodic payments.  If the schedule of the cash flows are not periodic use the XNPV function. 
@EXAMPLES=
NPV(0.17,-10000,3340,2941,2493,3233,1732,2932) equals 186.30673.
@SEEALSO=PV,XNPV
@FUNCTION=ODDFPRICE
@SYNTAX=ODDFPRICE(settlement,maturity,issue,first_coupon,rate,yld,redemption,frequency[,basis])
@DESCRIPTION=ODDFPRICE returns the price per $100 face value of a security. The security should have an odd short or long first period.
@settlement is the settlement date of the security. @maturity is the maturity date of the security. @issue is the issue date of the security. @frequency is the number of coupon payments per year. Allowed frequencies are: 1 = annual, 2 = semi, 4 = quarterly. @basis is the type of day counting system you want to use:
  0  US 30/360
  1  actual days/actual days
  2  actual days/360
  3  actual days/365
  4  European 30/360
* If @frequency is other than 1, 2, or 4, ODDFPRICE returns #NUM! error.
* If @basis is omitted, US 30/360 is applied.
* If @basis is not in between 0 and 4, #NUM! error is returned.
@EXAMPLES=
@SEEALSO=
@FUNCTION=ODDFYIELD
@SYNTAX=ODDFYIELD(settlement,maturity,issue,first_coupon,rate,pr,redemption,frequency[,basis])
@DESCRIPTION=ODDFYIELD calculates the yield of a security having an odd first period.
@settlement is the settlement date of the security. @maturity is the maturity date of the security. @frequency is the number of coupon payments per year. Allowed frequencies are: 1 = annual, 2 = semi, 4 = quarterly. @basis is the type of day counting system you want to use:
  0  US 30/360
  1  actual days/actual days
  2  actual days/360
  3  actual days/365
  4  European 30/360
* If @frequency is other than 1, 2, or 4, ODDFYIELD returns #NUM! error.
* If @basis is omitted, US 30/360 is applied.
* If @basis is not in between 0 and 4, #NUM! error is returned.
@EXAMPLES=
@SEEALSO=
@FUNCTION=ODDLPRICE
@SYNTAX=ODDLPRICE(settlement,maturity,last_interest,rate,yld,redemption,frequency[,basis])
@DESCRIPTION=ODDLPRICE calculates the price per $100 face value of a security that has an odd last coupon period.
@settlement is the settlement date of the security. @maturity is the maturity date of the security. @frequency is the number of coupon payments per year. Allowed frequencies are: 1 = annual, 2 = semi, 4 = quarterly. @basis is the type of day counting system you want to use:
  0  US 30/360
  1  actual days/actual days
  2  actual days/360
  3  actual days/365
  4  European 30/360
* If @frequency is other than 1, 2, or 4, ODDLPRICE returns #NUM! error.
* If @basis is omitted, US 30/360 is applied.
* If @basis is not in between 0 and 4, #NUM! error is returned.
@EXAMPLES=
@SEEALSO=
@FUNCTION=ODDLYIELD
@SYNTAX=ODDLYIELD(settlement,maturity,last_interest,rate,pr,redemption,frequency[,basis])
@DESCRIPTION=ODDLYIELD calculates the yield of a security having an odd last period.
@settlement is the settlement date of the security. @maturity is the maturity date of the security. @frequency is the number of coupon payments per year. Allowed frequencies are: 1 = annual, 2 = semi, 4 = quarterly. @basis is the type of day counting system you want to use:
  0  US 30/360
  1  actual days/actual days
  2  actual days/360
  3  actual days/365
  4  European 30/360
* If @frequency is other than 1, 2, or 4, ODDLYIELD returns #NUM! error.
* If @basis is omitted, US 30/360 is applied.
* If @basis is not in between 0 and 4, #NUM! error is returned.
@EXAMPLES=
@SEEALSO=
@FUNCTION=PMT
@SYNTAX=PMT(rate,nper,pv[,fv,type])
@DESCRIPTION=PMT returns the amount of payment for a loan based on a constant interest rate and constant payments (each payment is equal amount).
@rate is the constant interest rate.
@nper is the overall number of payments.
@pv is the present value.
@fv is the future value.
@type is the type of the payment: 0 means at the end of the period and 1 means at the beginning of the period.
* If @fv is omitted, Gnumeric assumes it to be zero.
* If @type is omitted, Gnumeric assumes it to be zero.
@EXAMPLES=
@SEEALSO=PPMT,PV,FV
@FUNCTION=PPMT
@SYNTAX=PPMT(rate,per,nper,pv[,fv,type])
@DESCRIPTION=PPMT calculates the amount of a payment of an annuity going towards principal.
Formula for it is:
PPMT(per) = PMT - IPMT(per)
where:
PMT = Payment received on annuity
IPMT(per) = amount of interest for period @per
* If @fv is omitted, it is assumed to be 0.
* If @type is omitted, it is assumed to be 0.
@EXAMPLES=
@SEEALSO=IPMT,PV,FV
@FUNCTION=PRICE
@SYNTAX=PRICE(settle,mat,rate,yield,redemption_price,[frequency,basis])
@DESCRIPTION=PRICE returns price per $100 face value of a security. This method can only be used if the security pays periodic interest.
@frequency is the number of coupon payments per year. Allowed frequencies are: 1 = annual, 2 = semi, 4 = quarterly. @basis is the type of day counting system you want to use:
  0  US 30/360
  1  actual days/actual days
  2  actual days/360
  3  actual days/365
  4  European 30/360
* If @frequency is other than 1, 2, or 4, PRICE returns #NUM! error.
* If @basis is omitted, US 30/360 is applied.
* If @basis is not in between 0 and 4, #NUM! error is returned.
@EXAMPLES=
@SEEALSO=
@FUNCTION=PRICEDISC
@SYNTAX=PRICEDISC(settlement,maturity,discount,redemption[,basis])
@DESCRIPTION=PRICEDISC calculates and returns the price per $100 face value of a security bond.  The security does not pay interest at maturity.
@settlement is the settlement date of the security. @maturity is the maturity date of the security.  @discount is the rate for which the security is discounted.  @redemption is the amount to be received on @maturity date.
@basis is the type of day counting system you want to use:
  0  US 30/360
  1  actual days/actual days
  2  actual days/360
  3  actual days/365
  4  European 30/360
* If @settlement date or @maturity date is not valid, PRICEDISC returns #NUM! error.
* If @basis is omitted, US 30/360 is applied.
* If @basis < 0 or @basis > 4, PRICEDISC returns #NUM! error.
* If @settlement date is after @maturity date or they are the same, PRICEDISC returns #NUM! error.
@EXAMPLES=
@SEEALSO=PRICEMAT
@FUNCTION=PRICEMAT
@SYNTAX=PRICEMAT(settlement,maturity,issue,rate,yield[,basis])
@DESCRIPTION=PRICEMAT calculates and returns the price per $100 face value of a security.  The security pays interest at maturity.
@settlement is the settlement date of the security.  @maturity is the maturity date of the security.  @issue is the issue date of the security.  @rate is the discount rate of the security. @yield is the annual yield of the security. @basis is the type of day counting system you want to use:
  0  US 30/360
  1  actual days/actual days
  2  actual days/360
  3  actual days/365
  4  European 30/360
* If @settlement date or @maturity date is not valid, PRICEMAT returns #NUM! error.
* If @basis is omitted, US 30/360 is applied.
* If @basis < 0 or @basis > 4, PRICEMAT returns #NUM! error.
* If @settlement date is after @maturity date or they are the same, PRICEMAT returns #NUM! error.
@EXAMPLES=
@SEEALSO=PRICEDISC
@FUNCTION=PV
@SYNTAX=PV(rate,nper,pmt[,fv,type])
@DESCRIPTION=PV calculates the present value of an investment. @rate is the periodic interest rate, @nper is the number of periods used for compounding. @pmt is the payment made each period, @fv is the future value and @type is when the payment is made.
* If @type = 1 then the payment is made at the beginning of the period.
* If @type = 0 (or omitted) it is made at the end of each period.
@EXAMPLES=
@SEEALSO=FV
@FUNCTION=RATE
@SYNTAX=RATE(nper,pmt,pv[,fv,type,guess])
@DESCRIPTION=RATE calculates the rate of an investment.
* If @pmt is ommitted it defaults to 0
* If @nper <= 0, RATE returns #NUM! error.
* If @type != 0 and @type != 1, RATE returns #VALUE! error.
@EXAMPLES=
@SEEALSO=PV,FV
@FUNCTION=RECEIVED
@SYNTAX=RECEIVED(settlement,maturity,investment,rate[,basis])
@DESCRIPTION=RECEIVED calculates and returns the amount to be received at maturity date for a security bond.
@settlement is the settlement date of the security.  @maturity is the maturity date of the security.  The amount of investment is specified in @investment.  @rate is the security's discount rate.
@basis is the type of day counting system you want to use:
  0  US 30/360
  1  actual days/actual days
  2  actual days/360
  3  actual days/365
  4  European 30/360
* If @settlement date or @maturity date is not valid, RECEIVED returns #NUM! error.
* If @basis is omitted, US 30/360 is applied.
* If @basis < 0 or @basis > 4, RECEIVED returns #NUM! error.
* If @settlement date is after @maturity date or they are the same, RECEIVED returns #NUM! error.
@EXAMPLES=
@SEEALSO=INTRATE
@FUNCTION=SLN
@SYNTAX=SLN(cost,salvage_value,life)
@DESCRIPTION=SLN function will determine the straight line depreciation of an asset for a single period.
The formula is:
Depreciation expense = ( @cost - @salvage_value ) / @life
@cost is the cost of an asset when acquired (market value).
@salvage_value is the amount you get when asset is sold at the end of the asset's useful life.
@life is the anticipated life of an asset.
* If @life <= 0, SLN returns #NUM! error.
@EXAMPLES=
For example, lets suppose your company purchases a new machine for $10,000, which has a salvage value of $700 and will have a useful life of 10 years. The SLN yearly depreciation is computed as follows:
=SLN(10000, 700, 10)
This will return the yearly depreciation figure of $930.
@SEEALSO=SYD
@FUNCTION=SYD
@SYNTAX=SYD(cost,salvage_value,life,period)
@DESCRIPTION=SYD function calculates the sum-of-years digits depreciation for an asset based on its cost, salvage value, anticipated life and a particular period. This method accelerates the rate of the depreciation, so that more depreciation expense occurs in earlier periods than in later ones. The depreciable cost is the actual cost minus the salvage value. The useful life is the number of periods (typically years) over which the asset is depreciated.
The Formula used for sum-of-years digits depreciation is:
Depreciation expense =
	 ( @cost - @salvage_value ) * (@life - @period + 1) * 2 / @life * (@life + 1).
@cost is the cost of an asset when acquired (market value).
@salvage_value is the amount you get when asset sold at the end of its useful life.
@life is the anticipated life of an asset.
@period is the period for which we need the expense.
* If @life <= 0, SYD returns #NUM! error.
@EXAMPLES=
For example say a company purchases a new computer for $5000 which has a salvage value of $200, and a useful life of five years. We would use the following to calculate the second year's depreciation using the SYD method:
=SYD(5000, 200, 5, 2) which returns 1,280.00.
@SEEALSO=SLN
@FUNCTION=TBILLEQ
@SYNTAX=TBILLEQ(settlement,maturity,discount)
@DESCRIPTION=TBILLEQ function returns the bond-yield equivalent (BEY) for a treasury bill.  TBILLEQ is equivalent to
	(365 * @discount) / (360 - @discount * DSM),
where DSM is the days between @settlement and @maturity.
* If @settlement is after @maturity or the @maturity is set to over one year later than the @settlement, TBILLEQ returns #NUM! error.
* If @discount is negative, TBILLEQ returns #NUM! error.
@EXAMPLES=
@SEEALSO=TBILLPRICE,TBILLYIELD
@FUNCTION=TBILLPRICE
@SYNTAX=TBILLPRICE(settlement,maturity,discount)
@DESCRIPTION=TBILLPRICE function returns the price per $100 value for a treasury bill where @settlement is the settlement date and @maturity is the maturity date of the bill.  @discount is the treasury bill's discount rate.
* If @settlement is after @maturity or the @maturity is set to over one year later than the @settlement, TBILLPRICE returns #NUM! error.
* If @discount is negative, TBILLPRICE returns #NUM! error.
@EXAMPLES=
@SEEALSO=TBILLEQ,TBILLYIELD
@FUNCTION=TBILLYIELD
@SYNTAX=TBILLYIELD(settlement,maturity,pr)
@DESCRIPTION=TBILLYIELD function returns the yield for a treasury bill. @settlement is the settlement date and @maturity is the maturity date of the bill.  @discount is the treasury bill's discount rate.
* If @settlement is after @maturity or the @maturity is set to over one year later than the @settlement, TBILLYIELD returns #NUM! error.
* If @pr is negative, TBILLYIELD returns #NUM! error.
@EXAMPLES=
@SEEALSO=TBILLEQ,TBILLPRICE
@FUNCTION=VDB
@SYNTAX=VDB(cost,salvage,life,start_period,end_period[,factor,switch])
@DESCRIPTION=VDB calculates the depreciation of an asset for a given period or partial period using the double-declining balance method.
* If @start_period < 0, VDB returns #NUM! error.
* If @start_period > @end_period, VDB returns #NUM! error.
* If @end_period > @life, VDB returns #NUM! error.
* If @cost < 0, VDB returns #NUM! error.
* If @salvage > @cost, VDB returns #NUM! error.
* If @factor <= 0, VDB returns #NUM! error.
@EXAMPLES=
@SEEALSO=DB
@FUNCTION=XIRR
@SYNTAX=XIRR(values,dates[,guess])
@DESCRIPTION=XIRR calculates and returns the internal rate of return of an investment that has not necessarily periodic payments.  This function is closely related to the net present value function (NPV and XNPV).  The XIRR is the interest rate for a series of cash flows where the XNPV is zero.
@values contains the series of cash flows generated by the investment.  @dates contains the dates of the payments.  The first date describes the payment day of the initial payment and thus all the other dates should be after this date. The optional @guess is the initial value used in calculating the XIRR.  You do not have to use that, it is only provided for the Excel compatibility.
* This function is Excel compatible.
@EXAMPLES=
Let us assume that the cells A1:A5 contain the numbers -6000, 2134, 1422, 1933, and 1422, and the cells B1:B5 contain the dates "1999-01-15", "1999-04-04", "1999-05-09", "2000-03-12", and "2000-05-1". Then
XIRR(A1:A5,B1:B5) returns 0.224838. 
@SEEALSO=IRR,XNPV
@FUNCTION=XNPV
@SYNTAX=XNPV(rate,values,dates)
@DESCRIPTION=XNPV calculates the net present value of an investment.  The schedule of the cash flows is given in @dates array.  The first date indicates the beginning of the payment schedule.  @rate is the interest rate and @values are the payments.
* If @values and @dates contain unequal number of values, XNPV returns the #NUM! error.
@EXAMPLES=
@SEEALSO=NPV,PV
@FUNCTION=YIELD
@SYNTAX=YIELD(settlement,maturity,rate,price,redemption_price,frequency[,basis])
@DESCRIPTION=YIELD returns the yield on a security that pays periodic interest.
@frequency is the number of coupon payments per year. Allowed frequencies are: 1 = annual, 2 = semi, 4 = quarterly. @basis is the type of day counting system you want to use:
  0  US 30/360
  1  actual days/actual days
  2  actual days/360
  3  actual days/365
  4  European 30/360
* If @frequency is other than 1, 2, or 4, YIELD returns #NUM! error.
* If @basis is omitted, US 30/360 is applied.
* If @basis is not in between 0 and 4, #NUM! error is returned.
@EXAMPLES=
@SEEALSO=
@FUNCTION=YIELDDISC
@SYNTAX=YIELDDISC(settlement,maturity,pr,redemption[,basis])
@DESCRIPTION=YIELDDISC calculates the annual yield of a security that is discounted.
@settlement is the settlement date of the security.  @maturity is the maturity date of the security. @pr is the price per $100 face value of the security. @redemption is the redemption value per $100 face value. @basis is the type of day counting system you want to use:
  0  US 30/360
  1  actual days/actual days
  2  actual days/360
  3  actual days/365
  4  European 30/360
* If @frequency is other than 1, 2, or 4, YIELDDISC returns #NUM! error.
* If @basis is omitted, US 30/360 is applied.
* If @basis is not in between 0 and 4, #NUM! error is returned.
@EXAMPLES=
@SEEALSO=
@FUNCTION=YIELDMAT
@SYNTAX=YIELDMAT(settlement,maturity,issue,rate,pr[,basis])
@DESCRIPTION=YIELDMAT calculates the annual yield of a security for which the interest is paid at maturity date.
@settlement is the settlement date of the security. @maturity is the maturity date of the security. @issue is the issue date of the security. @rate is the interest rate set to the security. @pr is the price per $100 face value of the security. @basis is the type of day counting system you want to use:
  0  US 30/360
  1  actual days/actual days
  2  actual days/360
  3  actual days/365
  4  European 30/360
* If @basis is omitted, US 30/360 is applied.
* If @basis is not in between 0 and 4, #NUM! error is returned.
@EXAMPLES=
@SEEALSO=
+D@%
d@cb
plugin.so.debug
.shstrtab
.note.gnu.build-id
.gnu.hash
.dynsym
.dynstr
.gnu.version
.gnu.version_r
.rela.dyn
.rela.plt
.init
.text
.fini
.rodata
.eh_frame_hdr
.eh_frame
.ctors
.dtors
.jcr
.data.rel.ro
.dynamic
.got
.got.plt
.bss
.gnu_debuglink
