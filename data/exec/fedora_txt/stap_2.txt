/lib64/ld-linux-x86-64.so.2
r@  
Q/qq(
b$A<{
nZq(
`z	%
sd	17
libdw.so.1
__gmon_start__
_Jv_RegisterClasses
dwfl_module_addrdie
dwfl_module_build_id
dwarf_frame_cfa
dwarf_linesrc
dwarf_highpc
dwarf_getsrclines
dwfl_standard_find_debuginfo
dwarf_haschildren
dwarf_onesrcline
dwfl_offline_section_address
dwarf_errmsg
dwfl_module_eh_cfi
dwfl_errmsg
dwarf_getlocation_implicit_value
dwfl_module_relocations
dwarf_haspc
dwarf_child
dwarf_decl_file
dwfl_begin
dwfl_module_relocation_info
dwfl_module_getsym
dwfl_module_dwarf_cfi
dwarf_lineaddr
dwarf_getsrc_die
dwarf_ranges
dwfl_end
dwarf_lowpc
dwarf_getsrc_file
dwfl_module_address_section
dwarf_diename
dwarf_hasattr_integrate
dwfl_report_end
dwarf_offdie
dwfl_module_getdwarf
dwarf_getsrcfiles
dwfl_version
dwarf_filesrc
dwarf_hasattr
dwfl_report_begin
dwarf_getfuncs
dwfl_module_relocate_address
dwarf_cfi_addrframe
dwfl_module_info
dwarf_formref_die
dwfl_module_getelf
dwarf_tag
dwarf_getelf
dwarf_dieoffset
dwfl_getmodules
dwarf_nextcu
dwfl_module_return_value_location
dwarf_decl_line
dwarf_attr_integrate
dwfl_report_offline
dwfl_errno
dwarf_func_inline
dwfl_addrmodule
dwarf_lineno
dwarf_formudata
dwfl_linux_kernel_find_elf
dwfl_module_getsymtab
dwarf_getscopes
dwfl_linux_kernel_report_offline
dwarf_getscopevar
dwarf_diecu
dwarf_getlocation_addr
dwarf_entrypc
dwarf_siblingof
libelf.so.1
elf_rawdata
gelf_getshdr
elf_nextscn
gelf_getehdr
elf_getshdrstrndx
elf_strptr
elf_getdata_rawchunk
libsqlite3.so.0
sqlite3_free_table
sqlite3_open
sqlite3_exec
sqlite3_errmsg
sqlite3_close
sqlite3_get_table
librpm.so.0
rpmtsInitIterator
rpmdbFreeIterator
headerFormat
rpmtsFree
rpmtsCreate
rpmdbNextIterator
rpmReadConfigFiles
libdl.so.2
libstdc++.so.6
pthread_cancel
_ZTTSt18basic_stringstreamIcSt11char_traitsIcESaIcEE
_ZNKSt15basic_stringbufIcSt11char_traitsIcESaIcEE3strEv
_ZNSt18basic_stringstreamIcSt11char_traitsIcESaIcEED1Ev
_ZNSs4_Rep9_S_createEmmRKSaIcE
_ZTVN10__cxxabiv117__class_type_infoE
_ZSt9terminatev
_ZNKSs7compareEmmPKc
__cxa_guard_release
_ZSt4cerr
__cxa_call_unexpected
_ZSt29_Rb_tree_insert_and_rebalancebPSt18_Rb_tree_node_baseS0_RS_
_ZTVSt13runtime_error
_ZNSt8ios_base4InitD1Ev
_ZNSolsEPFRSoS_E
_ZNSo9_M_insertImEERSoT_
_ZSt18_Rb_tree_incrementPSt18_Rb_tree_node_base
_ZSt18_Rb_tree_decrementPKSt18_Rb_tree_node_base
_ZNSo5tellpEv
_ZNSt13basic_filebufIcSt11char_traitsIcEE5closeEv
_ZTVSt14basic_ifstreamIcSt11char_traitsIcEE
_ZTVSt15basic_streambufIcSt11char_traitsIcEE
_ZNSi10_M_extractIlEERSiRT_
_ZNSt15basic_streambufIcSt11char_traitsIcEED2Ev
__gxx_personality_v0
_ZNSt13basic_filebufIcSt11char_traitsIcEE4openEPKcSt13_Ios_Openmode
_ZNSi10_M_extractImEERSiRT_
_ZNSt19basic_istringstreamIcSt11char_traitsIcESaIcEED1Ev
_ZNSt14basic_ofstreamIcSt11char_traitsIcEED1Ev
_ZNSs6insertEmPKcm
_ZNSo3putEc
_ZTVSt13basic_filebufIcSt11char_traitsIcEE
_ZNSt9basic_iosIcSt11char_traitsIcEE4initEPSt15basic_streambufIcS1_E
_ZNSs9_M_mutateEmmm
_ZTVN10__cxxabiv120__si_class_type_infoE
_Znwm
_ZNKSt5ctypeIcE13_M_widen_initEv
_ZStplIcSt11char_traitsIcESaIcEESbIT_T0_T1_ERKS6_S8_
_ZNSs7_M_leakEv
_ZTVSt19basic_ostringstreamIcSt11char_traitsIcESaIcEE
_ZSt3cin
__cxa_rethrow
_ZNSt12__basic_fileIcED1Ev
_ZNSs4_Rep10_M_destroyERKSaIcE
_ZNSo9_M_insertIlEERSoT_
_ZNSt9basic_iosIcSt11char_traitsIcEE5clearESt12_Ios_Iostate
_ZTVN10__cxxabiv121__vmi_class_type_infoE
_ZNSs6appendEPKc
_ZNSt13runtime_errorC2ERKSs
_ZNKSs7compareEPKc
__cxa_throw
_ZNSs6assignERKSs
_ZNSs6assignEPKc
_ZNSt6localeC1Ev
_ZSt18_Rb_tree_decrementPSt18_Rb_tree_node_base
_ZNKSs5rfindEPKcmm
__cxa_pure_virtual
_ZSt4clog
_ZNSt3tr18__detail12__prime_listE
_ZNSo9_M_insertIbEERSoT_
_ZdlPv
_ZNSs4_Rep20_S_empty_rep_storageE
_ZNKSs5rfindEcm
_ZNKSs13find_first_ofEPKcmm
_ZNSolsEPFRSt8ios_baseS0_E
_ZTVSt18basic_stringstreamIcSt11char_traitsIcESaIcEE
__cxa_begin_catch
_ZTVSt14basic_ofstreamIcSt11char_traitsIcEE
_ZSt18_Rb_tree_incrementPKSt18_Rb_tree_node_base
_ZNKSt12__basic_fileIcE7is_openEv
_ZSt20__throw_length_errorPKc
_ZSt20__throw_out_of_rangePKc
_ZNSs6assignEPKcm
_ZNSt8ios_baseC2Ev
_ZNSsC1EPKcmRKSaIcE
_ZNSs6resizeEm
_ZSt19__throw_logic_errorPKc
_ZNSt15basic_stringbufIcSt11char_traitsIcESaIcEE7_M_syncEPcmm
_ZTVSt9basic_iosIcSt11char_traitsIcEE
_ZNSs9push_backEc
_ZNSs5clearEv
_ZNSirsERi
_ZNSo9_M_insertIyEERSoT_
_ZNSt13runtime_errorD1Ev
_Znam
__cxa_guard_acquire
__cxa_allocate_exception
_ZNSt19basic_ostringstreamIcSt11char_traitsIcESaIcEED1Ev
_ZNSs7reserveEm
_ZNSs6resizeEmc
_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l
_ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_
_ZNSt6localeD1Ev
_ZTVSt15basic_stringbufIcSt11char_traitsIcESaIcEE
_ZTTSt19basic_istringstreamIcSt11char_traitsIcESaIcEE
_ZNSt13runtime_errorD2Ev
__dynamic_cast
_ZNSt9basic_iosIcSt11char_traitsIcEED2Ev
__cxa_end_catch
_ZTTSt14basic_ifstreamIcSt11char_traitsIcEE
_ZNKSs17find_first_not_ofEPKcmm
_ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc
_ZNSolsEPSt15basic_streambufIcSt11char_traitsIcEE
_ZNKSs7compareERKSs
_ZStlsIcSt11char_traitsIcESaIcEERSt13basic_ostreamIT_T0_ES7_RKSbIS4_S5_T1_E
_ZNKSt13runtime_error4whatEv
_ZStrsIcSt11char_traitsIcESaIcEERSt13basic_istreamIT_T0_ES7_RSbIS4_S5_T1_E
_ZNKSs6substrEmm
_ZNSt13basic_filebufIcSt11char_traitsIcEEC1Ev
_ZSt28_Rb_tree_rebalance_for_erasePSt18_Rb_tree_node_baseRS_
_ZNSt8ios_baseD2Ev
__cxa_free_exception
_ZdaPv
_ZNSsaSEc
_ZNSs6appendEmc
_ZNSs12_M_leak_hardEv
_ZNKSt3tr14hashISsEclESs
_ZNSsD1Ev
_ZNSi3getERc
_ZNSsC1ERKSsmm
_ZNSsC1EPKcRKSaIcE
_ZNSo5seekpESt4fposI11__mbstate_tE
_ZNSs7replaceEmmPKcm
_ZSt4cout
_ZStplIcSt11char_traitsIcESaIcEESbIT_T0_T1_EPKS3_RKS6_
_ZTVSt19basic_istringstreamIcSt11char_traitsIcESaIcEE
_ZSt7getlineIcSt11char_traitsIcESaIcEERSt13basic_istreamIT_T0_ES7_RSbIS4_S5_T1_ES4_
_ZNSs6appendERKSs
_ZNSo5flushEv
_ZSt16__throw_bad_castv
_ZNKSs4findEPKcmm
_ZNSsC1ERKSs
_ZSt17__throw_bad_allocv
_ZNSt8ios_base4InitC1Ev
_ZNSt13basic_filebufIcSt11char_traitsIcEED1Ev
_ZNKSs4findEcm
_ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_c
_ZNSt14basic_ifstreamIcSt11char_traitsIcEED1Ev
_ZNSt13runtime_errorC1ERKSs
_ZNSolsEi
_ZNSt15basic_stringbufIcSt11char_traitsIcESaIcEED1Ev
_ZTISt13runtime_error
_ZNSs6appendEPKcm
_ZNSt9exceptionD2Ev
_ZTTSt14basic_ofstreamIcSt11char_traitsIcEE
_ZNSo9_M_insertIPKvEERSoT_
_ZTTSt19basic_ostringstreamIcSt11char_traitsIcESaIcEE
libm.so.6
ceilf
libgcc_s.so.1
_Unwind_Resume
libc.so.6
mkdtemp
fchmod
fnmatch
fopen
optind
strrchr
isalpha
regexec
getpwuid
__stack_chk_fail
unlink
mkdir
abort
_exit
strpbrk
memrchr
popen
getpid
kill
__assert_fail
mkstemp
isspace
strtol
isprint
fgets
strlen
__cxa_atexit
sigemptyset
isalnum
glob
__errno_location
read
memcmp
unsetenv
__fprintf_chk
sigaddset
memcpy
fclose
strtoul
malloc
umask
remove
getenv
regcomp
optarg
_obstack_newchunk
__snprintf_chk
getuid
fscanf
getopt_long
open_memstream
__fxstat
strtoull
__obstack_printf_chk
pclose
posix_spawn
getcwd
gettimeofday
sigaction
rename
geteuid
__memcpy_chk
waitpid
strverscmp
canonicalize_file_name
times
__cxa_finalize
__vasprintf_chk
__xstat
uname
memmove
_obstack_begin
access
strcmp
strerror
__asprintf_chk
__libc_start_main
write
globfree
sysconf
ispunct
__environ
libpthread.so.0
_edata
__bss_start
_ZTV14update_visitor
_ZTV24tracepoint_derived_probe
_ZTV11generic_dpgI19timer_derived_probeE
_ZTV6aggvar
_ZTV11generic_dpgI20utrace_derived_probeE
_ZTV10symboldecl
_ZTV5probe
_ZTV29perfmon_var_expanding_visitor
_ZTV21perfmon_derived_probe
_ZTV18ternary_expression
_ZTV28utrace_var_expanding_visitor
_ZTV32tracepoint_var_expanding_visitor
_ZTV11probe_alias
_ZTV26procfs_derived_probe_group
_ZTV6symbol
_ZTV21mutated_var_collector
_ZTV14uprobe_builder
_ZTV11generic_dpgI20itrace_derived_probeE
_ZTV12if_statement
_ZTV26utrace_derived_probe_group
_ZTV7visitor
_ZTV31task_finder_derived_probe_group
_ZTV36delete_statement_typeresolution_info
_ZTV12print_format
_ZTV27profile_derived_probe_group
_ZTV16delete_statement
_ZTV16unary_expression
_ZTV17deep_copy_visitor
_ZTV11generic_dpgI18mark_derived_probeE
_ZTV7hist_op
_ZTV16logical_and_expr
_ZTI9statement
_ZTV10expression
_ZTV7cast_op
_ZTV12post_crement
_ZNSt3setISsSt4lessISsESaISsEED1Ev
_ZTV19dwarf_derived_probe
_ZTV32delete_statement_operand_visitor
_ZTV20kprobe_derived_probe
_ZTV18traversing_visitor
_ZTI14literal_string
_ZTV12embeddedcode
_ZTV18symresolution_info
_ZTV11generic_dpgI21hrtimer_derived_probeE
_ZTV10base_query
_ZTV27dwarf_var_expanding_visitor
_ZTV14utrace_builder
_ZTV8for_loop
_ZTV11pre_crement
_ZTV20procfs_derived_probe
_ZTV27hrtimer_derived_probe_group
_ZTV21hrtimer_derived_probe
_ZTV13concatenation
_ZTV18mark_derived_probe
_ZTV21c_unparser_assignment
_ZTV14semantic_error
_ZTV23alias_expansion_builder
_ZTV19typeresolution_info
_ZTV12functioncall
_ZTV11generic_dpgI16be_derived_probeE
_ZTV25dwarf_derived_probe_group
pending_interrupts
_ZTV18continue_statement
_ZTV11generic_dpgI20procfs_derived_probeE
_ZTV21var_expanding_visitor
_ZTV26uprobe_derived_probe_group
_ZTV16return_statement
_ZTV6mapvar
_ZTV14kprobe_builder
_ZTV16tracepoint_query
_ZTV16throwing_visitor
_ZTV12foreach_loop
_ZTV14literal_string
_ZTV12functiondecl
_ZTV21arrayindex_downcaster
_ZTV13never_builder
_ZTV8unparser
_ZTV13timer_builder
_ZTV22void_statement_reducer
_ZTV38no_var_mutation_during_iteration_check
_ZTV31functioncall_traversing_visitor
_ZTV10c_unparser
_ZTV24mark_derived_probe_group
_ZSt3decRSt8ios_base
_ZTV35delete_statement_symresolution_info
_ZTV26kprobe_derived_probe_group
_ZTV3var
_ZTI11parse_error
_ZTV14next_statement
_ZTV16be_derived_probe
_ZTV13derived_probe
_ZTV22be_derived_probe_group
_ZTV21derived_probe_builder
_ZTV10assignment
_ZTV14itrace_builder
_ZTV21dead_stmtexpr_remover
_ZTV9statement
_ZTV25timer_derived_probe_group
_ZTV10be_builder
_ZTV14null_statement
_ZTV14symbol_fetcher
_ZTV8array_in
_ZTV25sdt_var_expanding_visitor
_ZTV7vardecl
_ZTV19never_derived_probe
_ZTV14literal_number
_ZTV11generic_dpgI20uprobe_derived_probeE
_ZTV11generic_dpgI21profile_derived_probeE
_ZN11parse_errorD1Ev
_ZTV14expr_statement
_ZTV17binary_expression
_ZTV11parse_error
_ZTI14semantic_error
_ZTV14procfs_builder
_ZTV14recursion_info
_ZTV11generic_dpgI25task_finder_derived_probeE
__libc_csu_init
_ZTI14literal_number
_ZTV13dwarf_builder
_ZTV30tracepoint_derived_probe_group
_ZTV11dwarf_query
_ZTV19stat_decl_collector
_ZTV12mark_builder
_ZTV26duplicate_function_remover
_ZTV9sdt_query
_ZTV6tmpvar
_ZTV25varuse_collecting_visitor
_ZTV23dead_assignment_remover
_ZTV28procfs_var_expanding_visitor
_ZTV26itrace_derived_probe_group
_ZTV20itrace_derived_probe
_ZTV10comparison
_ZTV15logical_or_expr
_ZTV15break_statement
_ZTV26mark_var_expanding_visitor
_ZN14semantic_errorD1Ev
_ZTV10arrayindex
_ZTV19timer_derived_probe
_ZTV23c_tmpcounter_assignment
_ZTV20utrace_derived_probe
_ZTV15perfmon_builder
_ZTV13target_symbol
_ZN21var_expanding_visitor4tickE
_ZTV7stat_op
_ZTV19derived_probe_group
__libc_csu_fini
_ZTV12c_tmpcounter
_ZTV5block
_ZTV20uprobe_derived_probe
_ZTV16dwarf_cast_query
_ZTI5block
_ZTV11generic_dpgI24tracepoint_derived_probeE
_ZTV36delete_statement_operand_tmp_visitor
_ZTV9indexable
_ZSt3hexRSt8ios_base
_ZTV18tracepoint_builder
_ZTV19alias_derived_probe
_ZTV28dwarf_cast_expanding_visitor
_ZTI10expression
_ZSt8showbaseRSt8ios_base
_ZTI7literal
_ZTV21profile_derived_probe
GCC_3.0
GLIBC_2.2.5
ELFUTILS_1.3
ELFUTILS_1.5
ELFUTILS_1.0
GLIBC_2.8
GLIBC_2.4
GLIBC_2.3.4
ELFUTILS_0.126
ELFUTILS_0.138
ELFUTILS_0.142
ELFUTILS_0.127
ELFUTILS_0.143
ELFUTILS_0.122
GLIBCXX_3.4.10
GLIBCXX_3.4.11
GLIBCXX_3.4.9
CXXABI_1.3
GLIBCXX_3.4
%zB4
%rB4
%jB4
%bB4
%ZB4
%RB4
%JB4
%BB4
%:B4
%2B4
%*B4
%"B4
%zA4
%rA4
%jA4
%bA4
%ZA4
%RA4
%JA4
%BA4
%:A4
%2A4
%*A4
%"A4
%z@4
%r@4
%j@4
%b@4
%Z@4
%R@4
%J@4
%B@4
%:@4
%2@4
%*@4
%"@4
%z?4
%r?4
%j?4
%b?4
%Z?4
%R?4
%J?4
%B?4
%:?4
%2?4
%*?4
%"?4
%z>4
%r>4
%j>4
%b>4
%Z>4
%R>4
%J>4
%B>4
%:>4
%2>4
%*>4
%">4
%z=4
%r=4
%j=4
%b=4
%Z=4
%R=4
%J=4
%B=4
%:=4
%2=4
%*=4
%"=4
%z<4
%r<4
%j<4
%b<4
%Z<4
%R<4
%J<4
%B<4
%:<4
%2<4
%*<4
%"<4
%z;4
%r;4
%j;4
%b;4
%Z;4
%R;4
%J;4
%B;4
%:;4
%2;4
%*;4
%";4
%z:4
%r:4
%j:4
%b:4
%Z:4
%R:4
%J:4
%B:4
%::4
%2:4
%*:4
%":4
ATSubH
ffff.
<$dH
D$(1
D$(dH3
fff.
=474
AWAVAUATI
\$0H
T$NH
l$`H
l$ H
|$pH
[]A\A]A^A_
D$@H
\$PH
D$PH
D$PL
|$`H
t$OL
t$@H
l$O@
D$`H
D$`H
D$PL
\$PH
AWAVAUATUH
L$0H
\$PH
D$8H
\$`H
D$HH
\$hH
\$ H
\$8H
D$xH
L$h1
D$@H
\$XH
\$HH
\$pH
L$8L
T$XH
L$PH
D$HH
L$pI
T$`H
T$xL
=5/4
|$PH
L$hH
|$ I
@xH)
|$@H
T$0L
L$0H
|$`H
|$PH
T$xH
L$hH
\$HH
|$ H
T$pI
L$`H
\$8H
T$XI
L$PH
[]A\A]A^A_
C8H+C0H
tFE1
C8H+C0A
L$@H
|$0L
|$@H
|$@I
T$(H
\$(H
D$(H
T$(L
L$(D
E@I+E8H
E@H)
L$(H
l$0I
5U04
\$(H
=W/4
E8I+E0H
E8H)
L$xH
T$hH
L$HI
T$pH
T$`H
L$8H
T$XH
L$PH
T$xH
L$hH
D$HH
AVAUATUSH
D$81
tIE1
D$ H
\$0H
|$ H
\$(H)
\$(H
|$ A
|$ H
|$ H
|$ H
|$ H
AWAVAUATUSH
|$HH
t$PL
T$ H
t$(H
t$(H
L$`H
|$`H
|$`H
|$ H
t$`H
|$ L
T$ 1
|$ H
L$XH
|$8H
D$hH
L$pH
|$HH
T$pH
|$@H
T$@H
T$ H
|$`H
|$`H
|$`H
|$ H
t$`H
|$ H
|$ H
|$ H
|$`H
|$`H
|$`H
|$ H
|$ H
9\$H
L$PHc
|$ H
9\$H
|$ H
L$ H9
|$ H
|$ H
T$0H
|$0H
|$hI
T$hH
T$hH
|$hI
T$hH
T$hH
|$h1
|$hH
|$8H
H;D$(
D$(H
T$HH
|$@H
L$8H)
t$XH
|$(H
t$(H
|$0H
L$@H
T$HH
|$hH)
T$hH
T$8H
T$hH
|$hH
D$8H
L$8H+
|$x1
|$H1
|$x1
|$H1
|$x1
|$H1
L$8H+
t$(H
|$(H
t$PL
|$(H
|$(H
|$(H
|$PH
|$(H
|$x1
|$H1
L$8H+
[]A\A]A^A_
|$0L
|$0H
|$0H
|$0H
L$8H+
L$8H+
|$0H
|$ H
t$ L
T$(H
L$(H
T$(H
|$hH
|$0H
|$ H
t$(H
T$hH
	v71
\$ H
T$XH
|$8H
t$8I
|$8H
\$ H
|$ H
\$ H
\$ H
6vQI
|$0H
\$ A
\$ H
t$`H
|$ H
|$ H
t$`H
|$ H
t$`H
t$`H
t$`H
|$ H
ATUSH
[]A\A]A^
d$ L
l$(L
t$0H
|$ H
u H)
ATUH
[]A\
[]A\
[]A\
[]A\
[]A\
[]A\
l$ H
l$ L
d$(L
l$0H
l$ H
AWAVAUI
ATUH
([]A\A]A^A_
<?L9
t%I9
l$ L
d$(L
l$0H
ATUH
]HI9
]0I9
[]A\
[]A\
\$(H
l$0L
d$8L
l$@L
t$HL
|$PH
D$hH
D$@H
D$hH
D$@H
D$hH
fffff.
ffff.
fff.
u8tCH
l$ H
l$ H
fff.
d$ H
l$ L
d$(L
l$0H
D$(1
uHL)
L$(dH3
AVAUATI
[]A\A]A^
t!H;-
t!H;-
t!H;-
t!H;-
t!H;-
t!H;-
t!H;-
d$pH
L$pM
H;-t
L$pM
d$`H
L$`M
H;-d
L$`M
d$PH
L$PM
H;-T
L$PM
d$@H
L$@M
H;-D
L$@M
d$0H
L$0M
H;-4
L$0M
l$ H
uQL)
AVAUATI
[]A\A]A^
t!H;-
t!H;-
t!H;-
t!H;-
t!H;-
d$pH
L$pM
L$pM
d$`H
L$`M
L$`M
d$PH
L$PM
L$PM
d$@H
L$@M
H;-t
L$@M
d$0H
L$0M
H;-d
L$0M
d$ H
L$ M
H;-T
L$ M
H;-D
H;-?
d$ L
l$(L
t$0H
d$ L
l$(L
t$0H
D$(1
T$(dH3
\$8H
l$@L
d$HL
l$PL
t$XL
|$`H
D$(1
T$(dH3
\$8H
l$@L
d$HL
l$PL
t$XL
|$`H
AWAVAUATUH
H;="s3
([]A\A]A^A_
fffff.
\$(H
l$0L
d$8L
l$@L
t$HL
|$PH
=[n3
fff.
=um3
=Jm3
=(m3
=5l3
d$ H
|$ H
\$@H
5bm3
\$0H
\$pH
l$`H
|$`H
5ak3
l$`I
5qj3
\$pH
t$`H
\$pL
l$`H
T$PH
|$XL
t$pH
t$`H
fffff.
AVAUL
ATUSH
D$`H
T$hM
L$pH
D$xH
L$HH
D$hH
L$PH
D$XH
L$@H
T$PA
T$HA
X8H)
D$@I
T$@H
5Y`3
|$@H
T$hI
|$@I
\$XH
|$@H
D$hH
5#`3
|$xH
L$XH
T$hH
|$@H
|$@L
|$@L
|$@L
|$@H
|$@H
|$@H
|$`H
[]A\A]A^A_
L$(H
t$0D
L$(H
t$0D
L$8u
l$`D
|$@L
t$xL
L$pH
T$HH
T$p1
T$pH
T$pH
|$pH
t$pH
T$hH
|$pH
p8H+p0H
T$hH
T$hH
L$XH
|$HL
|$HL
|$HL
|$HH
|$HH
|$HH
H9={M3
BhH9
|$pH
L$pH
L$pH
L$pH
|$HL
T$ H
t$0L
T$ H
t$0L
L$(I
-t8E
D$hH
=oH3
D$hH
T$@L
T$`H
t$pH
D$`H
|$HH
|$pH
T$pH
L$HH
T$pH
|$pH
T$HH
L$pH
=y@3
=M@3
d$`D
t$pH
=V>3
|$@H
L$@L
|$PH
D$`L
}tjA
=E;3
=~:3
`AVAUATUSH
T$HH
|$(@
t$GH
D$PH
T$XH
D$`H
T$hH
D$pH
T$(H
T$GH
\$8H
[]A\A]A^A_
D$(L
D$ I
D"|$ 
T$8H
H;=<73
t$4H
t$4H
D$8H
D$(H
|$HH
t$4H
T$8H
T$(H
D$(H
t$4H
t$4H
H9=A23
T$8H
5t43
=,13
=|03
=P03
t$ H
t$pH
fffff.
\$ H
l$(L
d$0H
5f/3
fffff.
H;={+3
5X.3
\$ H
l$(L
d$0H
\$ H
l$(L
d$0H
=))3
D$(1
T$'H
H;=r(3
5K+3
T$&H
T$(dH3
\$0H
l$8L
d$@H
D$(1
T$&H
T$(dH3
\$8H
l$@L
d$HL
l$PH
T$'H
fffff.
ATUH
D$(1
T$'H
T$&H
=;"3
T$(dH3
0[]A\
D$(1
T$'H
"t(H
vTf.
T$&H
T$(dH3
\$0H
l$8L
d$@L
l$HL
t$PH
fff.
D$h1
|$ L
l$@H
l$0L
|$0H
|$@H
|$PH
|$ H
T$hdH3
\$xH
D$(1
t	9X
T$(dH3
\$8H
l$@L
d$HL
l$PH
D$(1
t	9X
T$(dH3
\$8H
l$@L
d$HL
l$PH
fff.
AWAVAUATI
D$XL
t$0H
D$PH
l$`H
|$`H
H;=d
D$XH
[]A\A]A^A_
|$X1
|$X1
l$XL
D$XH
T$PH
H=?B
D$XH
|$0H
H;=B
\$pH
\$@H
\$ H
AWAVAUATUH
l$`H
|$`H
D$ H
T$(H
s H;s(H
T$ H
D$(H
D$ H
T$8H
wpI;wxH
T$ H
[]A\A]A^A_
l$pH
|$pH
T$(H
D$(H
T$ H
E@I9EHL
T$0H
l$@H
|$(I
D$81
T$8dH3
\$@H
l$HL
d$PH
T$6H
\$ H
T$7H
T$5H
H;=|
d$ L
l$(L
t$0H
l$ L
d$(L
l$0H
D$ L
l$ L
d$(L
l$0H
AVAUATI
[]A\A]A^
AVAUATI
[]A\A]A^
AVAUATI
[]A\A]A^
fff.
AVAUATI
[]A\A]A^
AVAUATI
[]A\A]A^
AWAVAUATUH
D$H1
t$8H
H;t$
l$0H
T$GH
|$0H
H;=]
l$ H
T$FH
|$ H
H;=d
T$HdH3
X[]A\A]A^A_
fff.
AVAUATI
[]A\A]A^
fff.
AVAUATI
[]A\A]A^
fff.
AVAUATI
[]A\A]A^
fff.
AVAUATI
[]A\A]A^
fff.
AVAUATI
[]A\A]A^
fff.
\$(H
l$0L
d$8L
l$@H
d$ L
l$(L
t$0H
|$ M
D$ H
fffff.
AWAVAUI
ATUH
D$@H
D$hH
D$(H
D$0H
D$pH
D$`H
D$XH
D$PH
D$8H
D$HH
|$ L
eHL;eP
D$ H
T$(H
eHL;ePH
D$ H
T$0H
T$HH
|$@L
T$PH
|$@L
L;ePL
D$ H
T$`H
|$@L
[]A\A]A^A_
|$HH
|$`H
|$PH
\$(H
l$0L
d$8L
l$@H
D$(1
T$'H
H;=M
T$&H
T$(dH3
\$8H
l$@L
d$HL
l$PH
AVAUI
ATUSH
D$X1
\$@H
T$WH
D$8H
T$SH
H;=D
l$8L
\$0H
T$VH
l$ H
T$UH
|$ H
H;={
T$TH
T$XdH3
`[]A\A]A^
D$X1
d$@H
T$WH
|$@L
T$VH
D$SL
t$0E1
T$8H
|$0H
w(H;w0
D$8H
\$ H
T$UH
|$ H
T$XdH3
\$hH
l$pL
d$xL
fffff.
D$(1
T$(dH3
\$8H
l$@L
d$HL
l$PH
t$'H
T$hL
|$ M
H;s 
D$hH
l$PH
|$PH
H;=F
l$@H
\$0H
\$pH
|$ H
\$`H
\$ H
l$(L
d$0H
fffff.
D$81
l$ H
T$7H
|$ H
H;=!
H;u H
T$8dH3
\$HH
l$PL
d$XL
l$`L
t$hL
|$pH
AVAUATI
l$pH
|$pH
H;=`
l$`H
|$`H
l$PH
|$PH
D$H1
l$0H
\$@H
|$HH
w(H;w0H
l$HH
I;t$
D$HH
[]A\A]A^
\$ H
l$HH
T$HL
AVAUATUH
T$ H
D$@H
\$pH
t$(H;t$0
D$(H
D$(H
T$@H9T$H
t$@H
t$ H
EXI;w
|$ H
|$@H
[]A\A]A^A_
t$HH;t$Pt01
D$HH
D$H1
t$HH;t$P
D$HH
D$H1
t$(H;t$0t21
D$(H
D$(1
t$ H
T$`L
|$ H
|$@H
AWAVAUATI
D$x1
D$@H
T$vH
t$`A
D$(H
T$ H
D$0H
T$8H
T$wH
D$HH
D$uH
T$hH
D$XH
T$PL
|$`H
T$(H
t$ L
upH;uxH
t$8A
T$ H
t$0L
T$xdH3
[]A\A]A^A_
T$PH
D$81
l$ H
T$7H
|$ H
T$6H
T$5H
T$8dH3
D$(L
\$HH
l$PL
d$XL
l$`H
fffff.
D$X1
l$@H
T$WH
|$@H
l$0H
T$VH
|$0H
H;=+
l$ H
T$UH
T$TH
D$ H
T$SH
T$XdH3
D$(L
\$hH
l$pL
d$xL
D$81
l$ H
T$7H
|$ H
H;=]
T$6H
T$5H
T$8dH3
\$HH
l$PL
d$XL
l$`H
l$ H
l$ H
\$ H
l$(L
d$0L
l$8L
t$@H
D$(1
T$'H
T$(dH3
\$0H
l$8L
d$@H
H+3H
4$H)
\$(H
l$0L
d$8L
l$@H
H+3H
4$H)
\$(H
l$0L
d$8L
l$@H
\$(H
l$0L
d$8L
l$@L
t$HL
|$PH
\$(H
l$0L
d$8L
l$@L
t$HL
|$PH
\$(H
l$0L
d$8L
l$@L
t$HL
|$PH
\$(H
l$0L
d$8L
l$@L
t$HL
|$PH
\$(H
l$0L
d$8L
l$@L
t$HL
|$PH
\$(H
l$0L
d$8L
l$@L
t$HL
|$PH
\$(H
l$0L
d$8L
l$@L
t$HL
|$PH
\$(H
l$0L
d$8L
l$@L
t$HL
|$PH
\$(H
l$0L
d$8L
l$@L
t$HL
|$PH
\$(H
l$0L
d$8L
l$@L
t$HL
|$PH
,)L)
\$(H
l$0L
d$8L
l$@L
t$HL
|$PH
\$(H
l$0L
d$8L
l$@L
t$HL
|$PH
\$(H
l$0L
d$8L
l$@L
t$HL
|$PH
AWAVAUI
ATUSH
[]A\A]A^A_
AWAVI
AUATUSH
D$(1
fffffff
D$'A
T$(dH3
8[]A\A]A^A_
H;T$
(H9T$
=hm2
=3m2
H;l$
l$ H
AWAVI
ATUH
D$h1
d$0H
D$HH
D$PH
D$0I
D$8A
|$@H
D$HH
D$PI
L$hdH3
x[]A\A]A^A_
fffffff
|$(I
tNf.
D$ H
D$(H
D$(H
d$(I9
T$ M
Hk|$ (
=	g2
\$(H9
t+H9\$(t2H
fffffff
H9L$ 
H;=+e2
\$(H
l$0L
d$8L
l$@H
=Vb2
u^H)
AWAVI
AUATUSH
\$ dH
l$ H
D$ H
D$ I
D$@H
t$xH
5@e2
|$xI
D$ I
D$@H
H;=b_2
l$ H
[]A\A]A^A_
=V^2
l$ H
fff.
fff.
fff.
fff.
fffff.
fffff.
fffff.
fffff.
fffff.
fffff.
fffff.
fffff.
fffff.
fffff.
fffff.
fffff.
fffff.
O@dH
L$@I
[]A\A]
fffff.
fffff.
fffff.
fffff.
fffff.
fffff.
fffff.
fffff.
I90u	
[]A\
fff.
fff.
l$ H
fff.
~ dH
~ dH
~ dH
l$ H
fff.
l$ H
fff.
l$ H
fff.
l$ H
fff.
fffff.
l$ H
fff.
l$ H
V dH
F(H)
[]A\
fff.
VhdH
FpH)
[]A\
[]A\
~ dH
l$ H
fffff.
l$ H
fffff.
l$ H
fff.
l$ H
fff.
l$ H
fff.
fffff.
l$ H
fffff.
d$ H
ta~o
fff.
d$ L
l$(L
t$0H
l$ H
fffff.
l$ H
fffff.
AVAUATUH
H9H s
G H9E8sbH
c tvH
H;V r
uDH9P rRL
[]A\A]A^
L;k8t
d$ H
fffff.
\$(H
l$0H
\$(H
l$0H
;stcH
<fto<dt[<lt?
fff.
ATUH
C(H+C H
C(H)
t?E1
C(H)
[]A\A]
C(H+C H
fffff.
[]A\A]
fffff.
t$ H
5e!2
\$(H
[]A\A]
\$(H
[]A\A]
fffff.
AWAVAUATI
GxH+GpH
CxH+CpH
[]A\A]A^A_
fff.
ATUH
[]A\A]
[]A\A]
l$ H
{@uaH
d$ H
C0H+C(H
d$ H
fffff.
AUATUH
CHH)
[]A\A]
fffff.
AWAVAUATUH
C0H+C(H
[]A\A]A^A_
C0L)
[]A\A]A^A_
AWAVAUATUH
C(H)
[]A\A]A^A_
](dH
d$ H
AWAVAUATUH
C(H)
[]A\A]A^A_
X dH
\$ H
l$(L
d$0H
AWAVI
AUATUSH
k4D9
{@uBH
[]A\A]A^A_
AWAVAUI
ATUH
E H)
[]A\A]A^A_
R H)
B H+B
[]A\A]
D$(1
D$(dH3
\$0H
l$8L
d$@H
T$'H
T$&H
fff.
F H)
|$0H
 []A\
fff.
tUH9
t|H;
\$(H
l$0L
d$8L
l$@H
t7H;
ATUH
 []A\
AUATUH
t$ H
D$(1
|$ H
D$(dH3
8[]A\A]
\$ H
l$(L
d$0H
fffff.
l$ H
E(H+E H
c0H)
k(u(H
d$ L
l$(L
t$0H
l$ H
t$ H
d$ H
d$ H
fff.
d$ H
fff.
d$ H
fff.
d$ H
fff.
l$ H
d$ H
l$ H
d$ H
l$ H
fffff.
l$ H
fffff.
l$ H
fffff.
l$ H
l$ H
l$ H
fffff.
d$ H
AWAVAUATUH
C(H)
{hu9H
[]A\A]A^A_
AVAUI
ATUSH
v(dH
{PH;{0
H;{XH
ChtGH
4$H)
[]A\A]A^
{PH;{0
H;{XH
ChtUH
d$ H
l$ H
E(H+E E1
c0H)
l$ L
d$(L
l$0L
t$8L
|$@H
tCH;
f(t6H
\$ H
l$(L
d$0H
ATUH
ChH;CptMI
L;cpt
ChL9
 []A\
AVAUI
ATUSH
vpdH
{PH;{0
H;{XH
ChtGH
4$H)
{PH;{0
H;{XH
Cht\H
[]A\A]A^
AUATUH
EpH)
EXH+EPH
EXH+EPH
E(H)
E@H)
[]A\A]
AVAUI
[]A\A]A^
}PH;}0
H;}XH
EhtTH
\$ H
l$(L
d$0H
AUATUH
v0dH
{PH;{0
H;{XH
ChtOH
[]A\A]A^
E H+E
e I)
d$ L
l$(L
t$0H
AVAUI
ATUSH
{PH;{0
H;{XH
ChtGH
4$H)
[]A\A]A^
c H)
d$ L
l$(L
t$0H
AUATI
[]A\A]
[]A\A]
ATUH
 []A\
M(Hc
AWAVI
O@dH
}PI;}0
I;}XI
EhtPH
[]A\A]A^A_
vhdH
fffff.
l$ H
fff.
{PH;{0
H;{XH
{PH;{0
H;{XH
[]A\
} E1
fffff.
l$ L
d$(L
l$0H
l$ L
d$(L
l$0H
d$ L
l$(L
t$0H
<$t+H
fffff.
AVAUATUH
{PH;{0
H;{XH
ChtOH
{PH;{0
H;{XH
{PH;{0
H;{XH
[]A\A]A^
}@E1
d$ L
l$(L
t$0H
H;s tC1
H;s tC1
l$ H
l$ H
l$ H
l$ H
{PH;{0
H;{XH
ChtVH
d$ H
d$ H
fff.
G@H9GH
d$pL
l$`L
l$PL
d$@H
|$@H
l$0L
t$ H
fff.
{PH;{0
H;{XH
ChtUH
d$ H
l$ H
{PH;{0
H;{XH
ChtUH
d$ H
l$ H
ATUH
{PH;{0
H;{XH
{PH;{0
H;{XH
[]A\
}(E1
fffff.
d$ H
ATUH
{PH;{0
H;{XH
{PH;{0
H;{XH
[]A\
} E1
fffff.
ATUH
{PH;{0
H;{XH
{PH;{0
H;{XH
{PH;{0
H;{XH
{PH;{0
H;{XH
[]A\
} E1
}(E1
fffff.
~ dH
{PH;{0
H;{XH
ChtUH
d$ H
d$ H
D$H1
L$8H
L$ H
T$HdH3
\$PH
l$XL
d$`H
~ dH
{PH;{0
H;{XH
ChtUH
d$ H
d$ H
AVAUATUSH
D$(1
GHI+G@H
fffffff
D$(dH3
[]A\A]A^A_
H;,$t1H
AWAVAUI
ATUSH
D$(1
E0I+E(H
fffffff
EpI+Eh1
]pH)
D$(dH3
[]A\A]A^A_
H;,$t6H
AWAVI
ATUSH
D$h1
D$0H
D$0H
D$0H
L$(E
D$0H
D$0H
D$0H
l$@H
T$fH
D$0H
D$(	
T$hdH3
x[]A\A]A^A_
l$PH
T$gH
fffff.
AWAVAUATUSH
D$H1
D$F(H
D$0H
t$0H
D$0H
D$0H
D$0H
D$0H
D$0H
D$0H
D$0L
D$0H
D$0H
D$0L
D$0H
D$0H
D$0H
D$0H
D$0H
D$0H
T$0H
D$0H
D$0H
t$0H
|$0H
\$ H
t$ H
D$F)H
FHH)
@HH)
D$HdH3
X[]A\A]A^A_
D$0H
D$0H
|$0H
fff.
D$81
t$ H
t$0H
T$7H
|$ H
D$8dH3
\$HH
l$PL
d$XL
l$`L
t$hL
|$pH
D$81
t$ H
t$0H
T$7H
|$ H
D$8dH3
\$HH
l$PL
d$XL
l$`L
t$hL
|$pH
AWAVI
AUATUSH
d$ H
D$xH
D$ H
D$ H
|$@H
D$ H
D$xH
D$(H
.I;n
<"tL
(I;n
(I;n
|$PH
D$ H
D$xH
|$@H
|$XH
D$ H
[]A\A]A^A_
D$ H
D$ H
fff.
AWAVAUATI
l$PH
D$ I
T$ L
t$PH
D$PH
D$PI
D$XH
D$(H
\$(H
T$(H
D$pH9
|$xH
T$OH
\$@H
D$@H
D$PI
T$ I
t$PI
[]A\A]A^A_
|$xH
\$0H
D$0H
T$ L
t$PI
T$ L
t$PI
l$ L
d$(L
l$0H
fffff.
l$ L
d$(L
l$0H
fffff.
H;=K
H;=?
AVAUATUSH
D$(1
GHI+G@H
fffffff
D$(dH3
[]A\A]A^A_
H;,$t1H
ATUH
[]A\
ATUH
[]A\
l$HI
\$(H
[]A\
[]A\
{PH;{0
H;{XH
Cht<H
l$ H
D$ L
l$ L
d$(L
l$0L
t$8L
|$@H
R H9
D$ L
l$ L
d$(L
l$0L
t$8L
|$@H
R H9
D$(1
H9U w
H;P wI
L$(dH3
0[]A\
H;P v
D$H1
V I9
$sEH
$H9P 
T$HdH3
\$PH
l$XL
d$`H
W H9
P I9
$H9B s
AWAVAUATM
D$81
t)L9
N I9M s
L$8dH3
|$(L
d$ L
H[]A\A]A^A_
w0dH
w0dH
w0dH
G0H9GPuBH
G0H9GPuVH
G0H9GPuVH
ATUSH
[]A\A]A^
{PH;{0
H;{XH
Cht<H
{PH;{0
H;{XH
Cht<H
{PH;{0
H;{XH
Cht<H
{PH;{0
H;{XH
Cht5H
{PH;{0
H;{XH
Cht<H
W@dH
dH34%(
l$ L
d$(L
l$0L
t$8L
|$@H
v[L)
SHL)
G0H9GPuBH
AWAVAUATI
[]A\A]A^A_
\$(H
l$0L
d$8L
l$@L
t$HL
|$PH
AWAVAUI
ATUSH
%,P1
[]A\A]A^A_
l$HI
\$@H9
|$@H
|$ H
[]A\
|$@H
|$@H
AWAVAUATI
D$X1
l$ H
D$ I
|$ I
D$(A
D$,A
D$0A
D$4A
D$8A
D$XdH3
h[]A\A]A^A_
<?L9
fffffff
fffffff
t5H9\$
=wI1
D$hH
%AK1
D$@H
D$hH
5fM1
D$@H
D$hH
AUATI
D$`L
l$0I
\$(H9
|$(H
D$ H
[]A\A]
=?E1
|$(H
AUATI
D$`L
l$0I
\$(H9
|$(H
D$ H
[]A\A]
|$(H
H;=KC1
=5B1
H;=[A1
H;=K>1
=/=1
=3:1
H;=}91
l$HI
\$@H9
|$@H
D$8H
|$ H
[]A\
|$@H
=y71
|$@H
AUATI
-\71
l$HI
\$@H9
|$@H
D$8H
|$ H
[]A\A]
=161
|$@H
ATUH
]@I9
[]A\
=841
D$pH
|$XH
l$HI
\$@H9
|$@H
|$ H
[]A\
=;21
|$@H
|$@H
H;=c11
wHdH
fffff.
} u1H
fff.
|$pH
d$ H
|$pH
fff.
=U'1
=r!1
fff.
l$ H
l$ H
fff.
fff.
AUATL
C8H)
[]A\A]
l$ H
l$ H
D$81
|$0H
D$8dH3
AUATUH
D$H1
L9H s
K8H;H I
H9J s
H9N v H
T$ H
L$ H
H9H s
H;N s
H9H s
H;N s
D$HdH3
X[]A\A]
H9J s
H;N s
T$0H
L$0H
fffff.
D$(1
T$&H
T$(dH3
\$0H
l$8L
d$@H
T$'H
fffff.
w(dH
v8H)
SHH)
d$ L
l$(L
t$0H
D$81
D$0H
D$(H
|$ H
l$0H
T$8dH3
ffffff.
l$0I
T$GH
D$H1
d$(A
|$ H
D$HdH3
\$XH
l$`L
d$hL
l$pH
fffff.
D$(1
l$ H
w8dH
H;w@t5H
<$t>H
wPdH
H;wXt9H
AVAUATUH
w(dH
[]A\A]A^A_
H(M)
IXH)
@XH)
t%H9J
H9J H
ATUH
D$(1
F H)
D$(dH3
0[]A\
S H+S
s H+s
T$'H
5]	1
\$(H
l$0L
d$8L
l$@H
\$ H
l$(L
d$0L
l$8L
t$@H
~#H9
AWAVAUI
ATUH
D$x1
l$`H
T$wH
t$PL
D$XA
D$XL
\$@L
D$8H
D$@H
T$xdH3
[]A\A]A^A_
\$(H
l$0H
D$(1
t$ I
L$(H
d$0H
D$(dH3
\$8H
l$@L
d$HL
l$PL
t$XL
|$`H
AUATUH
[]A\A]
d$ L
u:H)
AWAVI
AUATUH
D$(1
D9,$t!I
t$'H
D$' 
D$(dH3
8[]A\A]A^A_
l$ H
d$(L
l$0H
AWAVI
ATUSH
D$(1
P(H+P 
\$ M)
H(H+H H
t$ I
D$ H
T$(dH3
8[]A\A]A^A_
AUATUH
[]A\A]
d$ L
k(H+k I
AWAVAUATUSH
T$hH
T$0H
L$HH
T$0H
D$@H
|$ H
D$(H
t$`H
L$PH
L;|$@H
D$pH
T$xH
L$8L
L$0M
H;D$
t$HH
H9P s
D$HI
H9V v1H
|$HH
H;\$
D$(I
L;|$@
T$ H
L$ H)
T$HH
D$ H
l$ 1
[]A\A]A^A_
H;\$
t$(H
T$PH
|$hH
|$PI
t$(H
T$XH
|$hH
|$XI
T$pH
T$8L
|$(H
T$8L
|$PH
|$XH
AVAUATUSH
T$?H
D$0H
t$@H
D$ 1
D$PH
[]A\A]A^A_
fff.
 []A\
|$ H
 []A\
|$ H
AWAVI
AUATUH
([]A\A]A^A_
AWAVAUI
ATUSH
[]A\A]A^A_
KPM)
KhH)
SHH;sp
D$pH
t$pI
T$`I
d$PI
l$ L
l$0H
D$ H
d$ H
d$ H
d$ H
fff.
~ dH
l$ H
l$ H
l$ H
d$ H
d$ H
fff.
|$ H
d$ H
|$ H
d$ H
d$ H
fffff.
AWAVAUATUH
D$0H
D$hH
D$pH
T$ H
D$(H
D$`I
\$(L
H;X v
H;Y stL
t$`H
|$8H
D$0t
[]A\A]A^A_
47t41
T$ H
l$pH
|$PH;|$0
H;|$XH
D$PM
T$0H
H9T$PH
D$hH
T$hH
D$XH
D$PH
AWAVAUATI
D$HH
D$PH
|$hH
[]A\A]A^A_
AWAVAUATI
|$ H+
T$0H
D$@L
T$HH)
l$xI
d$pH
|$PH;|$0
H;|$XH
D$htSH
D$PM
s H)
D$hH
T$hH
D$XH
D$PH
|$PH;|$0
H;|$XH
D$htCH
D$PM
D$hH
T$hH
D$XH
D$PH
D$0H9D$P
[]A\A]A^A_
AVAUATUH
l$p1
|$ H+
T$0H
D$@L
T$HH)
|$PH;|$0
H;|$XH
D$PH
D$0H9D$P
] ubH
[]A\A]A^
D$hH
T$hH
D$XH
D$PH
ffffff.
AWAVAUATUH
T$,dH
t$ H
t$HH
T$0H
L$XH
t$`H
H;Y v
MhH9
H;_ 
H;Y v
H;<$t
H;_ s
L$hH)
t$XH
L$@H
D$HH
D$XH9
T$XE1
t$0H
L$`H
t$hH
H;Y v
MhH9
H;_ 
H;Y v
H;<$t
H;_ s
D$XH
D$XH9
T$hH
L$pH
D$0I
L$XH
t$ H
D$@H
H9D$
L$`I
H;X v
EhH9
H;Y 
H;X v
H;Y s
t$PH
H;^ v
H;4$t
H;^ 
L$@H
vPI;vX
t$8H
|$ H
t$ H
|$0H
T$@H
t$0H
b0L;b8u?
8L;b8t+M
L;b8u
t$HH
|$XH
|$XH
|$`H
t$`H
|$PH
t$PL
T$pL
t$HL
|$0H
H;^ v
H;4$t
H;^ 
L$ H
vXI;v`J
|$0J
|$@H
t$@H
T$ H
f M;f(u0
M;f(t'M
M;f(u
f8M;f@u/
M;f@t'M
M;f@u
|$`H
t$xH
t$HH
|$`H
|$hH
t$hH
|$PH
t$PL
T$xL
t$HL
|$PH
H;Z v
H;Z 
D$HH
T$`I
|$pI
T$8L
|$0H
t$0H
T$HH
|$XH
|$ I
|$ H
|$@H
t$@H
T$`L
[]A\A]A^A_
|$PH
AWAVAUI
ATUSH
l$PH
l$XL
H;l$`H
l$XH
l$XH
|$PH)
T$(H
T$@H
T$pH
T$0H
T$(H
T$HH
D$ H
FxH)
D$ H
D$8H)
D$<H)
[]A\A]A^A_
|$PH
|$PH
|$@H
|$@H
t$@L
t$HH
t$0H
T$ H
|$0H
AVAUATUH
D$0H
T$0H
T$`H
D$pL
T$xH)
D$0I
D$ H
^0I9
H;|$`
^ tO
D$ H
H9D$
^ I9
H;|$`
H9D$
D$0H
D$`H9
|$8H
D$0t
[]A\A]A^A_
|$(I
t$(H
|$ H
t$ H
|$ I
t$ H
D$0H
|$ H
~@dH
{PH;{0
H;{XH
d$ H
H+C H
~(dH
{PH;{0
H;{XH
d$ H
H+C H
ATUH
{PH;{0
H;{XH
{PH;{0
H;{XH
[]A\
} E1
H+C H
ATUH
~@dH
{PH;{0
H;{XH
e@tSH
[]A\
H+C H
fff.
d$ H
D$CH
H+C H
D$ I
D$(I
d$ L
l$(L
t$0H
=my0
H+C H
fffff.
AUATI
D$(I
[]A\A]
H+C H
AVAUATUSH
D$81
I;t$ H
\$0H
D$(H
I;t$ H
l$(H
D) I
D$8dH3
H[]A\A]A^A_
H+B H
H;s L
H;s L
\$(H
l$0L
d$8L
l$@L
t$HL
|$PH
=mp0
D$CH
H+E H
fff.
AUATI
WpdH
D$(H
D$8H
D$@H
T$XH
D$hH
D$xH
CxE1
[]A\A]
=Ym0
H+C H
AUATI
D$(I
[]A\A]
H+C H
fffff.
{PH;{0
H;{XH
e(tuH
D$(H
D$8H
D$@H
T$XH
D$hH
D$xH
H+C H
=qf0
AUATE1
{PH;{0
H;{XH
{PH;{0
H;{XH
e tQH
[]A\A]
D$ H
=Md0
H+C H
AVAUATI
{PH;{0
H;{XH
|$(I
{PH;{0
H;{XH
H;h v
t]H;i rWH
[]A\A]A^
D$(I
D$8H
D$@H
L$XH
D$hH
D$xH
D$(H
H+C H
AVAUATUSH
D$81
D$01
l$0H
I;t$ I
D) I
I9T$
D$8dH3
H[]A\A]A^A_
H+B H
t$(L
|$(H
AVAUATI
D$(1
D$(dH3
8[]A\A]A^A_
FpH+FhH
T$pI+T$hH
D$ H
T$hH
D$pA
T$hH
\$ H
H;u H
I+G H
{PH;{0
H;{XL
l$ L
d$(L
l$0H
H+C H
AVAUATUSH
D$H1
D$@1
D$ H
{PH;{0
H;{XH
5sT0
t$(H
t$(H;t$0
D$(H
D$(I
T$ H
D$(H)
T$ H
t$8H
|$ H
D$HdH3
X[]A\A]A^A_
t$ I
H+C H
|$ H
AVAUATUH
l$p1
|$ H+
T$0H
D$@L
T$HH)
|$PH;|$0
H;|$XH
D$PH
D$0H9D$P
] ubH
[]A\A]A^
D$hH
T$hH
D$XH
D$PH
fffff.
l$`H
|$PH
d$@L
t$@H
t$0H
|$PH
|$PH
T$_H
fffff.
AWAVAUATI
5^J0
|$0H
D$HH
H;\$
\$PH
l$8E
\$<E
|$pI
|$XH
[]A\A]A^A_
t	D9
t	A9
fff.
v(dH
fff.
AWAVI
AUATUSH
D$X1
D$XdH3
h[]A\A]A^A_
v0E1
H;|$ 
CpH+ChH
l$0H
T$VH
5mC0
l$@H
T$WH
fffff.
|$pH
l$PL
t$PI
t$@I
l$ H
|$pH
l$`H
|$pH
o8dH
d$ H
l$ H
l$ H
fff.
WxdH
fff.
ATUH
[]A\
5270
WxdH
fff.
WxdH
fff.
\$(H
l$0L
d$8L
l$@L
t$HL
|$PH
R0H)
AWAVAUATI
n8dH
R(H)
D$xH
dH34%(
([]A\A]A^A_
[]A\A]A^A_
C H)
\$(H
l$0L
d$8L
l$@L
t$HL
|$PH
P0H)
AVAUATI
F(H+F H
T$ H
D$xH
L$ H
T$XH
T$`H
D$8H
D$pH
=F%0
T$(I+T$ H
T$ H
D$(A
T$ H
H;u H
[]A\A]A^A_
I+G H
H+G H
AUATUH
|$`H;|$@
H;|$hH
D$`H
D$@H9D$`
[]A\A]
D$xH
T$xH
D$hH
D$`H
fff.
AVAUATUSH
t$P1
D$@H
D$(H
D$ H
D$HH
D$0H
|$XH
D$Pt
D$PI
T$0H
|$8H
T$@H
|$(H
t$(H
t$ L
|$HH
[]A\A]A^A_
|$ H
|$ I
fffff.
AVAUATUH
|$ H
T$@H
D$PL
T$XH)
|$`H;|$@
H;|$hH
D$`H
D$@H9D$`
[]A\A]A^
D$xH
T$xH
D$hH
D$`H
fffff.
AWAVAUATUSH
D$LE
|$ H
T$0H
L$(H
T$ H
J0H9J8
D$PH
t$hL
9l$LI
\$`A
T$LH
T$(H
L$(H
t$ H
T$8H
T$LI
D$LL
L$(L
T$0A
T$LH
D$ H
@8H)
L$(L
T$0H
@8H)
t$`H
[]A\A]A^A_
D$8H+D$@H
L$(H
T$LH
T$ H
l$ H
L$ H
t$LL
D$ H
H;,$u
t$LL
D$ H
t$ H
D$0H
t$LL
T$ H
t$(H
L$0L
D$LI
|$0L
L$(H
T$0H
t$`H
|$ H
|$ H
AVAUATUSH
L$ H)
L$@H
L$`H
L$pH
L$PH
L$@H
L$hH
L$XH
L$HL
L$8H
u	A9
T$8L
[]A\A]A^A_
|$`I
|$`H
t$hH
t$PH
T$XH
|$HH
t$HH
|$HH
|$PI
AWAVAUI
ATSH
[A\A]A^A_
L;` v
L;` 
L;b H
L;` 
@XM)
B0H+B(H
H;sxI
L$ I
H;q 
spH;sxH
H;r H
I;v H
L$0I
T$ I
T$ H
spH;sxH
t$ I;t$(I
spH;sxL
H;q I
H;sxI
AWAVAUATUH
D$pH
D$(H
D$PH
D$xH
D$`H
D$hL
VXH)
T$0L)
T$@f.
D$(I
H9\$(I
T$0K
D$(D
VpH)
t$8H
T$@H
|$PH
|$@I
D$0H
D$0L)
{PH;{0
H;{XH
ChtWH
D$8H
T$81
{PH;{0
H;{XH
Cht_H
M H)
L$0H)
L$\H)
T$hH
D$Lu"H
[]A\A]A^A_
|$@H
T$ H
D$(H
T$0H
D$8L;l$
D$ H
t$(H
H;X v
H;^ s!H
T$8L
T$0L
|$(H
H9\$
T$0H
D$(H
T$@H
T$ L)
d$0I
D$8H
L9d$0L
t$ H
T$8H
|$PH
ATUH
[]A\
ATUH
[]A\
[]A\
AUATUH
([]A\A]
{PH;{0
H;{XH
Cht<H
l$ H
[]A\
r0H9
D$ I
D$(L
l$ L
d$(L
l$0L
t$8L
|$@H
R H9
D$ I
D$(L
l$ L
d$(L
l$0L
t$8L
|$@H
R H9
D$(1
H;U r
H9P rI
L$(dH3
0[]A\
H9P s
D$H1
V I9
$sEH
$H9P 
T$HdH3
\$PH
l$XL
d$`H
W H9
P I9
$H9B s
D$(1
H;U r
H9P rI
L$(dH3
0[]A\
H9P s
D$H1
V I9
$sEH
$H9P 
T$HdH3
\$PH
l$XL
d$`H
W H9
P I9
$H9B s
G0H9GPuVH
\$(H
l$0L
d$8L
l$@H
D$X1
T$ H
D$0H
{ H+T$
H+D$8H
D$HH+D$(H
t$ H
L$0H+L$8H
D$(H)
L$HL)
D$XdH3
`[]A\
l$ H
\$ H
l$(L
d$0H
l$ H
w0dH
w0dH
\$(H
l$0L
d$8L
l$@L
t$HL
|$PH
\$(H
l$0L
d$8L
l$@L
t$HL
|$PH
~(dH
$t H
s8H;s@tD1
\$ H
l$(L
d$0H
H+3H
4$H)
\$(H
l$0L
d$8L
l$@H
\$(H
l$0L
d$8L
l$@L
t$HL
|$PH
,)L)
\$(H
l$0L
d$8L
l$@L
t$HL
|$PH
d$ L
l$(L
t$0H
G0H9GPuVH
G0H9GPuBH
C0H9CPuUH
C0H9CPuBH
C0H9CPuUH
C0H9CPuBH
d$ L
l$(L
t$0H
u H)
D$(1
uEI)
L$(dH3
0[]A\
D$H1
T$HdH3
\$XH
l$`L
d$hL
l$pH
H9] 
D$(1
uEI)
L$(dH3
0[]A\
 t(H
d$ L
l$(L
t$0H
u H)
D$(1
uEI)
L$(dH3
0[]A\
D$H1
T$HdH3
\$XH
l$`L
d$hL
l$pH
H9] 
D$(1
ugH)
T$(dH3
8[]A\A]
ATUSH
~ dH
unH)
[]A\
ATUH
~ SH
[]A\
[]A\
d$ L
l$(L
t$0H
u H)
D$(1
uEI)
L$(dH3
0[]A\
D$H1
T$HdH3
\$XH
l$`L
d$hL
l$pH
H9] 
AWAVAUATUSH
D$h1
H9H s
T$ H9P8
D$PL
t$ L
l$`1
D$(H
H;P v
H;V 
|$0H
D$ H
D$hdH3
x[]A\A]A^A_
AWAVI
AUATI
D$h1
t$8I
L$0H
D$PL
|$ H
l$`H
|$ L
D$ H
D$0H
L$0I
D$hdH3
x[]A\A]A^A_
AWAVAUATUSH
D$h1
S(H)
T$hdH3
x[]A\A]A^A_
S(H+S H
B(D9
M9j0
d$`H
l$PL
\$ H
l$0H
D$ H
I;B8
I;R@
ATUSH
d$pH
|$ H+
T$0H
D$@L
T$HH)
|$PH;|$0
H;|$XH
D$PH
T$0H9T$PI
[]A\A]
D$hH
T$hH
D$XH
D$PH
W`dH
H+G H
W`dH
H+G H
W`dH
H+G H
W`dH
H+G H
W`dH
H+G H
W`dH
H+G H
W`dH
H+G H
W`dH
H+G H
W`dH
H+G H
v(dH
AWAVI
AUATI
t$ L
t$`H
|$`H
D$hH)
|$`H
D$`H
\$0L
|$ H
D$0H
[]A\A]A^A_
T$(L
T$ H
|$ H
D$ H
|$ H
t$ H
|$`H
fffff.
fff.
=Xq/
5*q/
=sf/
ffff.
fff.
\$(H
l$0H
AUATI
[]A\A]
oPdH
oPt#
[]A\
[]A\
fffff.
AVAUATI
I+D$
I+D$
D$`1
T$hH
D$@H
D$PH
T$HH
T$XH
D$ H
T$(H
D$0H
T$8H
D$pH
[]A\A]A^
T$0H
[]A\A]
D$81
D$0H
D$ H
H9\$0tHH
T$8dH3
\$@H
l$HL
d$PH
fff.
D$81
|$0H
D$8dH3
D$X1
|$0H
D$8H
D$XdH3
fffff.
D$X1
|$0H
D$@H
D$XdH3
fffff.
D$X1
|$0H
D$8H
D$XdH3
fffff.
51X/
\$ H
l$(L
d$0H
fffff.
\$ H
l$(L
d$0H
fffff.
5hU/
\$ H
l$(L
d$0H
\$ H
l$(L
d$0H
\$ H
l$(L
d$0H
\$ H
l$(L
d$0H
\$ H
l$(L
d$0H
D$(1
T$'H
58L/
T$&H
D$(dH3
\$0H
l$8L
d$@H
ATUH
D$81
T$5H
T$6H
d$ H
T$7H
D$8dH3
@[]A\
fffff.
\$ H
l$(L
d$0H
ATUH
D$(1
H8H)
H93u
H;3u
T$'H
5kD/
T$(dH3
0[]A\
H@H)
H;3u
H(H)
H;3u
5nC/
fffff.
\$(H
l$0L
d$8L
l$@H
fff.
\$(H
l$0L
d$8L
l$@H
fff.
l$ H
l$ H
l$ H
d$ H
d$ H
AWAVAUATUH
W(dH
D$81
={7/
L$(f
H;X v
H9D$
H;X A
H;X v
H9D$
H;X A
H;X v
H9D$(
H;X 
=`5/
D$ L
t$ H
D9t$
T$8dH3
D$8dH3
H[]A\A]A^A_
=a3/
L$8dH3
[]A\A]A^A_
ATUH
[]A\
D$(1
T$'H
5Z4/
D$(dH3
0[]A\
fffff.
D$(1
T$'H
D$(dH3
0[]A\
fffff.
\$ H
l$(L
d$0H
AWAVAUATUSH
D$X1
D$ H
D$0H
D$(H
C0H+C(
|$0H
|$8L
l$HH
\$ L
|$0M
.|BH
0|(H
A;j8|
l$8H
|$0M
192|
L$(H
|$0H
T$XdH3
h[]A\A]A^A_
@8;D$H
L$(H
|$0H
AWAVAUATUSH
|$ H
D$x1
D$8H
l$8I
T$pL
t$PH
T$`H
t$pH
t$PH
E(H)
E(H+E H
H;D$
t$0L
D$xdH3
[]A\A]A^A_
t$`H
t$PH
E(H)
E(H+E H
t$0L
ATUSH
([]A\A]
fff.
ATUH
[]A\
fff.
D$h1
d$PH
T$gH
D$hdH3
\$pH
l$xL
fff.
D$h1
d$PH
T$gH
5A!/
D$hdH3
\$pH
l$xL
fffff.
l$0I
T$GH
D$H1
d$(H
|$ H
D$HdH3
\$XH
l$`L
d$hL
l$pH
D$(L
[]A\
D$81
T$8dH3
\$@H
l$HL
d$PH
l$ H
T$7H
T$6H
=U$/
\$(H
l$0L
d$8L
l$@H
t$HL
|$PH
\$(H
l$0L
d$8L
l$@H
t$HL
|$PH
AVAUATUH
T$81
E0H+E(H
cHH)
L$8dH3
H[]A\A]A^A_
l$ H
T$7H
V(dH
D$X1
B0H+B(H
d$@H
T$WH
D$0H
|$0H
D$XdH3
\$`H
l$hL
d$pH
D$(1
T$'H
D$(dH3
\$0H
l$8L
d$@L
l$HL
t$PH
fffff.
s(A;F
l$pH
d$`H
|$PH
|$0H
d$(I
t$8H
|$0H
|$ H
V(dH
T$0H
|$8H
|$0H
T$0H
d$`H
T$0H
T$0H
|$0H
t$0H
D$ H
D$(H
D$8I
t$@H
D$pA
D$xA
D$|I
D$pH
t$@L
\$ I
D$ A
D$(A
D$,I
D$0I
D$8I
D$@I
T$`H
l$@H
T$OH
l$PH
l$PH
D$PH
D$PI
D$XH
D$0H
T$ H
l$0I
D$PI
l$PH
l$PH
l$PH
AVAUATUSH
T$pH
t$ H
D$8H
L$01
D$0H
D$@H
D$PH
D$hH
D$XH
D$`H
L$01
T$@H
T$8H
|$ H
|$PH
l$ H
H;D$ H
H;l$ 
L;l$ L
t$hH
t$hH
T$0I
D$8H)
T$0I
D$8A
|$ H
t$hH
D$0H
T$@H
T$8H
L$(H
L$8H
L$ H
T$(H
H9D$(H
L$PH
T$HH
L$(H
|$8L
T$8I
D$@H)
|$ H
T$8I
D$@A
T$ I
D$(H)
T$ I
D$(A
|$hH
t$HH
t$0H
D$(H
H9D$(
[]A\A]A^A_
|$PH
T$hH
t$XH
|$PH
t$HH
|$`L
|$xL
T$`H
|$pL
|$xH
|$PH
T$HH
|$`H
|$`H
|$XH
|$PH
|$@H
|$ H
|$8H
L$0H
T$@H
T$8H
D$0H
T$@H
T$8H
ATUSH
 []A\A]A^
AWAVI
AUATUSH
d$`L
D$8H
D$(H
D$0H
D$pH
D$PH
D$@H
L;h v
H9D$
L;h @
L;h v
H9D$
L;h 
L;h v
H9D$8
L;h 
T$0H
|$ L
t$@H
|$(L
[]A\A]A^A_
|$ H
AVAUATUSH
D$@H
T$pH
T$ H
t$`H
\$PL
l$0H
[]A\A]A^A_
D$pH
T$pH
T$ H
|$ H
D$(H
D$(H
D$(H
D$(L
D$(L
D$(H
D$(L
D$(H
D$(L
\$ H
l$(L
d$0H
fff.
d$ H
D$X1
t$0H
T$VH
l$ H
T$UH
D$@L
T$SH
T$TH
|$01
D$XdH3
\$hH
l$pL
d$xL
\$@H
T$WH
fffff.
W8dH
D$X1
l$ H
T$WH
d$0H
D$XdH3
\$`H
l$hL
d$pL
l$xL
d$0H
d$@L
d$0H
T$VH
T$UH
fffff.
AVAUATUSH
|$ dH
L$ H
t$ H
T$0H
D$8H
T$8H
L$(H
|$P1
L$ H
L$PH
D$XH
L$ H
D$ H
l$ H
D$@L
T$ H
t$ H
L$@H
T$ H
t!H;
L$ L
D$HH
t$ L
T$HH
L$(H
L$8H
[]A\A]A^A_
t$ H
D$(H
T$8H
D$(H
T$8H
fff.
AWAVAUATUSH
\$8H
l$@H
D$hH
D$(L
t$(H
[]A\A]A^A_
AVAUATI
t$XH
D$HH
T$0H
L$ H
D$(H
L$hH
D$pH
T$`H
D$xH
L$@H
D9l$
L$ H
T$(D
|$8H
H+\$X
H9D$X
H+D$XH
t$0H
9X s
D$0H
t	9^ 
L$xH
|$0H
|$pH
H9H s
H9N v%H
D9l$
L$`H
t$ H
t$>H
T$HH
[]A\A]A^A_
T$`H
|$@L
t$@H
|$8H
D$@H
T$0H
D9h s
T$0H
D9h 
|$0H
D9n s
D$0H
D9n 
|$0H
0H9\$(
D$(H
H9P s*H
D$(H
L$@H
L$@1
|$@H
L$@H
|$@H
t$@H
D$(H
|$@H
|$@H
|$@H
L$@H
L$@H
L$@H
L$(I
Y H+
T$@H
H;\$P
T$HI
H;\$h
T$`I
L$0H
T$pH
L$@H
L$pH
;N v
|$0H
T$pH
\$xH
\$(H
t$ H
t$(H
t$xH
L$(H9
t$ H
T$8H
t$XH
t$ H
t$PH
t$ H
t$hH
t$ H
t$ H
|$8H
H+\$X
59o.
t$8I
t$@H
T$xH
L$PH
|$pH
|$pH
L$PH
L$@H
|$@H
|$@I
|$@H
|$ I
H+\$X
|$@I
fffff.
AWAVAUATUH
s8dH
D$8H
T$8H
L$0H
D$(H
t$hH
D$(H
L$(H
|$ H
t$ L
=_`.
D$0H
L$8I
[]A\A]A^A_
D$(H
|$ H
t$hH
D$@H
D$xH
D$@H
E8H)
F0H+F(H
F0H+F(H
|$ H
D$(L
T$ H
L$(L
t$pH
|$HH
D$(H
5<X.
L$(L
|$HH
|$ H
D$0H
L$8H
L$0H
T$8H
AWAVAUATUH
D$h1
d$PH
D$@H
|$0H
t$ H
t$@H
T$gH
t$ H
t$0H
t$@H
t$ H
D$hdH3
x[]A\A]A^A_
fff.
D$(1
T$(dH3
\$8H
l$@L
d$HL
l$PH
T$'H
fffff.
ATUSH
D$(1
T$(dH3
0[]A\
D$(1
T$(dH3
\$8H
l$@L
d$HL
l$PH
fffff.
5.K.
t$`H
l$pH
l$PH
fff.
AVAUATUSH
P H;
|$PH
D$8H
|$0H
D$ H
|$(H
D$@I
|$(1
B0H+B(H
T$PH
|$ H
|$8H
5N;.
T$8H
|$@H
T$@H
|$0H
t$0H
|$ H
T$HH
|$HL
T$HH
T$8H
|$@H
|$XH
|$hH
D$ H
|$8H
D$(H
|$0H
|$hH
D$HH
L$XI
D$XH
L$PH
|$(f.
|$(H
L$ H
[]A\A]A^A_
t%L;
T$HH
L$HL
=	*.
|$0H
D$@H
T$@H
L$01
|$0H
|$@H
L$0H
|$`H
t$0H
|$0L
|$8L
|$8L
|$8L
|$8L
|$8H
|$8H
|$8H
L$`H
|$0H
|$0H
L$@H
|$0H
L$HH
|$0H
|$0H
T$@H
T$@H
L$01
|$0H
|$@H
L$0H
|$`H
t$0H
D$pH
|$0H
L$pH
|$xH
L$pH
T$pH
|$ H
|$ L
|$ L
|$ L
|$ H
|$ H
|$ H
|$`H
|$0H
|$0H
|$@H
L$0H
|$0H
T$HH
|$@1
L$0H
|$@H
L$@1
L$0H
|$0H
|$@H
L$0H
|$`H
|$pH
|$0H
|$0H
t$0H
D$xH
T$pH
|$(H
|$pH
|$(L
|$(L
|$(L
|$(H
|$(H
|$(H
L$`H
|$0H
|$0H
L$@H
|$0H
T$HH
L$HH
|$8L
|$ L
|$(L
d$XI
|$8H
L$hH
|$XL
t$0H
D$xH
t$0L
|$0H
|$0H
|$@H
L$0H
|$ H
|$ H
|$0H
|$0H
|$0H
|$@H
L$0H
|$0H
|$0H
|$8H
|$0H
AWAVAUATUH
T$8H
T$(D
B0H+B(H
T$ H
D$(H
|$(H
T$(A
B0H+B(H
t$ H
|$0I
|$8I
[]A\A]A^A_
FpH)
l$@H
l$@H
t$LH
AWAVAUATUH
T$hH
t$pdH
D$x1
D$pH
E0H)
T$ 1
t$,L
D$xdH3
[]A\A]A^A_
fffff.
AWAVAUATUH
n8dH
D$h1
E(H)
T$ 1
t$,L
D$hdH3
x[]A\A]A^A_
fff.
AWAVI
AUATUSH
T$pH
t$xdH
D$xH
E0H)
E0H)
[]A\A]A^A_
l$`H
d$PD
|$@I
|$0H
|$@H
|$0H
|$0H
ATUH
D$H1
|$@H
|$0H
D$HdH3
P[]A\
|$0H
fff.
AWAVAUI
ATUSH
F0H)
D$`1
t$lL
F0H)
[]A\A]A^A_
AWAVAUATUH
f8dH
|$8M
T$(H
F(I+T$ H+F H
T$81
T$`1
T$@H
T$0H
T$HH
T$@H
T$PH
T$ H
T$@H
T$PH
|$ H
t$ H
D$pH
D$xH
t$8L
D$ H
t$8H
|$0L
t$0H
|$0L
|$ H
l$HH
T$@H
T$ H
T$PH
T$XH
T$0H
|$0H
D$ H
t$PH
|$ H
t$ L
L$HL
L$@H
T$0H
\$(H)
T$ H
T$XH
|$0H
|$0H
t$PH
D$81
T$81
t$PH
T$81
[]A\A]A^A_
D$81
D$8L
D$8L
D$8u
D$8L
D$8t
D$8H
D$8L
D$8H
|$ H
D$8L
D$8I
|$@H
D$8I
D$`H
|$0H
fff.
AWAVAUATI
B0H)
U H)
D$P1
D$8H
D$@H
D$8H
D$HH
D$ H
D$(H
D$8H
T$HH
|$ H
|$(H
L$ H
t$(H
I;\$
D$`H
D$hH
D$pH
D$xH
S0H)
t$@H
I;\$
T$8H
|$(H
E H)
D$PH
t$8H
I;\$
D$`H
D$hH
D$pH
D$xH
t$8H
t$8H
[]A\A]A^A_
t$8H
T$8H
|$(H
|$8H
D$PH
|$@H
AWAVAUATUH
|$8H
|$@H
|$0H
[]A\A]A^A_
|$0H
AWAVAUATUH
|$pH
|$HH
|$pH
l$xH9
|$pH
[]A\A]A^A_
|$pH
AVAUATUH
l$PL
t$\H
5s~	
|$@I
|$0H
[]A\A]A^
T$0H
|$0H
fffff.
AWAVAUI
ATUSH
l$0H
t$<H
[]A\A]A^A_
@0H)
@0H)
|$ I
|$(I
AVAUATUH
g(dH
|$0L
B0H+B(H
l$PH
|$@H
|$0H
[]A\A]A^
|$0H
AWAVAUATUH
[]A\A]A^A_
E H+E
T$ H
@0H)
D$01
t$<L
@0H)
AWAVAUI
ATUSH
~ dH
T$8H
T$(H
T$(H
B0H+B(H
T$@E1
|$ H
B0H+B(H
|$(H
|$(I
|$0I
|$8I
[]A\A]A^A_
|$(I
t$\I
|$@I
|$0I
|$0H
fffff.
|$pH
|$01
|$01
AWAVAUATUH
T$0H
T$0H
T$0H
T$0H
T$ H
T$(L
|$0H
[]A\A]A^A_
T$0H
T$0H
T$0H
T$0H
T$0H
T$0H
T$0H
T$0H
T$0H
T$0H
T$0H
T$0H
T$0H
T$0H
AWAVAUATI
B(H+B H
|$01
|$01
|$01
[]A\A]A^A_
5X{	
B(H)
{ H9y
C(H9A
|$8H
L$8H
D$@H
|$0H
D$HH
|$(H
T$HH
|$ H
|$(H
L$ H
t$(H
|$8L
|$@L
t$0H
T$@H
|$0H
|$(H
L$@H
T$8H
|$(H
D$ H
EpH+EhA
t$(L
|$ H
L$PL
t$ H
5Wz	
|$01
D$0H
D$0H
|$01
D$0H
5[~	
D$0H
|$8H
t$@H
|$01
t$8H
L$0H
D$0H
D$0H
D$0H
|$(A
D$0H
t$(H
|$0A
D$0H
t$0H
D$0H
t$@H
|$01
5|m	
|$@H
|$01
t$8H
|$01
D$0H
5fx	
|$8H
|$ L
|$8H
D$ tdI
L$ u
5<g	
=Cg	
|$(I
|$0I
5:f	
|$8I
|$(I
|$0I
ffff.
AWAVAUATUH
l$ H
5,e	
|$XH
D$ t
|$@H
|$0H
[]A\A]A^A_
5+h	
L9T$
L9l$
5}f	
5Of	
5Rw	
5`1	
=HH	
5*[	
B(H+B H
B(H)
G H9A
G(H9A
5YY	
5cX	
5DX	
5%X	
=EX	
|$0H
AWAVAUATI
T$@H
T$ H
D$LH
T$0H
5(n	
t$ L
|$01
5lm	
t$ H
|$01
59n	
5`k	
t$ L
5ul	
5hh	
5Oh	
5{a	
T$ L
|$01
5ng	
5Tg	
T$ L
5IZ	
t"M;
T$ H
|$01
|$01
5&i	
5u$	
|$01
5jb	
5Vb	
|$01
5Y^	
|$01
56a	
5i!	
T$ H
|$01
5|N	
|$xH
D$@t
|$ H
[]A\A]A^A_
=K7	
5-J	
T$ L
B(H+B H
5bQ	
T$ L
|$01
|$01
|$01
T$ H
5FN	
B(H)
=aa	
T$ L
5(E	
T$ H
t$ H
|$01
5,]	
5(Y	
5:R	
T$0H
T$(H
t$ L
5P\	
5LX	
53X	
5_Q	
5#B	
=ZB	
=,B	
5NA	
5/A	
=BJ	
|$ I
5i@	
5J@	
5+@	
=K@	
=VY	
AWAVAUATUH
|$0L
5(R	
B0H+B(H
|$ H
t$0I
t$@I
|$XH
D$ t
[]A\A]A^A_
5	l	
5>w-
|$ H
5AM	
5r<	
5^L	
AWAVAUATL
5(9	
52j	
5Ej	
5,O	
E@H)
B0H+B(H
l$PE1
B0H+B(H
5|o-
|$0H
|$0H
5EM	
51M	
5GE	
[]A\A]A^A_
5AZ	
AWAVAUATUSH
5mJ	
5EJ	
T$ H
d$`A
5)G	
T$ L
d$`A
5F7	
54^	
5aC	
5?C	
5<C	
5r:	
5b:	
51]	
5<]	
52]	
5_@	
5C@	
5m@	
5l@	
5%@	
E0H+E(H
5@%	
5J2	
55;	
5[W	
x,Ic
55t	
5c1	
D$8H
D$HH
D$@H
D$PH
D$(H
|$(1
5A&	
D$Pt
B0H+B(H
T$HH
|$8H
5M#	
5[S	
5V#	
L$ L
5"W-
T$8H
|$@H
5E.	
t$@H
T$0H
|$0L
t$0L
T$8H
5(,	
5Y-	
5]-	
5|,	
[]A\A]A^A_
|$@H
ATUH
[]A\
[]A\
[]A\
[]A\
[]A\
[]A\
ATUH
[]A\
[]A\
[]A\
AVAUI
ATUH
[]A\A]A^
F(H+F H
F(H)
G H9B
G(H9B
=^'	
D$ I
D$(L
l$ L
d$(L
l$0L
t$8L
|$@H
R H9
D$(1
H;U r
H9P rI
L$(dH3
0[]A\
H9P s
D$H1
V I9
$sEH
$H9P 
T$HdH3
\$PH
l$XL
d$`H
W H9
P I9
$H9B s
\$ H
l$(L
d$0L
l$8L
t$@H
AVAUI
C t?H
[]A\A]A^
;B A
D$(1
;U r
9P rJ
L$(dH3
0[]A\
9P s
D$H1
P A;
T$HdH3
\$PH
l$XL
d$`H
W H9
$;P 
B A;
[]A\
AWAVI
AUATUH
 t	H
[]A\A]A^A_
\$(H
l$0L
d$8L
l$@L
t$HL
|$PH
A;F8A
AWAVL
ATUSH
[]A\A]A^A_
u7H)
\$(H
l$0L
d$8L
l$@L
t$HL
|$PH
AWAVAUATUH
e@dH
D$81
<$I)
d$ H
T$7H
5S(-
T$8dH3
H[]A\A]A^A_
T$0H
l$ L
d$(L
l$0L
t$8L
|$@H
u H)
D$(1
uEI)
L$(dH3
0[]A\
D$H1
T$HdH3
\$XH
l$`L
d$hL
l$pH
H9] 
AVAUATUH
D;c(v
c(H)
L9'u
H9s@
[]A\A]A^
[]A\A]A^
ATUH
[]A\
ATUH
[]A\
AWAVI
ATUH
D$81
d$ H
D$(H
D$(L
T$8dH3
H[]A\A]A^A_
H9T$
tAH9\$
AVAUATI
T$ H
l$0H
T$0H
D$8H
[]A\A]A^A_
l$pH
T$0H
t$PI
T$0H
l$@H
t$PI
T$0H
\$(H
l$0L
d$8L
l$@H
\$(H
l$0L
d$8L
l$@H
D$81
l$0H
T$8dH3
\$@H
l$HL
d$PL
l$XL
t$`H
D$81
l$0H
T$8dH3
\$@H
l$HL
d$PL
l$XL
t$`H
AWAVAUI
ATUSH
T$`dH
l$`H
D$`H
D$pH
D$pH
D$`H
D$pH
D$xH
\$PH
T$_H
l$@H
L$@H
D$ L
d$ H
D$@L
d$@A
D$`H
D$pH
D$pH
D$`H
[]A\A]A^A_
L$@H
T$^H
D$0L
d$0H
D$@L
T$@H
l$`H
AVAUATUSH
\$PH
l$PL
D$PH
D$PI
D$@H
D$XH
l$@H
T$OH
D$pH9
|$xH
t$ L
D$ L
D$PI
D$@H
l$PL
[]A\A]A^A_
|$xH
T$NH
t$0L
D$0L
l$PL
l$PL
AWAVAUI
ATUSH
T$`dH
l$`H
D$`H
D$pH
D$pH
D$`H
D$pH
D$xH
\$PH
T$_H
l$@H
L$@H
D$ L
d$ H
D$@L
d$@A
D$`H
D$pH
D$pH
D$`H
[]A\A]A^A_
L$@H
T$^H
D$0L
d$0H
D$@L
T$@H
l$`H
AVAUATUSH
\$PH
l$PL
D$PH
D$PI
D$@H
D$XH
l$@H
T$OH
D$pH9
|$xH
t$ L
D$ L
D$PI
D$@H
l$PL
[]A\A]A^A_
|$xH
T$NH
t$0L
D$0L
l$PL
l$PL
d$pL
|$0H
l$PH
l$@L
d$ L
D$81
l$ H
T$7H
T$8dH3
\$HH
l$PL
d$XL
l$`H
KPE1
l$pH
\$`H
l$PH
t$@H
l$0H
\$ L
l$PH
D$h1
T$eH
t$PH
T$gH
l$@E1
T$hdH3
\$pH
l$xL
t$0H
T$fH
l$ E1
AWAVI
AUATUH
D$x1
t$0L
t$@H
|$0H
D$<H
D$@H
D$HH
D$PH
D$8I
D$<A
D$@I
D$HI
D$PI
D$XI
D$hI
D$xdH3
[]A\A]A^A_
d$ H
L$(H
|$0H
D$ H
|$@H
T$HH
T$(H
d$HI9
L$ H
Hk|$ H
\$(H9
t/H9\$(t5H
H9T$ 
t$ H
|$PH
l$@H
l$0L
|$PH
|$pH
d$`L
D$x1
T$uH
t$ H
T$vH
T$xdH3
t$`H
T$wH
l$PE
d$@H
\$0L
D$h1
l$Pt{L
d$@H
T$gH
T$hdH3
\$xH
d$0H
l$ H
5Ic	
{PE1
\$pH
d$`H
t$PL
l$@H
\$0L
t$@H
T$ L
{PE1
d$`H
T$0H
t$@H
t$@H
D$(f
d$PH
l$@H
\$`L
5nT	
d$PH
T$0H
t$(H
T$ H
|$ H
t$ L
\$pH
D$8u
D$8u
D$8H
D$8L
D$8f
AWAVAUATUSH
|$0H
T$ L
T$(H
\$@H
|$0L
[]A\A]A^A_
T$(H
\$PH
T$pH
T$8L
t$(H
|$`H
D$0H
D$0L
D$0L
fff.
[]A\
d$ H
fffff.
fffff.
fffff.
fffff.
O@dH
H;p r
H;OPt
fff.
l$ H
AUATI
 []A\A]A^
l$ H
ATUH
[]A\
5~b	
5Jb	
[]A\
ATUH
52Z	
[]A\
fffff.
5<X	
5vS	
5GP	
5nM	
ATUH
5RD	
[]A\
fffff.
5yB	
5NA	
5[>	
d$ H
d$ H
5p9	
5%8	
5	8	
5]7	
\$ H
l$(L
d$0H
fff.
5RB	
fff.
w(dH
v8H)
SHH)
d$ L
l$(L
t$0H
[]A\A]
AUATI
t{E1
[]A\A]
5hO	
ATUH
[]A\
ffff.
55*	
5Q(	
[]A\A]
fff.
g dH
d$ H
=-y,
fffff.
g dH
d$ H
fffff.
AVAUATI
[]A\A]A^
AVAUATUH
 []A\A]A^
D$x1
T$p1
T$xdH3
T$hH
T$ H
T$(H
T$0H
T$8H
T$@H
T$HH
T$PH
T$XH
T$`H
fff.
AVAUATL
gPUH
PRB2D
k(t^A
PRB1tUA
PRB3tLH
[]A\A]A^
=!a,
5C<	
=P`,
o SH
5Uj,
[]A\
5Ij,
o SH
5Ji,
[]A\
5	i,
D$H1
=PRB2
=PRB3
=PRB1
d$ H
T$FH
D$HdH3
\$PH
l$XL
d$`L
l$hL
t$pH
l$0H
T$GH
=qY,
=AY,
5/^,
5m[,
5NY,
fff.
o SH
&v#1
AUATUSH
D$H1
F(=PRB3
=PRB2
~(PRB3
~(PRB3H
t$(I;t$0H
l$(H
D$(H
u(H;u0H
d$ H
D$ H
l$(L
T$HdH3
X[]A\A]A^A_
H;s H
d$@I
t$(I;t$0H
T$8H
D$(H
D$(L
PRB2H
H;s H
l$0I
T$(I
T$ H
T$@H
T$0H
T$8I
AVAUI
ATUSH
T$ H
D$0H
{ H+T$
H+D$8H
D$HH+D$(H
|$ H
L$0H+L$8L
L$(H
SHH)
L$HL)
T$pH
{pH+T$`H+
H+D$xH
|$pH
D$`H
L$xH
5]V,
5%V,
5&V,
5gV,
55V,
[]A\A]A^
ATUSH
5VT,
52T,
5+T,
5AS,
5}S,
5XS,
5cR,
5lR,
5 R,
5&R,
5YQ,
5RQ,
5[Q,
5TQ,
5aQ,
[]A\
u2H)
fffff.
D$(1
{PH;{0
H;{XH
{PH;{0
H;{XH
t$(I;t$0
D$(H
t$(dH34%(
\$8H
l$@L
d$HL
l$PL
t$XL
|$`H
T$'H
H+C H
AWAVI
uPI)
t$HI
|$@M
I;n r
I;n A
([]A\A]A^A_
AVAUATUSH
D$81
l$4L
T$8dH3
H[]A\A]A^A_
AWAVAUATE1
T$(H
T$8L
l$@dH
D$X1
D$0L
t$HL
|$WH
D$ f
l$HH
D$W<tt*<Tt&<Wt"H
D$ H
L$81
T$XdH3
h[]A\A]A^A_
=q=,
T$(H
T$(H
l$ L
d$(L
l$0H
=u;,
d$ L
l$(L
t$0H
5G@,
d$ L
l$(L
t$0H
d$ H
d$ H
AWAVAUI
ATUSH
[]A\A]A^A_
D$@H
T$ I
D$0H
T$(H
|$ H
|$(H
|$(H
}PI;}0
I;}XI
=R.,
|$ H
\$`H
l$hH
\$`H9
l$`H
I+E H
}PI;}0
I;}XI
t$8H
|$`H
AWAVAUATI
\$`dH
l$ H
l$ H
l$(H
D$@H
D$HH
D$PH
D$XH
t$(H
t$ H
[]A\A]A^A_
5+*,
fffff.
AWAVE
AUATI
5}0,
t$(H;t$0H
D$(H
D$(E
t$(H;t$0H
D$(H
t$(H;t$0H
D$(H
D$(E
t$(H;t$0H
D$(H
D$(H
t$ H
|$ H
[]A\A]A^A_
D$pH
l$`H
t$(H;t$0H
D$(H
5r-,
t$(H;t$0H
D$(H
D$(L
5#-,
t$(H;t$0H
D$(H
t$(H;t$0H
T$HH
T$8H
T$XH
T$PH
T$@H
|$ H
fff.
AWAVE
AUATI
5=*,
t$(H;t$0H
D$(H
D$(E
t$(H;t$0H
D$(H
5S),
t$(H;t$0H
D$(H
D$(E
t$(H;t$0H
D$(H
D$(H
t$ H
|$ H
[]A\A]A^A_
D$pH
l$`H
t$(H;t$0H
D$(H
52',
t$(H;t$0H
D$(H
D$(L
t$(H;t$0H
D$(H
5_&,
t$(H;t$0H
T$HH
T$8H
T$XH
T$PH
T$@H
|$ H
fff.
H;=7
l$ H
D$(1
H;=m
T$(dH3
fff.
AWAVI
AUATI
D$81
D$ H
t$ H
H;S r
u_H9P ruI
|$ H
H;=g
D$8dH3
H[]A\A]A^A_
H9P s
AWAVAUATUSH
|$PH
L$pH
L$8H
t$@H
D$xH
T$HH
D$ H
L$`H
L$@H
L$@H
T$PH
D$(t
L$PH
t$(H
T$0H
\$0H
H9P r
t$HH
L$HH
D$@H
L$HH
L$@H
l$xH
t$@H
H;N(
D$@L
T$@H
|$@H
\$0H
H9S w
|$0H
H9Q s
L9d$0
H9D$0I
\$(H
H9\$(H
|$ H
t$ H
|$8H
|$xH
[]A\A]A^A_
H1B(
H1A(
t$@H
D$HH
t$xH
|$xH
|$ H
AUATUH
l$ L
D$81
|$ H
D$8dH3
H[]A\A]
fffff.
AUATUH
l$ L
D$81
|$ H
D$8dH3
H[]A\A]
fffff.
l$ H
D$(1
t$ I
L$(H
d$0H
D$(dH3
\$8H
l$@L
d$HL
l$PL
t$XL
|$`H
l$0H
|$0H
t$8H
d$pH
l$PH
|$PH
t$ H
|$0H
|$PH
|$(H
AVAUATUSH
|$ H
[]A\A]A^A_
D$0I
T$0H
D$8I
T$8L
D$HH
\$@H
D$hH
D$@H
D$(H
D$(H
\$`H
D$PH
4t H
|$XH
T$(H
|$ H
D$hH
D$@H
T$HH
T$@H
T$8L
T$0L
T$HH
T$@H
T$8L
T$0L
T$HH
T$@H
T$8L
AVAUATUSH
l$ H
T$7dH
D$81
|$ L
H;B w
D$8dH3
H[]A\A]A^A_
H;F r
H;A v
L$5H
l$(A
t$6H
W4dH
D$81
D$8dH3
\$@H
l$HL
d$PH
d$ H
T$7H
T$6H
T$5H
fffff.
T$'H
D$(1
T$(dH3
\$8H
l$@L
d$HL
l$PL
t$XL
|$`H
fff.
AWAVAUATUSH
\$pH
|$pH
H;=u
l$ L
[]A\A]A^A_
t$ H
fffff.
T$0dH
L$@L
D$(L
t$(L
L$?H
T$@H
t$0E
D$>D
D$`H
L$?L
L$(E
T$@H
t$0H
D$>D
\$pH
D$0H
T$xH
T$XH
|$(I
fff.
T$'H
D$(1
T$(dH3
AWAVI
AUATUSH
,/I9
[]A\A]A^A_
H9J w
u#H9H 
nHI;nXt
l$pI
ffffff.
AWAVAUATI
t$pL
\$pH
l$`H
|$p1
\$pH
\$pH
l$`H
t$(M
t$8H
\$pH
l$`H
\$pH
\$pH
l$`H
\$pH
\$pH
\$pH
\$pH
\$pH
\$pH
l$`H
\$pH
\$pH
t$pH
\$pH
l$`H
\$pH
t$`H
\$pH
l$`H
\$pH
\$pH
\$pH
\$pH
|$`H
|$pH
H9=m
[]A\A]A^A_
\$pH
l$`H
l$`H
\$pH
|$`1
\$pH
\$pH
l$`I
D$ I
T$ L
|$PH
D$(H
t$pH
t$`H
t$PH
\$0H
l$PH
D$0H
\$pH
l$`H
\$pH
l$`H
\$pH
l$`H
\$pH
l$`H
\$@H
l$PH
D$@H
l$PI
t$`H
\$pH
T$(H
T$ H
|$hH
\$pH
fffff.
AWAVI
AUATUL
D$pH
L$ H
L$pM
t$pH
uXI)
|$@H
T$pH
](L9
[]A\A]A^A_
t$8H
t$8H
|$`H
L$`M
t$`I
|$ H
D$ H
T$XH
T$P1
D$X1
D$PH
t$XH
D$0L
T$(L
|$(H
t$PH
|$(H
T$ H
D$(H
D$0H
d$0H+
|$ H
T$`H
D$pL
T$xH)
D$0H
|$pH+
T$(H
D$0H
H;|$`
|$pH
D$0H
D$`H9
|$8H
D$0t
H9=]
[]A\A]A^A_
D$(H
|$8H
D$0t
D$(H
D$(H
D$(H
D$(tCH
D$(L
D$(H
D$(u
D$(u
D$(u
D$(H
AVAUI
ATUSH
D$81
d$ H
L$ M
H;k`
L$ M
uHL)
~3L;
T$8dH3
@[]A\A]A^
T$ H
T$ I
t$7L
fff.
fff.
T$ H
H;=;
D$(H
D$0H
d$0H+
|$ H
T$`H
D$pL
T$xH)
D$0H
|$pH+
T$(H
D$0H
H;|$`
|$pH
D$0H
D$`H9
|$8H
D$0t
[]A\A]A^A_
D$(H
|$8H
D$0t
D$(H
D$(H
D$(H
D$(tCH
D$(L
D$(H
D$(u
D$(u
D$(u
D$(H
AVAUATUH
D$X1
t$@H
T$PH
T$XdH3
`[]A\A]A^
D$0H
D$8H
D$@H
D$PH
t$@H
D$(H
D$0H
D$8H
D$@H
D$HH
fff.
D$(1
>t5H
D$(dH3
\$0H
l$8L
d$@L
l$HL
t$PH
fff.
AVAUATI
D$x1
l$`tPH
T$PL
l$`H
l$`H
|$PH
|$`H
D$@H
l$`H
l$0L
l$0H
l$0H
t$0H
t$`H
t$`H
|$0H
|$@H
|$`H
T$xdH3
[]A\A]A^A_
T$@H
l$`H
t$0H
t$`H
fff.
AWAVAUI
ATUSH
[]A\A]A^A_
D$@H
T$ H
T$0H
D$(H
T$8D
t$ H
H;D$@
T$HH
|$(H
T$0H
T$(H
|$(I
|$8L
d$@L
l$HL
t$PH
D$pH
t$hH
d$pH
H+C H
D$ H
t$`L
|$`I
|$ M
t$XI
t$(L
E@H9EH
|$8H
t$0H
D$8I
D$XI
D$pI
|$@M
l$hL
l$@I
l$ L
|$pH
t$hI
d$hI
H+C H
\$PH
AUATUH
T$PH
L$|H
D$`L
T$0dH
t$XL
|$PH
t$PL
D$|E
t$|L
H;=k
[]A\A]A^A_
L9l$`
T$0H
D$hH
|$hH
L$0H
D$`H
D$hH
T$8H
T$`H
D$8M
L$|M
t$XH
|$8H
T$PH
L$8H
|$hH
|$hH
|$hH
T$0H
L9l$`
T$`H
D$8M
L$|M
t$XH
|$8H
T$PH
L$8H
D$(H
5o|+
D$PtPH
D$PH
D$PL
D$PH
|$hH
|$8H
|$8H
|$8H
D$Pf
AUATUH
T$PH
L$|H
D$`L
T$0dH
50}+
t$XL
|$PH
t$PL
L$|E
t$|L
5({+
[]A\A]A^A_
L9l$`
T$0H
D$hH
|$hH
L$0H
D$`H
D$hH
T$8H
T$`H
D$8M
L$|M
t$XH
|$8H
T$PH
L$8H
|$hH
|$hH
|$hH
T$0H
5Nh+
L9l$`
5/p+
5go+
T$`H
D$8M
L$|M
t$XH
|$8H
T$PH
L$8H
D$(H
D$PtPH
D$PH
D$PL
D$PH
|$hH
|$8H
|$8H
|$8H
D$Pf
AWAVI
ATUSH
T$0H
L$8H
D$HH
D$@H
T$8H
t$0H
t$8H
t$ H
|$(H
t$0H
D$ M
L$8H
D$?H
t$8H
D$8I
t I;
D$8I
d$`H
t$0H
T$@H
L$(H
D$HL
D$ L
L$8H
l$XH
[]A\A]A^A_
|$(H
t$8H
d$pH
t$0H
T$@H
L$(H
D$HL
D$ L
L$8H
l$hH
L$ L
L$ H
=,U+
=]T+
fff.
d$ L
l$(L
t$0H
d$ L
l$(H
t$0H
d$ L
l$(L
t$0H
=hU+
5IU+
d$ L
l$(H
t$0H
D$(1
D$(dH3
\$0H
l$8L
d$@L
l$HL
t$PH
l$ H
fff.
AWAVAUATUH
[]A\A]A^A_
D$oI
D$nI
t$8H
|$8M9
t$pL
5AM+
d$@I
l$PI
d$`L
D$(H
T$ H
D$(H
T$ H
fffff.
D$h1
4$L+t$
T$fH
D$8N
|$@H
T$eH
|$@H
l$8H
D$PH
T$gL
t$PI
L$ H
D$hdH3
x[]A\A]A^A_
L$PM
=v>+
AVAUATUH
D$(1
t$ u,
D$(dH3
0[]A\A]A^
T$&H
T$'H
AVAUATUSH
D$?t
L$ H
|$ H
D$@H
D$HH
D$(H
L$PH
D$pH
L$XH
L$hH
|$(L
t$(L
T$0H
H9\$
H9l$
T$ H
L$?H
T$@H
H9=57+
L$ H
WPH9
[]A\A]A^A_
L$ H
t$ H
T$ H
L$HH
T$ I
t$@H
L$(H
L$ H
s(H;s0H
T$ H
L$0H
L$PH
L$ H
s(H;s0H
T$ H
D$`H
H9\$
H9l$
|$hL
T$hI
|$hH
|$PL
T$PI
|$PH
|$XL
T$XI
|$XI
t$01
H9\$
D$`I
T$0I
|$0I
H9\$
D$0L
|$pL
T$pI
|$pI
|$xL
T$xI
|$xH
L$ H
s(H;s0H
|$(H
t$ H
T$ H
t$(I;t$0M
l$ I
L$ H
D$(H
D$(H
T$ H
t$(I;t$0H
T$(H
T$(H
T$ H
|$(H
T$0H
T$ H
T$ L
T$ H
t$HL
I+G H
T$ H
I+G H
T$ L
|$XH
|$`H
|$0H
|$pH
|$xH
|$hH
|$PH
|$(H
AWAVAUI
L$(H
D$0I
T$0L
T$HH
L$@H
D$@H
L$(H
L$HH
H9D$(tYH
D$8H
t$8H
T$ H
t$8H
T$`H
|$`L
t$`I
t$`H
|$hH
t$hI
|$XL
T$XH
t$`I
T$XH
L$pI
I;v(M
T$ A
L$ H
t$pH
|$8H
t$hH
T$8I
L$XH
I;w(H
T$ L
r H;r(
L$ H
T$ H
t$`H
|$8H
|$PH
t$8H
L$8H
D$@H
L$8H
T$ H
T$ H
L$8H
H;p 
T$ H
L$ H
D$@H
T$ H
q H;q(L
D$ H
L$ H
H;p 
L$ H
D$@H
T$8H
D$ H
H;p 
L$@I
p H;p(
D$@H
L$PH
T$HM
T$HL
d$HL9d$(
|$ H
L$PH
|$hI
[]A\A]A^A_
I+E H
t$0L
t$HI
I+E H
T$PH
L$ H
|$ H
L$@H
L$ H
T$ H
L$@I
D$XM
H;p 
|$ H
|$xH
|$PH
|$pH
|$8I
|$ I
L$HH
T$0H
L$(L
|$hI
|$`I
|$`I
|$`I
|$`I
|$PI
|$XI
|$8I
AVE1
AUATUH
H;=[
t$`I
|$`H
l$@L
d$0H
l$ H
|$ H
[]A\A]A^A_
t$pH
l$PH
5		+
[]A\A]A^
[]A\A]A^
AVAUATUH
\$pH
D$`E1
\$(H
D$ H
\$XH
\$0H
|$ H
t$ H
|$`H
H;=x
}PH;}0
H;}XH
vpI;vx
D$XH
[]A\A]A^A_
T$0H
\$@H
d$HH
\$@I9
d$@M
H+E H
H+E H
|$ I
|$@H
fffff.
AWAVAUATUSH
t$`H
T$`H
D$hH)
T$`H
t$(H
D$8H
L$0H
t$HH
D$PH
|$(H
T$8H
|$0H
H;=y
H9=`
t$hH
t$hH
D$$H
H9D$
|$`H
l$hH9
|$`H
[]A\A]A^A_
|$0H
|$`H
AVAUATUSH
[]A\A]A^A_
D$pH
D$pH
H;=e
H9D$
D$xH
g M9
t$`H
t$`H
|$`H
H;=!
l$PH
l$0H
fff.
AWAVAUATUSH
[]A\A]A^A_
\$0E1
D$ H
T$8H
|$ H
H;D$
\$0H
t$(H
t$(L
t$(L
` M9
l$pH
l$PH
t$8H
fffff.
AWAVAUATUH
\$HH
,4$H
D$`H
L$HH
D$(H
D$`H
\$8H
\$@H
D$0H
D$hf
|$8I
|$(I
|$(H
T$ H
t$(H
t$@H
T$8H
d$0M
H;D$0
L$PH
D$HH
\$8H
D$(H
D$0H
\$@H
D$hH
\$pH
D$XH
\$xH
|$(H
|$0L
t$0L
T$(H
|$@L
d$`H
D$`M
|$ H
H;X v
H9D$8tkH;X reH
L$ H
D$HH
T$HH
[]A\A]A^A_
L;d$0L
|$ H
|$ H
t$@H
T$PH
|$`L
|$PI
|$ H
D$hH
D$hL
L$Xw	D
D$hH
t$XH
L$Xw
D$hH
t$XH
L$hH
D$hH
T$hH
t$pL
|$`L
T$hL
L$hL
|$xH
|$(H
|$PH
|$ H
AWAVAUATUH
t$@H
t$8H
T$(H
T$0H
t$(H
t$ H
T$(L
L$(H
T$0H
t$ L
t$HH
L$8H
L$(H
L$ H
L$@H
L$PH
t$(H
|$ H
t$ H
H;=H
H9=/
u(I;u0H
[]A\A]A^A_
u(I;u0H
|$ H
t$HI
}PH;}0
H;}XH
w(I;w0H
t$xH
T$@H
D$`H
t$0H
T$ I
|$ H
T$ H
|$HI
|$HI
|$HI
|$HI
|$HI
|$ I
|$ I
|$ H
|$ I
fffff.
AWAVM
AUATI
t$0H
T$@H
L$HH
L$8H
D$ H
=)y*
D$ L
\$`L
L$8H
T$HH
t$@M
[]A\A]A^A_
D$(I
H9\$(I
T$PI
|$PI
L9l$(L
t$0H
L$8H
T$HH
t$@M
t$(H
T$PI
|$PI
T$(H
t$(L
D$PI
D$ H
|$ M
D$ H
|$8H
D$0L
t$0H
D$0H;
L$(M
\$(f
H9\$(H
D$PL
t$(H
T$XI
|$XI
T$XI
|$XH
l$0H
|$XH
|$(H
|$PH
D$0H
|$XH
|$ H
|$PH
|$PH
D$0H
=Jj*
fffff.
AWAVAUI
ATUSH
T$0I
D$XI
T$pH
D$xH
T$PH
T$`H
D$8H
D$hH
T$ I
}(PRB1
T$0H
I;]pt_H
L$0H
|$XH
,,E1
C8H+C0I
k8H)
,,E1
CPH+CHI
kPH)
|$`H
t$PL
^ =PRB3
=PRB2
D$HH
|$hH
|$8H
T$0D
T$HH
D$xE
D$(A
T$@=PRB3
=PRB2
|$ H
D$ H
T$(H+T$@L
t$0H
5;g*
|$8H
[]A\A]A^A_
}(PRB3
={X*
=]W*
t$HH
|$(H
|$(H
|$PH
|$(H
AWAVAUATI
T$(H
t$(H
|$hH
T$(H
U@H9UH
5RS*
L$HH
t$(H
L$8H
t$8H
|$0H
t$0H
T$PH
T$XH
t$PH
|$(H
T$HH
t$(H
t$PH
t$`H
D$@I
L$(H
|$(H
t$(I
u(I;u0H
L$(H
L$8H
L$0H
L$xH
t$8H
|$(A
T$(H
|$0H
t$0H
u(I;u0H
u(I;u0H
D$(H
t$`I
|$PI;|$0
I;|$XI
D$PH
u(I;u0M
|$PI;|$0
I;|$XI
T$PH
u(I;u0H
U@H9UH
|$HH
T$xH
H9|$P
[]A\A]A^A_
57K*
T$`I
D$PH
T$PH
T$PH
T$hH
L$hH
T$XH
T$PI
t$XH
|$(H
T$0L
|$0H
T$(L
\$hH
I+D$ H
D$(H
D$PH
D$hH
T$hH
D$XI
D$PI
T$8H
T$(H
t$8H
T$0H
t$@H
t$(H
|$ H
D$hH
T$hH
D$XH
D$PI
|$pH
|$pH
L$ L
L$ H
=AB*
|$0I
|$(H
|$ H
|$0I
|$0I
|$(I
|$`I
=X=*
|$`I
d$ H
d$ H
ATUH
[]A\
l$HI
\$(H
[]A\
[]A\
ATUH
[]A\
l$ H
l$ H
[]A\
D$ I
D$(L
l$ L
d$(L
l$0L
t$8L
|$@H
R H9
D$ L
l$ L
d$(L
l$0L
t$8L
|$@H
R H9
[]A\
{PH;{0
H;{XH
Cht<H
 t>H
d$ L
l$(L
t$0H
\$(H
l$0L
d$8L
l$@H
d$ H
D$CH
\$(H
l$0L
d$8L
l$@H
H+3H
4$H)
H+3H
4$H)
\$(H
l$0L
d$8L
l$@H
\$(H
l$0L
d$8L
l$@L
t$HL
|$PH
\$(H
l$0L
d$8L
l$@L
t$HL
|$PH
\$(H
l$0L
d$8L
l$@L
t$HL
|$PH
\$(H
l$0L
d$8L
l$@L
t$HL
|$PH
T$ L
D$(1
5^+*
D$(dH3
\$8H
l$@L
d$HL
l$PL
t$XL
|$`H
C0H9CPuWH
C0H9CPuWH
C0H9CPuBH
[]A\
[]A\
C0H9CPuWH
C0H9CPuBH
C0H9CPuWH
C0H9CPuWH
C0H9CPuBH
C0H9CPuBH
d$ L
l$(L
t$0H
u H)
d$ L
l$(L
t$0H
u H)
D$(1
uEI)
L$(dH3
0[]A\
D$H1
T$HdH3
\$XH
l$`L
d$hL
l$pH
H9] 
d$ L
l$(L
t$0H
u H)
d$ L
l$(L
t$0H
u H)
D$(1
uEI)
L$(dH3
0[]A\
D$H1
T$HdH3
\$XH
l$`L
d$hL
l$pH
H9] 
d$ L
l$(L
t$0H
u H)
D$(1
uEI)
L$(dH3
0[]A\
D$H1
T$HdH3
\$XH
l$`L
d$hL
l$pH
H9] 
d$ L
l$(L
t$0H
u H)
D$(1
uEI)
L$(dH3
0[]A\
D$H1
T$HdH3
\$XH
l$`L
d$hL
l$pH
H9] 
d$ L
l$(L
t$0H
u H)
D$(1
uEI)
L$(dH3
0[]A\
D$H1
T$HdH3
\$XH
l$`L
d$hL
l$pH
H9] 
AWAVL
w@AUATI
oHdH
D$X1
|$@H
|$8L
T$HM
T$HM
uqI)
l$ H
|$8L
T$XdH3
G(uxH
h[]A\A]A^A_
T$0H
|$8L
AWAVAUI
ATUSH
[]A\A]A^A_
AWAVAUI
ATUSH
[]A\A]A^A_
AWAVAUATI
[]A\A]A^A_
AWAVAUATI
[]A\A]A^A_
C0H9CPuUH
C0H9CPuBH
AWAVAUATI
[]A\A]A^A_
AWAVAUATI
[]A\A]A^A_
AWAVAUATI
[]A\A]A^A_
AVAUATUSH
([]A\A]A^A_
AWAVAUATUH
H;=I
[]A\A]A^A_
AVAUATI
D$81
l$ H
D$7H
|$ H
I9D$
D$8dH3
H[]A\A]A^A_
AWAVI
AUATUSH
D$(1
fffffff
D$'A
T$(dH3
8[]A\A]A^A_
H;T$
(H9T$
H;l$
wXdH
H;=	
l$ H
AVAUI
ATUH
D$h1
t$ H
D$:H
D$@H
D$HH
D$PH
D$X~qf
D$8I
D$9A
D$:A
D$@I
D$HI
D$PI
D$XI
D$hdH3
x[]A\A]A^A_
$tiH
D$ H
D$(H
D$0H
D$8H
D$@H
d$@I9
H9T$
H9\$
AWAVAUATI
[]A\A]A^A_
AWAVAUL
_ dH
\$ I
\$(I
\$PI
t$HI
\$PI
\$XI
[]A\A]A^A_
|$hH
|$HH
|$0H
[]A\
|$HH
|$0H
AUATUH
[]A\A]
AWAVAUL
D$(1
D$'L
H)D$
T$(dH3
8[]A\A]A^A_
|$hH
|$HH
|$0H
[]A\
|$HH
|$0H
AVAUATUH
D$H1
H;O(
YK$L
d$0H
|$0H
H;=W
d$(M
<$H9G
T$(H
D$(L
L$HdH3
D$ H
P[]A\A]A^
H1C(
H1C(
t$GH
AWAVI
ATUH
d$ H
D$0H
D$8H
D$@H
D$HH
D$PH
D$XH
D$`H
D$pH
D$(H
|$ I
D$0H
H;=_
D$8I
D$@I
D$HI
D$PI
D$XI
D$`I
D$hI
D$pA
[]A\A]A^A_
D$ H
D$(H
D$0H
D$8H
D$@H
D$PH
L$XH
d$XI9
Hk|$
H9L$
t*H9\$
d$ H
d$ H
AWAVI
ATUH
D$h1
d$ H
D$0H
D$8H
D$@H
D$HH
D$PH
D$XH
D$(H
|$ I
D$0H
D$8I
D$@I
D$HI
D$PI
D$XI
D$hdH3
x[]A\A]A^A_
D$ H
D$(H
D$0H
D$8H
D$@H
d$@I9
D$fA
t*H9\$
H9D$
AWAVI
AUATUSH
D$pH
D$@H
D$pH
t$hH
D$@H
D$pI
[]A\A]A^A_
wXdH
AWAVAUATUSH
T$pH
t$ dH
d$pH
D$pH
D$(I
T$(H
D$pH
t$ H
\$`H
T$oH
|$`H
l$PH
L$PH
D$0L
d$0H
D$PL
d$PA
|$PH
D$pH
D$pH
[]A\A]A^A_
L$PH
T$mH
D$@L
d$@H
D$PL
T$PH
D$ H
D$ H
D$pH
D$ H
D$ H
T$(H
d$pH
D$ H
d$pH
AUATUH
[]A\A]
fff.
l$ L
d$(L
l$0L
t$8L
|$@H
l$ H
d$(L
l$0H
ffffff.
l$ L
d$(L
l$0H
AWAVAUATUSH
l$PH
d$@H
t$0H
l$ L
[]A\A]A^A_
l$pH
d$`H
l$`H
d$pI
D$x1
l$PL
\$@H
d$ H
\$0H
T$xdH3
fffff.
D$X1
|$@H
T$VH
d$ H
T$WH
t$0H
t$@H
T$XdH3
\$hH
l$pL
d$xL
D$CH
fffff.
AWAVI
AUATI
[]A\A]A^A_
t$ H
t$ H
T$8H
|$8H
|$(H
|$(H
|$(H
t$ H
T$0H
|$0H
T$ H
\$pL
FPH)
d$PH
l$`H
\$@1
D$@H
|$(H
D$@H
|$(H
|$(I
|$(H
|$(H
|$(H
|$(H
|$(I
|$0I
AVAUATUSH
t$8H
T$XH
|$XH
t$PH
D$0H
|$@H
t$HH
|$HH
B H)
L$0L
T$(H
t$0H
L$(H
d$ H
F H)
|$PH
t$0H
D$ H
[]A\A]A^A_
T$ H
T$8L
APH)
FPH)
|$pL
t$8H
l$`L
T$8H
|$ H
|$HH
|$@H
|$PH
|$XH
AWAVI
5uk)
ATUSH
|$ dH
T$XH
|$XH
t$ H
T$XH
D$ A
[]A\A]A^A_
t$PH
T$XL
t$PH
T$hH
|$hH
|$@H
|$@H
T$XH
|$@H
|$@H
t$PH
T$XH
|$HH
T$ L
T$PH
t$ L
|$0H
D$ H
@PH)
D$8H
L$(H
L$pH
D$(H
T$(D
T$8H
@PH)
|$0H
t$0H
|$0A
-*Z)
|$HH
|$HH
|$HI
|$HH
|$@H
|$@H
|$@I
|$@H
|$@H
|$@H
|$@I
|$HH
|$HH
|$HI
|$0I
|$0I
|$0I
|$HH
|$`I
|$@H
\$ H
l$(L
d$0L
l$8L
t$@H
AVAUATA
T$81
tzE1
L;c(sWH
L;c(r
D$,1
D;cXr
L$,L
D$8dH3
[]A\A]A^A_L
?AVAUI
ATUH
D$81
C8Ic
L$7H
HcM8H
D$7H
D$,H
T$8dH3
H[]A\A]A^A_
D$ H
D$(1
$t-H
T$(dH3
t$ H
fffff.
\$ H
l$(L
d$0L
l$8L
t$@H
D$81
t$0H
T$8dH3
D$0uTH
\$@H
l$HL
d$PH
J<dH
E;J8u
H;G 
U0Hc
l$ L
d$(L
l$0H
D$(1
D$(dH3
\$8H
l$@L
d$HL
l$PL
t$XL
|$`H
D$(1
T$(dH3
\$8H
l$@L
d$HL
l$PL
t$XL
|$`H
H;X0s
T$8H
D$0H
T$HH
T$HH
fff.
AVAUI
H;C 
[]A\A]A^
T$7H
D$81
T$8dH3
D$7u
\$@H
l$HL
d$PH
ffffff.
AVAUATI
|$ H
t$,dH
D$x1
t$pL
C0I9
C0L9
|$ L
|$ 1
T$xdH3
[]A\A]A^A_
|$ L
\$0L
t$pL
fff.
D$81
D$8dL3
H[]A\A]A^A_
u.piecesI
_~IH
ffffff.
D$(1
t$ H
T$ L
D$(dH3
\$8H
l$@L
d$HL
l$PL
t$XL
|$`H
ffff.
D$h1
L$ H
D$hdL3
x[]A\A]A^A_
L$ H
u.piecesH
D$H.p
D$@E
l$8D
t$4E1
|$(M
L$4M
_~IH
l$8L
L$ C
l$(E
l$(L
L$ L
D$(1
t$ H
T$ A
D$(dH3
\$0H
l$8L
d$@L
l$HL
t$PH
l$ L
d$(L
l$0H
L$@D
D$x1
t$pH
t$hH
D$hH
L$pH
T$pL
L$XH
D$XC
D$`H
T$pM
D$xdH3
T$hH
L$@D
D$x1
t$pH
t$hH
D$hH
L$pH
T$pA
D$xdH3
T$pL
L$XH
D$XC
D$`H
AWAVAUATUSL
D$ H
[]A\A]A^A_
t$(A
D$HL
H;p vG
D$`H
T$XL
D$hL
L$pL
D$`L
T$xL
L$pL
D$hH
T$XH
LcY0D
D$`H
T$XL
D$hL
L$pL
D$`L
T$xL
L$pL
D$hH
T$XL
x0Lc
D$HA
H;S v
Hcp0
D$H1
D$\1
ffffff.
D$HH
\$XL
D$`H
\$PdL
D$hH
D$XD
L$HH
t$`H
|$PH
L$xH
T$@H
L$8D
D$(L
L$0D
D$(H
L$8H
L$PH
D$xH
L$xL
D$(L
L$HH
fffff.
AVAUATUH
D$pH
T$xL
D$pL
T$xH
[]A\A]A^A_
D$pL
T$x1
u H)
T$`D
T$`I
\$HI
D$xI)
T$0H
T$hL
t$ L
T$(H
T$pH
T$hu
[]A\A]A^A_
u H)
u H)
u H)
u H)
u H)
u H)
u H)
M H)
M H)
u H)
u H)
u H)
u H)
M H)
u H)
u H)
u H)
u H)
u H)
u H)
u H)
u H)
T$`L
D$PL
T$hD
\$HL
T$hL
T$`L
D$PD
\$HL
T$`H
L$hL
D$PD
\$HL
D$PH
T$`L
D$PD
\$HL
T$`L
D$PD
\$HL
L$hL
D$PD
\$HL
T$`L
D$PD
\$HL
T$`L
D$PD
\$HL
T$`L
D$PD
\$HL
D$XL
D$PD
\$HL
D$XL
D$PD
\$HL
T$`L
D$PD
\$HL
T$`L
D$PD
\$HL
D$XL
D$PD
\$HL
T$`L
D$PD
\$HL
T$`L
D$PD
\$HL
T$`L
D$PD
\$HL
T$`L
D$PD
\$HL
T$`L
D$PD
\$HL
L$hL
D$PD
\$HL
T$`L
D$PD
\$HL
T$`L
D$PD
\$HL
T$`L
D$PD
\$HL
T$`L
D$PD
\$HL
B0H9
B0H9
I;R0
I)R0
T$hD
T$hD
\$HI
fff.
fffff.
fffff.
AVAUATUH
mpSH
d$pH
|$pL
t$`L
|$`H
t$PL
|$PH
t$@L
|$@H
t$0L
|$0H
l$ H
|$ H
[]A\A]A^
fff.
AVAUATUSH
|$ H
t$ H
l$`L
d$P1
D$pH
T$(H
D$0H
|$PH
|$`H
|$pH
D9t$
[]A\A]A^A_
t$@H
|$@H
AWAVAUATUSH
l$pH
|$ H
t$8dH
T$pH
D$(H
T$(H
D$pH
D$pH
D$xH
D$0H
|$ 1
|$ L
D$pA
D$pH
D$ H
T$0H
T$nH
d$PH
\$`H
D$PL
|$PH
H;=v
|$8H
|$`H
H;=S
H9=/
D$pH
T$(H
D$pH
[]A\A]A^A_
d$@H
\$`H
D$@L
|$@H
H;=P
\$`H
D$xuSH
T$(H
D$pH
AWAVAUATI
C H)
CPH)
D$pH
|$`H
|$`H
|$pH
D$PH
|$@H
D$0L
t$ H
|$ H
|$0H
|$@H
|$PH
[]A\A]A^A_
AVAUATUSH
CPH)
t$pH
l$`L
D$pH
l$`L
D$0H
L$ H
|$ H
|$0H
L$PL
D$@H
|$@H
|$PH
|$`H
|$pH
[]A\A]A^A_
|$`H
|$pH
fff.
AVAUATUH
T$PdH
t$@H
l$0L
D$@H
l$0L
l$ H
|$ H
|$0H
|$@H
[]A\A]A^A_
T$OH
CPH)
AWAVI
AUATUH
|$@dH
CPH)
l$0L
d$ L
D$0H
d$ L
T$?H
|$ H
|$0H
[]A\A]A^A_
AWAVAUATUSH
D$81
l$ A
t$,A!
t$ A!
t$(A!
t$$A!
t$(A1
t$$1
D$8dH3
H[]A\A]A^A_
AWAVAUATA
?~_H
D$PL
[]A\A]A^A_
D$PL
t$@H
D$X1
D$XdH3
fff.
l$ L
d$(L
l$0L
t$8L
|$@H
l$ L
d$(L
l$0L
t$8L
|$@H
D$(1
D$(dH3
\$0H
l$8L
d$@H
DT$xH
T$ H
DT$xH
DT$xH
T$ H
DT$xH
AVAUATUSH
|$(H
T$ dH
[]A\A]A^A_
t$ H
|$HH
|$HH
|$0H
T$(H
L$(H
t$ H
|$@H
T$`H
T$81
H;D$`
T$hH
H;P8|
u_H9P8|yL
|$0H
|$0H
|$0H
H9P8}
|$8H
t$ H
|$@H
L$8H
L$PH
H;D$`
T$hH
H;P8|
H9P8|9L
H9P8}
|$8H
t$ H
|$@H
L$8H
L$ H
H;D$`
T$hH
H;P8|
H9P8|9L
H9P8}
|$8L
L+c0
H;D$
L$(H
|$0H
|$0H
|$0H
|$0H
|$@H
|$HH
|$0H
|$0H
|$0H
AWAVAUL
l$pdH
|$pH
d$PL
l$@L
t$`L
|$@H
|$PH
d$0L
T$0H
|$01
|$`H
[]A\A]A^A_
|$01
|$0H
|$(H
D$ H
D$(H
|$01
AWAVAUATUSH
l$`dH
D$pL
|$`L
t$pH
l$@L
d$0L
|$PL
|$0H
|$@H
|$PH
t$PH
t$PH
t$pH
|$pH
[]A\A]A^A_
d$ H
T$ H
t$ H
t$ H
t$ H
|$ H
|$PH
|$pH
d$ L
l$(L
t$0H
R8H9Q
AWAVAUATI
[]A\A]A^A_
ffff.
DD$0H
\$ H
l$(L
d$0H
AWAVAUI
ATUH
D$h1
T$gI
D$PH
D$@H
T$fH
t$P1
T$eH
t$0H
|$0H
t$PI
d$ H
|$ H
|$@H
|$PH
T$hdH3
x[]A\A]A^A_
AWAVAUATUSH
|$@I
D$@1
l$0H
T$OH
\$ H
|$@H
|$ H
|$0H
T$@H
~zHc
|$@H
[]A\A]A^A_
=s}(
ffff.
T$?H
\$0L
t$0H
t$ L
%Z|(
|$ H
|$ H
|$0H
%A{(
fffff.
ATUH
D$81
D$ H
D$CH
T$8dH3
@[]A\
D$CH
AWAVAUATI
D$(1
D$'L
I;|$
H;=@u(
D$(dH3
8[]A\A]A^A_
=Nt(
AWAVAUATUH
-%t(
[]A\A]A^A_
l$PH
|$PH
D$0H
D$0H
T$0L
\$0H;\$8
t$`L
|$pH
T$ H
|$pH
H;\$8
|$`H
=qp(
=?p(
=%|(
ffff.
=9t(
AWAVI
AUATUSH
|$(H
D$ H
T$ H
D$@H
l$PH
t$@L
l$PH
D$@L
|$@H
t$PH
|$(H
L$tH
T$`L
L$hL
|$PH
t$hL
l$tH
D$@H
T$ H
[]A\A]A^A_
t$0L
l$PH
D$0L
|$0H
=~i(
l$PH
l$PI
T$ H
fff.
AWAVAUATUSH
l$`H
|$(dH
d$`L
D$`H
D$`I
D$hI
t$ H
t$$H
t$ H
T$_H
T$@H
\$PH
D$@H
|$@H
t$PH
|$PH
D$`I
d$`L
[]A\A]A^A_
D$0H
\$PH
D$0H
|$0H
\$PH
=`b(
=3b(
d$`L
AWAVAUATUH
\$`H
|$(dH
d$`L
D$`H
-oc(
D$`I
5a`(
D$hI
t$ H
t$$H
T$_H
D$@H
l$PH
D$@H
|$@H
t$PH
|$PH
D$`I
d$`L
[]A\A]A^A_
T$0H
l$PH
D$0H
|$0H
=y](
l$PH
=2](
d$`L
AVAUATUSH
D$x1
t$@H
T$ H
T$wH
T$(H
T$vH
T$0H
T$uH
|$ L
l$XL
T$LH
|$`H
|$XH
|$@H
D$xdH3
[]A\A]A^A_
=vZ(
=IZ(
= Z(
AVAUATUSH
D$x1
t$@H
T$ H
T$wH
T$(H
T$vH
T$0H
T$uH
|$ L
l$XL
T$LH
|$`H
|$XH
|$@H
D$xdH3
[]A\A]A^A_
=&X(
AVAUATUSH
D$x1
t$@H
-_W(
T$ H
T$wH
T$(H
T$vH
T$0H
T$uH
|$ L
l$XL
T$LH
|$`H
|$XH
|$@H
D$xdH3
[]A\A]A^A_
AUATUSH
D$h1
l$0H
D$gH
D$fH
D$ H
D$eH
d$HL
d$PH
|$PH
|$HH
|$0H
D$hdH3
x[]A\A]A^A_
ffffff.
AWAVAUATUSH
|$PH
D$HH
T$,H
T$8H
D$ f
\$XH
D$hH
D$pH
|$pH
|$hH
|$PH
=mP(
=@P(
|$pH
|$hH
|$PH
=xO(
=OO(
=*O(
[]A\A]A^A_
ffff.
AWAVAUATUSH
|$`H
T$DH
T$8H
H9T$8
L$8H
T$8H
T$ H
T$HH
D$0f.
\$hH
D$xH
|$xH
|$`H
D$(H)
T$8H
Q8H)
L$(H
D$0H
T$8f.
\$hH
T$ H
l$lH
D$xH
|$xH
|$`H
T$ A
Q8H)
IPH)
L$(H
D$0H
\$hH
L$ H
l$lH
D$xH
|$xH
|$`H
T$ H
IPH)
=YH(
=0H(
|$xH
|$`H
=eG(
=@G(
[]A\A]A^A_
=TF(
|$xH
|$`H
=8E(
|$xH
|$`H
=ED(
AVAUATUSH
D$H1
\$(H
D$$H
H9D$
t$(H
t$8H
\$0H
\$0A
t$8H
A8H)
A8H)
APH)
@PH)
|$0H
|$0H
\$8H
|$0H
|$0A
\$8H
D$HdH3
X[]A\A]A^A_
AWAVI
AUATUSH
|$(H
D$ H
T$ H
%q9(
D$@H
|$PH
t$@L
l$PH
D$@L
|$@H
H;=g5(
t$PH
|$(H
L$tH
T$`L
L$hL
|$PH
H;=.5(
t$hL
l$tH
D$@H
H9=H4(
T$ H
[]A\A]A^A_
t$0L
l$PH
D$0L
|$0H
H;=p3(
l$PH
=X2(
=&2(
l$PI
T$ H
o`ATUSH
d$0dH
D$X1
l$ L
l$@H
|$ H
|$0H
|$@H
=;6(
|$HH
T$WH
T$VH
|$HH
|$HH
|$HH
|$HH
|$HH
|$HH
|$HH
|$HH
|$HH
|$@H
D$XdH3
`[]A\A]A^
=R.(
=%.(
l$ H
=r,(
=K,(
=),(
ffff.
D$(1
D$(dH3
\$8H
l$@L
d$HL
l$PH
=,*(
D$(1
D$(dH3
\$8H
l$@L
d$HL
l$PH
%_)(
=O((
ffff.
D$H1
Bv-1
T$HdH3
\$PH
l$XL
d$`H
AWAVI
AUATUSH
\$@H
l$@L
D$@H
%@&(
D$@I
D$@H
D$HH
t$pM
D$`H9
|$hH
|$ L
D$ L
|$ H
=Q"(
T$?H
D$@I
D$@H
H;=;"(
l$@L
[]A\A]A^A_
|$hH
T$>H
|$0L
D$0L
|$0H
H;=u!(
l$@L
AWAVAUATUSH
\$`H
t$ dH
l$`L
D$`H
%."(
D$`I
D$@H
D$hL
|$PH
T$_H
T$@L
|$PH
D$@H
|$@H
|$ L
|$PH
D$`I
D$@H
l$`L
[]A\A]A^A_
D$0L
|$PH
D$0L
|$0H
|$PH
|$(I
l$`L
ATUSH
5v((
54((
5L'(
[]A\
ffffff.
5a&(
=N&(
5;&(
=%&(
fffff.
AVAUATI
[]A\A]A^
[]A\A]
AWAVAUATUH
D$0H
D$HH
t$@H
T$(H
T$`H
T$ H
t$@H
9N }
H;t$
;N }
T$ H
L$`H
t$@H
[]A\A]A^A_
t$@H
AVAUATI
I+l$
[]A\A]A^H
[]A\A]A^
fffff.
l$ L
d$(L
l$ L
d$(L
l$0H
ATUH
[]A\
D$ I
D$(L
l$ L
d$(L
l$0L
t$8L
|$@H
;B @
D$(1
9P |J
L$(dH3
0[]A\
9P }
D$H1
P A;
T$HdH3
\$PH
l$XL
d$`H
W H9
$;P 
B A;
\$(H
l$0L
d$8L
l$@L
t$HL
|$PH
D$(1
t$ E
D$(dH3
\$8H
l$@L
d$HL
l$PL
t$XL
|$`H
T$ H
T$ H
T$ H
l$ L
d$(L
l$0H
H;={
H;=d
|$PH;|$0
H;|$XH
D$PM
D$0H9D$P
D$hH
T$hH
D$XH
D$PH
fff.
H;=$
|$PH;|$0
H;|$XH
D$PM
D$0H9D$P
D$hH
T$hH
D$XH
D$PH
fff.
AWAVAUATUH
|$XI
|$@H
t$HH
|$HH
t$hH
|$hH
t$(H
|$(H
t$8H
T$(H
T$pH
T$xH
T$hH
t$`H
t$pH
T$XH
t$`H
t$PH
T$@H
T$HH
T$0H
t$ H
t$@H
t$ H
t$8H
|$8H
t$8L
t$0H
T$ H
T$(H
t$ H
[]A\A]A^A_
T$ L
|$ I
r(H;r0
v{L)
|$ H
AVAUATUSL
T$PH
t$HH
u*H)
L$0M
T$XH
H;=1
T$08T$ 
l$pL
L$ H
T$PH
t$HH
\$hH
|$pH
H;=4
[]A\A]A^A_
~xAVI
AUATL
g(UL
O0dH
D$x1
d$@H
l$0L
|$0H
|$@H
h(u<I
D$xdH3
[]A\A]A^A_
d$`H
l$PL
|$PH
|$`H
d$ L
t$wH
D$@H
D$`H
T$ H
t$(H
|$pH
t$PH
l$0H
|$0H
|$PH
|$pH
|$`H
|$@H
fffff.
AWAVAUATUSH
|$@H
[]A\A]A^A_
D$@H
T$@H
T$(H9
D$HH
T$0H
L$ H
D$8H
T$XH
T$ H
|$0H
|$8H
T$(H
l$`H
\$pH
|$pH
|$`H
|$8I
|$0I
fffff.
AUATUH
gHdH
[]A\A]
[]A\A]
l$PH
T$pH
{ H+T$`H+
H+D$xH
|$pH
D$`H
L$xH
SHH)
T$ H
D$0H
{pH+T$
H+D$8H
D$HH+D$(H
|$ H
L$0H+L$8L
L$(H
L$HL)
[]A\A]A^A_
d$ L
l$(L
t$0H
u H)
D$(1
uEI)
L$(dH3
0[]A\
D$H1
T$HdH3
\$XH
l$`L
d$hL
l$pH
H9] 
AWAVAUATI
[]A\A]A^A_
w0dH
w0dH
C0H9CPujH
C0H9CPurH
ATUSH
[]A\
[]A\
d$ H
d$ H
d$ H
d$ H
ATUH
[]A\
[]A\
fffff.
AUATUH
[]A\A]
[]A\A]
AVAUATUSH
l$pH
|$pH
t$PH
l$`H
|$`H
|$PH
l$@H
|$@H
t$ H
l$0H
|$0H
|$ H
[]A\A]A^
=j~'
=:~'
=z}'
=J}'
=Z|'
=*|'
=j{'
=:{'
=zz'
=Jz'
AWAVAUATUSH
d$@dH
-Cz'
l$@H
D$@H
D$PH
D$PH
|$PH
D$@H
D$PH
D$XH
\$ H
T$?H
|$ H
T$0I
D$0H
|$0H
H;=Mr'
|$`H
D$@H
D$PH
|$PH
|$hH
D$PH
D$@H
[]A\A]A^A_
l$@H
AWAVAUI
ATUSH
D$81
T$7H
t$hH
|$ H
D$8dH3
H[]A\A]A^A_
=~j'
=Uj'
D$81
H=?B
x	L9
T$6H
5"m'
T$5H
5yl'
d$ H
T$7H
|$ H
D$8dH3
\$HH
l$PL
d$XL
l$`H
=Zg'
=-g'
fff.
D$81
H=?B
x	L9
T$6H
T$5H
d$ H
T$7H
|$ H
5Yh'
D$8dH3
\$HH
l$PL
d$XL
l$`H
fff.
AWAVAUATI
t&I;
[]A\A]A^A_
|$hH
T$0H
T$8H
t$(L
t$`H
d$@H
D$pH
=_Y'
=VW'
D$PH
AWAVAUATUH
D$X1
D$UL
t$@1
t$@H
|$@H
H;=mT'
T$VH
l$0H
T$WH
|$0H
-0P'
|$ H
D$XdH3
h[]A\A]A^A_
fffff.
AWAVAUATUH
D$X1
D$UL
t$@1
t$@H
|$@H
H;=}L'
T$VH
l$0H
T$WH
|$0H
|$ H
D$XdH3
h[]A\A]A^A_
=qH'
=HH'
\$(H
l$0L
d$8L
l$@L
t$HL
|$PH
\$(H
l$0L
d$8L
l$@L
t$HL
|$PH
\$(H
l$0L
d$8L
l$@L
t$HL
|$PH
d$ H
|$ H
D$pH
|$`H
l$PL
t$@H
d$0L
%76'
|$0H
|$@H
|$PH
|$`H
|$pH
5\9'
=w4'
=G4'
=I?'
fff.
AWAVAUM
T$@H
D$PL
T$XH)
=)1'
}pH+
|$`H;|$@
H;|$hH
D$`M
D$@H9D$`
[]A\A]A^A_
D$xH
T$xH
D$hH
D$`H
D$(1
T$&H
T$'H
D$(dH3
\$8H
l$@L
d$HL
l$PH
AWAVAUM
T$@H
D$PL
T$XH)
}pH+
|$`H;|$@
H;|$hH
D$`M
D$@H9D$`
[]A\A]A^A_
D$xH
T$xH
D$hH
D$`H
AVAUATUSH
D$ H
T$0H
t$8H
|$8H
t$8H
T$(H
T$0H
t$(H
T$ H
t$HH
t$pL
t$pL
T$`L
|$`H
|$pH
t$@H
t$@H
[]A\A]A^A_
t$PH
v`L)
C0H9CPuBH
C0H9CPuWH
d$PH
T$wH
D$x1
|$`H
|$PH
d$@H
T$vH
|$@H
t$0L
|$0H
|$`H
D$xdH3
T$(H
I+l$
[]A\
[]A\
ATUH
[]A\
[]A\
AWAVAUATI
[]A\A]A^A_
fffff.
w(dH
v8H)
SHH)
d$ L
l$(L
t$0H
AWAVAUI
ATUSH
tu<%u
<SvV
([]A\A]A^A_
LtOH
D$@H
D$`H
t$pH
l$PH
d$0H
T$(H
AWAVAUATUSH
|$(H
T$ 1
D$ 1
T$ 1
L$ 1
T$ H
T$(H
L$0H
T$hH
L$HH
D$ 1
L$(H
T$@H
D$0H
T$0D
D$ H
H;=>
T$(H
L$@H
D$0H
T$0D
D$ H
T$(H
L$@H
|$HH
D$pH
L$8I
T$XH
D$xI
D$0H
t$`H
|$hH
L$0H
|$HH
L$8H
L$ H
T$(H
L$@H
D$ H
T$ H
\$TH
T$ 1
L$ 1
D$ 1
L$ L
D$ 1
T$ 1
L$ 1
D$ 1
T$ 1
L$ 1
[]A\A]A^A_
T$pH
T$xL
L$8H
T$XL
L$pH
L$8H
fffff.
|$`H;|$@
H;|$hH
D$`M
D$@H9D$`
[]A\A]A^A_
D$xH
T$xH
D$hH
D$`H
|$`H;|$@
H;|$hH
D$`M
D$@H9D$`
[]A\A]A^A_
D$xH
T$xH
D$hH
D$`H
AWAVAUATU1
D$H1
D$@H
l$ L
|$0H
D$GH
D$FH
t$0H
|$0H
|$ L
t$0H
t$0H
D$HdH3
X[]A\A]A^A_
AVAUATUSH
D$h1
D$`L
l$@1
D$PH
D$fH
D$ H
D$dH
D$(H
|$@L
l$0H
T$gH
|$0H
t$PH
|$PH
t$PH
D$hdH3
x[]A\A]A^A_
AWAVAUATUSH
D$X1
D$@L
l$0L
|$P1
D$VH
D$TH
|$0L
l$ H
T$WH
|$ H
t$@H
|$@H
D$XdH3
h[]A\A]A^A_
fff.
AVAUATUH
T$PH
[]A\A]A^A_
D$XH
T$ H
D$@H
T$(H
D$`H
T$hH
D$0H
T$HH
D$8H
T$pH
upI;ux
H9D$
t$@H
|$ A
T$ H
|$(H
t$(H
t$HH
T$0H
|$8H
t$8H
}PH;}0
H;}XH
upI;ux
|$XH
H+E H
|$(I
|$8I
t$pH
|$p1
d$`H
|$`H
l$@H
T$}H
|$@H
H;=9
|$0I
l$ H
U`Mc
EPH9
d$PH
T$~H
|$PH
T$|H
H+E H
fffff.
D$H1
d$ H
|$ L
D$HdH3
\$XH
l$`L
d$hL
l$pH
d$0H
T$GH
|$0H
T$FH
fffff.
AVAUI
ATUL
L$ H
D$8H
L$ L
H;=m
H9=T
[]A\A]A^A_
T$(L
D$`H
|$`H
L$@H
D$HH
L$(H
D$PH
L$XH
D$pH
D$hH
L$xH
t$@L
t$HH
|$(H
|$(H
t$@H
t$(H
t$hH
L$xH
t$`H
t$@H
t$(H
t$PH
t$pH
L$XH
|$(H
|$xH
|$hH
|$XH
|$PH
|$XH
|$xH
|$`H
w dH
w dH
l$PH
T$pH
{ H+T$`H+
H+D$xH
|$pH
D$`H
L$xH
SHH)
T$ H
D$0H
{pH+T$
H+D$8H
D$HH+D$(H
|$ H
L$0H+L$8L
L$(H
L$HL)
[]A\A]A^
d$ H
D$CH
\$(H
l$0L
d$8L
l$@L
t$HL
|$PH
\$(H
l$0L
d$8L
l$@L
t$HL
|$PH
C0H9CPuqH
C0H9CPueH
l$ H
l$@dH
d$ L
l$(L
t$0H
l$@dH
d$ L
l$(L
t$0H
ATUH
D$X1
u0I;u8
D$XdH3
h[]A\A]
H9H }
H9N ~@H
s0H;s8
l$0L
|$8I
|$0H
|$8H
|$0H
H;=*
fffff.
l$ H
AUATUH
H;=_
([]A\A]
ATUH
[]A\H
[]A\
AVAUATUH
D$(1
T$&H
T$'H
e(M9
eXM9
D$(dH3
0[]A\A]A^
ATUH
[]A\
\$(H
l$0L
d$8L
l$@L
t$HL
|$PH
R H9
D$(1
H;U |
H9P |I
L$(dH3
0[]A\
H9P }
D$H1
V I9
$}EH
$H9P 
T$HdH3
\$PH
l$XL
d$`H
W H9
P I9
$H9B }
\$(H
l$0L
d$8L
l$@L
t$HL
|$PH
AUATM
l$PH
L$ dH
D$h1
T$HH
d$@L
|$@H
D$(I
L$PM
L$PM
L$ H
D$HH
d$8t
|$PH
D$hdH3
x[]A\A]A^A_
|$(L
T$8H
\$(H
l$0L
d$8L
l$@L
t$HL
|$PH
u H)
D$(1
uEI)
L$(dH3
0[]A\
D$H1
T$HdH3
\$XH
l$`L
d$hL
l$pH
H9] 
-@r&
=^q&
=4q&
-0q&
=Vp&
=/p&
AWAVAUATI
[]A\A]A^A_
=Vo&
w`dH
w`dH
= {&
=Ps&
-rq&
=qz&
5ez&
=Oz&
5Cz&
=-z&
5!z&
w(dH
v8H)
SHH)
d$ L
l$(L
t$0H
ATUSH
D$81
5Vw&
H;t$
H;t$
H;t$
<$H)
5ev&
5=v&
5wu&
D$8dH3
@[]A\
T$0H
T$(H
T$ H
ATUSH
d$ H
|$pH;|$P
H;|$xH
D$pH
5up&
5/p&
|$pH
D$ H
D$PH9D$p
|$(H
D$ t
[]A\A]A^A_
5wn&
5gm&
5Gl&
D$xH
D$pH
ATUSH
d$ H
|$pH;|$P
H;|$xH
D$pH
5ce&
5=d&
|$pH
D$ H
D$PH9D$p
|$(H
D$ t
[]A\A]A^A_
5wb&
5]a&
D$xH
D$pH
AVAUATUH
D$ I
D$`H
D$ A
D$hA
D$hH
|$`H
D$8H
D$PH
D$0H
D$@H
D$XH
D$HH
D$pH
D$xD
|$,H
t$PH
|$8A
T$8H
|$0H
t$0H
t$XH
D$ H
T$@H
|$HH
t$HH
t$,H
s(H;s0H
t$pI;t$xH
D$pH
5ZN&
|$`H
|$(H
[]A\A]A^A_
T$xH
T$pH
5WJ&
I+G H
s(H;s0H
=~D&
=ND&
|$HI
|$0I
AVAUATI
L$0H
T$ H
D$@I
5o@&
L$(H
T$HH
t$8H
D$8H
T$XH
H9D$
L$ H
|$ H
t$(H
|$(H
T$ H
t$(H
T$0H
|$0L
H9=r<&
t$0I
L$(L
t$(H
t$0I
L$(I
I;u(M
t$0L
|$ L
L$8I
D$ M
H;p 
H;p 
D$8H
T$`I
D$PM
t$ H
T$PH
T$PI
T$XM
T$XL
l$XL9l$
D$ H
H9=u7&
D$HI
T$(H
L$@H
t$ H
D$0H
T$pH
D$pH
|$pH
=r6&
D$`I
L$PH
D$HH
T$0H
L$(H
D$ I
D$PH
t$@H
D$PH
T$HH
L$(H
t$@H
T$ H
L$0L
[]A\A]A^A_
L$hH
I+D$ H
D$(H
D$PH
D$HH
L$(H
t$@H
D$ H
T$0H
D$hH
T$hH
D$XI
D$PI
T$`H
t$`H
t$PL
t$XI
l$hL
I+D$ H
D$(H
D$PH
T$ H
D$hH
T$hH
D$XI
D$PI
t$8I
L$(H
D$(I
t$@I
p8H;p@
D$8I
T$(M
H;p 
t$hH
L$0H
=|+&
=:+&
|$(H
=+)&
|$ H
l$`H
d$PdH
D$x1
T$wH
|$PL
%4(&
|$@H
t$0L
|$0H
|$@H
5?+&
t$ L
T$vH
D$xdH3
t$ H
|$ H
|$`H
T$uH
5b(&
t$ H
H+E H
=f#&
=4#&
t$ L
t$ u
D$H1
d$0H
T$GH
|$0H
d$ H
T$FH
|$ H
=% &
D$HdH3
\$PH
l$XL
d$`L
l$hL
t$pH
T$EH
ATUSH
D$X1
u0I;u8
D$XdH3
h[]A\A]
H9H }
H9N ~@H
u0H;u8
l$0L
|$8I
|$0H
H;=L
l$ H
AUATUH
D$(1
T$'H
H;h v
H;i 
D$(dH3
8[]A\A]
AVAUATUH
D$H1
D$HdH3
P[]A\A]A^
T$FH
d$0H
T$GH
|$0L
|$ H
T$DH
T$EH
e(M9
eXM9
ATUH
[]A\
l$PH
T$pH
{ H+T$`H+
H+D$xH
|$pH
D$`H
L$xH
SHH)
T$ H
D$0H
{pH+T$
H+D$8H
D$HH+D$(H
|$ H
L$0H+L$8L
L$(H
L$HL)
[]A\A]A^A_
\$(H
l$0L
d$8L
l$@L
t$HL
|$PH
R H9
D$(1
H;U |
H9P |I
L$(dH3
0[]A\
H9P }
D$H1
V I9
$}EH
$H9P 
T$HdH3
\$PH
l$XL
d$`H
W H9
P I9
$H9B }
\$(H
l$0L
d$8L
l$@L
t$HL
|$PH
\$(H
l$0L
d$8L
l$@L
t$HL
|$PH
\$(H
l$0L
d$8L
l$@L
t$HL
|$PH
u H)
D$(1
uEI)
L$(dH3
0[]A\
D$H1
T$HdH3
\$XH
l$`L
d$hL
l$pH
H9] 
C0H9CPuqH
C0H9CPueH
AWAVAUATI
[]A\A]A^A_
w`dH
w`dH
AVAUATUL
T$ H
d$`dH
D$x1
T$XH
l$PL
|$PH
H;=R
D$(I
D$`I
D$`I
|$(L
D$XH
T$ M
|$`H
H;=q
D$xdH3
[]A\A]A^A_
D$`1
T$8H
\$@H
T$wH
|$(L
ffff.
fff.
~0dH
T$(1
D$(dH3
0[]A\
D$(1
|$0H
L$(dH3
\$0H
l$8L
d$@L
l$HL
t$PH
fff.
fff.
fffff.
l$ L
d$(L
l$0H
fffff.
d$ H
AWAVI
AUATI
[]A\A]A^A_
\$0L
t$PL
l$pH
ATUH
S E1
 []A\
d$ H
fffff.
T$(1
T$ H
t$ H
T$(dH3
\$ H
l$(L
d$0L
l$8L
t$@H
D$CH
AWAVAUI
T$@H
L$pH
T$(H
L$pH
|$xI
[]A\A]A^A_
T$X1
L$@H
D$`H
|$HI
t$PH
t/H;
T$8H
D$0H
t$ L
D$0H
T$8H
t$(L
T$8H
D$0H
fffff.
AUATUSH
D$81
D$(I
t$ H
L$ H
T$8dH3
H[]A\A]
D$(H
I1D$(
d$0H
AVAUATUH
T$0L
D$h1
D$PH
T$XH
9w4L
L$hdH3
p[]A\A]A^
D$PH
T$XH
AWAVAUATI
D$x1
\$ L
D$xdH3
[]A\A]A^A_
T$`H
AWAVAUATI
|$0M
I9V w
H;P 
 M;e
[]A\A]A^A_
H;P 
t$0L
fff.
AVAUATI
D$h1
t$0L
D$PH
T$XH
T$hdH3
p[]A\A]A^
D$(1
T$(dH3
0[]A\
fff.
D$(1
H+t$
D$ H
D$ H
T$(dH3
\$8H
l$@L
d$HL
l$PL
t$XL
|$`H
H+t$
D$X1
Q0tHH
D$XdH3
\$hH
l$pL
d$xL
d$@H
T$WH
|$0H
T$VH
t$ L
T$UH
fffff.
AVAUI
\$PH
L$ dH
D$(H
D$8H
D$pH
D$@H
D$HH
t$(H
t$8H
|$@H
|$pH
D$xH)
T$ H
|$pH
[]A\A]A^A_
L$ H
T$HH
|$0H
t$0L
|$pH
AWAVAUATI
D$X1
t$PH
D$PL
+L9k
 L;k
D$XdH3
h[]A\A]A^A_
D$ H
l$@H
|$PE1
t$HH
$H9S
d$@I
D$`L
T$ H
D$@I
D$HI
D$PI
D$XI
t	H9
fffff.
T$PH
L$XL
D$`H
L$hH
D$81
D$(H
D$$0
D$(1
t$ I
L$(H
d$0H
D$(dH3
\$8H
l$@L
d$HL
l$PL
t$XL
|$`H
AWAVAUATI
t$(L
D$pH
|$pH
t$hH
D$`H
|$`H
l$PH
|$PH
|$hL
t$ H
t$@H
\$0H
|$(H
[]A\A]A^A_
|$(H
L$hI
|$(H
L$ H
|$(H
|$(H
fffff.
AWAVAUATUH
D$x1
\$0H
|$0H
;H;G
D$PH
T$vH
D$ H
|$PH
|$ H
t$PH
T$xdH3
[]A\A]A^A_
l$`H
H1C(
L$@H
|$ H
t$@H
|$ H
t$wH
AWAVL
AUATUSH
D$(1
H9T$
H9D$
L9d$
t@E1
L9d$
T$(dH3
8[]A\A]A^A_
AWAVL
AUATUSH
D$(1
H9T$
H9D$
L9d$
t@E1
L9d$
T$(dH3
8[]A\A]A^A_
AWAVAUI
ATUSH
T$XH
D$XH
T$hH
D$`H
T$PH
T$HH
D$ f
T$0H
t$hH
T$`H
|$PH
D$0H
D$(H
T$(H
D$@H
T$(H
D$pH
T$8H
D$xD
H9=&
t$ H
D$XH
D$0XH
T$0H;P
[]A\A]A^A_
T$0H
T$0H
D$09X
T$@H
|$(H
T$HH
|$8H
H9=h
D$0H
T$0H
=X~%
T$0H
=x}%
|$PH
|$(H
|$8H
fff.
AUATI
\$PH
D$`L
|$PH
T$xH
\$@H
|$@H
H9=H{%
D$0H
|$p1
L$0M
L$0M
H9\$x
|$`H
H9=cy%
[]A\A]A^A_
|$`1
H9\$x
T$0I
=qx%
t$(L
=!x%
AWAVA
ATUH
D$8H
D$pH
D$@H
D$HH
D$ H
D$`H
T$8H
T$@H
T$HH
T$(H
t$ L
|$0L
|$`L
|$pH
|$PH
H;=st%
[]A\A]A^A_
5,w%
=Or%
|$0H
fff.
AVAUATUSH
([]A\A]A^A_
H1Cp
fffff.
AVAUATUSH
([]A\A]A^A_
H1Cp
fffff.
D$81
d$ H
T$7H
|$ H
T$8dH3
\$HH
l$PL
d$XL
l$`H
fffff.
l$PL
\$pH
\$ H
l$hL
t$`H
D$XH
D$(H
D$`H
D$0H
D$hH
D$8H
D$pH
|$ H
|$PH
fffff.
AWAVI
ATUSH
=b_%
D$h1
d$XI
L+l$XH
t$PH
\$@H
T$gH
|$@H
H I9
t$PH
T$hdH3
x[]A\A]A^A_
D$XH
t$`u@H
\$(H
l$0L
d$8L
l$@L
t$HL
|$PH
=ej%
fff.
AUATI
D$H1
T$FH
5"^%
l$0H
T$GH
d$ H
T$HdH3
X[]A\A]
AWAVAUI
ATUSH
D$PH
T$(H
|$pL
t$`H
T$8H
D$$H
|$PH
|$`H
T$$D)
|$pH
D9d$4
T$(H
t$pH
|$pH
[]A\A]A^A_
t$8H
t$@H
=VU%
fff.
D$81
L$ L
T$7H
H;=HT%
d$ I
T$8dH3
\$HH
l$PL
d$XL
l$`L
t$hL
|$pH
D$(L
 L;`
XM;g
 L;`
@M;f
|$ L
=YR%
T$5H
=AQ%
AVAUM
ATUSH
T$@H
L$OH
L$@dH
D$hH
D$`H
T$PH
L$,H
D$XH
T$ H
L$pH
L$xH
L$0L
T$XH
|$ H
H;=8O%
t$`H
L$PH
t$pH
t$hL
[]A\A]A^A_
L$`H
D$0H
L$@H
D$@D
5uL%
|$ H
fffff.
D$h1
l$@L
|$@L
5%F%
D$ H
T$(H
l$0H
T$fL
|$0H
T$hdH3
\$xH
l$PH
=\D%
I1E(
=-C%
t$eH
t$dH
t$PH
T$ L
D$(dH
5oE%
L$ H
t$0L
D$ H
D$(E
L$ H
D$ H
L$ H
L$ H
D$ H
|$ H
fffff.
AVAUATUH
t$pH
l$`H
d$PH
=-.%
t$pH
=V-%
t$`H
t$PH
t$pH
|$0H
5r/%
|$@H
|$@H
t$`H
t$PH
5F.%
|$ H
[]A\A]A^A_
=g(%
AWAVAUATI
D$PH
D$pH
|$`H
t$(L
d$@H
T$ L
|$@H
|$`H
|$pH
|$PH
=y1%
=^1%
=11%
l$0H
[]A\A]A^A_
=d!%
=1!%
=q %
=A %
AWAVAUI
-=#%
D$81
D$8dH3
H[]A\A]A^A_
H1Cp
l$ L
|$ L
d$(I9
|$ H
|$ I
AWAVAUI
D$81
D$8dH3
H[]A\A]A^A_
H1Cp
l$ L
|$ L
d$(I9
|$ H
|$ I
L$HI
t$`H
l$pH
l$PL
t$HL
t$HI
D$0H
t$(H
l$ H
D$HH
AVAUATUSH
|$ H
T$hH
L$(L
D$PL
D$(H
T$0H
L$8H
\$@H
L$HH
|$ H
|$0H
L$ H
t$hH
T$ H
T$(H
t$ L
T$XL
t$HL
t$@H
T$(H
T$8H
L$PH
t$(H
D$PH
|$pH
[]A\A]A^A_
t$ L
|$pH
|$8H
T$(H
D$PH
|$8H
T$HH
L$@H
T$8H
L$0H
T$0I
|$pH
AWAVAUATI
D$x1
D$`H
D$`H
t$`H
|$`H
T$xdH3
[]A\A]A^A_
|$HL
t$PL
l$X1
l$pE
t$@H
t$pL
l$0H
l$ H
fff.
AUATM
L$ L
\$HI
L$@H9
T$`H
D$XH
T$HH
t$8H
D$PH
T$@H
|$0L
L$(L
t$PH
T$8H
|$@H
\$HI
t$(L
t$(H
D$XH
T$HH
t$(H
D$`H
D$hH
D$pH
L$ M
T$(H
t$(H
[]A\A]A^A_
L$(E1
|$0L
t$(H
t$(H
t$(L
L$(H
D$0H
|$HH
|$HH
T$ L
t$0L
t$HH
t$HH
T$0H
T$(H
|$0H
t$0H
T$8H
t$ L
t$(H
D$@H
t$(L
D$(H
t$(H
|$8H
|$@H
|$@H
fffff.
D$(1
|$  
T$'H
T$&H
T$(dH3
\$0H
l$8L
d$@L
l$HL
t$PH
AVAUATUSH
|$PH
T$8L
L$@D
d$`L
L$8H
D$HM
T$@H
T$ H
D$8H
D$_H
T$@H
t$8L
t$@L
D$HH
|$PL
[]A\A]A^A_
t$8H
fffff.
AVAUI
|$HdH
L$gH
D$XH
l$p1
T$PH
T$HL
T$PH
T$ A
T$PL
D$XH
T$XH
T$PH
t$XH
D$hH
|$HL
[]A\A]A^A_
T$@H
T$PH
T$HL
T$HL
|$PI
AVAUATM
D$0H
L$0M
|$HM
D$XdH
T$WL
D$@H
t$`L
D$@L
T$8H
T$8L
T$0H
T$8L
D$XH
t$0H
D$@H
|$HL
[]A\A]A^A_
T$0H
T$0H
T$8L
T$0H
D$HH
D$Ht!H
D$Hu
D$Ht
D$Ht
D$Ht
D$HL
D$Hu
ffff.
D$(1
T$'H
T$(dH3
D$(1
t'H;
L$(dH3
ATUH
[]A\
ATUH
[]A\
AWAVAUATUSH
t9E1
([]A\A]A^A_
D$ L
l$ L
d$(L
l$0L
t$8L
|$@H
;B @
D$ L
l$ L
d$(L
l$0L
t$8L
|$@H
R H9
AWAVI
AUATUSH
[]A\A]A^A_
AWAVI
AUATUSH
[]A\A]A^A_
AUATUSH
[]A\A]A^
AUATUSH
[]A\A]A^
AUATUSH
[]A\A]A^
AUATUSH
[]A\A]A^
AUATUSH
[]A\A]A^
AUATI
l$ dH
D$(1
8L;G
L$(dH3
8[]A\A]
\$(H
l$0L
d$8L
l$@H
\$(H
l$0L
d$8L
l$@L
t$HL
|$PH
AWE1
ATUH
D$81
H;O(
YM$L
d$ H
L$8dH3
T$(L
H[]A\A]A^A_
H1E(
H1E(
D$81
t$ H
L$ H
T$8dH3
AWE1
ATUH
D$81
H;O(
YM$L
d$ H
L$8dH3
T$(L
H[]A\A]A^A_
H1E(
H1E(
D$81
t$ H
L$ H
T$8dH3
AWE1
ATUH
D$81
H;O(
YM$L
d$ H
L$8dH3
T$(L
H[]A\A]A^A_
H1E(
H1E(
D$81
t$ H
L$ H
T$8dH3
AWE1
ATUH
D$81
H;O(
YM$L
d$ H
L$8dH3
T$(L
H[]A\A]A^A_
H1E(
H1E(
D$81
t$ H
L$ H
T$8dH3
AWE1
ATUH
D$81
H;O(
YM$L
D$ E
D$(H
d$ H
L$8dH3
T$(L
H[]A\A]A^A_
H1E(
H1E(
AWE1
ATUH
D$81
H;O(
YM$L
d$ H
L$8dH3
T$(L
H[]A\A]A^A_
H1E(
H1E(
\$(H
l$0L
d$8L
l$@L
t$HL
|$PH
AWAVAUATI
[]A\A]A^A_
AUATUH
t<E1
[]A\A]A^
AWAVAUATI
[]A\A]A^A_
AVAUATI
D$(1
l$ H
I9T$
T$(dH3
8[]A\A]A^A_
AUATI
D$81
H;O(
YK$H
L$8dH3
T$(H
@[]A\A]A^
H1C(
H1C(
AWAVAUATI
8H9W
[]A\A]A^A_
t$@L
D$HL
D$PH
D$ H
D$XH
D$(H
D$`H
D$pH
T$xH
AVAUATUSH
\$PH
l$PL
D$PH
D$PI
D$@H
D$XH
l$@H
T$OH
|$@H
D$pH9
|$xH
t$ L
D$ L
D$PI
D$@H
l$PL
[]A\A]A^A_
|$xH
T$MH
t$0L
D$0L
l$PL
l$PL
AVAUATUSH
\$PH
l$PL
D$PH
D$PI
D$@H
D$XH
D$PH
l$@H
T$OH
|$@H
D$pH9
|$xH
t$ L
D$ L
D$PI
D$@H
l$PL
[]A\A]A^A_
|$xH
T$MH
t$0L
D$0L
l$PL
l$PL
ffff.
AVAUATUSH
D$h1
t$(t
T$hdH3
x[]A\A]A^A_
T$(1
l$XH
T$@H
T$gH
D$0H
D$PH
T$8H
T$fH
D$ H
T$Hf
t$(H
-debuginL
T$8H
|$ H
\$0H
L$PM
t"I;
L$PM
\$XL
t$(H
L$ H
|$@H
T$PI
|$ H
t$HL
fffff.
[]A\
[]A\
fffff.
l$ L
t$(L
|$0H
basic_string::_S_construct NULL not valid
Too many interrupts received, exiting.
Copyright (C) 2005-2009 Red Hat, Inc. and others
This is free software; see the source for copying conditions.
/include/config/kernel.release
Usage: stap [options] FILE         Run script in file.
   or: stap [options] -            Run script on stdin.
   or: stap [options] -e SCRIPT    Run given script.
   or: stap [options] -l PROBE     List matching probes.
   or: stap [options] -L PROBE     List matching probes and local variables.
   --         end of translator options, script options follow
   -p NUM     stop after pass NUM 1-5, instead of 
              (parse, elaborate, translate, compile, run)
   -v         add verbosity to all passes
   --vp {N}+  add per-pass verbosity [
   -k         keep temporary directory
   -u         unoptimized translation
   -w         suppress warnings
   -P         prologue-searching for function probes
   -b         bulk (percpu file) mode
   -s NUM     buffer size in megabytes, instead of 
   -I DIR     look in DIR for additional .stp script files
   -D NM=VAL  emit macro definition into generated C code
   -B NM=VAL  pass option to kbuild make
   -R DIR     look in DIR for runtime, instead of
   -r DIR     cross-compile to kernel with given build tree; or else
   -r RELEASE cross-compile to kernel /lib/modules/RELEASE/build, instead of
   -a ARCH    cross-compile to given architecture, instead of 
   -m MODULE  set probe module name, instead of 
   -o FILE    send script output to file, instead of stdout. This supports
              strftime(3) formats for FILE
   -c CMD     start the probes, run CMD, and exit when it finishes
   -x PID     sets target() to PID
   -F         run as on-file flight recorder with -o.
              run as on-memory flight recorder without -o.
   -S size[,n] set maximum of the size and the number of files.
   -d OBJECT  add unwind/symbol data for OBJECT file
   -t         collect probe timing information
   -q         generate information on tapset coverage
              restrict usage to features available to unprivileged users
              overlook context of bad $ variables
Warning: failed to create systemtap data directory ("
Warning: failed to create cache directory ("
hVvtp:I:e:o:R:r:a:m:kgPc:x:D:bs:uqwl:d:L:FS:B:
Invalid pass number (should be 1-5).
Listing (-l) mode implies pass 2.
Only one script can be given on the command line.
_abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789
Invalid module name (must only be composed of characters [_a-zA-Z0-9]).
Invalid buffer size (should be 1-4095).
Invalid target process ID number.
You can't specify multiple --kmap options.
Invalid --vp argument: it takes 1 to 5 digits.
Internal error parsing command arguments.
You can't specify -c and -x options together.
You can't specify -g and --unprivileged together.
You can't specify --kelf and --kmap together.
WARNING: kernel release/architecture mismatch with host forces last-pass 4.
ERROR: cannot create temporary directory ("
' cannot be run directly as a session script.
Pass 1: parsed user script and 
Try again with another '--vp 1' option.
Try again with another '--vp 01' option.
Pass 3: translated to C into "
Try again with another '--vp 001' option.
Try again with another '--vp 0001' option.
Try again with another '--vp 00001' option.
SystemTap translator/driver 
(version 
non-git sources
bad lexical cast
Missing 
/lib/modules/
/build
main.cxx
a->alias_names.size() >= 1
second->locations.size() >= 1
# global embedded code
# globals
# functions
  # locals
# probes
Options:
   -h         show help
   -V         show version
 [set]
   -g         guru mode
, in addition to
              
   --unprivileged
   --skip-badvars
i486
i386
i586
i686
sun4u
sparc64
sa110
s390x
s390
powerpc
mips
stap_
stapconf_
/etc/systemtap/ssl/server
/.systemtap/ssl/server
HOME
SYSTEMTAP_TAPSET
/usr/share/systemtap
/tapset
SYSTEMTAP_RUNTIME
/runtime
SYSTEMTAP_DIR
/.systemtap
"): 
, disabling cache support.
/cache
SYSTEMTAP_COVERAGE
SYSTEMTAP_RELEASE
basic_string::substr
basic_string::erase
Truncating module name to '
Module name cannot be empty.
__TBD__
/boot/System.map-
A script must be specified.
Session arch: 
 release: 
TMPDIR
/tmp
/stapXXXXXX
Created temporary directory "
/*.stp
Searched '
found 
usage error: tapset file '
# parse tree dump
 library script(s) in 
usr/
sys/
real ms.
Pass 1: parse failed.  
Pass 2: analyzed script: 
 probe(s), 
 function(s), 
 embed(s), 
 global(s) in 
Pass 2: analysis failed.  
" in 
Pass 3: translation failed.  
Pass 4: compiled C into "
Pass 4: compilation failed.  
Copying 
Copy failed ("
" to "
Pass 5: starting run.
Pass 5: run completed in 
Pass 5: run failed.  
Keeping temporary directory "
rm -rf 
kelf
kmap
ignore-vmlinux
ignore-dwarf
void printscript(systemtap_session&, std::ostream&)
junk
embedded-code
keyword
unknown token
expected comparison operator
vector::_M_range_insert
global
foreach
delete
while
continue
next
<input>
 at 
parse error: 
	at: 
	saw: 
 EOF
kernel_v
kernel_vr
expected string literal
arch
expected '==' or '!='
command line argument index 
 out of range [1-
01234567
unexpected end-of-file
expected 'continue'
expected 'break'
expected 'next'
expected '%{'
expected number
expected 
 or 
expected '
expected 'global'
expected identifier
duplicate global name
array size out of range
@cast
struct 
union 
@avg
@count
@sum
@min
@max
unknown statistic operator 
println
@hist_linear
@hist_log
parse.cxx
expected ',' or ')'
!hop != !sym
expected ',' or ']'
expected value
expected ')'
expected @cast or $var
expected ':'
expected 'delete'
expected 'return'
expected identifier or '*'
expected '('
expected 'foreach'
multiple sort directives
expected 'in'
expected statement
expected '{'
expected 'function'
duplicate function name
expected 'string' or 'long'
expected 'probe'
Input file '
' is empty or missing.
 parse error(s).
expected 'while'
expected 'for'
expected ';'
expected 'if'
expression* parser::parse_symbol()
wildcard not allowed with order comparison operators
expected string literal as right value
expected number literal as right value
expected 'arch' or 'kernel_v' or 'kernel_vr'
             or comparison between strings or integers
invalid nested substitution of command line arguments
incomplete condition after '%('
expected '%?' marker for conditional
incomplete conditional - missing '%:' or '%)'
incomplete conditional - missing %)
found 'next' not in probe context
number invalid or out of range
expected literal string or number
embedded code in unprivileged script
only scalar globals can be initialized
base histogram operator where expression expected
unexpected comma-separated expression list
found 'return' not in function context
expected one of '. , ( ? ! { = +='
probe point alias name cannot be optional nor sufficient
expected probe point specifier
expected 'probe', 'global', 'function', or '%{'
11parse_error
delete 
return 
for (
staptree.h
!targets.empty()
clearok || dst
staptree.cxx
!active_lvalues.empty()
print_char
invalid element
avg(
count(
sum(
max(
hist_linear(
hist_log(
 if (
[...]
hist
foreach ([
] in 
 limit 
Failed to classify indexable
current_function
/* unprivileged */
symbol without referent
# file 
global 
else 
vector::_M_fill_insert
inconsistent arity
' may not be used as array
invalid use of 
curr.type == conv_literal
i->type != conv_unspecified
!i->literal_string.empty()
Expecting symbol or histogram operator
function may not be used when --unprivileged is specified
' may not be used as a structure
curr.type == conv_unspecified || curr.type == conv_literal
invalid or missing conversion specifier
trailing incomplete print format conversion
virtual update_visitor::~update_visitor()
T* update_visitor::require(T*, bool) [with T = indexable]
T* update_visitor::require(T*, bool) [with T = symbol]
T* update_visitor::require(T*, bool) [with T = hist_op]
T* update_visitor::require(T*, bool) [with T = expression]
T* update_visitor::require(T*, bool) [with T = arrayindex]
T* update_visitor::require(T*, bool) [with T = statement]
T* update_visitor::require(T*, bool) [with T = expr_statement]
virtual void varuse_collecting_visitor::visit_embeddedcode(embeddedcode*)
void visitor::pop_active_lvalue()
void indexable::visit_indexable(visitor*)
void indexable::print_indexable(std::ostream&) const
void hist_op::print(std::ostream&) const
static std::vector<print_format::format_component, std::allocator<print_format::format_component> > print_format::string_to_components(const std::string&)
static std::string print_format::components_to_string(const std::vector<print_format::format_component, std::allocator<print_format::format_component> >&)
17deep_copy_visitor
14update_visitor
16throwing_visitor
25varuse_collecting_visitor
31functioncall_traversing_visitor
18traversing_visitor
11probe_alias
5probe
14next_statement
18continue_statement
15break_statement
16delete_statement
16return_statement
12if_statement
14expr_statement
14null_statement
12foreach_loop
8for_loop
5block
12embeddedcode
9statement
12functiondecl
7vardecl
10symboldecl
7hist_op
7stat_op
12print_format
12functioncall
10arrayindex
7cast_op
13target_symbol
6symbol
9indexable
10assignment
18ternary_expression
13concatenation
10comparison
8array_in
16logical_and_expr
15logical_or_expr
12post_crement
11pre_crement
16unary_expression
17binary_expression
14literal_number
14literal_string
10expression
7visitor
7literal
14semantic_error
 /* <- 
elaborate.cxx
derivations.size() > 0
derivations[0] == use
vector::_M_insert_aux
Changing 
 reference to 
 reference
inappropriate
type definition '
' not found
no current probe/function
Resolution problem with 
other
unresolved arity-
 global array 
source: 
Eliding unused unary 
fd->name == name
where != s.functions.end()
semantic error: 
WARNING: 
probe condition
 with type mismatch (
 type first inferred here (
e->type == pe_string
function call modifies var '
' during 'foreach' iteration
eliding unused function '
Eliding unused function 
e->params.size() == 3
e->htype == hist_log
e->params.size() == 0
eliding unused variable '
read-only local variable '
 in function 
read-only global variable '
alias component 
 contains illegal parameter
side-effect-free probe '
side-effect-free function '
Eliding unused typecast 
Eliding unused binary 
Eliding assignment to 
Eliding unused target symbol 
Eliding unused print 
Flattening nested block 
 with unresolved type
e->referent != 0
false
wanted != pe_unknown
 uses invalid operator
 with invalid type 
array->referent != 0
(string)
(number)
(...)
pos <= loc->components.size()
 (follow:
wildcard '
' matched '
no match
Probe point 
 sufficient, skipped
 while resolving probe point 
="%#s"\n
=%#x\n
 @count=0x0\n
idx%d
"%#s"
no probes found
Expecting symbol or array index expression
Assignment to read-only histogram bucket
derived_probe with no locations
derived_probe with too many locations
invalid operand of delete expression
unresolved array in delete statement
probe condition must not reference undeclared global
unresolved target-symbol expression
invalid use of wildcard probe point component
probe condition must not reference function
' modified during 'foreach' iteration
multiple histogram types declared on '
Eliding unused local variable 
Eliding unused global variable 
 while registering probe alias 
Eliding side-effect-free foreach statement 
Eliding side-effect-free null statement 
Creating if statement from unused ternary expression 
Creating if statement from unused logical-and 
Eliding side-effect-free expression 
Creating if statement from unused logical-or 
Eliding side-effect-free for statement 
Eliding side-effect-free if statement 
Creating simple evaluation from if statement 
Inverting the condition of if statement 
Eliding side-effect-free empty block 
Eliding side-effect-free singleton block 
Unspecified conversion in print operator format string
Wrong number of args to formatted print operator
unsupported assignment operator 
Eliding side-effect-free function call 
probe condition must not modify any variables
probe condition must not include impure embedded-C
probe point truncated at position 
probe point is not allowed for unprivileged users
probe point mismatch at position 
 didn't find any wildcard matches
 @count=%#x @min=%#x @max=%#x @sum=%#x @avg=%#x\n
unable to infer statistic parameters for global '
Recursive loop in alias expansion of 
26duplicate_function_remover
22void_statement_reducer
21dead_stmtexpr_remover
23dead_assignment_remover
13derived_probe
19typeresolution_info
18symresolution_info
virtual update_visitor::~update_visitor()
virtual void typeresolution_info::visit_print_format(print_format*)
virtual void delete_statement_typeresolution_info::visit_symbol(symbol*)
virtual void typeresolution_info::visit_foreach_loop(foreach_loop*)
virtual void typeresolution_info::visit_functioncall(functioncall*)
virtual void typeresolution_info::visit_arrayindex(arrayindex*)
virtual void typeresolution_info::visit_symbol(symbol*)
virtual void typeresolution_info::visit_literal_string(literal_string*)
virtual void typeresolution_info::visit_literal_number(literal_number*)
void semantic_pass_opt6(systemtap_session&, bool&)
T* update_visitor::require(T*, bool) [with T = statement]
T* update_visitor::require(T*, bool) [with T = expression]
void semantic_pass_opt1(systemtap_session&, bool&)
functiondecl* symresolution_info::find_function(const std::string&, unsigned int)
virtual void symresolution_info::visit_arrayindex(arrayindex*)
virtual void symresolution_info::visit_foreach_loop(foreach_loop*)
void systemtap_session::print_error_source(std::ostream&, std::string&, const token*)
void systemtap_session::print_token(std::ostream&, const token*)
virtual void stat_decl_collector::visit_hist_op(hist_op*)
bool alias_expansion_builder::checkForRecursiveExpansion(probe*)
void match_node::find_and_build(systemtap_session&, probe*, probe_point*, unsigned int, std::vector<derived_probe*, std::allocator<derived_probe*> >&)
derived_probe::derived_probe(probe*, probe_point*)
derived_probe::derived_probe(probe*)
T* update_visitor::require(T*, bool) [with T = logical_and_expr]
36delete_statement_typeresolution_info
35delete_statement_symresolution_info
38no_var_mutation_during_iteration_check
21mutated_var_collector
19stat_decl_collector
14symbol_fetcher
23alias_expansion_builder
21derived_probe_builder
19alias_derived_probe
translate.cxx
hop.htype == hist_linear
hop.params.size() == 3
hop.htype == hist_log
hop.params.size() == 0
/* null */;
c->actionremaining -= 
(void) 
((int64_t)
union {
invalid lvalue type
translate.h
tablevel == 0
INT64
STRING
int64_t
string_t
Stat
cannot expand unknown type
STAT
expected numeric types
(int64_t)(0 
 (uint64_t)(
expected numeric condition
expected matching types
) ? (
) : (
expected string types
strncmp (
, MAXSTRINGLEN
unexpected type
cannot 'next' from function
unresolved symbol
unresolved symbol: 
static void function_
static 
strlcat (
, MAXSTRINGLEN);
strlcpy (
struct stat_data *
 locks 
write_unlock (& global.s_
_lock);
read_unlock (& global.s_
unlock_: ;
nothing
#ifdef STP_TIMING
#endif
cannot 'break' outside loop
#include "alloc.c"
#define VALUE_TYPE 
#define KEY
#include "pmap-gen.c"
#include "map-gen.c"
#undef VALUE_TYPE
#undef KEY
#include "map.c"
PMAP s_
rwlock_t s_
_lock;
atomic_t s_
_lock_skip_count;
#endif
#undef 
module_param_named (
, int64_t, 0);
module_param_string (
, MAXSTRINGLEN, 0);
expected numeric type
unknown type of map
invalid reference to array
non-number <<< expression
_stp_pmap_clear (
_stp_map_clear (
_stp_stat_clear (
[0] = '\0';
string assignment operator 
lval.type() == pe_stats
rval.type() == pe_long
res.type() == pe_long
_stp_stat_add (
*error*
invalid post-mode operator
if (unlikely(!
_stp_mod64
_stp_div64
 (NULL, 
unknown macop for assignment
#define STAP_SESSION_ERROR 2
struct context {
atomic_t busy;
const char *probe_point;
int actionremaining;
int nesting;
string_t error_buffer;
const char *last_error;
const char *last_stmt;
struct pt_regs *regs;
unsigned long *unwaddr;
int regparm;
va_list *mark_va_list;
const char * marker_name;
const char * marker_format;
void *data;
Stat *statp;
#ifdef STP_OVERLOAD
cycles_t cycles_base;
cycles_t cycles_sum;
c->statp = & time_
# needs_global_locks: 
_locals {
} probe_locals;
struct function_
/* no return value */
 __retvalue;
} function_
} locals [MAXNESTING+1];
#if MAXNESTING < 0
#include "stat.c"
& _stp_module_
unsigned numtrylock = 0;
(void) numtrylock;
write
_trylock (& global.s_
_lock)
while (! 
ndelay (TRYLOCKDELAY);
atomic_inc (& skipped_count);
atomic_inc (& global.s_
_lock_skip_count);
goto unlock_
if (0) goto unlock_;
pmap
_stp_pmap_get_agg(
 >= 0)
 && (
ty == pe_stats
->hist))
->hist.buckets)
 type unsupported
cannot 'return' from probe
return type mismatch
l->__retvalue
need rvalue for assignment
stap-symbols.h
#include 
SYSTEMTAP_DEBUGINFO_PATH
cannot open dwfl
dwfl_getmodules
modname.length() != 0
cannot create dwfl for 
 non-recursive
 recursive
#define STP_PRIVILEGED 1
#ifndef MAXNESTING
#define MAXNESTING 
#include <asm/types.h>
#ifndef MAXSTRINGLEN
#if BITS_PER_LONG == 32
#define MAXSTRINGLEN 256
#else
#define MAXSTRINGLEN 512
#ifndef MAXACTION
#define MAXACTION 1000
#ifndef MAXTRYLOCK
#define MAXTRYLOCK MAXACTION
#ifndef TRYLOCKDELAY
#define TRYLOCKDELAY 100
#ifndef MAXMAPENTRIES
#define MAXMAPENTRIES 2048
#ifndef MAXERRORS
#define MAXERRORS 0
#ifndef MAXSKIPPED
#define MAXSKIPPED 100
#ifndef MINSTACKSPACE
#define MINSTACKSPACE 1024
#ifndef INTERRUPTIBLE
#define INTERRUPTIBLE 1
#ifndef STP_OVERLOAD_INTERVAL
#ifndef STP_NO_OVERLOAD
#define STP_OVERLOAD
#define STP_SKIP_BADVARS 
#define STP_BULKMODE
#define STP_TIMING
#define STP_PERFMON
#include "runtime.h"
#include "stack.c"
#include "stat.c"
#include <linux/string.h>
#include <linux/timer.h>
#include <linux/sched.h>
#include <linux/delay.h>
#include <linux/profile.h>
#include <linux/random.h>
#include <linux/vermagic.h>
#include <linux/utsname.h>
#include <linux/version.h>
#include "loc2c-runtime.h" 
#ifndef read_trylock
static struct {
} global = {
systemtap_module_exit ();
MODULE_LICENSE("GPL");
dump_unwindsyms 
 index=
 base=0x
Getting symbol table for 
Found build-id in 
, length 
, end at 0x
dwfl_module_relocations
_stext
dwfl_module_relocate_address
kretprobe_trampoline_holder
secname != __null
.dynamic
n == 0
scn != __null
.eh_frame
.debug_frame
static uint8_t _stp_module_
_debug_frame[] = 
_eh_frame[] = 
No unwind data for 
static struct _stp_symbol 
_symbols_
#ifdef STP_NEED_SYMBOL_DATA
  { 0x
_sections[] = {
.name = 
.size = 0x
.symbols = _stp_module_
.num_symbols = 
.path = 
.dwarf_module_base = 0x
.eh_frame_addr = 0x
.debug_frame = 
_debug_frame, 
.debug_frame_len = 
#else
.debug_frame = NULL,
.debug_frame_len = 0,
.eh_frame = 
_eh_frame, 
.eh_frame_len = 
.eh_frame = NULL,
.eh_frame_len = 0,
.unwind_hdr = NULL,
.unwind_hdr_len = 0,
.sections = _stp_module_
_sections
_sections)/
sizeof(struct _stp_section),
.build_id_bits = "
.build_id_len = 
.build_id_offset = 0x
.build_id_len = 0,
.notes_sect = 0,
.absolute
 elided, duplicates 
static void 
_locals * __restrict__ l =
& c->probe_locals.
(void) l;
CATCH_DEREF_FAULT ();
out:
_stp_print_flush();
top_
continue_
break_
if (! (
)) goto 
; /* dummy statement */
__tmp
max(min(
c->last_stmt = 
operator not yet implemented
int holdon;
int i=0, j=0;
(void) i;
(void) j;
synchronize_sched();
do {
int i;
holdon = 0;
for (i=0; i < NR_CPUS; i++)
if (cpu_possible (i) && 
holdon = 1;
yield ();
} while (holdon);
_stp_pmap_del (
_stp_map_del (
_stp_stat_del (
unsupported deallocator for 
free_percpu (contexts);
if (likely (time_
const char *probe_point = 
const char *decl_location = 
if (stats->count) {
_stp_stat_del (time_
#ifdef STAP_NEED_GETTIMEOFDAY
 _stp_kill_time();
skipped probes: %d\n", 
int ctr;
, ctr);
_stp_key_get_int64 (
); if (! v) v = ""; v; })
illegal key type
{ int rc = 
size limit (
"; goto out; }}
exists
((uintptr_t)
) != (uintptr_t) 0)
invalid length argument list
function actual argument copy
(void) 0;
c->locals[c->nesting+1]
.function_
.__retvalue;
invalid array reference
array index type mismatch
e->indexes.size() == 1
array index copy
struct map_node *
Invalid indexing of histogram
unexpected reference to array
_stp_map_iter (
({ char *v = 
if (!v) v = ""; v; })
 = _stp_stat_get (
if (unlikely (
 == NULL))
 || 
->count == 0) {
_stp_div64(NULL, 
->sum, 
->count)
->count
->sum
->min
->max
} else
_stp_stat_print_histogram (
too many arguments to print
%s\n
"\n"
deref_buffer (0, 
_stp_print_char (
_stp_print (
((int64_t)0LL)
_stp_printf (
_stp_snprintf (
, MAXSTRINGLEN, 
, (int)
, (char*)(uintptr_t)
idx.size() == 1
idx[0].type() == pe_long
} else {
->histogram[
_stp_map_start (
foreach limit
_stp_pmap_agg (
if (unlikely(NULL == 
_stp_map_sortn (
_stp_map_sort (
 = 0LL;
++ >= 
s->indexes.size() == 1
 = 0; 
++) { 
[0] ? 
 : NULL))
e->type == pe_stats
rvalue->type == pe_long
 = _stp_stat_init (
 == NULL) rc = -ENOMEM;
unsupported stats type for 
unsupported initializer for 
_locals * 
#define CONTEXT c
#define THIS l
if (0) goto out;
c->nesting ++;
#define return goto out
#undef return
c->nesting --;
#undef CONTEXT
#undef THIS
 = _stp_
_new_
, HIST_NONE
, HIST_LINEAR
, HIST_LOG
int rc = 0;
const char *probe_point = "";
if (strcmp (release, 
rc = -EINVAL;
if (rc) goto out;
rc = _stp_init_time();
if (rc) {
_stp_sym_init();
(void) probe_point;
if (contexts == NULL) {
_stp_error ("global variable 
 allocation failed");
rwlock_init (& global.s_
_stp_print_kernel_info(
return rc;
+:.debug:/usr/lib/debug:build
hop.params[0] == sd.linear_low
hop.params[1] == sd.linear_high
hop.params[2] == sd.linear_step
indent > 0 || tablevel >= (unsigned)-indent
if (unlikely (c->actionremaining <= 0)) {
c->last_error = "MAXACTION exceeded";
array type is neither string nor long
array key is neither string nor long
cannot translate general cast expression
 (struct context * __restrict__ c);
_lock_skip_count = ATOMIC_INIT(0),
cannot 'continue' outside loop
cannot translate general target expression
attempt to use scalar where map expected
identified max-nested function: 
identified recursive function: 
unknown lvalue type in assignment
non-stats left operand to <<< expression
non-number right operand to <<< expression
Cannot delete unknown expression type
post assignment on strings not supported
c->last_error = "division by 0";
assignment type not yet implemented
unsupported c_expression token type
typedef char string_t[MAXSTRINGLEN];
#define STAP_SESSION_STARTING 0
#define STAP_SESSION_RUNNING 1
#define STAP_SESSION_STOPPING 3
#define STAP_SESSION_STOPPED 4
static atomic_t session_state = ATOMIC_INIT (STAP_SESSION_STARTING);
static atomic_t error_count = ATOMIC_INIT (0);
static atomic_t skipped_count = ATOMIC_INIT (0);
static atomic_t skipped_count_lowstack = ATOMIC_INIT (0);
static atomic_t skipped_count_reentrant = ATOMIC_INIT (0);
static atomic_t skipped_count_uprobe_reg = ATOMIC_INIT (0);
static atomic_t skipped_count_uprobe_unreg = ATOMIC_INIT (0);
struct kretprobe_instance *pi;
#error "MAXNESTING must be positive"
static void *contexts = NULL; /* alloc_percpu */
static struct _stp_module *_stp_modules [] = {
static unsigned _stp_num_modules = 
static unsigned long _stp_kretprobe_trampoline = 
missing unwind/symbol data for module '
&& (++numtrylock < MAXTRYLOCK))
if (unlikely (numtrylock >= MAXTRYLOCK)) {
fetching aggregate of non-parallel map type
sd.type != statistic_decl::none
function recursion-analysis: max-nesting 
#ifndef MAXACTION_INTERRUPTIBLE
#define MAXACTION_INTERRUPTIBLE (MAXACTION * 10)
#define STP_OVERLOAD_INTERVAL 1000000000LL
#ifndef STP_OVERLOAD_THRESHOLD
#define STP_OVERLOAD_THRESHOLD 500000000LL
#include "access_process_vm.h" 
#define read_trylock(x) ({ read_lock(x); 1; })
static int probe_start (void) {
return systemtap_module_init () ? -1 : 0;
static void probe_exit (void) {
MODULE_DESCRIPTION("systemtap-generated probe");
dwfl_module_relocate_address extra_offset
Found kernel _stext extra offset 0x
module debug unwind table size too big
#if defined(STP_USE_DWARF_UNWINDER) && defined(STP_NEED_UNWIND_DATA)
#endif /* STP_USE_DWARF_UNWINDER && STP_NEED_UNWIND_DATA */
module eh unwind table size too big
#endif /* STP_NEED_SYMBOL_DATA */
static struct _stp_section _stp_module_
static struct _stp_module _stp_module_
#endif /* STP_USE_DWARF_UNWINDER && STP_NEED_UNWIND_DATA*/
.num_sections = sizeof(_stp_module_
static __cacheline_aligned Stat 
 (struct context * __restrict__ c) 
array locals not supported, missing global declaration?
unsupported local variable type
iterating over unknown reference type
unexpected concatenation operator
, (int64_t)64LL), (int64_t)0LL))
static void systemtap_module_exit (void) {
if (atomic_read (&session_state) == STAP_SESSION_STARTING)
if (atomic_read (&session_state) == STAP_SESSION_RUNNING)
atomic_set (&session_state, STAP_SESSION_STOPPING);
#ifdef STAPCONF_SYNCHRONIZE_SCHED
atomic_read (& ((struct context *)per_cpu_ptr(contexts, i))->busy)) 
struct stat_data *stats = _stp_stat_get (time_
int64_t avg = _stp_div64 (NULL, stats->sum, stats->count);
_stp_printf ("probe %s (%s), hits: %lld, cycles: %lldmin/%lldavg/%lldmax\n",
probe_point, decl_location, (long long) stats->count, (long long) stats->min, (long long) avg, (long long) stats->max);
if (atomic_read (& skipped_count) || 
atomic_read (& error_count) || 
atomic_read (& skipped_count_reentrant)) {
_stp_warn ("Number of errors: %d, 
(int) atomic_read (& error_count), 
(int) atomic_read (& skipped_count));
ctr = atomic_read (& global.s_
if (ctr) _stp_warn ("Skipped due to global '%s' lock timeout: %d\n", 
ctr = atomic_read (& skipped_count_lowstack);
if (ctr) _stp_warn ("Skipped due to low stack: %d\n", ctr);
ctr = atomic_read (& skipped_count_reentrant);
if (ctr) _stp_warn ("Skipped due to reentrancy: %d\n", ctr);
ctr = atomic_read (& skipped_count_uprobe_reg);
if (ctr) _stp_warn ("Skipped due to uprobe register failure: %d\n", ctr);
ctr = atomic_read (& skipped_count_uprobe_unreg);
if (ctr) _stp_warn ("Skipped due to uprobe unregister failure: %d\n", ctr);
({ char *v = _stp_key_get_str (
adding a value of an unsupported map type
; if (unlikely(rc)) { c->last_error = "Array overflow, check 
checking existence of an unsupported map type
expected arrayindex expression in printed hist_op
unknown type of arg to print operator
cannot delete histogram bucket entries
function argument type mismatch
c->locals[c->nesting+1].function_
if (unlikely(c->last_error)) goto out;
function actual argument evaluation
e->indexes[0]->type == pe_long
cannot assign to histogram buckets
expected arrayindex expression in iterated hist_op
expected arrayindex expression in indexed hist_op
expected arrayindex expression in stat_op of array
inconsistent iterator type in itervar::next()
getting a value from an unsupported map type
unexpected aggregate of non-statistic
unexpected aggregate of non-arrayindex
c->last_error = "empty aggregate";
cannot print unknown expression type
cannot print a raw stats object
print format actual argument evaluation
statistic-valued array in rvalue context
c->last_error = "histogram index out of range";
inconsistent iterator type in itervar::start()
c->last_error = "aggregation overflow in 
s->indexes[0]->referent->type == pe_long
setting a value of an unsupported map type
unexpected reference to scalar
 (struct context* __restrict__ c) {
& c->locals[c->nesting+1].function_
if (unlikely (c->nesting+1 > MAXNESTING)) {
c->last_error = "MAXNESTING exceeded";
static int systemtap_module_init (void) {
const char* release = UTS_RELEASE;
_stp_error ("module release mismatch (%s vs %s)", 
if (_stp_module_check()) rc = -EINVAL;
_stp_error ("couldn't initialize gettimeofday");
#if defined(STP_NEED_VMA_TRACKER)
atomic_set (&session_state, STAP_SESSION_STARTING);
if (sizeof (struct context) <= 131072)
contexts = alloc_percpu (struct context);
_stp_error ("percpu context (size %lu) allocation failed", (unsigned long) sizeof (struct context));
 = _stp_stat_init (HIST_NONE);
, (num_online_cpus() * sizeof(struct context))
_stp_error ("probe %s registration error (rc %d)", probe_point, rc);
atomic_set (&session_state, STAP_SESSION_ERROR);
atomic_set (&session_state, STAP_SESSION_RUNNING);
void translator_output::assert_0_indent()
void emit_symbol_data(systemtap_session&)
int dump_unwindsyms(Dwfl_Module*, void**, const char*, Dwarf_Addr, void*)
virtual void c_unparser::visit_hist_op(hist_op*)
virtual std::string var::buckets() const
virtual std::string var::hist() const
void aggvar::declare(c_unparser&) const
void var::assert_hist_compatible(const hist_op&)
virtual void c_unparser::visit_functioncall(functioncall*)
virtual void c_tmpcounter::visit_functioncall(functioncall*)
virtual void c_unparser_assignment::visit_arrayindex(arrayindex*)
virtual std::string mapvar::buckets() const
virtual std::string mapvar::hist() const
virtual void c_unparser::visit_arrayindex(arrayindex*)
virtual void c_tmpcounter::visit_arrayindex(arrayindex*)
void c_unparser::load_map_indices(arrayindex*, std::vector<tmpvar, std::allocator<tmpvar> >&)
void c_tmpcounter::load_map_indices(arrayindex*)
virtual void c_unparser_assignment::visit_symbol(symbol*)
virtual void c_unparser::visit_symbol(symbol*)
virtual void c_tmpcounter::visit_array_in(array_in*)
virtual void delete_statement_operand_tmp_visitor::visit_arrayindex(arrayindex*)
virtual void delete_statement_operand_visitor::visit_symbol(symbol*)
virtual void c_unparser::visit_foreach_loop(foreach_loop*)
void c_unparser_assignment::c_assignop(tmpvar&, const var&, const tmpvar&, const token*)
void translator_output::indent(int)
std::ostream& translator_output::newline(int)
32delete_statement_operand_visitor
36delete_statement_operand_tmp_visitor
23c_tmpcounter_assignment
21c_unparser_assignment
12c_tmpcounter
10c_unparser
8unparser
14recursion_info
3var
6tmpvar
6aggvar
21arrayindex_downcaster
6mapvar
tapsets.cxx
syments
/* init tracepoint probes */
for (i=0; i<
; i++) {
for (j=i-1; j>=0; j--)
j = 0;
if (!sdp->return_p)
if (sdp->return_p)
#ifdef __ia64__
if (sdp->return_p) {
if (kp->u.krp.nmissed)
if (kp->u.krp.kp.nmissed)
if (kp->u.kp.nmissed)
sdp->registered_p = 0;
probe_point = sdp->pp;
kp->u.krp.kp.addr = addr;
if (sdp->maxactive_p) {
kp->dummy.pre_handler = NULL;
if (rc == 0) {
if (rc != 0)
kp->u.kp.addr = addr;
if (!sdp->optional_p)
else sdp->registered_p = 1;
/* ---- user probes ---- */
unsigned short sdt_semaphore;
struct task_struct *tsk;
rcu_read_lock();
  put_pid(p_pid); }
#endif /* 2.6.24 */
#endif /* 2.6.31 */
if (tsk) {
sdt_semaphore --;
rcu_read_unlock();
if (sups->return_p) {
#ifdef DEBUG_UPROBES
sup->spec_index = -1;
probe_point = stf->pathname;
if (rc) break;
atomic_inc (&error_count);
c->cycles_sum = 0;
c->probe_point = 0;
if (c->last_stmt != NULL)
atomic_inc (& error_count);
_stp_exit ();
atomic_dec (&c->busy);
probe_epilogue:
#if INTERRUPTIBLE
preempt_enable_no_resched ();
local_irq_restore (flags);
inline
maxactive
process
mark
label
kprobe
int64_t __tracepoint_arg_
 /* 
 name = 
 /* pc=
#if !INTERRUPTIBLE
unsigned long flags;
preempt_disable ();
local_irq_save (flags);
goto probe_epilogue;
#ifdef DEBUG_REENTRANCY
atomic_dec (& c->busy);
c->last_stmt = 0;
c->last_error = 0;
c->nesting = -1;
c->regs = 0;
c->unwaddr = 0;
c->probe_point = 
c->pi = 0;
c->regparm = 0;
c->marker_name = NULL;
c->marker_format = NULL;
c->statp = 0;
dwarf_line_t::addr
b1 && b2
got unknown probe_type: 0x
saw .probes 
found probe_name
probe_type == kprobe_type
*getegid*
probe_type == utrace_type
_stapprobe1_
(intptr_t)
(intptr_t)&
_utrace_syscall_nr
ulong_arg
_utrace_syscall_arg
user_string
new_left == fcall
Symbol table error: Line 
 of symbol list from 
%llx %c %as [%as
Symbol table error: 
 -- 
sprint
$$return
=%#x
$$parms
$$locals
variable location problem: 
' parameter '
': type:'
' name:'
stapprobe_
_semaphore
<unknown>
 while searching for local '
 $return:
sys_ni_syscall
 -- ignoring 
Error: Cannot find vmlinux.
__kprobes_text_start
__kprobes_text_end
getshdrstrndx
shdr != __null
.probes
pdata != __null
got .probes elf scn_addr@0x
, size: 
linux/skbuff.h
checking instances of inline 
selected function 
dwfl_getehdr
i?86
x86_64
ia64
arm*
 (code 
) mismatch with target 
focused on module '
 = [0x
, bias 0x
 ELF machine 
q->has_kernel
trace/
' in '
_event_types
tracepoint-based 
 tracepoint='
!q->has_statement_num
examining inline instance of 
selected inline instance of 
kernel<
Pass 2: using cached 
/include/
/include/trace/events/*.h
/source/include/trace/*.h
/ftrace.h
/trace_events.h
_event_types.h
$$name
$arg
invalid argument number
user_long
pointer_arg
q.has_return && !q.has_call
! has_absolute
 kernel
 module=
 process=
 reloc=
 pc=0x
has_kernel || has_module
spec_type == function_alone
Error: Pattern '
  Please be more precise.
Warning: address 
 out of range for module 
querying entrypc 
 of instance of inline '
 (try 0x
 (no line info found for '
', in module '
dwarf_line_t::lineno
_dwarf_tvar_get
_dwarf_tvar_set
_dwarf_tvar_
_ctr
_dwarf_tvar_tid
parsed '
, scope '
, func '
, file '
, line 
malformed specification '
write to tracepoint '
' not permitted
tracepoint
_mark_name_get
sprintf
!tsym->saved_conversion_error
#include <
void
STAP_SESSION_RUNNING
c->marker_name = 
.__tracepoint_arg_
 = (int64_t)
(void) {
return register_trace_
(enter_tracepoint_probe_
(void) unregister_trace_
int (*reg)(void);
void (*unreg)(void);
#if ! defined(CONFIG_KPROBES)
#error "Need CONFIG_KPROBES!"
#ifndef KRETACTIVE
 struct pt_regs *regs);
struct kprobe dummy;
} stap_dwarfless_kprobes[
const unsigned return_p:1;
const unsigned maxactive_p:1;
const unsigned optional_p:1;
unsigned registered_p:1;
const char 
symbol_string
const unsigned long address;
} stap_dwarfless_probes[] = {
 .return_p=1,
 .maxactive_p=1,
 .maxactive_val=
 .optional_p=1,
 .address=(unsigned long)0x
 .symbol_string="
 .pp=
 .ph=&
 struct pt_regs *regs) {
kprobe_idx:0)
sdp->pp
c->regs = regs;
(*sdp->ph) (c);
SET_REG_IP(regs, kprobes_ip);
c->pi = inst;
/* ---- dwarf probes ---- */
} stap_dwarf_kprobes[
stap_dwarf_probe 
const char * const 
stap_dwarf_probe *
section
} stap_dwarf_probes[] = {
 .module="
 .section="
#include <linux/uprobes.h>
#include "uprobes/uprobes.h"
#ifndef UPROBES_API_VERSION
#define UPROBES_API_VERSION 1
#ifndef MAXUPROBES
#define MAXUPROBES 
static struct stap_uprobe {
int spec_index;
} stap_uprobes [MAXUPROBES];
const char *pathname;
} stap_uprobe_finders[] = {
 .finder={
 .pid=
 .procname=
 .pathname=
unsigned tfi;
const char *pp;
void (*ph) (struct context*);
} stap_uprobe_specs [] = {
 .tfi=
sups->pp
if (sup->spec_index < 0 ||
sup->spec_index >= 
) return;
(*sups->ph) (c);
SET_REG_IP(regs, uprobes_ip);
int handled_p = 0;
int slotted_p = 0;
if (sup->spec_index < 0) {
#if (UPROBES_API_VERSION < 2)
sup->spec_index = spec_index;
slotted_p = 1;
if (slotted_p) {
sup->urp.u.pid = tsk->tgid;
sup->up.pid = tsk->tgid;
sdt_semaphore ++;
handled_p = 1;
if (unlikely (! handled_p)) {
unmap_uretprobe (& sup->urp);
sup->spec_index = -2;
unmap_uprobe (& sup->up);
if (! process_p) return 0;
#ifdef DEBUG_TASK_FINDER_VMA
if (register_p)
if (offset != 0) return 0;
dwarf_builder::build for 
TOK_MARK: 
 $$name $$parms $$vars
' (alternatives:
_tracepoint_tvar_get
_tracepoint_tvar_set
rc = stap_tracepoint_probes[i].reg();
stap_tracepoint_probes[j].unreg();
#if defined(STAPCONF_UNREGISTER_KPROBES)
struct stap_dwarfless_probe *sdp = & stap_dwarfless_probes[i];
struct stap_dwarfless_kprobe *kp = & stap_dwarfless_kprobes[i];
if (! sdp->registered_p) continue;
stap_unreg_kprobes2[j++] = &kp->u.kp;
unregister_kprobes((struct kprobe **)stap_unreg_kprobes2, j);
stap_unreg_kprobes2[j++] = &kp->u.krp;
unregister_kretprobes((struct kretprobe **)stap_unreg_kprobes2, j);
stap_unreg_kprobes2[j++] = &kp->dummy;
#if !defined(STAPCONF_UNREGISTER_KPROBES)
unregister_kretprobe (&kp->u.krp);
atomic_add (kp->u.krp.nmissed, & skipped_count);
_stp_warn ("Skipped due to missed kretprobe/1 on '%s': %d\n", sdp->pp, kp->u.krp.nmissed);
atomic_add (kp->u.krp.kp.nmissed, & skipped_count);
_stp_warn ("Skipped due to missed kretprobe/2 on '%s': %lu\n", sdp->pp, kp->u.krp.kp.nmissed);
unregister_kprobe (&kp->u.kp);
atomic_add (kp->u.kp.nmissed, & skipped_count);
_stp_warn ("Skipped due to missed kprobe on '%s': %lu\n", sdp->pp, kp->u.kp.nmissed);
#if !defined(STAPCONF_UNREGISTER_KPROBES) && defined(__ia64__)
unregister_kprobe (&kp->dummy);
void *addr = (void *) sdp->address;
const char *symbol_name = addr ? NULL : sdp->symbol_string;
kp->u.krp.kp.symbol_name = (char *) symbol_name;
kp->u.krp.maxactive = sdp->maxactive_val;
kp->u.krp.maxactive = KRETACTIVE;
kp->u.krp.handler = &enter_kretprobe2_probe;
kp->dummy.addr = kp->u.krp.kp.addr;
kp->dummy.symbol_name = kp->u.krp.kp.symbol_name;
rc = register_kprobe (& kp->dummy);
rc = register_kretprobe (& kp->u.krp);
unregister_kprobe (& kp->dummy);
kp->u.kp.symbol_name = (char *) symbol_name;
kp->u.kp.pre_handler = &enter_kprobe2_probe;
kp->dummy.addr = kp->u.kp.addr;
kp->dummy.symbol_name = kp->u.kp.symbol_name;
rc = register_kprobe (& kp->u.kp);
_stp_warn ("probe %s (address 0x%lx) registration error (rc %d)", probe_point, (unsigned long) addr, rc);
for (j=0; j<MAXUPROBES; j++) {
struct stap_uprobe *sup = & stap_uprobes[j];
const struct stap_uprobe_spec *sups = &stap_uprobe_specs [sup->spec_index];
if (sup->spec_index < 0) continue;
if (sups->sdt_sem_address != 0) {
pid_t pid = (sups->return_p ? sup->urp.u.pid : sup->up.pid);
#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,31)
  { struct pid *p_pid = find_get_pid(pid);
  tsk = pid_task(p_pid, PIDTYPE_PID);
#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,24)
  tsk = find_task_by_vpid (pid);
  tsk = find_task_by_pid (pid);
(void) __access_process_vm (tsk, sup->sdt_sem_address, &sdt_semaphore, sizeof (sdt_semaphore), 0);
(void) __access_process_vm (tsk, sup->sdt_sem_address, &sdt_semaphore, sizeof (sdt_semaphore), 1);
_stp_dbug (__FUNCTION__,__LINE__, "-uretprobe spec %d index %d pid %d addr %p\n", sup->spec_index, j, sup->up.pid, (void*) sup->up.vaddr);
unregister_uretprobe (& sup->urp);
_stp_dbug (__FUNCTION__,__LINE__, "-uprobe spec %d index %d pid %d addr %p\n", sup->spec_index, j, sup->up.pid, (void*) sup->up.vaddr);
unregister_uprobe (& sup->up);
mutex_destroy (& stap_uprobes_lock);
mutex_init (& stap_uprobes_lock);
for (i=0; i<sizeof(stap_uprobe_finders)/sizeof(stap_uprobe_finders[0]); i++) {
struct stap_uprobe_tf *stf = & stap_uprobe_finders[i];
rc = stap_register_task_finder_target (& stf->finder);
struct stap_dwarf_probe *sdp = & stap_dwarf_probes[i];
struct stap_dwarf_kprobe *kp = & stap_dwarf_kprobes[i];
stap_unreg_kprobes[j++] = &kp->u.kp;
unregister_kprobes((struct kprobe **)stap_unreg_kprobes, j);
stap_unreg_kprobes[j++] = &kp->u.krp;
unregister_kretprobes((struct kretprobe **)stap_unreg_kprobes, j);
stap_unreg_kprobes[j++] = &kp->dummy;
unsigned long relocated_addr = _stp_module_relocate (sdp->module, sdp->section, sdp->address);
if (relocated_addr == 0) continue;
kp->u.krp.kp.addr = (void *) relocated_addr;
kp->u.krp.handler = &enter_kretprobe_probe;
kp->u.kp.addr = (void *) relocated_addr;
kp->u.kp.pre_handler = &enter_kprobe_probe;
_stp_warn ("probe %s (address 0x%lx) registration error (rc %d)", probe_point, (unsigned long) relocated_addr, rc);
bspcache(c->unwaddr, c->regs);
/* deregister tracepoint probes */
stap_tracepoint_probes[i].unreg();
#if defined(STP_TIMING) || defined(STP_OVERLOAD)
cycles_t cycles_atend = get_cycles ();
int32_t cycles_elapsed = ((int32_t)cycles_atend > (int32_t)cycles_atstart)
? ((int32_t)cycles_atend - (int32_t)cycles_atstart)
: (~(int32_t)0) - (int32_t)cycles_atstart + (int32_t)cycles_atend + 1;
if (likely (c->statp)) _stp_stat_add(*c->statp, cycles_elapsed);
cycles_t interval = (cycles_atend > c->cycles_base)
? (cycles_atend - c->cycles_base)
: (STP_OVERLOAD_INTERVAL + 1);
c->cycles_sum += cycles_elapsed;
if (interval > STP_OVERLOAD_INTERVAL) {
if (c->cycles_sum > STP_OVERLOAD_THRESHOLD) {
_stp_error ("probe overhead exceeded threshold");
c->cycles_base = cycles_atend;
if (unlikely (c->last_error && c->last_error[0])) {
_stp_softerror ("%s near %s", c->last_error, c->last_stmt);
_stp_softerror ("%s", c->last_error);
if (atomic_read (& error_count) > MAXERRORS) {
atomic_set (& session_state, STAP_SESSION_ERROR);
if (unlikely (atomic_read (& skipped_count) > MAXSKIPPED)) {
struct context* __restrict__ c;
cycles_t cycles_atstart = get_cycles ();
if (unlikely ((((unsigned long) (& c)) & (THREAD_SIZE-1))
< (MINSTACKSPACE + sizeof (struct thread_info)))) {
atomic_inc (& skipped_count_lowstack);
if (atomic_read (&session_state) != 
c = per_cpu_ptr (contexts, smp_processor_id());
if (atomic_inc_return (& c->busy) != 1) {
atomic_inc (& skipped_count_reentrant);
_stp_warn ("Skipped %s due to %s residency on cpu %u\n", 
, c->probe_point ?: "?", smp_processor_id());
c->actionremaining = MAXACTION_INTERRUPTIBLE;
c->actionremaining = MAXACTION;
tracepoint_builder releasing dwflpp
has_kernel || has_process || has_module
probe_type == uprobe_type, use statement addr: 0x
probe_type == use_uprobe_no_dwarf, use label name: 
Operator-assign expressions on target variables not implemented
 is not in correct format: address type name [module]
 contains no function symbols.
Warning: cannot read symbol table from 
get_string_param(params, TOK_MARK, mark_name)
cannot get type of tracepoint '
found parameter for tracepoint '
dwarf_builder releasing kernel dwflpp 
dwarf_builder releasing user dwflpp 
unable to find any scopes containing 
Warning: reading symbol table from 
  Consider using --kmap instead of --kelf.
/usr/bin/nm -n --defined-only 
Internal error reading symbol table from 
Warning: nm cannot read symbol table from 
absolute statement probe in unprivileged script
cannot parse header location for tracepoint '
dw.function_name.compare(0, 10, "stapprobe_") == 0
Pass 2: getting a tracequery for 
/source/include/trace/events/*.h
get_param (parameters, TOK_TRACE, tracepoint)
cannot take address of sdt variable
missing relocation base against
inconsistent relocation address
maxactive value out of range [0,
' matches every instruction address in the symbol table,
some of which aren't even functions.
has_function_num || has_statement_num
 maps to no known compilation unit in module 
cannot probe .return of inline function '
 does not match the beginning of a statement
has_function_str || has_statement_str
function DIE lands on srcfile
inline instance DIE lands on srcfile
write to typecast value not permitted
!target_symbol_setter_functioncalls.empty()
cannot take address of context variable
/* ---- tracepoint probes ---- */
static void enter_tracepoint_probe_
static int register_tracepoint_probe_
static void unregister_tracepoint_probe_
static struct stap_tracepoint_probe {
} stap_tracepoint_probes[] = {
 .reg=&register_tracepoint_probe_
 .unreg=&unregister_tracepoint_probe_
/* ---- kprobe-based probes ---- */
#define KRETACTIVE (max(15,6*NR_CPUS))
static int enter_kprobe2_probe (struct kprobe *inst,
static int enter_kretprobe2_probe (struct kretprobe_instance *inst,
static void * stap_unreg_kprobes2[
static struct stap_dwarfless_kprobe {
union { struct kprobe kp; struct kretprobe krp; } u;
static struct stap_dwarfless_probe {
const unsigned short maxactive_val;
void (* const ph) (struct context*);
p->maxactive_val >= 0 && p->maxactive_val <= 32767
int kprobe_idx = ((uintptr_t)inst-(uintptr_t)stap_dwarfless_kprobes)/sizeof(struct stap_dwarfless_kprobe);
struct stap_dwarfless_probe *sdp = &stap_dwarfless_probes[
((kprobe_idx >= 0 && kprobe_idx < 
unsigned long kprobes_ip = REG_IP(c->regs);
SET_REG_IP(regs, (unsigned long) inst->addr);
struct kretprobe *krp = inst->rp;
int kprobe_idx = ((uintptr_t)krp-(uintptr_t)stap_dwarfless_kprobes)/sizeof(struct stap_dwarfless_kprobe);
SET_REG_IP(regs, (unsigned long) inst->rp->kp.addr);
static int enter_kprobe_probe (struct kprobe *inst,
static int enter_kretprobe_probe (struct kretprobe_instance *inst,
static void * stap_unreg_kprobes[
static struct stap_dwarf_kprobe {
static struct stap_dwarf_probe {
int kprobe_idx = ((uintptr_t)inst-(uintptr_t)stap_dwarf_kprobes)/sizeof(struct stap_dwarf_kprobe);
struct stap_dwarf_probe *sdp = &stap_dwarf_probes[
int kprobe_idx = ((uintptr_t)krp-(uintptr_t)stap_dwarf_kprobes)/sizeof(struct stap_dwarf_kprobe);
#if defined(CONFIG_UPROBES) || defined(CONFIG_UPROBES_MODULE)
union { struct uprobe up; struct uretprobe urp; };
unsigned long sdt_sem_address;
DEFINE_MUTEX(stap_uprobes_lock);
static int stap_uprobe_process_found (struct stap_task_finder_target *tgt, struct task_struct *tsk, int register_p, int process_p);
static int stap_uprobe_mmap_found (struct stap_task_finder_target *tgt, struct task_struct *tsk, char *path, unsigned long addr, unsigned long length, unsigned long offset, unsigned long vm_flags);
static int stap_uprobe_munmap_found (struct stap_task_finder_target *tgt, struct task_struct *tsk, unsigned long addr, unsigned long length);
static struct stap_uprobe_tf {
struct stap_task_finder_target finder;
 .callback=&stap_uprobe_process_found,
 .mmap_callback=&stap_uprobe_mmap_found, 
 .munmap_callback=&stap_uprobe_munmap_found, 
static const struct stap_uprobe_spec {
 .sdt_sem_address=(unsigned long)0x
static void enter_uprobe_probe (struct uprobe *inst, struct pt_regs *regs) {
struct stap_uprobe *sup = container_of(inst, struct stap_uprobe, up);
unsigned long uprobes_ip = REG_IP(c->regs);
SET_REG_IP(regs, inst->vaddr);
static void enter_uretprobe_probe (struct uretprobe_instance *inst, struct pt_regs *regs) {
struct stap_uprobe *sup = container_of(inst->rp, struct stap_uprobe, urp);
SET_REG_IP(regs, inst->rp->u.vaddr);
static int stap_uprobe_change_plus (struct task_struct *tsk, unsigned long relocation, unsigned long length, const struct stap_uprobe_tf *stf) {
int tfi = (stf - stap_uprobe_finders);
for (spec_index=0; spec_index<sizeof(stap_uprobe_specs)/sizeof(stap_uprobe_specs[0]); spec_index++) {
const struct stap_uprobe_spec *sups = &stap_uprobe_specs [spec_index];
if (likely(sups->tfi != tfi)) continue;
if (likely(sups->address >= length)) continue;
mutex_lock (& stap_uprobes_lock);
for (i=0; i<MAXUPROBES; i++) {
struct stap_uprobe *sup = & stap_uprobes[i];
if (sup->spec_index == -1 && sup->up.kdata != NULL) continue;
else if (sup->spec_index == -2 && sup->urp.u.kdata != NULL) continue;
mutex_unlock (& stap_uprobes_lock);
_stp_dbug(__FUNCTION__,__LINE__, "+uprobe spec %d idx %d process %s[%d] addr %p pp %s\n", 
spec_index, (slotted_p ? i : -1), tsk->comm, tsk->tgid, 
(void*)(relocation+sups->address), sups->pp);
sup->urp.u.vaddr = relocation + sups->address;
sup->urp.handler = &enter_uretprobe_probe;
rc = register_uretprobe (& sup->urp);
sup->up.vaddr = relocation + sups->address;
sup->up.handler = &enter_uprobe_probe;
rc = register_uprobe (& sup->up);
if (!rc && sups->sdt_sem_address) {
sup->sdt_sem_address = relocation + sups->sdt_sem_address;
_stp_warn ("u*probe failed %s[%d] '%s' addr %p rc %d\n", tsk->comm, tsk->tgid, sups->pp, (void*)(relocation + sups->address), rc);
atomic_inc (& skipped_count_uprobe_reg);
if (unlikely (atomic_inc_return (& skipped_count) > MAXSKIPPED)) {
static int stap_uprobe_change_minus (struct task_struct *tsk, unsigned long relocation, unsigned long length, const struct stap_uprobe_tf *stf) {
struct stap_uprobe_spec *sups;
sups = (struct stap_uprobe_spec*) & stap_uprobe_specs[sup->spec_index];
if (sups->return_p && sup->urp.u.pid == tsk->tgid && 
sup->urp.u.vaddr >= relocation && sup->urp.u.vaddr < relocation+length) {
_stp_dbug (__FUNCTION__,__LINE__, "-uretprobe spec %d idx %d process %s[%d] addr %p pp %s\n", 
sup->spec_index, i, tsk->comm, tsk->tgid, (void*) sup->urp.u.vaddr, sups->pp);
#if (UPROBES_API_VERSION >= 2)
} else if (!sups->return_p && sup->up.pid == tsk->tgid && 
sup->up.vaddr >= relocation && sup->up.vaddr < relocation+length) {
_stp_dbug (__FUNCTION__,__LINE__, "-uprobe spec %d idx %d process %s[%d] reloc %p pp %s\n", 
sup->spec_index, i, tsk->comm, tsk->tgid, (void*) sup->up.vaddr, sups->pp);
static int stap_uprobe_process_found (struct stap_task_finder_target *tgt, struct task_struct *tsk, int register_p, int process_p) {
const struct stap_uprobe_tf *stf = container_of(tgt, struct stap_uprobe_tf, finder);
_stp_dbug (__FUNCTION__,__LINE__, "%cproc pid %d stf %p %p path %s\n", register_p?'+':'-', tsk->tgid, tgt, stf, stf->pathname);
return stap_uprobe_change_plus (tsk, 0, TASK_SIZE, stf);
return stap_uprobe_change_minus (tsk, 0, TASK_SIZE, stf);
static int stap_uprobe_mmap_found (struct stap_task_finder_target *tgt, struct task_struct *tsk, char *path, unsigned long addr, unsigned long length, unsigned long offset, unsigned long vm_flags) {
if (path == NULL || strcmp (path, stf->pathname)) return 0;
if (!(vm_flags & VM_EXEC)) return 0;
_stp_dbug (__FUNCTION__,__LINE__, "+mmap pid %d path %s addr %p length %u offset %p stf %p %p path %s\n", 
tsk->tgid, path, (void *) addr, (unsigned)length, (void*) offset, tgt, stf, stf->pathname);
return stap_uprobe_change_plus (tsk, addr, length, stf);
static int stap_uprobe_munmap_found (struct stap_task_finder_target *tgt, struct task_struct *tsk, unsigned long addr, unsigned long length) {
_stp_dbug (__FUNCTION__,__LINE__, "-mmap pid %d addr %p length %lu stf %p %p path %s\n", 
tsk->tgid, (void *) addr, length, tgt, stf, stf->pathname);
return stap_uprobe_change_minus (tsk, addr, length, stf);
e->base_name.size() > 0 && e->base_name[0] == '$'
write to target variable not permitted
write to target variable not permitted in .return probes
cannot write to context variable
Bad $context variable being substituted with literal 0
!have_reg_args || (arg_count >= 0 && arg_count <= 10)
unable to find tracepoint variable '
write to tracepoint variable '
cannot take address of tracepoint variable
virtual update_visitor::~update_visitor()
virtual void uprobe_builder::build(systemtap_session&, probe*, probe_point*, const literal_map_t&, std::vector<derived_probe*, std::allocator<derived_probe*> >&)
virtual void tracepoint_builder::build(systemtap_session&, probe*, probe_point*, const literal_map_t&, std::vector<derived_probe*, std::allocator<derived_probe*> >&)
int query_module(Dwfl_Module*, void**, const char*, Dwarf_Addr, void*)
Dwarf_Addr lookup_symbol_address(Dwfl_Module*, const char*)
int tracepoint_query::handle_query_func(Dwarf_Die*)
T* update_visitor::require(T*, bool) [with T = statement]
virtual void tracepoint_var_expanding_visitor::visit_target_symbol(target_symbol*)
void tracepoint_var_expanding_visitor::visit_target_symbol_context(target_symbol*)
T* update_visitor::require(T*, bool) [with T = target_symbol]
void tracepoint_var_expanding_visitor::visit_target_symbol_arg(target_symbol*)
T* update_visitor::require(T*, bool) [with T = expression]
virtual void kprobe_derived_probe_group::emit_module_decls(systemtap_session&)
void translator_output::assert_0_indent()
void module_info::get_symtab(dwarf_query*)
info_status symbol_table::get_from_elf()
bool sdt_query::init_probe_scn()
sdt_var_expanding_visitor::sdt_var_expanding_visitor(std::string&, std::string&, int, bool, bool)
sdt_query::sdt_query(probe*, probe_point*, dwflpp&, const literal_map_t&, std::vector<derived_probe*, std::allocator<derived_probe*> >&)
virtual void dwarf_derived_probe_group::emit_module_decls(systemtap_session&)
dwarf_derived_probe::dwarf_derived_probe(const std::string&, const std::string&, int, const std::string&, const std::string&, Dwarf_Addr, Dwarf_Addr, dwarf_query&, Dwarf_Die*)
virtual void dwarf_cast_expanding_visitor::visit_cast_op(cast_op*)
virtual void dwarf_var_expanding_visitor::visit_target_symbol(target_symbol*)
virtual void var_expanding_visitor::visit_assignment(assignment*)
void dwarf_query::add_probe_point(const std::string&, const char*, int, Dwarf_Die*, Dwarf_Addr)
void dwarf_query::query_module_symtab()
void dwarf_query::query_module_dwarf()
int query_cu(Dwarf_Die*, void*)
int query_dwarf_func(Dwarf_Die*, base_query*)
int query_dwarf_inline_instance(Dwarf_Die*, void*)
base_query::base_query(dwflpp&, const literal_map_t&)
18tracepoint_builder
16tracepoint_query
32tracepoint_var_expanding_visitor
30tracepoint_derived_probe_group
24tracepoint_derived_probe
14kprobe_builder
26kprobe_derived_probe_group
20kprobe_derived_probe
26uprobe_derived_probe_group
9sdt_query
25sdt_var_expanding_visitor
28dwarf_cast_expanding_visitor
16dwarf_cast_query
27dwarf_var_expanding_visitor
13dwarf_builder
11dwarf_query
25dwarf_derived_probe_group
20uprobe_derived_probe
19dwarf_derived_probe
21var_expanding_visitor
10base_query
11generic_dpgI24tracepoint_derived_probeE
19derived_probe_group
11generic_dpgI20uprobe_derived_probeE
14uprobe_builder
A > /dev/null 2>&1
; then 
echo "#define 
; fi >> $@
ARCH
KBUILD_EXTMOD
CROSS_COMPILE
KBUILD_IMAGE
KCONFIG_CONFIG
INSTALL_PATH
unsetenv failed: 
CCACHE_DISABLE
 V=1
 -s --no-print-directory
2.6.29
 >/dev/null
SYSTEMTAP_STAPRUN
/usr/bin/staprun
/typequery_umod_
 -xc /dev/null -include 
 >/dev/null 2>&1
Pass 4, preamble: 
/uprobes
 uprobes.ko
make -q -C 
As root, run "make -C 
tracequery_kmod_
/Makefile
obj-m := 
#ifdef CONFIG_TRACEPOINTS
#include <linux/tracepoint.h>
#undef DECLARE_TRACE
#undef DEFINE_TRACE
make -C '
 M='
' modules
 ARCH=
/Module.symvers
uprobes rebuild rc=
/Module.symvers 
/bin/cp 
set -x;
stap_check_gcc = $(shell 
stap_check_build = $(shell 
 if $(CHECK_BUILD) $(1) 
SYSTEMTAP_RUNTIME = "
EXTRA_CFLAGS
STAPCONF_HEADER := 
: $(STAPCONF_HEADER)
$(STAPCONF_HEADER):
	@echo -n > $@
autoconf-hrtimer-rel.c
STAPCONF_INODE_PRIVATE
autoconf-inode-private.c
STAPCONF_CONSTANT_TSC
autoconf-constant-tsc.c
STAPCONF_TSC_KHZ
autoconf-tsc-khz.c
STAPCONF_KTIME_GET_REAL
autoconf-ktime-get-real.c
STAPCONF_X86_UNIREGS
autoconf-x86-uniregs.c
STAPCONF_NAMEIDATA_CLEANUP
autoconf-nameidata.c
STAPCONF_UNREGISTER_KPROBES
autoconf-unregister-kprobes.c
STAPCONF_REAL_PARENT
autoconf-real-parent.c
STAPCONF_LINUX_UACCESS_H
autoconf-uaccess.c
STAPCONF_ONEACHCPU_RETRY
autoconf-oneachcpu-retry.c
STAPCONF_DPATH_PATH
autoconf-dpath-path.c
STAPCONF_SYNCHRONIZE_SCHED
autoconf-synchronize-sched.c
STAPCONF_TASK_UID
autoconf-task-uid.c
STAPCONF_VM_AREA
autoconf-vm-area.c
STAPCONF_PROCFS_OWNER
autoconf-procfs-owner.c
STAPCONF_ALLOC_PERCPU_ALIGN
autoconf-alloc-percpu-align.c
STAPCONF_X86_GS
autoconf-x86-gs.c
STAPCONF_GRSECURITY
autoconf-grsecurity.c
STAPCONF_KERNEL_STACKTRACE
autoconf-save-stack-trace.c
STAPCONF_ASM_SYSCALL_H
autoconf-asm-syscall.c
STAPCONF_RING_BUFFER_FLAGS
autoconf-ring_buffer-flags.c
EXTRA_CFLAGS += -D 
EXTRA_CFLAGS += -I"
Module directory 
 check failed: 
 -C "
make
 M="
typequery_kmod_
CFLAGS_
.o := -include 
if $(CHECK_BUILD) $(SYSTEMTAP_RUNTIME)/
gcc -shared -g -fno-eliminate-unused-debug-types -o 
verifying that SystemTap's version of uprobes is up to date.
SystemTap's version of uprobes is out of date.
Warning: failed to create directory for querying tracepoints.
EXTRA_CFLAGS := -g -Wno-implicit-function-declaration
#define DECLARE_TRACE(name, proto, args) \
  void stapprobe_##name(proto) {}
#define DEFINE_TRACE(name, proto, args) \
  DECLARE_TRACE(name, TPPROTO(proto), TPARGS(args))
#endif /* CONFIG_TRACEPOINTS */
/bin/grep -q unregister_uprobe 
(re)building SystemTap's version of uprobes.
_KBUILD_CFLAGS := $(call flags,KBUILD_CFLAGS)
 if $(CC) $(1) -S -o /dev/null -xc /dev/null > /dev/null 2>&1; then echo "$(1)"; else echo "$(2)"; fi)
CHECK_BUILD := $(CC) $(KBUILD_CPPFLAGS) $(CPPFLAGS) $(LINUXINCLUDE) $(_KBUILD_CFLAGS) $(CFLAGS_KERNEL) $(EXTRA_CFLAGS) $(CFLAGS) -DKBUILD_BASENAME=\"
\" -Werror -S -o /dev/null -xc 
 ; then echo "$(2)"; else echo "$(3)"; fi)
 += -Iinclude2/asm/mach-default
autoconf-hrtimer-getset-expires.c
 += -include $(STAPCONF_HEADER)
EXTRA_CFLAGS += -ftime-report -Q
EXTRA_CFLAGS += -freorder-blocks
EXTRA_CFLAGS += $(call cc-option,-Wframe-larger-than=600)
EXTRA_CFLAGS += -Wno-unused -Werror
Make sure kernel devel is installed.
Warning: failed to create directory for querying types.
EXTRA_CFLAGS := -g -fno-eliminate-unused-debug-types
%*s%s %s;
%*s{ // synthesized
%*s{ // DWARF expression:
 %#x
(%ld)
(%ld,%ld)
%*s%s = fetch_register (%u);
loc2c.c
%*s{
%*s%s s%u
, s%u
%s%*s%s = s%u;
%*suint%lu_t %s;
frame_base
%s%*s}
<anonymous>
%#lxUL
%*sunion {
%*schar bytes[%lu];
%*sstruct {
%*suint%lu_t p%lu;
%*suint%lu_t whole;
%*s} u;
%*scontainer_addr = addr;
container_addr
%*saddr = %s;
%*saddr += %s * %luUL;
%*saddr += %luUL * %luUL;
%*su.whole = %s;
store_deref (%lu, addr, %s); 
store_register (%u, %s);
%*s%s = u.whole;
%*su.bytes[%zu] = %#x;
%sint%u_t value = 
deref (%lu, addr);
deref (sizeof %s, addr);
fetch_register (%u);
%s = value; 
%*s%s = addr;
%*ss%u = addr;
%*ss%u = s%u;
%*s/* drop s%u*/
invalid skip target
%*ss%u = deref (%luUL, s%u);
%*ss%u = 
%*ss%u = %ldL;
%*ss%u = %s (s%u);
op_abs
%*ss%u = s%u %s s%u;
uintptr_t
%*ss%u = s%u + %luUL;
%*ss%u = frame_base + %ldL;
stack underflow
tos == 0
XXX DW_OP_push_object_address
unrecognized operation
multiple values left on stack
%*saddr += %ldL
register
DW_OP_piece
cannot handle offset into register in fetch
loc->type == loc_address || loc->type == loc_value
cannot get bit field parameters: %s
dwarf_tag (typedie) == DW_TAG_base_type || dwarf_tag (typedie) == DW_TAG_enumeration_type
cannot get byte_size attribute for type %s: %s
%*ss%u = fetch_register (%d);
%*s} pieces __attribute__ ((packed));
%*saddr = container_addr + %luUL;
stack value too big for fetch ???
single register too big for fetch/store ???
discontiguify of noncontiguous location not supported
cannot determine CU address size from %s: %s
dwarf_tag (typedie) == DW_TAG_array_type || dwarf_tag (typedie) == DW_TAG_pointer_type
cannot get byte_stride attribute array type %s: %s
cannot get element type of array type %s: %s
cannot get inner type of type %s: %s
cannot get byte_size attribute for array element type %s: %s
confused about array element size
cannot dynamically index noncontiguous array
constant index is outside noncontiguous array
noncontiguous array splits elements
cannot index array stored in a register
constant index is outside array held in register
cannot index into constant value
constant index is outside constant array value
cannot index into computed value
store_deref (sizeof %s, addr, %s); 
cannot handle offset into register in store
noncontiguous location for base store
location is computed value, cannot store
location is constant value, cannot store
store is larger than base integer types
dwarf_tag (typedie) == DW_TAG_pointer_type
noncontiguous location for base fetch
fetch is larger than base integer types
dwarf_tag (typedie) == DW_TAG_pointer_type || dwarf_tag (typedie) == DW_TAG_reference_type || dwarf_tag (typedie) == DW_TAG_rvalue_reference_type
cannot take the address of a bit field
cannot take address of object in register
cannot take address of noncontiguous object
cannot take address of computed value
cannot take address of constant value
%*sstore_bitfield (tmp, %s, %lu, %lu);
%*sfetch_bitfield (%s, tmp, %lu, %lu);
operations follow DW_OP_stack_value
operations follow DW_OP_implicit_value
%*ss%u = s%u, s%u = s%u, s%u = s%u;
%*ss%u = s%u, s%u = s%u, s%u = s%u, s%u = s%u;
conditional branches not supported
%*ss%u = deref (sizeof (void *), s%u);
%*ss%u = xderef (sizeof (void *), s%u, s%u);
%*ss%u = xderef (%luUL, s%u, s%u);
%*ss%u = (%s) s%u >> (%s)s%u;
%*ss%u = fetch_register (%u) + %ldL;
DW_OP_fbreg from DW_AT_frame_base
DW_OP_piece left multiple values on stack
register value must stand alone in location expression
DW_OP_stack_value left multiple values on stack
DW_OP_implicit_value used in invalid context (no DWARF attribute, ABI return value location?)
DW_OP_implicit_value follows stack operations
dwarf_getlocation_implicit_value failed
DW_OP_call_frame_cfa while processing frame base
DW_OP_call_frame_cfa not expected outside DW_AT_frame_base
extra operations after last DW_OP_piece
%s in DWARF expression [%Zu] at %lu (%#x: %ld, %ld)
required DW_AT_frame_base attribute not supplied
dwarf_getlocation_addr (form %#x): %s
DW_AT_frame_base not accessible at this address
No cfa_ops supplied, but needed by DW_OP_call_frame_cfa
static calculation depends on load-time address
offset outside available pieces
offset outside available constant block
relative expression computed constant
cannot handle location expression
emit_loc_address
c_translate_array
c_translate_pointer_store
c_translate_pointer
base_byte_size
translate
/.config
/.version
/include/linux/compile.h
/include/linux/version.h
/include/linux/utsrelease.h
/proc/self/exe
SYSTEMTAP_NLEVELS
/typequery_
/tracequery_
cache_mb_limit
Cache limit file 
 missing, creating default.
/*/*.ko
/*/*.so
/*/*.h
Pass 3: using cached 
Pass 4: using cached 
Cache cleaning successful, removed entries: 
Cache cleaning skipped, no cache path.
'"'"'
.XXXXXX
(not-a-git-repository)
/.git/
git --git-dir="
" rev-parse HEAD 2>/dev/null
Running 
/bin/sh
Spawn waitpid result (0x
Spawn waitpid error (
Spawn error (
remove returned 0
Unable to determine home directory
SELECT name FROM sqlite_master 
insert or ignore into counts values ('
update counts set compiled=compiled+
create table counts (file text, line integer, col integer, type text, name text, parent text, compiled integer, executed integer)
create unique index tokens on counts (file, line, col, type, name)
Error in statement: 
WHERE type='table' AND name='
', '
'0', '0'); 
 where (
file=='
' and 
line=='
col=='
type=='
name=='
'0', '0')
---- used probes-----
probe: 
unused_local: 
---- unused probes----- 
---- used functions----- 
---- unused functions----- 
unused_function: 
---- used globals----- 
globals: 
---- unused globals----- 
WHERE type='index' AND name='
Can't open database: 
counts
tokens
commit
libdw failure (
libdwfl failure (
enum 
class 
{...}
__va_list_tag
va_list
 const
 volatile
/* ---- begin/end/error probes ---- */
static void enter_be_probe (struct stap_be_probe *stp) {
struct stap_be_probe* stp = & stap_be_probes [i];
enter_be_probe (stp); /* rc = 0 */
never
STAP_SESSION_STARTING
STAP_SESSION_STOPPING
STAP_SESSION_ERROR
static struct stap_be_probe {
void (*ph)(struct context*);
const char* pp;
int state, type;
} stap_be_probes[] = {
 .state=
 .type=
stp->pp
stp->state
(*stp->ph) (c);
if (stp->type == 
enter_be_probe (stp);
22be_derived_probe_group
16be_derived_probe
11generic_dpgI16be_derived_probeE
10be_builder
13never_builder
19never_derived_probe
_stp_close_procfs();
procfs
tapset-procfs.cxx
$value
_procfs_value_get
_procfs_value_set
CONTEXT->data
))->count); /* pure */
    data->count = bytes;
    }
        bytes = data->count;
      bytes -= data->off;
    else {
      bytes = 0;
    if (data->off >= bytes)
int bytes = 0;
command
need read/write component
  unsigned long count;
  off_t off;
  const char *buffer;
struct _stp_procfs_data {
/* ---- procfs probes ---- */
#include "procfs.c"
const char *path;
const char *read_pp;
const char *write_pp;
} stap_procfs_probes[] = {
 .path=
 .read_pp=
 .read_ph=&
 .read_pp=NULL,
 .read_ph=NULL,
 .write_pp=
 .write_ph=&
 .write_pp=NULL,
 .write_ph=NULL
spp->read_pp
pdata.buffer = page;
pdata.off = off;
pdata.count = count;
if (c->data == NULL)
c->data = &pdata;
(*spp->read_ph) (c);
c->data = NULL;
if (pdata.count == 0)
*eof = 1;
return pdata.count;
spp->write_pp
count = MAXSTRINGLEN - 1;
pdata.buffer = buffer;
(*spp->write_ph) (c);
return count;
for (i = 0; i < 
if (spp->read_pp)
probe_point = spp->read_pp;
probe_point = spp->write_pp;
if (spp->write_pp)
invalid target symbol for procfs probe, $value expected
procfs $value variable is read-only in a procfs write probe
procfs $value variable cannot be read in a procfs read probe
cannot take address of procfs variable
))->buffer, ((struct _stp_procfs_data *)(
_stp_copy_from_user(THIS->__retvalue, ((struct _stp_procfs_data *)(
      memcpy((void *)data->buffer, THIS->value + data->off, bytes);
      if (bytes > data->count)
    bytes = strnlen(THIS->value, MAXSTRINGLEN - 1);
    struct _stp_procfs_data *data = (struct _stp_procfs_data *)(
procfs path cannot start with a '/'
procfs path component cannot be empty
procfs path cannot be relative (and contain '.' or '..')
procfs path cannot end with a '/'
only one write procfs probe can exist for procfs path "
only one read procfs probe can exist for procfs path "
static struct stap_procfs_probe {
void (*read_ph) (struct context*);
void (*write_ph) (struct context*);
static int _stp_procfs_read(char *page, char **start, off_t off, int count, int *eof, void *data) {
struct stap_procfs_probe *spp = (struct stap_procfs_probe *)data;
struct _stp_procfs_data pdata;
static int _stp_procfs_write(struct file *file, const char *buffer, unsigned long count, void *data) {
if (count > (MAXSTRINGLEN - 1))
struct stap_procfs_probe *spp = &stap_procfs_probes[i];
rc = _stp_create_procfs(spp->path, i);
_stp_procfs_files[i]->read_proc = &_stp_procfs_read;
_stp_procfs_files[i]->read_proc = NULL;
_stp_procfs_files[i]->write_proc = &_stp_procfs_write;
_stp_procfs_files[i]->write_proc = NULL;
_stp_procfs_files[i]->data = spp;
14procfs_builder
28procfs_var_expanding_visitor
26procfs_derived_probe_group
20procfs_derived_probe
11generic_dpgI20procfs_derived_probeE
virtual update_visitor::~update_visitor()
virtual void procfs_var_expanding_visitor::visit_target_symbol(target_symbol*)
T* update_visitor::require(T*, bool) [with T = statement]
timer
unsigned long nsecs;
int64_t i = stp->intrv;
if (stp->rnd != 0) {
int64_t r;
r -= stp->rnd;
i += r;
i = stap_hrtimer_resolution;
ktime_set(i, nsecs);
struct timespec res;
probe_point = stp->pp;
, HRTIMER_MODE_REL);
unsigned i = stp->intrv;
if (stp->rnd != 0)
stp->timer_list.data = i;
randomize
msec
usec
nsec
jiffies
timer.profile
if (c->last_error == NULL) 
(void) self; (void) val;
expect single probe point
interval value out of range (
unrecognized timer variant
2.6.17
struct hrtimer hrtimer;
int64_t intrv, rnd;
} stap_hrtimer_probes [
 .intrv=
 .rnd=
#ifdef STAPCONF_HRTIMER_REL
static int 
static enum hrtimer_restart 
int rc = HRTIMER_NORESTART;
rc = HRTIMER_RESTART;
/* ---- timer probes ---- */
struct timer_list timer_list;
unsigned intrv, ms, rnd;
} stap_timer_probes [
 .ms=
probe_point = "timer.profile";
#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,10)
rc = register_profile_notifier (& stap_profile_notifier);
rc = register_timer_hook (& enter_profile_probes);
unregister_profile_notifier (& stap_profile_notifier);
unregister_timer_hook (& enter_profile_probes);
hrtimer_cancel (& stap_hrtimer_probes[i].hrtimer);
del_timer_sync (& stap_timer_probes[i].timer_list);
get_random_bytes(&r, sizeof(r));
r &= ((uint64_t)1 << (8*sizeof(r) - 1)) - 1;
r = _stp_mod64(NULL, r, (2*stp->rnd+1));
if (unlikely(i < stap_hrtimer_resolution))
nsecs = do_div(i, NSEC_PER_SEC);
hrtimer_get_res (CLOCK_MONOTONIC, &res);
stap_hrtimer_resolution = timespec_to_ns (&res);
struct stap_hrtimer_probe* stp = & stap_hrtimer_probes [i];
hrtimer_init (& stp->hrtimer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
stp->hrtimer.function = & enter_hrtimer_probe;
(void) hrtimer_start (& stp->hrtimer, 
i += _stp_random_pm(stp->rnd);
stp->ms ? msecs_to_jiffies(i) : i;
struct stap_timer_probe* stp = & stap_timer_probes [i];
init_timer (& stp->timer_list);
stp->timer_list.function = & enter_timer_probe;
stp->timer_list.expires = jiffies + 
add_timer (& stp->timer_list);
/* ---- profile probes ---- */
static void enter_all_profile_probes (struct pt_regs *regs) {
static int enter_profile_probes (struct notifier_block *self,
 unsigned long val, void *data) {
enter_all_profile_probes ((struct pt_regs *) data);
struct notifier_block stap_profile_notifier = {
 .notifier_call = & enter_profile_probes };
static int enter_profile_probes (struct pt_regs *regs) {
enter_all_profile_probes (regs);
invalid interval for jiffies timer
invalid randomize for jiffies timer
randomization value out of range
frequency must be greater than 0
/* ---- hrtimer probes ---- */
static unsigned long stap_hrtimer_resolution;
static struct stap_hrtimer_probe {
#ifndef STAPCONF_HRTIMER_GETSET_EXPIRES
#define hrtimer_get_expires(timer) ((timer)->expires)
#define hrtimer_set_expires(timer, time) (void)((timer)->expires = (time))
#define HRTIMER_MODE_REL HRTIMER_REL
enter_hrtimer_probe (struct hrtimer *timer) {
struct stap_hrtimer_probe *stp = container_of(timer, struct stap_hrtimer_probe, hrtimer);
if ((atomic_read (&session_state) == STAP_SESSION_STARTING) ||
    (atomic_read (&session_state) == STAP_SESSION_RUNNING)) {
hrtimer_set_expires(timer, ktime_add (hrtimer_get_expires(timer),
static struct stap_timer_probe {
static void enter_timer_probe (unsigned long val) {
struct stap_timer_probe* stp = & stap_timer_probes [val];
    (atomic_read (&session_state) == STAP_SESSION_RUNNING))
mod_timer (& stp->timer_list, jiffies + 
13timer_builder
27profile_derived_probe_group
21profile_derived_probe
27hrtimer_derived_probe_group
21hrtimer_derived_probe
25timer_derived_probe_group
19timer_derived_probe
11generic_dpgI21profile_derived_probeE
11generic_dpgI21hrtimer_derived_probeE
11generic_dpgI19timer_derived_probeE
perfmon-based probe
perfmon
incomplete
perfmon requires an event
tapset-perfmon.cxx
_perfmon_tvar_get
$counter
].reg_num;
writes to $counter not permitted
target variables not available to perfmon probes
cannot take address of perfmon variable
THIS->__retvalue = _pfm_pmd_x[
21perfmon_derived_probe
29perfmon_var_expanding_visitor
virtual update_visitor::~update_visitor()
T* update_visitor::require(T*, bool) [with T = statement]
virtual void perfmon_var_expanding_visitor::visit_target_symbol(target_symbol*)
15perfmon_builder
/* init marker probes */
probe_point = smp->pp;
for (j=i-1; j>=0; j--) {
 __mark_arg
mark_builder releasing cache
char *
long long
short
#include <linux/marker.h>
/* ---- marker probes ---- */
const char * const name;
const char * const format;
const char * const pp;
} stap_marker_probes [
 .name=
 .format=
smp->pp
c->marker_name = smp->name;
c->mark_va_list = args;
(*smp->ph) (c);
c->mark_va_list = NULL;
marker-based 
 mark=
 fmt='
:long
:string
:unknown
l->__mark_arg
 = va_arg(*c->mark_va_list, 
deref_string (
, tmp_str, MAXSTRINGLEN); }
deref_fault: ;
int64_t 
string_t 
write to marker '
marker
$format
_mark_format_get
tapset-mark.cxx
has_mark_str
/Module.markers
 cannot be opened: 
/* deregister marker probes */
struct stap_marker_probe *smp = &stap_marker_probes[i];
marker_probe_unregister(smp->name, enter_marker_probe, smp);
rc = marker_probe_register(smp->name, smp->format, enter_marker_probe, smp);
struct stap_marker_probe *smp2 = &stap_marker_probes[j];
marker_probe_unregister(smp2->name, enter_marker_probe, smp2);
#error "Need CONFIG_MARKERS!"
#if ! defined(CONFIG_MARKERS)
static struct stap_marker_probe {
void (* const ph) (struct context *);
static void enter_marker_probe (void *probe_data, void *call_data, const char *fmt, va_list *args) {
struct stap_marker_probe *smp = (struct stap_marker_probe *)probe_data;
c->marker_format = smp->format;
 tmp_str = va_arg(*c->mark_va_list, 
invalid marker argument number
write to marker parameter not permitted
cannot take address of marker variable
invalid target symbol for marker, $argN, $name, $format, $$parms or $$vars expected
virtual update_visitor::~update_visitor()
virtual void mark_builder::build(systemtap_session&, probe*, probe_point*, const literal_map_t&, std::vector<derived_probe*, std::allocator<derived_probe*> >&)
T* update_visitor::require(T*, bool) [with T = statement]
virtual void mark_var_expanding_visitor::visit_target_symbol(target_symbol*)
void mark_var_expanding_visitor::visit_target_symbol_context(target_symbol*)
T* update_visitor::require(T*, bool) [with T = target_symbol]
12mark_builder
26mark_var_expanding_visitor
24mark_derived_probe_group
18mark_derived_probe
11generic_dpgI18mark_derived_probeE
 .callback=&_stp_itrace_probe_cb,
struct stap_itrace_probe *p = &stap_itrace_probes[i];
if (!arch_has_single_step()) {
_stp_error ("insn probe init: arch does not support step mode");
if (!p->single_step && !arch_has_block_step()) {
_stp_error ("insn probe init: arch does not support block step mode");
rc = stap_register_task_finder_target(&p->tgt);
static int _stp_itrace_probe_cb(struct stap_task_finder_target *tgt, struct task_struct *tsk, int register_p, int process_p) {
struct stap_itrace_probe *p = container_of(tgt, struct stap_itrace_probe, tgt);
rc = usr_itrace_init(p->single_step, tsk, p);
remove_usr_itrace_info(find_itrace_info(p->tgt.pid));
static struct stap_itrace_probe stap_itrace_probes[] = {
struct stap_task_finder_target tgt;
static void enter_itrace_probe(struct stap_itrace_probe *p, struct pt_regs *regs, void *data);
static void enter_itrace_probe(struct stap_itrace_probe *p, struct pt_regs *regs, void *data) {
insn
block
tapset-itrace.cxx
has_path || has_pid
 .tgt={
 .procname="
 .pid=0,
 .procname=NULL,
 .single_step=
/* ---- itrace probes ---- */
cleanup_usr_itrace();
rc = -EPERM;
c->data = data;
(*p->ph) (c);
if (register_p) 
struct stap_itrace_probe {
int single_step;
#include "itrace.c"
26itrace_derived_probe_group
20itrace_derived_probe
11generic_dpgI20itrace_derived_probeE
14itrace_builder
virtual void itrace_builder::build(systemtap_session&, probe*, probe_point*, const std::map<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, literal*, std::less<std::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::pair<const std::basic_string<char, std::char_traits<char>, std::allocator<char> >, literal*> > >&, std::vector<derived_probe*, std::allocator<derived_probe*> >&)
thread
tapset-utrace.cxx
utrace
_utrace_tvar_
_utrace_tvar_tid
utrace '
' variable is read-only
_utrace_syscall_return
$syscall
unknown target variable
 .mmap_callback=NULL,
 .munmap_callback=NULL,
 .mprotect_callback=NULL,
 .flags=(UDPF_BEGIN),
 .flags=(UDPF_THREAD_BEGIN),
 .flags=(UDPF_END),
 .flags=(UDPF_THREAD_END),
 .flags=(UDPF_SYSCALL),
 .flags=(UDPF_NONE),
 .ops={ },
 .events=0,
bad utrace probe flag
 .engine_attached=0,
 .tsk=0,
/* ---- utrace probes ---- */
probe_point = p->pp;
#ifdef UTRACE_ORIG_VERSION
debug_task_finder_detach();
return UTRACE_DETACH;
return UTRACE_RESUME;
if (register_p) {
switch (p->flags) {
case UDPF_BEGIN:
if (process_p) {
case UDPF_THREAD_BEGIN:
if (! process_p) {
case UDPF_END:
case UDPF_THREAD_END:
case UDPF_SYSCALL:
case UDPF_SYSCALL_RETURN:
p->engine_attached = 1;
default:
size_t sdt_semaphore;
p->tsk = tsk;
sdt_semaphore += 1;
UDPF_NONE,
UDPF_BEGIN,
UDPF_END,
UDPF_THREAD_BEGIN,
UDPF_THREAD_END,
UDPF_SYSCALL,
UDPF_SYSCALL_RETURN,
UDPF_NFLAGS
struct stap_utrace_probe {
struct utrace_engine_ops ops;
unsigned long events;
int engine_attached;
if (p->engine_attached) {
if (p->sdt_sem_address) {
sdt_semaphore -= 1;
process pid must be greater than 1
only "process(PATH_OR_PID).syscall" support $argN or $$parms.
invalid syscall argument number (1-6)
utrace '$argN' variable is read-only
only "process(PATH_OR_PID).syscall.return" support $return.
only "process(PATH_OR_PID).syscall" and "process(PATH_OR_PID).syscall.return" probes support target symbols
cannot take address of utrace variable
invalid target symbol for utrace probe, $syscall, $return, $argN or $$parms expected
 .callback=&_stp_utrace_probe_cb,
 .ops={ .report_syscall_entry=stap_utrace_probe_syscall,  .report_death=stap_utrace_task_finder_report_death },
 .events=(UTRACE_EVENT(SYSCALL_ENTRY)|UTRACE_EVENT(DEATH)),
 .flags=(UDPF_SYSCALL_RETURN),
 .ops={ .report_syscall_exit=stap_utrace_probe_syscall, .report_death=stap_utrace_task_finder_report_death },
 .events=(UTRACE_EVENT(SYSCALL_EXIT)|UTRACE_EVENT(DEATH)),
 .sdt_sem_address=(unsigned long)0x0,
for (i=0; i<ARRAY_SIZE(stap_utrace_probes); i++) {
struct stap_utrace_probe *p = &stap_utrace_probes[i];
static void stap_utrace_probe_handler(struct task_struct *tsk, struct stap_utrace_probe *p) {
static u32 stap_utrace_probe_syscall(struct utrace_attached_engine *engine, struct task_struct *tsk, struct pt_regs *regs) {
static u32 stap_utrace_probe_syscall(enum utrace_resume_action action, struct utrace_attached_engine *engine, struct task_struct *tsk, struct pt_regs *regs) {
struct stap_utrace_probe *p = (struct stap_utrace_probe *)engine->data;
if ((atomic_read (&session_state) != STAP_SESSION_STARTING) && (atomic_read (&session_state) != STAP_SESSION_RUNNING)) {
static int _stp_utrace_probe_cb(struct stap_task_finder_target *tgt, struct task_struct *tsk, int register_p, int process_p) {
struct stap_utrace_probe *p = container_of(tgt, struct stap_utrace_probe, tgt);
struct utrace_attached_engine *engine;
stap_utrace_probe_handler(tsk, p);
rc = stap_utrace_attach(tsk, &p->ops, p, p->events);
_stp_error("unhandled flag value %d at %s:%d", p->flags, __FUNCTION__, __LINE__);
if (p->sdt_sem_address != 0) {
__access_process_vm (tsk, p->sdt_sem_address, &sdt_semaphore, sizeof (sdt_semaphore), 0);
__access_process_vm (tsk, p->sdt_sem_address, &sdt_semaphore, sizeof (sdt_semaphore), 1);
stap_utrace_detach(tsk, &p->ops);
static struct stap_utrace_probe stap_utrace_probes[] = {
enum utrace_derived_probe_flags {
enum utrace_derived_probe_flags flags;
stap_utrace_detach_ops(&p->ops);
__access_process_vm (p->tsk, p->sdt_sem_address, &sdt_semaphore, sizeof (sdt_semaphore), 0);
__access_process_vm (p->tsk, p->sdt_sem_address, &sdt_semaphore, sizeof (sdt_semaphore), 1);
virtual update_visitor::~update_visitor()
virtual void utrace_var_expanding_visitor::visit_target_symbol(target_symbol*)
utrace_derived_probe::utrace_derived_probe(systemtap_session&, probe*, probe_point*, bool, std::string&, int64_t, utrace_derived_probe_flags)
T* update_visitor::require(T*, bool) [with T = statement]
28utrace_var_expanding_visitor
26utrace_derived_probe_group
20utrace_derived_probe
11generic_dpgI20utrace_derived_probeE
14utrace_builder
/* ---- task finder ---- */
stap_stop_task_finder();
rc = stap_start_task_finder();
31task_finder_derived_probe_group
11generic_dpgI25task_finder_derived_probeE
dwflpp.cxx
<unknown source>
pattern '
matches 
 Error: 
 isn't a struct/class/union
 is empty
module_name == TOK_KERNEL
literal_addr_to_sym_addr 0x
symbias 0x
, dwbias 0x
die parent cache 
 size 
func_is_inline ()
get_cfa_ops @0x
, module_start @0x
got dwarf cfi bias: 0x
dwarf_cfi_addrframe failed: 
got eh cfi bias: 0x
dwfl_module_eh_cfi failed: 
not 
found cfa
cannot find 
 debuginfo
bias == module_bias
no location for field '
dwfl_addrmodule
dwfl_module_info
emit dwarf addr 0x
 => module 
 section 
 relocaddr 0x
dwfl_module_relocation_info
addr; })
function cache 
 hit 
 match 
 vs 
dwarf_getsrclines
dwarf_highpc
prologue searching function '
dwarf_line_t::linesrc
checking line record 0x
prologue found function '
 (naked)
 (tail-call?)
dwarf_getsrcfiles
selected source file '
missing process 
dwfl_report_end
 skipping - init/exit
 skipping - __kprobes
 skipping - blacklisted
cannot get type: 
cannot get type of pointee: 
dwarf_getsrc_file
alternative line 
 rejected: nsrcs=
 accepted: fn=
 accepted: ifn=
dwarf_entrypc
dwarf_getsrc_die
dwarf_lineno
Invalid line range (
, the end line number 
multiple addresses for 
 (try 
global alias cache 
THIS->__retvalue
unsupported type tag 
unsupported type (encoding 
THIS->value
cannot write to array address
cannot write to reference
\.init\.
|\.exit\.
|\.devinit\.
|\.devexit\.
|\.cpuinit\.
|\.cpuexit\.
|\.meminit\.
|\.memexit\.
|arch/.*/kernel/kprobes\.c
|include/asm/io\.h
|include/asm/bitops\.h
|arch/.*/include/asm/io\.h
|drivers/ide/ide-iops\.c
atomic_notifier_call_chain
|default_do_nmi
|__die
|die_nmi
|do_debug
|do_general_protection
|do_int3
|do_IRQ
|do_page_fault
|do_sparc64_fault
|do_trap
|dummy_nmi_callback
|flush_icache_range
|ia64_bad_break
|ia64_do_page_fault
|ia64_fault
|io_check_error
|mem_parity_error
|nmi_watchdog_tick
|notifier_call_chain
|oops_begin
|oops_end
|program_check_exception
|single_step_exception
|sync_regs
|unhandled_fault
|unknown_nmi_error
|.*raw_.*lock.*
|.*read_.*lock.*
|.*write_.*lock.*
|.*spin_.*lock.*
|.*rwlock_.*lock.*
|.*rwsem_.*lock.*
|.*mutex_.*lock.*
|raw_.*
|.*seq_.*lock.*
|atomic_.*
|atomic64_.*
|get_bh
|put_bh
|.*apic.*|.*APIC.*
|.*softirq.*
|.*IRQ.*
|.*_intr.*
|__delay
|.*kernel_text.*
|get_current
|current_.*
|.*exception_tables.*
|.*setup_rt_frame.*
|.*preempt_count.*
|preempt_schedule
do_exit
|sys_exit
|sys_exit_group
|__switch_to
blacklist regexps:
blfn: 
blfn_ret: 
blfile: 
blsection: 
blacklist_func regcomp failed
blacklist_file regcomp failed
missing 
unable to find local '
 near pc 
' in an inlined subroutines
dwarf_ranges
, ignored 
 more
 (skip comdat)
entry-pc lookup (
 dieoffset: 
) = 0x
 (rc 
invalid access '
' vs. 
THIS->index
' for array type
' for 
unresolved 
unable to find member '
cannot find type: 
: unexpected type tag 
cannot get type of field: 
memstream
oversized DWARF stack
if (0) goto deref_fault;
deref_fault:
  goto out;
THIS->pointer
) has no return value
finding location for local '
' near address 0x
, module bias 0x
' (dieoffset: 
offline_search_modname
dwarf_tag(cu) == DW_TAG_compile_unit
 Error in obtaining type attribute for anonymous member at 
mi && mi->name && mi->name == TOK_KERNEL
literal_addr_to_sym_addr ret 0x
dwfl_module_dwarf_cfi failed: 
({ static unsigned long addr = 0; 
if (addr==0) addr = _stp_module_relocate ("%s","%s",%#lx); 
cannot relocate user-space dso (?) address
missing entrypc dwarf line record for function '
 guru mode enabled - ignoring blacklist
 rejected: leaves selected fns
cannot write to member address
cannot take address of bit-field
' is being accessed instead of a member
typetag == DW_TAG_pointer_type
|arch/.*/include/asm/bitops\.h
blacklist_func_ret regcomp failed
blacklist_section regcomp failed
 kernel/module debuginfo under '
not accessible at this address (
dwarf_getlocation_addr failed, 
unable to get die scopes for '
literal_stmt_for_pointer: finding value for 
literal_stmt_for_return: finding return value for 
failed to retrieve return value location for 
failed to retrieve return value type attribute for 
failed to retrieve location attribute for local '
failed to retrieve type attribute for local '
Dwarf_Addr dwflpp::relocate_address(Dwarf_Addr, std::string&)
std::string dwflpp::express_as_string(std::string, std::string, location*)
void dwflpp::translate_final_fetch_or_store(obstack*, location**, Dwarf_Addr, Dwarf_Die*, Dwarf_Attribute*, bool, const target_symbol*, std::string&, std::string&, exp_type&)
Dwarf_Attribute* dwflpp::find_variable_and_frame_base(std::vector<Dwarf_Die, std::allocator<Dwarf_Die> >&, Dwarf_Addr, const std::string&, const target_symbol*, Dwarf_Die*, Dwarf_Attribute*)
void dwflpp::function_line(int*)
void dwflpp::function_file(const char**)
void dwflpp::function_die(Dwarf_Die*)
bool dwflpp::function_entrypc(Dwarf_Addr*)
void dwflpp::resolve_prologue_endings(func_info_map_t&)
void dwflpp::collect_srcfiles_matching(const std::string&, std::set<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::less<std::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::basic_string<char, std::char_traits<char>, std::allocator<char> > > >&)
int dwflpp::iterate_over_globals(int (*)(Dwarf_Die*, void*), void*)
int dwflpp::iterate_over_functions(int (*)(Dwarf_Die*, base_query*), base_query*, const std::string&, bool)
std::vector<Dwarf_Die, std::allocator<Dwarf_Die> > dwflpp::getscopes(Dwarf_Addr)
cu_die_parent_cache_t* dwflpp::get_die_parents()
void dwflpp::iterate_over_inline_instances(int (*)(Dwarf_Die*, void*), void*)
bool dwflpp::func_is_inline()
int dwfl_report_offline_predicate(const char*, const char*)
bool dwflpp::function_name_matches(const std::string&)
Dwarf_Die* dwflpp::query_cu_containing_address(Dwarf_Addr)
void dwflpp::focus_on_function(Dwarf_Die*)
void dwflpp::focus_on_cu(Dwarf_Die*)
void dwflpp::focus_on_module(Dwfl_Module*, module_info*)
Error reading the rpm configuration files
%{sourcerpm}-debuginfo.%{arch}
%{name}-%{version}-%{release}.%{arch}
Missing separate debuginfos, use: debuginfo-install 
Error querying the rpm file `
.src.rpm
zPLR
}(<!
pass0__start
PRB1
pass0__end
PRB1p
pass1a__start
PRB1
pass1b__start
PRB1
pass1__end
PRB1
pass6__start
PRB1
pass6__end
PRB1P
pass2__start
PRB1
pass2__end
PRB1
pass3__start
PRB1
pass3__end
PRB1
pass4__start
PRB1
pass4__end
PRB1X
pass5__start
PRB1
pass5__end
PRB1
cache__clean
PRB1
cache__get
PRB1
cache__add__module
PRB10
cache__add__source
PRB1`
stap_system__start
PRB1
stap_system__spawn
PRB1
stap_system__complete
PRB1
stap.debug
.shstrtab
.interp
.note.ABI-tag
.note.gnu.build-id
.gnu.hash
.dynsym
.dynstr
.gnu.version
.gnu.version_r
.rela.dyn
.rela.plt
.init
.text
.fini
.rodata
.eh_frame_hdr
.eh_frame
.gcc_except_table
.ctors
.dtors
.jcr
.data.rel.ro
.dynamic
.got
.data
.probes
.bss
.gnu_debuglink
