AFS28
__gmon_start__
_ITM_deregisterTMCloneTable
_ITM_registerTMCloneTable
__cxa_finalize
uuid_utoa_r
gf_fop_list
_gf_log_callingfn
call_stub_destroy
iobref_unref
fd_unref
__gf_free
_gf_msg
__stack_chk_fail
__glusterfs_this_location
mem_get0
use_spinlocks
pthread_mutex_init
pthread_spin_lock
pthread_spin_unlock
pthread_spin_init
pthread_mutex_lock
pthread_mutex_unlock
gf_latency_begin
default_readv_cbk
default_fsync_cbk
default_stat_cbk
default_fstat_cbk
default_setattr_cbk
default_fsetattr_cbk
inode_ctx_del2
fd_ctx_del
__vsnprintf_chk
__snprintf_chk
gf_proc_dump_add_section
gf_proc_dump_write
__errno_location
pthread_spin_destroy
mem_put
pthread_mutex_destroy
__inode_ctx_get0
memcpy
default_flush_cbk
strerror
__gf_calloc
gf_latency_end
gettimeofday
inode_unref
uuid_copy
fd_ref
__inode_ctx_set0
__memcpy_chk
iobref_merge
create_frame
memcmp
iobuf_get2
iobref_new
iobref_add
iobuf_unref
iobref_ref
call_resume_keep_stub
call_unwind_error_keep_stub
fop_writev_stub
fop_readv_stub
fop_flush_stub
fop_fsync_stub
fop_stat_stub
fop_fstat_stub
fop_truncate_stub
fop_ftruncate_stub
fop_setattr_stub
fop_fsetattr_stub
fop_lookup_stub
fop_link_stub
fop_fallocate_stub
fop_discard_stub
fop_zerofill_stub
__inode_path
pthread_mutex_trylock
pthread_spin_trylock
xlator_mem_acct_init
reconfigure
xlator_option_reconf_size_uint64
xlator_option_reconf_bool
xlator_option_init_size_uint64
xlator_option_init_bool
fini
options
dumpops
cbks
fops
libglusterfs.so.0
libz.so.1
libm.so.6
libuuid.so.1
librt.so.1
libdl.so.2
libpthread.so.0
libcrypto.so.1.1
libc.so.6
write-behind.so
UUID_1.0
GLIBC_2.14
GLIBC_2.4
GLIBC_2.3.4
GLIBC_2.2.5
AUATUSH
D$H1
)D$ 
)D$0
t$HdH34%(
X[]A\A]
I9D$
AWAVM
AUATI
[]A\A]A^A_
AWAVM
AUATM
t$XL
[]A\A]A^A_
AWAVM
AUATM
[]A\A]A^A_
AWAVM
AUATM
[]A\A]A^A_
AWAVM
AUATI
|$@I
d$hI
D$(H
D$0H
t$xE
T$xL
L$0H
[]A\A]A^A_
AWAVE
AUATI
|$@I
d$hI
D$(H
D$0H
t$hM
L$ H
[]A\A]A^A_
AWAVI
AUATM
[]A\A]A^A_
AWAVI
AUATI
[]A\A]A^A_
AWAVI
AUATI
[]A\A]A^A_
AWAVI
AUATM
[]A\A]A^A_
AWAVI
AUATM
[]A\A]A^A_
AWAVM
AUATI
|$@I
d$hI
D$(H
D$0H
[]A\A]A^A_
AWAVM
AUATI
|$@I
d$hI
D$(H
D$0H
[]A\A]A^A_
AWAVI
AUATI
[]A\A]A^A_
AWAVM
AUATI
|$@I
d$hI
D$(H
D$0H
[]A\A]A^A_
C(H9C(tAH
C8H9C8tAH
CHH9CHtAH
ATUI
\$ L
[]A\
ATUI
[]A\
ATUStcL
[]A\
[]A\
AWAVAUATUSH
[]A\A]A^A_
AUATUSH
[]A\A]
[]A\A]
AWAVAUATI
shE1
[]A\A]A^A_
AWAVAUATA
A8H9A8tHI
t$hI
[]A\A]A^A_
AVATH
ATUH
o8SH
G8H9
C H9
[]A\
ATUSH
CPI9
[]A\
ATUH
StdL
[]A\
[]A\
AWAVAUATUSH
C@A	
[]A\A]A^A_
[]A\A]A^A_
[]A\A]A^A_
[]A\A]A^A_
shH9
EptV
AUATUSH
[]A\A]
AUATUS
]A\A]A^
]A\A]A^
St:H
ATUSf
D$H1
)D$ 
)D$0H)E
D$HdH3
P[]A\
t+H9
WxH)P
tKUSH
tkUSH
AUATUSH
[]A\A]
[]A\A]
tcATUH
AUATA
[]A\A]
[]A\A]
AVAUHc
ATUSH
_`H)wh
[]A\A]A^
tIUSH
AWAVAUATUSH
[]A\A]A^A_
AWAVI
AUAT
<$dH
~xu&
C`Hc
[]A\A]A^A_
AWAVAUATUSH
D$(H
\$ A;
\$ L9
L$(L
ShL;
wsHc
k8t$I
[]A\A]A^A_
[]A\A]A^A_
AWAV
AUATUSH
|$ H
L$ D
@L;d$
AWAVH
[]A\A]A^A_
AWAVL
wHAUATUSf
D$X1
)D$ 
)D$0
)D$@H
E L9
H93|
D$XdH3
h[]A\A]A^A_
AWAVI
AUATUSH
[]A\A]A^A_
L9l$
ATSQ
AWAVI
AUATM
o(USf
D$x1
)D$0H
)D$@
)D$P
)D$`H
D$0H
ulHc
D$$u2H
D$(H
H9Eh~bf.
D$xdH3
[]A\A]A^A_
AVAUI
ATUI
D$H1
)D$ 
)D$0L
D$PI9D$P
L$HdH3
P[]A\A]A^
AWAVAUATUSf
o(dH
)D$ H
)D$0
)D$@
)D$P
)D$`
)D$p
G(H9
AUE1
H;,$
l$`H
T$XH
T$`H
[]A\A]A^A_
AUE1
l$`H
T$(E1
AUATA
E0L9
[]A\A]
AWAVL
xAUATUSH
l$ I
D$81
l$(H
D$8dH3
H[]A\A]A^A_
AWAVAUATUSH
H;Gx
[]A\A]A^A_
AWAVAUATE
t$XL
[]A\A]A^A_
AUUH
AWAVM
AUATE
t$hM
D$hE
shE1
[]A\A]A^A_
t$hM
D$hE
AWAVE
AUATM
t$hH
A[]t
[]A\A]A^A_
t$hL
D$ H
AWAVI
AUATI
shE1
[]A\A]A^A_
D$0A
D$0H
T$0L
D$0H
D$0H
AWAVM
AUATA
shE1
[]A\A]A^A_
AWAVI
AUATI
T$(H
T$(H
[]A\A]A^A_
D$0A
D$0H
T$0L
D$0H
D$0H
AWAVI
AUATI
T$(H
T$(H
[]A\A]A^A_
D$0A
D$0H
T$0L
D$0H
D$0H
AVAUM
ATUI
V(E1
]A\A]A^
[]A\A]A^
AVAUM
ATUI
]A\A]A^
V(E1
]A\A]A^
AWAVM
AUATE
T$(H
T$(H
shE1
[]A\A]A^A_
AWAVM
AUATE
T$(H
T$(H
shE1
[]A\A]A^A_
AWAVI
AUATI
=Eo 
[]A\A]A^A_
=6n 
D$0A
D$0H
T$0L
D$0H
D$0H
AWAVM
AUATI
[]A\A]A^A_
D$HL
AWAVM
AUATI
AZA[t
shE1
[]A\A]A^A_
D$0L
t$XH
AWAVM
AUATI
shE1
[]A\A]A^A_
D$HL
AWAVM
AUATI
D$PH
D$ A
D$0L
[]A\A]A^A_
AUATI
[]A\A]
[]A\A]
AWAVI
AUATUSD
ATSH
t$XL
[]A\A]A^A_
AWAVI
AUATUSD
ATSH
%3[ 
t$XL
[]A\A]A^A_
AWAVM
AUATE
AUUH
t$PH
t$hM
t$hE
[]A\A]A^A_
AWAVE
AUATI
d$`H
t$hL
D$$H
\$(A
[]A\A]A^A_
AWAVM
AUATM
[]A\A]A^A_
AWAV
AUATI
CPH9CP
[]A\A]A^A_
AVAUH
\$PH
)D$ 
)D$0
)D$@
-8M 
I;|$
[]A\A]A^
ATUH
[]A\
write-behind.c
wb-request
FIRST_CHILD(this)->fops->link
stack-trace
wb_writev_cbk
default_readv_cbk
default_fsync_cbk
default_stat_cbk
default_fstat_cbk
wb_truncate_cbk
wb_ftruncate_cbk
default_setattr_cbk
default_fsetattr_cbk
wb_lookup_cbk
wb_readdirp_cbk
%s.%s
write-behind
invalid argument: this
invalid argument: conf
priv
aggregate_size
window_size
flush_behind
trickling_writes
invalid argument: req
refcount(%d) is < 0
invalid argument: inode
default_flush_cbk
gf_common_mt_groups_t
stack
gettimeofday () failed.
wb_flush_bg_cbk
!frame
invalid argument: wb_inode
invalid argument: stub
gf_wb_mt_wb_request_t
gf_wb_mt_wb_inode_t
wb_fulfill_cbk
processing queues
Assertion failed: wb_inode
Assertion failed: postbuf
FIRST_CHILD(this)->fops->open
unique
refcount
wound
generation-number
req->op_ret
req->op_errno
sync-attempts
sync-in-progress
offset
lied
append
fulfilled
path
gfid
window_conf
window_current
transit-size
dontsync
Memory accounting initfailed
cache-size
flush-behind
trickling-writes
strict-O_DIRECT
strict-write-ordering
gf_wb_mt_wb_conf_t
window-size
(unique=%lu, fop=%s, gfid=%s, gen=%lu): refcount(%d) is <= 0 
(unique = %lu, fop=%s, gfid=%s, gen=%lu): destroying request, removing from all queues
stack-address: %p, winding from %s to %s
FIRST_CHILD(this)->fops->fallocate
FIRST_CHILD(this)->fops->discard
FIRST_CHILD(this)->fops->zerofill
(this->children->xlator)->fops->writev
(this->children->xlator)->fops->readv
(this->children->xlator)->fops->fsync
(this->children->xlator)->fops->stat
(this->children->xlator)->fops->fstat
(this->children->xlator)->fops->truncate
(this->children->xlator)->fops->ftruncate
(this->children->xlator)->fops->setattr
(this->children->xlator)->fops->fsetattr
(this->children->xlator)->fops->lookup
(this->children->xlator)->fops->readdirp
Assertion failed: list_empty (&wb_inode->todo)
Assertion failed: list_empty (&wb_inode->liability)
Assertion failed: list_empty (&wb_inode->temptation)
xlator.performance.write-behind
(this->children->xlator)->fops->flush
../../../../libglusterfs/src/stack.h
stack-address: %p, %s returned %d error: %s
stack-address: %p, %s returned %d
(unique=%lu, fop=%s, gfid=%s, gen=%lu): request fulfilled. removing the request from liability queue? = %s
(frame->this->children->xlator)->fops->writev
(unique=%lu, fop=%s, gfid=%s, gen=%lu): added req to liability queue. inode-generation-number=%lu
cannot add iobuf (%p) into iobref (%p)
(unique=%lu, fop=%s, gfid=%s, gen=%lu): not setting ordering.goas dontsync is set
(unique=%lu, fop=%s, gfid=%s, gen=%lu): A conflicting write request in liability queue has failed to sync (error = "%s"), unwinding this request as a failure
(unique=%lu, fop=%s, gfid=%s, gen=%lu): removed from liability queue
(unique=%lu, fop=%s, gfid=%s, gen=%lu): A conflicting write request in liability queue has failed to sync (error = "%s"). This is an FSYNC/FLUSH and we need to maintain ordering guarantees with other writes in TODO queue. Hence doing nothing now
Not winding request due to a conflicting write in liability queue. REQ: unique=%lu, fop=%s, gen=%lu, gfid=%s. CONFLICT: unique=%lu, fop=%s, gen=%lu, gfid=%s, conflicts-sync-failed?=%s, conflicts-error=%s
(unique=%lu, fop=%s, gen=%lu, gfid=%s): ordering.go is not set, hence not winding
Not winding write request as a conflicting write is being synced to backend. REQ: unique=%lu fop=%s, gen=%lu, gfid=%s. CONFLICT: unique=%lu fop=%s, gen=%lu, gfid=%s
(unique=%lu, fop=%s, gfid=%s, gen=%lu): picking the request for winding
Assertion failed: frame->local
FIRST_CHILD(this)->fops->create
(Lock acquisition failed) %p (gfid: %s)
Unable to dump the inode information
resync-failed-syncs-after-fsync
FATAL: write-behind (%s) not configured with exactly one child
dangling volume. check volfilex
setting window-size to be equal to aggregate-size(%lu)
aggregate-size(%lu) cannot be more than window-size(%lu)
If this option is set ON, instructs write-behind translator to perform flush in background, by returning success (or any errors, if any of previous  writes were failed) to application even before flush FOP is sent to backend filesystem. 
Size of the write-behind buffer for a single file (inode).
This option when set to off, ignores the O_DIRECT flag.
Do not let later writes overtake earlier writes even if they do not overlap
If sync of "cached-writes issued before fsync" (to backend) fails, this option configures whether to retry syncing them after fsync or forget them. If set to on, cached-writes are retried till a "flush" fop (or a successful sync) on sync failures. fsync itself is failed irrespective of the value of this option. 
fini
init
mem_acct_init
wb_priv_dump
wb_forget
wb_zerofill
wb_zerofill_helper
wb_discard
wb_discard_helper
wb_fallocate
wb_fallocate_helper
wb_link
wb_link_helper
wb_readdirp
wb_readdirp_cbk
wb_lookup
wb_lookup_helper
wb_lookup_cbk
wb_open
wb_create
wb_fsetattr
wb_fsetattr_helper
wb_setattr
wb_setattr_helper
wb_ftruncate
wb_ftruncate_helper
wb_ftruncate_cbk
wb_truncate
wb_truncate_helper
wb_truncate_cbk
wb_fstat
wb_fstat_helper
wb_stat
wb_stat_helper
wb_fsync
wb_fsync_helper
wb_flush
copy_frame
wb_flush_helper
wb_readv
wb_readv_helper
wb_writev
wb_writev_helper
wb_writev_cbk
wb_set_inode_size
wb_process_queue
__wb_pick_winds
__wb_handle_failed_conflict
__wb_preprocess_winds
__wb_collapse_small_writes
__wb_pick_unwinds
wb_request_unref
wb_do_unwinds
wb_fulfill_head
__wb_request_unref
__wb_fulfill_request
wb_inode_destroy
wb_inode_create
__wb_inode_create
wb_enqueue_common
__wb_request_ref
wb_request_ref
wb_inode_ctx_get
;*3$"
write-behind.so-3.12.1-2.fc27.x86_64.debug
7zXZ
OrQ}
m>h,
#7$+
4PbL[aj
[7%6
AALW
]j `
:~TxS
#i~F
mTn4o
^S@h
fPoU
Phvq	
K8EVi
\hlJ
W~2f
2tlP
9f|w
iN*l	
V1nS
.shstrtab
.note.gnu.build-id
.gnu.hash
.dynsym
.dynstr
.gnu.version
.gnu.version_r
.rela.dyn
.rela.plt
.init
.plt.got
.text
.fini
.rodata
.eh_frame_hdr
.eh_frame
.init_array
.fini_array
.data.rel.ro
.dynamic
.data
.bss
.gnu_debuglink
.gnu_debugdata
