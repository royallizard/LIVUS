N@pD 
 nLSE
0q4m
`qOd
{1&/
__gmon_start__
_ITM_deregisterTMCloneTable
_ITM_registerTMCloneTable
__cxa_finalize
_Jv_RegisterClasses
jv_mem_alloc
jv_string
jv_free
jv_mem_free
__assert_fail
jv_string_vfmt
jv_get_kind
jv_string_value
jv_string_fmt
jq_report_error
__printf_chk
jv_copy
jv_object_get
jv_array_get
putchar
jv_dump
strcmp
__strdup
jv_number_value
__isinf
strlen
strcpy
jv_null
jv_false
jv_true
jv_number
jv_array
jv_array_append
jv_object
jv_object_set
jv_array_length
jv_identical
jv_mem_realloc
memmove
jv_invalid
jv_array_slice
jq_next
jv_nomem_handler
jv_dump_string_trunc
jv_kind_name
jv_invalid_with_msg
jv_invalid_get_msg
jv_get
jv_get_refcnt
jv_object_iter_next
jv_object_iter_valid
jv_object_iter_key
jv_object_iter_value
jv_invalid_has_msg
jv_object_iter
jq_format_error
jv_dump_string
stderr
fwrite
__fprintf_chk
jq_init
jv_mem_alloc_unguarded
jq_set_error_cb
jq_get_error_cb
jq_set_nomem_handler
jq_start
jq_teardown
jq_compile_args
jq_compile
jq_set_attrs
jq_set_attr
jq_get_attr
jq_get_jq_origin
jq_get_prog_origin
jq_get_lib_dirs
jq_dump_disassembly
jq_set_input_cb
jq_get_input_cb
jq_set_debug_cb
jq_get_debug_cb
jq_util_input_get_current_line
jq_util_input_get_current_filename
timegm
jv_dumpf
fputc
jv_string_explode
jv_string_sized
jv_array_set
jv_equal
jv_string_length_bytes
OnigSyntaxPerl_NG
OnigEncodingUTF8
onig_new
onig_region_new
onig_search
jv_string_concat
onig_foreach_name
onig_region_free
onig_free
onig_error_code_to_str
strchr
jv_string_append_str
jv_string_append_buf
jv_cmp
jv_group
jv_sort
__fpclassify
__isnan
jv_object_length
jv_string_length_codepoints
jv_contains
jv_bool
jv_has
jv_delpaths
jv_getpath
jv_setpath
jv_string_indexes
jv_string_implode
jv_string_split
memcmp
jv_keys_unsorted
jv_keys
jv_parse
jv_parse_sized
jv_object_merge_recursive
jv_array_concat
jv_object_merge
remainder
hypot
atan2
tgamma
sqrt
log2
log10
exp2
cbrt
atanh
atan
asinh
asin
acosh
acos
jq_parse_library
gettimeofday
gmtime_r
strftime
strptime
__ctype_b_loc
getenv
jv_load_file
jv_is_integer
jv_array_sized
jv_string_empty
memset
jv_string_append_codepoint
__vsnprintf_chk
jv_string_hash
jv_string_slice
jv_object_delete
jv_array_indexes
jv_object_contains
jv_array_contains
strstr
jv_parser_new
jv_parser_free
jv_parser_remaining
jv_parser_set_buf
jv_parser_next
__sprintf_chk
stdout
jv_show
fflush
strncpy
qsort
jv_set
jv_dels
fopen
feof
ferror
fread
fclose
__errno_location
strerror
___tls_get_addr
fputs
abort
malloc
jv_mem_calloc
jv_mem_calloc_unguarded
jv_mem_strdup
jv_mem_strdup_unguarded
jv_mem_uninit_setup
jv_mem_uninitialised
snprintf
fgets
rand
exit
jq_testsuite
stdin
perror
clearerr
memchr
getuid
getpwuid
jq_realpath
pathconf
memmem
jq_util_input_init
jq_util_input_set_parser
jq_util_input_free
jq_util_input_add_input
jq_util_input_errors
jq_util_input_get_position
jq_util_input_next_input_cb
jq_util_input_next_input
strrchr
__xstat
dirname
jq_parse
jq_yylex
jq_yylex_init_extra
jq_yy_scan_bytes
jq_yy_delete_buffer
jq_yylex_destroy
jq_yy_flush_buffer
fileno
isatty
jq_yyget_extra
jq_yyget_lineno
jq_yyget_column
jq_yyget_in
jq_yyget_out
jq_yyget_leng
jq_yyget_text
jq_yyset_extra
jq_yyset_lineno
jq_yyset_column
jq_yyset_in
jq_yyset_out
jq_yyget_debug
jq_yyset_debug
jq_yyget_lval
jq_yyset_lval
jq_yyget_lloc
jq_yyset_lloc
jq_yyalloc
jq_yy_create_buffer
jq_yylex_init
jq_yyrealloc
jq_yyrestart
jq_yy_switch_to_buffer
jq_yy_scan_buffer
jq_yy_scan_string
jq_yypush_buffer_state
_IO_getc
jq_yyfree
jq_yypop_buffer_state
libm.so.6
libonig.so.2
libc.so.6
__environ
__stack_chk_fail
ld-linux.so.2
libjq.so.1
GLIBC_2.3
GLIBC_2.3.4
GLIBC_2.1.3
GLIBC_2.4
GLIBC_2.1
GLIBC_2.0
4$;,$sl
[^_]
UWVS
D$<1
|$<e3=
d$L[^_]
T$$9V
UWVS
D$|1
D$|e3
[^_]
UWVS
D$4e
D$4t
D$0;D$<
[^_]
UWVS
[^_]
UWVS
[^_]
#D$@
D$@%
D$@uB
d$,[^_]
UWVS
T$TtB
[^_]
D$,1
T$,e3
D$,1
T$,e3
d$0[^_
UWVS
d$ [^_
t$(t
T$8e
D$,e
D$<1
T$<e3
d$L[^_]
[^_]
UWVS
T$Xe
D$,1
L$,e3
[^_]
UWVS
D$ e
D$<1
T$<e3
d$L[^_]
UWVS
d$<[^_]
t$@e
D$,1
L$,e3
d$4[^
UWVS
D$<1
L$<e3
[^_]
UWVS
D$<1
L$<e3
[^_]
UWVS
D$\1
|$\e3=
d$l[^_]
UWVS
D$\1
L$\e3
[^_]
UWVS
[^_]
UWVS
T$pe
D$<1
L$<e3
[^_]
UWVS
T$|1
T$|e3
[^_]
UWVS
T$|1
T$|e3
[^_]
UWVS
D$,e
D$l1
L$le3
d$|[^_]
UWVS
T$L1
L$Le3
[^_]
UWVS
D$0e
L$L1
L$4t
|$Le3=
d$\[^_]
D$<1
L$<e3
UWVS
D$,e
D$\1
\$\e3
d$l[^_]
D$<1
T$<e3
UWVS
L$<1
L$<e3
[^_]
UWVS
D$l1
|$le3=
d$|[^_]
UWVS
|$`e
L$<1
L$<e3
d$L[^_]
UWVS
D$0e
T$L1
L$Le3
[^_]
D$$e
D$<1
T$,9l$h
T$pu
L$<e3
d$L[^_]
D$l1
T$@9T$L
L$le3
d$|[^_]
L$(e
T$\1
T$4t{
L$\e3
d$l[^_]
UWVS
D$|1
\$|e3
[^_]
UWVS
D$8e
D$l1
t$le35
d$|[^_]
|$D1
>*tP
UWVS
D$|1
L$|e3
[^_]
UWVS
D$Le
[^_]
UWVS
D$Le
D$DuX
[^_]
UWVS
D$Le
[^_]
|$he
D$\1
D$h1
[^_]
T$Xf
L$Pf
\$Xf
L$`9
L$Pf
\$Xf
UWVS
t$He
V ;z
[^_]
UWVS
;j(}9
[^_]
[^_]
D$l1
D$le3
d$|[^_]
D$<1
L$<e3
d$D[^
[^_]
UWVS
;w,t
d$,[^_]
w0;w,
d$,[^_]
d$,[^_]
\$ e
\$\1
T$$}
t$,1
L$\e3
d$l[^_]
;^(}
d$ [^_
UWVS
t$pe
D$L1
\$Le3
d$\[^_]
UWVS
t$`e
D$<1
U$;E,
L$<e3
d$L[^_]
UWVS
D$,e
D$\1
(;~(
D$\e3
d$l[^_]
UWVS
|$Le
D$\1
F,9F8tH9F4u
F,9F8u
F8;F,
L$\e3
d$l[^_]
D$,1
D$,e3
d$0[^_
d$([
UWVS
9t$pu
D$p&
D$x1
9t$xt0
[^_]
|$p	
D$l1
L$le3
d$p[^_
D$,1
D$,e3
d$4[^
D$,1
T$,e3
d$0[^_
UWVS
[^_]
t$Pe
D$<1
D$<e3
d$D[^
UWVS
[^_]
9t$4
D$<1
T$<e3
d$@[^_
T$ e
D$\1
D$\e3
d$d[^
t$`e
T$L1
T$Le3
D$<1
L$<e3
D$<1
L$<e3
D$<1
L$<e3
t$Pe
D$<1
L$<e3
d$@[^_
D$,1
T$,e3
[^_]
UWVS
D$<1
L$<e3
[^_]
D$<1
L$<e3
d$@[^_
D$l1
L$le3
d$p[^_
D$<1
L$<e3
d$@[^_
D$<1
L$<e3
d$D[^
UWVS
D$\e
D$P)
[^_]
D$\1
L$\e3
[^_]
UWVS
[^_]
9t$H
D$@9
D$T9G
9T$H
D$<1
T$<e3
d$D[^
D$L1
T$Le3
d$T[^
D$:%
[^_]
D$\1
T$\e3
d$d[^
UWVS
D$\e
[^_]
9t$0
D$H9D$X
UWVS
[^_]
D$,1
T$,e3
d$4[^
D$,1
T$,e3
[^_]
UWVS
[^_]
|$@t
|$@u
|$@t
;t$H
|$@t
L$L)
D$`9t$D
|$@s
D$`;|$D
[^_]
D$<1
T$<e3
D$<1
T$<e3
D$L1
L$Le3
D$L1
L$Le3
D$\1
L$\e3
d$`[^_
D$\1
L$\e3
d$`[^_
D$L1
L$Le3
d$T[^
D$,1
T$,e3
d$4[^
D$,1
T$,e3
d$4[^
D$,1
T$,e3
d$4[^
D$<1
T$<e3
d$D[^
D$<1
T$<e3
d$@[^_
D$,1
L$,e3
d$0[^_
D$L1
T$Le3
D$L1
T$Le3
D$L1
T$Le3
D$L1
T$Le3
D$,1
T$,e3
D$,1
T$,e3
D$<1
T$<e3
D$<1
T$<e3
D$<1
T$<e3
D$L1
T$Le3
D$<1
T$<e3
D$<1
L$<e3
d$D[^
D$L1
L$Le3
d$T[^
D$L1
T$Le3
d$T[^
UWVS
D$l1
|$le3=
d$|[^_]
|$,)
UWVS
D$\1
L$\e3
d$l[^_]
UWVS
[^_]
D$,1
T$,e3
d$4[^
D$,1
T$,e3
d$4[^
D$L1
D$hty
L$Le3
d$P[^_
D$L1
L$Le3
d$P[^_
UWVS
D$<e
[^_]
D$L1
T$Le3
d$T[^
D$L1
T$Le3
d$T[^
D$L1
T$Le3
d$T[^
D$L1
T$Le3
d$T[^
D$L1
T$Le3
d$T[^
D$<1
T$<e3
d$D[^
D$<1
T$<e3
d$D[^
D$<1
T$<e3
d$D[^
D$<1
T$<e3
d$D[^
D$<1
T$<e3
d$D[^
D$<1
T$<e3
d$D[^
D$<1
T$<e3
d$D[^
D$<1
T$<e3
d$D[^
D$<1
T$<e3
d$D[^
D$<1
T$<e3
d$D[^
D$<1
T$<e3
d$D[^
D$<1
T$<e3
d$D[^
D$<1
T$<e3
d$D[^
D$<1
T$<e3
d$D[^
D$<1
T$<e3
d$D[^
D$<1
T$<e3
d$D[^
D$<1
T$<e3
d$D[^
D$<1
T$<e3
d$D[^
D$<1
T$<e3
d$D[^
D$<1
T$<e3
d$D[^
D$<1
T$<e3
d$D[^
D$<1
T$<e3
d$D[^
D$<1
T$<e3
d$D[^
D$<1
T$<e3
d$D[^
D$<1
T$<e3
d$L[^_]
D$,1
T$,e3
d$4[^
UWVS
[^_]
D$`%
[^_]
UWVS
[^_]
T$;t
|$01
[^_]
UWVS
D$,e
D$<1
;t$ sz
T$(+t$$
T$<e3
d$L[^_]
UWVS
D$ f
D$@f
d$\1
[^_]
UWVS
d$,[^_]
d$,[^_]
d$$[^
UWVS
d$L[^_]
9D$t
t$pse1
UWVS
d$<1
[^_]
UWVS
d$L[^_]
d$0[^_
tX;s
d$41
d$8[
[^_]
d$$[
d$([
d$ [
UWVS
l$Pe
D$,1
|$,e3=
d$<[^_]
UWVS
d$,[
D$,1
L$,e3
D$(e
D$<1
T$<e3
d$L[^_]
\$ e
d$([
D$<1
t$<e35
d$@[^_
D$,1
L$,e3
d$$[^
d$$[^
d$$[^
d$$[^
D$,1
T$,e3
d$0[^_
D$<1
L$<e3
d$D[^
D$,1
L$,e3
d$4[^
d$ [^_
d$ [^_
UWVS
D$|f
D$0;w
D$(f
T$,;t$8}<
|$8f
D$(f
[^_]
D$$9
D$L1
L$Le3
UWVS
D$<e
D$|1
9t$4
T$|e3
[^_]
UWVS
D$<1
|$<e3=
d$L[^_]
UWVS
D$L1
D$p1
L$Le3
d$\[^_]
UWVS
D$D+L$L
T$<)
[^_]
UWVS
D$|1
T$|e3
[^_]
UWVS
D$8=
D$@9t$0
[^_]
UWVS
D$$e
D$l1
L$le3
d$|[^_]
L$()
L$()
D$<1
L$<e3
d$@[^_
UWVS
D$\1
L$\e3
d$l[^_]
D$,1
T$,e3
D$,1
L$,e3
d$4[^
UWVS
d$\[^_]
UWVS
D$<e
D$@1
[^_]
UWVS
[^_]
UWVS
D$,e
D$l1
D$(;E
\$le3
d$|[^_]
UWVS
D$Le
D$|1
|$|e3=
[^_]
UWVS
D$Le
[^_]
UWVS
;|$8
9|$8
l$8)
[^_]
UWVS
[^_]
T$(8T$8u
T$\f
D$hf
D$@f
9t$4
|$L1
D$Df
D$@f
D$D1
L$81
9L$D
T$<9T$4
D$@f9D$D
UWVS
D$\e
9t$8
9l$X
[^_]
D$$;D$4u
t5r#
T$ 9D$(
D$(1
UWVS
9t$$
D$L1
[^_]
D$,9D$0
UWVS
[^_]
0<	w
D$,1
D$,e3
d$0[^_
D$,1
D$,e3
d$0[^_
~8Vu"
d$0[1
[^_]
UWVS
t$pe
D$L1
\$Le3
d$\[^_]
D$|1
L$|e3
D$<1
L$<e3
d$L[^_]
d$$[^
D$Le
t$\9
[^_]
D$G< 
9D$P
D$G<]
|$G"
D$G<{t
D$G<{f
D$G<{
9D$P
}8Vt
D$,e
[^_]
t$Pe
|$<1
D$<e3
d$@[^_
|$@tH
d$,[^_]
UWVS
D$,e
D$K"
D$Q\
D$Pr
D$M\
D$Lf
D$O\
D$Nn
D$S\
D$Rt
D$U\
D$Tb
D$W\
D$J"
[^_]
D$l1
D$+ 
D$*(
D$))
D$le3
d$|[^_]
UWVS
[^_]
D$w]
D$x{
9D$<
D${}
9t$P
D$w]
D$L1
D$Le3
d$P[^_
d$([
UWVS
L$<1
D$<e3
d$L[^_]
UWVS
l$(e
D$\1
T$\e3
[^_]
UWVS
D$<1
9D$,v
L$<e3
d$L[^_]
L$(9
|$ 1
d$<[^_]
l$,)
d$<[^_]
d$<[^_]
[^_]
392t
D$$1
9l$ 
\$(9
d$<[^_]
d$<[
9\$ 
T$ ;P
d$<[^_]
d$,[^_]
UWVS
D$,1
l$ 1
d$<[^_]
89:t
t$Pe
L$,1
D$$tG
t$,e35
d$<[^_]
T$()
L$$	
[^_]
D$81
[^_]
|$()
D$L	
|$T)
+T$P
+\$(
+\$D
T$\)
;D$D
L$P)
L$P9
D$41
D$`1
+T$8
t$89
L$D)
L$T9L$P
*9(t
T$T9T$P
l$T9l$P
l$H)
9L$P
L$T-
9L$P
L$|)
|$41
D$8j
T$P)
D$Xt
L$Pt
9l$T
9t$Pu
+D$D
t$,)
+L$8+
;D$H
9L$T
9\$P
+T$8
9\$P
MD$D1
9\$P
t$ f
\$0)
t$4-
[^_]
\$()
:98t
D$<1
)D$(
|$(1
D$T-
t$4u3
:98t
\$8u;
9|$\
290t
L$4!
\$h-
:98t
|$<9
|$<9ty
D$L1
t$Le35
d$\[^_]
T$H)
L$@u
gfff
;L$D
d$,[^_]
9t$Ds 
D$D)
|$4e
d$ [^_
UWVS
[^_]
UWVS
D$$1
9t$ 
[^_]
UWVS
D$\1
T$,9
T$\e3
d$l[^_]
UWVS
[^_]
D$`9
t$P1
D$`9|$H
+|$H
+D$L
+|$L
UWVS
D$Pe
[^_]
D$p9t$<
D$p9t$<
D$\1
D$h;D$<
D$p9t$<
D$h;D$<
D$h;D$<
D$<9D$X
UWVS
9D$T
L$X9L$\
[^_]
UWVS
D$Le
D$P9t$@
[^_]
D$P9t$@
UWVS
[^_]
UWVS
[^_]
D$<f
9t$H
|$0)
t$`e
D$L1
L$Le3
d$P[^_
UWVS
L$@9t$4
[^_]
UWV1
9t$8
[^_]
UWVS
D$P9|$<
[^_]
UWVS
[^_]
UWVS
hell
hellf
good
z}u{
[^_]
UWVS
D$,1
D$,e3
d$<[^_]
UWVS
D$0e
+T$4
[^_]
d$$1
d$([
D$,1
L$,e3
d$<[^_]
D$L1
L$Le3
d$T[^
UWVS
D$|1
?~t(
|$|e3=
[^_]
d$,[^_]
UWVS
l$Te
D$,1
T$,e3
d$<[^_]
UWVS
D$<1
D$<e3
d$L[^_]
UWVS
D$,1
L$,e3
d$<[^_]
D$<1
9D$$t_
L$<e3
d$D[^
D$L1
9D$4
D$<t[
L$Le3
d$T[^
T$81
UWVS
D$8e
[^_]
[^_]
D$P9t$4
D$He
[^_]
9l$8
9l$8
9l$4
UWVS
D$\9
r	;u
[^_]
UWVS
[^_]
UWVS
[^_]
D$h1
T$<t{
9|$hw
9t$d
D$<1
L$<e3
UWVS
L$4e
L$L1
t$Le35
[^_]
UWVS
L$Te
[^_]
UWVS
L$4e
L$L1
t$Le35
[^_]
UWVS
t$L1
L$Le3
[^_]
D$4e
[^_]
z~u|
UWVS
L$,e
L$L1
|$Le3=
d$\[^_]
UWVS
:"t8
[^_]
\$`e
D$<1
L$<e3
d$L[^_]
d$ [^_
UWVS
D$8e
t+=(
[^_]
L$De
L$Xf
t$l9
t$\9
9l$H
L$Df
D$`=
;l$Ht>
|$l9|$Ht
;D$|t
[^_]
;D$|t
UWVS
D$,1
L$,e3
d$<[^_]
UWVS
[^_]
[^_]
t	[^
d$,[^_]
UWVS
[^_]
UWVS
D$|1
T$|e3
[^_]
[^_]
[^_]
UWVS
[^_]
[^_]
UWVS
[^_]
UWVS
[^_]
D$0e
\$4f
L$(f
[^_]
9D$L
D$L)
L$L)
D$(~
;L$(u
\$L=
;L$H
L$Lu
OPuo
;0t9
d$,[^_]
locfile.c
pos < l->length
line-1 < l->nlines
line < l->nlines
%s at %s, line %d:
%.*s%*s
jq: error: %s
<unknown location>
locfile_line_length
locfile_get_line
%04d 
params
 %s:%d
 %04d
 $%s:%d
%*s[params: 
%*s%s:%d:
#INVALID
LOADK
DUPN
DUP2
LOADV
LOADVN
STOREV
STORE_GLOBAL
INDEX
INDEX_OPT
EACH
EACH_OPT
FORK
FORK_OPT
JUMP
JUMP_F
BACKTRACK
APPEND
INSERT
RANGE
SUBEXP_BEGIN
SUBEXP_END
PATH_BEGIN
PATH_END
CALL_BUILTIN
TAIL_CALL_JQ
CLOSURE_REF
CLOSURE_CREATE_C
CLOSURE_PARAM_REGULAR
DEPS
MODULEMETA
GENLABEL
compile.c
0 && "Unknown function type"
bc && bc == target->compiled
block_is_single(binder)
binder.first->symbol
break_distance >= 0
i->op == CLOSURE_PARAM
*anonlabel
block_is_const(b)
target.last
block_is_single(b)
!a->next
!b->prev
reduce
foreach
found
left.first->op == DUP
@lambda
__jq
_equal
i->op == CLOSURE_CREATE
curr->op == CALL_JQ
!curr->arglist.first
actual_args == desired_args
metadata
is_data
relpath
collect
curr == b.last
curr->bound_by == curr
param->op == CLOSURE_PARAM
param->bound_by == param
bc && target && target->compiled
(opcode_describe(binder.first->op)->flags & bindflags) == (bindflags & ~OP_BIND_WILDCARD)
binder.first->bound_by == 0 || binder.first->bound_by == binder.first
opcode_describe(op)->length == 1
opcode_describe(LOADK)->flags & OP_HAS_CONSTANT
(opcode_describe(STORE_GLOBAL)->flags & (OP_HAS_CONSTANT | OP_HAS_VARIABLE | OP_HAS_BINDING)) == (OP_HAS_CONSTANT | OP_HAS_VARIABLE | OP_HAS_BINDING)
opcode_describe(op)->flags & OP_HAS_BRANCH
opcode_describe(b.first->op)->flags & OP_HAS_BRANCH
opcode_describe(op)->flags & OP_HAS_BINDING
block_has_only_binders(binder, bindflags)
opcode_describe(op)->flags & OP_HAS_VARIABLE
left.first->next->op == SUBEXP_BEGIN
left.first->next->next->op == LOADK
jq: error: break used outside labeled control structure
jq: error: %s/%d is not defined
opcode_describe(i->op)->flags & OP_IS_CALL_PSEUDO
0 && "Unknown type of parameter"
curr->bound_by->op == CLOSURE_CREATE_C
metadata.first == ((void *)0) || block_is_const(metadata)
curr->op != CLOSURE_REF && curr->op != CLOSURE_PARAM
function compiled to %d bytes which is too long
curr->bound_by->op == CLOSURE_CREATE || curr->bound_by->op == CLOSURE_PARAM
arg->op == CLOSURE_REF && arg->bound_by->op == CLOSURE_CREATE
curr->imm.target->bytecode_pos != -1
curr->imm.target->bytecode_pos > pos
0 && "codegen not implemented for this operation"
bc->globals->ncfunctions == ncfunc
nesting_level
expand_call_arglist
compile
block_compile
gen_array_matcher
gen_import
block_bind_referenced
block_bind_library
block_count_actuals
block_count_formals
block_bind_subblock
block_bind_each
inst_join
gen_op_bound
gen_op_var_fresh
gen_op_unbound
inst_set_target
gen_op_targetlater
gen_op_target
block_const
block_const_kind
gen_const_global
gen_const
gen_op_simple
execute.c
closure < fr->bc->nclosures
n2 == n1 + 1
fp->retaddr == 0
var >= 0
var < fr->bc->nlocals
jq->curr_frame
jv_is_valid(val)
path_len >= 0
path_len == 0
jq->stk_top == 0
jq->fork_top == 0
jq->curr_frame == 0
exec_stack.h
jq->err_cb
	<backtracking>
0 && "invalid instruction"
jv_is_valid(v)
jq->subexp_nest > 0
Range bounds must be numeric
V%d = 
 (%d)
Cannot iterate over %s (%s)
jq: error: out of memory
jq: error: %s
<top-level>
jq: %d compile %s
JQ_ORIGIN
PROGRAM_ORIGIN
JQ_LIBRARY_PATH
subfn_idx < fr->bc->nsubfunctions
fp->retaddr >= bc->code && fp->retaddr < bc->code + bc->codelen
nargs == new_frame->bc->nclosures
s->limit == 0 && "stack freed while not empty"
jv_get_kind(jq->error) == JV_KIND_NULL
jv_get_kind(*var) == JV_KIND_ARRAY
jv_get_kind(objv) == JV_KIND_OBJECT
Cannot use %s (%s) as object key
Invalid path expression with result %s
Invalid path expression near attempt to access element %s of %s
Invalid path expression near attempt to iterate through %s
opcode == EACH || opcode == EACH_OPT
Function takes too many arguments
jq->stk_top == frame_current(jq)->retdata
jv_get_kind(args) == JV_KIND_ARRAY
jv_get_kind(attrs) == JV_KIND_OBJECT
jq_set_attrs
jq_compile_args
stack_reset
jq_reset
frame_push
make_closure
path_append
jq_next
jq_report_error
frame_local_var
frame_current
frame_pop
stack_restore
stack_popn
stack_pop
stack_push
?mktime requires array inputs
invalid gmtime representation
break
is not a string
Regex failure: 
offset
captures
cannot be negated
number required
%s (%s) and %s (%s) %s
cannot be divided (remainder)
cannot be subtracted
builtin.c
text
is not valid in a csv row
html
%%%02X
can not be escaped for shell
base64
 is not a valid format
cannot be iterated over
have wrong length
has no length
cannot be divided
has no keys
cannot be parsed as a number
only strings can be parsed
cannot be multiplied
cannot be added
<builtin>
empty
HOME
/.jq
!nerrors
rangevar
start
range
def error: error(.);
def map(f): [.[] | f];
def acos: _acos;
def acosh: _acosh;
def asin: _asin;
def asinh: _asinh;
def atan: _atan;
def atanh: _atanh;
def cbrt: _cbrt;
def cos: _cos;
def cosh: _cosh;
def exp2: _exp2;
def exp: _exp;
def floor: _floor;
def j0: _j0;
def j1: _j1;
def log10: _log10;
def log2: _log2;
def log: _log;
def sin: _sin;
def sinh: _sinh;
def sqrt: _sqrt;
def tan: _tan;
def tanh: _tanh;
def tgamma: _tgamma;
def y0: _y0;
def y1: _y1;
def pow(a;b): _pow(a;b);
def atan2(a;b): _atan2(a;b);
def hypot(a;b): _hypot(a;b);
def map_values(f): .[] |= f;
def recurse: recurse(.[]?);
def recurse_down: recurse;
def any: any(.);
def all: all(.);
def flatten: _flatten(-1);
def range($x): range(0;$x);
def todate: todateiso8601;
def first: .[0];
def last: .[-1];
def nth($n): .[$n];
def input: _input;
_acos
_acosh
_asin
_asinh
_atan
_atanh
_cbrt
_cos
_cosh
_exp2
_exp
_floor
_log10
_log2
_log
_sin
_sinh
_sqrt
_tan
_tanh
_tgamma
_pow
_atan2
_hypot
_remainder
_plus
_negate
_minus
_multiply
_divide
_mod
tojson
fromjson
tonumber
tostring
keys_unsorted
startswith
endswith
ltrimstr
rtrimstr
split
explode
implode
_strindices
setpath
getpath
delpaths
_notequal
_less
_greater
_lesseq
_greatereq
contains
type
isinfinite
isnan
isnormal
sort
_sort_by_impl
_group_by_impl
_min_by_impl
_max_by_impl
get_search_list
get_prog_origin
get_jq_origin
_match_impl
modulemeta
_input
debug
stderr
strptime
strftime
mktime
gmtime
input_filename
input_line_number
mktime requires parsed datetime inputs
mktime not supported on this platform
modulemeta input module name must be a string
explode input must be a string
cannot be matched, as it is not a string
 is not a valid modifier string
cannot be divided (remainder) because the divisor is zero
jv_get_kind(input) == JV_KIND_STRING
cannot be csv-formatted, only array
cannot be tsv-formatted, only array
ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_.!~*'()
!__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (fmt_s) && __builtin_constant_p ("tsv") && (__s1_len = strlen (fmt_s), __s2_len = strlen ("tsv"), (!((size_t)(const void *)((fmt_s) + 1) - (size_t)(const void *)(fmt_s) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("tsv") + 1) - (size_t)(const void *)("tsv") == 1) || __s2_len >= 4)) ? __builtin_strcmp (fmt_s, "tsv") : (__builtin_constant_p (fmt_s) && ((size_t)(const void *)((fmt_s) + 1) - (size_t)(const void *)(fmt_s) == 1) && (__s1_len = strlen (fmt_s), __s1_len < 4) ? (__builtin_constant_p ("tsv") && ((size_t)(const void *)(("tsv") + 1) - (size_t)(const void *)("tsv") == 1) ? __builtin_strcmp (fmt_s, "tsv") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("tsv"); int __result = (((const unsigned char *) (const char *) (fmt_s))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (fmt_s))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (fmt_s))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (fmt_s))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("tsv") && ((size_t)(const void *)(("tsv") + 1) - (size_t)(const void *)("tsv") == 1) && (__s2_len = strlen ("tsv"), __s2_len < 4) ? (__builtin_constant_p (fmt_s) && ((size_t)(const void *)((fmt_s) + 1) - (size_t)(const void *)(fmt_s) == 1) ? __builtin_strcmp (fmt_s, "tsv") : (- (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) (fmt_s); int __result = (((const unsigned char *) (const char *) ("tsv"))[0] - __s2[0]); if (__s2_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) ("tsv"))[1] - __s2[1]); if (__s2_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) ("tsv"))[2] - __s2[2]); if (__s2_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) ("tsv"))[3] - __s2[3]); } } __result; })))) : __builtin_strcmp (fmt_s, "tsv")))); })
ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/
cannot be sorted, as they are not both arrays
cannot be sorted, as it is not an array
cannot have their containment checked
implode input must be an array
split input and separator must be strings
cannot be divided because the divisor is zero
endswith() requires string inputs
startswith() requires string inputs
gmtime() requires numeric inputs
errror converting number of seconds since epoch to datetime
strftime/1 requires parsed datetime inputs
strftime/1: unknown system failure
strptime/1 requires string inputs and arguments
date "%s" does not match format "%s"
strptime/1 not supported on this platform
def bsearch(target):  if length == 0 then -1  elif length == 1 then     if target == .[0] then 0 elif target < .[0] then -1 else -2 end  else . as $in    | [0, length-1, null]    | until( .[0] > .[1] ;             if .[2] != null then (.[1] = -1)             else               ( ( (.[1] + .[0]) / 2 ) | floor ) as $mid               | $in[$mid] as $monkey               | if $monkey == target  then (.[2] = $mid)                 elif .[0] == .[1]     then (.[1] = -1)                 elif $monkey < target then (.[0] = ($mid + 1))                 else (.[1] = ($mid - 1))                 end             end )    | if .[2] == null then         if $in[ .[0] ] < target then (-2 -.[0])         else (-1 -.[0])         end      else .[2]      end  end;
def select(f): if f then . else empty end;
def sort_by(f): _sort_by_impl(map([f]));
def group_by(f): _group_by_impl(map([f]));
def unique: group_by(.) | map(.[0]);
def unique_by(f): group_by(f) | map(.[0]);
def max_by(f): _max_by_impl(map([f]));
def min_by(f): _min_by_impl(map([f]));
def remainder(a;b): _remainder(a;b);
def add: reduce .[] as $x (null; . + $x);
def del(f): delpaths([path(f)]);
def _assign(paths; value): value as $v | reduce path(paths) as $p (.; setpath($p; $v));
def _modify(paths; update): reduce path(paths) as $p (.; setpath($p; getpath($p) | update));
def recurse(f): def r: ., (f | select(. != null) | r); r;
def recurse(f; cond): def r: ., (f | select(cond) | r); r;
def to_entries: [keys_unsorted[] as $k | {key: $k, value: .[$k]}];
def from_entries: map({(.key // .Key // .Name): (if has("value") then .value else .Value end)}) | add | .//={};
def with_entries(f): to_entries | map(f) | from_entries;
def reverse: [.[length - 1 - range(0;length)]];
def indices($i): if type == "array" and ($i|type) == "array" then .[$i]  elif type == "array" then .[[$i]]  elif type == "string" and ($i|type) == "string" then _strindices($i)  else .[$i] end;
def index($i):   indices($i) | .[0];
def rindex($i):  indices($i) | .[-1:][0];
def paths: path(recurse(if (type|. == "array" or . == "object") then .[] else empty end))|select(length > 0);
def paths(node_filter): . as $dot|paths|select(. as $p|$dot|getpath($p)|node_filter);
def any(generator; condition):        [label $out | foreach generator as $i                 (false;                  if . then break $out elif $i | condition then true else . end;                  if . then . else empty end)] | length == 1;
def any(condition): any(.[]; condition);
def all(generator; condition):         [label $out | foreach generator as $i                 (true;                  if .|not then break $out elif $i | condition then . else false end;                  if .|not then . else empty end)] | length == 0;
def all(condition): all(.[]; condition);
def isfinite: type == "number" and (isinfinite | not);
def arrays: select(type == "array");
def objects: select(type == "object");
def iterables: arrays, objects;
def booleans: select(type == "boolean");
def numbers: select(type == "number");
def normals: select(isnormal);
def finites: select(isfinite);
def strings: select(type == "string");
def nulls: select(type == "null");
def values: select(. != null);
def scalars: select(. == null or . == true or . == false or type == "number" or type == "string");
def scalars_or_empty: select(. == null or . == true or . == false or type == "number" or type == "string" or ((type=="array" or type=="object") and length==0));
def leaf_paths: paths(scalars);
def join($x): reduce .[] as $i (null; (.//"") + (if . == null then $i else $x + $i end))//"";
def _flatten($x): reduce .[] as $i ([]; if $i | type == "array" and $x != 0 then . + ($i | _flatten($x-1)) else . + [$i] end);
def flatten($x): if $x < 0 then error("flatten depth must not be negative") else _flatten($x) end;
def fromdateiso8601: strptime("%Y-%m-%dT%H:%M:%SZ")|mktime;
def todateiso8601: strftime("%Y-%m-%dT%H:%M:%SZ");
def fromdate: fromdateiso8601;
def match(re; mode): _match_impl(re; mode; false)|.[];
def match($val): ($val|type) as $vt | if $vt == "string" then match($val; null)   elif $vt == "array" and ($val | length) > 1 then match($val[0]; $val[1])   elif $vt == "array" and ($val | length) > 0 then match($val[0]; null)   else error( $vt + " not a string or array") end;
def test(re; mode): _match_impl(re; mode; true);
def test($val): ($val|type) as $vt | if $vt == "string" then test($val; null)   elif $vt == "array" and ($val | length) > 1 then test($val[0]; $val[1])   elif $vt == "array" and ($val | length) > 0 then test($val[0]; null)   else error( $vt + " not a string or array") end;
def capture(re; mods): match(re; mods) | reduce ( .captures | .[] | select(.name != null) | { (.name) : .string } ) as $pair ({}; . + $pair);
def capture($val): ($val|type) as $vt | if $vt == "string" then capture($val; null)   elif $vt == "array" and ($val | length) > 1 then capture($val[0]; $val[1])   elif $vt == "array" and ($val | length) > 0 then capture($val[0]; null)   else error( $vt + " not a string or array") end;
def scan(re):  match(re; "g")  |  if (.captures|length > 0)      then [ .captures | .[] | .string ]      else .string      end ;
def _nwise(a; $n): if a|length <= $n then a else a[0:$n] , _nwise(a[$n:]; $n) end;
def _nwise($n): _nwise(.; $n);
def splits($re; flags): . as $s  | [ match($re; "g" + flags) | (.offset, .offset + .length) ]  | [0] + . +[$s|length]  | _nwise(2)  | $s[.[0]:.[1] ] ;
def splits($re): splits($re; null);
def split($re; flags): [ splits($re; flags) ];
def sub($re; s):  . as $in  | [match($re)]  | if length == 0 then $in    else .[0]    | . as $r    | reduce ( $r | .captures | .[] | select(.name != null) | { (.name) : .string } ) as $pair        ({}; . + $pair)    | $in[0:$r.offset] + s + $in[$r.offset+$r.length:]    end ;
def sub($re; s; flags):  def subg: explode | select(. != 103) | implode;  def sub1(fla; gs):    def mysub:      . as $in      | [match($re; fla)]      | if length == 0 then $in        else .[0] as $edit        | ($edit | .offset + .length) as $len        | reduce ( $edit | .captures | .[] | select(.name != null) | { (.name) : .string } ) as $pair            ({}; . + $pair)        | $in[0:$edit.offset]          + s          + ($in[$len:] | if gs then mysub else . end)        end ;    mysub ;    (flags | index("g")) as $gs    | (flags | if $gs then subg else . end) as $fla    | sub1($fla; $gs);
def sub($re; s): sub($re; s; "");
def gsub($re; s; flags): sub($re; s; flags + "g");
def gsub($re; s): sub($re; s; "g");
def range($init; $upto; $by):     def _range:         if ($by > 0 and . < $upto) or ($by < 0 and . > $upto) then ., ((.+$by)|_range) else . end;     if $by == 0 then $init else $init|_range end | select(($by > 0 and . < $upto) or ($by < 0 and . > $upto));
def while(cond; update):      def _while:          if cond then ., (update | _while) else empty end;      _while;
def until(cond; next):      def _until:          if cond then . else (next|_until) end;     _until;
def limit($n; exp): if $n < 0 then exp else label $out | foreach exp as $item ([$n, null]; if .[0] < 1 then break $out else [.[0] -1, $item] end; .[1]) end;
def first(g): label $out | foreach g as $item ([false, null]; if .[0]==true then break $out else [true, $item] end; .[1]);
def last(g): reduce g as $item (null; $item);
def nth($n; g): if $n < 0 then error("nth doesn't support negative indices") else last(limit($n + 1; g)) end;
def combinations:    if length == 0 then [] else        .[0][] as $x          | (.[1:] | combinations) as $y          | [$x] + $y    end;
def combinations(n):    . as $dot      | [range(n) | $dot]      | combinations;
def transpose:  if . == [] then []  else . as $in  | (map(length) | max) as $max  | length as $length  | reduce range(0; $max) as $j      ([]; . + [reduce range(0;$length) as $i ([]; . + [ $in[$i][$j] ] )] )  end;
def in(xs): . as $x | xs | has($x);
def inside(xs): . as $x | xs | contains($x);
def repeat(exp):      def _repeat:          exp, _repeat;     _repeat;
def inputs: try repeat(_input) catch if .=="break" then empty else .|error end;
def ascii_downcase:  explode | map( if 65 <= . and . <= 90 then . + 32  else . end) | implode;
def ascii_upcase:  explode | map( if 97 <= . and . <= 122 then . - 32  else . end) | implode;
def truncate_stream(stream):  . as $n | null | stream | . as $input | if (.[0]|length) > $n then setpath([0];$input[0][1:]) else empty end;
def fromstream(i):  foreach i as $item (    [null,false,null,false];    if ($item[0]|length) == 0 then [null,false,.[2],.[3]]    elif ($item|length) == 1 and ($item[0]|length) < 2 then [null,false,.[0],.[1]]    else . end |    . as $state |    if ($item|length) > 1 and ($item[0]|length) > 0 then      [.[0]|setpath(($item|.[0]); ($item|.[1])),          true,                                               $state[2],                                          $state[3]]                                        else .    end;    if ($item[0]|length) == 1 and ($item|length == 1) and .[3] then .[2] else empty end,    if ($item[0]|length) == 0 then $item[1] else empty end    );
def tostream:
  {string:true,number:true,boolean:true,null:true} as $leaf_types |
  . as $dot |
  if $leaf_types[$dot|type] or length==0 then [[],$dot]
  else
    # We really need a _streaming_ form of `keys`.
    # We can use `range` for arrays, but not for objects.
    keys as $keys |
    $keys[-1] as $last|
    ((# for each key
      $keys[] | . as $key |
      $dot[$key] | . as $dot |
      # recurse on each key/value
      tostream|.[0]|=[$key]+.),
     # then add the closing marker
     [[$last]])
  end;
&&amp;
<&lt;
>&gt;
'&apos;
"&quot;
''\''
escape_string
f_format
builtins_bind
$tIjv.c
out < s->data + maxlength
c->count > 0
<invalid>
null
boolean
array
0 && "invalid kind"
iter != ITER_FINISHED
Invalid UTF-8 string
new_slot
jv_get_refcnt(a) == 1
size > 0 && (size & (size - 1)) == 0
jv_get_kind(a) == JV_KIND_ARRAY
jv_get_kind(a) == JV_KIND_STRING
jv_get_kind(o) == JV_KIND_OBJECT
i + jvp_array_offset(a) < array->length
s->alloc_length >= jvp_string_length(s)
slot == -1 || (slot >= 0 && slot < jvp_object_size(object))
jv_get_kind(b) == JV_KIND_STRING
jv_get_kind(key) == JV_KIND_STRING
jv_get_kind(j) == JV_KIND_NUMBER
jv_get_kind(j) == JV_KIND_STRING
jv_get_kind(object) == JV_KIND_OBJECT
jv_get_kind(jvp_object_get_slot(object,iter)->string) == JV_KIND_STRING
jv_get_kind(s) == JV_KIND_STRING
jv_get_kind(x) == JV_KIND_INVALID
jv_get_kind(inv) == JV_KIND_INVALID
jv_get_kind(j) == JV_KIND_ARRAY
Out of bounds negative array index
jv_get_kind(b) == JV_KIND_ARRAY
0 <= start && start <= end && end <= len
jv_get_kind(k) == JV_KIND_STRING
jv_get_kind(n) == JV_KIND_NUMBER
jvp_refcnt_unshared(new_object.u.ptr)
jvp_refcnt_unshared(object.u.ptr)
!jvp_object_find_slot(new_object, slot->string, new_bucket)
!jvp_object_find_slot(*object, key, bucket)
jv_get_kind(a) == JV_KIND_OBJECT
jv_get_kind(b) == JV_KIND_OBJECT
jv_get_kind(sep) == JV_KIND_STRING
jvp_invalid_free
jv_object_iter_key
jv_object_iter_next
jv_object_iter
jv_object_contains
jv_object_merge_recursive
jv_object_merge
jv_object_length
jvp_object_delete
jv_object_delete
jvp_object_rehash
jvp_object_free
jvp_object_unshare
jvp_object_write
jv_object_set
jvp_string_equal
jvp_object_size
jvp_object_get_slot
jvp_object_mask
jvp_object_ptr
jvp_object_read
jv_object_get
jvp_object_new
jvp_string_remaining_space
jv_string_slice
jv_string_value
jv_string_hash
jv_string_implode
jv_string_explode
jv_string_split
jv_string_indexes
jv_string_length_codepoints
jvp_string_ptr
jv_string_length_bytes
jvp_string_copy_replace_bad
jvp_array_slice
jv_array_slice
jv_array_concat
jvp_array_free
jvp_refcnt_unshared
jv_array_set
jvp_array_offset
jvp_array_ptr
jvp_array_read
jv_array_get
jvp_array_length
jv_array_length
jv_number_value
jv_invalid_get_msg
jv_kind_name
Expected separator between values
(p->curr_buf == 0 || p->curr_buf_pos == p->curr_buf_length) && "previous buffer not exhausted"
Invalid string: control characters from U+0000 through U+001F must be escaped
Expected escape character at end of string
Invalid \uXXXX\uXXXX surrogate pair escape
Invalid characters in \uXXXX escape
Expected a separator between values
Expected another key-value pair
Missing value in key:value pair
Objects must consist of key:value pairs
Unmatched '}' in the middle of an array
Expected another key:value pair
Unmatched '}' at the top-level
Unmatched ']' in the middle of an object
Expected another array element
Unmatched ']' at the top-level
',' not as part of an object or array
Expected string key before ':'
Potentially truncated top-level numeric value
p->stackpos > 1 && jv_get_kind(p->stack[p->stackpos-2]) == JV_KIND_OBJECT
%s at line %d, column %d (need RS to resync)
p->curr_buf_pos == p->curr_buf_length
Unfinished abandoned text at EOF at line %d, column %d
Unfinished string at EOF at line %d, column %d
%s at EOF at line %d, column %d
Unfinished JSON term at EOF at line %d, column %d
Potentially truncated top-level numeric value at EOF at line %d, column %d
jv_parse.c
p->stackpos <= p->stacklen
p->stackpos < p->stacklen
Invalid numeric literal
Invalid literal
false
true
p->tokenpos <= p->tokenlen
p->tokenpos < p->tokenlen
output produced
Invalid \uXXXX escape
Invalid escape
Unmatched '}'
Expected value before ','
':' should follow a key
Object keys must be strings
':' not as part of an object
Truncated value
Unmatched ']'
Malformed BOM
!jv_is_valid(*out)
k == JV_KIND_NULL
!jv_is_valid(p->next)
%s at line %d, column %d
Unexpected extra JSON values
Expected JSON value
%s (while parsing '%s')
tokenadd
push
parse_token
stream_token
scan
jv_parser_next
jv_parser_set_buf
jv_print.c
c != -1
\u%04x\u%04x
<invalid:
0 && "Invalid value"
[34;1m
[1;30m
[0;39m
[0;32m
[1;39m
jv_get_kind(str) == JV_KIND_STRING
jvp_dump_string
jv_dump_term
Infinity
[%Co
O8M2
vH7B
W4vC
?aCoc
@jv_unicode.c
in <= end
length > 0
codepoint >= 0 && codepoint <= 0x10FFFF
out - start == jvp_utf8_encode_length(codepoint)
jvp_utf8_encode
jvp_utf8_next
????????????????????????????????????????????????????????????????
jv_aux.c
Cannot index %s with %s
jv_is_valid(t)
jv_is_valid(k)
Cannot delete fields from %s
jv_get_kind(objects) == JV_KIND_ARRAY
jv_get_kind(keys) == JV_KIND_ARRAY
jv_array_length(jv_copy(objects)) == jv_array_length(jv_copy(keys))
Start and end indices of an array slice must be numbers
Start and end indices of an string slice must be numbers
Cannot index %s with string "%s"
0 <= start && start <= end && end <= array_len
A slice of an array can only be assigned another array
Cannot update field at %s index of %s
Cannot check whether %s has a %s key
Cannot delete %s element of array
Cannot delete %s field of object
jv_array_length(jv_array_get(jv_copy(paths), i)) > start
Path must be specified as an array
0 && "jv_keys passed something neither object nor array"
0 && "invalid kind passed to jv_cmp"
Path must be specified as array, not %s
jv_group
sort_items
jv_sort
jv_cmp
jv_keys
delpaths_sorted
jv_dels
jv_has
jv_set
parse_slice
Could not open %s: %s
Error reading from %s
error: cannot allocate memory
{"a':"12"}
jq_test.c
before == after
hello%d%s
hello42!
jq: error
%%FAIL IGNORE MSG
Disassembly:
*** Expected 
, but got 
*** Superfluous result: 
%%FAIL
fopen
jv_get_kind(v) == JV_KIND_INVALID
Expected separator between values at line 1, column 9 (while parsing '{"a':"12"}')
__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (jv_string_value(v)) && __builtin_constant_p ("Expected separator between values at line 1, column 9 (while parsing '{\"a':\"12\"}')") && (__s1_len = strlen (jv_string_value(v)), __s2_len = strlen ("Expected separator between values at line 1, column 9 (while parsing '{\"a':\"12\"}')"), (!((size_t)(const void *)((jv_string_value(v)) + 1) - (size_t)(const void *)(jv_string_value(v)) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("Expected separator between values at line 1, column 9 (while parsing '{\"a':\"12\"}')") + 1) - (size_t)(const void *)("Expected separator between values at line 1, column 9 (while parsing '{\"a':\"12\"}')") == 1) || __s2_len >= 4)) ? __builtin_strcmp (jv_string_value(v), "Expected separator between values at line 1, column 9 (while parsing '{\"a':\"12\"}')") : (__builtin_constant_p (jv_string_value(v)) && ((size_t)(const void *)((jv_string_value(v)) + 1) - (size_t)(const void *)(jv_string_value(v)) == 1) && (__s1_len = strlen (jv_string_value(v)), __s1_len < 4) ? (__builtin_constant_p ("Expected separator between values at line 1, column 9 (while parsing '{\"a':\"12\"}')") && ((size_t)(const void *)(("Expected separator between values at line 1, column 9 (while parsing '{\"a':\"12\"}')") + 1) - (size_t)(const void *)("Expected separator between values at line 1, column 9 (while parsing '{\"a':\"12\"}')") == 1) ? __builtin_strcmp (jv_string_value(v), "Expected separator between values at line 1, column 9 (while parsing '{\"a':\"12\"}')") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("Expected separator between values at line 1, column 9 (while parsing '{\"a':\"12\"}')"); int __result = (((const unsigned char *) (const char *) (jv_string_value(v)))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (jv_string_value(v)))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (jv_string_value(v)))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (jv_string_value(v)))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("Expected separator between values at line 1, column 9 (while parsing '{\"a':\"12\"}')") && ((size_t)(const void *)(("Expected separator between values at line 1, column 9 (while parsing '{\"a':\"12\"}')") + 1) - (size_t)(const void *)("Expected separator between values at line 1, column 9 (while parsing '{\"a':\"12\"}')") == 1) && (__s2_len = strlen ("Expected separator between values at line 1, column 9 (while parsing '{\"a':\"12\"}')"), __s2_len < 4) ? (__builtin_constant_p (jv_string_value(v)) && ((size_t)(const void *)((jv_string_value(v)) + 1) - (size_t)(const void *)(jv_string_value(v)) == 1) ? __builtin_strcmp (jv_string_value(v), "Expected separator between values at line 1, column 9 (while parsing '{\"a':\"12\"}')") : (- (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) (jv_string_value(v)); int __result = (((const unsigned char *) (const char *) ("Expected separator between values at line 1, column 9 (while parsing '{\"a':\"12\"}')"))[0] - __s2[0]); if (__s2_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) ("Expected separator between values at line 1, column 9 (while parsing '{\"a':\"12\"}')"))[1] - __s2[1]); if (__s2_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) ("Expected separator between values at line 1, column 9 (while parsing '{\"a':\"12\"}')"))[2] - __s2[2]); if (__s2_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) ("Expected separator between values at line 1, column 9 (while parsing '{\"a':\"12\"}')"))[3] - __s2[3]); } } __result; })))) : __builtin_strcmp (jv_string_value(v), "Expected separator between values at line 1, column 9 (while parsing '{\"a':\"12\"}')")))); }) == 0
jv_array_length(jv_copy(a)) == 0
jv_array_length(jv_copy(a)) == 1
jv_number_value(jv_array_get(jv_copy(a), 0)) == 42
jv_equal(jv_copy(a), jv_copy(a))
jv_equal(jv_copy(a2), jv_copy(a2))
jv_equal(jv_copy(a), jv_copy(a2))
jv_equal(jv_copy(a2), jv_copy(a))
!jv_equal(jv_copy(a), jv_copy(a2))
!jv_equal(jv_copy(a2), jv_copy(a))
jv_array_length(jv_copy(a)) == 2
jv_get_kind(subarray) == JV_KIND_ARRAY
jv_array_length(jv_copy(subarray)) == 1
jv_number_value(jv_array_get(jv_copy(subarray), 0)) == 42
jv_get_kind(sub2) == JV_KIND_ARRAY
jv_array_length(jv_copy(sub2)) == 2
jv_number_value(jv_array_get(jv_copy(sub2), 0)) == 42
jv_number_value(jv_array_get(jv_copy(sub2), 1)) == 19
jv_array_length(jv_copy(a3)) == 3
jv_number_value(jv_array_get(jv_copy(a3), 0)) == 42
jv_array_length(jv_array_get(jv_copy(a3), 1)) == 1
jv_number_value(jv_array_get(jv_copy(a3), 2)) == 19
jv_array_length(jv_copy(a4)) == 1
jv_array_length(jv_copy(a4)) == 2
jv_array_length(jv_copy(a5)) == 2
jv_array_length(jv_array_get(jv_copy(a), 1)) == 1
jv_equal(jv_string("foo"), jv_string_sized("foo", 3))
jv_string_length_bytes(jv_copy(shortstr)) == (int)strlen(nasty)
jv_string_length_bytes(jv_copy(longstr)) == (int)sizeof(nasty)
jv_equal(jv_copy(a1), jv_copy(a2))
jv_equal(jv_copy(a2), jv_copy(a1))
!jv_equal(jv_copy(a1), jv_copy(b))
jv_string_hash(jv_copy(a1)) == jv_string_hash(jv_copy(a1))
jv_string_hash(jv_copy(a1)) == jv_string_hash(jv_copy(a2))
jv_string_hash(jv_copy(b)) != jv_string_hash(jv_copy(a1))
jv_equal(jv_string("hello42!"), jv_string_fmt("hello%d%s", 42, "!"))
jv_string_length_bytes(jv_copy(str)) == sizeof(big) - 1
!__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (big) && __builtin_constant_p (jv_string_value(str)) && (__s1_len = strlen (big), __s2_len = strlen (jv_string_value(str)), (!((size_t)(const void *)((big) + 1) - (size_t)(const void *)(big) == 1) || __s1_len >= 4) && (!((size_t)(const void *)((jv_string_value(str)) + 1) - (size_t)(const void *)(jv_string_value(str)) == 1) || __s2_len >= 4)) ? __builtin_strcmp (big, jv_string_value(str)) : (__builtin_constant_p (big) && ((size_t)(const void *)((big) + 1) - (size_t)(const void *)(big) == 1) && (__s1_len = strlen (big), __s1_len < 4) ? (__builtin_constant_p (jv_string_value(str)) && ((size_t)(const void *)((jv_string_value(str)) + 1) - (size_t)(const void *)(jv_string_value(str)) == 1) ? __builtin_strcmp (big, jv_string_value(str)) : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) (jv_string_value(str)); int __result = (((const unsigned char *) (const char *) (big))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (big))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (big))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (big))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p (jv_string_value(str)) && ((size_t)(const void *)((jv_string_value(str)) + 1) - (size_t)(const void *)(jv_string_value(str)) == 1) && (__s2_len = strlen (jv_string_value(str)), __s2_len < 4) ? (__builtin_constant_p (big) && ((size_t)(const void *)((big) + 1) - (size_t)(const void *)(big) == 1) ? __builtin_strcmp (big, jv_string_value(str)) : (- (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) (big); int __result = (((const unsigned char *) (const char *) (jv_string_value(str)))[0] - __s2[0]); if (__s2_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (jv_string_value(str)))[1] - __s2[1]); if (__s2_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (jv_string_value(str)))[2] - __s2[2]); if (__s2_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (jv_string_value(str)))[3] - __s2[3]); } } __result; })))) : __builtin_strcmp (big, jv_string_value(str))))); })
jv_number_value(jv_object_get(jv_copy(o1), jv_string("foo"))) == 42
jv_number_value(jv_object_get(jv_copy(o1), jv_string("bar"))) == 24
jv_number_value(jv_object_get(jv_copy(o2), jv_string("foo"))) == 420
jv_number_value(jv_object_get(jv_copy(o2), jv_string("bar"))) == 240
Testing '%s' at line number %u
*** Test program compiled that should not have at line %u: %s
*** Erroneous test program failed with wrong message (%s) at line %u: %s
*** Test program failed to compile at line %u: %s
*** Input is invalid on line %u: %s
*** Expected result is invalid on line %u: %s
*** Insufficient results for test at line number %u: %s
jv_equal(jv_copy(expected), jv_copy(reparsed))
 for test at line number %u, %s
%d of %d tests passed (%d malformed)
run_jq_tests
jv_test
pCjq: error: Could not open file %s: %s
Could not find home directory.
jv_get_kind(path) == JV_KIND_STRING
cb == jq_util_input_next_input_cb
Input error: %s
<stdin>
util.c
%s/%s
Could not expand %s. (%s)
!jv_is_valid(state->slurped)
<unknown>
%s:%lu
Unknown input filename
Unknown input line number
jq_util_input_get_position
jq_util_input_set_parser
expand_path
Modules must be named by relative paths using '/', not '\' (%s)
Relative paths to modules may not traverse to parent directories (%s)
module names must not have equal consecutive components: %s
Module search path must be an array
jv_get_kind(search_path) == JV_KIND_ARRAY
!jv_is_valid(as) || jv_get_kind(as) == JV_KIND_STRING
jq: error loading data file %s: %s
Module path must be a string
linker.c
$ORIGIN/
jq/main
%s/%s/%s%s
module not found: %s (%s)
module not found: %s
.json
search
jq: error: %s
unknown error
deps
process_dependencies
build_lib_search_chain
parser.y
funcname
_modify
syntax error
syntax error, unexpected %s
unexpected
*label-%s
_assign
Division by zero?
Remainder by zero?
recurse
line
file
module
import
include
then
else
elif
catch
__loc__
memory exhausted
$end
$undefined
INVALID_CHARACTER
IDENT
FIELD
LITERAL
FORMAT
".."
"%="
"=="
"!="
"//"
"as"
"def"
"module"
"import"
"include"
"if"
"then"
"else"
"elif"
"reduce"
"foreach"
"end"
"and"
"or"
"try"
"catch"
"label"
"break"
"__loc__"
"|="
"+="
"-="
"*="
"/="
"//="
"<="
">="
QQSTRING_START
QQSTRING_TEXT
QQSTRING_INTERP_START
QQSTRING_INTERP_END
QQSTRING_END
FUNCDEF
NONOPT
$accept
TopLevel
Module
Imports
FuncDefs
Import
FuncDef
Params
Param
QQString
ElseBody
ExpD
Term
Args
Pattern
ArrayPats
ObjPats
ObjPat
Keyword
MkDict
MkDictPair
syntax error, unexpected %s, expecting %s
syntax error, unexpected %s, expecting %s or %s
syntax error, unexpected %s, expecting %s or %s or %s
syntax error, unexpected %s, expecting %s or %s or %s or %s
jq: error: %s (Unix shell quoting issues?)
Module metadata must be constant.
Possibly unterminated 'if' statement
Possibly unterminated 'try' statement
break requires a label to break to
try .["field"] instead of .field for unusually named fields
jq: error: library should only have function definitions, not a main expression
block_has_only_binders_and_imports(*answer, OP_IS_CALL_PSEUDO)
jq_parse_library
gen_binop
DEEFFGGHHIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIJJJJJJKKLLMMONPNQQQRRSSSTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTUUVWWWXXYYZZZZZ[[[[[[[[[[[[[[[[[[[\\\\]]]]]]]]
(4;=?@BIKNT
GJ;9(
ITTI=
;=N[\]	
 !"#$%&'./012345679:I
?@NNHIKGIUVP;>
9AA/C>
>>C/IIIIIIIIIIIIIIIIIIIIIIII9=@BWN
:IH:<Q
=LMI
I.)*,
\4ST<<SS\
;=NYZ[.9AI9>A
=:V,
R;;IIS.>>/A>I
>/C>IAAI9:I
M>IIII+SSSWW<WZW99A::II
::>9::IIIWR<:<I<
iQ`bI
kcUOld
!#%&L
4p?:
|x{\[]30
;<53/4?6
>:1029
 !"#$%&'()*+,-8
"%.*s"
flex scanner jammed
input in flex scanner failed
lexer.l
state
start-condition stack underflow
jq_yyset_lineno called with no buffer
jq_yyset_column called with no buffer
out of dynamic memory in jq_yy_create_buffer()
out of dynamic memory in jq_yyensure_buffer_stack()
out of dynamic memory in jq_yy_scan_buffer()
out of dynamic memory in jq_yy_scan_bytes()
bad buffer in jq_yy_scan_bytes()
out of memory expanding start-condition stack
fatal flex scanner internal error--end of buffer missed
fatal error - scanner input buffer overflow
out of dynamic memory in yy_get_next_buffer()
fatal flex scanner internal error--no action found
enter
;*2$"D
libjq.so.1.0.4.debug
7zXZ
FGaIh
qy0;
i>a@
EhqV
E$uq
41N'y
WL	!
yoEV
Q@3aO
d!M}
j>3A
5rk|
 %jn
<,VCh
X3<f
=9B98W
(%I:
qI21>
r#}BD
d4^]n
U5Tta4
AMLkkP
~,Po
:sCL
za`8F
`u"`
io,Q
)jcH
Z"rCy~{x
 >	6s)
`*~h
$HsU
M0i^
z	6B
00OZ3
L+h~
_eX'
rwbEa
b9m#
9m^R
-?P<
erTqa
+sGuOrE-=
xx0o
i' _F
F(OQC@Q
XH{`
vI$i
DzR*
qv7~
Ym2^
L Tl
D8 }-5sb
7t\|
N9A{V
T4!t?^
n}fbq\]
#^c:
]=X.
dl:5
V}8?
I#x:y
RA_t
DB6p
%l4w
<XGP_[+
Z8Zdk
RRZ_
VH	q"
p5;m
$VDk[
O(k9 "B
#~Qs
/Psx
i#%<
gEb<
t55h
.shstrtab
.note.gnu.build-id
.gnu.hash
.dynsym
.dynstr
.gnu.version
.gnu.version_r
.rel.dyn
.rel.plt
.init
.text
.fini
.rodata
.eh_frame_hdr
.eh_frame
.tbss
.init_array
.fini_array
.jcr
.data.rel.ro
.dynamic
.got
.bss
.gnu_debuglink
.gnu_debugdata
