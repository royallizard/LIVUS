a\.z
gf0R
nYhq
[tOM
NFsu
u	rh%
j$0a
Kt+Zv
5p2c
g^Y~
z8h%
__gmon_start__
_fini
__cxa_finalize
_Jv_RegisterClasses
gg_crc32
memset
gg_chomp
strlen
gg_base64_encode
malloc
gg_urlencode
__stack_chk_fail
gg_proxy_auth
gg_proxy_enabled
gg_proxy_username
gg_proxy_password
__snprintf_chk
gg_base64_decode
calloc
strchr
gg_get_line
gg_gethostbyname
gg_http_hash
gg_vsaprintf
__vsnprintf_chk
gg_saprintf
gg_debug_common
gg_debug_handler_session
gg_debug_handler
gg_debug_level
gg_debug_file
__vfprintf_chk
stderr
gg_debug_session
__errno_location
gg_debug
gg_read_line
strerror
gg_connect
inet_ntoa
socket
gg_local_ip
bind
ioctl
close
gg_dcc_set_type
gg_dcc_free
gg_dcc_voice_send
gg_fix32
gg_dcc_socket_create
listen
gg_dcc_voice_chat
gg_dcc_send_file
gg_dcc_get_file
gg_dcc_request
gg_send_message_ctcp
gg_dcc_watch_fd
getsockopt
__read_chk
accept
lseek
memcpy
strncmp
gg_dcc_fill_file_info2
__xstat
open
strrchr
__ctype_toupper_loc
strncpy
gg_dcc_fill_file_info
gg_image_queue_remove
gg_event_free
gg_pubdir50_free
gg_watch_fd
gg_resolve_pthread_cleanup
strtol
strcpy
realloc
strcat
gg_proxy_http_only
gg_recv_packet
SSL_connect
SSL_get_current_cipher
SSL_CIPHER_get_name
SSL_get_peer_certificate
X509_get_subject_name
X509_NAME_oneline
X509_get_issuer_name
SSL_set_fd
SSL_get_error
ERR_get_error
ERR_error_string_n
gg_pubdir50_handle_reply
gg_fix16
inet_addr
gg_login_hash
gg_dcc_ip
gg_dcc_port
gg_send_packet
getsockname
__strdup
gg_http_free_fields
gg_http_stop
gg_http_free
gg_http_watch_fd
memmove
strstr
strncasecmp
gg_http_connect
gg_proxy_host
gg_proxy_port
gg_resolve_pthread
gg_userlist_get_free
gg_userlist_put_free
gg_userlist_remove_free
gg_free_search
gg_search_request_mode_0
gg_search_request_mode_1
gg_search_request_mode_2
gg_search_request_mode_3
gg_search_request_free
gg_change_info_request_new
gg_change_info_request_free
gg_change_info
gg_remind_passwd2
gg_remind_passwd
gg_change_passwd3
gg_change_passwd2
gg_change_passwd
gg_unregister2
gg_unregister
gg_register2
gg_register
gg_search_watch_fd
gg_search
gg_userlist_remove_watch_fd
gg_userlist_remove
gg_userlist_put_watch_fd
gg_userlist_put
gg_userlist_get_watch_fd
gg_userlist_get
gg_token_free
gg_pubdir_free
gg_token_watch_fd
sscanf
gg_token
gg_pubdir_watch_fd
gg_remind_passwd3
gg_change_passwd4
gg_register3
gg_unregister3
random
gg_pubdir50_count
gg_pubdir50_type
gg_pubdir50_next
gg_pubdir50_seq
gg_pubdir50_seq_set
gg_pubdir50_get
strcasecmp
strcmp
gg_pubdir50_add
gg_pubdir50_new
gg_pubdir50
gg_libgadu_version
gg_write
SSL_write
gg_read
SSL_read
pipe
pthread_create
pthread_self
pthread_detach
pthread_exit
pthread_cancel
pthread_join
gg_free_session
SSL_free
SSL_CTX_free
gg_resolve
fork
__memcpy_chk
gg_userlist_request
gg_remove_notify_ex
gg_remove_notify
gg_add_notify_ex
gg_add_notify
gg_notify
gg_notify_ex
gg_ping
gg_send_message_confer_richtext
rand
gg_send_message_confer
gg_send_message_richtext
gg_send_message
gg_image_reply
__strcpy_chk
gg_image_request
gg_change_status_descr_time
gg_change_status_descr
gg_change_status
gg_logoff
SSL_shutdown
gg_login
SSL_library_init
RAND_status
TLSv1_client_method
SSL_CTX_new
SSL_CTX_set_verify
SSL_new
RAND_seed
libssl.so.6
libcrypto.so.6
libdl.so.2
libz.so.1
libpthread.so.0
libc.so.6
_edata
__bss_start
_end
libgadu.so.3
GLIBC_2.2.5
GLIBC_2.4
GLIBC_2.3
GLIBC_2.3.4
ATSubH
[]A\A]
ffff.
<	vk
l$ H
t$ H
tSL9
t:r,A
AVAUI
ATE1
T$PH
t$ dH
D$81
D$@H
t$HH
L$XL
D$`L
T$8dH3
[]A\A]A^
fff.
|$ M
l$@H
\$8L
d$HL
l$PH
fff.
t$(H
L$8L
D$@L
L$HH
D$ H
D$@H
L$HH)
D$ L
L$8H
D$@L
L$HA
D$ 1
[]A\A]
D$81
D$"A
T$8dH3
\$@H
l$HL
d$PL
l$XL
t$`H
[]A\H
fffff.
l$ L
d$(L
l$0H
\$(H
l$0L
d$8L
l$@L
t$HL
|$PH
l$@H
\$8L
d$HL
l$PL
t$XL
|$`H
|$ H
l$ A
ffff.
l$ A
ffff.
l$ A
ffff.
$v'H
L$LL
l$LI
D$PH
D$$H
EP+ET
EL;Ex
ET;EP
Ex+EL
D$$H
ET;EP
|$ H
ET;EP
ETr+H
D$_<
D$_<
T$_H
T$H1
d$`)
]x+]L
EL;Ex
ET;EP
|$HH
|$XH
|$hH
H(H9
A(H9
D$XvTH
L$PH
t$PH
t$PH
|$P1
T$PH
L$PH
H+T$P
L$PH
H+L$PHc
L$HH
t$hI
D$hH
D$hI
T$pA
D9|$l
L$PH
\$gI
D$lD)
D$lH
D$pL
T$ H
C	H9
{	L;
d$(M
A;D$
A;T$
|$ A
D$ A;D$
|$|E1
D$8H
D;D$|u
D$|L
fffff.
}@Lc
Hc}PL
HcUPH
\$HH
l$PL
d$XL
l$`L
t$hL
|$pH
D$ t
|$(H
D$ H
t$ H
|$ H
D$ H
T$ H
|$01
fffff.
fffff.
fffff.
fffff.
ffff.
ffff.
ffff.
ffff.
fffff.
ffff.
fffff.
fffff.
fffff.
l$ L
d$(L
l$0L
t$8L
|$@H
ffff.
C(u*H
l$ L
t$(L
|$0H
L$ H
T$`L
T$`H
C(u,H
l$0H
\$(L
d$8L
l$@L
t$HL
|$PH
C(u*H
l$ L
t$(L
|$0H
C(u*H
l$ H
d$(L
l$0L
t$8L
|$@H
AUATA
D9#u
[]A\A]A^
[]A\A]A^
~/E1
[]A\
[]A\
AUATUSH
t?D93u
[]A\A]A^A_
[]A\A]A^A_
fffff.
AVAUATI
[]A\A]A^A_
[]A\A]A^A_
[]A\A]A^A_
	tHH
l$ H
d$(L
l$0L
t$8L
|$@H
Hc|$
,$E1
E9t$
E9t$
ffff.
fff.
fffff.
]A\A]A^
d$ L
l$(L
t$0H
fff.
\$(H
l$0L
d$8L
l$@H
ffff.
AVAUI
ATUSH
8[]A\A]A^A_
[]A\A]A^A_
[]A\A]A^A_
D$ E1
L$ H
D$$H
AVAUATUSH
T$@H
L$HL
D$PH
D$0H
D$ H
[]A\A]A^A_
AUATI
[]A\A]
[]A\A]
[]A\A]
ffffff.
d$ H
fff.
d$ H
fff.
AUATUSH
[]A\A]A^A_
([]A\A]A^A_
[]A\A]A^A_
[]A\A]A^A_
AVAUATUSH
l$ H
t$4E1
|$(1
D)|$
D$ H
T$8H
HcT$
T$8H
|$(H
[]A\A]A^A_
H[]A\A]A^A_
[]A\A]A^A_
[]A\A]A^A_
ffff.
AWAVA
AUATUS
L$`L
D$XL
L$PL
[]A\A]A^A_
l$`H
D$pH
T$HH
;A;}
D$XL
|$h1
T$(H
T$PH
T$ H
T$pH
T$@H
D9t$|
T$h%
l$ L
t$(L
|$0H
D$ D
T$ L
\$8H
l$@L
d$HL
l$PL
t$XL
|$`H
fff.
t$ E1
ffff.
\$ H
l$(L
d$0L
l$8L
t$@H
AVAUATE
[]A\A]A^A_
D$HH
D$PD
T$81
T$8E
D$@H
D$ H
T$ F
|$01
T$8A)
D$5H
D$0H
T$ L
D$?A
\$HH
l$PL
d$XL
l$`L
t$hL
|$pH
D$0D
T$0L
D$,M
\$HH
l$PL
d$XL
l$`H
\$ H
l$(L
d$0H
fff.
ffff.
|$xH
T$ A
ELfA
T$\E
D$XE
D$PH
T$0A
t$8I
0123456789abcdef
%s:%s
** gg_connect(%s, %d, %d);
Proxy-Authorization: Basic %s
// gg_read_line() error on read (errno=%d, %s)
// gg_read_line() eof reached
// gg_connect() socket() failed (errno=%d, %s)
// gg_connect() bind() failed (errno=%d, %s)
// gg_connect() ioctl() failed (errno=%d, %s)
// gg_connect() connect() failed (errno=%d, %s)
// gg_connect() connect() in progress
++ gg_dcc %s (fd=%d,len=%d)
 %.2x
** gg_dcc_free(%p);
write
SEND
** gg_dcc_watch_fd(%p);
read
// gg_dcc_watch_fd() dialin
UDAG
++ gg_dcc_voice_send(%p, %p, %d);
// gg_dcc_voice_send() invalid argument
// gg_dcc_voice_send() write() failed
** gg_create_dcc_socket(%d, %d);
// gg_create_dcc_socket() invalid arguments
// gg_create_dcc_socket() can't create socket (%s)
// gg_create_dcc_socket() trying port %d
// gg_create_dcc_socket() no free port found
// gg_create_dcc_socket() unable to listen (%s)
// gg_create_dcc_socket() bound to port %d
// gg_create_dcc_socket() not enough memory for struct
** gg_dcc_transfer(%s, %d, %ld, %ld, %s);
// gg_dcc_transfer() invalid arguments
// gg_dcc_transfer() not enough memory
// gg_dcc_transfer() connection failed
// gg_dcc_voice_chat() handing over to gg_dcc_transfer()
// gg_dcc_send_file() handing over to gg_dcc_transfer()
// gg_dcc_get_file() handing over to gg_dcc_transfer()
// gg_dcc_watch_fd() invalid argument
// gg_dcc_watch_fd() not enough memory
// gg_dcc_watch_fd() can't accept() new connection (errno=%d, %s)
// gg_dcc_watch_fd() new direct connection from %s:%d
// gg_dcc_watch_fd() can't set nonblocking (errno=%d, %s)
// gg_dcc_watch_fd() not enough memory for client data
// gg_dcc_watch_fd() GG_READING_UIN_%d
// gg_dcc_watch_fd() read() failed (errno=%d, %s)
// gg_dcc_watch_fd() read() failed, connection broken
// gg_dcc_watch_fd() read() failed (%d bytes, %d needed)
// gg_dcc_watch_fd() GG_SENDING_ACK
// gg_dcc_watch_fd() write() failed (errno=%d, %s)
// gg_dcc_watch_fd() write() failed (%d needed, %d done)
// gg_dcc_watch_fd() GG_STATE_READING_TYPE
// gg_dcc_watch_fd() callback
// gg_dcc_watch_fd() unknown dcc type (%.4x) from %ld
// gg_dcc_watch_fd() GG_STATE_READING_REQUEST
// gg_dcc_watch_fd() file transfer request
// gg_dcc_watch_fd() voice chat request
// gg_dcc_watch_fd() unknown dcc request (%.4x) from %ld
// gg_dcc_watch_fd() GG_STATE_READING_FILE_INFO
// gg_dcc_watch_fd() GG_STATE_SENDING_FILE_ACK
// gg_dcc_watch_fd() out of memory
// gg_dcc_watch_fd() GG_STATE_SENDING_VOICE_ACK
// gg_dcc_watch_fd() GG_STATE_READING_FILE_HEADER
// gg_watch_fd() read() failed (errno=%d, %s)
// gg_dcc_watch_fd() transfer refused
// gg_dcc_watch_fd() empty chunk, EOF
// gg_dcc_watch_fd() GG_STATE_READING_VOICE_HEADER
// gg_dcc_watch_fd() peer breaking connection
// gg_dcc_watch_fd() unknown request (%.2x)
// gg_dcc_watch_fd() GG_STATE_READING_VOICE_SIZE
// gg_dcc_watch_fd() invalid voice frame size (%d)
// gg_dcc_watch_fd() out of memory for voice frame
// gg_dcc_watch_fd() GG_STATE_READING_VOICE_DATA
// gg_dcc_watch_fd() GG_STATE_CONNECTING
// gg_dcc_watch_fd() connection failed (fd=%d,errno=%d(%s),foo=%d,res=%d(%s))
// gg_dcc_watch_fd() connected, sending uins
// gg_dcc_watch_fd() GG_STATE_READING_ACK
// gg_dcc_watch_fd() did't get ack
// gg_dcc_watch_fd() GG_STATE_SENDING_VOICE_REQUEST
// gg_dcc_watch_fd() GG_STATE_SENDING_REQUEST
// gg_dcc_watch_fd() GG_STATE_SENDING_FILE_INFO
// gg_dcc_watch_fd() GG_STATE_READING_FILE_ACK
// gg_dcc_watch_fd() GG_STATE_READING_VOICE_ACK
// invalid reply (%.2x), connection refused
// gg_dcc_watch_fd() GG_STATE_SENDING_FILE_HEADER
// gg_dcc_watch_fd() GG_STATE_SENDING_FILE
// gg_dcc_watch_fd() offset=%d, size=%d
// gg_dcc_watch_fd() read() reached eof on empty file
// gg_dcc_watch_fd() read() failed. (errno=%d, %s)
// gg_dcc_watch_fd() read() reached eof
// gg_dcc_watch_fd() read() too much (read=%d, ofs=%d, size=%d)
// gg_dcc_watch_fd() reached EOF after cutting
// gg_dcc_watch_fd() write() failed (%s)
// gg_dcc_watch_fd() chunk finished
// gg_dcc_watch_fd() GG_STATE_GETTING_FILE
// gg_dcc_watch_fd() ofs=%d, size=%d, read()=%d
// gg_dcc_watch_fd() write() failed (%d:fd=%d:res=%d:%s)
// gg_dcc_watch_fd() GG_STATE_???
** gg_dcc_fill_file_info2(%p, "%s", "%s");
// gg_dcc_fill_file_info2() invalid arguments
// gg_dcc_fill_file_info2() stat() failed (%s)
// gg_dcc_fill_file_info2() that's a directory
// gg_dcc_fill_file_info2() open() failed (%s)
// gg_dcc_fill_file_info2() short name "%s", dos name "%s"
** gg_event_free(%p);
** gg_watch_fd(%p);
6, 1, 0, 158
http://appmsg.gadu-gadu.pl
appmsg3.asp
appmsg2.asp
HTTP/1.
notoperating
// gg_watch_fd() connected
CONNECT %s:%d HTTP/1.0
//   %s
//   cert subject: %s
//   cert issuer: %s
//   %s
255.255.255.255
userlist_reply=%p, len=%d
// gg_watch_fd() not enough memory for event data
// gg_watch_fd() GG_STATE_RESOLVING
// gg_watch_fd() resolving failed
// gg_watch_fd() resolved, connecting to %s:%d
// gg_watch_fd() connection failed (errno=%d, %s), critical
// gg_watch_fd() GG_STATE_CONNECTING_HUB
// gg_watch_fd() connection to proxy failed (errno=%d, %s)
// gg_watch_fd() connection to hub failed (errno=%d, %s), trying direct connection
// gg_watch_fd() direct connection failed (errno=%d, %s), critical
// gg_watch_fd() connected to hub, sending query
// gg_watch_fd() out of memory for client version
GET %s/appsvc/%s?fmnumber=%u&version=%s&lastmsg=%d HTTP/1.0
Host: appmsg.gadu-gadu.pl
User-Agent: Mozilla/4.7 [en] (Win98; I)
Pragma: no-cache
=> -----BEGIN-HTTP-QUERY-----
=> -----END-HTTP-QUERY-----
// gg_watch_fd() sending query failed
// gg_watch_fd() GG_STATE_READING_DATA
// gg_watch_fd() received http header (%s)
// gg_watch_fd() that's not what we've expected, trying direct connection
// gg_watch_fd() connection failed (errno=%d, %s), trying https
// gg_watch_fd() connection failed (errno=%d, %s)
// gg_watch_fd() out of memory for system message, ignoring
// gg_watch_fd() received http data (%s)
// gg_watch_fd() service unavailable
// gg_watch_fd() GG_STATE_CONNECTING_GG
// gg_watch_fd() proxy request:
//   %s
// gg_watch_fd() can't send proxy request
// gg_watch_fd() GG_STATE_TLS_NEGOTIATION
// gg_watch_fd() disconnected during TLS negotiation
// gg_watch_fd() SSL_connect() wants to read
// gg_watch_fd() SSL_connect() wants to write
// gg_watch_fd() SSL_connect() bailed out: %s
// gg_watch_fd() TLS negotiation succeded:
//   cipher: %s
//   WARNING! unable to get peer certificate!
// gg_watch_fd() GG_STATE_READING_KEY
// gg_watch_fd() proxy response:
//   %s
// gg_watch_fd() didn't receive packet (errno=%d, %s)
// gg_watch_fd() invalid packet received
// gg_watch_fd() challenge %.4x --> hash %.8x
// gg_watch_fd() gg_dcc_ip = %s
// gg_watch_fd() detecting address
// gg_watch_fd() detected address to %s
// gg_watch_fd() unable to detect address
// gg_watch_fd() sending GG_LOGIN60 packet
// gg_watch_fd() sending packet failed. (errno=%d, %s)
// gg_watch_fd() GG_STATE_READING_REPLY
// gg_watch_fd() login succeded
// gg_watch_fd() login failed
// gg_watch_fd() too many incorrect password attempts
// gg_watch_fd() invalid packet
// gg_watch_fd() GG_STATE_CONNECTED
** gg_watch_fd_connected(%p, %p);
// gg_watch_fd_connected() gg_recv_packet failed (errno=%d, %s)
** gg_handle_recv_msg(%p, %p);
// gg_handle_recv_msg() oops, silently ignoring the bait
// gg_handle_recv_msg() received ctcp packet
// gg_handle_recv_msg() malformed packet, message out of bounds (0)
// gg_handle_recv_msg() packet out of bounds (1)
// gg_handle_recv_msg() packet out of bounds (1.5)
// gg_handle_recv_msg() not enough memory for recipients data
// gg_handle_recv_msg() packet out of bounds (2)
// gg_handle_recv_msg() not enough memory for richtext data
// gg_handle_recv_msg() packet out of bounds (3)
// gg_handle_recv_msg() packet out of bounds (4)
// gg_image_queue_parse() not enough memory for filename
// gg_handle_recv_msg() unknown payload 0x%.2x
// gg_watch_fd_connected() received a notify reply
// gg_watch_fd_connected() incomplete packet
// gg_watch_fd_connected() not enough memory for notify data
// gg_watch_fd_connected() received a status change
// gg_watch_fd_connected() received a message ack
// gg_watch_fd_connected() received a pong
// gg_watch_fd_connected() received disconnection warning
// gg_watch_fd_connected() received pubdir/search reply
// gg_watch_fd_connected() received userlist reply
// gg_watch_fd_connected() not enough memory for userlist reply
// gg_watch_fd_connected() received unknown packet 0x%.2x
// gg_watch_fd() watch_fd_connected failed (errno=%d, %s)
// gg_image_queue_parse() unknown image from %d, size=%d, crc32=%.8x
// gg_image_queue_parse() malformed packet from %d, unlimited filename
** gg_http_watch_fd(%p);
=> http, resolving done
=> http, connecting to %s:%d
Content-length: 
=> http, body_size=%d
%s %s HTTP/1.0
// gg_http_watch_fd() invalid arguments
=> http, resolver thread failed
=> http, connection failed (errno=%d, %s)
=> http, async connection failed (errno=%d, %s)
=> http, connected, sending request
=> http, write() failed (len=%d, res=%d, errno=%d)
=> http, partial header sent (led=%d, sent=%d)
=> http, request sent (len=%d)
=> http, reading header failed (errno=%d)
=> http, connection reset by peer
=> http, read %d bytes of header
=> http, not enough memory for header
=> http, header_buf=%p, header_size=%d
=> http, got all header (%d bytes, %d left)
=> -----BEGIN-HTTP-HEADER-----
=> -----END-HTTP-HEADER-----
=> http, didn't get 200 OK -- no results
=> http, content-length not found
=> http, oversized reply (%d bytes needed, %d bytes left)
=> http, not enough memory (%d bytes for body_buf)
=> http, reading body failed (errno=%d)
=> http, we're done, closing socket
=> http, connection closed while reading (have %d, need %d)
=> http, read %d bytes of body
=> http, too much data (%d bytes, %d needed), enlarging buffer
=> http, not enough memory for data (%d needed)
=> body_done=%d, body_size=%d
// gg_http_connect() invalid arguments
%s http://%s:%d%s HTTP/1.0
%s%s
// gg_http_connect() not enough memory for query
// gg_http_connect() resolver failed
// gg_http_connect() resolver = %p
// gg_http_connect() host not found
// gg_http_connect() some strange error
// gg_change_info() is obsolete. use gg_pubdir50() instead
// gg_remind_passwd2() is obsolete. use gg_remind_passwd3() instead!
// gg_remind_passwd() is obsolete. use gg_remind_passwd3() instead!
// gg_change_passwd3() is obsolete. use gg_change_passwd4() instead!
// gg_change_passwd2() is obsolete. use gg_change_passwd4() instead!
// gg_change_passwd() is obsolete. use gg_change_passwd4() instead!
// gg_unregister2() is obsolete. use gg_unregister3() instead!
// gg_unregister() is obsolete. use gg_unregister3() instead!
// gg_register2() is obsolete. use gg_register3() instead!
// gg_register() is obsolete. use gg_register3() instead!
// gg_search() is obsolete. use gg_search50() instead!
// gg_userlist_remove() is obsolete. use gg_userlist_request() instead!
// gg_userlist_put() is obsolete. use gg_userlist_request() instead!
// gg_userlist_get() is obsolete. use gg_userlist_request() instead!
=> token, watch_fd issued on failed session
=> token, not enough memory for results
=> token, not enough memory for token url
Host: %s
User-Agent: Mozilla/4.7 [en] (Win98; I)
=> token, gg_http_connect() failed mysteriously
=> token, not enough memory for token data
Host: register.gadu-gadu.pl
Content-Type: application/x-www-form-urlencoded
User-Agent: Mozilla/4.7 [en] (Win98; I)
Content-Length: 0
Pragma: no-cache
=> pubdir, watch_fd issued on failed session
=> pubdir, not enough memory for results
Tokens okregisterreply_packet.reg.dwUserId=
=> pubdir, success (okregisterreply, uin=%d)
=> remind, not enough memory for form fields
userid=%d&code=%u&tokenid=%s&tokenval=%s&email=%s
Host: retr.gadu-gadu.pl
Content-Type: application/x-www-form-urlencoded
User-Agent: Mozilla/4.7 [en] (Win98; I)
Content-Length: %d
Pragma: no-cache
=> remind, not enough memory for query
=> remind, gg_http_connect() failed mysteriously
=> change, not enough memory for form fields
fmnumber=%d&fmpwd=%s&pwd=%s&email=%s&tokenid=%s&tokenval=%s&code=%u
Host: register.gadu-gadu.pl
Content-Type: application/x-www-form-urlencoded
User-Agent: Mozilla/4.7 [en] (Win98; I)
Content-Length: %d
Pragma: no-cache
=> change, not enough memory for query
=> change, gg_http_connect() failed mysteriously
=> register, not enough memory for form fields
pwd=%s&email=%s&tokenid=%s&tokenval=%s&code=%u
=> register, not enough memory for form query
=> register, not enough memory for query
=> register, gg_http_connect() failed mysteriously
=> unregister, NULL parameter
=> unregister, not enough memory for form fields
fmnumber=%d&fmpwd=%s&delete=1&pwd=%s&email=deletedaccount@gadu-gadu.pl&tokenid=%s&tokenval=%s&code=%u
=> unregister, not enough memory for form query
=> unregister, not enough memory for query
=> unregister, gg_http_connect() failed mysteriously
=> token, http failure
=> token body "%s"
%d %d %d
=> token, parsing failed
http://
%s?tokenid=%s
register.gadu-gadu.pl
=> token, url parsing failed
/appsvc/regtoken.asp
POST
=> pubdir, http failure
=> pubdir, let's parse "%s"
success
results
=> pubdir, success (uin=%d)
=> pubdir, error.
=> remind, NULL parameter
=> remind, %s
/appsvc/fmsendpwd3.asp
retr.gadu-gadu.pl
=> change, NULL parameter
=> change, %s
/appsvc/fmregister3.asp
=> register, NULL parameter
=> register, %s
deletedaccount@gadu-gadu.pl
=> unregister, %s
** gg_pubdir50_seq_set(%p, %d);
// gg_pubdir50_seq_set() invalid arguments
** gg_pubdir50_get(%p, %d, "%s");
// gg_pubdir50_get() invalid arguments
** gg_pubdir50_add_n(%p, %d, "%s", "%s");
// gg_pubdir50_add_n() out of memory
// gg_pubdir50_new() out of memory
** gg_pubdir50_handle_reply(%p, %p, %d);
// gg_pubdir50_handle_reply() invalid arguments
// gg_pubdir50_handle_reply() packet too short
// gg_pubdir50_handle_reply() unable to allocate reply
// gg_pubdir50_handle_reply() premature end of packet
// gg_pubdir50() invalid arguments
// gg_pubdir50() not connected
// gg_pubdir50() out of memory (%d bytes)
** gg_pubdir50_new(%d);
nextstart
** gg_pubdir50(%p, %p);
// gg_resolve_pthread() %p
** gg_resolve(%p, %p, "%s");
** gg_recv_packet(%p);
// gg_recv_packet(%.2x)
// gg_send_packet(0x%.2x)
** gg_notify(%p, %p, %d);
** gg_ping(%p);
** gg_change_status(%p, %d);
** gg_logoff(%p);
** gg_login(%p);
** gg_resolve_pthread(%p, %p, "%s");
// gg_resolve_pthread() invalid arguments
// gg_resolve_pthread() out of memory for resolver data
// gg_resolve_pthread() unable to create pipes (errno=%d, %s)
// gg_resolve_pthread() out of memory
// gg_resolve_phread() unable to create thread
// gg_recv_packet() header recv: resuming last read (%d bytes left)
// gg_recv_packet() header recv(%d,%p,%d) = %d
// gg_recv_packet() header recv() failed: connection broken
// gg_recv_packet() header recv() interrupted system call, resuming
// gg_recv_packet() header recv() incomplete header received
// gg_recv_packet() header recv() not enough memory
// gg_recv_packet() header recv() failed: errno=%d, %s
// gg_recv_packet() invalid packet length (%d)
// gg_recv_packet() resuming last gg_recv_packet()
// gg_recv_packet() not enough memory for packet data
// gg_recv_packet() body recv(%d,%p,%d) = %d
// gg_recv_packet() body recv() failed: connection broken
// gg_recv_packet() body recv() failed (errno=%d, %s)
// gg_recv_packet() %d bytes received, %d left
** gg_send_packet(%p, 0x%.2x, ...);
// gg_send_packet() not enough memory for packet header
// gg_send_packet() not enough memory for payload
// gg_send_packet() write() failed. res = %d, errno = %d (%s)
** gg_remove_notify_ex(%p, %u, %d);
** gg_add_notify_ex(%p, %u, %d);
** gg_notify_ex(%p, %p, %p, %d);
** gg_send_message_confer_richtext(%p, %d, %d, %p, %p, %p, %d);
** gg_send_message_confer(%p, %d, %d, %p, %p);
** gg_send_message_richtext(%p, %d, %u, %p, %p, %d);
** gg_send_message(%p, %d, %u, %p)
** gg_send_message_ctcp(%p, %d, %u, ...);
** gg_image_reply(%p, %d, "%s", %p, %d);
** gg_image_request(%p, %d, %u, 0x%.4x);
// gg_image_request() not enough memory for image queue
// gg_image_request() not enough memory for image
** gg_change_status_descr_time(%p, %d, "%s", %d);
** gg_change_status_descr(%p, %d, "%s");
** gg_login(%p: [uin=%u, async=%d, ...]);
// gg_login() not enough memory for session data
// gg_login() invalid arguments. uin and password needed
// gg_login() not enough memory for password
// gg_login() not enough memory for status
// gg_login() SSL_CTX_new() failed: %s
// gg_login() SSL_new() failed: %s
// gg_login() host "%s" not found
// gg_login() connection failed (errno=%d, %s)
// gg_login() critical error in gg_watch_fd()
// gg_login() could not login
// gg_login() resolving failed (errno=%d, %s)
// gg_login() direct connection failed (errno=%d, %s)
ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/
libgadu.so.3.7.0.debug
.shstrtab
.note.gnu.build-id
.gnu.hash
.dynsym
.dynstr
.gnu.version
.gnu.version_r
.rela.dyn
.rela.plt
.init
.text
.fini
.rodata
.eh_frame_hdr
.eh_frame
.ctors
.dtors
.jcr
.data.rel.ro
.dynamic
.got
.got.plt
.data
.bss
.gnu_debuglink
