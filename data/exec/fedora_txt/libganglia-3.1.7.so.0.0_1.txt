FlP9Y
/zgb
)Vr8
l72%
	Gl.`o
E1bZ
Z.kX
__gmon_start__
_fini
__cxa_finalize
_Jv_RegisterClasses
xdr_Ganglia_extra_data
xdr_string
xdr_Ganglia_value_types
xdr_enum
xdr_Ganglia_metadata_message
xdr_array
xdr_u_int
xdr_Ganglia_metric_id
xdr_bool
xdr_Ganglia_metadatadef
xdr_Ganglia_metadatareq
xdr_Ganglia_gmetric_ushort
xdr_u_short
xdr_Ganglia_gmetric_short
xdr_short
xdr_Ganglia_gmetric_int
xdr_int
xdr_Ganglia_gmetric_uint
xdr_Ganglia_gmetric_string
xdr_Ganglia_gmetric_float
xdr_float
xdr_Ganglia_gmetric_double
xdr_double
xdr_Ganglia_msg_formats
xdr_Ganglia_metadata_msg
xdr_Ganglia_value_msg
xdr_Ganglia_25metric
xdr_pointer
become_a_nobody
getpwnam
getuid
setuid
err_quit
debug_msg
debug_level
stderr
__vfprintf_chk
fputc
set_debug_msg_level
get_debug_msg_level
update_pidfile
fopen
__isoc99_fscanf
fclose
umask
unlink
getpid
__fprintf_chk
getpgid
err_msg
__errno_location
strerror
daemon_init
fork
setsid
daemon_proc
chdir
openlog
readn
read
writen
write
slurpfile
err_ret
skip_whitespace
__ctype_b_loc
skip_token
getenv
snprintf
dotconf_warning
__vsnprintf_chk
__stack_chk_fail
dotconf_substitute_env
strlen
__strdup
strncat
dotconf_register_options
realloc
malloc
dotconf_callback
dotconf_continue_line
dotconf_get_next_line
fgets
strcpy
dotconf_get_here_document
__xstat
memset
strncmp
dotconf_invoke_command
dotconf_read_arg
dotconf_find_command
dotconf_set_command
calloc
__isoc99_sscanf
dotconf_free_command
dotconf_handle_command
dotconf_command_loop_until_error
dotconf_command_loop
dotconf_create
access
strncasecmp
dotconf_cleanup
dotconf_is_wild_card
dotconf_wild_card_cleanup
dotconf_find_wild_card
strncpy
dotconf_strcmp_from_back
dotconf_question_mark_match
dotconf_star_match
dotconf_handle_star
__strncpy_chk
opendir
readdir
strstr
__strcat_chk
__sprintf_chk
strcmp
__strcpy_chk
dotconf_handle_wild_card
closedir
dotconf_handle_question_mark
__snprintf_chk
ganglia_quiet_errors
stdout
fflush
fputs
__syslog_chk
err_quiet
err_verbose
err_sys
err_dump
abort
llist_add
gexec_errno
strtol
strchr
strtod
gexec_cluster_free
gexec_cluster
g_tcp_socket_connect
XML_ParserCreate
time
XML_SetElementHandler
XML_SetUserData
XML_GetBuffer
XML_ParserFree
g_tcp_socket_delete
XML_ParseBuffer
llist_sort
XML_GetErrorCode
XML_ErrorString
XML_GetCurrentLineNumber
memcpy
datum_new
datum_free
hash_create
pthread_rdwr_init_np
hash_get_flags
hash_set_flags
hashval
__ctype_tolower_loc
hash_keycmp
hash_insert
pthread_rdwr_wlock_np
pthread_rdwr_wunlock_np
hash_lookup
pthread_rdwr_rlock_np
pthread_rdwr_runlock_np
hash_delete
hash_destroy
hash_walkfrom
hash_foreach
g_gethostbyname
inet_aton
gethostbyname_mutex
pthread_mutex_lock
pthread_mutex_unlock
g_gethostbyaddr
g_inetaddr_new
g_inetaddr_ref
g_inetaddr_unref
g_inetaddr_delete
g_inetaddr_get_port
g_inetaddr_set_port
g_inetaddr_is_multicast
g_inetaddr_get_interface_to
socket
getsockname
g_inetaddr_list_interfaces
ioctl
llist_remove
llist_search
llist_print
my_inet_ntop
pthread_mutex_init
pthread_cond_init
pthread_cond_wait
pthread_cond_signal
pthread_cond_broadcast
g_tcp_socket_new
g_tcp_socket_server_new_interface
setsockopt
g_tcp_socket_server_new
g_tcp_socket_server_accept
select
apr_sockaddr_info_get
apr_socket_create
apr_socket_opt_set
apr_socket_bind
apr_socket_close
apr_socket_addr_get
apr_sockaddr_vars_set
if_nametoindex
apr_gethostname
apr_socket_connect
apr_sockaddr_ip_buffer_get
apr_inet_ntop
memmove
create_udp_client
create_udp_server
create_tcp_server
apr_socket_listen
create_mcast_client
apr_mcast_hops
create_mcast_server
apr_strnatcasecmp
apr_os_sock_get
Ganglia_default_collection_groups
build_default_gmond_configuration
apr_pstrdup
apr_pstrcat
Ganglia_pool_create
libgmond_apr_lib_initialized
apr_initialize
apr_terminate
apr_pool_create_ex
Ganglia_pool_destroy
apr_pool_destroy
Ganglia_gmond_config_create
cfg_tilde_expand
cfg_init
cfg_parse
cfg_parse_buf
Ganglia_udp_send_channels_create
cfg_size
apr_array_make
apr_array_push
cfg_getnsec
cfg_getstr
cfg_getint
cfg_getbool
Ganglia_udp_send_message
apr_socket_send
Ganglia_metric_create
apr_palloc
apr_table_make
Ganglia_metadata_send
apr_table_elts
__ctype_toupper_loc
strcasecmp
xdrmem_create
Ganglia_value_send
Ganglia_metric_send
Ganglia_metric_destroy
check_value
Ganglia_metric_set
Ganglia_metadata_add
apr_table_add
cstr_to_slope
slope_to_cstr
has_wildcard
cfg_error
strrchr
apr_temp_dir_get
apr_psprintf
apr_file_mktemp
fnmatch
apr_file_puts
cfg_include
apr_file_close
libdl.so.2
libnsl.so.1
libpcre.so.0
libexpat.so.1
libconfuse.so.0
libapr-1.so.0
libpthread.so.0
libc.so.6
__cxa_atexit
_edata
__bss_start
_end
libganglia-3.1.7.so.0
/usr/lib64
GLIBC_2.3.2
GLIBC_2.2.5
GLIBC_2.4
GLIBC_2.3
GLIBC_2.7
GLIBC_2.3.4
ATSubH
ffff.
fff.
ffffff.
ffff.
T$0H
t$(H
L$8H)
D$@L
fffff.
[]A\
fff.
[]A\
[]A\A]
USt/H
[]A\
l$ L
t$(L
|$0H
ffff.
ffff.
+[]A\
D$ H
l$0I
AVAUATUSH
T$ H
,$M9
s:M9
t,<$u
[]A\A]A^A_
v+<}u
<$}tII
H+T$
gfff
C Mc
AUATA
[]A\A]
AWAVAUATUH
d$0L
tUIc
[]A\A]A^A_
fffff.
fff.
AVAUATI
\$0dH
[]A\A]A^A_
t$(1
t$(E
L;|$
D$(A
t$(I
D$(I
AWE1
AVAUE1
ATUH
t]Mc
[]A\A]A^A_
fff.
AWAVI
AUATI
\$0I
t$(A
l$(E
t$ Mc
8 ~h
D$ H
([]A\A]A^A_
D$ I
D$ H
fff.
A9\$(
|$ A\
fffff.
d$ L
|$hD
|$hM
\$xL
|$h1
HcL$
T$hL
T$(L
ffffff.
|$HH
l$ L
t$(L
|$0H
fff.
fffff.
\$8H
l$@L
d$HL
l$PL
t$XL
|$`H
D$ H
T$ A
8/t3H
H9\$
uCHcD$
Hc\$,H
D$ I
HcL$
Hc\$,
ATUH
xNHc
;u;A
[]A\
AVAUI
ATUH
~lIc
[]A\D
A]A^
t*<*t&<?t"1
l$ L
d$(L
l$0L
t$8L
|$@H
D;l$
ffff.
AVAUATUSH
|$8H
t$(dH
|$(B
T$XH
D$`H
t$PH
T$hH
D$pH
9t$4
D$PH
t$@I
D9d$0
|$XMc
t$@H
L$XL
D$(H
|$ H
t$HH
t$ H
D$`H
L$hH
T$pH
t$xH
D$(H
|$ H
T$8H
|$ H
T$8L
D$PH
[]A\A]A^A_
|$ Hc
D$8L
D$ H
T$8D
AVAUATI
D$`H
T$HH
D$pHcD$<H
T$hH
T$xH
D$<H
T$4E
T$$9T$8
D$49D$<
\$XH
L$@L
D$(H
t$HH
D$`H
L$hH
T$pH
t$xH
[]A\A]A^A_
Hct$$L
L$(L
T$PH
T$ H
t$/L
t$/L
|$ H
\$8H
l$@L
d$HL
l$PL
t$XL
|$`H
D$XH
T$0H
t$(H
D$@L
L$HH
D$ H
fffff.
T$0H
t$(H
D$@L
L$HH
D$ H
fff.
T$0H
t$(H
D$@L
L$HH
D$ H
T$0H
t$(H
D$@L
L$HH
D$ H
T$0H
t$(H
D$@L
L$HH
D$ H
fff.
fffff.
l$ L
t$(L
|$0H
unresolvH
unspecifH
fff.
[]A\
[]A\
AWAVAUATI
[]A\A]A^A_
[]A\A]A^A_
[]A\A]A^A_
[]A\A]A^A_
fff.
L9#v'N
L9#t:H
[]A\A]
fff.
fff.
AWAVI
AUATI
[]A\A]A^A_
AUATI
[]A\A]
[]A\A]
AVAUI
ATUH
]A\A]A^
]A\A]A^
ffffff.
AUATUH
tcE1
[]A\A]
ffffff.
AWAVAUI
ATUH
H;7sqL
[]A\A]A^A_
AWAVI
AUATI
teE1
[]A\A]A^A_
l$ L
d$(L
l$0L
t$8L
|$@H
-9| 
l$ H
fffff.
D$(1
T$(dH3
\$0H
l$8L
d$@H
fff.
fffff.
fffff.
D$(1
T$(dH3
\$0H
l$8L
d$@H
AVAUATUSH
D$81
T$8dH3
H[]A\A]A^A_
D$ H
D$(1
D$(I
ffff.
ATUH
[]A\A]
[]A\A]
UStMH
ATUH
fff.
ATUH
fff.
fff.
fffff.
AUATI
[]A\A]
[]A\A]
T$(1
T$(dH3
AWAVAUATUH
[]A\A]A^A_
d$ L
l$(L
t$0H
<$E1
ffffff.
|$0H
\$HH
l$PL
d$XL
l$`H
L$<A
|$ I
|$(I
l$0H
|$(I
D$ H
t$(H
t$ H
ffffff.
ffff.
l$ L
t$(L
|$0H
fffff.
T$`H
D$hH
L$`A
d$0H
l$ H
=qd 
AWAVAUATUSH
t$@H
|$HH
D$PH
D$hH
T$$L
L$(I
L$0H
|$hH
|$PA
(D9d$<
|$@H
D$$H
t$HH
|$X1
T$$L
D$(H
|$hE
T$$H
D$PH
x[]A\A]A^A_
[]A\A]A^A_
T$$H
~CHc
\$(H
l$0L
d$8L
l$@L
t$HL
|$PH
ATE1
AWAVAUATI
T$0H
T$8H
T$@H
T$HH
T$PH
T$XH
D$XLcu
t$`H
t$`I
D$ H
D$8I
\$pH
D$xH
[]A\A]A^A_
AWAVAUATI
\$@H
l$p1
D$HH
[]A\A]A^A_
fffff.
fff.
T$PD
T$XH
\$ H
l$(L
d$0L
l$8L
t$@H
fff.
?t.f
)tgH
T$ H
gmond.tmI
p.XXXXXXH
user '%s' does not exist
exiting. setuid '%s' error
Must be root to setuid to "%s"
daemon already running: %s pid %ld
Error writing pidfile '%s' -- %s
slurpfile() open() error on file %s
slurpfile() read() error on file %s
slurpfile() read() buffer overflow on file %s
DC_INCLUDEPATH
%s:%ld: 
Unbalanced '{'
Unterminated here-document!
Unknown Config-Option: '%s'
%s%s%s
Include
IncludePath
[dotconf] Parse error. Unexpected end of file at line %ld in file %s
[emerg] could not stat currently read file (%s)
Missing argument to option '%s'
Error opening configuration file '%s'
Error occured while processing wildcard %c
Filename is '%s'
Cannot open %s for inclusion.
IncludePath is '%s'
Absolute filename too long (>%d)
Error occured while attempting to process %s for inclusion.
IncludePath is '%s'
: %s
CLUSTER
LOCALTIME
METRIC
cpu_num
load_one
load_five
load_fifteen
proc_run
proc_total
cpu_user
cpu_nice
cpu_system
cpu_idle
cpu_wio
gexec
Connected to socket %s:%d
Created the XML Parser
Got the XML Buffer
Read %d bytes of data
gexec_cluster() XML_ParseBuffer() error at line %d:
hash_create size = %d
hash->size is %d
hash->node[i] malloc error
hash malloc error in hash_create()
hash->node malloc error. freeing hash.
tcp_listen() setsockopt() SO_REUSEADDR error
tcp_listen() setsockopt() SO_KEEPALIVE error
tcp_listen() setsockopt() TCP_NODELAY error
Warning: your operating system does not support IPV6_V6ONLY!
This means that you are also listening to IPv4 traffic on port %d
This IPv6=>IPv4 mapping may be a security risk.
/* Each metrics module that is referenced by gmond must be specified and
   loaded. If the module has been statically linked with gmond, it does
   not require a load path. However all dynamically loadable modules must
   include a load path. */
modules {
  module {
    name = "core_metrics"
  module {
    name = "cpu_module"
    path = "modcpu.so"
  module {
    name = "disk_module"
    path = "moddisk.so"
  module {
    name = "load_module"
    path = "modload.so"
  module {
    name = "mem_module"
    path = "modmem.so"
  module {
    name = "net_module"
    path = "modnet.so"
  module {
    name = "proc_module"
    path = "modproc.so"
  module {
    name = "sys_module"
    path = "modsys.so"
include ('/etc/ganglia/conf.d/*.conf')
/* The old internal 2.5.x metric array has been replaced by the following
   collection_group directives.  What follows is the default behavior for
   collecting and sending metrics that is as close to 2.5.x behavior as
   possible. */
/* This collection group will cause a heartbeat (or beacon) to be sent every
   20 seconds.  In the heartbeat is the GMOND_STARTED data which expresses
   the age of the running gmond. */
collection_group {
  collect_once = yes
  time_threshold = 20
  metric {
    name = "heartbeat"
/* This collection group will send general info about this host every
   1200 secs.
   This information doesn't change between reboots and is only collected
   once. */
collection_group {
  collect_once = yes
  time_threshold = 1200
  metric {
    name = "cpu_num"
    title = "CPU Count"
  metric {
    name = "cpu_speed"
    title = "CPU Speed"
  metric {
    name = "mem_total"
    title = "Memory Total"
  /* Should this be here? Swap can be added/removed between reboots. */
  metric {
    name = "swap_total"
    title = "Swap Space Total"
  metric {
    name = "boottime"
    title = "Last Boot Time"
  metric {
    name = "machine_type"
    title = "Machine Type"
  metric {
    name = "os_name"
    title = "Operating System"
  metric {
    name = "os_release"
    title = "Operating System Release"
  metric {
    name = "location"
    title = "Location"
/* This collection group will send the status of gexecd for this host
   every 300 secs.*/
/* Unlike 2.5.x the default behavior is to report gexecd OFF. */
collection_group {
  collect_once = yes
  time_threshold = 300
  metric {
    name = "gexec"
    title = "Gexec Status"
/* This collection group will collect the CPU status info every 20 secs.
   The time threshold is set to 90 seconds.  In honesty, this
   time_threshold could be set significantly higher to reduce
   unneccessary  network chatter. */
collection_group {
  collect_every = 20
  time_threshold = 90
  /* CPU status */
  metric {
    name = "cpu_user"
    value_threshold = "1.0"
    title = "CPU User"
  metric {
    name = "cpu_system"
    value_threshold = "1.0"
    title = "CPU System"
  metric {
    name = "cpu_idle"
    value_threshold = "5.0"
    title = "CPU Idle"
  metric {
    name = "cpu_nice"
    value_threshold = "1.0"
    title = "CPU Nice"
  metric {
    name = "cpu_aidle"
    value_threshold = "5.0"
    title = "CPU aidle"
  metric {
    name = "cpu_wio"
    value_threshold = "1.0"
    title = "CPU wio"
  /* The next two metrics are optional if you want more detail...
     ... since they are accounted for in cpu_system.
  metric {
    name = "cpu_intr"
    value_threshold = "1.0"
    title = "CPU intr"
  metric {
    name = "cpu_sintr"
    value_threshold = "1.0"
    title = "CPU sintr"
  */
collection_group {
  collect_every = 20
  time_threshold = 90
  /* Load Averages */
  metric {
    name = "load_one"
    value_threshold = "1.0"
    title = "One Minute Load Average"
  metric {
    name = "load_five"
    value_threshold = "1.0"
    title = "Five Minute Load Average"
  metric {
    name = "load_fifteen"
    value_threshold = "1.0"
    title = "Fifteen Minute Load Average"
/* This group collects the number of running and total processes */
collection_group {
  collect_every = 80
  time_threshold = 950
  metric {
    name = "proc_run"
    value_threshold = "1.0"
    title = "Total Running Processes"
  metric {
    name = "proc_total"
    value_threshold = "1.0"
    title = "Total Processes"
/* This collection group grabs the volatile memory metrics every 40 secs and
   sends them at least every 180 secs.  This time_threshold can be increased
   significantly to reduce unneeded network traffic. */
collection_group {
  collect_every = 40
  time_threshold = 180
  metric {
    name = "mem_free"
    value_threshold = "1024.0"
    title = "Free Memory"
  metric {
    name = "mem_shared"
    value_threshold = "1024.0"
    title = "Shared Memory"
  metric {
    name = "mem_buffers"
    value_threshold = "1024.0"
    title = "Memory Buffers"
  metric {
    name = "mem_cached"
    value_threshold = "1024.0"
    title = "Cached Memory"
  metric {
    name = "swap_free"
    value_threshold = "1024.0"
    title = "Free Swap Space"
collection_group {
  collect_every = 40
  time_threshold = 300
  metric {
    name = "bytes_out"
    value_threshold = 4096
    title = "Bytes Sent"
  metric {
    name = "bytes_in"
    value_threshold = 4096
    title = "Bytes Received"
  metric {
    name = "pkts_in"
    value_threshold = 256
    title = "Packets Received"
  metric {
    name = "pkts_out"
    value_threshold = 256
    title = "Packets Sent"
/* Different than 2.5.x default since the old config made no sense */
collection_group {
  collect_every = 1800
  time_threshold = 3600
  metric {
    name = "disk_total"
    value_threshold = 1.0
    title = "Total Disk Space"
collection_group {
  collect_every = 40
  time_threshold = 180
  metric {
    name = "disk_free"
    value_threshold = 1.0
    title = "Disk Space Available"
  metric {
    name = "part_max_used"
    value_threshold = 1.0
    title = "Maximum Disk Space Used"
/* This configuration is as close to 2.5.x default behavior as possible
   The values closely match ./gmond/metric.h definitions in 2.5.x */
globals {
  daemonize = yes
  setuid = yes
  user = ganglia
  debug_level = 0
  max_udp_msg_len = 1472
  mute = no
  deaf = no
  allow_extra_data = yes
  host_dmax = 0 /*secs */
  cleanup_threshold = 300 /*secs */
  gexec = no
  send_metadata_interval = 0 /*secs */
 * The cluster attributes specified will be used as part of the <CLUSTER>
 * tag that will wrap all hosts collected by this instance.
cluster {
  name = "unspecified"
  owner = "unspecified"
  latlong = "unspecified"
  url = "unspecified"
/* The host section describes attributes of the host, like the location */
host {
  location = "unspecified"
/* Feel free to specify as many udp_send_channels as you like.  Gmond
   used to only support having a single channel */
udp_send_channel {
  #bind_hostname = yes # Highly recommended, soon to be default.
                       # This option tells gmond to use a source address
                       # that resolves to the machine's hostname.  Without
                       # this, the metrics may appear to come from any
                       # interface and the DNS names associated with
                       # those IPs will be used to create the RRDs.
  mcast_join = 239.2.11.71
  port = 8649
  ttl = 1
/* You can specify as many udp_recv_channels as you like as well. */
udp_recv_channel {
  mcast_join = 239.2.11.71
  port = 8649
  bind = 239.2.11.71
/* You can specify as many tcp_accept_channels as you like to share
   an xml description of the state of the cluster */
tcp_accept_channel {
  port = 8649
Configuration file '%s' not found.
Your default configuration buffer failed to parse. Exiting.
udp_send_channel mcast_join=%s mcast_if=%s host=%s port=%d
udp_send_channel: bind and bind_hostname are mutually exclusive, both parameters can't be specified for the same udp_send_channel
Unable to join multicast channel %s:%d. Exiting
Unable to create UDP client for %s:%d. Exiting.
wrong number of arguments to cfg_include()
failed to determine the temp dir
unable to create a temporary file %s
failed to process include file %s
Parse error for '%s'
NULL
udp_send_channel
host
mcast_join
mcast_if
port
bind
bind_hostname
SPOOF_HOST
SPOOF_HEARTBEAT
heartbeat
float
double
string
uint8
uint16
uint32
zero
positive
negative
both
unspecified
%s/%s
include ('
processed include file %s
invalid include path
cluster
globals
udp_recv_channel
tcp_accept_channel
collection_group
include
modules
owner
latlong
location
daemonize
setuid
ganglia
debug_level
max_udp_msg_len
mute
deaf
allow_extra_data
host_dmax
cleanup_threshold
send_metadata_interval
module_dir
family
inet4
interface
timeout
metric
collect_once
collect_every
time_threshold
module
default
allow
access
name_match
value_threshold
title
language
Enabled
params
param
action
mask
value
libganglia-3.1.7.so.0.0.0.debug
.data
.rodata
.shstrtab
.dynamic
.note.gnu.build-id
.eh_frame
.gnu.hash
.fini
.gnu_debuglink
.dynsym
.gnu.version
.rela.dyn
.data.rel.ro
.gnu.version_r
.jcr
.eh_frame_hdr
.dynstr
.ctors
.dtors
.bss
.init
.rela.plt
.got.plt
.got
.text
