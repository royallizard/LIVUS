ca]u?L
__gmon_start__
_fini
_ITM_deregisterTMCloneTable
_ITM_registerTMCloneTable
__cxa_finalize
_Jv_RegisterClasses
PL_thr_key
pthread_getspecific
boot_DynaLoader
Perl_newXS
Perl_get_hv
Perl_newSViv
Perl_newCONSTSUB
Perl_get_sv
Perl_sv_setpv
exit
hexchat_print
Perl_sv_2uv_flags
hexchat_plugingui_remove
Perl_sv_2pv_flags
hexchat_nickcmp
Perl_sv_2mortal
malloc
hexchat_send_modes
Perl_av_len
Perl_av_fetch
Perl_sv_2iv_flags
hexchat_emit_print
hexchat_get_prefs
Perl_newSVpv
Perl_stack_grow
__stack_chk_fail
hexchat_get_context
hexchat_find_context
Perl_sv_2bool_flags
hexchat_pluginpref_list
strtok
hexchat_pluginpref_get_str
Perl_markstack_grow
hexchat_pluginpref_delete
hexchat_pluginpref_set_str
Perl_newSV_type
hexchat_list_time
Perl_newSVnv
Perl_hv_common_key_len
hexchat_list_int
Perl_newSVuv
hexchat_list_str
Perl_newSVpvn
Perl_newRV_noinc
hexchat_list_get
hexchat_list_next
hexchat_list_free
hexchat_list_fields
Perl_block_gimme
hexchat_get_info
hexchat_set_context
hexchat_command
Perl_newSVsv
hexchat_hook_timer
hexchat_hook_command
hexchat_hook_fd
Perl_push_scope
Perl_save_strlen
Perl_call_sv
hexchat_printf
Perl_free_tmps
Perl_pop_scope
Perl_gv_add_by_type
setlocale
Perl_sys_init3
perl_alloc
perl_construct
perl_parse
Perl_eval_pv
memcpy
opendir
readdir64
strcasecmp
__sprintf_chk
closedir
Perl_sv_setsv_flags
Perl_sv_mortalcopy_flags
Perl_call_pv
hexchat_hook_print
Perl_av_push
hexchat_hook_server
hexchat_plugingui_add
strchr
strncasecmp
hexchat_unhook
Perl_sv_free2
hexchat_plugin_get_info
hexchat_plugin_init
hexchat_plugin_deinit
perl_destruct
perl_free
Perl_sys_term
libperl.so.5.20
libresolv.so.2
libdl.so.2
libm.so.6
libcrypt.so.1
libutil.so.1
libpthread.so.0
libc.so.6
libssl.so.10
libcrypto.so.10
_edata
__bss_start
_end
perl.so
GLIBC_2.14
GLIBC_2.3.4
GLIBC_2.4
GLIBC_2.2.5
%z1!
%r1!
%j1!
%b1!
%Z1!
%R1!
%J1!
%B1!
%:1!
%21!
%*1!
%"1!
%z0!
%r0!
%j0!
%b0!
%Z0!
%R0!
%J0!
%B0!
%:0!
%20!
%*0!
%"0!
%z/!
%r/!
%j/!
%b/!
%Z/!
%R/!
%J/!
%B/!
%:/!
%2/!
%*/!
%"/!
fffff.
fffff.
fffff.
ATUSH
AUATUSH
HxLc"
[]A\A]
AUATUSH
HxLc"
[]A\A]
AVAUATUSH
t#[]A\A]A^H
=l$!
,$[]A\A]A^
AWAVAUATUSH
[]A\A]A^A_
=&!!
[]A\A]A^A_
[]A\A]A^A_
AWAVAUATUSH
HxHc*
$/Mc
[]A\A]A^A_
[]A\A]A^A_
D( L
AUATUSH
([]A\A]
@ L)
Lcl$
AUATUSH
[]A\A]
[]A\A]
AVAUATUSH
HxLc*
[]A\A]A^
AWAVAUATUSH
HxLc:
@ L)
@ H)
[]A\A]A^A_
AUATUSH
HxHc
[]A\A]
AUATUSH
HxHc
[]A\A]
AVAUATUSH
HxHc
[]A\A]A^
AWAVI
AUATUS1
<iu7H
[]A\A]A^A_
AVAUATUH
t"[]A\A]A^H
+[]A\A]A^
P H)
[]A\A]A^
AUATUSH
HxHc*
P L)
[]A\A]
AVAUATUSH
t![]A\A]A^H
@ L)
[]A\A]A^
AUATUSH
[]A\A]
[]A\A]
AUATUSH
HxLc"
[]A\A]
AWAVAUATUSH
[]A\A]A^A_
[]A\A]A^A_
ffff.
AWAVAUATUSH
[]A\A]A^A_
([]A\A]A^A_
AWAVAUATUSH
[]A\A]A^A_
[]A\A]A^A_
AVAUI
ATUI
t$XH
@ H)
H;hX~
]A\A]A^
ATUH
D$H1
L$HdH3
P[]A\
d$ H
D$ H
D$(H
D$0H
D$8H
fffff.
AUATUS
/addons
]A\A]A^
ffff.
tVATUSH
ffff.
tVUSH
[]A\H
[]A\
AWAVAUATI
@ H)
H;hX~
[]A\A]A^A_
@ L)
@ H)
fff.
AWAVAUATUSH
[]A\A]A^A_
D$ I
[]A\A]A^A_
AWAVAUATI
t$XH
D$XA
[]A\A]A^A_
@ L)
@ H)
L;`X
[]A\A]A^A_
AVAUI
]A\A]A^
AWAVI
AUATI
t$XH
[]A\A]A^A_
@ L)
@ L)
@ L)
L;`X
[]A\A]A^A_
AWAVI
AUATI
t$XH
[]A\A]A^A_
@ L)
@ L)
@ L)
L;`X
[]A\A]A^A_
AWAVAUATUSH
[]A\A]A^A_
D$ I
[]A\A]A^A_
AWAVAUATUSH
[]A\A]A^A_1
[]A\A]A^A_
ATUH
[]A\
ATUH
ATUS
fffff.
AVAUATUSH
HxHc*
[]A\A]A^
@ L)
[]A\A]A^
fffff.
AVAUI
ATUSH
t$XH
@ H)
H;hX~
[]A\A]A^
@ L)
ffff.
ATUH
StyH
perl.c
DynaLoader::boot_DynaLoader
HexChat::Internal::register
HexChat::Internal::hook_print
HexChat::Internal::hook_timer
HexChat::Internal::hook_fd
HexChat::Internal::unhook
HexChat::Internal::print
HexChat::Internal::command
HexChat::Internal::get_info
HexChat::Internal::get_list
HexChat::find_context
HexChat::get_context
HexChat::get_prefs
HexChat::emit_print
HexChat::send_modes
HexChat::nickcmp
HexChat::
PRI_HIGHEST
PRI_HIGH
PRI_NORM
PRI_LOW
PRI_LOWEST
EAT_NONE
EAT_HEXCHAT
EAT_XCHAT
EAT_PLUGIN
EAT_ALL
FD_READ
FD_WRITE
FD_EXCEPTION
FD_NOTSOCKET
KEEP
REMOVE
HexChat::VERSION
2.10.2
Usage: HexChat::get_context()
channels
Usage: HexChat::get_info(id)
gtkwin_ptr
libdirfs
xchatdirfs
configdir
Perl error: %s
perl_warnings
HexChat::Embed::load
%s/%s
HexChat::Embed::evaluate
HexChat::Embed::reload_all
HexChat::Embed::unload_all
Error in timer callback %s
HexChat::unhook
Error in print callback %s
Error in command callback %s
Error in server callback %s
HexChat::Embed::reload
HexChat::Embed::unload
Usage: HexChat::unhook(hook)
Error in fd callback %s
Perl
Perl scripting interface
pl_reload
unloadall
reloadall
Perl interface loaded
Perl interface unloaded
HexChat::Internal::hook_server
HexChat::Internal::hook_command
HexChat::Internal::set_context
HexChat::Internal::context_info
HexChat::Internal::plugin_pref_set
HexChat::Internal::plugin_pref_get
HexChat::Internal::plugin_pref_delete
HexChat::Internal::plugin_pref_list
HexChat::Embed::plugingui_remove
Usage: HexChat::Embed::plugingui_remove(handle)
Usage: HexChat::Internal::print(text)
Usage: HexChat::nickcmp(s1, s2)
Usage: HexChat::send_modes( targets, sign, mode, modes_per_line)
Usage: HexChat::emit_print(event_name, ...)
Usage: HexChat::get_prefs(name)
Usage: HexChat::find_context ([channel, [server]])
Usage: HexChat::get_list(name)
Usage: HexChat::Internal::context_info()
Usage: HexChat::set_context(ctx)
Usage: HexChat::Internal::command(command)
Usage: HexChat::Internal::hook_timer(timeout, callback, userdata, package)
Usage: HexChat::Internal::hook_command(name, priority, callback, help_text, userdata, package)
Usage: HexChat::Internal::hook_fd(fd, callback, flags, userdata)
Perl error: expected 1 value from %s, got: %d
HexChat::Embed::current_package
Timer handler should only return 1 value.
Usage: HexChat::Internal::hook_print(name, priority, callback, userdata, package)
Print handler should only return 1 value.
Command handler should only return 1 value.
Server handler should only return 1 value.
Usage: HexChat::Internal::hook_server(name, priority, callback, userdata, package)
Usage: HexChat::Internal::register(scriptname, version, desc, filename)
Fd handler should only return 1 value.
Perl interface already loaded
Reloads a Perl script. Syntax: /pl_reload <filename.pl>
Unloads all loaded Perl scripts.
Realoads all loaded Perl scripts.
Evaluates Perl code. Syntax: /pl <perl code>
BEGIN {
$INC{'IRC.pm'} = 'Compiled into the plugin.';
#line 1 "lib/IRC.pm"
package IRC;
sub IRC::register {
my ($script_name, $version, $callback) = @_;
my $package = caller;
$callback = Xchat::Embed::fix_callback( $package, undef, $callback) if $callback;
Xchat::register( $script_name, $version, undef, $callback );
sub IRC::add_command_handler {
my ($command, $callback) = @_;
my $package = caller;
$callback = Xchat::Embed::fix_callback( $package, undef, $callback );
my $start_index = $command ? 1 : 0;
Xchat::hook_command( $command,
sub {
no strict 'refs';
return &{$callback}($_[1][$start_index]);
return;
sub IRC::add_message_handler {
my ($message, $callback) = @_;
my $package = caller;
$callback = Xchat::Embed::fix_callback( $package, undef, $callback );
Xchat::hook_server( $message,
sub {
no strict 'refs';
return &{$callback}( $_[1][0] );
return;
sub IRC::add_print_handler {
my ($event, $callback) = @_;
my $package = caller;
$callback = Xchat::Embed::fix_callback( $package, undef, $callback );
Xchat::hook_print( $event,
sub {
my @word = @{$_[0]};
no strict 'refs';
return &{$callback}( join( ' ', @word[0..3] ), @word );
return;
sub IRC::add_timeout_handler {
my ($timeout, $callback) = @_;
my $package = caller;
$callback = Xchat::Embed::fix_callback( $package, undef, $callback );
Xchat::hook_timer( $timeout,
sub {
no strict 'refs';
&{$callback};
return 0;
return;
sub IRC::command {
my $command = shift;
if( $command =~ m{^/} ) {
$command =~ s{^/}{};
Xchat::command( $command );
} else {
Xchat::command( qq[say $command] );
sub IRC::command_with_channel {
my ($command, $channel, $server) = @_;
my $old_ctx = Xchat::get_context;
my $ctx = Xchat::find_context( $channel, $server );
if( $ctx ) {
Xchat::set_context( $ctx );
IRC::command( $command );
Xchat::set_context( $ctx );
sub IRC::command_with_server {
my ($command, $server) = @_;
my $old_ctx = Xchat::get_context;
my $ctx = Xchat::find_context( undef, $server );
if( $ctx ) {
Xchat::set_context( $ctx );
IRC::command( $command );
Xchat::set_context( $ctx );
sub IRC::dcc_list {
my @dccs;
for my $dcc ( Xchat::get_list( 'dcc' ) ) {
push @dccs, $dcc->{nick};
push @dccs, $dcc->{file} ? $dcc->{file} : '';
push @dccs, @{$dcc}{qw(type status cps size)};
push @dccs, $dcc->{type} == 0 ? $dcc->{pos} : $dcc->{resume};
push @dccs, $dcc->{address32};
push @dccs, $dcc->{destfile} ? $dcc->{destfile} : '';
return @dccs;
sub IRC::channel_list {
my @channels;
for my $channel ( Xchat::get_list( 'channels' ) ) {
push @channels, @{$channel}{qw(channel server)},
Xchat::context_info( $channel->{context} )->{nick};
return @channels;
sub IRC::get_info {
my $id = shift;
my @ids = qw(version nick channel server configdir xchatdir away network host topic);
if( $id >= 0 && $id <= 8 && $id != 5 ) {
my $info = Xchat::get_info($ids[$id]);
return defined $info ? $info : '';
} else {
if( $id == 5 ) {
return Xchat::get_info( 'away' ) ? 1 : 0;
} else {
return 'Error2';
sub IRC::get_prefs {
return 'Unknown variable' unless defined $_[0];
my $result = Xchat::get_prefs(shift);
return defined $result ? $result : 'Unknown variable';
sub IRC::ignore_list {
my @ignores;
for my $ignore ( Xchat::get_list( 'ignore' ) ) {
push @ignores, $ignore->{mask};
my $flags = $ignore->{flags};
push @ignores, $flags & 1, $flags & 2, $flags & 4, $flags & 8, $flags & 16,
$flags & 32, ':';
return @ignores;
sub IRC::print {
Xchat::print( $_ ) for @_;
return;
sub IRC::print_with_channel {
Xchat::print( @_ );
sub IRC::send_raw {
Xchat::commandf( qq[quote %s], shift );
sub IRC::server_list {
my @servers;
for my $channel ( Xchat::get_list( 'channels' ) ) {
push @servers, $channel->{server} if $channel->{server};
return @servers;
sub IRC::user_info {
my $user;
if( @_ > 0 ) {
$user = Xchat::user_info( shift );
} else {
$user = Xchat::user_info();
my @info;
if( $user ) {
push @info, $user->{nick};
if( $user->{host} ) {
push @info, $user->{host};
} else {
push @info, 'FETCHING';
push @info, $user->{prefix} eq '@' ? 1 : 0;
push @info, $user->{prefix} eq '+' ? 1 : 0;
return @info;
sub IRC::user_list {
my ($channel, $server) = @_;
my $ctx = Xchat::find_context( $channel, $server );
my $old_ctx = Xchat::get_context;
if( $ctx ) {
Xchat::set_context( $ctx );
my @users;
for my $user ( Xchat::get_list( 'users' ) ) {
push @users, $user->{nick};
if( $user->{host} ) {
push @users, $user->{host};
} else {
push @users, 'FETCHING';
push @users, $user->{prefix} eq '@' ? 1 : 0;
push @users, $user->{prefix} eq '+' ? 1 : 0;
push @users, ':';
Xchat::set_context( $old_ctx );
return @users;
} else {
return;
sub IRC::user_list_short {
my ($channel, $server) = @_;
my $ctx = Xchat::find_context( $channel, $server );
my $old_ctx = Xchat::get_context;
if( $ctx ) {
Xchat::set_context( $ctx );
my @users;
for my $user ( Xchat::get_list( 'users' ) ) {
my $nick = $user->{nick};
my $host = $user->{host} || 'FETCHING';
push @users, $nick, $host;
Xchat::set_context( $old_ctx );
return @users;
} else {
return;
sub IRC::add_user_list {}
sub IRC::sub_user_list {}
sub IRC::clear_user_list {}
sub IRC::notify_list {}
sub IRC::perl_script_list {}
BEGIN {
$INC{'HexChat.pm'} = 'Compiled into the plugin.';
$INC{'Xchat.pm'} = 'Compiled into the plugin.';
$INC{'HexChat/Embed.pm'} = 'Compiled into the plugin.';
$INC{'HexChat/List/Network.pm'} = 'Compiled into the plugin.';
$INC{'HexChat/List/Network/Entry.pm'} = 'Compiled into the plugin.';
$INC{'HexChat/List/Network/AutoJoin.pm'} = 'Compiled into the plugin.';
#line 1 "lib/HexChat.pm"
$SIG{__WARN__} = sub {
my $message = shift @_;
my ($package) = caller;
my $message_levels =	qr/ERROR|CRITICAL|WARNING|MESSAGE|INFO|DEBUG/i;
if( $message =~ /^(?:Gtk|GLib|Gdk)(?:-\w+)?-$message_levels/i ) {
print STDERR $message;
} else {
if( defined &HexChat::Internal::print ) {
HexChat::print( $message );
} else {
warn $message;
use File::Spec ();
use File::Basename ();
use File::Glob ();
use List::Util ();
use Symbol();
use Time::HiRes ();
use Carp ();
package HexChat;
use base qw(Exporter);
use strict;
use warnings;
sub PRI_HIGHEST ();
sub PRI_HIGH ();
sub PRI_NORM ();
sub PRI_LOW ();
sub PRI_LOWEST ();
sub EAT_NONE ();
sub EAT_HEXCHAT ();
sub EAT_PLUGIN ();
sub EAT_ALL ();
sub KEEP ();
sub REMOVE ();
sub FD_READ ();
sub FD_WRITE ();
sub FD_EXCEPTION ();
sub FD_NOTSOCKET ();
sub get_context;
sub HexChat::Internal::context_info;
sub HexChat::Internal::print;
sub EAT_XCHAT ();
BEGIN {
*Xchat:: = *HexChat::;
our %EXPORT_TAGS = (
constants => [
qw(PRI_HIGHEST PRI_HIGH PRI_NORM PRI_LOW PRI_LOWEST), # priorities
qw(EAT_NONE EAT_HEXCHAT EAT_XCHAT EAT_PLUGIN EAT_ALL), # callback return values
qw(FD_READ FD_WRITE FD_EXCEPTION FD_NOTSOCKET), # fd flags
qw(KEEP REMOVE), # timers
hooks => [
qw(hook_server hook_command hook_print hook_timer hook_fd unhook),
util => [
qw(register nickcmp strip_code send_modes), # misc
qw(print prnt printf prntf command commandf emit_print), # output
qw(find_context get_context set_context), # context
qw(get_info get_prefs get_list context_info user_info), # input
qw(plugin_pref_set plugin_pref_get plugin_pref_delete plugin_pref_list), #settings
$EXPORT_TAGS{all} = [ map { @{$_} } @EXPORT_TAGS{qw(constants hooks util)}];
our @EXPORT = @{$EXPORT_TAGS{constants}};
our @EXPORT_OK = @{$EXPORT_TAGS{all}};
sub register {
my ($package, $calling_package) = HexChat::Embed::find_pkg();
my $pkg_info = HexChat::Embed::pkg_info( $package );
my $filename = $pkg_info->{filename};
my ($name, $version, $description, $callback) = @_;
if( defined $pkg_info->{gui_entry} ) {
HexChat::print( "HexChat::register called more than once in "
. $pkg_info->{filename} );
return ();
$description = "" unless defined $description;
if( $callback ) {
$callback = HexChat::Embed::fix_callback(
$package, $calling_package, $callback
$pkg_info->{shutdown} = $callback;
unless( $name && $name =~ /[[:print:]\w]/ ) {
$name = "Not supplied";
unless( $version && $version =~ /\d+(?:\.\d+)?/ ) {
$version = "NaN";
$pkg_info->{gui_entry} =
HexChat::Internal::register( $name, $version, $description, $filename );
return ();
sub _process_hook_options {
my ($options, $keys, $store) = @_;
unless( @$keys == @$store ) {
die 'Number of keys must match the size of the store';
my @results;
if( ref( $options ) eq 'HASH' ) {
for my $index ( 0 .. @$keys - 1 ) {
my $key = $keys->[$index];
if( exists( $options->{ $key } ) && defined( $options->{ $key } ) ) {
${$store->[$index]} = $options->{ $key };
sub hook_server {
return undef unless @_ >= 2;
my $message = shift;
my $callback = shift;
my $options = shift;
my ($package, $calling_package) = HexChat::Embed::find_pkg();
$callback = HexChat::Embed::fix_callback(
$package, $calling_package, $callback
my ($priority, $data) = ( HexChat::PRI_NORM, undef );
_process_hook_options(
$options,
[qw(priority data)],
[\($priority, $data)],
my $pkg_info = HexChat::Embed::pkg_info( $package );
my $hook = HexChat::Internal::hook_server(
$message, $priority, $callback, $data, $package
push @{$pkg_info->{hooks}}, $hook if defined $hook;
return $hook;
sub hook_command {
return undef unless @_ >= 2;
my $command = shift;
my $callback = shift;
my $options = shift;
my ($package, $calling_package) = HexChat::Embed::find_pkg();
$callback = HexChat::Embed::fix_callback(
$package, $calling_package, $callback
my ($priority, $help_text, $data) = ( HexChat::PRI_NORM, undef, undef );
_process_hook_options(
$options,
[qw(priority help_text data)],
[\($priority, $help_text, $data)],
my $pkg_info = HexChat::Embed::pkg_info( $package );
my $hook = HexChat::Internal::hook_command(
$command, $priority, $callback, $help_text, $data, $package
push @{$pkg_info->{hooks}}, $hook if defined $hook;
return $hook;
sub hook_print {
return undef unless @_ >= 2;
my $event = shift;
my $callback = shift;
my $options = shift;
my ($package, $calling_package) = HexChat::Embed::find_pkg();
$callback = HexChat::Embed::fix_callback(
$package, $calling_package, $callback
my ($priority, $run_after, $filter, $data) = ( HexChat::PRI_NORM, 0, 0, undef );
_process_hook_options(
$options,
[qw(priority run_after_event filter data)],
[\($priority, $run_after, $filter, $data)],
if( $run_after and $filter ) {
Carp::carp( "HexChat::hook_print's run_after_event and filter options are mutually exclusive, you can only use of them at a time per hook" );
return;
if( $run_after ) {
my $cb = $callback;
$callback = sub {
my @args = @_;
hook_timer( 0, sub {
$cb->( @args );
if( ref $run_after eq 'CODE' ) {
$run_after->( @args );
return REMOVE;
return EAT_NONE;
if( $filter ) {
my $cb = $callback;
$callback = sub {
my @args = @{$_[0]};
my $event_data = $_[1];
my $event_name = $event;
my $last_arg = @args - 1;
my @new = $cb->( \@args, $event_data, $event_name );
if( @new > @args ) {
$event_name = pop @new;
if( @new == @args ) {
emit_print( $event_name, @new[ 0 .. $last_arg ] );
return EAT_ALL;
} elsif(
join( "\0", @{$_[0]} ) ne join( "\0", @args[ 0 .. $last_arg ] )
emit_print( $event_name, @args[ 0 .. $last_arg ] );
return EAT_ALL;
return EAT_NONE;
my $pkg_info = HexChat::Embed::pkg_info( $package );
my $hook = HexChat::Internal::hook_print(
$event, $priority, $callback, $data, $package
push @{$pkg_info->{hooks}}, $hook if defined $hook;
return $hook;
sub hook_timer {
return undef unless @_ >= 2;
my ($timeout, $callback, $data) = @_;
my ($package, $calling_package) = HexChat::Embed::find_pkg();
$callback = HexChat::Embed::fix_callback(
$package, $calling_package, $callback
ref( $data ) eq 'HASH' && exists( $data->{data} )
&& defined( $data->{data} )
$data = $data->{data};
my $pkg_info = HexChat::Embed::pkg_info( $package );
my $hook = HexChat::Internal::hook_timer( $timeout, $callback, $data, $package );
push @{$pkg_info->{hooks}}, $hook if defined $hook;
return $hook;
sub hook_fd {
return undef unless @_ >= 2;
my ($fd, $callback, $options) = @_;
return undef unless defined $fd && defined $callback;
my $fileno = fileno $fd;
return undef unless defined $fileno; # no underlying fd for this handle
my ($package, $calling_package) = HexChat::Embed::find_pkg();
$callback = HexChat::Embed::fix_callback(
$package, $calling_package, $callback
my ($flags, $data) = (HexChat::FD_READ, undef);
_process_hook_options(
$options,
[qw(flags data)],
[\($flags, $data)],
my $cb = sub {
my $userdata = shift;
return $userdata->{CB}->(
$userdata->{FD}, $userdata->{FLAGS}, $userdata->{DATA},
my $pkg_info = HexChat::Embed::pkg_info( $package );
my $hook = HexChat::Internal::hook_fd(
$fileno, $cb, $flags, {
DATA => $data, FD => $fd, CB => $callback, FLAGS => $flags,
$package
push @{$pkg_info->{hooks}}, $hook if defined $hook;
return $hook;
sub unhook {
my $hook = shift @_;
my $package = shift @_;
($package) = caller unless $package;
my $pkg_info = HexChat::Embed::pkg_info( $package );
if( defined( $hook )
&& $hook =~ /^\d+$/
&& grep { $_ == $hook } @{$pkg_info->{hooks}} ) {
$pkg_info->{hooks} = [grep { $_ != $hook } @{$pkg_info->{hooks}}];
return HexChat::Internal::unhook( $hook );
return ();
sub _do_for_each {
my ($cb, $channels, $servers) = @_;
if( @_ == 3 && !($channels || $servers) ) { 
$channels = [ undef ];
$servers = [ undef ];
} elsif( !($channels || $servers) ) {
$cb->();
return 1;
$channels = [ $channels ] unless ref( $channels ) eq 'ARRAY';
if( $servers ) {
$servers = [ $servers ] unless ref( $servers ) eq 'ARRAY';
} else {
$servers = [ undef ];
my $num_done = 0;
my $old_ctx = HexChat::get_context();
for my $server ( @$servers ) {
for my $channel ( @$channels ) {
if( HexChat::set_context( $channel, $server ) ) {
$cb->();
$num_done++
HexChat::set_context( $old_ctx );
return $num_done;
sub print {
my $text = shift @_;
return "" unless defined $text;
if( ref( $text ) eq 'ARRAY' ) {
if( $, ) {
$text = join $, , @$text;
} else {
$text = join "", @$text;
return _do_for_each(
sub { HexChat::Internal::print( $text ); },
sub printf {
my $format = shift;
HexChat::print( sprintf( $format, @_ ) );
sub prnt {
goto &HexChat::print;
sub prntf {
goto &HexChat::printf;
sub command {
my $command = shift;
return "" unless defined $command;
my @commands;
if( ref( $command ) eq 'ARRAY' ) {
@commands = @$command;
} else {
@commands = ($command);
return _do_for_each(
sub { HexChat::Internal::command( $_ ) foreach @commands },
sub commandf {
my $format = shift;
HexChat::command( sprintf( $format, @_ ) );
sub plugin_pref_set {
my $setting = shift // return 0;
my $value   = shift // return 0;
return HexChat::Internal::plugin_pref_set($setting, $value);
sub plugin_pref_get {
my $setting = shift // return 0;
return HexChat::Internal::plugin_pref_get($setting);
sub plugin_pref_delete {
my $setting = shift // return 0;
return HexChat::Internal::plugin_pref_delete($setting);
sub plugin_pref_list {
my %list = HexChat::Internal::plugin_pref_list();
return \%list;
sub set_context {
my $context;
if( @_ == 2 ) {
my ($channel, $server) = @_;
$context = HexChat::find_context( $channel, $server );
} elsif( @_ == 1 ) {
if( defined $_[0] && $_[0] =~ /^\d+$/ ) {
$context = $_[0];
} else {
$context = HexChat::find_context( $_[0] );
} elsif( @_ == 0 ) {
$context = HexChat::find_context();
return $context ? HexChat::Internal::set_context( $context ) : 0;
sub get_info {
my $id = shift;
my $info;
if( defined( $id ) ) {
if( grep { $id eq $_ } qw(state_cursor id) ) {
$info = HexChat::get_prefs( $id );
} else {
$info = HexChat::Internal::get_info( $id );
return $info;
sub user_info {
my $nick = HexChat::strip_code(shift @_ || HexChat::get_info( "nick" ));
my $user;
for (HexChat::get_list( "users" ) ) {
if ( HexChat::nickcmp( $_->{nick}, $nick ) == 0 ) {
$user = $_;
last;
return $user;
sub context_info {
my $ctx = shift @_ || HexChat::get_context;
my $old_ctx = HexChat::get_context;
my @fields = (
qw(away channel charset host id inputbox libdirfs modes network),
qw(nick nickserv server topic version win_ptr win_status),
qw(configdir xchatdir xchatdirfs state_cursor),
if( HexChat::set_context( $ctx ) ) {
my %info;
for my $field ( @fields ) {
$info{$field} = HexChat::get_info( $field );
my $ctx_info = HexChat::Internal::context_info;
@info{keys %$ctx_info} = values %$ctx_info;
HexChat::set_context( $old_ctx );
return \%info;
} else {
return undef;
sub get_list {
unless( grep { $_[0] eq $_ } qw(channels dcc ignore notify users networks) ) {
Carp::carp( "'$_[0]' does not appear to be a valid list name" );
if( $_[0] eq 'networks' ) {
return HexChat::List::Network->get();
} else {
return HexChat::Internal::get_list( $_[0] );
sub strip_code {
my $pattern = qr<
\cB| #Bold
\cC\d{0,2}(?:,\d{1,2})?| #Color
\e\[(?:\d{1,2}(?:;\d{1,2})*)?m| # ANSI color code
\cG| #Beep
\cO| #Reset
\cV| #Reverse
\c_  #Underline
if( defined wantarray ) {
my $msg = shift;
$msg =~ s/$pattern//g;
return $msg;
} else {
$_[0] =~ s/$pattern//g if defined $_[0];
#line 1 "lib/Xchat.pm"
require HexChat;
#line 1 "lib/HexChat/Embed.pm"
package HexChat::Embed;
use strict;
use warnings;
use Data::Dumper;
our %scripts;
our %owner_package;
our $current_package;
sub load {
my $file = expand_homedir( shift @_ );
my $package = file2pkg( $file );
if( exists $scripts{$package} ) {
my $pkg_info = pkg_info( $package );
my $filename = File::Basename::basename( $pkg_info->{filename} );
HexChat::printf(
qq{'%s' already loaded from '%s'.\n},
$filename, $pkg_info->{filename}
HexChat::print(
'If this is a different script then it rename and try '.
'loading it again.'
return 2;
if( open my $source_handle, $file ) {
my $source = do {local $/; <$source_handle>};
close $source_handle;
$source =~ s/^__END__.*//ms;
$scripts{$package}{filename} = $file;
$scripts{$package}{loaded_at} = Time::HiRes::time();
my @inner_packages = $source =~
m/^\s*package \s+
((?:[^\W:]+(?:::)?)+)\s*? # package name
(?:\d+(?:[.]\d+) # positive integer or decimal-fraction
|v\d+(?:[.]\d+){2,})? # dotted-decimal v-string
[{;]
/mgx;
my @conflicts;
for my $inner ( @inner_packages ) {
if( exists $owner_package{ $inner } ) {
push @conflicts, $inner;
if( @conflicts ) {
my $error_message =
"'$file' won't be loaded due to conflicting inner packages:\n";
for my $conflict_package ( @conflicts ) {
$error_message .= "   $conflict_package already defined in " .
pkg_info($owner_package{ $conflict_package })->{filename}."\n";
HexChat::print( $error_message );
return 2;
my $full_path = File::Spec->rel2abs( $file );
$source =~ s/^/#line 1 "$full_path"\n\x7Bpackage $package;/;
if( $source =~ /^#.*\Z/m ) {
$source =~ s/^(?=#.*\Z)/\x7D/m;
} else {
$source =~ s/\Z/\x7D/;
$scripts{$package}{inner_packages} = [ @inner_packages ];
@owner_package{ @inner_packages } = ($package) x @inner_packages;
_do_eval( $source );
unless( exists $scripts{$package}{gui_entry} ) {
$scripts{$package}{gui_entry} =
HexChat::Internal::register(
"", "unknown", "", $file
if( $@ ) {
$@ =~ s/\(eval \d+\)/$file/g;
HexChat::print( "Error loading '$file':\n$@\n" );
unload( $scripts{$package}{filename} );
return 1;
} else {
HexChat::print( "Error opening '$file': $!\n" );
return 2;
return 0;
sub _do_eval {
no strict;
no warnings;
eval $_[0];
sub unload {
my $file = shift @_;
my $package = file2pkg( $file );
my $pkg_info = pkg_info( $package );
if( $pkg_info ) {	
if( exists $pkg_info->{shutdown} ) {
eval {
if( ref $pkg_info->{shutdown} eq 'CODE' ) {
$pkg_info->{shutdown}->();
} elsif ( $pkg_info->{shutdown} ) {
no strict 'refs';
&{$pkg_info->{shutdown}};
if( exists $pkg_info->{hooks} ) {
for my $hook ( @{$pkg_info->{hooks}} ) {
HexChat::unhook( $hook, $package );
if( exists $pkg_info->{gui_entry} ) {
plugingui_remove( $pkg_info->{gui_entry} );
delete @owner_package{ @{$pkg_info->{inner_packages}} };
for my $inner_package ( @{$pkg_info->{inner_packages}} ) {
Symbol::delete_package( $inner_package );
Symbol::delete_package( $package );
delete $scripts{$package};
return HexChat::EAT_ALL;
} else {
HexChat::print( qq{"$file" is not loaded.\n} );
return HexChat::EAT_NONE;
sub unload_all {
for my $package ( keys %scripts ) {
unload( $scripts{$package}->{filename} );
return HexChat::EAT_ALL;
sub reload {
my $file = shift @_;
my $package = file2pkg( $file );
my $pkg_info = pkg_info( $package );
my $fullpath = $file;
if( $pkg_info ) {
$fullpath = $pkg_info->{filename};
unload( $file );
load( $fullpath );
return HexChat::EAT_ALL;
sub reload_all {
my @dirs = HexChat::get_info( "configdir" );
push @dirs, File::Spec->catdir( $dirs[0], "plugins" );
for my $dir ( @dirs ) {
my $auto_load_glob = File::Spec->catfile( $dir, "*.pl" );
my @scripts = map { $_->{filename} }
sort { $a->{loaded_at} <=> $b->{loaded_at} } values %scripts;
push @scripts, File::Glob::bsd_glob( $auto_load_glob );
my %seen;
@scripts = grep { !$seen{ $_ }++ } @scripts;
unload_all();
for my $script ( @scripts ) {
if( !pkg_info( file2pkg( $script ) ) ) {
load( $script );
sub evaluate {
my ($code) = @_;
my @results = eval $code;
HexChat::print $@ if $@; #print warnings
local $Data::Dumper::Sortkeys = 1;
local $Data::Dumper::Terse    = 1;
if (@results > 1) {
HexChat::print Dumper \@results;
elsif (ref $results[0] || !$results[0]) {
HexChat::print Dumper $results[0];
else {
HexChat::print $results[0];
return HexChat::EAT_HEXCHAT;
sub expand_homedir {
my $file = shift @_;
if ( $^O eq "MSWin32" ) {
$file =~ s/^~/$ENV{USERPROFILE}/;
} else {
$file =~ s{^~}{
(getpwuid($>))[7] ||  $ENV{HOME} || $ENV{LOGDIR}
}ex;
return $file;
sub file2pkg {
my $string = File::Basename::basename( shift @_ );
$string =~ s/\.pl$//i;
$string =~ s|([^A-Za-z0-9/])|'_'.unpack("H*",$1)|eg;
return "HexChat::Script::" . $string;
sub pkg_info {
my $package = shift @_;
return $scripts{$package};
sub find_external_pkg {
my $level = 1;
while( my @frame = caller( $level ) ) {
return @frame if $frame[0] !~ /(?:^IRC$|^HexChat)/;
$level++;
return;
sub find_pkg {
my $level = 1;
while( my ($package, $file, $line) = caller( $level ) ) {
return $package if $package =~ /^HexChat::Script::/;
$level++;
my $current_package = get_current_package();
if( defined $current_package ) {
return $current_package;
my @frame = find_external_pkg();
my $location;
if( $frame[0] or $frame[1] ) {
my $calling_package = $frame[0];
if( defined( my $owner = $owner_package{ $calling_package } ) ) {
return ($owner, $calling_package);
$location = $frame[1] ? $frame[1] : "package $frame[0]";
$location .= " line $frame[2]";
} else {
$location = "unknown location";
die "Unable to determine which script this hook belongs to. at $location\n";
sub fix_callback {
my ($package, $calling_package, $callback) = @_;
unless( ref $callback ) {
unless( $callback =~ /::/ ) {
my $prefix = defined $calling_package ? $calling_package : $package;
$callback =~ s/^/${prefix}::/;
no strict 'subs';
$callback = \&{$callback};
return $callback;
sub get_current_package {
return $current_package;
sub set_current_package {
my $old_package = $current_package;
$current_package = shift;
return $old_package;
#line 1 "lib/HexChat/List/Network.pm"
package HexChat::List::Network;
use strict;
use warnings;
use Storable qw(dclone);
my $last_modified;
my @servers;
sub get {
my $server_file = HexChat::get_info( "configdir" ) . "/servlist.conf";
if( -f $server_file && 
(!defined $last_modified || $last_modified != -M $server_file ) ) {
$last_modified = -M _;
@servers = ();
if( open my $fh, "<", $server_file ) {
local $/ = "\n\n";
while( my $record = <$fh> ) {
chomp $record;
next if $record =~ /^v=/; # skip the version line
push @servers, HexChat::List::Network::Entry::parse( $record );
} else {
warn "Unable to open '$server_file': $!";
my $clone = dclone( \@servers );
return @$clone;
#line 1 "lib/HexChat/List/Network/Entry.pm"
package HexChat::List::Network::Entry;
use strict;
use warnings;
my %key_for = (
I => "irc_nick1",
i => "irc_nick2",
U => "irc_user_name",
R => "irc_real_name",
P => "server_password",
B => "nickserv_password",
N => "network",
D => "selected",
E => "encoding",
my $letter_key_re = join "|", keys %key_for;
sub parse {
my $data  = shift;
my $entry = {
irc_nick1       => undef,
irc_nick2       => undef,
irc_user_name   => undef,
irc_real_name   => undef,
server_password => undef,
autojoins         => HexChat::List::Network::AutoJoin->new( '' ),
connect_commands   => [],
flags             => {},
selected          => undef,
encoding          => undef,
servers           => [],
nickserv_password => undef,
network           => undef,
my @fields = split /\n/, $data;
chomp @fields;
$entry->{ autojoins } = HexChat::List::Network::AutoJoin->new();
for my $field ( @fields ) {
SWITCH: for ( $field ) {
/^($letter_key_re)=(.*)/ && do {
$entry->{ $key_for{ $1 } } = $2;
last SWITCH;
/^J.(.*)/ && do {
$entry->{ autojoins }->add( $1 );
/^F.(.*)/ && do {
$entry->{ flags } = parse_flags( $1 );
/^S.(.+)/ && do {
push @{$entry->{servers}}, parse_server( $1 );
/^C.(.+)/ && do {
push @{$entry->{connect_commands}}, $1;
return $entry;
sub parse_flags {
my $value = shift || 0;
my %flags;
$flags{ "cycle" }         = $value & 1  ? 1 : 0;
$flags{ "use_global" }    = $value & 2  ? 1 : 0;
$flags{ "use_ssl" }       = $value & 4  ? 1 : 0;
$flags{ "autoconnect" }   = $value & 8  ? 1 : 0;
$flags{ "use_proxy" }     = $value & 16 ? 1 : 0;
$flags{ "allow_invalid" } = $value & 32 ? 1 : 0;
return \%flags;
sub parse_server {
my $data = shift;
if( $data ) {
my ($host, $port) = split /\//, $data;
unless( $port ) {
my @parts = split /:/, $host;
if( @parts == 2 ) {
$port = $parts[1];
$port ||= 6667;
return { host => $host, port => $port };
#line 1 "lib/HexChat/List/Network/AutoJoin.pm"
package HexChat::List::Network::AutoJoin;
use strict;
use warnings;
use overload
'""'   => 'as_string',
'0+'   => 'as_bool';
sub new {
my $class = shift;
my @autojoins;
return bless \@autojoins, $class;
sub add {
my $self = shift;
my $line = shift;
my ( $channel, $key ) = split /,/, $line, 2;
$key = $key || '';
push @$self, {
channel => $channel,
key     => $key,
sub channels {
my $self = shift;
if( wantarray ) {
return map { $_->{channel} } @$self;
} else {
return scalar @$self;
sub keys {
my $self = shift;
return map { $_->{key} } @$self  ;
sub pairs {
my $self = shift;
my @channels = $self->channels;
my @keys = $self->keys;
my @pairs = map { $_ => shift @keys } @channels;
sub as_hash {
my $self = shift;
return +{ $self->pairs };
sub as_string {
my $self = shift;
return join " ",
join( ",", $self->channels ),
join( ",", $self->keys );
sub as_array {
my $self = shift;
return [ map { \%$_ } @$self ];
sub as_bool {
my $self = shift;
return $self->channels ? 1 : "";
;*3$"
perl.so.debug
7zXZ
SVdD
H>eh(
+-pG
# d1R
Wdcm
p%7=B(
uxIC
3h\,
8pgQ!S
[{G~
K;lN
,Hqa
n~;~
="<	{V
pkF5k
qa0o'
.shstrtab
.note.gnu.build-id
.gnu.hash
.dynsym
.dynstr
.gnu.version
.gnu.version_r
.rela.dyn
.rela.plt
.init
.text
.fini
.rodata
.eh_frame_hdr
.eh_frame
.init_array
.fini_array
.jcr
.data.rel.ro
.dynamic
.got
.got.plt
.bss
.gnu_debuglink
.gnu_debugdata
