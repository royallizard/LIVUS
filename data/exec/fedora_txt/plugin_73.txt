__gmon_start__
_fini
_ITM_deregisterTMCloneTable
_ITM_registerTMCloneTable
__cxa_finalize
_Jv_RegisterClasses
value_peek_string
g_utf8_skip
g_utf8_get_char
g_unichar_isspace
workbook_date_conv
format_match_number
value_dup
value_new_error_VALUE
g_utf8_strup
value_new_string_nocopy
g_string_new
g_string_append_unichar
g_string_free
g_string_truncate
value_zero
go_format_str_delocalize
go_format_new_from_XL
g_string_sized_new
format_value_gstring
go_format_unref
value_release
format_match
value_new_empty
value_get_as_string
value_get_as_float
strstr
g_string_append_len
g_string_append
value_new_int
gnm_regcomp_XL
go_regexec
g_log
go_regfree
__stack_chk_fail
value_new_string
g_utf8_find_next_char
g_utf8_strlen
g_try_malloc
memcpy
g_utf8_get_char_validated
g_utf8_validate
g_malloc
g_utf8_offset_to_pointer
g_unichar_tolower
g_unichar_isalpha
g_unichar_toupper
format_match_decimal_number_with_locale
g_utf8_find_prev_char
g_strndup
g_utf8_strdown
value_get_as_checked_bool
go_fake_trunc
value_new_float
go_format_details_new
go_format_generate_str
go_format_details_free
format_value
go_pow10
go_fake_round
g_strstr_len
g_utf8_pointer_to_offset
value_new_bool
g_utf8_normalize
g_strcmp0
range_concatenate
string_range_function
g_convert_with_iconv
g_unichar_isprint
g_unichar_validate
g_unichar_to_utf8
gnm_excel_search_impl
go_locale_get_currency
go_string_append_c_n
go_string_append_gstring
g_string_insert_c
go_plugin_init
gsf_msole_iconv_win_codepage
gsf_msole_iconv_open_for_import
gsf_msole_iconv_open_for_export
go_plugin_shutdown
gsf_iconv_close
string_functions
go_plugin_header
go_plugin_depends
libm.so.6
libc.so.6
_edata
__bss_start
_end
plugin.so
GLIBC_2.14
GLIBC_2.4
GLIBC_2.2.5
fffff.
fffff.
fffff.
=ia 
ATUSH
[]A\
[]A\H
<$]A\
AWAV1
AUATUSH
[]A\A]A^A_
AWAVAUATUSH
[]A\A]A^A_
AVAUATUSH
[]A\A]A^H
AWAVAUATI
[]A\A]A^A_
fff.
AWAVAUATI
D$ H
8[]A\A]A^A_
|$ 1
HcD$(H
H+D$
H9D$
tTA9
H+D$
H9D$
T$(H
t$ L
8[]A\A]A^A_
8[]A\A]A^A_
AVAUATUI
D$81
L$8dH3
@[]A\A]A^
t$ E1
ffff.
ATUI
[]A\
[]A\
[]A\
ffffff.
AWAVI
AUATUSH
[]A\A]A^A_
[]A\A]A^A_
[]A\A]A^A_
AWAVAUATI
<,Hc
[]A\A]A^A_
([]A\A]A^A_
AWAVAUATI
[]A\A]A^A_
[]A\A]A^A_
ffffff.
AVAU1
ATUSH
[]A\A]A^H
fffff.
AWAVAUATI
[]A\A]A^A_
AWAVAUATI
}jHc
[]A\A]A^A_
[]A\A]A^A_
[]A\A]A^A_
ATUI
[]A\
[]A\
[]A\
ATUI
[]A\
[]A\
[]A\
ffffff.
AVAUATUI
[]A\A]A^
[]A\A]A^
AUATI
[]A\A]
[]A\A]
AUATI
[]A\A]
<([]A\A]
ATUH
~ []A\
[]A\1
[]A\
ffffff.
ffff.
ATUH
[]A\
fffff.
AUATUSH
[]A\A]
AUATUSH
[]A\A]
[]A\A]
fff.
ffffff.
vI[H
[]A\H
<$]A\
[]A\H
<$]A\
AUATI
D$(1
t$$H
L$(dH3
8[]A\A]
t$$H
t$ H
D$$H
L$$H
Unexpected go_regexec result
Unexpected regcomp result
iconv failed for CODE(U%x)
iconv failed for CHAR(%d)
#,##0
unichar
clean
unicode
concatenate
dollar
exact
find
findb
fixed
f|fb
left
leftb
lenb
lower
midb
numbervalue
proper
replace
SffS
replaceb
rept
right
rightb
search
searchb
substitute
SSS|f
trim
upper
text:original text
=JIS("ABC")
text:string
=ASC("
search:search string
text:search field
=SEARCHB("n","Canc
=SEARCHB("n","Canc
n",4)
=SEARCHB("n","Canc
n",6)
=SEARCHB("n*n","Canc
=SEARCHB("n*n","Canc
n",4)
FINDB,SEARCH
=SEARCH("c","Canc
=SEARCH("c","Canc
n",2)
=SEARCH("c*c","Canc
=SEARCH("c*c","Canc
n",2)
FIND,SEARCHB
num:number
decimals:decimals
=DOLLAR(12345)
FIXED,TEXT,VALUE
old:string to be replaced
new:replacement string
REPLACE,TRIM
separator:decimal separator
=NUMBERVALUE("$1,000",",")
=VALUE("$1,000")
DOLLAR,FIXED,TEXT
=TRIM("  a bbb  cc ")
CLEAN,MID,REPLACE,SUBSTITUTE
value:value to be formatted
format:desired format
=TEXT(3.223,"$0.00")
DOLLAR,FIXED,VALUE
value:original value
=T("Gnumeric")
=T(64)
CELL,N,VALUE
old:original text
start:starting byte position
=REPLACEB("L
vy",2,1,"*")
=REPLACEB("L
vy",2,2,"*")
=REPLACEB("L
vy",2,3,"*")
=REPLACEB("L
vy",2,4,"*")
=REPLACEB("L
vy",3,2,"*")
=REPLACEB("L
vy",3,3,"*")
MID,SEARCH,SUBSTITUTE,TRIM
start:starting position
=PROPER("j. f. kennedy")
LOWER,UPPER
decimals:number of decimals
=FIXED(1234.567,2)
=FIXED(1234.567,2,TRUE)
TEXT,VALUE,DOLLAR
string1:search string
string2:search field
=FIND("num","Gnumeric")
EXACT,LEN,MID,SEARCH
=CLEAN("Gnumeric"&char(7))
num:non-negative integer
=REPT("x",3)
CONCATENATE
s1:first string
s2:second string
=CONCATENATE("aa","bb")
LEFT,MID,RIGHT
=UPPER("Gnumeric")
=UPPER("L
vy")
LOWER
s:the string
=RIGHTB("L
vy",2)
=RIGHTB("L
vy",3)
=RIGHT("L
vy",2)
=RIGHT("L
vy",3)
=FINDB("v","L
vy")
=FINDB("v","L
vy",3)
=FINDB("v","L
vy",5)
=MIDB("L
vy",2,1)
=MIDB("L
vy",2,2)
=MIDB("L
vy",3,2)
=MID("L
vy",2,1)
=MID("L
vy",3,2)
=LOWER("J. F. Kennedy")
=LOWER("L
VY")
=LEFTB("L
vy",3)
=LEFTB("L
vy",2)
=LEFT("L
vy",3)
=LEFT("L
vy",2)
=LENB("Helsinki")
=LENB("L
vy")
CHAR, CODE, LEN
=LEN("Helsinki")
=LEN("L
vy")
CHAR,CODE,LENB
string1:first string
string2:second string
=EXACT("Gnumeric","Gnumeric")
=EXACT("gnumeric","Gnumeric")
LEN,SEARCH,DELTA
c:character
=UNICODE("A")
UNICHAR,CODE,CHAR
=CODE("A")
x:Unicode code point
=UNICHAR(65)
=UNICHAR(960)
=UNICHAR(20000)
CHAR,UNICODE,CODE
x:code point
=CHAR(65)
goffice
gnumeric
1.12.23
iconv for CHAR(%d) produced a string of length %d
JIS:text with half-width katakana and ASCII characters converted to full-width
JIS converts half-width katakana and ASCII characters to full-width equivalent characters, copying all others. 
The distinction between half-width and full-width characters is described in http://www.unicode.org/reports/tr11/.
For most strings, this function has the same effect as in Excel.
While in obsolete encodings JIS used to translate between 1-byte and 2-byte characters, this is not the case in UTF-8.
This function is OpenFormula compatible.
ASC:text with full-width katakana and ASCII characters converted to half-width
ASC converts full-width katakana and ASCII characters to half-width equivalent characters, copying all others. 
While in obsolete encodings ASC used to translate between 2-byte and 1-byte characters, this is not the case in UTF-8.
SEARCHB:the location of the @{search} string within @{text} after byte position @{start}
start:starting byte position, defaults to 1
@{search} may contain wildcard characters (*) and question marks (?). A question mark matches any single character, and a wildcard matches any string including the empty string. To search for * or ?, precede the symbol with ~.
This search is not case sensitive.
If @{search} is not found, SEARCHB returns #VALUE!
If @{start} is less than one or it is greater than the byte length of @{text}, SEARCHB returns #VALUE!
The semantics of this function is subject to change as various applications implement it.
While this function is syntactically Excel compatible, the differences in the underlying text encoding will usually yield different results.
While this function is OpenFormula compatible, most of its behavior is, at this time, implementation specific.
SEARCH:the location of the @{search} string within @{text} after position @{start}
start:starting position, defaults to 1
If @{search} is not found, SEARCH returns #VALUE!
If @{start} is less than one or it is greater than the length of @{text}, SEARCH returns #VALUE!
This function is Excel compatible.
DOLLAR:@{num} formatted as currency
SUBSTITUTE:@{text} with all occurrences of @{old} replaced by @{new}
num:if @{num} is specified and a number only the @{num}th occurrence of @{old} is replaced
=SUBSTITUTE("United Nations Educational, Scientific and Cultural Organization","ation","-5-")
=SUBSTITUTE("United Nations Educational, Scientific and Cultural Organization","ation","-5-",2)
NUMBERVALUE:numeric value of @{text}
If @{text} does not look like a decimal number, NUMBERVALUE returns the value VALUE would return (ignoring the given @{separator}).
VALUE:numeric value of @{text}
TRIM:@{text} with only single spaces between words
TEXT:@{value} as a string formatted as @{format}
=TEXT(date(1999,4,15),"mmmm, dd, yy")
T:@{value} if and only if @{value} is text, otherwise empty
REPLACEB:string @{old} with up to @{num} bytes starting at @{start} replaced by @{new}
num:number of bytes to be replaced
REPLACEB replaces the string of valid unicode characters starting at the byte @{start} and ending at @{start}+@{num}-1 with the string @{new}.
REPLACE:string @{old} with @{num} characters starting at @{start} replaced by @{new}
num:number of characters to be replaced
=REPLACE("Gnumeric",2,6,"*6*")
PROPER:@{text} with initial of each word capitalised
FIXED:formatted string representation of @{num}
no_commas:TRUE if no thousand separators should be used, defaults to FALSE
FIND:first position of @{string1} in @{string2} following position @{start}
This search is case-sensitive.
CLEAN:@{text} with any non-printable characters removed
CLEAN removes non-printable characters from its argument leaving only regular characters and white-space.
REPT:@{num} repetitions of string @{text}
CONCATENATE:the concatenation of the strings @{s1}, @{s2},
UPPER:an upper-case version of the string @{text}
RIGHTB:the last characters of the string @{s} comprising at most @{num_bytes} bytes
num_bytes:the maximum number of bytes to return (defaults to 1)
If the string @{s} is in a right-to-left script, the returned last characters are from the left of the string.
LEFTB,MIDB,LENB,LEFT,MID,RIGHT,LEN
RIGHT:the last @{num_chars} characters of the string @{s}
num_chars:the number of characters to return (defaults to 1)
LEFT,MID,LEN,LEFTB,MIDB,RIGHTB,LENB
FINDB:first byte position of @{string1} in @{string2} following byte position @{start}
FIND,LEFTB,RIGHTB,LENB,LEFT,MID,RIGHT,LEN
MIDB:the characters following the first @{start_pos} bytes comprising at most @{num_bytes} bytes
start_pos:the number of the byte with which to start (defaults to 1)
LEFTB,RIGHTB,LENB,LEFT,MID,RIGHT,LEN
MID:the substring of the string @{s} starting at position @{position} consisting of @{length} characters
position:the starting position
length:the number of characters to return
LEFT,RIGHT,LEN,LEFTB,MIDB,RIGHTB,LENB
LOWER:a lower-case version of the string @{text}
LEFTB:the first characters  of the string @{s} comprising at most @{num_bytes} bytes
If the string is in a right-to-left script, the returned first characters are from the right of the string.
MIDB,RIGHTB,LENB,LEFT,MID,RIGHT,LEN
LEFT:the first @{num_chars} characters of the string @{s}
If the string @{s} is in a right-to-left script, the returned first characters are from the right of the string.
MID,RIGHT,LEN,MIDB,RIGHTB,LENB
LENB:the number of bytes in the string @{s}
LEN:the number of characters of the string @{s}
EXACT:TRUE if @{string1} is exactly equal to @{string2}
UNICODE:the Unicode code point for the character @{c}
CODE:the CP1252 (Windows-1252) code point for the character @{c}
@{c} must be a valid CP1252 (Windows-1252) character.
CP1252 (Windows-1252) is also known as the "ANSI code page", but it is not an ANSI standard.
CP1252 (Windows-1252) is based on an early draft of ISO-8859-1, and contains all of its printable characters (but partially at different positions.)
In CP1252 (Windows-1252), 129, 141, 143, 144, and 157 do not have matching characters.
For @{x} from 1 to 255 except 129, 141, 143, 144, and 157 we have CODE(CHAR(@{x}))=@{x}.
UNICHAR:the Unicode character represented by the Unicode code point @{x}
CHAR:the CP1252 (Windows-1252) character for the code point @{x}
CHAR(@{x}) returns the CP1252 (Windows-1252) character with code @{x}.
@{x} must be in the range 1 to 255.
CP1252 (Windows-1252) is based on an early draft of ISO-8859-1, and contains all of its printable characters. It also contains all of ISO-8859-15's printable characters (but partially at different positions.)
munG
;*3$"
plugin.so.debug
7zXZ
';l$fBV
0-&Q
"TP#
Kj8Z5
eWq,
7	oK
r?j:
l!1C>)
4kGE
+Z& 
gUWr
AwOA
.shstrtab
.note.gnu.build-id
.gnu.hash
.dynsym
.dynstr
.gnu.version
.gnu.version_r
.rela.dyn
.rela.plt
.init
.text
.fini
.rodata
.eh_frame_hdr
.eh_frame
.init_array
.fini_array
.jcr
.data.rel.ro
.dynamic
.got
.bss
.gnu_debuglink
.gnu_debugdata
