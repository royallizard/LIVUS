U9.o
yuoj&-V1E
__gmon_start__
_ITM_deregisterTMCloneTable
_ITM_registerTMCloneTable
__cxa_finalize
_Jv_RegisterClasses
g_free
vcard_emul_delete_key
vcard_make_response
vcard_get_current_applet_private
g_realloc
memcpy
vcard_emul_rsa_op
vcard_response_new_bytes
vcard_response_new
__assert_fail
cac_card_init
vcard_set_type
vcard_set_applet_private
vcard_add_applet
g_malloc0
g_malloc
vcard_new_applet
__stack_chk_fail
vevent_new
vreader_reference
vcard_reference
vevent_delete
vreader_free
vcard_free
vevent_queue_init
vevent_queue_vevent
g_mutex_lock
g_cond_signal
g_mutex_unlock
vevent_wait_next_vevent
g_cond_wait
vevent_get_next_vevent
vcard_buffer_response_new
g_memdup
vcard_buffer_response_delete
vcard_reset
vcard_emul_reset
vcard_delete_applet
vcard_new
vcard_get_atr
vcard_emul_get_atr
vcard_set_atr_func
vcard_find_applet
memcmp
vcard_applet_get_aid
vcard_select_applet
vcard_process_applet_apdu
vcard_get_buffer_response
vcard_set_buffer_response
vcard_get_type
vcard_get_private
vreader_new
g_mutex_init
g_strdup
g_mutex_clear
vreader_card_is_present
vreader_get_id
vreader_set_id
vreader_get_name
vreader_get_private
vreader_power_on
vreader_power_off
vreader_xfr_bytes
vcard_apdu_new
vcard_response_delete
vcard_apdu_delete
g_log
vcard_process_apdu
vreader_list_get_first
vreader_list_get_next
vreader_list_delete
vreader_list_get_reader
vreader_get_reader_list
vreader_get_reader_by_id
vreader_get_reader_by_name
strcmp
vreader_add_reader
vreader_remove_reader
vreader_queue_card_event
vreader_insert_card
vreader_init
PK11_FreeSlot
g_malloc_n
PK11_ReferenceSlot
CERT_DupCertificate
PK11_FindKeyByDERCert
vcard_emul_type_select
vcard_init
PK11_FindGenericObjects
PK11_GetNextGenericObject
PK11_ReadRawAttribute
CERT_GetDefaultCertDB
CERT_NewTempCertificate
SECITEM_FreeItem
CERT_DestroyCertificate
PORT_Strdup
SECMOD_WaitForAnyTokenEvent
PK11_IsPresent
PK11_GetSlotName
PORT_GetError
PK11_GetSlotSeries
__ctype_b_loc
SECKEY_DestroyPrivateKey
PK11_SignatureLen
PK11_DoesMechanism
memset
PK11_FindPrivateKeyFromCert
PK11_PubDecryptRaw
PK11_Sign
vcard_emul_get_login_count
vcard_emul_login
PK11_Authenticate
PK11_IsLoggedIn
PK11_Logout
vcard_emul_force_card_remove
vcard_emul_force_card_insert
vcard_emul_init
NSS_Init
PK11_SetPasswordFunc
PK11_FindSlotByName
PK11_FindCertFromNickname
SECMOD_GetDefaultModuleListLock
SECMOD_GetDefaultModuleList
SECMOD_GetReadLock
PK11_IsRemovable
PK11_IsHW
SECMOD_ReleaseReadLock
SECMOD_GetInternalModule
stderr
fwrite
PR_CreateThread
PORT_SetError
vcard_emul_replay_insertion_events
vcard_emul_options
vcard_emul_type_from_string
g_strndup
__memcpy_chk
g_realloc_n
vcard_emul_usage
strcasecmp
vcard_response_new_data
vcard_response_new_status_bytes
strlen
libssl3.so
libsmime3.so
libnss3.so
libnssutil3.so
libplds4.so
libplc4.so
libnspr4.so
libpthread.so.0
libdl.so.2
libgthread-2.0.so.0
libglib-2.0.so.0
libc.so.6
libcacard.so.0
GLIBC_2.14
GLIBC_2.4
GLIBC_2.3
GLIBC_2.3.4
GLIBC_2.2.5
NSS_3.9.3
NSS_3.5
NSS_3.3
NSS_3.12
NSS_3.9.2
NSS_3.2
5*{ 
%,{ 
%*{ 
%"{ 
%zz 
%rz 
%jz 
%bz 
%Zz 
%Rz 
%Jz 
%Bz 
%:z 
%2z 
%*z 
%"z 
%zy 
%ry 
%jy 
%by 
%Zy 
%Ry 
%Jy 
%By 
%:y 
%2y 
%*y 
%"y 
%zx 
%rx 
%jx 
%bx 
%Zx 
%Rx 
%Jx 
%Bx 
%:x 
%2x 
%*x 
%"x 
%zw 
%rw 
%jw 
%bw 
%Zw 
%Rw 
%Jw 
fffff.
=Qw 
5Jw 
fffff.
=	w 
fffff.
t3SH
<VtHv&<
ffffff.
AWAVAUATI
v#<Rt
<Xu[
<6u<
[]A\A]A^A_
[]A\A]A^A_
Hc}(H
ffff.
<Rt(<Xu
fff.
AWAVH
AUATUSH
D$81
D$(H
D$0H
|$ H
L9d$(
D$4yN
d$6B
L$8dH3
H[]A\A]A^A_
\$ H
AUATA
[]A\A]
ffffff.
t#SH
=!o 
5in 
=Rn 
ffffff.
=8n 
ATUI
[]A\
fffff.
AVAUI
ATUI
[]A\A]A^
t+SH
fffff.
ATUI
k0[]A\
fffff.
uVUSH
fffff.
fff.
AUATUSH
t-Lc
9k u
[]A\A]
ffff.
ATUS
[]A\
fff.
fff.
fff.
ffff.
AUATI
[]A\A]
t{UH
o SH
fffff.
fffff.
ffff.
ATUI
[]A\
AWAVA
AUATI
([]A\A]A^A_
ffff.
ffff.
ATUI
ffff.
AUATH
[]A\A]
twUS
=[a 
=Va 
[]A\
fff.
==` 
=5` 
ATUH
o SH
fffff.
t+SH
fffff.
AUATI
USHc
[]A\A]
fff.
ATUH
[]A\
AWAVE
AUATI
$t>AWAV
[]A\A]A^A_
[]A\A]A^A_
AWAVAUATUSH
D$H1
T$(H
t$ H
T$(L
L$(H
T$ E
t$HdH34%(
X[]A\A]A^A_
AUATI
[]A\A]
AWAVI
AUATUSH
L; u
[]A\A]A^A_
ffff.
ATUI
t	[]A\
t:SH
AWAVAUATUSH
D+T$
T$`I9
[]A\A]A^A_
D;T$
t$ L
l$PH
T$HH
T$@L
u5D;T$0
tR~/=1
AVAUI
ATUHc
x,Ic
u	H9
[]A\A]A^
ATUStVI
[]A\
ffffff.
AWAVAUATUSH
D$X1
t$XdH34%(
h[]A\A]A^A_
D$P1
D$ H
D$HH
D$(H
D$@H
T$ H
t$(H
~zE1
T$@Hc
T$PL
A9D$
L$PA
T$HH
t$@L
A;l$P
D$HL
A9_P~kI
ATUS
AWAVI
AUATI
@USH
D$@H
[]A\A]A^A_
<)uqL
<)taI
\$ L
\$ t]
)tHI
L$0I)
\$(H
t$ I
D$ A
\$(L
H+D$
L$8L
\$0H
\$0L
L$8L
\$0I
L$8L
\$0I
D$ H
t$(H
t	<,u
o(Hc
o E1
,t>H
H;l$
Hct$
L$8L
L$8L
ffff.
AUATI
[]A\A]
AUATI
[]A\A]
fff.
t1HcH
TUSH
fff.
AUATI
USHc
[]A\A]
[]A\A]
fffff.
AVAUATUI
 []A\A]A^
tcr)
AVAUI
ATUH
$VCARf
DEFAULT
{	Ic
 []A\A]A^
libcacard/cac.c
applet_private
pki_applet->cert != ((void *)0)
cac_applet_pki_process_apdu
cac_applet_pki_reset
libcacard/event.c
vevent_queue_tail
vevent_queue_vevent
libcacard/vcard.c
channel < 4
vcard_select_applet
manage channel
external authenticate
get challenge
internal authenticate
erase binary
read binary
write binary
update binary
read record
write record
update record
append record
envelope
put data
get data
select file
verify
get response
get properties
get acr
read buffer
update buffer
sign decrypt
get certificate
unknown
libcacard
libcacard/vreader.c
%s: CLS=0x%x,INS=0x%x,P1=0x%x,P2=0x%x,Lc=%d,Le=%d %s
%s: status=%d sw1=0x%x sw2=0x%x len=%d (total=%d)
card_status == VCARD_DONE && response
vreader_xfr_bytes
vreader_xfr_bytes
libcacard/vcard_emul_nss.c
buffer_size == signature_len
buffer_size == signature.len
pad_len < 4
atr != ((void *)0)
/etc/pki/nssdb
E-Gate 0 0
soft=
use_hw=
hw_type=
hw_params=
known bad coolkey version - see https://bugzilla.redhat.com/show_bug.cgi?id=802435
emul args: comma separated list of the following arguments
 db={nss_database}               (default sql:/etc/pki/nssdb)
 use_hw=[yes|no]                 (default yes)
 hw_type={card_type_to_emulate}  (default CAC)
 hw_param={param_for_card}       (default "")
 soft=({slot_name},{vreader_name},{card_type_to_emulate},{params_for_card},
       {cert1},{cert2},{cert3}    (default none)
  {nss_database}          The location of the NSS cert & key database
  {card_type_to_emulate}  What card interface to present to the guest
  {param_for_card}        Card interface specific parameters
  {slot_name}             NSS slot that contains the certs
  {vreader_name}          Virtual reader name to present to the guest
  {certN}                 Nickname of the certificate n on the virtual card
These parameters come as a single string separated by blanks or newlines.
Unless use_hw is set to no, all tokens that look like removable hardware
tokens will be presented to the guest using the emulator specified by
hw_type, and parameters of hw_param.
If more one or more soft= parameters are specified, these readers will be
presented to the guest
vcard_emul_get_atr
vcard_emul_rsa_op
libcacard/card_7816.c
*response != ((void *)0)
!"VCARD_DIRECT: applet failure"
vcard7816_vm_process_apdu
vcard_process_apdu
;*3$"
libcacard.so.0.0.0.debug
7zXZ
X)7tg {
/^l\
h?v(
k\BGh/h
oHFl`_
M.ga
@aM<	+abo
}vY`[
7j>_
d)g!A
jO!&p
re.`,
6evx:
7	3:
q{Jg
.shstrtab
.note.gnu.build-id
.gnu.hash
.dynsym
.dynstr
.gnu.version
.gnu.version_r
.rela.dyn
.rela.plt
.init
.text
.fini
.rodata
.eh_frame_hdr
.eh_frame
.init_array
.fini_array
.jcr
.data.rel.ro
.dynamic
.got
.data
.bss
.gnu_debuglink
.gnu_debugdata
