/lib64/ld-linux-x86-64.so.2
eC 3
{a;&
.3MK
TJZ`_1
NRsQB
CjIL2
y@zj
libm.so.6
_ITM_deregisterTMCloneTable
__gmon_start__
_Jv_RegisterClasses
_ITM_registerTMCloneTable
libjemalloc.so.1
malloc_usable_size
libdl.so.2
libpthread.so.0
write
read
__errno_location
accept
fcntl
connect
libc.so.6
epoll_create
socket
fflush
__printf_chk
exit
fopen
gai_strerror
strncmp
__strdup
epoll_wait
inet_ntop
signal
strncpy
time
__stack_chk_fail
listen
abort
strtoll
getpid
chmod
__assert_fail
strtol
fgets
strlen
getaddrinfo
memset
strstr
bind
memcmp
getsockopt
poll
__fprintf_chk
stdout
memcpy
fclose
__vsnprintf_chk
setsockopt
getpeername
__ctype_b_loc
stderr
__snprintf_chk
usleep
gettimeofday
epoll_ctl
__memcpy_chk
srandom
strchr
getsockname
qsort
__ctype_toupper_loc
__ctype_tolower_loc
__cxa_finalize
freeaddrinfo
__xpg_strerror_r
__sprintf_chk
memmove
__libc_start_main
sysconf
_edata
__bss_start
_end
sdscpy
anetPeerToString
__libc_csu_fini
sdsfromlonglong
listRelease
redisFormatCommandArgv
listAddNodeHead
aeResizeSetSize
test_is_selected
aeCreateTimeEvent
redisContextSetTimeout
sdsdup
sdsll2str
anetNonBlock
redisReaderCreate
zmalloc_enable_thread_safeness
anetUnixNonBlockConnect
hex_digit_to_int
redisvCommand
aeGetSetSize
redisFreeKeepFd
redisAppendFormattedCommand
redisReaderGetReply
redisBufferWrite
anetSockName
sdsjoin
redisCommandArgv
sdscatprintf
anetWrite
sdssplitlen
redisCheckSocketError
redisvAppendCommand
aeDeleteTimeEvent
zmalloc_get_rss
aeDeleteFileEvent
anetUnixGenericConnect
sdsupdatelen
anetGenericResolve
redisConnectWithTimeout
zmalloc_set_oom_handler
redisReaderFeed
listRewindTail
listRewind
anetUnixServer
anetTcpConnect
anetSetSendBuffer
sdsMakeRoomFor
zlibc_free
aeGetFileEvents
sdssplitargs
listAddNodeTail
sdsmapchars
anetTcpNonBlockBindConnect
zmalloc
anetRead
anetBlock
anetTcpServer
aeProcessEvents
sdsrange
redisGetReplyFromReader
listReleaseIterator
anetSendTimeout
sdsfree
listNext
__redisSetError
__data_start
sdsRemoveFreeSpace
redisContextConnectUnix
sdsnewlen
redisConnectFd
redisContextConnectBindTcp
anetTcpNonBlockConnect
used_memory_mutex
anetResolve
aeDeleteEventLoop
sdscmp
_IO_stdin_used
listIndex
listSearchKey
redisConnectUnix
sdstolower
zmalloc_get_smap_bytes_by_field
anetEnableTcpNoDelay
listCreate
anetSetBlock
zmalloc_get_private_dirty
sdscpylen
redisFree
__libc_csu_init
redisConnectBindNonBlock
redisKeepAlive
anetKeepAlive
aeCreateEventLoop
sdsclear
zrealloc
parseOptions
anetTcpNonBlockBestEffortBindConnect
redisFormatCommand
listRotate
sdscat
redisSetTimeout
sdstoupper
sdstrim
redisConnectUnixWithTimeout
listInsertNode
redisConnectNonBlock
listDelNode
redisConnectUnixNonBlock
anetUnixConnect
sdscatvprintf
aeWait
anetTcp6Server
freeReplyObject
redisContextConnectTcp
showThroughput
listDup
anetTcpKeepAlive
anetTcpAccept
zmalloc_get_fragmentation_ratio
anetResolveIP
sdscatlen
zcalloc
sdsIncrLen
anetUnixAccept
aeMain
sdsfreesplitres
listGetIterator
aeSetBeforeSleepProc
redisAppendCommandArgv
redisCommand
is_hex_digit
redisBufferRead
aeCreateFileEvent
sdscatrepr
zmalloc_used_memory
zfree
sdscatsds
sdsempty
aeGetApiName
redisReaderFree
redisConnect
redisGetReply
sdsAllocSize
sdsgrowzero
redisEnableKeepAlive
aeStop
anetDisableTcpNoDelay
zstrdup
redisvFormatCommand
sdsull2str
sdscatfmt
sdsnew
__redisAppendCommand
GLIBC_2.2.5
GLIBC_2.14
GLIBC_2.3.2
GLIBC_2.4
GLIBC_2.3.4
GLIBC_2.3
AWAVAUATA
[]A\A]A^A_
fffff.
fffff.
fffff.
ATUI
 []A\
ffff.
ATUA
tyHcC
k8~+A
[]A\
fff.
AUATUSHc
~7A)
[]A\A]
ffff.
AWAVAUATUSH
$uaH
t#D	+A
A;,$L
([]A\A]A^A_
AUATUSH
([]A\A]
x*Hc
AWAVI
AUATI
[]A\A]A^A_
t)SH;2u
H93t
ffffff.
AWAVAUATUSH
D$(1
t$(dH34%(
8[]A\A]A^A_
H9D$
H+L$
fff.
T$0H
L$8L
D$@L
L$Ht7
)D$P
)L$`
)T$p
[]A\A]A^
[]A\A]A^
fff.
AUATI
[]A\A]
AVAUE
ATUL
l$@dH
D$H1
t$HdH34%(
P[]A\A]A^
AUAT1
[]A\A]
AWAVA
AUATI
\$pD
D$(L
D$x1
L$0L
l$0H
|$(H
D$8H
l$8M
8su@
L$xdH3
[]A\A]A^A_
T$,1
t$ L
fffff.
AVAUA
ATUI
VUUUA
[]A\A]A^
ATUI
D$H1
\$HdH3
P[]A\
AVAUI
ATUI
D$x1
L$xdH3
[]A\A]A^
tbAUATA
[]A\A]
[]A\A]
tbAUATA
[]A\A]
[]A\A]
AWAVI
AUATA
[]A\A]A^A_
fff.
AVAUI
ATUI
[]A\A]A^
ffffff.
AUATI
[]A\A]
AUATI
[]A\A]
AUATI
4$Hc
HcMHH
C@tfH
sH+uH
dH34%(
[]A\A]
fff.
D$(1
HcKH1
D$(dH3
HiD$
H+C0H
AVAUH
ATUHc
L$(1
Hit$
HiL$
D$(dH3
0[]A\A]A^
ffff.
dH3<%(
AWAVAUATI
D$0A
D$(I
([]A\A]A^A_
D$(;B
M;t$
AWAVAUATUSH
<-t*H
[]A\A]A^A_
atMA
AUATI
[]A\A]
fff.
ATUH
StDI
[]A\
fff.
fffff.
ffffff.
fff.
AUATUSH
[]A\A]
AVAUI
ATUH
[]A\A]A^
fffff.
AUATH
[]A\A]
fff.
ffff.
fff.
AWAVI
AUATI
[]A\A]A^A_
D$0H
T$0H
L$8L
D$@L
L$Ht7
)D$P
)L$`
)T$p
ffffff.
AWAVI
AUATUSH
T$pH
L$xL
D$X1
D$0H
D$`H
d$@H
|$XdH3<%(
[]A\A]A^A_
D$(H
D$(H
T$0H
T$(<sH
/v3H
T$0H
T$0H
D$(Hc2
L$0H
T$0H
AVAUI
ATUI
wBH)
A\A]A^
AWAVA
AUATUS
T$(H
uAHc
T$ H
D;l$8}vA
[]A\A]A^A_
t$<Hc
D$0A
[]A\A]A^A_
[]A\A]A^A_
Hct$<H
fffff.
tKHc
ATUSH
fffff.
ATUI
[]A\
@tcH
AWAVI
AUATI
D$(1
D$'H
|$(dH3<%(
8[]A\A]A^A_
D$'	
5wLH
5v;H
D$'I
fff.
AWAVI
AUATH
H;\$
[]A\A]A^A_
AUATI
[]A\A]
fff.
fff.
AUATI
uBH;+H
[]A\A]
fff.
fff.
ATUI
D$ H
[]A\
[]A\
[]A\
AUATI
D$ H
D$ H
[]A\A]
t	H9
=x{ 
fffff.
ffff.
ATUI
uhH)-'{ 
[]A\
[]A\
tSSH
fff.
=Ax 
[]A\
AWAVH
AUATI
[]A\A]A^A_
fff.
H9] w
AVAUI
ATUI
ufIcT$
[]A\A]A^
]A\A]A^
ffff.
ATUA
[]A\
fffff.
ffff.
ATUI
C(tHI
uEIcT$
[]A\
[]A\
u~Hc
ffffff.
fffff.
AWAVI
AUATUSH
D$ "\a"
l$0L
[]A\A]A^A_
4$H)
L;T$
D$ "\r"
D$ "\n"
l$ L
D$ "\t"
D$ "\b"
ffff.
AWAVAUATUSH
\$h1
t<<%
gfff
<.u-I
t$8H
D$8H
D$@H
D$HA
|$ L
L$(L
L$(M
gfff
|$(h
|$(l
\$hdH3
x[]A\A]A^A_
gfff
L9|$
D;t$
<ltUI
T$0H
L$8L
D$@L
L$Ht7
)D$P
)L$`
)T$p
ffffff.
AWAVA
AUATI
gfff
gfffH
H9l$
u5Ic
([]A\A]A^A_
ffffff.
ATUA
[]A\
ATUA
[]A\
ATUA
[]A\
AUATI
[]A\A]
ffff.
fff.
fff.
ATUSH
[]A\
fff.
ATUSD
[]A\
AUATUSH
([]A\A]
ffffff.
T$0H
L$8L
D$@L
L$Ht7
)D$P
)L$`
)T$p
ffffff.
fff.
T$0H
L$8L
D$@L
L$Ht7
)D$P
)L$`
)T$p
ffffff.
AUAT
[]A\A]
ATUH
[]A\
[]A\
[]A\
ffffff.
AVAUA
ATUI
VUUUA
x(E1
[]A\A]A^
ATUSH
H=@B
[]A\
fffff.
AWAVM
AUATL
\$pL
l$@H
|$0H
l$0H
D$8H
|$8M
L$,A
[]A\A]A^A_
fffff.
AWAVI
AUAT1
[]A\A]A^A_
AWAVA
AUATL
[]A\A]A^A_
epoll
accept: %s
setsockopt TCP_NODELAY: %s
setsockopt SO_REUSEADDR: %s
bind: %s
listen: %s
setsockopt: %s
unable to bind socket
creating socket: %s
fcntl(F_GETFL): %s
fcntl(F_SETFL,O_NONBLOCK): %s
setsockopt SO_KEEPALIVE: %s
setsockopt TCP_KEEPIDLE: %s
setsockopt TCP_KEEPINTVL: %s
setsockopt TCP_KEEPCNT: %s
setsockopt SO_SNDBUF: %s
setsockopt SO_SNDTIMEO: %s
connect: %s
/unixsocket
Could not connect to Redis at 
Unexpected error reply, exiting...
  %d requests completed in %.2f seconds
All clients disconnected... aborting.
Invalid option "%s" or option argument missing
Usage: redis-benchmark [-h <host>] [-p <port>] [-c <clients>] [-n <requests]> [-k <boolean>]
 -h <hostname>      Server hostname (default 127.0.0.1)
 -p <port>          Server port (default 6379)
 -s <socket>        Server socket (overrides host and port)
 -a <password>      Password for Redis Auth
 -c <clients>       Number of parallel connections (default 50)
 -n <requests>      Total number of requests (default 100000)
 -d <size>          Data size of SET/GET value in bytes (default 2)
 -dbnum <db>        SELECT the specified db number (default 0)
 -k <boolean>       1=keep alive 0=reconnect (default 1)
 -r <keyspacelen>   Use random keys for SET/GET/INCR, random values for SADD
  Using this option the benchmark will expand the string __rand_int__
  inside an argument with a 12 digits number in the specified range
  from 0 to keyspacelen-1. The substitution changes every time a command
  is executed. Default tests use this to hit random keys in the
  specified range.
 -P <numreq>        Pipeline <numreq> requests. Default 1 (no pipeline).
 -q                 Quiet. Just show query/sec values
 --csv              Output in CSV format
 -l                 Loop. Run the tests forever
 -t <tests>         Only run the comma separated list of tests. The test
                    names are the same as the ones produced as output.
 -I                 Idle mode. Just open N idle connections and wait.
Examples:
 Run the benchmark with the default configuration against 127.0.0.1:6379:
   $ redis-benchmark
 Use 20 parallel clients, for a total of 100k requests, against 192.168.1.1:
   $ redis-benchmark -h 192.168.1.1 -p 6379 -n 100000 -c 20
 Fill 127.0.0.1:6379 with about 1 million keys only using the SET test:
   $ redis-benchmark -t set -n 1000000 -r 100000000
 Benchmark 127.0.0.1:6379 for a few commands producing CSV output:
   $ redis-benchmark -t ping,set,get -n 100000 --csv
 Benchmark a specific command line:
   $ redis-benchmark -r 10000 -n 10000 eval 'return redis.call("ping")' 0
 Fill a list with 10000 random elements:
   $ redis-benchmark -r 10000 -n 10000 lpush mylist __rand_int__
 On user specified command lines __rand_int__ is replaced with a random integer
 with a range of values selected by the -r option.
WARNING: keepalive disabled, you probably need 'echo 1 > /proc/sys/net/ipv4/tcp_tw_reuse' for Linux and 'sudo sysctl -w net.inet.tcp.msl=1000' for Mac OS X in order to use a lot of clients/requests
Creating %d idle connections and waiting forever (Ctrl+C when done)
SADD myset element:__rand_int__
LPUSH (needed to benchmark LRANGE)
LRANGE_100 (first 100 elements)
LRANGE_300 (first 300 elements)
LRANGE_500 (first 450 elements)
LRANGE_600 (first 600 elements)
%s:%d: %s
%s: %s
AUTH %s
SELECT
redis-benchmark.c
ln != ((void *)0)
Error: %s
====== %s ======
  %d parallel clients
  %d bytes payload
  keep alive: %d
%.2f requests per second
%.2f%% <= %d milliseconds
"%s","%.2f"
%s: %.2f requests per second
clients: %d
%s: %.2f
Writing to socket: %s
--dbnum
--help
--csv
127.0.0.1
ping_inline
PING
PING_INLINE
ping
ping_mbulk
PING
PING_BULK
SET key:__rand_int__ %s
GET key:__rand_int__
incr
INCR counter:__rand_int__
INCR
lpush
LPUSH mylist %s
LPUSH
lpop
LPOP mylist
LPOP
sadd
SADD
spop
SPOP myset
SPOP
lrange
lrange_100
lrange_300
lrange_500
lrange_600
LRANGE mylist 0 99
LRANGE mylist 0 299
LRANGE mylist 0 449
LRANGE mylist 0 599
mset
MSET
MSET (10 keys)
freeClient
Bsds.c
\x%02x
sh->free >= (unsigned int)incr
sh->len >= (unsigned int)(-incr)
sdsIncrLen
zmalloc: Out of memory trying to allocate %zu bytes
/proc/%d/stat
/proc/self/smaps
Private_Dirty:
hiredis.c
parent->type == 2
prv->type == 2
cur->idx < prv->elements
r->buf != ((void *)0)
Out of memory
"\%c"
"%c"
"\x%02x"
eEfFgGaA
$%zu
pos == totlen
type == 1
Server closed the connection
task->type == 6 || task->type == 5 || task->type == 1
Protocol error, got %s as reply type byte
No support for nested multi bulk replies with depth > 7
__redisSetError
redisFormatCommandArgv
redisvFormatCommand
diouxX
moveToNextTask
processItem
redisReaderFeed
createStringObject
createArrayObject
createIntegerObject
createNilObject
%s: 
fcntl(F_GETFL)
fcntl(F_SETFL)
getsockopt(SO_ERROR)
poll(2)
Can't create socket: %s
Can't get addr: %s
setsockopt(TCP_NODELAY)
Can't bind socket: %s
setsockopt(SO_RCVTIMEO)
setsockopt(SO_SNDTIMEO)
;*3$"
redis-benchmark.debug
7zXZ
cD%\
`DhQ
4_,v*S
N41Y`
qoEkk
h%7^g
.`LfX
a=cG#oC
UMPAk
KwWe
l3g~
I8}y
,a)Al^
dVO*yz
.shstrtab
.interp
.note.ABI-tag
.note.gnu.build-id
.gnu.hash
.dynsym
.dynstr
.gnu.version
.gnu.version_r
.rela.dyn
.rela.plt
.init
.text
.fini
.rodata
.eh_frame_hdr
.eh_frame
.init_array
.fini_array
.jcr
.data.rel.ro
.dynamic
.got
.data
.bss
.gnu_debuglink
.gnu_debugdata
