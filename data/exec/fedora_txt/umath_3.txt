jl[U
__gmon_start__
_init
_fini
__cxa_finalize
_Jv_RegisterClasses
degreesf
degrees
degreesl
radiansf
radians
radiansl
PyInt_FromLong
_Py_NoneStruct
PyString_FromString
PyList_New
PyMem_Malloc
PyString_FromStringAndSize
PyMem_Free
PyString_FromFormat
PyString_ConcatAndDel
PyObject_CallMethod
PyNumber_Power
PyErr_Occurred
PyTuple_Type
PyType_IsSubtype
PyString_Type
PyExc_ValueError
PyErr_Format
PyExc_TypeError
PyErr_SetString
PyDict_GetItem
PyCObject_AsVoidPtr
PyErr_NoMemory
memmove
free
__sprintf_chk
__stack_chk_fail
PyGILState_Ensure
stderr
__fprintf_chk
PyGILState_Release
PyOS_snprintf
PyExc_RuntimeWarning
PyErr_WarnEx
Py_BuildValue
PyObject_CallObject
PyExc_FloatingPointError
PyExc_NameError
fetestexcept
feclearexcept
PyList_Type
PyInt_AsLong
PyCallable_Check
PyObject_GetAttrString
PyThreadState_GetDict
PyEval_GetBuiltins
PyString_InternFromString
__memcpy_chk
PyExc_RuntimeError
memcpy
malloc
memset
PyArg_ParseTupleAndKeywords
PyEval_SaveThread
PyEval_RestoreThread
PyExc_IndexError
PyErr_Clear
PyTuple_New
PyEval_CallObjectWithKeywords
PyTuple_Size
PyObject_HasAttrString
PyDict_Next
PyString_AsString
PyInt_Type
PyFloat_Type
PyComplex_Type
PyLong_Type
PyBool_Type
PyUnicode_Type
PyObject_CallFunction
PyErr_ExceptionMatches
PyObject_CallFunctionObjArgs
_Py_NotImplementedStruct
PySequence_Size
PySequence_GetItem
PyLong_FromLongLong
PyNumber_Add
PyCObject_FromVoidPtr
PyDict_SetItem
PyDict_New
PyObject_Init
PyDict_SetItemString
PyArg_ParseTuple
PyString_AsStringAndSize
PyImport_ImportModule
PyCObject_Type
initumath
Py_InitModule4_64
PyType_Ready
PyModule_GetDict
PyUFunc_API
PyExc_ImportError
PyNumber_Absolute
acosf
acos
acosl
acoshf
acosh
acoshl
asinf
asin
asinl
asinhf
asinh
asinhl
atanf
atan
atanl
atan2f
atan2
atan2l
atanhf
atanh
atanhl
PyNumber_And
PyNumber_Or
PyNumber_Xor
ceilf
ceil
ceill
PyNumber_Divide
expm1f
expm1
expm1l
fabsf
fabs
fabsl
floorf
floor
floorl
PyNumber_FloorDivide
fmodf
fmod
fmodl
hypotf
hypot
hypotl
PyNumber_Invert
PyNumber_Lshift
logf
logl
log10f
log10
log10l
log1pf
log1p
log1pl
PyNumber_Multiply
PyNumber_Negative
powf
powl
PyNumber_Remainder
PyNumber_Rshift
rint
rintl
sqrtf
sqrt
sqrtl
PyNumber_Subtract
PyNumber_TrueDivide
PyFloat_FromDouble
PyModule_AddIntConstant
PyModule_AddStringConstant
PyModule_AddObject
PyDict_GetItemString
sincosf
sincos
sincosl
PyObject_Compare
PyObject_RichCompareBool
modfl
modff
__isnanl
__isnan
__isnanf
__isinfl
__isinf
__isinff
__finite
feraiseexcept
PyObject_Cmp
ldexpl
ldexp
ldexpf
frexpl
frexp
frexpf
libm.so.6
libpython2.5.so.1.0
libpthread.so.0
libc.so.6
_edata
__bss_start
_end
GLIBC_2.2.5
GLIBC_2.4
GLIBC_2.3.4
ATSubH
ffffff.
fff.
ffff.
fffff.
fff.
fff.
ffffff.
ffffff.
fff.
fff.
ffffff.
ffffff.
ffffff.
ffffff.
ffffff.
ffffff.
ffffff.
ffffff.
ffff.
ffff.
ffffff.
ffffff.
fff.
ffff.
ffff.
ffff.
fffff.
ffffff.
fff.
fff.
fffff.
fffff.
:~)L
fffff.
fffff.
fffff.
fffff.
fffff.
fffff.
fffff.
fffff.
ffffff.
fffff.
fff.
ffff.
t@fA
t0fA
fffff.
ffffff.
zNfA
z>fA
z.fA
fffff.
fffff.
ffffff.
fffff.
ffffff.
fffff.
fffff.
8~&L
fffff.
ffff.
ffffff.
fff.
fff.
fff.
fff.
fff.
fff.
fff.
ATUSH
[]A\
ATUSH
[]A\
fff.
ATUSH
[]A\
fffff.
fffff.
ffffff.
ffffff.
ffffff.
ffffff.
fffff.
fffff.
ffffff.
ffffff.
ffffff.
ffffff.
l$ L
t$(L
|$0H
AWAVAUATUSH
H9\$
[]A\A]A^A_
l$ L
t$(L
|$0H
AWAVAUATUSH
H9\$
[]A\A]A^A_
AWAVAUATUSH
([]A\A]A^A_
AWAVAUATUSH
L$(L
t$0H
D$8L
T$(L
H9\$0
H[]A\A]A^A_
l$ L
t$(L
|$0H
AWAVAUATUSH
H9\$
[]A\A]A^A_
AWAVAUATUSH
D$ E1
D$0H
H[]A\A]A^A_
AWAVAUATUSH
D$ H
D$(~yH
D$0E1
D$@H
D$PH
D$PA
D$0L
d$ H
h[]A\A]A^A_
ffff.
AWAVAUATUSH
D$ E1
D$0H
D$0H
D$ H
D$(H
H[]A\A]A^A_
AWAVAUATUSH
D$ H
D$0E1
D$@H
D$PH
D$PI
D$XH
D$@H
D$0L
d$ H
l$(H
D$8H
h[]A\A]A^A_
AWAVAUATUSH
D$ E1
D$@H
T$HH
T$(H
T$8H
h[]A\A]A^A_
AWAVAUATUSH
D$ H
D$0E1
D$PH
D$pH
T$xI
T$XH
T$hH
T$8L
d$ H
l$(H
T$HH
[]A\A]A^A_
AWAVAUATUSH
D$ E1
D$0H
D$ f
D$(f
H[]A\A]A^A_
AWAVAUATUSH
D$ H
D$0E1
D$@H
D$PH
D$0L
d$ H
l$(f
D$8f
h[]A\A]A^A_
ATUSD
t%Hc
[]A\A]A^A_
[]A\A]A^
fffff.
fffff.
AWAVAUI
ATUSH
T$,A
HcD$,
D$,H
T$,1
Hcl$(
9\$,
D$(H
T$0E
>~:Lcd$(H
|$(H
L$ H
L$@H
L$@H9
D$ H
H[]A\A]A^A_
fffff.
l$ L
d$(L
l$0H
AWAVAUATUSH
T$ ~pE1
\$ I
P0M9
([]A\A]A^A_
AWAVAUATUSH
P0I9
[]A\A]A^A_
AWAVAUATUSH
T$ H
L$ L
H9l$
d$ H
H+\$ H
P0H9l$
([]A\A]A^A_
ffffff.
AWAVAUATUSH
H9l$
3~bI
P0H9l$
[]A\A]A^A_
AWAVAUI
ATUL
t$ H
T$ 1
=IZ"
5q["
H9D$0H
T$0Ic
D$0H
H9D$0
|$01
]%E1
H9l$0
D$Pt~
L$8H
X[]A\A]A^A_
t$PH
|$PH
\$81
T$ Ic
H;\$0
|$PH
T$8B
}@E1
E Ic
\$ H
[]A\A]A^A_
E9e0
E;e0
t$ I
L$D1
9l$D~(H
9l$D
t$,H
D$,I
[]A\A]A^A_
AWAVAUATUSH
~lE1
[]A\A]A^A_
ffffff.
AWAVAUATUSH
~rE1
[]A\A]A^A_
AWAVAUATUSH
~qE1
[]A\A]A^A_
AWAVAUATUSH
~pE1
[]A\A]A^A_
AWAVAUATUSH
~rE1
[]A\A]A^A_
AWAVAUATUSH
~qE1
[]A\A]A^A_
P0[]L
G8dH
D$h1
T$hdH3
D$x1
T$xdH3
k H;-
k H;-
l$ H
?uo@
t$ H
ffff.
5GC"
t$ H
l$ H
=hw"
5Uw"
l$ H
AWAVI
AUATUSD
L$4D
D$HD
HcT$4H
D$@H
|$@H
T$ I
L$ H
t$(H
D$Lt1H
t$(E1
D$01
;L$4t
U Hc
9L$H
[]A\A]A^A_
T$L;P
HcT$HI
L$ H
L$L9H
}@Hc
|$LH
H9D$8
L$L1
\$ H
d$ D
t$0H
L$LHc
E89H
T$ H
AWAVAUA
pPH9
[]A\A]A^A_
D$ H
\$XI
\$XH
L$XH
t$XH
G Hc
D$xI
H9|$x
T$xH
D$pA
\$XI
D$`f
|$`f
t$0I9t$8
\$xH
D$PI
IcT$(I
t$PA
t$pH
D$0H
I;D$8I
T$0I9T$8
t$xH
D$0I
IcT$(I
t$0A
t$pH
IcD$(I
D$0H
I;D$8I
T$0I9T$8
T$(I
T$(Hc
D$0H
I;D$8I
@8Hc@ H
\$0I9\$8
T$(I
T$(Hc
D$0H
I;D$8I
@8Hc@ H
L$0I9L$8
|$xA
T$(I
T$(Hc
D$0H
I;D$8I
@8Hc@ H
t$pL
F0H;
D$0I9D$8
|$xI
D$0H
I;D$8I
IcT$(H
@8Hc@ H
@8Hc@ H
t$pL
F0H;
A0H;
F0H;
F0H;
@8Hc@ H
@8Hc@ H
@8Hc@ H
T$(I
\$@A
T$(Hc
I;D$8|
T$(I
\$@A
T$(Hc
I;D$8|
L$0I9L$8
L$@H
T$xI
D$xH
T$@H
L$8H
IcT$(I
D$@H9
t$8H
t$pH
H9L$x
D$0H
I;D$8I
\$0I9\$8
T$xL
l$xI
L$HH
~bIc
t$HI
H9\$x
IcT$(I
t$pH
D$0H
I;D$8I
@8Hc@ H
@8Hc@ H
F0H;
F0H;
A0H;
B0H;
A0H;
@8Hc@ H
@8Hc@ H
A0H;
B0H;
AWAVAUATUSH
T$ H
L$0Lc
L$@1
|$@Hc
D$@H
H9T$
|$01
H9D$
H9\$
$~TL
[]A\A]A^A_
L$ I
D$8H9D$(
[]A\A]A^A_A
AWAVAUATUSH
|$`H
T$PH
L$HH
t$XH
D$xH
L$xH
H9D$h
H9D$h
l$PE1
D$0H
t$0H
\$(H
9D$p
MD$p
D$pH
D$xA
L$XL
rPH9
\$0E
\$@B
\$(9D$tB
MD$t
D$hH
[]A\A]A^A_
T$XH
t$xH
T$t9T$p|
T$(1
\$@H
t$`H
L$`I
T$`L
L$HH
t$@H
D$`L
d$PL
l$@E1
\$`Hc
X89{
D$PH
T$`H
t$xD
H9D$h
T$PI
D$8H
H9D$h
L$XH
p(H9
T$XL
\$`L
L$`L
D$xD
T$xD;r
|$`H
L$PMc
T$`H
L$xA
t$`H
t$`L
9auiA
dubA
du[A
D$`L
\$`H
\$`H
t$xA
\$PH
D$`H
T$`H
\$`H
\$PH
t$`H
L$`D
~.Ic
\$`H
D$`H
T$`D
D$`I
\$`H
t$xH
\$PH
t$`H
@8Hc@ H
t$xA
t$`D
L$PH
D$@H
B8;x
T$`H
L$`D
\$`H
t$`H
t$`H
T$`D
L$`Ic
D$`D
t$PE1
D$`H
D$`H
t$`L
t$`H
T$xD;r
T$PH
L$@H
L$`H
L$`H
t$PH
t$PH
T$`H
T$x1
l$PA
t$`Hc
R(L)
L$`Hc
\$PH
AWAVAUI
ATUSH
|$hH
t$`H
L$hH
\$hH
D$hH
t$xH
T$PH
t$PL
D$xH
L$xH
T$xH
T$XH
t$`L
[]A\A]A^A_
L$xH
T$xH
t$xH
L$xH
t$xH
F H9F
t$h1
T$xD
D$xL
t$hE1
L$xD
T$hA
@8Hc@ H
A0H;
L$xH
D$xH
T$xH
t$xH
|$xH
\$xH
D$xH
T$xH
L$xH
t$xH
\$xH
D$hH
T$xH
L$XH
D$0H
T$(H
L$ H
t$xE
\$xH
\$0H
\$xD
\$xH
T$PH
L$@H
t$hD
D$Hf
T$xB
L$ B
L$0H
T$xJ
t$HH
\$8N
<vNc,31
D$xB
T$xJ
L$(H
\$xE1
\$xH
t$PH
T$pH
T$hH
\$xH
t$xH
T$XH
\$xJ
*~6N
D$hD
T$pH
\$0H
\$xD
\$xD
\$hA
\$@H
D$0J
\$XH
T$(A
L$8J
Jc41H
T$hH
\$xD
t$xD
T$hE1
L$xD
\$hA
@8Hc@ H
B0H;
D$hD
L$xH
ffffff.
AVAUATUSH
t$0H
T$0A
D$LH
L$0H
pPH9
H;=o
D$8H
D$ H
D$(L
D$8H
L$ H
.D$8w
D$8H
P0A9
9\$L
3H9D$@~
T$0Hc
9\$L
D$0H
~/Hc
P0A9_
[]A\A]A^A_
tFHc
D$0A
L$LH
D$@E1
P0E1
l$ H
d$(L
l$0L
t$8L
|$@H
$Hcx
$ujI
AVAUATUH
8[]A\A]A^A_
D$0H
T$(H
[]A\A]A^A_
D$0M
[]A\A]A^A_
[]A\A]A^A_
D$ H
D$@L
ED$HH
ED$PH
l$ L
t$(L
|$0H
5G "
([]A
fffff.
H9_ 
u!E1
\$ H
l$(L
d$0H
 (vectorH
izedf
fff.
\$@H
l$HL
d$PH
T$ f
L$0f
L$0f
T$ f
\$@H
l$HL
d$PH
\$@H
l$HL
d$PH
AWAVAUATUSH
~aE1
[]A\A]A^A_
AWAVAUATUSH
[]A\A]A^A_
AWAVAUATUSH
~dE1
[]A\A]A^A_
AWAVAUATUSH
[]A\A]A^A_
AWAVAUATUSH
~ZE1
([]A\A]A^A_
AWAVAUATUSH
([]A\A]A^A_
AWAVAUATUSH
D$(H
l$(L
d$0L
H[]A\A]A^A_
ffff.
AWAVAUATUSH
D$(H
l$(L
d$0L
D$8f
H[]A\A]A^A_
ffff.
AWAVAUATUSH
D$@H
l$@L
d$HL
X[]A\A]A^A_
ffffff.
|$ H
8[A\
|$ H
\$8A
d$@H
fffff.
fffff.
AWAVAUATUSH
[]A\A]A^A_
AWAVAUATUSH
[]A\A]A^A_
AWAVAUATUSH
[]A\A]A^A_
AWAVAUATUSH
[]A\A]A^A_
AWAVAUATUSH
[]A\A]A^A_
fff.
AWAVAUATUSH
[]A\A]A^A_
AWAVAUATUSH
[]A\A]A^A_
fff.
AWAVAUATUSH
[]A\A]A^A_
fff.
AWAVAUATUSH
[]A\A]A^A_
ffff.
AWAVAUATUSH
[]A\A]A^A_
ffff.
ffff.
d$ H
ffff.
fff.
BcH=
ffff.
d$ H
d$ H
BcH=
\$(L
d$0L
t$@H
\$(L
d$0L
t$@H
BcH=
|$,H
YT$ 
Y\$ 
8[A\
fffff.
d$ H
fffff.
fffff.
ffff.
t$ H
ffffff.
|$8H
YT$ f
Y\$ f
H[A\
t$ H
fffff.
|$ H
d$0H
t$ H
fffff.
|$ H
([A\
fffff.
L$PH
t$@L
l$@L
|$0L
l$ L
d$hL
\$`H
|$PH
t$@H
l$@L
|$0L
\$hL
d$pL
L$@H
t$0L
l$0L
l$ L
d$XL
\$PH
|$@H
t$0H
l$0L
l$ H
\$XL
d$`L
t$pH
L$@H
t$0L
l$0L
l$ L
d$XL
\$PH
|$@H
t$0H
l$0L
l$ L
\$XL
d$`L
t$pH
z7u5
ffffff.
z<u:f
ffff.
ffff.
fff.
z,u.
ffff.
-li!
-mi!
([A\
AWAVAUATUSH
[]A\A]A^A_
[]A\A]A^A_A
AWAVAUATUSH
[]A\A]A^A_
AWAVAUATUSH
[]A\A]A^A_
AWAVAUATUSH
[]A\A]A^A_
AWAVAUATUSH
[]A\A]A^A_
AWAVAUATUSH
[]A\A]A^A_
AWAVAUATUSH
[]A\A]A^A_
AWAVAUATUSH
D$ H
D$(~VH
D$01
l$ L
d$(H
T$8H
H[]A\A]A^A_
AWAVAUATUSH
D$ 1
D$ L
([]A\A]A^A_
AWAVAUATUSH
D$$1
D$$L
([]A\A]A^A_
AWAVAUATUSH
[]A\A]A^A_
AWAVAUATUSH
[]A\A]A^A_
AWAVAUATUSH
[]A\A]A^A_
ffffff.
AWAVAUATUSH
[]A\A]A^A_
AWAVAUATUSH
[]A\A]A^A_
ffffff.
AWAVAUATUSH
[]A\A]A^A_
AWAVAUATUSH
[]A\A]A^A_
AWAVAUATUSH
[]A\A]A^A_
AWAVAUATUSH
([]A\A]A^A_
AWAVAUATUSH
([]A\A]A^A_
AWAVAUATUSH
[]A\A]A^A_
ffffff.
AWAVAUATUSH
[]A\A]A^A_
AWAVAUATUSH
[]A\A]A^A_
ffffff.
AWAVAUATUSH
[]A\A]A^A_
AWAVAUATUSH
$~NL
[]A\A]A^A_
AWAVAUATUSH
[]A\A]A^A_
fff.
AWAVAUATUSH
[]A\A]A^A_
AWAVAUATUSH
[]A\A]A^A_
AWAVAUATUSH
[]A\A]A^A_
AWAVAUATUSH
[]A\A]A^A_
AWAVAUATUSH
[]A\A]A^A_
AWAVAUATUSH
[]A\A]A^A_
AWAVAUATUSH
[]A\A]A^A_
ffffff.
AWAVAUATUSH
[]A\A]A^A_
AWAVAUATUSH
[]A\A]A^A_
AWAVAUATUSH
[]A\A]A^A_
AWAVAUATUSH
[]A\A]A^A_
AWAVAUATUSH
[]A\A]A^A_
AWAVAUATUSH
t$ H
~PE1
L9d$ I
([]A\A]A^A_
AWAVAUATUSH
[]A\A]A^A_
AWAVAUATUSH
t$ H
~PE1
L9d$ I
([]A\A]A^A_
AWAVAUATUSH
[]A\A]A^A_
AWAVAUATUSH
t$ H
~PE1
L9d$ A
([]A\A]A^A_
AWAVAUATUSH
[]A\A]A^A_
AWAVAUATUSH
t$ H
~PE1
L9d$ fA
([]A\A]A^A_
AWAVAUATUSH
[]A\A]A^A_
fff.
AWAVAUATUSH
t$ H
$H9l$ ~-L
([]A\A]A^A_
AWAVAUATUSH
[]A\A]A^A_
AWAVAUATUSH
[]A\A]A^A_
AWAVAUATUSH
[]A\A]A^A_
AWAVAUATUSH
[]A\A]A^A_
AWAVAUATUSH
[]A\A]A^A_
AWAVAUATUSH
[]A\A]A^A_
fff.
AWAVAUATUSH
[]A\A]A^A_
AWAVAUATUSH
[]A\A]A^A_
AWAVAUATUSH
[]A\A]A^A_
AWAVAUATUSH
[]A\A]A^A_
AWAVAUATUSH
[]A\A]A^A_
AWAVAUATUSH
[]A\A]A^A_
AWAVAUATUSH
[]A\A]A^A_
AWAVAUATUSH
[]A\A]A^A_
AWAVAUATUSH
[]A\A]A^A_
AWAVAUATUSH
[]A\A]A^A_
fffff.
AWAVAUATUSH
[]A\A]A^A_
fffff.
AWAVAUATUSH
[]A\A]A^A_
AWAVAUATUSH
[]A\A]A^A_
fffff.
AWAVAUATUSH
[]A\A]A^A_
AWAVAUATUSH
[]A\A]A^A_
l$ H
l$ H
AWAVAUATUSH
([]A\A]A^A_
ffffff.
AWAVAUATUSH
[]A\A]A^A_
AWAVAUATUSH
[]A\A]A^A_
AWAVAUATUSH
D$ H
D$(~MH
D$<1
D$<L
l$ A
H[]A\A]A^A_
fffff.
AWAVAUATUSH
D$$1
([]A\A]A^A_
AWAVAUATUSH
D$$1
([]A\A]A^A_
%s1,%s2
,%s%d
%s = %s(%s)
(unknown)
<ufunc '%.50s'>
%s encountered in %s
write
divide by zero
overflow
underflow
invalid value
UFUNC_PYVALS
%s must be a length 3 list.
invalid error mask (%d)
wrong shape for output
function not supported
OO|iO&O&
O(O)i
cannot %s on a scalar
axis not in array
multiply
reduce
accumulate
index out-of-bounds (0, %d)
reduceat
__array_wrap__
invalid number of arguments
__array_priority__
__radd__
subtract
__rsub__
__rmul__
__rdiv__
true_divide
__rtruediv__
floor_divide
__rfloordiv__
remainder
__rmod__
power
__rpow__
left_shift
__rlshift__
right_shift
__rrshift__
bitwise_and
__rand__
bitwise_xor
__rxor__
bitwise_or
__ror__
__array__
invalid return array shape
return array is not writeable
invalid keyword
extobj
O(OOi)
(OO)
unknown user-defined type
NULL
frexp
Compute y = x1 * 2**x2.
ldexp
test
function must be callable
__name__
numpy.core.multiarray
_ARRAY_API
umath
_UFUNC_API
0.4.0
__version__
absolute
arccos
arccosh
arcsin
arcsinh
arctan
arctan2
arctanh
ceil
conjugate
degrees
e**x-1 elementwise.
expm1
fabs
floor
fmod
greater
greater_equal
hypot
invert
isfinite
isinf
isnan
less
less_equal
log10
log1p
logical_and
logical_not
logical_or
logical_xor
maximum
minimum
modf
negative
not_equal
ones_like
radians
reciprocal
rint
sign
signbit
sqrt
square
ERR_IGNORE
ERR_WARN
ERR_CALL
ERR_RAISE
ERR_PRINT
ERR_LOG
ERR_DEFAULT
ERR_DEFAULT2
SHIFT_DIVIDEBYZERO
SHIFT_OVERFLOW
SHIFT_UNDERFLOW
SHIFT_INVALID
FPE_DIVIDEBYZERO
FPE_OVERFLOW
FPE_UNDERFLOW
FPE_INVALID
FLOATING_POINT_SUPPORT
UFUNC_PYVALS_NAME
UFUNC_BUFSIZE_DEFAULT
PINF
NINF
PZERO
NZERO
conj
cannot load umath module.
numpy.ufunc
indices
axis
dtype
frompyfunc
seterrobj
geterrobj
outer
__doc__
documentation string
number of inputs
nout
number of outputs
nargs
ntypes
number of types
function name
identity
identity value
a type-tuple must be specified of length 1 or %d for %s
a type-string for %s, requires %d typecode(s) before and %d after the -> sign
user-defined type used in ufunc with no registered loops
python callback specified for %s (in  %s) but no function found.
Warning: %s encountered in %s
log specified for %s (in %s) but no object with write method found.
buffer size (%d) is not in range (%ld - %ld) or not a multiple of 16
python object must be callable or have a callable write method
zero-size array to ufunc.%s without identity
UFUNC_MAXIDENTITY (%d) is too small (needs to be at least %d)
%s only supported for binary functions
%s only supported for functions returning a single value
cannot perform %s with flexible type
return arrays must be of ArrayType
'%s' is an invalid keyword to %s
outer product only supported for binary functions
exactly two arguments expected
Split the number, x, into a normalized fraction (y1) and exponent (y2)
dynamic ufunc based on a python function
module compiled against version %x of C-API but this version of numpy is %x
umath failed: Could not import array core.
Calculate the absolute value elementwise.
Parameters
----------
x : array_like
    An array-like sequence of values or a scalar.
Returns
-------
res : {ndarray, scalar}
    An ndarray containing the absolute value of
    each element in `x`.  For complex input, ``a + ib``, the
    absolute value is :math:`\sqrt{ a^2 + b^2 }`.
    Returns a scalar for scalar input.
Examples
--------
>>> x = np.array([-1.2, 1.2])
>>> np.absolute(x)
array([ 1.2,  1.2])
>>> np.absolute(1.2 + 1j)
1.5620499351813308
Plot the function over ``[-10, 10]``:
>>> import matplotlib.pyplot as plt
>>> x = np.linspace(-10, 10, 101)
>>> plt.plot(x, np.absolute(x))
>>> plt.show()
Plot the function over the complex plane:
>>> xx = x + 1j * x[:, np.newaxis]
>>> plt.imshow(np.abs(xx), extent=[-10, 10, -10, 10])
>>> plt.show()
Add arguments element-wise.
Parameters
----------
x1, x2 : array_like
    The arrays to be added.
Returns
-------
y : {ndarray, scalar}
    The sum of `x1` and `x2`, element-wise.  Returns scalar if
    both  `x1` and `x2` are scalars.
Notes
-----
Equivalent to `x1` + `x2` in terms of array broadcasting.
Examples
--------
>>> np.add(1.0, 4.0)
>>> x1 = np.arange(9.0).reshape((3, 3))
>>> x2 = np.arange(3.0)
>>> np.add(x1, x2)
array([[  0.,   2.,   4.],
       [  3.,   5.,   7.],
       [  6.,   8.,  10.]])
Trigonometric inverse cosine, element-wise.
The inverse of `cos` so that, if ``y = cos(x)``, then ``x = arccos(y)``.
Parameters
----------
x : array_like
    `x`-coordinate on the unit circle.
    For real arguments, the domain is [-1, 1].
Returns
-------
angle : {ndarray, scalar}
    The angle of the ray intersecting the unit circle at the given
    `x`-coordinate in radians [0, pi]. If `x` is a scalar then a
    scalar is returned, otherwise an array of the same shape as `x`
    is returned.
See Also
--------
cos, arctan, arcsin
Notes
-----
`arccos` is a multivalued function: for each `x` there are infinitely
many numbers `z` such that `cos(z) = x`. The convention is to return the
angle `z` whose real part lies in `[0, pi]`.
For real-valued input data types, `arccos` always returns real output.
For each value that cannot be expressed as a real number or infinity, it
yields ``nan`` and sets the `invalid` floating point error flag.
For complex-valued input, `arccos` is a complex analytical function that
has branch cuts `[-inf, -1]` and `[1, inf]` and is continuous from above
on the former and from below on the latter.
The inverse `cos` is also known as `acos` or cos^-1.
References
----------
.. [1] M. Abramowitz and I.A. Stegun, "Handbook of Mathematical Functions",
       10th printing, 1964, pp. 79. http://www.math.sfu.ca/~cbm/aands/
.. [2] Wikipedia, "Inverse trigonometric function",
       http://en.wikipedia.org/wiki/Arccos
Examples
--------
We expect the arccos of 1 to be 0, and of -1 to be pi:
>>> np.arccos([1, -1])
array([ 0.        ,  3.14159265])
Plot arccos:
>>> import matplotlib.pyplot as plt
>>> x = np.linspace(-1, 1, num=100)
>>> plt.plot(x, np.arccos(x))
>>> plt.axis('tight')
>>> plt.show()
Inverse hyperbolic cosine, elementwise.
Parameters
----------
x : array_like
    Input array.
Returns
-------
out : {ndarray, scalar}
    Array of the same shape and dtype as `x`.
Notes
-----
`arccosh` is a multivalued function: for each `x` there are infinitely
many numbers `z` such that `cosh(z) = x`. The convention is to return the
`z` whose imaginary part lies in `[-pi, pi]` and the real part in
``[0, inf]``.
For real-valued input data types, `arccosh` always returns real output.
For each value that cannot be expressed as a real number or infinity, it
yields ``nan`` and sets the `invalid` floating point error flag.
For complex-valued input, `arccosh` is a complex analytical function that
has a branch cut `[-inf, 1]` and is continuous from above on it.
References
----------
.. [1] M. Abramowitz and I.A. Stegun, "Handbook of Mathematical Functions",
       10th printing, 1964, pp. 86. http://www.math.sfu.ca/~cbm/aands/
.. [2] Wikipedia, "Inverse hyperbolic function",
       http://en.wikipedia.org/wiki/Arccosh
Examples
--------
>>> np.arccosh([np.e, 10.0])
array([ 1.65745445,  2.99322285])
Inverse sine elementwise.
Parameters
----------
x : array_like
  `y`-coordinate on the unit circle.
Returns
-------
angle : {ndarray, scalar}
  The angle of the ray intersecting the unit circle at the given
  `y`-coordinate in radians ``[-pi, pi]``. If `x` is a scalar then
  a scalar is returned, otherwise an array is returned.
See Also
--------
sin, arctan, arctan2
Notes
-----
`arcsin` is a multivalued function: for each `x` there are infinitely
many numbers `z` such that `sin(z) = x`. The convention is to return the
angle `z` whose real part lies in `[-pi/2, pi/2]`.
For real-valued input data types, `arcsin` always returns real output.
For each value that cannot be expressed as a real number or infinity, it
yields ``nan`` and sets the `invalid` floating point error flag.
For complex-valued input, `arcsin` is a complex analytical function that
has branch cuts `[-inf, -1]` and `[1, inf]` and is continuous from above
on the former and from below on the latter.
The inverse sine is also known as `asin` or ``sin^-1``.
References
----------
.. [1] M. Abramowitz and I.A. Stegun, "Handbook of Mathematical Functions",
       10th printing, 1964, pp. 79. http://www.math.sfu.ca/~cbm/aands/
.. [2] Wikipedia, "Inverse trigonometric function",
       http://en.wikipedia.org/wiki/Arcsin
Examples
--------
>>> np.arcsin(1)     # pi/2
1.5707963267948966
>>> np.arcsin(-1)    # -pi/2
-1.5707963267948966
>>> np.arcsin(0)
Inverse hyperbolic sine elementwise.
Parameters
----------
x : array_like
    Input array.
Returns
-------
out : ndarray
    Array of of the same shape as `x`.
Notes
-----
`arcsinh` is a multivalued function: for each `x` there are infinitely
many numbers `z` such that `sinh(z) = x`. The convention is to return the
`z` whose imaginary part lies in `[-pi/2, pi/2]`.
For real-valued input data types, `arcsinh` always returns real output.
For each value that cannot be expressed as a real number or infinity, it
yields ``nan`` and sets the `invalid` floating point error flag.
For complex-valued input, `arccos` is a complex analytical function that
has branch cuts `[1j, infj]` and `[-1j, -infj]` and is continuous from
the right on the former and from the left on the latter.
The inverse hyperbolic sine is also known as `asinh` or ``sinh^-1``.
References
----------
.. [1] M. Abramowitz and I.A. Stegun, "Handbook of Mathematical Functions",
       10th printing, 1964, pp. 86. http://www.math.sfu.ca/~cbm/aands/
.. [2] Wikipedia, "Inverse hyperbolic function",
       http://en.wikipedia.org/wiki/Arcsinh
Examples
--------
>>> np.arcsinh(np.array([np.e, 10.0]))
array([ 1.72538256,  2.99822295])
Trigonometric inverse tangent, element-wise.
The inverse of tan, so that if ``y = tan(x)`` then
``x = arctan(y)``.
Parameters
----------
x : {array_like, scalar}
    Input values.  `arctan` is applied to each element of `x`.
Returns
-------
out : {ndarray, scalar}
    Out has the same shape as `x`.  Its real part is
    in ``[-pi/2, pi/2]``. It is a scalar if `x` is a scalar.
See Also
--------
arctan2 : Calculate the arctan of y/x.
Notes
-----
`arctan` is a multivalued function: for each `x` there are infinitely
many numbers `z` such that `tan(z) = x`. The convention is to return the
angle `z` whose real part lies in `[-pi/2, pi/2]`.
For real-valued input data types, `arctan` always returns real output.
For each value that cannot be expressed as a real number or infinity, it
yields ``nan`` and sets the `invalid` floating point error flag.
For complex-valued input, `arctan` is a complex analytical function that
has branch cuts `[1j, infj]` and `[-1j, -infj]` and is continuous from the
left on the former and from the right on the latter.
The inverse tangent is also known as `atan` or ``tan^-1``.
References
----------
.. [1] M. Abramowitz and I.A. Stegun, "Handbook of Mathematical Functions",
       10th printing, 1964, pp. 79. http://www.math.sfu.ca/~cbm/aands/
.. [2] Wikipedia, "Inverse trigonometric function",
       http://en.wikipedia.org/wiki/Arctan
Examples
--------
We expect the arctan of 0 to be 0, and of 1 to be :math:`\pi/4`:
>>> np.arctan([0, 1])
array([ 0.        ,  0.78539816])
>>> np.pi/4
0.78539816339744828
Plot arctan:
>>> import matplotlib.pyplot as plt
>>> x = np.linspace(-10, 10)
>>> plt.plot(x, np.arctan(x))
>>> plt.axis('tight')
>>> plt.show()
Elementwise arc tangent of ``x1/x2`` choosing the quadrant correctly.
The quadrant (ie. branch) is chosen so that ``arctan2(x1, x2)``
is the signed angle in radians between the line segments
``(0,0) - (1,0)`` and ``(0,0) - (x2,x1)``. This function is defined
also for `x2` = 0.
`arctan2` is not defined for complex-valued arguments.
Parameters
----------
x1 : array-like, real-valued
    y-coordinates.
x2 : array-like, real-valued
    x-coordinates. `x2` must be broadcastable to match the shape of `x1`,
    or vice versa.
Returns
-------
angle : array-like
    Array of angles in radians, in the range ``[-pi, pi]``.
See Also
--------
arctan, tan
Notes
-----
`arctan2` is identical to the `atan2` function of the underlying
C library. The following special values are defined in the C standard [2]:
====== ====== ================
`x1`   `x2`   `arctan2(x1,x2)`
====== ====== ================
+/- 0  +0     +/- 0
+/- 0  -0     +/- pi
 > 0   +/-inf +0 / +pi
 < 0   +/-inf -0 / -pi
+/-inf +inf   +/- (pi/4)
+/-inf -inf   +/- (3*pi/4)
====== ====== ================
Note that +0 and -0 are distinct floating point numbers.
References
----------
.. [1] Wikipedia, "atan2",
       http://en.wikipedia.org/wiki/Atan2
.. [2] ISO/IEC standard 9899:1999, "Programming language C", 1999.
Examples
--------
Consider four points in different quadrants:
>>> x = np.array([-1, +1, +1, -1])
>>> y = np.array([-1, -1, +1, +1])
>>> np.arctan2(y, x) * 180 / np.pi
array([-135.,  -45.,   45.,  135.])
Note the order of the parameters. `arctan2` is defined also when `x2` = 0
and at several other special points, obtaining values in
the range ``[-pi, pi]``:
>>> np.arctan2([1., -1.], [0., 0.])
array([ 1.57079633, -1.57079633])
>>> np.arctan2([0., 0., np.inf], [+0., -0., np.inf])
array([ 0.        ,  3.14159265,  0.78539816])
Inverse hyperbolic tangent elementwise.
Parameters
----------
x : array_like
    Input array.
Returns
-------
out : ndarray
    Array of the same shape as `x`.
Notes
-----
`arctanh` is a multivalued function: for each `x` there are infinitely
many numbers `z` such that `tanh(z) = x`. The convention is to return the
`z` whose imaginary part lies in `[-pi/2, pi/2]`.
For real-valued input data types, `arctanh` always returns real output.
For each value that cannot be expressed as a real number or infinity, it
yields ``nan`` and sets the `invalid` floating point error flag.
For complex-valued input, `arctanh` is a complex analytical function that
has branch cuts `[-1, -inf]` and `[1, inf]` and is continuous from
above on the former and from below on the latter.
The inverse hyperbolic tangent is also known as `atanh` or ``tanh^-1``.
References
----------
.. [1] M. Abramowitz and I.A. Stegun, "Handbook of Mathematical Functions",
       10th printing, 1964, pp. 86. http://www.math.sfu.ca/~cbm/aands/
.. [2] Wikipedia, "Inverse hyperbolic function",
       http://en.wikipedia.org/wiki/Arctanh
Examples
--------
>>> np.arctanh([0, -0.5])
array([ 0.        , -0.54930614])
Compute bit-wise AND of two arrays, element-wise.
When calculating the bit-wise AND between two elements, ``x`` and ``y``,
each element is first converted to its binary representation (which works
just like the decimal system, only now we're using 2 instead of 10):
.. math:: x = \sum_{i=0}^{W-1} a_i \cdot 2^i\\
          y = \sum_{i=0}^{W-1} b_i \cdot 2^i,
where ``W`` is the bit-width of the type (i.e., 8 for a byte or uint8),
and each :math:`a_i` and :math:`b_j` is either 0 or 1.  For example, 13
is represented as ``00001101``, which translates to
:math:`2^4 + 2^3 + 2`.
The bit-wise operator is the result of
.. math:: z = \sum_{i=0}^{i=W-1} (a_i \wedge b_i) \cdot 2^i,
where :math:`\wedge` is the AND operator, which yields one whenever
both :math:`a_i` and :math:`b_i` are 1.
Parameters
----------
x1, x2 : array_like
    Only integer types are handled (including booleans).
Returns
-------
out : array_like
    Result.
See Also
--------
bitwise_or, bitwise_xor
logical_and
binary_repr :
    Return the binary representation of the input number as a string.
Examples
--------
We've seen that 13 is represented by ``00001101``.  Similary, 17 is
represented by ``00010001``.  The bit-wise AND of 13 and 17 is
therefore ``000000001``, or 1:
>>> np.bitwise_and(13, 17)
>>> np.bitwise_and(14, 13)
>>> np.binary_repr(12)
'1100'
>>> np.bitwise_and([14,3], 13)
array([12,  1])
>>> np.bitwise_and([11,7], [4,25])
array([0, 1])
>>> np.bitwise_and(np.array([2,5,255]), np.array([3,14,16]))
array([ 2,  4, 16])
>>> np.bitwise_and([True, True], [False, True])
array([False,  True], dtype=bool)
Compute bit-wise OR of two arrays, element-wise.
When calculating the bit-wise OR between two elements, ``x`` and ``y``,
each element is first converted to its binary representation (which works
just like the decimal system, only now we're using 2 instead of 10):
.. math:: x = \sum_{i=0}^{W-1} a_i \cdot 2^i\\
          y = \sum_{i=0}^{W-1} b_i \cdot 2^i,
where ``W`` is the bit-width of the type (i.e., 8 for a byte or uint8),
and each :math:`a_i` and :math:`b_j` is either 0 or 1.  For example, 13
is represented as ``00001101``, which translates to
:math:`2^4 + 2^3 + 2`.
The bit-wise operator is the result of
.. math:: z = \sum_{i=0}^{i=W-1} (a_i \vee b_i) \cdot 2^i,
where :math:`\vee` is the OR operator, which yields one whenever
either :math:`a_i` or :math:`b_i` is 1.
Parameters
----------
x1, x2 : array_like
    Only integer types are handled (including booleans).
Returns
-------
out : array_like
    Result.
See Also
--------
bitwise_and, bitwise_xor
logical_or
binary_repr :
    Return the binary representation of the input number as a string.
Examples
--------
We've seen that 13 is represented by ``00001101``.  Similary, 16 is
represented by ``00010000``.  The bit-wise OR of 13 and 16 is
therefore ``000111011``, or 29:
>>> np.bitwise_or(13, 16)
>>> np.binary_repr(29)
'11101'
>>> np.bitwise_or(32, 2)
>>> np.bitwise_or([33, 4], 1)
array([33,  5])
>>> np.bitwise_or([33, 4], [1, 2])
array([33,  6])
>>> np.bitwise_or(np.array([2, 5, 255]), np.array([4, 4, 4]))
array([  6,   5, 255])
>>> np.bitwise_or(np.array([2, 5, 255, 2147483647L], dtype=np.int32),
...               np.array([4, 4, 4, 2147483647L], dtype=np.int32))
array([         6,          5,        255, 2147483647])
>>> np.bitwise_or([True, True], [False, True])
array([ True,  True], dtype=bool)
Compute bit-wise XOR of two arrays, element-wise.
When calculating the bit-wise XOR between two elements, ``x`` and ``y``,
each element is first converted to its binary representation (which works
just like the decimal system, only now we're using 2 instead of 10):
.. math:: x = \sum_{i=0}^{W-1} a_i \cdot 2^i\\
          y = \sum_{i=0}^{W-1} b_i \cdot 2^i,
where ``W`` is the bit-width of the type (i.e., 8 for a byte or uint8),
and each :math:`a_i` and :math:`b_j` is either 0 or 1.  For example, 13
is represented as ``00001101``, which translates to
:math:`2^4 + 2^3 + 2`.
The bit-wise operator is the result of
.. math:: z = \sum_{i=0}^{i=W-1} (a_i \oplus b_i) \cdot 2^i,
where :math:`\oplus` is the XOR operator, which yields one whenever
either :math:`a_i` or :math:`b_i` is 1, but not both.
Parameters
----------
x1, x2 : array_like
    Only integer types are handled (including booleans).
Returns
-------
out : ndarray
    Result.
See Also
--------
bitwise_and, bitwise_or
logical_xor
binary_repr :
    Return the binary representation of the input number as a string.
Examples
--------
We've seen that 13 is represented by ``00001101``.  Similary, 17 is
represented by ``00010001``.  The bit-wise XOR of 13 and 17 is
therefore ``00011100``, or 28:
>>> np.bitwise_xor(13, 17)
>>> np.binary_repr(28)
'11100'
>>> np.bitwise_xor(31, 5)
>>> np.bitwise_xor([31,3], 5)
array([26,  6])
>>> np.bitwise_xor([31,3], [5,6])
array([26,  5])
>>> np.bitwise_xor([True, True], [False, True])
array([ True, False], dtype=bool)
Return the ceiling of the input, element-wise.
The ceil of the scalar `x` is the smallest integer `i`, such that
`i >= x`.  It is often denoted as :math:`\lceil x \rceil`.
Parameters
----------
x : array_like
    Input data.
Returns
-------
y : {ndarray, scalar}
    The ceiling of each element in `x`.
Examples
--------
>>> a = np.array([-1.7, -1.5, -0.2, 0.2, 1.5, 1.7, 2.0])
>>> np.ceil(a)
array([-1., -1., -0.,  1.,  2.,  2.,  2.])
Return the complex conjugate, element-wise.
The complex conjugate of a complex number is obtained by changing the
sign of its imaginary part.
Parameters
----------
x : array_like
    Input value.
Returns
-------
y : {ndarray, scalar}
    The complex conjugate of `x`, with same dtype as `y`.
Examples
--------
>>> np.conjugate(1+2j)
(1-2j)
Cosine elementwise.
Parameters
----------
x : array_like
    Input array in radians.
Returns
-------
out : ndarray
    Output array of same shape as `x`.
Examples
--------
>>> np.cos(np.array([0, np.pi/2, np.pi]))
array([  1.00000000e+00,   6.12303177e-17,  -1.00000000e+00])
Hyperbolic cosine, element-wise.
Equivalent to ``1/2 * (np.exp(x) + np.exp(-x))`` and ``np.cos(1j*x)``.
Parameters
----------
x : array_like
    Input array.
Returns
-------
out : ndarray
    Output array of same shape as `x`.
Examples
--------
>>> np.cosh(0)
The hyperbolic cosine describes the shape of a hanging cable:
>>> import matplotlib.pyplot as plt
>>> x = np.linspace(-4, 4, 1000)
>>> plt.plot(x, np.cosh(x))
>>> plt.show()
Convert angles from radians to degrees.
Parameters
----------
x : array-like
  Angle in radians.
Returns
-------
y : {ndarray, scalar}
  The corresponding angle in degrees.
See Also
--------
radians : Convert angles from degrees to radians.
unwrap : Remove large jumps in angle by wrapping.
Notes
-----
degrees(x) is ``180 * x / pi``.
Examples
--------
>>> np.degrees(np.pi/2)
90.0
Divide arguments element-wise.
Parameters
----------
x1 : array_like
    Dividend array.
x2 : array_like
    Divisor array.
Returns
-------
y : {ndarray, scalar}
    The quotient `x1/x2`, element-wise. Returns a scalar if
    both  `x1` and `x2` are scalars.
See Also
--------
seterr : Set whether to raise or warn on overflow, underflow and division
         by zero.
Notes
-----
Equivalent to `x1` / `x2` in terms of array-broadcasting.
Behavior on division by zero can be changed using `seterr`.
When both `x1` and `x2` are of an integer type, `divide` will return
integers and throw away the fractional part. Moreover, division by zero
always yields zero in integer arithmetic.
Examples
--------
>>> np.divide(2.0, 4.0)
>>> x1 = np.arange(9.0).reshape((3, 3))
>>> x2 = np.arange(3.0)
>>> np.divide(x1, x2)
array([[ NaN,  1. ,  1. ],
       [ Inf,  4. ,  2.5],
       [ Inf,  7. ,  4. ]])
Note the behavior with integer types:
>>> np.divide(2, 4)
>>> np.divide(2, 4.)
Division by zero always yields zero in integer arithmetic, and does not
raise an exception or a warning:
>>> np.divide(np.array([0, 1], dtype=int), np.array([0, 0], dtype=int))
array([0, 0])
Division by zero can, however, be caught using `seterr`:
>>> old_err_state = np.seterr(divide='raise')
>>> np.divide(1, 0)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
FloatingPointError: divide by zero encountered in divide
>>> ignored_states = np.seterr(**old_err_state)
>>> np.divide(1, 0)
Returns elementwise x1 == x2 in a bool array.
Parameters
----------
x1, x2 : array_like
    Input arrays of the same shape.
Returns
-------
out : boolean
    The elementwise test `x1` == `x2`.
Calculate the exponential of the elements in the input array.
Parameters
----------
x : array_like
    Input values.
Returns
-------
out : ndarray
    Element-wise exponential of `x`.
Notes
-----
The irrational number ``e`` is also known as Euler's number.  It is
approximately 2.718281, and is the base of the natural logarithm,
``ln`` (this means that, if :math:`x = \ln y = \log_e y`,
then :math:`e^x = y`. For real input, ``exp(x)`` is always positive.
For complex arguments, ``x = a + ib``, we can write
:math:`e^x = e^a e^{ib}`.  The first term, :math:`e^a`, is already
known (it is the real argument, described above).  The second term,
:math:`e^{ib}`, is :math:`\cos b + i \sin b`, a function with magnitude
1 and a periodic phase.
References
----------
.. [1] Wikipedia, "Exponential function",
       http://en.wikipedia.org/wiki/Exponential_function
.. [2] M. Abramovitz and I. A. Stegun, "Handbook of Mathematical Functions
       with Formulas, Graphs, and Mathematical Tables," Dover, 1964, p. 69,
       http://www.math.sfu.ca/~cbm/aands/page_69.htm
Examples
--------
Plot the magnitude and phase of ``exp(x)`` in the complex plane:
>>> import matplotlib.pyplot as plt
>>> x = np.linspace(-2*np.pi, 2*np.pi, 100)
>>> xx = x + 1j * x[:, np.newaxis] # a + ib over complex plane
>>> out = np.exp(xx)
>>> plt.subplot(121)
>>> plt.imshow(np.abs(out),
...            extent=[-2*np.pi, 2*np.pi, -2*np.pi, 2*np.pi])
>>> plt.title('Magnitude of exp(x)')
>>> plt.subplot(122)
>>> plt.imshow(np.angle(out),
...            extent=[-2*np.pi, 2*np.pi, -2*np.pi, 2*np.pi])
>>> plt.title('Phase (angle) of exp(x)')
>>> plt.show()
Compute the absolute values elementwise.
This function returns the absolute values (positive magnitude) of the data
in `x`. Complex values are not handled, use `absolute` to find the
absolute values of complex data.
Parameters
----------
x : array_like
    The array of numbers for which the absolute values are required. If
    `x` is a scalar, the result `y` will also be a scalar.
Returns
-------
y : {ndarray, scalar}
    The absolute values of `x`, the returned values are always floats.
See Also
--------
absolute : Absolute values including `complex` types.
Examples
--------
>>> np.fabs(-1)
>>> np.fabs([-1.2, 1.2])
array([ 1.2,  1.2])
Return the floor of the input, element-wise.
The floor of the scalar `x` is the largest integer `i`, such that
`i <= x`.  It is often denoted as :math:`\lfloor x \rfloor`.
Parameters
----------
x : array_like
    Input data.
Returns
-------
y : {ndarray, scalar}
    The floor of each element in `x`.
Notes
-----
Some spreadsheet programs calculate the "floor-towards-zero", in other
words ``floor(-2.5) == -2``.  NumPy, however, uses the a definition of
`floor` such that `floor(-2.5) == -3``.
Examples
--------
>>> a = np.array([-1.7, -1.5, -0.2, 0.2, 1.5, 1.7, 2.0])
>>> np.floor(a)
array([-2., -2., -1.,  0.,  1.,  1.,  2.])
Return the largest integer smaller or equal to the division of the inputs.
Parameters
----------
x1 : array_like
    Numerator.
x2 : array_like
    Denominator.
Returns
-------
y : ndarray
    y = floor(`x1`/`x2`)
See Also
--------
divide : Standard division.
floor : Round a number to the nearest integer toward minus infinity.
ceil : Round a number to the nearest integer toward infinity.
Examples
--------
>>> np.floor_divide(7,3)
>>> np.floor_divide([1., 2., 3., 4.], 2.5)
array([ 0.,  0.,  1.,  1.])
Return the remainder of division.
This is the NumPy implementation of the C modulo operator `%`.
Parameters
----------
x1 : array_like
  Dividend.
x2 : array_like
  Divisor.
Returns
-------
y : array_like
  The remainder of the division of `x1` by `x2`.
See Also
--------
mod : Modulo operation where the quotient is `floor(x1,x2)`.
Notes
-----
The result of the modulo operation for negative dividend and divisors is
bound by conventions. In `fmod`, the sign of the remainder is the sign of
the dividend, and the sign of the divisor has no influence on the results.
Examples
--------
>>> np.fmod([-3, -2, -1, 1, 2, 3], 2)
array([-1,  0, -1,  1,  0,  1])
>>> np.mod([-3, -2, -1, 1, 2, 3], 2)
array([1, 0, 1, 1, 0, 1])
Return (x1 > x2) element-wise.
Parameters
----------
x1, x2 : array_like
    Input arrays.
Returns
-------
Out : {ndarray, bool}
    Output array of bools, or a single bool if `x1` and `x2` are scalars.
See Also
--------
greater_equal
Examples
--------
>>> np.greater([4,2],[2,2])
array([ True, False], dtype=bool)
Returns (x1 >= x2) element-wise.
Parameters
----------
x1, x2 : array_like
    Input arrays.
Returns
-------
Out : {ndarray, bool}
    Output array of bools, or a single bool if `x1` and `x2` are scalars.
See Also
--------
greater
Examples
--------
>>> np.greater_equal([4,2],[2,2])
array([ True, True], dtype=bool)
Given two sides of a right triangle, return its hypotenuse.
Parameters
----------
x : array-like
  Base of the triangle.
y : array-like
  Height of the triangle.
Returns
-------
z : {ndarray, scalar}
  Hypotenuse of the triangle: sqrt(x**2 + y**2)
Examples
--------
>>> np.hypot(3,4)
Compute bit-wise inversion, or bit-wise NOT, element-wise.
When calculating the bit-wise NOT of an element ``x``, each element is
first converted to its binary representation (which works
just like the decimal system, only now we're using 2 instead of 10):
.. math:: x = \sum_{i=0}^{W-1} a_i \cdot 2^i
where ``W`` is the bit-width of the type (i.e., 8 for a byte or uint8),
and each :math:`a_i` is either 0 or 1.  For example, 13 is represented
as ``00001101``, which translates to :math:`2^4 + 2^3 + 2`.
The bit-wise operator is the result of
.. math:: z = \sum_{i=0}^{i=W-1} (\lnot a_i) \cdot 2^i,
where :math:`\lnot` is the NOT operator, which yields 1 whenever
:math:`a_i` is 0 and yields 0 whenever :math:`a_i` is 1.
For signed integer inputs, the two's complement is returned.
In a two's-complement system negative numbers are represented by the two's
complement of the absolute value. This is the most common method of
representing signed integers on computers [1]_. A N-bit two's-complement
system can represent every integer in the range
:math:`-2^{N-1}` to :math:`+2^{N-1}-1`.
Parameters
----------
x1 : ndarray
    Only integer types are handled (including booleans).
Returns
-------
out : ndarray
    Result.
See Also
--------
bitwise_and, bitwise_or, bitwise_xor
logical_not
binary_repr :
    Return the binary representation of the input number as a string.
Notes
-----
`bitwise_not` is an alias for `invert`:
>>> np.bitwise_not is np.invert
True
References
----------
.. [1] Wikipedia, "Two's complement",
    http://en.wikipedia.org/wiki/Two's_complement
Examples
--------
We've seen that 13 is represented by ``00001101``.
The invert or bit-wise NOT of 13 is then:
>>> np.invert(np.array([13], dtype=uint8))
array([242], dtype=uint8)
>>> np.binary_repr(x, width=8)
'00001101'
>>> np.binary_repr(242, width=8)
'11110010'
The result depends on the bit-width:
>>> np.invert(np.array([13], dtype=uint16))
array([65522], dtype=uint16)
>>> np.binary_repr(x, width=16)
'0000000000001101'
>>> np.binary_repr(65522, width=16)
'1111111111110010'
When using signed integer types the result is the two's complement of
the result for the unsigned type:
>>> np.invert(np.array([13], dtype=int8))
array([-14], dtype=int8)
>>> np.binary_repr(-14, width=8)
'11110010'
Booleans are accepted as well:
>>> np.invert(array([True, False]))
array([False,  True], dtype=bool)
Returns True where x is finite, False otherwise.
Parameters
----------
x : array_like
  input values
Returns
-------
y : {ndarray, bool}
  array of bools
Notes
-----
`Nan` is considered as non-finite.
Examples
--------
>>> np.isfinite([np.log(-1.),1.,np.log(0)])
array([False,  True, False], dtype=bool)
Returns True where x is +inf or -inf, False otherwise.
Parameters
----------
x : array_like
  input values
Returns
-------
y : {ndarray, bool}
  array of bools
Examples
--------
>>> np.isinf([np.inf, -np.inf, 1.0, np.nan])
array([ True,  True, False, False], dtype=bool)
Returns True where elements are Not-A-Number, False otherwise.
Parameters
----------
x : array_like
  input values.
Returns
-------
y : {ndarray, bool}
  array of bools
Examples
--------
>>> np.isnan([np.log(-1.),1.,np.log(0)])
array([ True, False, False], dtype=bool)
Computes x1 << x2 (x1 shifted to left by x2 bits) elementwise.
Returns (x1 < x2) element-wise.
Parameters
----------
x1, x2 : array-like
    Input arrays.
Returns
-------
Out : {ndarray, bool}
    Output array of bools, or a single bool if `x1` and `x2` are scalars.
See Also
--------
less_equal
Examples
--------
>>> np.less([1,2],[2,2])
array([ True, False], dtype=bool)
Returns (x1 <= x2) element-wise.
Parameters
----------
x1, x2 : array_like
    Input arrays.
Returns
-------
Out : {ndarray, bool}
    Output array of bools, or a single bool if `x1` and `x2` are scalars.
See Also
--------
less
Examples
--------
>>> np.less_equal([1,2,3],[2,2,2])
array([ True,  True, False], dtype=bool)
Natural logarithm, element-wise.
The natural logarithm `log` is the inverse of the exponential function,
so that `log(exp(x)) = x`. The natural logarithm is logarithm in base `e`.
Parameters
----------
x : array_like
  Input value.
Returns
-------
y : {ndarray, scalar}
  The natural logarithm of `x`, element-wise.
See Also
--------
log10, log2, log1p
Notes
-----
Logarithm is a multivalued function: for each `x` there is an infinite
number of `z` such that `exp(z) = x`. The convention is to return the `z`
whose imaginary part lies in `[-pi, pi]`.
For real-valued input data types, `log` always returns real output. For
each value that cannot be expressed as a real number or infinity, it
yields ``nan`` and sets the `invalid` floating point error flag.
For complex-valued input, `log` is a complex analytical function that
has a branch cut `[-inf, 0]` and is continuous from above on it. `log`
handles the floating-point negative zero as an infinitesimal negative
number, conforming to the C99 standard.
References
----------
.. [1] M. Abramowitz and I.A. Stegun, "Handbook of Mathematical Functions",
       10th printing, 1964, pp. 67. http://www.math.sfu.ca/~cbm/aands/
.. [2] Wikipedia, "Logarithm". http://en.wikipedia.org/wiki/Logarithm
Examples
--------
>>> np.log([1, np.e, np.e**2, 0])
array([  0.,   1.,   2., -Inf])
Compute the logarithm in base 10 elementwise.
Parameters
----------
x : array_like
  input values.
Returns
-------
y : {ndarray, scalar}
  base-10 logarithm of `x`.
Notes
-----
Logarithm is a multivalued function: for each `x` there is an infinite
number of `z` such that `10**z = x`. The convention is to return the `z`
whose imaginary part lies in `[-pi, pi]`.
For real-valued input data types, `log10` always returns real output. For
each value that cannot be expressed as a real number or infinity, it
yields ``nan`` and sets the `invalid` floating point error flag.
For complex-valued input, `log10` is a complex analytical function that
has a branch cut `[-inf, 0]` and is continuous from above on it. `log10`
handles the floating-point negative zero as an infinitesimal negative
number, conforming to the C99 standard.
References
----------
.. [1] M. Abramowitz and I.A. Stegun, "Handbook of Mathematical Functions",
       10th printing, 1964, pp. 67. http://www.math.sfu.ca/~cbm/aands/
.. [2] Wikipedia, "Logarithm". http://en.wikipedia.org/wiki/Logarithm
Examples
--------
>>> np.log10([1.e-15,-3.])
array([-15.,  NaN])
`log(1 + x)` in base `e`, elementwise.
Parameters
----------
x : array_like
    Input values.
Returns
-------
y : {ndarray, scalar}
    Natural logarithm of `1 + x`, elementwise.
Notes
-----
For real-valued input, `log1p` is accurate also for `x` so small
that `1 + x == 1` in floating-point accuracy.
Logarithm is a multivalued function: for each `x` there is an infinite
number of `z` such that `exp(z) = 1 + x`. The convention is to return
the `z` whose imaginary part lies in `[-pi, pi]`.
For real-valued input data types, `log1p` always returns real output. For
each value that cannot be expressed as a real number or infinity, it
yields ``nan`` and sets the `invalid` floating point error flag.
For complex-valued input, `log1p` is a complex analytical function that
has a branch cut `[-inf, -1]` and is continuous from above on it. `log1p`
handles the floating-point negative zero as an infinitesimal negative
number, conforming to the C99 standard.
References
----------
.. [1] M. Abramowitz and I.A. Stegun, "Handbook of Mathematical Functions",
       10th printing, 1964, pp. 67. http://www.math.sfu.ca/~cbm/aands/
.. [2] Wikipedia, "Logarithm". http://en.wikipedia.org/wiki/Logarithm
Examples
--------
>>> np.log1p(1e-99)
1e-99
>>> np.log(1 + 1e-99)
Compute the truth value of x1 AND x2 elementwise.
Parameters
----------
x1, x2 : array_like
    Logical AND is applied to the elements of `x1` and `x2`.
    They have to be of the same shape.
Returns
-------
y : {ndarray, bool}
    Boolean result with the same shape as `x1` and `x2` of the logical
    AND operation on elements of `x1` and `x2`.
See Also
--------
logical_or, logical_not, logical_xor
bitwise_and
Examples
--------
>>> np.logical_and(True, False)
False
>>> np.logical_and([True, False], [False, False])
array([False, False], dtype=bool)
>>> x = np.arange(5)
>>> np.logical_and(x>1, x<4)
array([False, False,  True,  True, False], dtype=bool)
Compute the truth value of NOT x elementwise.
Parameters
----------
x : array_like
    Logical NOT is applied to the elements of `x`.
Returns
-------
y : {ndarray, bool}
    Boolean result with the same shape as `x` of the NOT operation
    on elements of `x`.
See Also
--------
logical_and, logical_or, logical_xor
Examples
--------
>>> np.logical_not(3)
False
>>> np.logical_not([True, False, 0, 1])
array([False,  True,  True, False], dtype=bool)
>>> x = np.arange(5)
>>> np.logical_not(x<3)
array([False, False, False,  True,  True], dtype=bool)
Compute the truth value of x1 OR x2 elementwise.
Parameters
----------
x1, x2 : array_like
    Logical OR is applied to the elements of `x1` and `x2`.
    They have to be of the same shape.
Returns
-------
y : {ndarray, bool}
    Boolean result with the same shape as `x1` and `x2` of the logical
    OR operation on elements of `x1` and `x2`.
See Also
--------
logical_and, logical_not, logical_xor
bitwise_or
Examples
--------
>>> np.logical_or(True, False)
True
>>> np.logical_or([True, False], [False, False])
array([ True, False], dtype=bool)
>>> x = np.arange(5)
>>> np.logical_or(x < 1, x > 3)
array([ True, False, False, False,  True], dtype=bool)
Compute the truth value of x1 XOR x2 elementwise.
Parameters
----------
x1, x2 : array_like
    Logical XOR is applied to the elements of `x1` and `x2`.
    They have to be of the same shape.
Returns
-------
y : {ndarray, bool}
    Boolean result with the same shape as `x1` and `x2` of the logical
    XOR operation on elements of `x1` and `x2`.
See Also
--------
logical_and, logical_or, logical_not
bitwise_xor
Examples
--------
>>> np.logical_xor(True, False)
True
>>> np.logical_xor([True, True, False, False], [True, False, True, False])
array([False,  True,  True, False], dtype=bool)
>>> x = np.arange(5)
>>> np.logical_xor(x < 1, x > 3)
array([ True, False, False, False,  True], dtype=bool)
Returns maximum (if x1 > x2: x1;  else: x2) elementwise.
Returns minimum (if x1 < x2: x1;  else: x2) elementwise
Return the fractional and integral part of a number.
The fractional and integral parts are negative if the given number is
negative.
Parameters
----------
x : array_like
    Input number.
Returns
-------
y1 : ndarray
    Fractional part of `x`.
y2 : ndarray
    Integral part of `x`.
Examples
--------
>>> np.modf(2.5)
(0.5, 2.0)
>>> np.modf(-.4)
(-0.40000000000000002, -0.0)
Multiply arguments elementwise.
Parameters
----------
x1, x2 : array-like
    The arrays to be multiplied.
Returns
-------
y : {ndarray, scalar}
    The product of `x1` and `x2`, elementwise. Returns a scalar if
    both  `x1` and `x2` are scalars.
Notes
-----
Equivalent to `x1` * `x2` in terms of array-broadcasting.
Examples
--------
>>> np.multiply(2.0, 4.0)
>>> x1 = np.arange(9.0).reshape((3, 3))
>>> x2 = np.arange(3.0)
>>> np.multiply(x1, x2)
array([[  0.,   1.,   4.],
       [  0.,   4.,  10.],
       [  0.,   7.,  16.]])
Returns an array with the negative of each element of the original array.
Parameters
----------
x : {array_like, scalar}
    Input array.
Returns
-------
y : {ndarray, scalar}
    Returned array or scalar `y=-x`.
Examples
--------
>>> np.negative([1.,-1.])
array([-1.,  1.])
Return (x1 != x2) element-wise.
Parameters
----------
x1, x2 : array_like
  Input arrays.
out : ndarray, optional
  A placeholder the same shape as `x1` to store the result.
Returns
-------
not_equal : ndarray bool, scalar bool
  For each element in `x1, x2`, return True if `x1` is not equal
  to `x2` and False otherwise.
See Also
--------
equal, greater, greater_equal, less, less_equal
Examples
--------
>>> np.not_equal([1.,2.], [1., 3.])
array([False,  True], dtype=bool)
Returns an array of zeros with the same shape and type as a given array.
Equivalent to ``a.copy().fill(1)``.
Please refer to the documentation for `zeros_like`.
See Also
--------
zeros_like
Examples
--------
>>> a = np.array([[1, 2, 3], [4, 5, 6]])
>>> np.ones_like(a)
array([[1, 1, 1],
       [1, 1, 1]])
Computes `x1` ** `x2` elementwise.
Raise each base in `x1` to the power of the exponents in `x2`. This
requires that `x1` and `x2` must be broadcastable to the same shape.
Parameters
----------
x1 : array_like
    The bases.
x2 : array_like
    The exponents.
Returns
-------
y : ndarray
    The bases in `x1` raised to the exponents in `x2`.
Examples
--------
Cube each element in a list.
>>> x1 = range(6)
>>> x1
[0, 1, 2, 3, 4, 5]
>>> np.power(x1, 3)
array([  0,   1,   8,  27,  64, 125])
Raise the bases to different exponents.
>>> x2 = [1.0, 2.0, 3.0, 3.0, 2.0, 1.0]
>>> np.power(x1, x2)
array([  0.,   1.,   8.,  27.,  16.,   5.])
The effect of broadcasting.
>>> x2 = np.array([[1, 2, 3, 3, 2, 1], [1, 2, 3, 3, 2, 1]])
>>> x2
array([[1, 2, 3, 3, 2, 1],
       [1, 2, 3, 3, 2, 1]])
>>> np.power(x1, x2)
array([[ 0,  1,  8, 27, 16,  5],
       [ 0,  1,  8, 27, 16,  5]])
Convert angles from degrees to radians.
Parameters
----------
x : array_like
  Angles in degrees.
Returns
-------
y : {ndarray, scalar}
  The corresponding angle in radians.
See Also
--------
degrees : Convert angles from radians to degrees.
unwrap : Remove large jumps in angle by wrapping.
Notes
-----
``radians(x)`` is ``x * pi / 180``.
Examples
--------
>>> np.radians(180)
3.1415926535897931
Compute 1/x.
Parameters
----------
x : array_like
    Input value.
Returns
-------
y : {ndarray, scalar}
    Return value.
Examples
--------
>>> reciprocal(2.)
>>> reciprocal([1, 2., 3.33])
array([ 1.       ,  0.5      ,  0.3003003])
Computes x1-n*x2 where n is floor(x1 / x2)
Parameters
----------
x1 : array_like
    Dividend array.
x2 : array_like
    Divisor array.
Returns
-------
y : {ndarray, scalar}
    The quotient `x1/x2`, element-wise. Returns a scalar if
    both  `x1` and `x2` are scalars.
See Also
--------
divide
floor
Notes
-----
Returns 0 when `x2` is 0.
Examples
--------
>>> np.remainder([4,7],[2,3])
array([0, 1])
Computes x1 >> x2 (x1 shifted to right by x2 bits) elementwise.
Round elements of the array to the nearest integer.
Parameters
----------
x : array_like
    Input array.
Returns
-------
out : ndarray
    Output array is same shape and type as `x`.
Examples
--------
>>> a = [-4.1, -3.6, -2.5, 0.1, 2.5, 3.1, 3.9]
>>> np.rint(a)
array([-4., -4., -2.,  0.,  2.,  3.,  4.])
Return the sign of a number.
-1 if x < 0, 0 if x==0, 1 if x > 0.
Parameters
----------
x : array_like
  Input values.
Returns
-------
y : {ndarray, scalar}
  The sign of `x`.
Examples
--------
>>> np.sign([-5., 4.5])
array([-1.,  1.])
>>> np.sign(0)
Returns True where `signbit` of `x` is set (`x<0`).
Parameters
----------
x: array-like or scalar
  the input value(s).
output : array-like or scalar
  the returned boolean(s)
Examples
--------
>>> np.signbit(-1.2)
True
>>> np.signbit(np.array([1,-2.3,2.1]))
array([False,  True, False], dtype=bool)
Trigonometric sine, element-wise.
Parameters
----------
x : array_like
    Angle, in radians (:math:`2 \pi` rad equals 360 degrees).
Returns
-------
y : array_like
    The sine of each element of x.
See Also
--------
arcsin, sinh, cos
Notes
-----
The sine is one of the fundamental functions of trigonometry
(the mathematical study of triangles).  Consider a circle of radius
1 centered on the origin.  A ray comes in from the :math:`+x` axis,
makes an angle at the origin (measured counter-clockwise from that
axis), and departs from the origin.  The :math:`y` coordinate of
the outgoing ray's intersection with the unit circle is the sine
of that angle.  It ranges from -1 for :math:`x=3\pi / 2` to
+1 for :math:`\pi / 2.`  The function has zeroes where the angle is
a multiple of :math:`\pi`.  Sines of angles between :math:`\pi` and
:math:`2\pi` are negative.  The numerous properties of the sine and
related functions are included in any standard trigonometry text.
Examples
--------
Print sine of one angle:
>>> np.sin(np.pi/2.)
Print sines of an array of angles given in degrees:
>>> np.sin(np.array((0., 30., 45., 60., 90.)) * np.pi / 180. )
array([ 0.        ,  0.5       ,  0.70710678,  0.8660254 ,  1.        ])
Plot the sine function:
>>> import matplotlib.pylab as plt
>>> x = np.linspace(-np.pi, np.pi, 201)
>>> plt.plot(x, np.sin(x))
>>> plt.xlabel('Angle [rad]')
>>> plt.ylabel('sin(x)')
>>> plt.axis('tight')
>>> plt.show()
Hyperbolic sine, element-wise.
Equivalent to ``1/2 * (np.exp(x) - np.exp(-x))`` or
``-1j * np.sin(1j*x)``.
Parameters
----------
x : array_like
    Input array.
Returns
-------
out : ndarray
    Output array of same shape as `x`.
Return the positive square-root of an array, element-wise.
Parameters
----------
x : array_like
    The square root of each element in this array is calculated.
Returns
-------
y : ndarray
    The square-root of each element in `x`.  If any element in `x`
    is complex, a complex array is returned.  If all of the elements
    of `x` are real, negative elements will return numpy.nan elements.
See Also
--------
numpy.lib.scimath.sqrt
    A version which will return complex numbers when given negative reals.
Notes
-----
`sqrt` has a branch cut ``[-inf, 0)`` and is continuous from above on it.
Examples
--------
>>> np.sqrt([1,4,9])
array([ 1.,  2.,  3.])
>>> np.sqrt([4, -1, -3+4J])
array([ 2.+0.j,  0.+1.j,  1.+2.j])
>>> np.sqrt([4, -1, numpy.inf])
array([  2.,  NaN,  Inf])
Compute `x` squared, or `x` to the power of two.
Parameters
----------
x : array_like or scalar
    Input data.
Returns
-------
out : ndarray or scalar
    Element-wise `x*x`, of the same shape and dtype as `x`.
    `out` is a scalar if `x` is a scalar.
See Also
--------
numpy.linalg.matrix_power
sqrt
power
Examples
--------
>>> np.square([-1j, 1])
array([-1.-0.j,  1.+0.j])
Subtract arguments elementwise.
Parameters
----------
x1, x2 : {array_like, scalar}
    The arrays to be subtracted from each other.  If type is 'array_like'
    the `x1` and `x2` shapes must be identical.
Returns
-------
y : {ndarray, scalar}
    The difference of `x1` and `x2`, elementwise.  Returns a scalar if
    both  `x1` and `x2` are scalars.
Notes
-----
Equivalent to `x1` - `x2` in terms of array-broadcasting.
Examples
--------
>>> np.subtract(1.0, 4.0)
-3.0
>>> x1 = np.arange(9.0).reshape((3, 3))
>>> x2 = np.arange(3.0)
>>> np.subtract(x1, x2)
array([[ 0.,  0.,  0.],
       [ 3.,  3.,  3.],
       [ 6.,  6.,  6.]])
Compute tangent elementwise.
Parameters
----------
x : array_like
  Angles in radians.
Returns
-------
y : ndarray or scalar
  The corresponding tangent values.
Examples
--------
>>> from math import pi
>>> np.tan(np.array([-pi,pi/2,pi]))
array([  1.22460635e-16,   1.63317787e+16,  -1.22460635e-16])
Hyperbolic tangent elementwise.
Parameters
----------
x : array_like
    Input array.
Returns
-------
y : ndarray or scalar
    The corresponding hyperbolic tangent values.
Returns an elementwise, true division of the inputs.
Instead of the Python traditional 'floor division', this returns a true
division.  True division adjusts the output type to present the best
answer, regardless of input types.
Parameters
----------
x1 : array_like
    Dividend
x2 : array_like
    Divisor
Returns
-------
out : {ndarray, scalar}
    Result is scalar if both inputs are scalar, ndarray otherwise.
Notes
-----
The floor division operator ('//') was added in Python 2.2 making '//'
and '/' equivalent operators.  The default floor division operation of
'/' can be replaced by true division with
'from __future__ import division'.
In Python 3.0, '//' will be the floor division operator and '/' will be
the true division operator.  The 'true_divide(`x1`, `x2`)' function is
equivalent to true division in Python.
function not supported for these types, and can't coerce safely to supported types
Error object must be a list of length 3
return a list with types grouped input->output
.eB5
!	@iW
loop written to specified type(s) not found
frompyfunc(func, nin, nout) take an arbitrary python function that takes nin objects as input and returns nout objects and return a universal function (ufunc).  This ufunc always returns PyObject arrays
umath.so.debug
.shstrtab
.note.gnu.build-id
.gnu.hash
.dynsym
.dynstr
.gnu.version
.gnu.version_r
.rela.dyn
.rela.plt
.init
.text
.fini
.rodata
.eh_frame_hdr
.eh_frame
.ctors
.dtors
.jcr
.data.rel.ro
.dynamic
.got
.got.plt
.data
.bss
.gnu_debuglink
