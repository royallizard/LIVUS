b5Y 
HpJ!)
|-fc
__gmon_start__
_init
_fini
_ITM_deregisterTMCloneTable
_ITM_registerTMCloneTable
__cxa_finalize
_Jv_RegisterClasses
plugin_register
proto_register_asn1
plugin_reg_handoff
proto_reg_handoff_asn1
version
g_log
g_free
strcmp
g_snprintf
asn1_open
asn1_uint32_decode
asn1_err_to_str
asn1_header_decode
asn1_string_value_decode
g_realloc
asn1_uint32_value_decode
g_malloc
g_node_new
g_node_insert_before
memset
g_ptr_array_new
fputs
fflush
fopen64
g_sprintf
g_ptr_array_add
proto_register_field_array
g_malloc0
g_strdup
g_strdup_printf
g_node_traverse
g_node_destroy
__ctype_b_loc
strncpy
lev_limit
asn1_close
icount
tvb_length_remaining
asn1_oid_value_decode
asn1_bits_decode
asn1_int32_value_decode
asn1_bool_decode
dissector_add_uint
dissector_delete_uint
except_throw
range_foreach
range_copy
create_dissector_handle
range_convert_range
fileno
__fxstat64
fclose
__errno_location
report_open_failure
tvb_free
fread
tvb_new_real_data
tvb_length
g_log_set_handler
g_strerror
memmove
proto_tree_add_text
proto_item_append_text
strlen
proto_tree_add_item
proto_item_set_text
proto_item_add_subtree
proto_item_set_len
proto_tree_add_string_format
proto_tree_add_none_format
proto_tree_add_uint_format
proto_tree_add_uint
proto_tree_add_boolean_format
proto_tree_add_boolean
proto_tree_add_string
proto_tree_add_bytes_format
proto_tree_add_bytes
col_add_fstr
col_clear
col_add_str
except_setup_try
_setjmp
except_free
except_pop
proto_tree_add_protocol_format
col_append_fstr
except_rethrow
g_assertion_message_expr
__longjmp_chk
get_tempfile_path
proto_register_protocol
proto_register_subtree_array
prefs_register_protocol
ep_strdup_printf
range_convert_str
prefs_register_range_preference
prefs_register_bool_preference
get_datafile_path
prefs_register_string_preference
prefs_register_uint_preference
prefs_register_enum_preference
prefs_register_obsolete_preference
asn1_octet_decode
tvb_get_guint8
asn1_tag_decode
asn1_id_decode
asn1_id_decode1
asn1_length_decode
asn1_eoc
asn1_eoc_decode
asn1_null_decode
asn1_int32_decode
tvb_ensure_bytes_exist
asn1_string_decode
asn1_octet_string_decode
asn1_subid_decode
asn1_oid_decode
asn1_sequence_decode
ep_strdup
libpthread.so.0
libc.so.6
__stack_chk_fail
_edata
__bss_start
_end
asn1.so
GLIBC_2.0
GLIBC_2.3
GLIBC_2.11
GLIBC_2.2
GLIBC_2.1.3
GLIBC_2.4
GLIBC_2.1
D$L1
T$4u1
T$8w
D$Le3
d$\[^_]
T$<1
T$<e3
d$L[^_]
d$([
l$Dt
D$de
T$<1
T$<e3
t$De
D$<1
T$<e3
t$Pe
D$<1
9l$(
T$<e3
t$`e
D$L1
9|$4
T$Le3
t$`e
D$L1
u[9l$4
T$Le3
D$,1
T$,e3
d$<[^_]
|$Dt
\$<e
D$,1
T$Tt
T$,e3
D$\1
|$\e3=
d$l[^_]
no i
nfo 
avai
labl
D$,u
[^_]
d$([
T$@e
[^_]
t$L1
UWVS
D$l1
|$X(
T$le3
d$|[^_]
L$Hu!
DD$@
+D$L
NDvt
L$8u
UWVS
D$He
;l$<t<
L$Hf
L$@9J(
L$,u
L$49H
L$@9
[^_]
UWVS
T$Pe
D$,1
T$,e3
d$<[^_]
UWVS
1;t$
d$,[^_]
UWVS
L$<1
T$<e3
d$L[^_]
UWVS
L$89
9D$0
D$<9D$0
[^_]
inde
fini
D$0e
d$([
D$0e
d$([
D$0e
d$([
D$0e
d$([
D$0e
d$([
D$0e
d$([
d$([
d$([
L$,1
D$,e3
d$([
UWVS
[^_]
D|$X
UWVS
+l$`
9T$`
[^_]
[^_]
;D$L
D$L9
;D$L
L$T9M
9D$l
L$ht
;D$L
;D$L
l$T9i
t$T9u
D$T9A
T$de
D$<1
9|$$
T$<e3
D$$u
d$L[^_]
UWVS
9D$t
DL$L
E|$D
9l$p
[^_]
L$ )
L$L)
D$\t
;t$T
+T$t
L$L)
L$L)
L$L)
L$L)
L$L)
L$()
L$$)
L$$)
L$L)
L$$)
L$L)
L$()
UWVS
[^_]
L$Lu
L$tw
L$lw
UWVS
D$81
[^_]
|$(e
d$,[^_]
|$De
D$,1
T$,e3
l$8e
D$,1
T$,e3
T$+	
\$$e
t$0t'9F
\$ e
t$0t+9F
T$ e
t$@e
D$,1
L$+	
T$,e3
|$de
D$L1
T$Le3
UWVS
|$Te
D$,1
L$+	
T$,e3
d$<[^_]
|$de
D$L1
T$Le3
UWVS
T$Xe
D$,1
L$,e3
d$<[^_]
UWVS
T$Xe
L$,1
L$,e3
d$<[^_]
T$xe
D$L1
T$Le3
T$$9T$Du
D$,1
T$,e3
d$8[
UWVS
d$,[^_]
L$,1
T$,e3
T$te
D$L1
T$Le3
|$Te
D$<1
T$<e3
\$De
T$<1
t$HvS
T$<e3
0.5.0
, useful
, isPDU
 opt
, implicit
%*smodule %s%s
%*stypedef %d %s%s
%*stype %d[%s]%s [%s]
%*stag %c%d[%s]
%*snamednumber %2d %s
%*srange %d .. %d
%*styperef %d[%s]%s
%*s--default-- type=%d
    using sub choice (%s)%s
    have %c%d, found %c%d, %s
    OK, '%s:(%s)%s' chosen
    ...no matching choice...
%d(changed from %d)
expect tag 3, ERROR
, optional
, namednum
, anonymous
, reference
, typedef
, typetree
name: %2d %s
def %d: 
, mt=%d, bt=%d
, reference to %s (%s)%s [%s]
 T%d
%s%s%s%s%s%s%s
%*s%s
TypeDef
Type
, CLASSREF %d
%*sno typeref tag%s
%*s*refer2 to type#%d %s, %p
%*s*collection T %s
NamedNumber
%*s  %3d %s
implicit 
%*s+handle a %s, list=%p
%*s*skip range
anon%d
%*s*switch %s %s
%*s*collection %s
%*s*insert type tag %c%d
%*s*set tag %c%d
TypeRef
%*s*type#%d %s, %p
%*s*refer to type#%d %s, %p
%*s*typeref %s > %s%s at %p
no data nodes
%s found, %p, typedef %d
%s not found, ignored
%s.%s
%s.%s.
%d anonymous types
******** Define type %d, %s
%s.--.%s
%s.--.%s.
%d types used
Type index:
  %3d %s, %c%d, refs: %d
      -- defining id=%d
      %s
The resulting PDU tree:
....
%2.2X
*too many bits*
*list-still-0*
%d skip1 %d
TAG%d
%d skip2 %d
sctp.port
udp.port
tcp.port
PDUreset %d-%d
sentinel
not 
, X  with errors  X
file %s is empty, ignored
reading %d bytes from %s
error reading %s, %s
logging to file %s
read %d items from %s
interpreting tree
TBLTypeId
%s %sfound, %p
tbltypenames: max=%d, info=%p
 %c %2d %s %s
tbltypedefs: max=%d, info=%p
  %3d %s, %c%d
* %3d %s pdu=%p
[repeat]
[choice]
[done]
[ref]
[ref-pop]
[chs-rep]
[rep-chs]
[seq-chs]
[constr]
==underflow
------
inknown tag
==off=%d %c%d%c
*underflow*
    EOI: reference pop
    EOI: pop typeref
    EOI: mark choice
  EOI, pos.node == NULL
*no-name-EOI*
  EOI %s:%s OK, offset=%d
explicit-EOC
  return '%s', ignore
ASN1
  pos.node == NULL
*no-name*
    finish choice
    repeating choice
    seqof: repeat start
  return for repeat '%s'
    anonymous: dontshow
    repeating a choice, %s
    reference pop, donext
    sequence done, donext
    donext
    seq [push,child]
    choice [push], %c%d, %s
    '%s' %c%d will be used
    typeref [pop,next]
*no-name-2*
  return '%s'
  candidate %s '%s'%s%s, %c%d
    got %c%d, found %c%d
    *end of optional list...
  optional, %s
%s!%s
    %s:%s will be used
    matching choice '%s'
  using: %s '%s'%s%s, %c%d
  using: unknown '%s'
   typeref [push]
  typeref %s %s
    typeref pop
    typeref [pop]
*error*
true
false
*too many bits, no names...*
, noshow
, unexpected constructed
ASN1 ERROR: %s
%s[%s]
%ctag%d
NN%d
%s ** nesting cut off **
(%s)%s: %d
(%s)%s: %d ~
(%s)%s: %d:%s
(%s)%s: %d:%s ~
(%s)%s: %s
(%s)%s: %s ~
(%s)%s: %s:%s
(%s)%s: %s:%s ~
(%s)%s: [NULL]
(%s)%s: %s bytes
(%s)%s: %s bytes %s data
dissect_asn1: udp
ASN.1 %s
 at %d
first pdu%s: (%s)%s 
%s: (%s)%s %d-%d %s
%s: (%s)%s %d-%d %s ~
%s: (%s)%s
%s: (%s)%s ~
 (%d error%s)
[%d msg%s]
, %d msg%s
[%d+1 msg%s]
, %d+1 msg%s
 (incomplete)
except_state == EXCEPT_CAUGHT
packet-asn1.c
wireshark.log
ASN.1 decoding
ASN.1 TCP Ports
tcp_ports
ASN.1 UDP Ports
udp_ports
ASN.1 SCTP Ports
sctp_ports
Desegment TCP
desegment_messages
asn1/default.tt
ASN.1 type table file
Name of top level PDU
ASN.1 PDU name
pdu_name
first_pdu_offset
Show full names
flat
Eliminate references to level
type_recursion
ASN.1 debug mode
debug
message_win
Write very verbose log
verbose_log
Boolean
Integer
BitString
OctetString
Null
ObjectIdentifier
ObjectDescriptor
External
Real
Enumerated
tag11
UTF8String
tag13
tag14
tag15
Sequence
NumericString
PrintableString
TeletexString
VideotexString
IA5String
UTCTime
GeneralTime
GraphicString
ISO646String
GeneralString
UniversalString
tag29
BMPString
Long tag prefix
Primitive
Constructed
Universal
Application
Context
Private
tbl-boolean
tbl-integer
tbl-bitstring
tbl-octetstring
tbl-null
tbl-oid
tbl-real
tbl-enumerated
tbl-sequence
tbl-set
tbl-sequenceof
tbl-setof
tbl-choice
tbl-typeref
tbl-sequenceof-start
tbl-typeref-nopop
tbl-choice-done
tbl-reserved
tbl-choice-immediate
tbl-invalid
Module
Range
FT_BOOLEAN
FT_UINT32
FT_STRINGZ
FT_NONE
FT_BYTES
FT_DOUBLE
INTEGER
BITSTRING
OCTET STRING
OBJECT IDENTIFIER
REAL
ENUMERATED
SEQUENCE
SET OF
CHOICE
TYPEREF
start-SEQUENCE OF
TYPEREF nopop
CHOICE done
Reserved
CHOICE immediate
INVALID entry
%*snode=%p, data=%p, next=%p, prev=%p, parent=%p, child=%p
ASN.1 uint mismatch at offset %d, %s
ASN.1 check_tag at offset %d, %s
ASN.1 string mismatch at offset %d, %s
ASN.1 int mismatch at offset %d, %s
expected a contents choice, error
***** index_typedef: expecting a tag or typeref, found %s *****
%s %s (%s)%s [%s] tag %c%d hf=%d tf=%d
****tbl_typeref: n>40, return [recursion too deep] ****************
**** unexpected type %s, want %s, at line %d
%*s+tbl_typeref %s [%s, tag %c%d]
%*s*change typeref tag from %c%d to %c%d
%*sNOT changing tag from %c%d to %c%d
%*sinclude typedef %d %s %s [%p:%s, tag %c%d]
regtype1: %3d %3d [%3d] F%2.2x (%s)%s %s %s -> id=%d
regtype2: %3d %3d [%3d] F%2.2x (%s)%s %s %s -> id=%d
regtype3: %3d %3d [%3d] F%2.2x (%s)%s %s %s -> id=%d
****tbl_type: n>40, return [recursion too deep] ****************
register: %3d %3d [%3d] F%2.2x (%s)%s %s %s -> id=%d
%*s*typeref %s > %s already at %p
**** unknown tbl-type %d at line %d
%*sinclude type %s %s [%p:%s, tag %c%d]
regist-2: %3d %3d [%3d] F%2.2x (%s)%s %s %s -> id=%d
build msg tree from '%s' for '%s'
******** Define main type %d, %s
Define the types that are actually referenced through the top level PDU
pdu %d %s defined twice, TopLevel & type
--off=%d named number list not initialized
--off=%d namednumber %d=%s from list %s
prefs change: tcpports=%s, udpports=%s, sctpports=%s, desegnment=%d, asn1file=%s, pduname=%s, first_offset=%d, debug=%d, msg_win=%d, verbose=%d
ASN.1 oid mismatch at offset %d, %s
OK, TBLTypeId's index verified%s
OK, %d TBLTypeDef's index set up
modules=%d, defs=%d, types=%d, tags=%d, strings=%d, lenstrings=%d
%s sp=%d,pos=%p,%s%s%s%s%s%s%s%s%s%s:%s,%d
| sp=%d,st=%p,%s%s%s%s%s%s%s%s%s%s:%s,%d
  return for constructed %s (%s)%s
>>off=%d stack underflow, return
>>off=%d stack underflow, return, no more messages
  *EOI %s:%s mismatch, EOIoffset=%d, stack=%d
  EOI extra pop, EOIoffset=%d, stack=%d
    seqof: first got %c%d, found %c%d
    seqof: child: got %c%d, found %c%d
    seqof: no repeat, force next
    reference change ref -> pop
    seqof: set repeat mark [push,child]
    seqof: end of repeat loop [next]
    immediate choice [no next]
    end of optional list, constructed, expect value next time
    already pushed, skip next push
    immediate choice [push], %c%d, %s
  return from immediate choice [%s] '%s'
  indirect typeref to %s:%s, %s [%c%d]
  typeref set named number list node %p
    dontshow and set constructed flag
  return [%s] '%s' vid=%d, tid=%d
dissect_asn1: tcp - seq=%u, delta=%d, reassembled=%d
first%s: (%s)%s %d %s, %s, %s, len=%s, off=%d, size=%d 
%s, %s, %s, len=%s, off=%d, remaining=%d
ReportedBoundsError: offset=%d len=%d can_desegment=%d
dissect_asn1 finished: desegment_offset=%d desegment_len=%d can_desegment=%d
The TCP ports on which ASN.1 messages will be read
The UDP ports on which ASN.1 messages will be read
The SCTP ports on which ASN.1 messages will be read
Desegment ASN.1 messages that span TCP segments
Compiled ASN.1 description of ASN.1 types
Offset for non-reassembled packets, wrong if this happens on other than the first packet!
Offset to first PDU in first tcp packet
Show full names for all values
Allow this recursion level for eliminated type references
Extra output useful for debugging
log to file $TMP/wireshark.log
UACPX
dissect_asn1
EOC mismatch
Wrong type for that item
Length was indefinite
Length mismatch
Unknown error (%d)
Wrong length for that item's type
;*2$" 
asn1
*noname*
off=%d: [%s %s %s] (%s)%s: %d%s
off=%d: [%s %s %s] (%s)%s: %d:%s%s
off=%d: [%s %s %s] (%s)%s: '%s'%s
off=%d: [%s %s %s] (%s)%s: %s:%s%s
off=%d: [%s %s %s] (%s)%s%s%s
*unnamed*
  **missing**  
asn1.so.debug
.data
.rodata
.shstrtab
.dynamic
.note.gnu.build-id
.eh_frame
.gnu.hash
.fini
.gnu_debuglink
.dynsym
.gnu.version
.rel.dyn
.data.rel.ro
.gnu.version_r
.jcr
.eh_frame_hdr
.dynstr
.bss
.init
.rel.plt
.got.plt
.got
.text
.fini_array
.init_array
