a2a 
RL	%
&Jh"
@	0C
!F"]
=H"zoW
m}7/L
	`)aUP
gp1)
7iFZ
zr4/
_^D~
__gmon_start__
_fini
_ITM_deregisterTMCloneTable
_ITM_registerTMCloneTable
__cxa_finalize
_Unwind_Resume
_ZN100_$LT$rustc_driver..pretty..NoAnn$LT$$u27$hir$GT$$u20$as$u20$rustc_driver..pretty..PrinterSupport$GT$4sess17hffacf9a7b320c920E
_ZN100_$LT$rustc_driver..pretty..NoAnn$LT$$u27$hir$GT$$u20$as$u20$rustc_driver..pretty..PrinterSupport$GT$6pp_ann17h120dcfeb17bee48cE
_ZN100_$LT$syntax_pos..MultiSpan$u20$as$u20$core..convert..From$LT$syntax_pos..span_encoding..Span$GT$$GT$4from17h76905094c20151ecE
_ZN101_$LT$rustc_incremental..persist..load..LoadResult$LT$rustc..dep_graph..prev..PreviousDepGraph$GT$$GT$4open17h2c8ab94ee9f0d120E
_ZN102_$LT$rustc_driver..pretty..HygieneAnnotation$LT$$u27$a$GT$$u20$as$u20$syntax..print..pprust..PpAnn$GT$4post17h50320cf690798075E
_ZN103_$LT$rustc_driver..pretty..IdentifiedAnnotation$LT$$u27$hir$GT$$u20$as$u20$rustc..hir..print..PpAnn$GT$3pre17h91f4ca35b3126579E
_ZN103_$LT$rustc_driver..pretty..IdentifiedAnnotation$LT$$u27$hir$GT$$u20$as$u20$rustc..hir..print..PpAnn$GT$4post17hd704bf6e18434ec9E
_ZN103_$LT$rustc_driver..pretty..IdentifiedAnnotation$LT$$u27$hir$GT$$u20$as$u20$rustc..hir..print..PpAnn$GT$6nested17h60d46c9f3c6c4ef2E
_ZN105_$LT$rustc_metadata..creader..CrateLoader$LT$$u27$a$GT$$u20$as$u20$rustc..middle..cstore..CrateLoader$GT$11postprocess17h059ee83f0e4b72d4E
_ZN105_$LT$rustc_metadata..creader..CrateLoader$LT$$u27$a$GT$$u20$as$u20$rustc..middle..cstore..CrateLoader$GT$12process_item17hc7e31a0f80208f44E
_ZN105_$LT$rustc_metadata..creader..CrateLoader$LT$$u27$a$GT$$u20$as$u20$rustc..middle..cstore..CrateLoader$GT$23resolve_crate_from_path17h6b1152b075f8edabE
_ZN106_$LT$rustc..hir..print..State$LT$$u27$a$GT$$u20$as$u20$syntax..print..pprust..PrintState$LT$$u27$a$GT$$GT$6writer17h8a7c7fbf61c8334dE
_ZN107_$LT$rustc_driver..pretty..IdentifiedAnnotation$LT$$u27$hir$GT$$u20$as$u20$syntax..print..pprust..PpAnn$GT$3pre17hb781434fddee9464E
_ZN107_$LT$rustc_driver..pretty..IdentifiedAnnotation$LT$$u27$hir$GT$$u20$as$u20$syntax..print..pprust..PpAnn$GT$4post17h5dc727a094e5e225E
_ZN107_$LT$rustc_errors..diagnostic_builder..DiagnosticBuilder$LT$$u27$a$GT$$u20$as$u20$core..ops..drop..Drop$GT$4drop17h974160d1ca19ba5fE
_ZN10env_logger4init17hd41fd66ea1dc6c97E
_ZN10rustc_back6target11get_targets17h62514d49f0df0087E
_ZN10rustc_lint17register_builtins17h7e449bfbceadbdc7E
_ZN10syntax_ext17register_builtins17h1ec861f0052d556bE
_ZN10syntax_ext20proc_macro_registrar6modify17h3eee7662bdb1e782E
_ZN10syntax_pos10SPAN_DEBUG7__getit17hbba977a952a31152E
_ZN10syntax_pos13span_encoding18with_span_interner8INTERNER7__getit17h0ed9c6b5853a2867E
_ZN10syntax_pos18default_span_debug17hdb82a5b7c627342aE
_ZN10syntax_pos6symbol6Symbol6as_str17h9af34139b9060525E
_ZN10syntax_pos6symbol6Symbol6as_u3217h6212fe2263b7e445E
_ZN10syntax_pos6symbol6Symbol6intern17h24dbc915fe2bc87bE
_ZN10syntax_pos7FileMap11is_imported17h911f1ff1833d87f6E
_ZN10syntax_pos7FileMap12is_real_file17h308aa0c4be25bc78E
_ZN10syntax_pos7hygiene11HygieneData3new17ha151f56a8a7e4394E
_ZN10syntax_pos7hygiene11HygieneData4with12HYGIENE_DATA7__getit17hf784531d450e911fE
_ZN10syntax_pos7hygiene14clear_markings17h67eab9119a88f8a7E
_ZN10syntax_pos83_$LT$impl$u20$core..cmp..PartialOrd$u20$for$u20$syntax_pos..span_encoding..Span$GT$11partial_cmp17h5a86ec17353a73f2E
_ZN10syntax_pos9MultiSpan3new17h7f55bf912bbd37f4E
_ZN110_$LT$core..any..Any$u20$$u2b$$u20$core..marker..Send$u20$$u2b$$u20$$u27$static$u20$as$u20$core..fmt..Debug$GT$3fmt17hec56bf91070b5549E
_ZN110_$LT$rustc_driver..pretty..HygieneAnnotation$LT$$u27$a$GT$$u20$as$u20$rustc_driver..pretty..PrinterSupport$GT$4sess17hf5cf43b92a90d60aE
_ZN110_$LT$rustc_driver..pretty..HygieneAnnotation$LT$$u27$a$GT$$u20$as$u20$rustc_driver..pretty..PrinterSupport$GT$6pp_ann17ha6160aa4ec63ad41E
_ZN110_$LT$syntax..print..pprust..State$LT$$u27$a$GT$$u20$as$u20$syntax..print..pprust..PrintState$LT$$u27$a$GT$$GT$6writer17ha3822daf610f4798E
_ZN110_$LT$syntax..tokenstream..TokenStream$u20$as$u20$core..convert..From$LT$syntax..tokenstream..TokenTree$GT$$GT$4from17h00beb9aaecc04593E
_ZN112_$LT$rustc_driver..pretty..TypedAnnotation$LT$$u27$a$C$$u20$$u27$tcx$GT$$u20$as$u20$rustc..hir..print..PpAnn$GT$3pre17h2fd9ff914b0e581bE
_ZN112_$LT$rustc_driver..pretty..TypedAnnotation$LT$$u27$a$C$$u20$$u27$tcx$GT$$u20$as$u20$rustc..hir..print..PpAnn$GT$4post17hd273123e9a135c72E
_ZN112_$LT$rustc_driver..pretty..TypedAnnotation$LT$$u27$a$C$$u20$$u27$tcx$GT$$u20$as$u20$rustc..hir..print..PpAnn$GT$6nested17h0b62cb3026eb670dE
_ZN113_$LT$rustc..ich..fingerprint..Fingerprint$u20$as$u20$rustc_data_structures..stable_hasher..StableHasherResult$GT$6finish17h2af59e692a133c7bE
_ZN115_$LT$rustc..session..CompileIncomplete$u20$as$u20$core..convert..From$LT$rustc..util..common..ErrorReported$GT$$GT$4from17he328ab4f0fb59ac8E
_ZN115_$LT$rustc_driver..derive_registrar..Finder$u20$as$u20$rustc..hir..itemlikevisit..ItemLikeVisitor$LT$$u27$v$GT$$GT$10visit_item17hc918aaa4a53d8261E
_ZN115_$LT$rustc_driver..derive_registrar..Finder$u20$as$u20$rustc..hir..itemlikevisit..ItemLikeVisitor$LT$$u27$v$GT$$GT$15visit_impl_item17hf5cbbb1400b38f0bE
_ZN115_$LT$rustc_driver..derive_registrar..Finder$u20$as$u20$rustc..hir..itemlikevisit..ItemLikeVisitor$LT$$u27$v$GT$$GT$16visit_trait_item17h96e6e68df90415f2E
_ZN115_$LT$rustc_driver..pretty..IdentifiedAnnotation$LT$$u27$hir$GT$$u20$as$u20$rustc_driver..pretty..PrinterSupport$GT$4sess17h60e8c9f5b80cb9d8E
_ZN115_$LT$rustc_driver..pretty..IdentifiedAnnotation$LT$$u27$hir$GT$$u20$as$u20$rustc_driver..pretty..PrinterSupport$GT$6pp_ann17h9edff8bd4acab96bE
_ZN116_$LT$rustc..cfg..graphviz..LabelledCFG$LT$$u27$a$C$$u20$$u27$hir$GT$$u20$as$u20$graphviz..Labeller$LT$$u27$a$GT$$GT$10edge_label17he524923d516b237eE
_ZN116_$LT$rustc..cfg..graphviz..LabelledCFG$LT$$u27$a$C$$u20$$u27$hir$GT$$u20$as$u20$graphviz..Labeller$LT$$u27$a$GT$$GT$10node_label17h941a9cc35b6a6babE
_ZN116_$LT$rustc..cfg..graphviz..LabelledCFG$LT$$u27$a$C$$u20$$u27$hir$GT$$u20$as$u20$graphviz..Labeller$LT$$u27$a$GT$$GT$7node_id17hc7eb25ffa76cc536E
_ZN116_$LT$rustc..cfg..graphviz..LabelledCFG$LT$$u27$a$C$$u20$$u27$hir$GT$$u20$as$u20$graphviz..Labeller$LT$$u27$a$GT$$GT$8graph_id17hf70055d30e5ef295E
_ZN116_$LT$rustc..ty..context..TyCtxt$LT$$u27$a$C$$u20$$u27$gcx$C$$u20$$u27$tcx$GT$$u20$as$u20$core..ops..deref..Deref$GT$5deref17h95ae36d1c0b3bec1E
_ZN116_$LT$syntax..tokenstream..ThinTokenStream$u20$as$u20$core..convert..From$LT$syntax..tokenstream..TokenStream$GT$$GT$4from17h56541d45cf0ccf1bE
_ZN116_$LT$syntax..tokenstream..TokenStream$u20$as$u20$core..convert..From$LT$syntax..tokenstream..ThinTokenStream$GT$$GT$4from17h3ef165c9635efa16E
_ZN117_$LT$rustc..cfg..graphviz..LabelledCFG$LT$$u27$a$C$$u20$$u27$hir$GT$$u20$as$u20$graphviz..GraphWalk$LT$$u27$a$GT$$GT$5edges17h4d941ad33f4a5a96E
_ZN117_$LT$rustc..cfg..graphviz..LabelledCFG$LT$$u27$a$C$$u20$$u27$hir$GT$$u20$as$u20$graphviz..GraphWalk$LT$$u27$a$GT$$GT$5nodes17hcd5c9dbbe56edd9bE
_ZN117_$LT$rustc..cfg..graphviz..LabelledCFG$LT$$u27$a$C$$u20$$u27$hir$GT$$u20$as$u20$graphviz..GraphWalk$LT$$u27$a$GT$$GT$6source17h2f1b9c0767d45df0E
_ZN117_$LT$rustc..cfg..graphviz..LabelledCFG$LT$$u27$a$C$$u20$$u27$hir$GT$$u20$as$u20$graphviz..GraphWalk$LT$$u27$a$GT$$GT$6target17h2b72fbb3a25f6e90E
_ZN117_$LT$rustc..hir..map..NodesMatchingSuffix$LT$$u27$a$C$$u20$$u27$hir$GT$$u20$as$u20$core..iter..iterator..Iterator$GT$4next17h460bb3a07f5bf216E
_ZN118_$LT$rustc..session..CrateDisambiguator$u20$as$u20$core..convert..From$LT$rustc..ich..fingerprint..Fingerprint$GT$$GT$4from17h0e21c6af31857369E
_ZN119_$LT$rustc_driver..pretty..NoAnn$LT$$u27$hir$GT$$u20$as$u20$rustc_driver..pretty..HirPrinterSupport$LT$$u27$hir$GT$$GT$4sess17h9c3f720a87b88bcfE
_ZN119_$LT$rustc_driver..pretty..NoAnn$LT$$u27$hir$GT$$u20$as$u20$rustc_driver..pretty..HirPrinterSupport$LT$$u27$hir$GT$$GT$6pp_ann17h3379f20583571c31E
_ZN119_$LT$rustc_driver..pretty..NoAnn$LT$$u27$hir$GT$$u20$as$u20$rustc_driver..pretty..HirPrinterSupport$LT$$u27$hir$GT$$GT$7hir_map17h8cedbd4eb5329c36E
_ZN119_$LT$rustc_driver..pretty..NodesMatchingUII$LT$$u27$a$C$$u20$$u27$hir$GT$$u20$as$u20$core..iter..iterator..Iterator$GT$4next17h8c0cea200e175be2E
_ZN11std_unicode6tables8property11White_Space17he0e8db3403b0b62aE
_ZN125_$LT$rustc_borrowck..graphviz..DataflowLabeller$LT$$u27$a$C$$u20$$u27$tcx$GT$$u20$as$u20$graphviz..Labeller$LT$$u27$a$GT$$GT$10edge_label17h378f51ed20c83415E
_ZN125_$LT$rustc_borrowck..graphviz..DataflowLabeller$LT$$u27$a$C$$u20$$u27$tcx$GT$$u20$as$u20$graphviz..Labeller$LT$$u27$a$GT$$GT$10node_label17h00e4cd293517c8e5E
_ZN125_$LT$rustc_borrowck..graphviz..DataflowLabeller$LT$$u27$a$C$$u20$$u27$tcx$GT$$u20$as$u20$graphviz..Labeller$LT$$u27$a$GT$$GT$7node_id17h52ac620b973484e8E
_ZN125_$LT$rustc_borrowck..graphviz..DataflowLabeller$LT$$u27$a$C$$u20$$u27$tcx$GT$$u20$as$u20$graphviz..Labeller$LT$$u27$a$GT$$GT$8graph_id17h22cc45ca0e9122f1E
_ZN126_$LT$rustc_borrowck..graphviz..DataflowLabeller$LT$$u27$a$C$$u20$$u27$tcx$GT$$u20$as$u20$graphviz..GraphWalk$LT$$u27$a$GT$$GT$5edges17hc681f61880f96067E
_ZN126_$LT$rustc_borrowck..graphviz..DataflowLabeller$LT$$u27$a$C$$u20$$u27$tcx$GT$$u20$as$u20$graphviz..GraphWalk$LT$$u27$a$GT$$GT$5nodes17h9a17703e744266c5E
_ZN126_$LT$rustc_borrowck..graphviz..DataflowLabeller$LT$$u27$a$C$$u20$$u27$tcx$GT$$u20$as$u20$graphviz..GraphWalk$LT$$u27$a$GT$$GT$6source17h83c10f974dcb2f5dE
_ZN126_$LT$rustc_borrowck..graphviz..DataflowLabeller$LT$$u27$a$C$$u20$$u27$tcx$GT$$u20$as$u20$graphviz..GraphWalk$LT$$u27$a$GT$$GT$6target17h6aa0ab0677315d8bE
_ZN12rustc_driver12run_compiler17h7af74434b788ff60E
_ZN12rustc_driver14describe_lints17h4e8eabc4c5ccd379E
_ZN12rustc_driver14handle_options17h5a0a0d48f402746bE
_ZN12rustc_driver15target_features17add_configuration17hbad4856814a11f1bE
_ZN12rustc_driver16derive_registrar4find17h2ed4100b1fb38de1E
_ZN12rustc_driver17RustcDefaultCalls13list_metadata17h18f55e12fbbb0f9bE
_ZN12rustc_driver20diagnostics_registry17h3142330ff73101d8E
_ZN12rustc_driver20enable_save_analysis17h1ed8c6a8a55bb292E
_ZN12rustc_driver4main17hdfe2be70253d3554E
_ZN12rustc_driver6driver11count_nodes17h3de4dd5f7dcae7edE
_ZN12rustc_driver6driver11source_name17h692672b91a20bf98E
_ZN12rustc_driver6driver13compile_input17h0403f6bcee6806c8E
_ZN12rustc_driver6driver15PhaseController5basic17hb3f321d855c155feE
_ZN12rustc_driver6driver15default_provide17h7227ca935c496f95E
_ZN12rustc_driver6driver17CompileController5basic17h1f86e334ac72a14eE
_ZN12rustc_driver6driver19collect_crate_types17hbb2e84a796bbc44bE
_ZN12rustc_driver6driver19phase_1_parse_input17h718f33b9df899959E
_ZN12rustc_driver6driver20output_contains_path17hc042aa7f4055ce11E
_ZN12rustc_driver6driver22build_output_filenames17h427b81ee49fec9cfE
_ZN12rustc_driver6driver22default_provide_extern17hea93400b33b66a5bE
_ZN12rustc_driver6driver25output_conflicts_with_dir17hee0cdc4438b19eb4E
_ZN12rustc_driver6driver25phase_4_translate_to_llvm17h34c89b393f54a0ecE
_ZN12rustc_driver6driver27compute_crate_disambiguator17h7a988fd748e759e0E
_ZN12rustc_driver6pretty10fold_crate17heaa04c60ae3a8e42E
_ZN12rustc_driver6pretty12parse_pretty17hdcba2811d70af2bcE
_ZN12rustc_driver6pretty19ReplaceBodyWithLoop3new17h34e6bbdeeec2c508E
_ZN12rustc_driver6pretty19print_after_parsing17h29ace635bae88137E
_ZN12rustc_driver6pretty24print_after_hir_lowering17h034f0d7e6931cbaaE
_ZN12rustc_driver6pretty6PpMode13needs_ast_map17he94295345946a2f3E
_ZN12rustc_driver6pretty6PpMode14needs_analysis17hd5962236a6332608E
_ZN12rustc_driver7profile4dump17h8cb5f2fec2e2d759E
_ZN12rustc_driver7profile5begin17ha521523519ce196cE
_ZN12rustc_driver7profile5trace11cons_of_key17hb232240ba877c358E
_ZN12rustc_driver7profile5trace11write_style17hb4b875b12f221b02E
_ZN12rustc_driver7profile5trace12write_counts17hbd8111a1e94b9798E
_ZN12rustc_driver7profile5trace12write_traces17h0d3b480619470a8cE
_ZN12rustc_driver7profile5trace14html_of_effect17h8922568d2b4aefd4E
_ZN12rustc_driver7profile5trace17cons_of_query_msg17h67d29f720c4338ceE
_ZN12rustc_driver7version17h8d139f99d062f1a6E
_ZN12rustc_driver9get_trans17h0e825f268e42f218E
_ZN12rustc_errors10FatalError5raise17h529244179987b808E
_ZN12rustc_errors18diagnostic_builder17DiagnosticBuilder3new17h9edb77441bc416deE
_ZN12rustc_errors18diagnostic_builder17DiagnosticBuilder4emit17h0f37381d961eb4b0E
_ZN12rustc_errors18diagnostic_builder17DiagnosticBuilder4note17hcec2fa18ff7ee7d8E
_ZN12rustc_errors7Handler12with_emitter17h9dd3a8c86b31496bE
_ZN12rustc_errors7Handler15abort_if_errors17hd0e60fa5ce43ba43E
_ZN12rustc_errors7Handler24set_continue_after_error17h34b730ca4e15a179E
_ZN12rustc_errors7Handler4emit17h5b783f256e1cb890E
_ZN12rustc_errors7Handler9err_count17h2fc1769ec3c63286E
_ZN12rustc_errors7emitter13EmitterWriter6stderr17h4fa2d005d43968dbE
_ZN12rustc_errors8registry8Registry16find_description17h6317f6584a542cabE
_ZN12rustc_errors8registry8Registry3new17hcedccf6c554f009eE
_ZN12rustc_passes14ast_validation11check_crate17h3c193fdeb9729421E
_ZN12rustc_passes16static_recursion11check_crate17h395b780bf172dde0E
_ZN12rustc_passes5loops11check_crate17hb4d0d2a1108814dfE
_ZN12rustc_passes6consts11check_crate17had5416c3922b2ab1E
_ZN12rustc_passes7provide17h827521efa22a1e0dE
_ZN12rustc_passes9hir_stats15print_ast_stats17hde9236e312c1473fE
_ZN12rustc_passes9hir_stats15print_hir_stats17h9e4e2b4f6f2292a9E
_ZN12rustc_plugin4load12load_plugins17h9f7ad035c5c1833fE
_ZN12rustc_plugin5build21find_plugin_registrar17hab26020358a1c0e2E
_ZN12rustc_plugin8registry8Registry14register_macro17hbba1da4b004279adE
_ZN12rustc_plugin8registry8Registry31take_whitelisted_custom_derives17h01886f763305b86dE
_ZN12rustc_plugin8registry8Registry3new17h2788c946bee0d282E
_ZN12rustc_typeck11check_crate17h7a7d841626d51fbfE
_ZN12rustc_typeck7provide17hbfcf95dd5e8a37d5E
_ZN134_$LT$rustc_driver..pretty..IdentifiedAnnotation$LT$$u27$hir$GT$$u20$as$u20$rustc_driver..pretty..HirPrinterSupport$LT$$u27$hir$GT$$GT$4sess17h9573b7c34fde5421E
_ZN134_$LT$rustc_driver..pretty..IdentifiedAnnotation$LT$$u27$hir$GT$$u20$as$u20$rustc_driver..pretty..HirPrinterSupport$LT$$u27$hir$GT$$GT$6pp_ann17h028b8d385ab588a3E
_ZN134_$LT$rustc_driver..pretty..IdentifiedAnnotation$LT$$u27$hir$GT$$u20$as$u20$rustc_driver..pretty..HirPrinterSupport$LT$$u27$hir$GT$$GT$7hir_map17h1ffc9462898495baE
_ZN13rustc_privacy11check_crate17h22e1b32955d94890E
_ZN13rustc_privacy7provide17h59709602f674b067E
_ZN13rustc_resolve6macros95_$LT$impl$u20$syntax..ext..base..Resolver$u20$for$u20$rustc_resolve..Resolver$LT$$u27$a$GT$$GT$11add_builtin17h21bacc0ac07aec3aE
_ZN13rustc_resolve6macros95_$LT$impl$u20$syntax..ext..base..Resolver$u20$for$u20$rustc_resolve..Resolver$LT$$u27$a$GT$$GT$12next_node_id17h5bf90d8e69126d33E
_ZN13rustc_resolve6macros95_$LT$impl$u20$syntax..ext..base..Resolver$u20$for$u20$rustc_resolve..Resolver$LT$$u27$a$GT$$GT$13resolve_invoc17h9538b4d4b58fd540E
_ZN13rustc_resolve6macros95_$LT$impl$u20$syntax..ext..base..Resolver$u20$for$u20$rustc_resolve..Resolver$LT$$u27$a$GT$$GT$13resolve_macro17h6a8b3ff22bcdbc4cE
_ZN13rustc_resolve6macros95_$LT$impl$u20$syntax..ext..base..Resolver$u20$for$u20$rustc_resolve..Resolver$LT$$u27$a$GT$$GT$15resolve_imports17hb2cba5c8ea97420eE
_ZN13rustc_resolve6macros95_$LT$impl$u20$syntax..ext..base..Resolver$u20$for$u20$rustc_resolve..Resolver$LT$$u27$a$GT$$GT$15visit_expansion17hb5f33ef5316cc4b8E
_ZN13rustc_resolve6macros95_$LT$impl$u20$syntax..ext..base..Resolver$u20$for$u20$rustc_resolve..Resolver$LT$$u27$a$GT$$GT$16get_module_scope17he91f283632669ebaE
_ZN13rustc_resolve6macros95_$LT$impl$u20$syntax..ext..base..Resolver$u20$for$u20$rustc_resolve..Resolver$LT$$u27$a$GT$$GT$19check_unused_macros17h12bba2ec9b0c2e53E
_ZN13rustc_resolve6macros95_$LT$impl$u20$syntax..ext..base..Resolver$u20$for$u20$rustc_resolve..Resolver$LT$$u27$a$GT$$GT$19eliminate_crate_var17hcb4ba94adfe1bce7E
_ZN13rustc_resolve6macros95_$LT$impl$u20$syntax..ext..base..Resolver$u20$for$u20$rustc_resolve..Resolver$LT$$u27$a$GT$$GT$22find_legacy_attr_invoc17h8eb4752a365265e3E
_ZN13rustc_resolve6macros95_$LT$impl$u20$syntax..ext..base..Resolver$u20$for$u20$rustc_resolve..Resolver$LT$$u27$a$GT$$GT$35is_whitelisted_legacy_custom_derive17h3b6ca1ab8e9fdb3dE
_ZN13rustc_resolve8Resolver13resolve_crate17h40e45ed9f2c9461dE
_ZN13rustc_resolve8Resolver3new17hfc091027b5b9e605E
_ZN13rustc_resolve8Resolver6arenas17h459b12905833e858E
_ZN143_$LT$rustc_driver..pretty..TypedAnnotation$LT$$u27$b$C$$u20$$u27$tcx$GT$$u20$as$u20$rustc_driver..pretty..HirPrinterSupport$LT$$u27$tcx$GT$$GT$4sess17hd8cb0babb89c9b7aE
_ZN143_$LT$rustc_driver..pretty..TypedAnnotation$LT$$u27$b$C$$u20$$u27$tcx$GT$$u20$as$u20$rustc_driver..pretty..HirPrinterSupport$LT$$u27$tcx$GT$$GT$6pp_ann17hbd881aff6c22a42aE
_ZN143_$LT$rustc_driver..pretty..TypedAnnotation$LT$$u27$b$C$$u20$$u27$tcx$GT$$u20$as$u20$rustc_driver..pretty..HirPrinterSupport$LT$$u27$tcx$GT$$GT$7hir_map17h2e6f0298109a7d4bE
_ZN143_$LT$rustc_driver..pretty..TypedAnnotation$LT$$u27$b$C$$u20$$u27$tcx$GT$$u20$as$u20$rustc_driver..pretty..HirPrinterSupport$LT$$u27$tcx$GT$$GT$9node_path17hf1826de18d5b95e9E
_ZN14rustc_borrowck8borrowck11check_crate17hffe51e07ac9f39ccE
_ZN14rustc_borrowck8borrowck35build_borrowck_dataflow_data_for_fn17h9fa26a8352283df9E
_ZN14rustc_borrowck8borrowck7provide17h5957dac70b23d98aE
_ZN14rustc_metadata11cstore_impl14provide_extern17hfbaf69888bf65d4dE
_ZN14rustc_metadata11cstore_impl7provide17hf107c77cad9b9ccdE
_ZN14rustc_metadata11cstore_impl94_$LT$impl$u20$rustc..middle..cstore..CrateStore$u20$for$u20$rustc_metadata..cstore..CStore$GT$13def_path_hash17hc7142ae31c957ea8E
_ZN14rustc_metadata11cstore_impl94_$LT$impl$u20$rustc..middle..cstore..CrateStore$u20$for$u20$rustc_metadata..cstore..CStore$GT$14def_path_table17h2ccaba9631ce2f7cE
_ZN14rustc_metadata11cstore_impl94_$LT$impl$u20$rustc..middle..cstore..CrateStore$u20$for$u20$rustc_metadata..cstore..CStore$GT$15encode_metadata17h5e55ffaba33013d1E
_ZN14rustc_metadata11cstore_impl94_$LT$impl$u20$rustc..middle..cstore..CrateStore$u20$for$u20$rustc_metadata..cstore..CStore$GT$15metadata_loader17h30210e91fd2a484cE
_ZN14rustc_metadata11cstore_impl94_$LT$impl$u20$rustc..middle..cstore..CrateStore$u20$for$u20$rustc_metadata..cstore..CStore$GT$16crates_untracked17h9cde65c26aef63b5E
_ZN14rustc_metadata11cstore_impl94_$LT$impl$u20$rustc..middle..cstore..CrateStore$u20$for$u20$rustc_metadata..cstore..CStore$GT$18dep_kind_untracked17h292bb828c17e85e3E
_ZN14rustc_metadata11cstore_impl94_$LT$impl$u20$rustc..middle..cstore..CrateStore$u20$for$u20$rustc_metadata..cstore..CStore$GT$20crate_data_as_rc_any17hbff3d9b28c54859cE
_ZN14rustc_metadata11cstore_impl94_$LT$impl$u20$rustc..middle..cstore..CrateStore$u20$for$u20$rustc_metadata..cstore..CStore$GT$20crate_hash_untracked17h4062e2a62152ac2eE
_ZN14rustc_metadata11cstore_impl94_$LT$impl$u20$rustc..middle..cstore..CrateStore$u20$for$u20$rustc_metadata..cstore..CStore$GT$20crate_name_untracked17hdc7da7fff7a48a3eE
_ZN14rustc_metadata11cstore_impl94_$LT$impl$u20$rustc..middle..cstore..CrateStore$u20$for$u20$rustc_metadata..cstore..CStore$GT$20load_macro_untracked17hb300578926befe42E
_ZN14rustc_metadata11cstore_impl94_$LT$impl$u20$rustc..middle..cstore..CrateStore$u20$for$u20$rustc_metadata..cstore..CStore$GT$20visibility_untracked17h97549eec143d6be7E
_ZN14rustc_metadata11cstore_impl94_$LT$impl$u20$rustc..middle..cstore..CrateStore$u20$for$u20$rustc_metadata..cstore..CStore$GT$23export_macros_untracked17h8cb4faf47a1baa6eE
_ZN14rustc_metadata11cstore_impl94_$LT$impl$u20$rustc..middle..cstore..CrateStore$u20$for$u20$rustc_metadata..cstore..CStore$GT$23item_children_untracked17h32df64d684e0b619E
_ZN14rustc_metadata11cstore_impl94_$LT$impl$u20$rustc..middle..cstore..CrateStore$u20$for$u20$rustc_metadata..cstore..CStore$GT$25metadata_encoding_version17hea7aa1523c05b5a8E
_ZN14rustc_metadata11cstore_impl94_$LT$impl$u20$rustc..middle..cstore..CrateStore$u20$for$u20$rustc_metadata..cstore..CStore$GT$25postorder_cnums_untracked17h92f4b2d91916b3dfE
_ZN14rustc_metadata11cstore_impl94_$LT$impl$u20$rustc..middle..cstore..CrateStore$u20$for$u20$rustc_metadata..cstore..CStore$GT$28struct_field_names_untracked17h4f2d91f9dd3e9b77E
_ZN14rustc_metadata11cstore_impl94_$LT$impl$u20$rustc..middle..cstore..CrateStore$u20$for$u20$rustc_metadata..cstore..CStore$GT$29crate_disambiguator_untracked17h665612606c2b14baE
_ZN14rustc_metadata11cstore_impl94_$LT$impl$u20$rustc..middle..cstore..CrateStore$u20$for$u20$rustc_metadata..cstore..CStore$GT$30extern_mod_stmt_cnum_untracked17h08746b7164f8a8aaE
_ZN14rustc_metadata11cstore_impl94_$LT$impl$u20$rustc..middle..cstore..CrateStore$u20$for$u20$rustc_metadata..cstore..CStore$GT$30item_generics_cloned_untracked17h11bd8b055758083bE
_ZN14rustc_metadata11cstore_impl94_$LT$impl$u20$rustc..middle..cstore..CrateStore$u20$for$u20$rustc_metadata..cstore..CStore$GT$32associated_item_cloned_untracked17h776d58ad27d62501E
_ZN14rustc_metadata11cstore_impl94_$LT$impl$u20$rustc..middle..cstore..CrateStore$u20$for$u20$rustc_metadata..cstore..CStore$GT$7def_key17h6770c71990ba4c84E
_ZN14rustc_metadata11cstore_impl94_$LT$impl$u20$rustc..middle..cstore..CrateStore$u20$for$u20$rustc_metadata..cstore..CStore$GT$8def_path17h36849969540151daE
_ZN14rustc_metadata11dynamic_lib14DynamicLibrary15open_global_now17hb50f3aea200b8e0dE
_ZN14rustc_metadata11dynamic_lib2dl6symbol17h9ba01edcf8beffd7E
_ZN14rustc_metadata6cstore6CStore3new17hbc24dc8f70afacc4E
_ZN14rustc_metadata7creader11CrateLoader3new17h9b18d7917e474877E
_ZN14rustc_metadata7locator18list_file_metadata17h67c61da37aa09837E
_ZN15rustc_allocator6expand6modify17h54e2c6b4a5299b98E
_ZN16rustc_const_eval11check_match11check_crate17h18148de99b6d7f93E
_ZN16rustc_const_eval7provide17ha7f7a4790ef79644E
_ZN16rustc_const_math3err12ConstMathErr11description17h2e428ade4b4bdcf4E
_ZN17rustc_incremental7persist2fs25prepare_session_directory17h5e5bfde739686113E
_ZN17rustc_incremental7persist2fs35garbage_collect_session_directories17h90fe34a10aa03537E
_ZN17rustc_incremental7persist4load14load_dep_graph17h790a1f0b76b6f00eE
_ZN17rustc_incremental7persist4load18dep_graph_tcx_init17h40bb516cb7791168E
_ZN17rustc_incremental7persist4load23load_query_result_cache17hcc6a77f091d62cd0E
_ZN17rustc_trans_utils11trans_crate22MetadataOnlyTransCrate3new17hed25c0c09609b51bE
_ZN17rustc_trans_utils4link15find_crate_name17h5584bdcb0645c906E
_ZN17rustc_trans_utils4link18filename_for_input17h4877a88b05edc394E
_ZN17rustc_trans_utils4link25default_output_for_target17h3278bfe26c93f7ddE
_ZN17rustc_trans_utils4link25invalid_output_for_target17h96a7b32744822cebE
_ZN19rustc_save_analysis10span_utils9SpanUtils3new17h43855dd6d8c68a6eE
_ZN19rustc_save_analysis11DumpHandler3new17hb43c7a2c9cfefbd5E
_ZN19rustc_save_analysis11find_config17h4cc5ed770bc80982E
_ZN3log20MAX_LOG_LEVEL_FILTER17h0abd80cf9756da6dE
_ZN3log6logger17hfdad19f6b6d7a38bE
_ZN3std10sys_common11thread_info3set17h96498f9bea449b10E
_ZN3std10sys_common6thread9min_stack17h0dfba7d470e3bf5dE
_ZN3std11collections4hash3map11RandomState3new4KEYS7__getit17hf53822f89a5950efE
_ZN3std11collections4hash3map19DefaultResizePolicy3new17he8a17fe0a9defd40E
_ZN3std11collections4hash5table20calculate_allocation17h33d262dab06c40d0E
_ZN3std2fs10DirBuilder3new17h45cf9368bf60de6eE
_ZN3std2fs10DirBuilder7_create17hc6fc8ada776742b4E
_ZN3std2fs10DirBuilder9recursive17h753a659600ce0181E
_ZN3std2fs11OpenOptions3new17h995cc941b394182dE
_ZN3std2fs11OpenOptions5_open17h127e468e7794076bE
_ZN3std2fs11OpenOptions5write17h0ef9908b712e3be8E
_ZN3std2fs11OpenOptions6create17h5041f5738ec0a820E
_ZN3std2fs11OpenOptions8truncate17hf495c46ce63198d8E
_ZN3std2fs8DirEntry4path17hf8c62e19302cf5c1E
_ZN3std2io5error5Error4_new17hd17ef21d1239b117E
_ZN3std2io5error5Error4kind17hb8ffe784261825d3E
_ZN3std2io5stdio5stdin17h011a2873770aa9deE
_ZN3std2io5stdio6_print17hf1de60c3d7597260E
_ZN3std2io5stdio7_eprint17hd9e288f05ac60a83E
_ZN3std3env7_var_os17h80bf75c343ee3b94E
_ZN3std3env7args_os17hbda2d923970e77feE
_ZN3std3ffi5c_str4CStr8from_ptr17hac1a6c9be69f41cbE
_ZN3std3ffi5c_str7CString4_new17hec93ba5ce62bf10bE
_ZN3std3ffi6os_str103_$LT$impl$u20$core..convert..AsRef$LT$std..ffi..os_str..OsStr$GT$$u20$for$u20$alloc..string..String$GT$6as_ref17he539808b03349fa1E
_ZN3std3ffi6os_str5OsStr12to_os_string17h9f3068ae01ffc766E
_ZN3std3ffi6os_str5OsStr15to_string_lossy17h20ee6ba27b8b859dE
_ZN3std3ffi6os_str5OsStr6to_str17h116663707aa95192E
_ZN3std3ffi6os_str85_$LT$impl$u20$core..convert..AsRef$LT$std..ffi..os_str..OsStr$GT$$u20$for$u20$str$GT$6as_ref17hbfc5bedf2839dadcE
_ZN3std3ffi6os_str8OsString11into_string17h3a01da38e3e7bc2aE
_ZN3std3ffi6os_str8OsString3new17heb9c3356d48373acE
_ZN3std3sys4unix4rand19hashmap_random_keys17h615f3120fb8ef185E
_ZN3std3sys4unix6thread5guard7current17h5d2f96babf623e37E
_ZN3std3sys4unix6thread6Thread3new17h5773fd958736e986E
_ZN3std3sys4unix6thread6Thread4join17h96f103a56eec3426E
_ZN3std3sys4unix6thread6Thread8set_name17h21b01bc1c6b6d6f6E
_ZN3std3sys4unix7process14process_common7Command3new17h418885e8e55df122E
_ZN3std3sys4unix7process14process_common7Command5stdin17h307369e164f11193E
_ZN3std4path4Path10_ends_with17h25ea814279c84077E
_ZN3std4path4Path11to_path_buf17hd30d02d2a55b64a3E
_ZN3std4path4Path12canonicalize17ha02617ec4cea86c1E
_ZN3std4path4Path15_with_file_name17h905d0a9cf90d5605E
_ZN3std4path4Path5_join17h5a38b438cb116458E
_ZN3std4path4Path6exists17h687b6964892a0b24E
_ZN3std4path4Path6is_dir17hbb457362bf997d32E
_ZN3std4path4Path6parent17hf8a118d20d903b72E
_ZN3std4path4Path7display17ha24fe75f3d0f7e84E
_ZN3std4path4Path8read_dir17h300369b928028040E
_ZN3std4path4Path9file_name17h361da16993b6069dE
_ZN3std4path4Path9file_stem17h77de44322f38a2fcE
_ZN3std4path77_$LT$impl$u20$core..convert..AsRef$LT$std..path..Path$GT$$u20$for$u20$str$GT$6as_ref17h5fc61fb8de88511eE
_ZN3std4path7PathBuf3new17h048344ef2f5bc23bE
_ZN3std4path95_$LT$impl$u20$core..convert..AsRef$LT$std..path..Path$GT$$u20$for$u20$alloc..string..String$GT$6as_ref17ha1a7588c1fd5c9d4E
_ZN3std4sync4mpsc4sync5Queue7dequeue17h6a5c05463b971125E
_ZN3std4sync4mpsc8blocking11SignalToken6signal17h3c696cf8ca00828bE
_ZN3std4sync4mpsc8blocking6tokens17hca13340c82870351E
_ZN3std4sync4mpsc8blocking9WaitToken4wait17h2daa910078ef64baE
_ZN3std4sync4once4Once10call_inner17h85e59158d1d63806E
_ZN3std4time7Instant3now17h5608b3a48a22fa46E
_ZN3std4time7Instant7elapsed17hfc589b2a53d9bff7E
_ZN3std5error205_$LT$impl$u20$core..convert..From$LT$$RF$$u27$b$u20$str$GT$$u20$for$u20$alloc..boxed..Box$LT$std..error..Error$u20$$u2b$$u20$core..marker..Sync$u20$$u2b$$u20$core..marker..Send$u20$$u2b$$u20$$u27$a$GT$$GT$4from17ha2c35d20379aff31E
_ZN3std5error213_$LT$impl$u20$core..convert..From$LT$alloc..string..String$GT$$u20$for$u20$alloc..boxed..Box$LT$std..error..Error$u20$$u2b$$u20$core..marker..Sync$u20$$u2b$$u20$core..marker..Send$u20$$u2b$$u20$$u27$static$GT$$GT$4from17h87d71761f0e9665bE
_ZN3std5panic13resume_unwind17h8701688c21d27f07E
_ZN3std6thread6Thread3new17hb560a1c1c27a5569E
_ZN3std6thread6Thread5cname17h260beb7aa63ba52cE
_ZN3std6thread7Builder10stack_size17h9ea81a6809fcb06bE
_ZN3std6thread7Builder3new17h5e9d2a57c80ae329E
_ZN3std6thread7Builder4name17hbaefa8541ebf9de5E
_ZN3std6thread9yield_now17h2a099ba1f0817986E
_ZN3std7process4exit17hf51d17e61857111fE
_ZN3std7process5Child4wait17h41a971899b7ba78eE
_ZN3std7process5Stdio5piped17h601577b0c5591f50E
_ZN3std7process7Command5spawn17h1c0bdca0c296b3ccE
_ZN3std9panicking15begin_panic_fmt17h3e1b2c309f719757E
_ZN3std9panicking18update_panic_count17ha40771f841f0df43E
_ZN3std9panicking20rust_panic_with_hook17he8346e7912797ff1E
_ZN3std9panicking9panicking17had455ff49befa258E
_ZN40_$LT$str$u20$as$u20$core..fmt..Debug$GT$3fmt17hed9c0cfeaad9424eE
_ZN42_$LT$str$u20$as$u20$core..fmt..Display$GT$3fmt17h183137abcc8e6526E
_ZN48_$LT$std..fs..File$u20$as$u20$std..io..Write$GT$5write17h8457c7516f919ca8E
_ZN4core3fmt10ArgumentV110from_usize17h911c25a71906fdd3E
_ZN4core3fmt3num52_$LT$impl$u20$core..fmt..Display$u20$for$u20$u32$GT$3fmt17he48bf2e2d155ab9dE
_ZN4core3fmt3num52_$LT$impl$u20$core..fmt..Display$u20$for$u20$u64$GT$3fmt17hac0c3e7637534564E
_ZN4core3fmt3num54_$LT$impl$u20$core..fmt..Display$u20$for$u20$isize$GT$3fmt17h39805abb45b2f66fE
_ZN4core3fmt3num54_$LT$impl$u20$core..fmt..Display$u20$for$u20$usize$GT$3fmt17hc45208aa86580358E
_ZN4core3fmt5float52_$LT$impl$u20$core..fmt..Display$u20$for$u20$f64$GT$3fmt17h75ab941167829f22E
_ZN4core3fmt5write17h545f67085ed8f8e3E
_ZN4core3fmt8builders10DebugTuple5field17h9366f37fe0567776E
_ZN4core3fmt8builders10DebugTuple6finish17h318076b2fab1b933E
_ZN4core3fmt8builders11DebugStruct5field17h88c88420a011e722E
_ZN4core3fmt8builders11DebugStruct6finish17h16c59b894f38911bE
_ZN4core3fmt8builders9DebugList5entry17h3a31081703315339E
_ZN4core3fmt8builders9DebugList6finish17h90b77713eb658341E
_ZN4core3fmt9Formatter10debug_list17h7c82302660826250E
_ZN4core3fmt9Formatter11debug_tuple17h120f93d3346e120dE
_ZN4core3fmt9Formatter12debug_struct17h9855754755870a25E
_ZN4core3num23_$LT$impl$u20$usize$GT$25checked_next_power_of_two17h4492384cb3d1a93bE
_ZN4core3num54_$LT$impl$u20$core..str..FromStr$u20$for$u20$usize$GT$8from_str17h2f09cf9519ac2f76E
_ZN4core3str16slice_error_fail17he886eef982d1876fE
_ZN4core3str7pattern11StrSearcher3new17hf46c5b09d23d7259E
_ZN4core3str9from_utf817h05a382d24cfdbfbaE
_ZN4core5slice20slice_index_len_fail17h1215ade5b906fe4dE
_ZN4core5slice22slice_index_order_fail17h0a9663b05cdd1202E
_ZN4core5slice6memchr6memchr17hf9631ec60dccc593E
_ZN4core6option13expect_failed17h14c74d4195be4d87E
_ZN4core9panicking18panic_bounds_check17h830e2df90c2a6008E
_ZN4core9panicking5panic17hce08f5d7586283e5E
_ZN4core9panicking9panic_fmt17hab703c003f911be6E
_ZN52_$LT$getopts..Fail$u20$as$u20$core..fmt..Display$GT$3fmt17h662f9b3e66144a68E
_ZN52_$LT$std..path..Path$u20$as$u20$core..fmt..Debug$GT$3fmt17h4173aeea3f98f284E
_ZN53_$LT$core..fmt..Error$u20$as$u20$core..fmt..Debug$GT$3fmt17hb50e2fe31962cbfbE
_ZN54_$LT$rustc..hir..Crate$u20$as$u20$core..fmt..Debug$GT$3fmt17h881ddf83187912cbE
_ZN55_$LT$std..io..stdio..Stdin$u20$as$u20$std..io..Read$GT$14read_to_string17h55dbceffe7f6c337E
_ZN56_$LT$log..SetLoggerError$u20$as$u20$core..fmt..Debug$GT$3fmt17hf8d5f22f4b0f5d0fE
_ZN56_$LT$syntax..ast..NodeId$u20$as$u20$core..fmt..Debug$GT$3fmt17h14409d86fce6427dE
_ZN57_$LT$syntax_pos..SpanData$u20$as$u20$core..fmt..Debug$GT$3fmt17hc0e0548a8270c698E
_ZN58_$LT$std..io..error..Error$u20$as$u20$core..fmt..Debug$GT$3fmt17h5d967462ab7bc7cdE
_ZN58_$LT$std..path..Path$u20$as$u20$alloc..borrow..ToOwned$GT$8to_owned17h23052fbd87199ea6E
_ZN58_$LT$syntax..ast..NodeId$u20$as$u20$core..fmt..Display$GT$3fmt17hd1888f8bc5104df5E
_ZN59_$LT$std..path..PathBuf$u20$as$u20$core..cmp..PartialEq$GT$2eq17hbec699739862c013E
_ZN59_$LT$std..process..ChildStdin$u20$as$u20$std..io..Write$GT$5write17he110d1a42c56bc16E
_ZN59_$LT$syntax_pos..FileName$u20$as$u20$core..fmt..Display$GT$3fmt17h27182117c1ba27b8E
_ZN5alloc3fmt6format17h65809e4a81fcc1beE
_ZN5alloc3str21_$LT$impl$u20$str$GT$12to_lowercase17h914d617a49e7622dE
_ZN5alloc3str56_$LT$impl$u20$alloc..borrow..ToOwned$u20$for$u20$str$GT$8to_owned17he7d8404923c8a84fE
_ZN5rustc2ty4maps4Maps3new17h8da843ab99544a25E
_ZN5rustc2ty4maps90_$LT$impl$u20$rustc..ty..context..TyCtxt$LT$$u27$a$C$$u20$$u27$tcx$C$$u20$$u27$lcx$GT$$GT$12mir_borrowck17hd73ce963e93db77aE
_ZN5rustc2ty4maps90_$LT$impl$u20$rustc..ty..context..TyCtxt$LT$$u27$a$C$$u20$$u27$tcx$C$$u20$$u27$lcx$GT$$GT$13optimized_mir17h986631b2538fc596E
_ZN5rustc2ty6layout16TargetDataLayout5parse17hd9e85b5a790a630fE
_ZN5rustc2ty7context11CommonTypes3new17h566f27adda82a47fE
_ZN5rustc2ty7context12TypeckTables5empty17h3da5b03cd8a73287E
_ZN5rustc2ty7context12TypeckTables7expr_ty17h3e47420a02f5f298E
_ZN5rustc2ty7context13CtxtInterners3new17h98f2c5ceca2d42e8E
_ZN5rustc2ty7context3tls10span_debug17ha056f4c85d3f45abE
_ZN5rustc2ty7context3tls7TLS_TCX7__getit17hbea95051fb32c413E
_ZN5rustc2ty7context6TyCtxt17print_debug_stats17hb0e6fa059c428942E
_ZN5rustc2ty7context9AllArenas3new17h3084b6f179b98ca9E
_ZN5rustc2ty7provide17h1e27fef22220b9beE
_ZN5rustc2ty90_$LT$impl$u20$rustc..ty..context..TyCtxt$LT$$u27$a$C$$u20$$u27$gcx$C$$u20$$u27$tcx$GT$$GT$11body_owners17hc07bcdaf99a0f443E
_ZN5rustc2ty90_$LT$impl$u20$rustc..ty..context..TyCtxt$LT$$u27$a$C$$u20$$u27$gcx$C$$u20$$u27$tcx$GT$$GT$11body_tables17hf416f586341845aeE
_ZN5rustc2ty9item_path90_$LT$impl$u20$rustc..ty..context..TyCtxt$LT$$u27$a$C$$u20$$u27$gcx$C$$u20$$u27$tcx$GT$$GT$13item_path_str17haca929159a60e25fE
_ZN5rustc2ty9item_path90_$LT$impl$u20$rustc..ty..context..TyCtxt$LT$$u27$a$C$$u20$$u27$gcx$C$$u20$$u27$tcx$GT$$GT$13node_path_str17hcef345b12b549032E
_ZN5rustc3cfg3CFG3new17hfadcad978cd6a9a1E
_ZN5rustc3hir10check_attr11check_crate17h199267ffd3686bf8E
_ZN5rustc3hir3map11definitions11DefPathData9to_string17h332fc9ddd25879d7E
_ZN5rustc3hir3map11definitions11Definitions14def_path_table17h2f737885bc2fbe22E
_ZN5rustc3hir3map11definitions12DefPathTable22add_def_path_hashes_to17hfef4975d6de518d3E
_ZN5rustc3hir3map11definitions12DefPathTable4size17hb616fe1cbd99d209E
_ZN5rustc3hir3map3Map10find_entry17h989f50b25e398216E
_ZN5rustc3hir3map3Map15get_parent_node17h93ec210dfb9fa04eE
_ZN5rustc3hir3map3Map16def_path_from_id17hb63e804346e4dafcE
_ZN5rustc3hir3map3Map17body_owner_def_id17h2baefebde7a577f3E
_ZN5rustc3hir3map3Map21nodes_matching_suffix17hef0f9d20beb0c39cE
_ZN5rustc3hir3map3Map3get17he3d108361c210c3eE
_ZN5rustc3hir3map3Map4body17h1a1ce905fc132a72E
_ZN5rustc3hir3map3Map4find17h0fad860bd6c32b41E
_ZN5rustc3hir3map3Map4span17h4b326486deeacab6E
_ZN5rustc3hir3map3Map5krate17ha577b48da71a359cE
_ZN5rustc3hir3map56_$LT$impl$u20$rustc..hir..print..State$LT$$u27$a$GT$$GT$10print_node17h26e4551f0e1ef889E
_ZN5rustc3hir3map6Forest3new17he472525682092eddE
_ZN5rustc3hir3map6Forest5krate17h175f23a20634b9d8E
_ZN5rustc3hir3map6blocks10FnLikeNode4body17hcac1687523e27ee8E
_ZN5rustc3hir3map6blocks10FnLikeNode9from_node17hfc8a22e0b1ddad3eE
_ZN5rustc3hir3map6blocks4Code2id17ha273822eccfc6fd6E
_ZN5rustc3hir3map6blocks4Code9from_node17h456dff39317a56acE
_ZN5rustc3hir3map9map_crate17hcdb7ee202d2f901dE
_ZN5rustc3hir5print11print_crate17haa0f8806e64ece3dE
_ZN5rustc3hir5print5State13synth_comment17hd8f1d542add3c077E
_ZN5rustc3hir5print5State14new_from_input17h2dbcbc86d09781e5E
_ZN5rustc3hir6def_id8CrateNum8as_usize17hbbb5ad3b886861aaE
_ZN5rustc3hir8lowering11lower_crate17hddced1c400f7ee6eE
_ZN5rustc3mir10Terminator10successors17hbfcb8a341c732e9cE
_ZN5rustc3mir14BasicBlockData10terminator17h567fcbb3f2f5a308E
_ZN5rustc3mir14TerminatorKind20fmt_successor_labels17hcf9b59a3d0d048dcE
_ZN5rustc3mir3Mir9return_ty17h962a176ae1269bddE
_ZN5rustc4lint10LintBuffer8add_lint17hf321ac304a111ba1E
_ZN5rustc4lint4Lint10name_lower17hdcbe1e1045ec1a2aE
_ZN5rustc4lint5Level6as_str17h6e7adc439c8a7ea8E
_ZN5rustc4lint6LintId9to_string17hd416483f258cd9abE
_ZN5rustc4lint7builtin19UNKNOWN_CRATE_TYPES17h50be89a7d0d67c86E
_ZN5rustc4lint7builtin26MISSING_FRAGMENT_SPECIFIER17h557c281b32b7b627E
_ZN5rustc4lint7context11check_crate17h891b4c931f973a78E
_ZN5rustc4lint7context15check_ast_crate17h83747216a2f78230E
_ZN5rustc4lint7context9LintStore14register_group17hace61a258cc0cb93E
_ZN5rustc4lint7context9LintStore15get_lint_groups17h2652565984501072E
_ZN5rustc4lint7context9LintStore18register_late_pass17he4c6a9b0bc3e0219E
_ZN5rustc4lint7context9LintStore19register_early_pass17h9bd5d615b55f77d8E
_ZN5rustc4lint7context9LintStore3new17h21e39ad58cdea7a6E
_ZN5rustc4lint7context9LintStore9get_lints17h13c6b84b9ce70678E
_ZN5rustc4lint7provide17he523e32e6bcbabddE
_ZN5rustc4util5ppaux77_$LT$impl$u20$core..fmt..Debug$u20$for$u20$rustc..ty..TyS$LT$$u27$tcx$GT$$GT$3fmt17h06cdca7079866fb5E
_ZN5rustc4util5ppaux79_$LT$impl$u20$core..fmt..Display$u20$for$u20$rustc..ty..TyS$LT$$u27$tcx$GT$$GT$3fmt17h1425d3b9c4f2faa2E
_ZN5rustc4util6common10TIME_DEPTH7__getit17hc91b836a68900dc7E
_ZN5rustc4util6common14profq_set_chan17hc56254d9a8ce0301E
_ZN5rustc4util6common20duration_to_secs_str17hc752aef6c4850ff3E
_ZN5rustc4util6common32print_time_passes_entry_internal17h42c3308a4b2c4b8eE
_ZN5rustc4util6common9profq_msg17h4fb506a18e53afbfE
_ZN5rustc6middle11intrinsicck11check_crate17hb75cef50ee7ebf8fE
_ZN5rustc6middle15recursion_limit13update_limits17h3b5f3cffe8069207E
_ZN5rustc6middle16resolve_lifetime7provide17h24b399945bcdd195E
_ZN5rustc6middle17dependency_format9calculate17h15dfba25326718cdE
_ZN5rustc6middle4dead11check_crate17hd4600a65cfe5074cE
_ZN5rustc6middle5entry16find_entry_point17h98c24aa088e3e8d7E
_ZN5rustc6middle6region7provide17h6b51e3cf6237a7dfE
_ZN5rustc6middle8liveness11check_crate17h8cb3cfe0d0c88d8bE
_ZN5rustc6middle9reachable7provide17h1ace35e7f6e5393aE
_ZN5rustc6middle9stability24check_unstable_api_usage17h29886f962c5e2843E
_ZN5rustc6middle9stability31check_unused_or_stable_features17h2fd26ccfe105b1f2E
_ZN5rustc6traits6select14SelectionCache3new17h1503f3f8e623eae9E
_ZN5rustc6traits6select15EvaluationCache3new17hd16cbd1de790fbd7E
_ZN5rustc6traits7provide17h1c18fdf7da4b4b7dE
_ZN5rustc7session10code_stats9CodeStats16print_type_sizes17hdba44cdda19b0280E
_ZN5rustc7session10early_warn17h0c474586ebd82575E
_ZN5rustc7session10filesearch22get_or_default_sysroot17h16a673b946b3fbc9E
_ZN5rustc7session10filesearch24relative_target_lib_path17h2806bdf3c560ce25E
_ZN5rustc7session11early_error17hdfe3ca2a19bfca28E
_ZN5rustc7session13build_session17hcc55ed16ba794a0eE
_ZN5rustc7session26build_session_with_codemap17h946439e2da5ce759E
_ZN5rustc7session6config11OutputTypes12contains_key17hb97281da0ea9567aE
_ZN5rustc7session6config11OutputTypes4keys17hda41858443a3119aE
_ZN5rustc7session6config11OutputTypes6values17h83409023bd878c7aE
_ZN5rustc7session6config11host_triple17h772ff5b22d0ad391E
_ZN5rustc7session6config13RustcOptGroup9is_stable17h077b7d0dd01d005fE
_ZN5rustc7session6config15OutputFilenames4path17h0aba45e06b0d268eE
_ZN5rustc7session6config15nightly_options16is_nightly_build17hdb7c99fbf5aaa094E
_ZN5rustc7session6config15nightly_options19is_unstable_enabled17he80b6c824f432570E
_ZN5rustc7session6config15nightly_options21check_nightly_options17h1ad2862fb488ed1fE
_ZN5rustc7session6config15rustc_optgroups17h36d092d7b1604caeE
_ZN5rustc7session6config18default_lib_output17h3cc23f7082d9794cE
_ZN5rustc7session6config19build_configuration17hd67a7ebeedf7b141E
_ZN5rustc7session6config21rustc_short_optgroups17h7b6512b2c86dfe86E
_ZN5rustc7session6config38build_session_options_and_crate_config17hc88f4797d7c35927E
_ZN5rustc7session6config5Input8filestem17h5ab2d7c20eae250aE
_ZN5rustc7session6config7Options15build_dep_graph17hcff35435f6d2e779E
_ZN5rustc7session6config7Options17file_path_mapping17hda64bd764afe3779E
_ZN5rustc7session6config7Options23will_create_output_file17h41d70983805f7b08E
_ZN5rustc7session6config9cgsetters10code_model17h9184625c19289fb9E
_ZN5rustc7session6config9cgsetters10no_redzone17he3fddcebef77154dE
_ZN5rustc7session6config9cgsetters10save_temps17hfab8f03f339b0b8fE
_ZN5rustc7session6config9cgsetters10soft_float17h889ac3d3d1e45f8eE
_ZN5rustc7session6config9cgsetters10target_cpu17hc97d52969a05c2f2E
_ZN5rustc7session6config9cgsetters11incremental17hb9f3de9ce0f0454dE
_ZN5rustc7session6config9cgsetters13codegen_units17h3674c8a8ca0e4781E
_ZN5rustc7session6config9cgsetters14extra_filename17h7c3da3efbfcb9e75E
_ZN5rustc7session6config9cgsetters14link_dead_code17hedcccab33b3d2e07E
_ZN5rustc7session6config9cgsetters14no_stack_check17h9141b60b9d862ca9E
_ZN5rustc7session6config9cgsetters14prefer_dynamic17h222061c95da312fdE
_ZN5rustc7session6config9cgsetters14target_feature17h944daf7fac9a3945E
_ZN5rustc7session6config9cgsetters15overflow_checks17hd5c02a74e95c2d9aE
_ZN5rustc7session6config9cgsetters16debug_assertions17h10d96df7749c49e7E
_ZN5rustc7session6config9cgsetters16inline_threshold17h70a8371b3f31cf03E
_ZN5rustc7session6config9cgsetters16no_integrated_as17h208c3afa6cb4b321E
_ZN5rustc7session6config9cgsetters16no_vectorize_slp17hfa072ec5b2fccecdE
_ZN5rustc7session6config9cgsetters16relocation_model17h3f083769d43c3f57E
_ZN5rustc7session6config9cgsetters18no_vectorize_loops17h64e72a6ae2ed00d7E
_ZN5rustc7session6config9cgsetters21no_prepopulate_passes17h221403b55266092eE
_ZN5rustc7session6config9cgsetters2ar17hf681a512009bf1ecE
_ZN5rustc7session6config9cgsetters3lto17h192a38b00c8c3175E
_ZN5rustc7session6config9cgsetters5panic17h0ec48fcc19b2ec8eE
_ZN5rustc7session6config9cgsetters5rpath17h3ebeeecec46072feE
_ZN5rustc7session6config9cgsetters6linker17he108410c280fd2afE
_ZN5rustc7session6config9cgsetters6passes17hc3a579128cb2fac9E
_ZN5rustc7session6config9cgsetters6remark17h0dd1a751e335e710E
_ZN5rustc7session6config9cgsetters8link_arg17hc89d11eab6d3ea4eE
_ZN5rustc7session6config9cgsetters8metadata17h3915ab7268663eaaE
_ZN5rustc7session6config9cgsetters9debuginfo17h6c1624dff0b262fbE
_ZN5rustc7session6config9cgsetters9link_args17h46d19fa60bb586a4E
_ZN5rustc7session6config9cgsetters9llvm_args17he6af9610445eb8eeE
_ZN5rustc7session6config9cgsetters9opt_level17ha186cc41ba80b955E
_ZN5rustc7session6config9dbsetters10meta_stats17h4884a3fd18d1161fE
_ZN5rustc7session6config9dbsetters10parse_only17h79b9783fc7898255E
_ZN5rustc7session6config9dbsetters10perf_stats17hca72170c43464f47E
_ZN5rustc7session6config9dbsetters10print_fuel17h50b8202f8f45789eE
_ZN5rustc7session6config9dbsetters11fewer_names17hdad1f8a4018177efE
_ZN5rustc7session6config9dbsetters11incremental17h5526634a948f6b1dE
_ZN5rustc7session6config9dbsetters11input_stats17h1dc97e91fc24170cE
_ZN5rustc7session6config9dbsetters11no_analysis17h9fa0df8d05b66b48E
_ZN5rustc7session6config9dbsetters11relro_level17h0e20457418f302bfE
_ZN5rustc7session6config9dbsetters11time_passes17h2acfe84f5385b293E
_ZN5rustc7session6config9dbsetters11trans_stats17ha32eade5eb244a54E
_ZN5rustc7session6config9dbsetters12asm_comments17ha3988bd0d8f00752E
_ZN5rustc7session6config9dbsetters12debug_macros17ha40e83b70bdfe84eE
_ZN5rustc7session6config9dbsetters12dump_mir_dir17h5ddbda3bb62c5060E
_ZN5rustc7session6config9dbsetters12pre_link_arg17h2dfd011e4c9b064fE
_ZN5rustc7session6config9dbsetters12trace_macros17hcaef222cfc0cd09fE
_ZN5rustc7session6config9dbsetters13extra_plugins17hbe679e2dfc4cfcdeE
_ZN5rustc7session6config9dbsetters13linker_flavor17ha59984318cd656beE
_ZN5rustc7session6config9dbsetters13mir_opt_level17h2c9f8879edc3fb7bE
_ZN5rustc7session6config9dbsetters13pre_link_args17h9f7ab4e0dac6d65dE
_ZN5rustc7session6config9dbsetters13query_threads17hccaae2bf7e08aaa8E
_ZN5rustc7session6config9dbsetters13save_analysis17h604579f98c075378E
_ZN5rustc7session6config9dbsetters14borrowck_stats17h6cdbbb90dbd846b1E
_ZN5rustc7session6config9dbsetters14dump_dep_graph17he63c123fdc6a489fE
_ZN5rustc7session6config9dbsetters14nll_dump_cause17h43feeba922389c5cE
_ZN5rustc7session6config9dbsetters15codegen_backend17hccf1ea539403d03bE
_ZN5rustc7session6config9dbsetters15mutable_noalias17h9fc51037e66e8fdfE
_ZN5rustc7session6config9dbsetters15no_landing_pads17ha85a81370cfb6a98E
_ZN5rustc7session6config9dbsetters15print_link_args17h29f404085b3a9ef9E
_ZN5rustc7session6config9dbsetters15profile_queries17h87602bca8575fb24E
_ZN5rustc7session6config9dbsetters15query_dep_graph17he573d2a9c5e0e624E
_ZN5rustc7session6config9dbsetters16count_llvm_insns17h7c7f1c866f51b13bE
_ZN5rustc7session6config9dbsetters16emit_end_regions17h8bc41965519dc67cE
_ZN5rustc7session6config9dbsetters16identify_regions17ha9c07ef075ef5acdE
_ZN5rustc7session6config9dbsetters16incremental_info17hc22ccd8e0719c001E
_ZN5rustc7session6config9dbsetters16lower_128bit_ops17h3ff26829c6be7390E
_ZN5rustc7session6config9dbsetters16print_type_sizes17h020d7fe699e4164eE
_ZN5rustc7session6config9dbsetters16time_llvm_passes17hbd5af9753aa4ba72E
_ZN5rustc7session6config9dbsetters16trans_time_graph17he99849f9574b2c8dE
_ZN5rustc7session6config9dbsetters16treat_err_as_bug17h90a9e21d0a2c9d3aE
_ZN5rustc7session6config9dbsetters16unstable_options17h82722485ca8d327dE
_ZN5rustc7session6config9dbsetters17always_encode_mir17h5c8cb42c04cbdc60E
_ZN5rustc7session6config9dbsetters17ast_json_noexpand17h6bd501575e6a2284E
_ZN5rustc7session6config9dbsetters17dump_mir_graphviz17h7a2fcae619db80c5E
_ZN5rustc7session6config9dbsetters17keep_hygiene_data17h45f57b5e78af812cE
_ZN5rustc7session6config9dbsetters17mir_emit_validate17h6600a53ac5bec58eE
_ZN5rustc7session6config9dbsetters17print_llvm_passes17h8264223ba6d8ac42E
_ZN5rustc7session6config9dbsetters17print_trans_items17hc2604e18def0418fE
_ZN5rustc7session6config9dbsetters17span_free_formats17hfa116d0c5481ca8eE
_ZN5rustc7session6config9dbsetters17two_phase_borrows17hf3d52e20613a3ca7E
_ZN5rustc7session6config9dbsetters18inline_in_all_cgus17h668b915e480d2ee1E
_ZN5rustc7session6config9dbsetters18print_region_graph17h817c5364b9733c9fE
_ZN5rustc7session6config9dbsetters19flowgraph_print_all17h7ac8935796f1fdb2E
_ZN5rustc7session6config9dbsetters19incremental_queries17h14c2b62cacd87885E
_ZN5rustc7session6config9dbsetters20remap_path_prefix_to17h5c5f53b2a927ecaeE
_ZN5rustc7session6config9dbsetters21flowgraph_print_loans17h1f87f075aba86e58E
_ZN5rustc7session6config9dbsetters21flowgraph_print_moves17ha801f62efb6560adE
_ZN5rustc7session6config9dbsetters21force_overflow_checks17h8a5e1c4e108a416aE
_ZN5rustc7session6config9dbsetters21incremental_dump_hash17h0a1b7c17b95610cfE
_ZN5rustc7session6config9dbsetters22dep_info_omit_d_target17h5362c8ecd2caaa25E
_ZN5rustc7session6config9dbsetters22incremental_verify_ich17hddab515c8f941ffeE
_ZN5rustc7session6config9dbsetters22osx_rpath_install_name17h2efacb64c39a3299E
_ZN5rustc7session6config9dbsetters22remap_path_prefix_from17h8a88f81b35975734E
_ZN5rustc7session6config9dbsetters22saturating_float_casts17hba859307dbe07639E
_ZN5rustc7session6config9dbsetters23approximate_suggestions17h3b3d2b6c9b69830eE
_ZN5rustc7session6config9dbsetters23flowgraph_print_assigns17h23835fe5f89e783aE
_ZN5rustc7session6config9dbsetters24external_macro_backtrace17h895a9a21d4595ec0E
_ZN5rustc7session6config9dbsetters24human_readable_cgu_names17h751a26966a0ec785E
_ZN5rustc7session6config9dbsetters24incremental_ignore_spans17hff5686bb18517773E
_ZN5rustc7session6config9dbsetters24profile_queries_and_keys17h3e64c5103feb1760E
_ZN5rustc7session6config9dbsetters24two_phase_beyond_autoref17h36a1fb26e5557eafE
_ZN5rustc7session6config9dbsetters26continue_parse_after_error17hbb854f2c5404853aE
_ZN5rustc7session6config9dbsetters26force_unstable_if_unmarked17hf41ca6a48c2ae560E
_ZN5rustc7session6config9dbsetters28dump_mir_exclude_pass_number17hcb5c6f946f1d0b35E
_ZN5rustc7session6config9dbsetters28enable_nonzeroing_move_hints17h51220f5b3daf8f24E
_ZN5rustc7session6config9dbsetters2ls17hc24067785a03992aE
_ZN5rustc7session6config9dbsetters3nll17h30dabf666ab26d54E
_ZN5rustc7session6config9dbsetters4fuel17h3bccf7a7bffe33e1E
_ZN5rustc7session6config9dbsetters4miri17hbe243c6afa03bc84E
_ZN5rustc7session6config9dbsetters5epoch17h22b52b00da0710cbE
_ZN5rustc7session6config9dbsetters5teach17h142274503da135d9E
_ZN5rustc7session6config9dbsetters7profile17h6ddca8d7a819e6d6E
_ZN5rustc7session6config9dbsetters7thinlto17h70c7a493661e4295E
_ZN5rustc7session6config9dbsetters7verbose17h2536cf203a2075c2E
_ZN5rustc7session6config9dbsetters8ast_json17hadf2ef537ac4571dE
_ZN5rustc7session6config9dbsetters8borrowck17hb45090594a34f71fE
_ZN5rustc7session6config9dbsetters8dump_mir17h24746873758b5f30E
_ZN5rustc7session6config9dbsetters8keep_ast17h175bbb84bc6a6be2E
_ZN5rustc7session6config9dbsetters8no_trans17h88f0b04081fe8b56E
_ZN5rustc7session6config9dbsetters8unpretty17he947f6bfbb8d9fc7E
_ZN5rustc7session6config9dbsetters9hir_stats17h550fdeed3914caacE
_ZN5rustc7session6config9dbsetters9mir_stats17hd89eaa25a653462fE
_ZN5rustc7session6config9dbsetters9no_verify17h3f880b970509a922E
_ZN5rustc7session6config9dbsetters9sanitizer17hb443d0d13ae6990aE
_ZN5rustc7session6config9dbsetters9show_span17hdcba0e3c6dac6430E
_ZN5rustc7session6config9dbsetters9tls_model17he3cde69d9aea9361E
_ZN5rustc7session7Session10diagnostic17h9d9841075db62d7dE
_ZN5rustc7session7Session11time_passes17ha0177728b33f2266E
_ZN5rustc7session7Session12next_node_id17hf12e71e6e75051b2E
_ZN5rustc7session7Session14compile_status17hd73f04f0e7cc6a24E
_ZN5rustc7session7Session15abort_if_errors17hf040f7791be2e829E
_ZN5rustc7session7Session15profile_queries17h31ae4e31cf2729dcE
_ZN5rustc7session7Session16print_perf_stats17h35163b2e3939cebbE
_ZN5rustc7session7Session18crt_static_feature17h0ed395907e6a55c7E
_ZN5rustc7session7Session3err17h176f67ff348da05fE
_ZN5rustc7session7Session4warn17ha92c1240f43451c3E
_ZN5rustc7session7Session5fatal17h6f0ec64703e7f236E
_ZN5rustc7session7Session7codemap17hd600382259026e41E
_ZN5rustc7session7Session7sysroot17hb9c2cbfd11969c20E
_ZN5rustc7session7Session9err_count17ha214af00a4b5d751E
_ZN5rustc7session7bug_fmt17h027ca62312e2553cE
_ZN5rustc9dep_graph4raii10IgnoreTask3new17hea19c759c33f7223E
_ZN5rustc9dep_graph5graph8DepGraph12new_disabled17hd3bf27970e83c5cdE
_ZN5rustc9dep_graph5graph8DepGraph14assert_ignored17he6e058c317d55013E
_ZN5rustc9dep_graph5graph8DepGraph3new17h95f3eab0ce3c622dE
_ZN60_$LT$alloc..string..String$u20$as$u20$core..clone..Clone$GT$5clone17h8a68633f6ef4e185E
_ZN60_$LT$core..cell..BorrowError$u20$as$u20$core..fmt..Debug$GT$3fmt17h1ad7b151861b23ffE
_ZN60_$LT$std..ffi..os_str..OsStr$u20$as$u20$core..fmt..Debug$GT$3fmt17h4bc6420c13f6315dE
_ZN60_$LT$std..io..error..Error$u20$as$u20$core..fmt..Display$GT$3fmt17ha6e7c673cf29500dE
_ZN62_$LT$core..time..Duration$u20$as$u20$core..ops..arith..Add$GT$3add17hf0b29110d7cf89e0E
_ZN62_$LT$core..time..Duration$u20$as$u20$core..ops..arith..Sub$GT$3sub17h905d13e4b55e4356E
_ZN62_$LT$rustc..ty..maps..QueryMsg$u20$as$u20$core..fmt..Debug$GT$3fmt17ha6c55ea84c0fca98E
_ZN62_$LT$rustc_driver..Compilation$u20$as$u20$core..fmt..Debug$GT$3fmt17h41b3bcd7ad6a3370E
_ZN62_$LT$std..ffi..c_str..NulError$u20$as$u20$core..fmt..Debug$GT$3fmt17h0348bc26c0dbd2dbE
_ZN62_$LT$std..path..PathBuf$u20$as$u20$core..ops..deref..Deref$GT$5deref17h851b77185fb98d28E
_ZN63_$LT$core..cell..BorrowMutError$u20$as$u20$core..fmt..Debug$GT$3fmt17h87bd7b9c8c81f90eE
_ZN63_$LT$std..ffi..os_str..OsString$u20$as$u20$core..fmt..Debug$GT$3fmt17h9366549e2c5db996E
_ZN63_$LT$std..sync..mpsc..RecvError$u20$as$u20$core..fmt..Debug$GT$3fmt17hb13d886805a54af2E
_ZN65_$LT$alloc..string..FromUtf8Error$u20$as$u20$core..fmt..Debug$GT$3fmt17hb003d59636e24630E
_ZN65_$LT$rustc_driver..pretty..PpMode$u20$as$u20$core..fmt..Debug$GT$3fmt17h0456bb52db634274E
_ZN65_$LT$std..sys..unix..fs..Dir$u20$as$u20$core..ops..drop..Drop$GT$4drop17h14b2a53f581a7ed9E
_ZN65_$LT$syntax_pos..symbol..Symbol$u20$as$u20$core..fmt..Display$GT$3fmt17h84356a4de8f18fbfE
_ZN67_$LT$std..env..ArgsOs$u20$as$u20$core..iter..iterator..Iterator$GT$4next17hc580cd5e39c4aee1E
_ZN67_$LT$std..env..ArgsOs$u20$as$u20$core..iter..iterator..Iterator$GT$9size_hint17h677deb8588620b80E
_ZN67_$LT$std..fs..ReadDir$u20$as$u20$core..iter..iterator..Iterator$GT$4next17h4366145ff2bd8212E
_ZN68_$LT$core..time..Duration$u20$as$u20$core..ops..arith..AddAssign$GT$10add_assign17ha71c622dc33cedb1E
_ZN68_$LT$std..thread..local..AccessError$u20$as$u20$core..fmt..Debug$GT$3fmt17h7bf43d3d03aaf783E
_ZN69_$LT$std..sync..condvar..Condvar$u20$as$u20$core..ops..drop..Drop$GT$4drop17h33dc1855cf1ebf4eE
_ZN6syntax10std_inject23maybe_inject_crates_ref17hbe88a0f860f1023dE
_ZN6syntax11diagnostics6plugin22expand_diagnostic_used17h6b96f7432c6feb3dE
_ZN6syntax11diagnostics6plugin26expand_register_diagnostic17h1c1eed6c6adc4fefE
_ZN6syntax11diagnostics6plugin29expand_build_diagnostic_array17h8e50cc16a357d36aE
_ZN6syntax11tokenstream11TokenStream10into_trees17hf5064e7c0c71911aE
_ZN6syntax11tokenstream11TokenStream5trees17h60abf1733419afacE
_ZN6syntax11tokenstream11TokenStream6concat17h05ae45d0ba4baef3E
_ZN6syntax11tokenstream6Cursor14next_as_stream17hd5244f37d2ef6f5fE
_ZN6syntax11tokenstream9Delimited6stream17hec0cec18d2da6d6eE
_ZN6syntax11tokenstream9TokenTree5joint17hf4618b2e7442c060E
_ZN6syntax12feature_gate11check_crate17hccb090a230c6b627E
_ZN6syntax12feature_gate16UnstableFeatures16from_environment17h1fec54ca02a41002E
_ZN6syntax12feature_gate16UnstableFeatures16is_nightly_build17hfc0b42eeac05cf60E
_ZN6syntax12feature_gate8GatedCfg4gate17h550840ad50257f6fE
_ZN6syntax3ast4Mac_6stream17h9e72963d1bacddf3E
_ZN6syntax3ast6NodeId3new17hfb442ba900468b05E
_ZN6syntax3ext4base7ExtCtxt18monotonic_expander17ha3fbdf038c19ea82E
_ZN6syntax3ext4base7ExtCtxt19check_unused_macros17ha49608316a582060E
_ZN6syntax3ext4base7ExtCtxt3new17hfe84f83a9d6ce2d1E
_ZN6syntax3ext6expand13MacroExpander12expand_crate17h1a33c9e2827766afE
_ZN6syntax3ext6expand15ExpansionConfig7default17hda61b50e9127debaE
_ZN6syntax4attr13contains_name17hfb113f1e8ca2311aE
_ZN6syntax4attr15find_crate_name17h794010c877074cf0E
_ZN6syntax4attr40_$LT$impl$u20$syntax..ast..Attribute$GT$10check_name17ha1117e703d336fc1E
_ZN6syntax4attr40_$LT$impl$u20$syntax..ast..Attribute$GT$9value_str17h2d1a99e5713d8c5bE
_ZN6syntax4test18modify_for_testing17h563909ef22ff8f25E
_ZN6syntax4util10node_count11NodeCounter3new17h3b96f9b24eaeb94fE
_ZN6syntax5parse21parse_crate_from_file17hb3f2473298f6058aE
_ZN6syntax5parse27parse_crate_attrs_from_file17h1bee9fbe2484884cE
_ZN6syntax5parse27parse_crate_from_source_str17heba9aa6b22aa4abeE
_ZN6syntax5parse33parse_crate_attrs_from_source_str17hb6be0b7b179fefbfE
_ZN6syntax5parse5token5Token12interpolated17he14bd9bc7f489212E
_ZN6syntax5print2pp7Printer3eof17hbc7f3a34a15c4071E
_ZN6syntax5print2pp7Printer4word17h504b474f1d35d6d7E
_ZN6syntax5print2pp7Printer5space17h3fd41a27f4d67b6aE
_ZN6syntax5print2pp7Printer9hardbreak17h32bf0e13db2b0bc0E
_ZN6syntax5print6pprust11print_crate17h9390fd1a96ed42adE
_ZN6syntax5print6pprust5State13synth_comment17h3d88d17261eab921E
_ZN6syntax6config8features17h80c70ac5312367d5E
_ZN6syntax7codemap7CodeMap11count_lines17h55c1fabed54d50b0E
_ZN6syntax7codemap7CodeMap11get_filemap17h28f1b32e82eeb9b7E
_ZN6syntax7codemap7CodeMap16with_file_loader17h6a5c2df7bbc5ffc3E
_ZN6syntax7codemap7CodeMap5files17hdb055e8affff3722E
_ZN6syntax9show_span3run17hbb6551c5fb317986E
_ZN70_$LT$rustc..mir..Place$LT$$u27$tcx$GT$$u20$as$u20$core..fmt..Debug$GT$3fmt17h7210fe108d12d2c0E
_ZN70_$LT$rustc_back..target..Target$u20$as$u20$serialize..json..ToJson$GT$7to_json17h614243f36b7d4d4aE
_ZN70_$LT$std..io..Guard$LT$$u27$a$GT$$u20$as$u20$core..ops..drop..Drop$GT$4drop17h9fb8630892ae69a1E
_ZN70_$LT$std..sys..unix..fd..FileDesc$u20$as$u20$core..ops..drop..Drop$GT$4drop17ha9f7f731cf74fd82E
_ZN71_$LT$rustc_driver..pretty..PpSourceMode$u20$as$u20$core..fmt..Debug$GT$3fmt17ha3e856bc085042cbE
_ZN71_$LT$std..path..Display$LT$$u27$a$GT$$u20$as$u20$core..fmt..Display$GT$3fmt17hf94b0541dd2b14cbE
_ZN71_$LT$syntax_pos..hygiene..SyntaxContext$u20$as$u20$core..fmt..Debug$GT$3fmt17hc2a43b9d238dd4dcE
_ZN72_$LT$rustc..dep_graph..dep_node..DepNode$u20$as$u20$core..fmt..Debug$GT$3fmt17hc9db07a5c55259ebE
_ZN72_$LT$rustc..mir..Operand$LT$$u27$tcx$GT$$u20$as$u20$core..fmt..Debug$GT$3fmt17hd031388cc5f88ae2E
_ZN72_$LT$rustc..session..config..CrateType$u20$as$u20$core..fmt..Display$GT$3fmt17h7d542a6f30946f2bE
_ZN72_$LT$rustc_driver..profile..trace..Query$u20$as$u20$core..fmt..Debug$GT$3fmt17h039ea4ab461baaadE
_ZN72_$LT$std..sys..unix..thread..Thread$u20$as$u20$core..ops..drop..Drop$GT$4drop17h8c698fe8ff3ec16aE
_ZN74_$LT$rustc..hir..map..Node$LT$$u27$hir$GT$$u20$as$u20$core..fmt..Debug$GT$3fmt17hb657aa77ea3298a9E
_ZN74_$LT$rustc..mir..Statement$LT$$u27$tcx$GT$$u20$as$u20$core..fmt..Debug$GT$3fmt17hc6d8ef75b383ef70E
_ZN74_$LT$rustc_driver..pretty..PpFlowGraphMode$u20$as$u20$core..fmt..Debug$GT$3fmt17h5184ca536b17d8ccE
_ZN75_$LT$rustc..util..common..ProfileQueriesMsg$u20$as$u20$core..fmt..Debug$GT$3fmt17h0b69976c6d849b9cE
_ZN76_$LT$syntax..parse..token..LazyTokenStream$u20$as$u20$core..clone..Clone$GT$5clone17h015618c6c9804f9aE
_ZN77_$LT$rustc..mir..Local$u20$as$u20$rustc_data_structures..indexed_vec..Idx$GT$3new17h7dd42e2535d7f910E
_ZN77_$LT$rustc..mir..Local$u20$as$u20$rustc_data_structures..indexed_vec..Idx$GT$5index17h642454d4294b8195E
_ZN77_$LT$rustc_driver..pretty..UserIdentifiedItem$u20$as$u20$core..fmt..Debug$GT$3fmt17hecbc0768a5133761E
_ZN78_$LT$rustc..hir..map..MapEntry$LT$$u27$hir$GT$$u20$as$u20$core..fmt..Debug$GT$3fmt17h10ef4d1e93fc4979E
_ZN78_$LT$std..ffi..os_str..OsStr$u20$as$u20$std..sys..unix..ext..ffi..OsStrExt$GT$10from_bytes17h2ab7989e1c0fb272E
_ZN78_$LT$syntax..tokenstream..Cursor$u20$as$u20$core..iter..iterator..Iterator$GT$4next17hb1e24606adc1590eE
_ZN78_$LT$syntax_pos..symbol..InternedString$u20$as$u20$core..ops..deref..Deref$GT$5deref17hb5db7acccbd42246E
_ZN79_$LT$rustc_driver..pretty..UserIdentifiedItem$u20$as$u20$core..str..FromStr$GT$8from_str17h6efb646111962a8dE
_ZN79_$LT$std..path..Path$u20$as$u20$core..convert..AsRef$LT$std..path..Path$GT$$GT$6as_ref17h6dc2cca1026a9128E
_ZN79_$LT$syntax..ast..NodeId$u20$as$u20$rustc_data_structures..indexed_vec..Idx$GT$5index17ha32c873bc7cea94eE
_ZN79_$LT$syntax..codemap..RealFileLoader$u20$as$u20$syntax..codemap..FileLoader$GT$11file_exists17hbf22df764b0528acE
_ZN79_$LT$syntax..codemap..RealFileLoader$u20$as$u20$syntax..codemap..FileLoader$GT$8abs_path17h3676ad2bdcbab4c3E
_ZN79_$LT$syntax..codemap..RealFileLoader$u20$as$u20$syntax..codemap..FileLoader$GT$9read_file17h1adba7a5f6fc6760E
_ZN7getopts4Name8from_str17hc1894b46ebaa091bE
_ZN7getopts4Name9to_string17h4a32b4174af93a4bE
_ZN7getopts6is_arg17h5ac33da2f18eea68E
_ZN7getopts7Matches11opt_default17h278bd4402d7759bbE
_ZN7getopts7Matches11opt_present17h70c907e865bbf35fE
_ZN7getopts7Matches7opt_str17hc7c758771438f58eE
_ZN7getopts7Matches8opt_strs17h5f883f366bfad8b8E
_ZN7getopts7Options3new17h2be52af4b59bca06E
_ZN7getopts7Options5parse1f17h670cde9049b2d473E
_ZN7getopts7Options5usage17h3aa5f0d1d8ba441bE
_ZN7getopts8OptGroup13long_to_short17hef6e0abfcd436b12E
_ZN7getopts8find_opt17ha7c0ca497b8f2d2aE
_ZN80_$LT$serialize..json..PrettyJson$LT$$u27$a$GT$$u20$as$u20$core..fmt..Display$GT$3fmt17had57b9d5e3aa1c34E
_ZN81_$LT$rustc..hir..map..Map$LT$$u27$hir$GT$$u20$as$u20$rustc..hir..print..PpAnn$GT$6nested17haebcf0f4dd93bb85E
_ZN81_$LT$rustc..ty..maps..Providers$LT$$u27$tcx$GT$$u20$as$u20$core..clone..Clone$GT$5clone17h6e7f008f4198b889E
_ZN81_$LT$rustc_data_structures..flock..imp..Lock$u20$as$u20$core..ops..drop..Drop$GT$4drop17ha87569f9759179e2E
_ZN82_$LT$rustc..mir..BasicBlock$u20$as$u20$rustc_data_structures..indexed_vec..Idx$GT$3new17hcf6fba807e38a831E
_ZN82_$LT$rustc..mir..BasicBlock$u20$as$u20$rustc_data_structures..indexed_vec..Idx$GT$5index17hed8df13e8f6bccc9E
_ZN82_$LT$rustc..session..config..ErrorOutputType$u20$as$u20$core..default..Default$GT$7default17h607c3c50478f9c29E
_ZN82_$LT$std..path..PathBuf$u20$as$u20$core..convert..AsRef$LT$std..path..Path$GT$$GT$6as_ref17hf0e65d4e1a9b5fbfE
_ZN85_$LT$rustc..ty..maps..Providers$LT$$u27$tcx$GT$$u20$as$u20$core..default..Default$GT$7default17h36ec38b23467f243E
_ZN85_$LT$rustc_metadata..dynamic_lib..DynamicLibrary$u20$as$u20$core..ops..drop..Drop$GT$4drop17h61260ca9b71f8cbfE
_ZN86_$LT$syntax_pos..FileName$u20$as$u20$core..convert..From$LT$std..path..PathBuf$GT$$GT$4from17hb93ec0d27de55a3fE
_ZN87_$LT$alloc..string..String$u20$as$u20$core..convert..From$LT$$RF$$u27$a$u20$str$GT$$GT$4from17h0747ecb4035de28eE
_ZN87_$LT$rustc_errors..emitter..EmitterWriter$u20$as$u20$rustc_errors..emitter..Emitter$GT$4emit17h2cb8b14755521abbE
_ZN88_$LT$rustc..hir..def_id..CrateNum$u20$as$u20$rustc_data_structures..indexed_vec..Idx$GT$5index17ha97d30c7e7225709E
_ZN88_$LT$rustc_driver..pretty..NoAnn$LT$$u27$hir$GT$$u20$as$u20$rustc..hir..print..PpAnn$GT$6nested17hadb3e2da4924dc21E
_ZN88_$LT$rustc_resolve..Resolver$LT$$u27$a$GT$$u20$as$u20$rustc..hir..lowering..Resolver$GT$11definitions17h4bde626253189d93E
_ZN88_$LT$rustc_resolve..Resolver$LT$$u27$a$GT$$u20$as$u20$rustc..hir..lowering..Resolver$GT$14get_resolution17h1f5674c7760888c6E
_ZN88_$LT$rustc_resolve..Resolver$LT$$u27$a$GT$$u20$as$u20$rustc..hir..lowering..Resolver$GT$16resolve_hir_path17h03f4f48b24de52faE
_ZN88_$LT$rustc_resolve..Resolver$LT$$u27$a$GT$$u20$as$u20$rustc..hir..lowering..Resolver$GT$16resolve_str_path17ha4ee7619679b51d2E
_ZN88_$LT$serialize..json..Encoder$LT$$u27$a$GT$$u20$as$u20$serialize..serialize..Encoder$GT$10emit_usize17h728c74a95b0bb9f7E
_ZN88_$LT$serialize..json..Encoder$LT$$u27$a$GT$$u20$as$u20$serialize..serialize..Encoder$GT$16emit_option_none17hcbbc6191f377fec9E
_ZN88_$LT$serialize..json..Encoder$LT$$u27$a$GT$$u20$as$u20$serialize..serialize..Encoder$GT$7emit_u817h6572099f46e8b927E
_ZN88_$LT$serialize..json..Encoder$LT$$u27$a$GT$$u20$as$u20$serialize..serialize..Encoder$GT$8emit_str17h55f6946bcadb294dE
_ZN88_$LT$serialize..json..Encoder$LT$$u27$a$GT$$u20$as$u20$serialize..serialize..Encoder$GT$8emit_u3217h3e9e991935655bb2E
_ZN88_$LT$serialize..json..Encoder$LT$$u27$a$GT$$u20$as$u20$serialize..serialize..Encoder$GT$9emit_bool17h7faeb34317ba479eE
_ZN88_$LT$serialize..json..Encoder$LT$$u27$a$GT$$u20$as$u20$serialize..serialize..Encoder$GT$9emit_char17hed0ced406c12c2baE
_ZN88_$LT$serialize..json..Encoder$LT$$u27$a$GT$$u20$as$u20$serialize..serialize..Encoder$GT$9emit_u12817hc6ad9c8987863855E
_ZN8graphviz11escape_html17h11de7b27e6c00fe5E
_ZN8graphviz2Id8as_slice17h006a955d48bdc44dE
_ZN8graphviz9LabelText13to_dot_string17h7784c710601d1268E
_ZN91_$LT$alloc..vec..Vec$LT$u8$GT$$u20$as$u20$core..convert..From$LT$$RF$$u27$a$u20$str$GT$$GT$4from17h310f0a282bff5af8E
_ZN92_$LT$serialize..json..FormatShim$LT$$u27$a$C$$u20$$u27$b$GT$$u20$as$u20$core..fmt..Write$GT$9write_str17hb36882051e134258E
_ZN92_$LT$std..path..PathBuf$u20$as$u20$core..convert..From$LT$std..ffi..os_str..OsString$GT$$GT$4from17h570a08941e2ae971E
_ZN93_$LT$rustc_driver..RustcDefaultCalls$u20$as$u20$rustc_driver..CompilerCalls$LT$$u27$a$GT$$GT$13late_callback17he1d9468e9d101cf7E
_ZN93_$LT$rustc_driver..RustcDefaultCalls$u20$as$u20$rustc_driver..CompilerCalls$LT$$u27$a$GT$$GT$14early_callback17h8db8b43054b8403eE
_ZN93_$LT$rustc_driver..RustcDefaultCalls$u20$as$u20$rustc_driver..CompilerCalls$LT$$u27$a$GT$$GT$16build_controller17h884da5db46a85d44E
_ZN93_$LT$rustc_driver..RustcDefaultCalls$u20$as$u20$rustc_driver..CompilerCalls$LT$$u27$a$GT$$GT$8no_input17h08747cb73d3076bcE
_ZN93_$LT$serialize..json..EncoderError$u20$as$u20$core..convert..From$LT$core..fmt..Error$GT$$GT$4from17h2918be4c9cf18f9cE
_ZN94_$LT$rustc..dep_graph..raii..IgnoreTask$LT$$u27$graph$GT$$u20$as$u20$core..ops..drop..Drop$GT$4drop17h1dd0363da8655cc2E
_ZN95_$LT$std..ffi..os_str..OsStr$u20$as$u20$core..convert..AsRef$LT$std..ffi..os_str..OsStr$GT$$GT$6as_ref17hec63427697572b40E
_ZN96_$LT$rustc_driver..pretty..ReplaceBodyWithLoop$LT$$u27$a$GT$$u20$as$u20$syntax..fold..Folder$GT$10fold_block17heda31ffdb7cda4f2E
_ZN96_$LT$rustc_driver..pretty..ReplaceBodyWithLoop$LT$$u27$a$GT$$u20$as$u20$syntax..fold..Folder$GT$14fold_impl_item17hce6bb0ca71400896E
_ZN96_$LT$rustc_driver..pretty..ReplaceBodyWithLoop$LT$$u27$a$GT$$u20$as$u20$syntax..fold..Folder$GT$14fold_item_kind17h85ced7bc32404b2fE
_ZN96_$LT$rustc_driver..pretty..ReplaceBodyWithLoop$LT$$u27$a$GT$$u20$as$u20$syntax..fold..Folder$GT$15fold_trait_item17hc608e506a78b4b6fE
_ZN96_$LT$rustc_driver..pretty..ReplaceBodyWithLoop$LT$$u27$a$GT$$u20$as$u20$syntax..fold..Folder$GT$8fold_mac17h43e7c6430a3e0f19E
_ZN96_$LT$syntax..util..node_count..NodeCounter$u20$as$u20$syntax..visit..Visitor$LT$$u27$ast$GT$$GT$15visit_attribute17h20fa58dc730c2cc2E
_ZN96_$LT$syntax..util..node_count..NodeCounter$u20$as$u20$syntax..visit..Visitor$LT$$u27$ast$GT$$GT$9visit_mod17he62a788d48443632E
_ZN98_$LT$std..ffi..os_str..OsString$u20$as$u20$core..convert..AsRef$LT$std..ffi..os_str..OsStr$GT$$GT$6as_ref17h1f794f68bf847f89E
_ZN99_$LT$rustc_save_analysis..DumpHandler$LT$$u27$a$GT$$u20$as$u20$rustc_save_analysis..SaveHandler$GT$4save17hc5f48cac7fbbb08cE
_ZN9rustc_mir4util6pretty16dump_mir_def_ids17h0cbab17b9b0c359eE
_ZN9rustc_mir4util6pretty16write_mir_pretty17h874497fb389c3e91E
_ZN9rustc_mir4util8graphviz4node17h32eac9e336374e56E
_ZN9rustc_mir7provide17h92356c0761e21d77E
_ZN9rustc_mir9transform14check_unsafety14check_unsafety17hc53089f7abaf9b1dE
_ZN9rustc_mir9transform8dump_mir8emit_mir17h58ceb7e7a822af7aE
_ZN9serialize4json10escape_str17h517af7e515a446feE
_ZN9serialize4json4Json6pretty17hf5e185f244165078E
_ZN9serialize4json7Encoder3new17h9898be0e117b6f59E
__rust_alloc
__rust_dealloc
__rust_maybe_catch_panic
__rust_oom
__rust_realloc
dladdr
isatty
memcmp
memcpy
memmove
memset
pthread_mutex_destroy
pthread_mutex_init
pthread_mutex_lock
pthread_mutex_unlock
pthread_mutexattr_destroy
pthread_mutexattr_init
pthread_mutexattr_settype
rust_eh_personality
rust_metadata_rustc_driver_ef2e358e734e2ba7a6fa224eff6cf516
__rdl_alloc
__rdl_alloc_excess
__rdl_alloc_zeroed
__rdl_dealloc
__rdl_grow_in_place
__rdl_oom
__rdl_realloc
__rdl_realloc_excess
__rdl_shrink_in_place
__rdl_usable_size
__rust_alloc_excess
__rust_alloc_zeroed
__rust_grow_in_place
__rust_realloc_excess
__rust_shrink_in_place
__rust_usable_size
librustc_trans_utils-9d5edc7bc904879e.so
librustc_save_analysis-7e54714f5f72d0d0.so
librustc_resolve-77e3805dae961844.so
librustc_incremental-385d8f6e106860f5.so
librustc_privacy-7125386f5bd619d8.so
librustc_typeck-d1ffba5d6a3b08f3.so
librustc_plugin-9e0ab4276e933b0b.so
librustc_metadata-332728fc34893e8b.so
libsyntax_ext-ee1fdde7809654fc.so
librustc_lint-6f7a1abbd4230d42.so
librustc_passes-372e1a55e1078543.so
librustc_borrowck-34a25846b37e95a4.so
librustc_mir-ec16b35852e5264e.so
librustc_const_eval-4d61e73298fe34eb.so
librustc_allocator-87b6bcb2352fe1fc.so
librustc-6f70081334e5c03a.so
libtest-cd24857d4591cf8a.so
librustc_const_math-e4c7e10bce9f4e40.so
librustc_back-d82b2f9b67be052a.so
libsyntax-3e705badb3655c53.so
librustc_errors-0c72a4b6ce7e9a2a.so
libsyntax_pos-4eadf9e30a68bc21.so
librustc_data_structures-ecc1b2c8bf109e1b.so
libserialize-660f13b48c90a844.so
_ZN10env_logger10LogBuilder3new17h90f15480a8acf578E
_ZN10env_logger10LogBuilder4init17h44540ef1ff41ead2E
_ZN10env_logger10LogBuilder5build17h4d357637c603b01dE
_ZN10env_logger10LogBuilder5parse17hcaf9920d33d7ca5eE
_ZN10env_logger10LogBuilder6filter17h73949eff91a2bac8E
_ZN10env_logger10LogBuilder6target17hfadf91c962691d7dE
_ZN10env_logger6Logger3new17hc252c7a4888520ceE
_ZN10env_logger6Logger6filter17hf02e704a3b2624a8E
_ZN3log10set_logger17hdcecb73367951ea5E
_ZN3log11LogLocation11module_path17h902a3ec19b3ae035E
_ZN3log11LogMetadata5level17h3c524695c909d98aE
_ZN3log11LogMetadata6target17h4788eb939bd7a12cE
_ZN3log14set_logger_raw7ADAPTOR17h57efe3a97ba39edaE
_ZN3log17MaxLogLevelFilter3set17h178d78b3595aef0dE
_ZN3log5STATE17hcf9af801e2599174E
_ZN3log6LOGGER17hdc867ee8f1590c22E
_ZN3log9LogRecord4args17hb3e74221a15791d9E
_ZN3log9LogRecord5level17ha91a1820f01fbb6fE
_ZN3log9LogRecord8location17h69e57dc1f5c86309E
_ZN3log9LogRecord8metadata17h9a61eab060d1b0a4E
_ZN3std2io5stdio6stderr17h07ba27c63005c6c3E
_ZN3std3env4_var17h73a410c4fe9ea941E
_ZN3std3sys4unix5mutex14ReentrantMutex7destroy17hdecaf98ff3889ecaE
_ZN47_$LT$env_logger..Logger$u20$as$u20$log..Log$GT$3log17he224c9aaef2f380eE
_ZN47_$LT$env_logger..Logger$u20$as$u20$log..Log$GT$7enabled17h9f2b5f27cd7f277dE
_ZN47_$LT$log..LoggerAdaptor$u20$as$u20$log..Log$GT$3log17h4b42c9d996a42d41E
_ZN47_$LT$log..LoggerAdaptor$u20$as$u20$log..Log$GT$5flush17h7eee73f36020baf0E
_ZN47_$LT$log..LoggerAdaptor$u20$as$u20$log..Log$GT$7enabled17h41f3d88afbaaebdaE
_ZN52_$LT$log..LogLevel$u20$as$u20$core..fmt..Display$GT$3fmt17h744604a154848bbfE
_ZN57_$LT$std..io..stdio..Stderr$u20$as$u20$std..io..Write$GT$9write_fmt17h022e6b0d62a254a9E
_ZN58_$LT$env_logger..LogTarget$u20$as$u20$core..fmt..Debug$GT$3fmt17hbb983a1610a1dd2aE
_ZN58_$LT$log..LogLevelFilter$u20$as$u20$core..str..FromStr$GT$8from_str17h8d19fca84f3861beE
_ZN5alloc3str21_$LT$impl$u20$str$GT$4trim17h49b610564959ba27E
_ZN65_$LT$env_logger..filter..Filter$u20$as$u20$core..fmt..Display$GT$3fmt17h8c9263838faa16b9E
_ZN73_$LT$core..fmt..Arguments$LT$$u27$a$GT$$u20$as$u20$core..fmt..Display$GT$3fmt17hda40beb920511c23E
_ZN3log11LogLocation4file17h7bf188130359c54dE
_ZN3log11LogLocation4line17hcd8dc1c9810c4d6fE
_ZN3log14LogLevelFilter10from_usize17hc338b269d23fbf15E
_ZN3log14LogLevelFilter8from_new17hd9d241ab38e59a1dE
_ZN3log15shutdown_logger17h2c5eaa5c47a27a74E
_ZN3log17MaxLogLevelFilter3get17he6ab861f7d2a1032E
_ZN3log19shutdown_logger_raw17had09d8156e1d7f24E
_ZN3log5__log17ha2cf638646977d26E
_ZN3log8LogLevel10from_usize17h7d98d9ca27ecf44eE
_ZN3log9LogRecord6target17h37f40d2f89a27038E
_ZN3log9__enabled17h98f5055b8538b02cE
_ZN43_$LT$log..NopLogger$u20$as$u20$log..Log$GT$3log17hdbb565e527dc32c8E
_ZN43_$LT$log..NopLogger$u20$as$u20$log..Log$GT$7enabled17hf6fa1c2316f05069E
_ZN4core3fmt9Formatter3pad17h777286d09b154fb0E
_ZN4core3fmt9Formatter9write_fmt17h514d0ef68aef7802E
_ZN50_$LT$log..LogLevel$u20$as$u20$core..fmt..Debug$GT$3fmt17h8538d404df7375b5E
_ZN52_$LT$log..LogLevel$u20$as$u20$core..str..FromStr$GT$8from_str17h1c379dad07366056E
_ZN53_$LT$log..LogLocation$u20$as$u20$core..fmt..Debug$GT$3fmt17hbfd37be380230d12E
_ZN56_$LT$log..LogLevelFilter$u20$as$u20$core..fmt..Debug$GT$3fmt17h5a4673737ede5b47E
_ZN57_$LT$log..SetLoggerError$u20$as$u20$std..error..Error$GT$11description17h12779fc1e0d70488E
_ZN58_$LT$log..LogLevelFilter$u20$as$u20$core..fmt..Display$GT$3fmt17h0bb18a0a643880c1E
_ZN58_$LT$log..LoggerGuard$u20$as$u20$core..ops..drop..Drop$GT$4drop17hd39700709ae5c27bE
_ZN58_$LT$log..SetLoggerError$u20$as$u20$core..fmt..Display$GT$3fmt17hf2ba6785821f2552E
_ZN59_$LT$log..MaxLogLevelFilter$u20$as$u20$core..fmt..Debug$GT$3fmt17h0b4327681ccc99deE
_ZN60_$LT$log..LoggerGuard$u20$as$u20$core..ops..deref..Deref$GT$5deref17hf6862e2bbcbba077E
_ZN61_$LT$log..ShutdownLoggerError$u20$as$u20$core..fmt..Debug$GT$3fmt17hd46930286be122c9E
_ZN62_$LT$log..ShutdownLoggerError$u20$as$u20$std..error..Error$GT$11description17h42860f45feeaca81E
_ZN63_$LT$log..ShutdownLoggerError$u20$as$u20$core..fmt..Display$GT$3fmt17h01ae1a3a975a329fE
_ZN90_$LT$core..str..Bytes$LT$$u27$a$GT$$u20$as$u20$core..iter_private..TrustedRandomAccess$GT$13get_unchecked17hfcd28ea1257a0527E
_ZN90_$LT$core..str..Bytes$LT$$u27$a$GT$$u20$as$u20$core..iter_private..TrustedRandomAccess$GT$20may_have_side_effect17hfde5ea0c2bd191e3E
libgraphviz-13b0b18917ead7a0.so
libstd-cb842bf560db20af.so
libdl.so.2
libpthread.so.0
libgcc_s.so.1
libc.so.6
_edata
__bss_start
_end
GCC_3.0
GLIBC_2.2.5
GLIBC_2.14
u+UH
AVSH
[A^]
AVSH
~HH9
@[A^]
AWAVATSH
fffff.
 [A\A^A_]
AVSH
fffff.
@[A^]
AWAVATSH
0[A\A^A_]
AVSH
[A^]
[A^]
AVSH
 [A^]
 [A^]
AVSH
p[A^]
5S@6
AWAVATSH
\$(H
p[A\A^A_]
AWAVSH
h[A^A_]
52<6
AWAVSH
h[A^A_]
5>:6
AVSH
[A^]
[A^]
AVSH
[A^]
[A^]
AWAVSH
h[A^A_]
AVSH
tRHk
 [A^]
 [A^]
AWAVATSI
[A\A^A_]
[A\A^A_]
AVSH
[A^]
[A^]
AVSH
[A^]
[A^]
AWAVAUATSPI
[A\A]A^A_]
[A\A]A^A_]
AWAVATSH
t$@I
p[A\A^A_]
AVSI
[A^]
[A^]
AVSH
[A^]
[A^]
AVSI
[A^]
[A^]
AVSI
[A^]
[A^]
AWAVATSH
L$ H
T$0H
T$8H
fffff.
p[A\A^A_]
5W/6
AVSH
[A^]
[A^]
AWAVSPI
[A^A_]
[A^A_]
AWAVATSH
t$@I
p[A\A^A_]
5	-6
AVSH
[A^]
[A^]
AWAVATSH
Yffffff.
I;\$
[A\A^A_]
AWAVATSH
Yffffff.
I;\$
[A\A^A_]
AWAVATSH
0[A\A^A_]
AVSH
0[A^]
AVSH
0[A^]
AVSH
0[A^]
AVSH
0[A^]
AVSH
0[A^]
AVSH
0[A^]
AVSH
0[A^]
AVSH
0[A^]
AVSH
0[A^]
AVSH
0[A^]
AVSH
0[A^]
AVSH
0[A^]
AVSH
0[A^]
AVSH
0[A^]
AVSH
0[A^]
AVSH
0[A^]
AVSH
0[A^]
AVSH
0[A^]
AVSH
t=Hi
0[A^]
AVSH
0[A^]
AVSH
0[A^]
AVSH
t=Hi
0[A^]
AVSH
0[A^]
AVSH
0[A^]
AVSH
0[A^]
AVSH
0[A^]
AVSH
0[A^]
AVSH
0[A^]
AVSH
0[A^]
AVSH
0[A^]
AVSH
0[A^]
AVSH
t=Hi
0[A^]
AOq]
AWAVAUATS
+ffff.
[A\A]A^A_]
AWAVAUATSH
X[A\A]A^A_]
AWAVAUATSH
8[A\A]A^A_]
AVSH
P[A^]
AVSH
P[A^]
AWAVATSI
[A\A^A_]
AWAVATSI
[A\A^A_]
AWAVATSH
[A\A^A_]
AWAVAUATSPH
[A\A]A^A_]
AWAVAUATSPI
[A\A]A^A_]
AWAVSH
=Su6
[A^A_]
AWAVSH
AWAVATSH
 [A\A^A_]
AWAVAUATSH
fff.
([A\A]A^A_]
AWAVAUATSH
ffff.
[A\A]A^A_]
AVSH
0[A^]
AVSH
0[A^]
AVSH
0[A^]
AVSH
0[A^]
AVSH
0[A^]
AVSH
0[A^]
AVSH
t/Hi
0[A^]
AVSH
0[A^]
AVSH
t)Hk
0[A^]
AVSH
t,Hk
0[A^]
AVSH
0[A^]
AVSH
0[A^]
AVSH
0[A^]
AVSH
0[A^]
AVSH
0[A^]
AVSH
0[A^]
AVSH
0[A^]
AVSH
0[A^]
AVSH
0[A^]
AVSH
0[A^]
AVSH
0[A^]
AVSH
0[A^]
AVSH
0[A^]
AVSH
0[A^]
AVSH
0[A^]
AVSH
0[A^]
AVSH
0[A^]
AVSH
t/Hi
0[A^]
AVSH
0[A^]
AVSH
0[A^]
AVSH
0[A^]
AVSH
0[A^]
AVSH
0[A^]
AVSH
0[A^]
AVSH
0[A^]
AVSH
0[A^]
AVSH
0[A^]
AVSH
t/Hi
0[A^]
AWAVATSH
0[A\A^A_]
AWAVAUATSH
[A\A]A^A_]
ffffff.
AVSH
KHH;KPu
KHH9
@[A^]
AVSH
C H=
KXH9
S H9
S H)
KXH9
[A^]
AVSH
C H=
KXH9
S H9
S H)
KXH9
0[A^]
AVSH
[A^]
AWAVATSH
p[A\A^A_]
AWAVATSI
u	[A\A^A_]
[A\A^A_]
AVSH
8[A^]
AVSI
[A^]
[A^]
[A^]
[A^]
[A^]
[A^]
[A^]
[A^]
AWAVSPI
4@fff.
[A^A_]
[A^A_]
AWAVAUATSH
%w"H
ffffff.
[A\A]A^A_]
ffffff.
D$(H
D$8H
l$(H
 H;]
D$0H
D$(H
D$ H
D$ H
|$ I
D$0H
\$ L
t$(H
t$ I
[A\A]A^A_]
fff.
[A\A]A^A_]
[A\A]A^A_]
[A\A]A^A_]
[A\A]A^A_]
ffff.
ffff.
fffff.
fffff.
t%fffff.
AWAVAUATSH
3H;s
fffff.
3H;s
[A\A]A^A_]
AWAVATSI
[A\A^A_]
[A\A^A_]
t!f.
AWAVAUATSPI
<@fffff.
t$ H
|$0I
\$0I
D$@H
D$8H
[A\A]A^A_]
[A\A]A^A_]
t$ffff.
AWAVAUATSPI
[A\A]A^A_]
[A\A]A^A_]
t)I)
AVSH
[A^]
[A^]
AWAVATSI
[A\A^A_]
C(H9
tGf.
AWAVATSI
ffffff.
[A\A^A_]
[A\A^A_]
AWAVATSI
[A\A^A_]
[A\A^A_]
AWAVSPI
[A^A_]
AWAVSPI
[A^A_]
[A^A_]
AWAVAUATSPI
D$ H
,@ff.
\$(H
t$0H
|$@I
\$@I
D$PH
D$HH
[A\A]A^A_]
[A\A]A^A_]
AVSH
tZHk
 [A^]
 [A^]
AVSH
 [A^]
 [A^]
AWAVSH
h[A^A_]
AVSH
[A^]
[A^]
AWAVATSI
[A\A^A_]
[A\A^A_]
AWAVATSI
[A\A^A_]
[A\A^A_]
AVSH
[A^]
[A^]
AWAVAUATSH
t$(M
t$(M
t$(H
t$(M
fffff.
t$ H
H[A\A]A^A_]
H[A\A]A^A_]
AVSH
[A^]
[A^]
=_{5
= z5
AVSH
[A^]
AWAVSPI
ffffff.
[A^A_]
[A^A_]
AVSH
tAffffff.
p[A^]
AWAVSPI
[A^A_]
AWAVSPH
[A^A_]
AWAVAUATSPI
[A\A]A^A_]
AWAVAUATSPI
[A\A]A^A_]
[A\A]A^A_]
t2I)
ffff.
AWAVATSH
 [A\A^A_]
 [A\A^A_]
AWAVATSH
tqLk
pffff.
[A\A^A_]
AWAVAUATSH
\'`H
t'hH
X[A\A]A^A_]
X[A\A]A^A_]
AVSH
[A^]
[A^]
AWAVSPI
[A^A_]
[A^A_]
AWAVAUATSPI
D$(H
\$ H
D$(H
[A\A]A^A_]
[A\A]A^A_]
fffff.
|$ I
fff.
AWAVAUATSH
8[A\A]A^A_]
8[A\A]A^A_]
=@j5
AWAVSPH
[A^A_]
[A^A_]
AVSH
H;C tAL
fffff.
H;C u
[A^]
=;u5
AWAVAUATSPI
,@ff.
[A\A]A^A_]
t&ffffff.
AWAVAUATSH
ffffff.
([A\A]A^A_]
([A\A]A^A_]
AWAVAUATSPI
[A\A]A^A_]
[A\A]A^A_]
AWAVAUATSPI
[A\A]A^A_]
$@fffff.
[A\A]A^A_]
AWAVAUATSH
D$(H
D$(I
t$(M
t$(M
t$ H
8[A\A]A^A_]
8[A\A]A^A_]
AWAVSH
[A^A_]
[A^A_]
=k_5
=?^5
=7]5
AWAVAUATSH
ffffff.
t"Hi
[A\A]A^A_]
[A\A]A^A_]
 ffff.
=<Z5
AVSH
[A^]
[A^]
AWAVSPI
[A^A_]
AWAVATSI
ffffff.
[A\A^A_]
[A\A^A_]
AWAVAUATSH
fffff.
H[A\A]A^A_]
H[A\A]A^A_]
AWAVAUATSPI
[A\A]A^A_]
[A\A]A^A_]
AWAVATSH
 [A\A^A_]
 [A\A^A_]
=QQ5
AWAVAUATSPI
gHLk
pffff.
t#Hk
[A\A]A^A_]
[A\A]A^A_]
AWAVAUATSH
[A\A]A^A_]
[A\A]A^A_]
AWAVAUATSH
[A\A]A^A_]
[A\A]A^A_]
AVSH
[A^]
AVSH
8[A^]
AVSH
[A^]
[A^]
AVSH
[A^]
[A^]
[A^]
AWAVAUATSH
H;s tvL
H;s u
ffffff.
[A\A]A^A_]
=$V5
AWAVAUATSH
8[A\A]A^A_]
8[A\A]A^A_]
AWAVATSI
t	[A\A^A_]
fffff.
[A\A^A_]
AVSH
[A^]
AVSH
[A^]
AWAVAUATSH
([A\A]A^A_]
$@ffffff.
([A\A]A^A_]
=Y@5
AWAVAUATSH
[A\A]A^A_]
[A\A]A^A_]
AWAVATSI
[A\A^A_]
[A\A^A_]
t!f.
AWAVATSI
[A\A^A_]
[A\A^A_]
AWAVSPI
[A^A_]
[A^A_]
=W<5
AVSH
[A^]
[A^]
AVSH
[A^]
[A^]
AWAVATSI
[A\A^A_]
[A\A^A_]
=H95
=p75
=`65
AWAVAUATSPI
t$HM
|$HI
D$XH
D$PH
|$xI
\$xMi
[A\A]A^A_]
\$HH
D$PH
|$`I
\$`Mit$p
ffffff.
[A\A]A^A_]
\$HH
D$PH
Mit$
[A\A]A^A_]
[A\A]A^A_]
tKHi
D$hH
t8Hi
t"Hi
[A\A]A^A_]
[A\A]A^A_]
ffff.
AWAVATSH
ffff.
 [A\A^A_]
 [A\A^A_]
AWAVAUATSH
[A\A]A^A_]
[A\A]A^A_]
AVSH
8[A^]
AWAVSPI
[A^A_]
<@ffffff.
[A^A_]
AWAVAUATSPI
[A\A]A^A_]
[A\A]A^A_]
t,I)
AWAVSPI
<@ff.
[A^A_]
[A^A_]
AVSH
[A^]
[A^]
AVSH
[A^]
[A^]
AWAVSH
fffff.
([A^A_]
AWAVATSH
 [A\A^A_]
 [A\A^A_]
AWAVAUATSPI
[A\A]A^A_]
$@fff.
[A\A]A^A_]
AVSH
[A^]
[A^]
AWAVAUATSPI
[A\A]A^A_]
[A\A]A^A_]
AVSH
[A^]
AVSH
[A^]
[A^]
AWAVATSI
[A\A^A_]
[A\A^A_]
ffffff.
AWAVATSI
[A\A^A_]
[A\A^A_]
AWAVAUATSH
fff.
[A\A]A^A_]
[A\A]A^A_]
AWAVAUATSPI
[A\A]A^A_]
AWAVAUATSH
fffff.
scIk
[A\A]A^A_]
AWAVAUATSH
$@ff.
ffffff.
fffff.
8[A\A]A^A_]
8[A\A]A^A_]
AWAVAUATSH
D7HH
|18H
@fff.
D7@H
H[A\A]A^A_]
H[A\A]A^A_]
AWAVSPI
fffff.
[A^A_]
[A^A_]
AWAVATSI
[A\A^A_]
AWAVAUATSPI
D$(H
D$ H
[A\A]A^A_]
[A\A]A^A_]
t#fff.
 ff.
AVSH
[A^]
AWAVATSI
[A\A^A_]
[A\A^A_]
AWAVSPI
[A^A_]
[A^A_]
AWAVSPI
fffff.
[A^A_]
[A^A_]
AWAVAUATSH
[A\A]A^A_]
[A\A]A^A_]
AWAVAUATSPI
<@fffff.
|$pI
[A\A]A^A_]
[A\A]A^A_]
t$ffff.
AWAVAUATSH
[A\A]A^A_]
[A\A]A^A_]
AVSH
[A^]
[A^]
[A^]
[A^]
AVSH
[A^]
[A^]
AVSH
[A^]
AVSH
[A^]
[A^]
AWAVSPI
[A^A_]
AWAVSPI
fffff.
[A^A_]
[A^A_]
AWAVATSH
 [A\A^A_]
 [A\A^A_]
AWAVSPI
4@ffffff.
[A^A_]
[A^A_]
AWAVSPI
<@fff.
<@fff.
[A^A_]
[A^A_]
AWAVATSH
fff.
 [A\A^A_]
 [A\A^A_]
AWAVSPI
fffff.
[A^A_]
[A^A_]
AWAVSPI
[A^A_]
AWAVSPI
<@f.
[A^A_]
[A^A_]
AWAVAUATSH
3H;s
fffff.
3H;s
[A\A]A^A_]
AWAVATSI
[A\A^A_]
[A\A^A_]
AWAVSPI
ffffff.
[A^A_]
[A^A_]
AWAVAUATSPI
[A\A]A^A_]
t$ I
D$0H
\$ H
D$(H
[A\A]A^A_]
AWAVATSI
[A\A^A_]
[A\A^A_]
t*ffff.
AWAVATSI
[A\A^A_]
[A\A^A_]
t*ffff.
AWAVAUATSPI
[A\A]A^A_]
AWAVATSI
[A\A^A_]
[A\A^A_]
AVSH
[A^]
[A^]
AWAVSPI
[A^A_]
[A^A_]
AWAVAUATSH
[A\A]A^A_]
[A\A]A^A_]
AWAVATSI
fffff.
[A\A^A_]
[A\A^A_]
AWAVSPI
fffff.
[A^A_]
[A^A_]
AWAVSPL
t3ffff.
[A^A_]
AWAVATSI
[A\A^A_]
[A\A^A_]
AWAVSPI
fffff.
[A^A_]
[A^A_]
AWAVAUATSPI
(ffffff.
[A\A]A^A_]
[A\A]A^A_]
AWAVAUATSPI
|$(I
\$(I
D$8H
D$0H
[A\A]A^A_]
[A\A]A^A_]
AWAVAUATSPH
[A\A]A^A_]
[A\A]A^A_]
t$M)
AVSH
[A^]
[A^]
AWAVAUATSH
[A\A]A^A_]
[A\A]A^A_]
AWAVAUATSPI
[A\A]A^A_]
[A\A]A^A_]
t-I)
AWAVAUATSH
[A\A]A^A_]
[A\A]A^A_]
AWAVSPH
[A^A_]
[A^A_]
AWAVSPI
fffff.
[A^A_]
[A^A_]
AWAVAUATSPI
$@ff.
[A\A]A^A_]
AWAVATSI
[A\A^A_]
[A\A^A_]
AVSH
[A^]
[A^]
tCf.
t=f.
AWAVSH
[A^A_]
AWAVAUATSH
8fff.
8fff.
([A\A]A^A_]
([A\A]A^A_]
AWAVAUATSH
ffffff.
H[A\A]A^A_]
H[A\A]A^A_]
AWAVSPI
<@ffffff.
[A^A_]
[A^A_]
AWAVATSH
 [A\A^A_]
 [A\A^A_]
AWAVSPI
<@ff.
[A^A_]
[A^A_]
AWAVAUATSPI
D$ H
[A\A]A^A_]
[A\A]A^A_]
AWAVATSI
[A\A^A_]
[A\A^A_]
AWAVATSI
[A\A^A_]
fff.
AWAVAUATSPI
\$ M
l$(I
fffff.
t$(H
[A\A]A^A_]
|$ I
AWAVATSI
[A\A^A_]
[A\A^A_]
t*ffff.
AWAVATSI
[A\A^A_]
[A\A^A_]
AVSH
	wQH
g[A^]
[A^]
[A^]
[A^]
AWAVATSI
[A\A^A_]
[A\A^A_]
t!f.
AWAVATSI
[A\A^A_]
[A\A^A_]
AWAVATSH
fff.
 [A\A^A_]
 [A\A^A_]
AWAVATSH
 [A\A^A_]
 [A\A^A_]
AWAVSH
4@ffff.
[A^A_]
AWAVAUATSPI
[A\A]A^A_]
l$ I
fff.
[A\A]A^A_]
D$ H
[A\A]A^A_]
[A\A]A^A_]
[A\A]A^A_]
(fff.
AWAVSPH
[A^A_]
AVSH
[A^]
[A^]
AWAVAUATSPI
[A\A]A^A_]
[A\A]A^A_]
[A\A]A^A_]
[A\A]A^A_]
[A\A]A^A_]
fffff.
ffff.
[A\A]A^A_]
[A\A]A^A_]
[A\A]A^A_]
[A\A]A^A_]
[A\A]A^A_]
[A\A]A^A_]
?#uLM
[A\A]A^A_]
AWAVAUATSH
ffffff.
([A\A]A^A_]
([A\A]A^A_]
AWAVAUATSH
[A\A]A^A_]
AWAVAUATSH
[A\A]A^A_]
[A\A]A^A_]
AWAVAUATSPI
|$ H
[A\A]A^A_]
[A\A]A^A_]
[A\A]A^A_]
[A\A]A^A_]
[A\A]A^A_]
AWAVSPI
fffff.
[A^A_]
[A^A_]
AVSH
[A^]
[A^]
[A^]
AWAVATSI
fffff.
[A\A^A_]
[A\A^A_]
AWAVAUATSPI
[A\A]A^A_]
AWAVAUATSPH
pffffff.
[A\A]A^A_]
AWAVATSH
 [A\A^A_]
 [A\A^A_]
AWAVAUATSH
[A\A]A^A_]
[A\A]A^A_]
AVSH
[A^]
[A^]
AWAVAUATSH
ffffff.
D$PH
D$pH
[A\A]A^A_]
AWAVAUATSH
fffff.
fffff.
[A\A]A^A_]
[A\A]A^A_]
AWAVSPI
[A^A_]
[A^A_]
AVSH
[A^]
[A^]
AVSH
 [A^]
 [A^]
AWAVSH
[A^A_]
[A^A_]
AWAVAUATSPI
t$(H
t$@H
t$`M
\$PH
ffffff.
t$XH
|$hI
|$hM
l$xI
t$pH
[A\A]A^A_]
[A\A]A^A_]
AVSH
[A^]
AWAVAUATSH
([A\A]A^A_]
([A\A]A^A_]
AWAVATSI
[A\A^A_]
[A\A^A_]
ffffff.
AWAVATSI
[A\A^A_]
[A\A^A_]
t&ffffff.
AVSH
[A^]
AVSH
p[A^]
AWAVAUATSH
ffffff.
([A\A]A^A_]
([A\A]A^A_]
AWAVSPI
ffffff.
[A^A_]
[A^A_]
AWAVAUATSPI
|$ I
\$ I
D$0H
D$(H
[A\A]A^A_]
[A\A]A^A_]
t"ff.
AVSH
 [A^]
 [A^]
AVSH
[A^]
[A^]
AWAVSPH
[A^A_]
AWAVAUATSPI
[A\A]A^A_]
t$ I
D$0H
\$ H
D$(H
[A\A]A^A_]
[A\A]A^A_]
AWAVAUATSH
([A\A]A^A_]
([A\A]A^A_]
=-{4
AWAVAUATSH
D$ H
Ikt$ XH
Mkt$ 8fffff.
Ikt$ 8H
t$PH
([A\A]A^A_]
t$ffff.
t!f.
AWAVSPI
<@ff.
[A^A_]
[A^A_]
AWAVAUATSH
t$(M
t$(M
r-f.
t$(H
t$(M
t$ H
H[A\A]A^A_]
H[A\A]A^A_]
=ks4
AWAVAUATSH
[A\A]A^A_]
[A\A]A^A_]
AWAVSPI
fffff.
[A^A_]
[A^A_]
AVSH
[A^]
[A^]
AWAVATSH
 [A\A^A_]
 [A\A^A_]
AWAVSPI
fffff.
[A^A_]
[A^A_]
AVSH
[A^]
AVSH
[A^]
[A^]
AWAVSPI
[A^A_]
[A^A_]
AVSI
[A^]
AWAVAUATSH
fffff.
t2ff.
[A\A]A^A_]
AWAVAUATSH
fffff.
h[A\A]A^A_]
AWAVAUATSPI
$@E1
[A\A]A^A_]
[A\A]A^A_]
t'M)
=0]4
AWAVAUATSPI
ffff.
[A\A]A^A_]
[A\A]A^A_]
t-I)
AWAVAUATSH
fff.
([A\A]A^A_]
([A\A]A^A_]
=\Z4
AWAVAUATSH
[A\A]A^A_]
[A\A]A^A_]
=QX4
AWAVATSH
 [A\A^A_]
 [A\A^A_]
=TW4
AWAVATSI
fffff.
[A\A^A_]
[A\A^A_]
AWAVAUATSPI
|$ I
D$0H
\$ Lk
8ffff.
D$(H
4@ffffff.
fff.
[A\A]A^A_]
[A\A]A^A_]
=CS4
AWAVATSH
ffff.
 [A\A^A_]
 [A\A^A_]
AVSH
[A^]
AVSH
[A^]
[A^]
AWAVAUATSPI
[A\A]A^A_]
[A\A]A^A_]
t%fffff.
AVSH
8[A^]
AWAVATSH
 [A\A^A_]
 [A\A^A_]
AWAVAUATSPI
ffff.
[A\A]A^A_]
[A\A]A^A_]
t(I)
AWAVSPI
[A^A_]
[A^A_]
AWAVAUATSH
ffffff.
fffff.
D$(H
D$(H
X[A\A]A^A_]
X[A\A]A^A_]
=(H4
AVSH
H H9
P[A^]
AWAVAUATSH
[A\A]A^A_]
[A\A]A^A_]
AVSH
@[A^]
@[A^]
AWAVATSI
fffff.
[A\A^A_]
[A\A^A_]
=O@4
AVSH
8[A^]
AWAVAUATSH
4@ffffff.
[A\A]A^A_]
[A\A]A^A_]
AWAVAUATSPI
[A\A]A^A_]
[A\A]A^A_]
[A\A]A^A_]
<@fff.
[A\A]A^A_]
fff.
=k;4
AWAVSPI
<@fff.
<@fff.
<@f.
[A^A_]
[A^A_]
AVSH
[A^]
[A^]
AWAVATSH
 [A\A^A_]
 [A\A^A_]
AWAVAUATSPI
[A\A]A^A_]
fffff.
AVSH
 [A^]
 [A^]
AWAVAUATSPI
[A\A]A^A_]
[A\A]A^A_]
t"ff.
AWAVATSI
[A\A^A_]
[A\A^A_]
AWAVAUATSH
\$8M
t$@I
t$@H
l$`A
[A\A]A^A_]
[A\A]A^A_]
t'ffffff.
|$8I
fff.
AWAVATSH
fff.
 [A\A^A_]
 [A\A^A_]
=P,4
AWAVAUATSH
t$(H
|$8H
|$@I
D$HH
|$@H
[A\A]A^A_]
[A\A]A^A_]
|$@I
AWAVAUATSH
ffffff.
fffff.
X[A\A]A^A_]
X[A\A]A^A_]
AWAVSPI
<@f.
[A^A_]
[A^A_]
AWAVAUATSH
D$ I
l$(M
L$0H
|$ I
|$0H
D$HH
\$8H
D$@H
|$XH
t$`H
t$xH
8[A\A]A^A_]
8[A\A]A^A_]
AVSH
[A^]
[A^]
AWAVATSH
 [A\A^A_]
 [A\A^A_]
AWAVSPI
ffffff.
[A^A_]
[A^A_]
AWAVATSH
 [A\A^A_]
 [A\A^A_]
AWAVSPH
[A^A_]
?#uHL
[A^A_]
[A^A_]
AWAVATSI
fffff.
[A\A^A_]
[A\A^A_]
AWAVAUATSPL
fff.
t*fffff.
[A\A]A^A_]
AVSH
p[A^]
AWAVSPI
[A^A_]
[A^A_]
AWAVATSH
3H;s
3H;s
0[A\A^A_]
=`"4
AVSH
[A^]
[A^]
AWAVAUATSH
[A\A]A^A_]
[A\A]A^A_]
AVSH
[A^]
[A^]
AWAVATSI
[A\A^A_]
[A\A^A_]
AWAVSPI
8ffffff.
[A^A_]
[A^A_]
tUHk
AVSH
[A^]
AWAVSPI
[A^A_]
[A^A_]
AWAVATSI
[A\A^A_]
[A\A^A_]
AWAVAUATSH
[A\A]A^A_]
=k	4
AWAVSPI
wxH9
[A^A_]
[A^A_]
AVSH
[A^]
[A^]
[A^]
AWAVAUATSPI
D$(H
,@ffff.
D$ H
[A\A]A^A_]
[A\A]A^A_]
AWAVATSI
[A\A^A_]
[A\A^A_]
0ffffff.
AWAVATSH
 [A\A^A_]
 [A\A^A_]
AVSH
[A^]
[A^]
AWAVATSI
[A\A^A_]
[A\A^A_]
Pffffff.
AWAVATSH
 [A\A^A_]
 [A\A^A_]
AWAVAUATSH
ffffff.
([A\A]A^A_]
([A\A]A^A_]
AWAVAUATSH
[A\A]A^A_]
[A\A]A^A_]
AVSH
H;C t3L
fffff.
H;C u
[A^]
fffff.
[A^]
AWAVSH
[A^A_]
[A^A_]
AWAVSPI
[A^A_]
[A^A_]
AWAVAUATSH
([A\A]A^A_]
([A\A]A^A_]
AVSH
H H9
P[A^]
AWAVSPI
<@ff.
[A^A_]
[A^A_]
AWAVSPH
 ff.
[A^A_]
AWAVSPI
[A^A_]
[A^A_]
AVSH
[A^]
AVSH
[A^]
[A^]
[A^]
AWAVAUATSPI
@ffff.
[A\A]A^A_]
[A\A]A^A_]
t!f.
AWAVAUATSPI
[A\A]A^A_]
[A\A]A^A_]
t#fff.
AWAVSPI
[A^A_]
AWAVSPH
[A^A_]
[A^A_]
AVSH
[A^]
AWAVAUATSH
fffff.
([A\A]A^A_]
([A\A]A^A_]
ffffff.
AWAVATSH
 [A\A^A_]
 [A\A^A_]
AVSH
[A^]
[A^]
AWAVATSI
ffffff.
[A\A^A_]
[A\A^A_]
t&ffffff.
AWAVSPH
[A^A_]
?#uHL
[A^A_]
[A^A_]
AWAVAUATSH
fffff.
^fffff.
@ffffff.
[A\A]A^A_]
AVSH
[A^]
[A^]
AVSH
[A^]
[A^]
AWAVATSI
[A\A^A_]
[A\A^A_]
ffffff.
AVSH
[A^]
AWAVATSI
[A\A^A_]
[A\A^A_]
AWAVAUATSPI
[A\A]A^A_]
[A\A]A^A_]
AVSH
[A^]
[A^]
[A^]
AVSH
[A^]
[A^]
AVSH
 [A^]
 [A^]
AWAVATSH
 [A\A^A_]
 [A\A^A_]
AWAVAUATSPI
[A\A]A^A_]
[A\A]A^A_]
t.I)
AWAVAUATSH
ffff.
t2ff.
([A\A]A^A_]
([A\A]A^A_]
AWAVAUATSH
t.fffff.
t3fff.
([A\A]A^A_]
([A\A]A^A_]
AWAVAUATSH
fff.
([A\A]A^A_]
([A\A]A^A_]
AWAVATSH
 [A\A^A_]
 [A\A^A_]
AWAVAUATSPI
[A\A]A^A_]
[A\A]A^A_]
[A\A]A^A_]
t=f.
AWAVAUATSH
ffffff.
([A\A]A^A_]
([A\A]A^A_]
AVSH
 [A^]
AWAVSPI
[A^A_]
[A^A_]
AVSH
 [A^]
AVSH
[A^]
[A^]
AWAVAUATSH
ffffff.
([A\A]A^A_]
([A\A]A^A_]
AVSH
[A^]
[A^]
AWAVSPI
[A^A_]
[A^A_]
AVSH
[A^]
[A^]
AWAVATSH
 [A\A^A_]
 [A\A^A_]
AWAVAUATSH
[A\A]A^A_]
[A\A]A^A_]
AVSH
[A^]
[A^]
AVSH
[A^]
AWAVATSI
[A\A^A_]
[A\A^A_]
AWAVATSH
fff.
 [A\A^A_]
 [A\A^A_]
AWAVAUATSPI
<@fffff.
D$(H
t$ H
[A\A]A^A_]
AWAVSPI
[A^A_]
AVSH
[A^]
[A^]
AWAVAUATSPI
[A\A]A^A_]
[A\A]A^A_]
0fff.
AWAVSPI
fffff.
[A^A_]
[A^A_]
AVSH
[A^]
[A^]
AWAVSPI
fffff.
[A^A_]
[A^A_]
AWAVAUATSH
fffff.
rTfffff.
t2ffffff.
([A\A]A^A_]
([A\A]A^A_]
AWAVSPI
<@ff.
[A^A_]
[A^A_]
AVSH
 [A^]
 [A^]
AWAVSPI
ffffff.
[A^A_]
[A^A_]
AWAVAUATSPI
$@fff.
[A\A]A^A_]
t!f.
AWAVSPI
ffffff.
[A^A_]
[A^A_]
AVSH
[A^]
[A^]
AWAVAUATSH
[A\A]A^A_]
[A\A]A^A_]
AWAVATSH
fff.
 [A\A^A_]
 [A\A^A_]
AWAVAUATSPI
\$ I
[A\A]A^A_]
[A\A]A^A_]
 ff.
AVSH
8[A^]
AWAVATSI
[A\A^A_]
[A\A^A_]
t(ff.
AVSH
[A^]
AWAVATSH
 [A\A^A_]
 [A\A^A_]
t"ff.
AWAVAUATSH
fffff.
sLIi
ffffff.
^fffff.
[A\A]A^A_]
AWAVAUATSH
([A\A]A^A_]
([A\A]A^A_]
AVSH
[A^]
AWAVAUATSPI
l$ M
|$(M
l$8M
\$(I
ffffff.
t$0H
t$HH
[A\A]A^A_]
[A\A]A^A_]
t#fff.
AWAVATSI
[A\A^A_]
[A\A^A_]
AWAVATSI
[A\A^A_]
[A\A^A_]
AVSH
[A^]
[A^]
AVSH
[A^]
[A^]
[A^]
[A^]
AWAVAUATSPI
[A\A]A^A_]
[A\A]A^A_]
[A\A]A^A_]
[A\A]A^A_]
[A\A]A^A_]
AVSH
[A^]
[A^]
AVSH
[A^]
[A^]
AVSH
[A^]
[A^]
AWAVAUATSH
([A\A]A^A_]
ffffff.
([A\A]A^A_]
=tq3
=fq3
=Xq3
t!f.
AWAVAUATSH
H;s 
H;s u
[A\A]A^A_]
AVSH
[A^]
[A^]
AWAVAUATSH
[A\A]A^A_]
[A\A]A^A_]
AVSH
[A^]
tUHk
AVSH
[A^]
[A^]
AWAVATSH
 [A\A^A_]
 [A\A^A_]
AVSH
[A^]
AWAVAUATSH
fffff.
,4E1
h[A\A]A^A_]
h[A\A]A^A_]
=Wg3
AWAVAUATSH
[A\A]A^A_]
[A\A]A^A_]
AVSH
[A^]
AWAVATSI
[A\A^A_]
[A\A^A_]
AWAVATSI
[A\A^A_]
[A\A^A_]
AWAVAUATSH
t$(M
t$(M
ffff.
t$(H
t$(M
t$ H
H[A\A]A^A_]
H[A\A]A^A_]
AWAVSPI
<@f.
[A^A_]
[A^A_]
AVSH
[A^]
AWAVATSI
ffffff.
[A\A^A_]
[A\A^A_]
t&ffffff.
AVSH
[A^]
AWAVAUATSH
[A\A]A^A_]
[A\A]A^A_]
=]\3
AWAVSPI
[A^A_]
AVSH
[A^]
[A^]
=,Z3
AVSH
[A^]
AWAVATSI
[A\A^A_]
[A\A^A_]
Pffffff.
AVSH
[A^]
[A^]
AVSH
[A^]
[A^]
AWAVAUATSH
[A\A]A^A_]
[A\A]A^A_]
=:W3
AWAVATSI
[A\A^A_]
[A\A^A_]
=|U3
AWAVSPI
[A^A_]
[A^A_]
AWAVATSI
[A\A^A_]
[A\A^A_]
AWAVSPI
fffff.
[A^A_]
[A^A_]
AWAVAUATSPI
[A\A]A^A_]
[A\A]A^A_]
t*I)
AWAVAUATSPI
$Mi|$
D$ H
|$0H
D$8H
|$HI
\$HMil$X
D$PH
|$hH
|$pH
t$xH
[A\A]A^A_]
[A\A]A^A_]
t+fffff.
AVSH
[A^]
[A^]
AWAVSPI
<@ff.
[A^A_]
[A^A_]
AWAVSPI
[A^A_]
[A^A_]
AWAVATSI
[A\A^A_]
[A\A^A_]
t*ffff.
AWAVAUATSPI
[A\A]A^A_]
[A\A]A^A_]
t"ff.
AWAVAUATSH
ffffff.
ffffff.
ffffff.
t6ffffff.
8[A\A]A^A_]
8[A\A]A^A_]
AVSH
[A^]
AWAVSPI
fffff.
[A^A_]
[A^A_]
=7?3
AWAVAUATSPI
[A\A]A^A_]
[A\A]A^A_]
t"ff.
t=f.
AWAVATSI
[A\A^A_]
AWAVATSI
fffff.
[A\A^A_]
[A\A^A_]
AWAVAUATSH
[A\A]A^A_]
[A\A]A^A_]
AVSH
[A^]
[A^]
[A^]
AVSH
[A^]
[A^]
AWAVATSI
[A\A^A_]
[A\A^A_]
AVSH
8[A^]
AVSH
[A^]
AVSH
[A^]
AWAVAUATSH
[A\A]A^A_]
[A\A]A^A_]
=:43
AWAVAUATSH
ffffff.
([A\A]A^A_]
([A\A]A^A_]
AWAVSPI
[A^A_]
[A^A_]
AVSH
[A^]
AWAVAUATSH
ffffff.
([A\A]A^A_]
([A\A]A^A_]
AWAVATSI
[A\A^A_]
[A\A^A_]
AWAVAUATSH
[A\A]A^A_]
[A\A]A^A_]
=Z-3
AVSH
tRHk
 [A^]
=)+3
tUHk
AWAVATSI
[A\A^A_]
[A\A^A_]
ffffff.
AWAVATSH
 [A\A^A_]
 [A\A^A_]
AVSH
[A^]
[A^]
AVSH
[A^]
[A^]
[A^]
[A^]
[A^]
=g%3
AVSH
[A^]
AWAVAUATSPI
$@E1
4@ffff.
[A\A]A^A_]
[A\A]A^A_]
[A\A]A^A_]
[A\A]A^A_]
[A\A]A^A_]
[A\A]A^A_]
[A\A]A^A_]
[A\A]A^A_]
t,M)
AVSH
[A^]
[A^]
AWAVATSH
ffff.
 [A\A^A_]
 [A\A^A_]
AWAVSPH
ffffff.
[A^A_]
AVSH
[A^]
[A^]
AWAVAUATSH
t$(M
t$(M
t$(H
t$(M
t$ H
H[A\A]A^A_]
H[A\A]A^A_]
AWAVAUATSH
fff.
[A\A]A^A_]
[A\A]A^A_]
AWAVSPI
[A^A_]
AVSH
[A^]
[A^]
0ff.
AWAVATSH
H;C tML
H;C u
@[A\A^A_]
AVSH
[A^]
[A^]
[A^]
AWAVATSI
[A\A^A_]
[A\A^A_]
t*ffff.
AVSH
[A^]
[A^]
AWAVAUATSH
H[A\A]A^A_]
H[A\A]A^A_]
AVSH
[A^]
[A^]
[A^]
AWAVAUATSH
ffffff.
([A\A]A^A_]
([A\A]A^A_]
AVSH
[A^]
[A^]
AWAVSPI
4@ff.
4@fff.
[A^A_]
[A^A_]
AWAVAUATSH
[A\A]A^A_]
[A\A]A^A_]
AWAVAUATSPI
\$8H
[A\A]A^A_]
[A\A]A^A_]
AWAVAUATSH
ffff.
([A\A]A^A_]
([A\A]A^A_]
AWAVATSI
[A\A^A_]
[A\A^A_]
AWAVSPI
[A^A_]
[A^A_]
AWAVATSH
fff.
 [A\A^A_]
 [A\A^A_]
AVSH
[A^]
[A^]
AWAVAUATSH
[A\A]A^A_]
[A\A]A^A_]
AWAVAUATSPI
D$(H
D$ H
[A\A]A^A_]
[A\A]A^A_]
fff.
[A\A]A^A_]
[A\A]A^A_]
AWAVAUATSH
ffffff.
([A\A]A^A_]
([A\A]A^A_]
AWAVATSH
fff.
 [A\A^A_]
 [A\A^A_]
tCf.
AWAVSPH
[A^A_]
AWAVATSI
[A\A^A_]
[A\A^A_]
AWAVATSI
[A\A^A_]
[A\A^A_]
AWAVATSH
fff.
 [A\A^A_]
 [A\A^A_]
AVSH
[A^]
[A^]
AVSH
3H;s
3H;s
[A^]
AWAVATSI
[A\A^A_]
[A\A^A_]
AWAVAUATSPI
[A\A]A^A_]
[A\A]A^A_]
AVSH
[A^]
[A^]
AWAVATSI
fffff.
[A\A^A_]
[A\A^A_]
ffff.
AWAVAUATSH
[A\A]A^A_]
[A\A]A^A_]
AVSH
[A^]
[A^]
AVSH
[A^]
[A^]
AWAVAUATSH
fffff.
8[A\A]A^A_]
8[A\A]A^A_]
AWAVATSI
@fffff.
[A\A^A_]
[A\A^A_]
ffffff.
r_fffff.
AWAVAUATSH
D$(H
D$(I
t$(M
t$(M
t$ H
t$@H
8[A\A]A^A_]
AVSH
[A^]
[A^]
AWAVAUATSPI
|$0I
\$0Mil$@
fff.
|$XI
\$XMil$h
D$8H
D$`H
[A\A]A^A_]
[A\A]A^A_]
t)fff.
AVSH
[A^]
[A^]
AWAVSH
[A^A_]
[A^A_]
AWAVAUATSH
ffffff.
([A\A]A^A_]
([A\A]A^A_]
AWAVAUATSPI
	w-H
D$(H
\$ L
D$(H
\$ H
fff.
D$(H
D$(H
\$ L
fffff.
t$(H
[A\A]A^A_]
fffff.
|$ I
|$ I
fff.
AVSH
[A^]
AVSH
[A^]
[A^]
AWAVSPI
<@ff.
[A^A_]
[A^A_]
AWAVATSI
[A\A^A_]
AWAVSPI
ffffff.
[A^A_]
[A^A_]
AWAVSH
[A^A_]
AVSH
[A^]
AWAVSPI
fffff.
[A^A_]
[A^A_]
AWAVAUATSH
[A\A]A^A_]
[A\A]A^A_]
AVSH
8[A^]
AWAVATSH
 [A\A^A_]
 [A\A^A_]
AVSH
[A^]
AWAVATSI
t	[A\A^A_]
[A\A^A_]
AWAVAUATSPI
,@ff.
[A\A]A^A_]
[A\A]A^A_]
AWAVSPI
[A^A_]
[A^A_]
AVSH
[A^]
AVSH
[A^]
[A^]
AWAVSH
[A^A_]
[A^A_]
AWAVSPI
ffffff.
[A^A_]
[A^A_]
AWAVAUATSH
ffffff.
fffff.
fff.
H[A\A]A^A_]
H[A\A]A^A_]
AVSH
[A^]
[A^]
AWAVATSH
 [A\A^A_]
 [A\A^A_]
AWAVSPI
fffff.
[A^A_]
[A^A_]
AWAVAUATSPI
[A\A]A^A_]
[A\A]A^A_]
AVSH
[A^]
AWAVAUATSPI
[A\A]A^A_]
ffffff.
[A\A]A^A_]
|$(I
D$8H
\$(L
D$(H
fffff.
D$ H
ffff.
[A\A]A^A_]
[A\A]A^A_]
|$ H
|$(I
D$8H
\$(L
t$0H
[A\A]A^A_]
ffffff.
t&ffffff.
AWAVAUATSH
([A\A]A^A_]
([A\A]A^A_]
AVSH
[A^]
[A^]
AWAVAUATSPI
[A\A]A^A_]
t.M)
Hffff.
AWAVAUATSH
[A\A]A^A_]
fffff.
[A\A]A^A_]
[A\A]A^A_]
[A\A]A^A_]
[A\A]A^A_]
[A\A]A^A_]
[A\A]A^A_]
t!f.
ffff.
AWAVAUATSPI
ffffff.
[A\A]A^A_]
[A\A]A^A_]
AWAVSPI
[A^A_]
AVSH
[A^]
AWAVAUATSH
|$(M
|$(M
|$(H
t$(M
t$ H
ffff.
H[A\A]A^A_]
H[A\A]A^A_]
AWAVATSI
ffffff.
[A\A^A_]
[A\A^A_]
AVSH
[A^]
[A^]
[A^]
[A^]
[A^]
AWAVSPI
fffff.
[A^A_]
[A^A_]
AWAVSH
[A^A_]
[A^A_]
AVSH
[A^]
[A^]
AVSH
[A^]
AVSH
[A^]
[A^]
AWAVSPI
[A^A_]
[A^A_]
AVSH
[A^]
[A^]
AVSH
[A^]
[A^]
AWAVAUATSH
D$(H
D$(I
t$(M
t$(M
t$ H
8[A\A]A^A_]
8[A\A]A^A_]
AWAVATSI
[A\A^A_]
[A\A^A_]
AWAVSPI
[A^A_]
[A^A_]
AVSH
tZHk
 [A^]
 [A^]
=nk2
=]k2
=Lk2
=;k2
=*k2
=oj2
=^j2
=Mj2
=<j2
=+j2
=	j2
=pi2
=_i2
=Ni2
==i2
=,i2
=qh2
=`h2
=Oh2
=>h2
=-h2
=rg2
=ag2
=Pg2
=?g2
=.g2
= g2
AWAVAUATSH
^0L9
/fff.
[A\A]A^A_]
=C_2
=G_2
AVSH
ffff.
[A^]
5!]2
5j[2
5*Z2
AVSH
5JX2
AVSH
AVSH
5:U2
AWAVAUATSH
H[A\A]A^A_]
AWAVAUATSH
X[A\A]A^A_]
AVSH
P[A^]
D$PH
L$pf
oD$P
)T$ 
D$PH
D$0H
(T$ 
AWAVAUATSH
[A\A]A^A_]
AWAVAUATSH
S0H9
-kQ2
x[A\A]A^A_]
AWAVATSH
`[A\A^A_]
AWAVAUATSH
[A\A]A^A_]
AWAVSH
[A^A_]
AWAVAUATSH
[A\A]A^A_]
AWAVAUATSH
T$0A
L$ A
[A\A]A^A_]
AWAVAUATSH
\$0A
T$ A
\$0A
T$ A
gfffffffL
[A\A]A^A_]
AWAVAUATSH
fffff.
r.I9
t=;H
8[A\A]A^A_]
AWAVAUATSH
\$0A
T$ A
\$(A
t$@H
[A\A]A^A_]
AWAVAUATSH
[A\A]A^A_]
AWAVAUATSH
\$0A
T$ A
[A\A]A^A_]
AWAVAUATSH
D$0H
L$ A
D$4L
[A\A]A^A_]
AWAVAUATSH
-fffff.
[A\A]A^A_]
AWAVAUATSH
H[A\A]A^A_]
AWAVAUATSH
([A\A]A^A_]
AWAVAUATSH
8[A\A]A^A_]
AWAVAUATSH
#fff.
[A\A]A^A_]
AWAVAUATSH
fff.
fffff.
<$M9
fffff.
ffffff.
fffff.
fffff.
[A\A]A^A_]
AWAVAUATSH
[A\A]A^A_]
AWAVAUATSH
[A\A]A^A_]
AWAVAUATSH
M9f(u#I
M9f@u#I
M9fXu
[A\A]A^A_]
AWAVAUATS
ffff.
ffffff.
fffff.
t	L9m
fff.
fffff.
ffff.
fffff.
[A\A]A^A_]
=$t1
AWAVAUATS
ffff.
ffffff.
fffff.
t	L9m
fff.
fffff.
ffff.
fffff.
[A\A]A^A_]
=1?1
AWAVAUATS
ffff.
ffffff.
fffff.
t	L9m
fff.
fffff.
ffff.
fffff.
[A\A]A^A_]
AWAVAUATS
ffff.
ffffff.
fffff.
t	L9m
fff.
fffff.
ffff.
fffff.
[A\A]A^A_]
ffff.
AWAVAUATS
ffff.
ffffff.
fffff.
t	L9m
fff.
fffff.
ffff.
fffff.
[A\A]A^A_]
AWAVAUATS
ffff.
fff.
ffff.
t	L9m
fffff.
ffff.
=hm	
=Ij	
=^h	
[A\A]A^A_]
=8n0
=Ay0
AVSH
AWAVSPI
AWAVATSH
@[A\A^A_]
AWAVAUATSH
[A\A]A^A_]
AWAVAUATSH
ffffff.
\(0B
T( B
@H;u
[A\A]A^A_]
AWAVAUATSH
[A\A]A^A_]
AWAVAUATSH
fff.
tYM)
ffffff.
[A\A]A^A_]
= F0
=pC0
=bC0
=TC0
=FC0
AWAVAUATSH
\$0A
T$ A
[A\A]A^A_]
AWAVAUATSH
[A\A]A^A_]
AWAVATSH
[A\A^A_]
AWAVAUATSH
ffffff.
[A\A]A^A_]
AWAVSH
([A^A_]
AWAVSH
([A^A_]
AWAVSH
([A^A_]
AWAVAUATSH
fffff.
[A\A]A^A_]
AWAVSH
([A^A_]
AWAVAUATSH
H[A\A]A^A_]
AWAVSH
([A^A_]
AWAVSH
([A^A_]
AWAVAUATSH
[A\A]A^A_]
AWAVSH
([A^A_]
AWAVSH
([A^A_]
AWAVAUATSH
tPM)
D$ I
L$0L
[A\A]A^A_]
AWAVAUATSH
uespemosH1
modnarodH1
arenegylH1
setybdetH
t4H9
rnL9
u#E9l
X[A\A]A^A_]
AWAVAUATSH
H[A\A]A^A_]
AWAVAUATSH
ffffff.
[A\A]A^A_]
AWAVAUATSH
\$PA
D$ H
D$0H
l$ H
D$(H
fff.
[A\A]A^A_]
AVSH
 [A^]
AVSH
0[A^]
AWAVAUATSH
l$0A
|$@H
t$ H
[A\A]A^A_]
AWAVAUATSH
8[A\A]A^A_]
AWAVAUATSH
[A\A]A^A_]
AWAVAUATSH
X[A\A]A^A_]
AWAVAUATSH
h[A\A]A^A_]
AWAVAUATSH
8[A\A]A^A_]
AWAVAUATSH
#uZM
[A\A]A^A_]
=ly/
=Py/
=4y/
=~x/
=ex/
AWAVAUATSH
T$ A
D$!L
[A\A]A^A_]
AWAVSH
[A^A_]
AWAVSH
[A^A_]
AWAVAUATSH
[A\A]A^A_]
AWAVAUATSH
t$ L
x[A\A]A^A_]
AWAVAUATSH
ffffff.
fff.
[A\A]A^A_]
AWAVSH
H[A^A_]
AWAVAUATSH
&w$L
[A\A]A^A_]
&wzH
t%fffff.
AWAVSH
X[A^A_]
AWAVAUATSH
[A\A]A^A_]
AWAVAUATSH
|$`H
D$8H
D$ H
D$ H
D$<H
\$pI
T$xA
)D$@H9
oD$@H
T$PH
fffff.
|$0H
D$PH
(D$@
H;|$(I
D$ H
t$hL
t$hf
t$0H
D$`H
(D$ 
[A\A]A^A_]
AWAVAUATSH
[A\A]A^A_]
AWAVATSH
P[A\A^A_]
AWAVAUATSH
D$PH
T$ A
\$0A
T$ A
[A\A]A^A_]
AWAVATSH
[A\A^A_]
AWAVAUATSH
[A\A]A^A_]
AWAVATSH
p[A\A^A_]
AWAVAUATSH
[A\A]A^A_]
AWAVAUATSH
|$0H
d$pA
|$PH
oVHA
|$HD
|$pH
|$pL
l$xH
D$,A
D$(A
oW f
|$pH
oD$p
l$(L
)D$pH
oD$pf
T$`H
)D$pH
D$,f
oT$p
)D$P
(\$P
)\$0
(\$0
T$Pf
\$pH
[A\A]A^A_]
(D$P
)D$0f
oD$0f
L$pH
AWAVAUATSH
_`Migp
_xMi
fffff.
t;Hi
t)Hi
[A\A]A^A_]
t+fffff.
t+fffff.
AWAVAUATSH
[A\A]A^A_]
AWAVAUATSH
o^Hf
oF`f
oT$ f
o]0f
[A\A]A^A_]
AWAVAUATSH
[A\A]A^A_]
AWAVAUATSH
x[A\A]A^A_]
AVSH
P[A^]
AWAVAUATSH
fff.
ffffff.
fffff.
fffff.
fffff.
T7 C
\70L
[A\A]A^A_]
AWAVSH
[A^A_]
AWAVAUATSH
[A\A]A^A_]
AWAVAUATSH
D$ E
\$8A
T$(A
[A\A]A^A_]
AWAVAUATSH
fffff.
|$ H
D$(E
[A\A]A^A_]
AWAVAUATSH
D$(A
\$8H
[A\A]A^A_]
==t.
="t.
AWAVAUATSH
fff.
ffff.
8[A\A]A^A_]
AWAVSH
[A^A_]
AWAVAUATSH
[A\A]A^A_]
AWAVAUATSH
t"L9
uSL9
 ffff.
|$ L
[A\A]A^A_]
u3I)
Dffffff.
"ffffff.
=1b.
=ra.
AWAVAUATSH
h[A\A]A^A_]
AWAVAUATSH
[A\A]A^A_]
AWAVATSH
0[A\A^A_]
AWAVAUATSH
uespemosH1
modnarodH1
arenegylH1
setybdetH
\$ H
rPH9
K;T(
4(H9u
x[A\A]A^A_]
AWAVATSH
tKE1
r=L9
L$ A
|$(A
\$,M
|$0I
D$8E
t$@L
0[A\A^A_]
AWAVAUATSH
rWL9
-ff.
[A\A]A^A_]
AWAVAUATSPA
rXL9
ffffff.
[A\A]A^A_]
AWAVAUATSH
t&H9
rfL9
[A\A]A^A_]
AWAVAUATSH
uespemosH1
modnarodH1
arenegylH1
setybdetH
t0H9
t$(H
L:0C
D: H
t2fff.
L=0C
D= H
[A\A]A^A_]
AWAVAUATSH
rWL9
-ff.
[A\A]A^A_]
AWAVAUATSH
fffff.
[A\A]A^A_]
=]-.
AWAVAUATSH
fffff.
ffffff.
[A\A]A^A_]
513.
AWAVAUATSH
fff.
[A\A]A^A_]
5#/.
AWAVAUATSH
fffff.
[A\A]A^A_]
==".
AWAVSH
[A^A_]
5i(.
AWAVAUATSH
[A\A]A^A_]
5J#.
AWAVAUATSH
fffff.
ffffff.
[A\A]A^A_]
AWAVAUATSH
x[A\A]A^A_]
AWAVAUATSH
8[A\A]A^A_]
AWAVAUATSH
8[A\A]A^A_]
AWAVSH
8[A^A_]
8[A^A_]
AWAVAUATSH
x[A\A]A^A_]
AWAVAUATSH
[A\A]A^A_]
AWAVSH
8[A^A_]
AWAVAUATSH
fffff.
8[A\A]A^A_]
AWAVAUATSH
d$@L
t$0H
t$0H
|$(L
D$ H
D$(<
t$8H
t$8H
(T$`
(\$p
D$ H
L$@f
oD$ 
T$@f
D$`H
D$PH
)L$p
D$`<
t$pH
)D$`H
(D$`
|$`H
L$hD
|$hA
|$hA
|$`fffff.
\$`L
\$`H
t$pH
[A\A]A^A_]
AWAVAUATSH
ffffff.
\$ H9
h[A\A]A^A_]
AWAVSH
8[A^A_]
AWAVSH
8[A^A_]
AWAVSH
8[A^A_]
AWAVAUATSH
oc D
S0L9
[A\A]A^A_]
AWAVAUATSH
>L;~
[A\A]A^A_]
AWAVAUATSH
&L;f
D$(H
[A\A]A^A_]
AWAVAUATSH
D$0H
D$HH
D$`L
[A\A]A^A_]
AWAVSH
8[A^A_]
AWAVAUATSH
8[A\A]A^A_]
AWAVAUATSH
<'w&
8[A\A]A^A_]
AWAVATSH
0[A\A^A_]
AVSH
p[A^]
AWAVAUATSH
8[A\A]A^A_]
8[A\A]A^A_]
AWAVATSH
0[A\A^A_]
0[A\A^A_]
W8I9
G M1
G(ffffff.
O@[]
AWAVAUATSPH
_0u/H
fffff.
Xfff.
[A\A]A^A_]
AWAVSH
8[A^A_]
AWAVAUATSH
fff.
fffff.
{ff.
[A\A]A^A_]
AWAVAUATSH
ffffff.
[A\A]A^A_]
AWAVAUATSH
[A\A]A^A_]
AWAVSH
[A^A_]
AWAVSH
ffff.
t8H9
h[A^A_]
AVSH
[A^]
AWAVAUATSH
D; B
[A\A]A^A_]
AWAVAUATSH
gfffffffH
fff.
\$0A
T$ A
\8 J
ffff.
[A\A]A^A_]
AWAVAUATSH
gfffffffH
fffff.
\$0A
T$ A
[A\A]A^A_]
AWAVAUATSH
[A\A]A^A_]
AWAVAUATSH
[A\A]A^A_]
AWAVAUATSH
[A\A]A^A_]
AWAVAUATSH
[A\A]A^A_]
AWAVAUATSH
ffffff.
[A\A]A^A_]
AWAVAUATSH
[A\A]A^A_]
AWAVAUATSH
\$0A
T$ A
[A\A]A^A_]
AWAVAUATSH
ffff.
[A\A]A^A_]
AWAVAUATSH
[A\A]A^A_]
AWAVAUATSH
gfffffffH
\'0C
T' C
[A\A]A^A_]
AWAVAUATSH
[A\A]A^A_]
AWAVAUATSH
ffffff.
\$0A
T$ A
[A\A]A^A_]
AWAVAUATSH
\$0A
T$ A
[A\A]A^A_]
AWAVAUATSH
gfffffffH
fffff.
\$0A
T$ A
[A\A]A^A_]
AWAVAUATSH
yxxxxxxxH
[A\A]A^A_]
AWAVATSH
[A\A^A_]
AWAVAUATSH
fff.
[A\A]A^A_]
AWAVAUATSH
D$Pf
)\$@
)T$0
)L$ f
|$`H
(D$`
oD$pf
\$0H
D$Pf
D$PH
)D$p
)D$`M9
(D$`
(L$p
(D$p
)T$@
)L$0
)D$ f
oD$`f
(L$ 
(T$0
(\$@H
D$PI
(l$`f
oD$p
\$0H
D$Pf
[A\A]A^A_]
AWAVAUATSH
8[A\A]A^A_]
AWAVAUATSH
[A\A]A^A_]
AWAVAUATSH
)D$Pf
)\$@f
)L$ f
|$`H
oD$`
(L$pf
l$@I
d$0H
)D$p
)D$`M9
(D$`
(L$p
)D$P
(D$p
)L$0
)D$ f
oD$`f
(L$ 
(T$0
(\$@
(d$PA
(L$pf
oD$`f
d$0I
[A\A]A^A_]
AWAVAUATSH
[A\A]A^A_]
AWAVAUATSH
5fff.
[A\A]A^A_]
=De-
AWAVAUATSH
8[A\A]A^A_]
AWAVAUATSH
8[A\A]A^A_]
AWAVAUATSH
>fff.
[A\A]A^A_]
=D_-
AWAVAUATSH
\)0B
T) B
\)0B
T) B
[A\A]A^A_]
="[-
AWAVAUATSH
8[A\A]A^A_]
=sY-
AWAVAUATSH
[A\A]A^A_]
AWAVAUATSH
ffffff.
[A\A]A^A_]
=qT-
AWAVAUATSH
)\$@f
T$0f
|$`H
(D$pf
oL$`f
l$@I
d$0H
)D$p
)D$`M9
(D$`
(L$p
)D$P
(D$pf
T$@f
)D$ 
(D$`
(L$ 
(T$0
(\$@
(d$PA
(D$p
d$0f
oL$`H
oP H
[A\A]A^A_]
AWAVAUATSH
)D$Pf
)\$@f
)L$ f
|$`H
oD$`
(L$pf
l$@I
d$0H
)D$p
)D$`M9
(D$`
(L$p
)D$P
(D$p
)L$0
)D$ f
oD$`f
(L$ 
(T$0
(\$@
(d$PA
(L$pf
oD$`f
d$0I
[A\A]A^A_]
==I-
AWAVAUATSH
8[A\A]A^A_]
AWAVAUATSH
D$Pf
)\$@
)T$0
)L$ f
|$`H
(D$`
oD$pf
\$0H
D$Pf
D$PH
)D$p
)D$`M9
(D$`
(L$p
(D$p
)T$@
)L$0
)D$ f
oD$`f
(L$ 
(T$0
(\$@H
D$PI
(l$`f
oD$p
\$0H
D$Pf
[A\A]A^A_]
=qB-
AWAVAUATSH
8[A\A]A^A_]
AWAVAUATSH
)D$Pf
)\$@f
)L$ f
|$`H
oD$`
(L$pf
l$@I
d$0H
)D$p
)D$`M9
(D$`
(L$p
)D$P
(D$p
)L$0
)D$ f
oD$`f
(L$ 
(T$0
(\$@
(d$PA
(L$pf
oD$`f
d$0I
[A\A]A^A_]
AWAVAUATSH
\,0C
T, C
\,0C
T, C
[A\A]A^A_]
AWAVAUATSH
[A\A]A^A_]
AWAVAUATSH
8[A\A]A^A_]
=31-
AWAVAUATSH
)D$p
)D$`f
)\$P
)T$@
)L$0f
D$ H
t$ L
l$`I
)D$p
)D$`
)T$P
)L$@
)D$0f
D$ M
(D$ 
(L$0
(T$@
(\$P
(d$`
(l$pA
l$`f
[A\A]A^A_]
=C+-
AWAVAUATSH
fff.
fffff.
[A\A]A^A_]
=t'-
AWAVAUATSH
)D$Pf
)\$@f
)L$ f
|$`H
oD$`
(L$pf
l$@I
d$0H
)D$p
)D$`M9
(D$`
(L$p
)D$P
(D$p
)L$0
)D$ f
oD$`f
(L$ 
(T$0
(\$@
(d$PA
(L$pf
oD$`f
d$0I
[A\A]A^A_]
=-"-
AWAVAUATSH
ffffff.
[A\A]A^A_]
AWAVAUATSH
X[A\A]A^A_]
AWAVATSH
0[A\A^A_]
AWAVAUATSH
H[A\A]A^A_]
-|"-
AWAVAUATSH
H[A\A]A^A_]
AWAVATSH
0[A\A^A_]
AWAVATSH
0[A\A^A_]
AWAVSH
8[A^A_]
AWAVATSH
ffffff.
p[A\A^A_]
p[A\A^A_]
AWAVAUATSH
x[A\A]A^A_]
AWAVAUATSH
8[A\A]A^A_]
AWAVAUATSH
8[A\A]A^A_]
AWAVAUATSH
8[A\A]A^A_]
AWAVAUATSH
8[A\A]A^A_]
AWAVAUATSH
8[A\A]A^A_]
AWAVAUATSH
X[A\A]A^A_]
AWAVAUATSH
8[A\A]A^A_]
AWAVAUATSH
H[A\A]A^A_]
AWAVAUATSH
8[A\A]A^A_]
AWAVAUATSH
H[A\A]A^A_]
AWAVAUATSH
8[A\A]A^A_]
AWAVAUATSH
H[A\A]A^A_]
AWAVAUATSH
8[A\A]A^A_]
AWAVATSH
0[A\A^A_]
AWAVAUATSH
8[A\A]A^A_]
AWAVAUATSH
8[A\A]A^A_]
AWAVAUATSH
H[A\A]A^A_]
AWAVAUATSH
8[A\A]A^A_]
AWAVAUATSH
8[A\A]A^A_]
AWAVAUATSH
8[A\A]A^A_]
AWAVATSH
0[A\A^A_]
AWAVAUATSH
h[A\A]A^A_]
AWAVAUATSH
8[A\A]A^A_]
AWAVSH
8[A^A_]
AWAVAUATSH
8[A\A]A^A_]
AWAVATSH
0[A\A^A_]
AWAVAUATSH
X[A\A]A^A_]
AWAVAUATSH
8[A\A]A^A_]
AWAVAUATSH
8[A\A]A^A_]
AWAVAUATSH
8[A\A]A^A_]
AWAVAUATSH
H[A\A]A^A_]
t$ L
|$$L
AWAVAUATSH
X[A\A]A^A_]
AWAVAUATSH
8[A\A]A^A_]
AWAVAUATSH
X[A\A]A^A_]
AWAVAUATSH
h[A\A]A^A_]
AWAVAUATSH
8[A\A]A^A_]
AWAVATSH
0[A\A^A_]
AWAVAUATSH
8[A\A]A^A_]
AWAVSH
[A^A_]
AWAVSH
H[A^A_]
AWAVSH
8[A^A_]
AWAVATSH
0[A\A^A_]
AWAVAUATSH
H[A\A]A^A_]
AWAVSH
8[A^A_]
AWAVSH
h[A^A_]
AWAVATSH
P[A\A^A_]
AWAVATSH
0[A\A^A_]
AWAVSH
8[A^A_]
AWAVAUATSH
H[A\A]A^A_]
AWAVSH
H[A^A_]
AWAVATSH
0[A\A^A_]
AWAVAUATSH
8[A\A]A^A_]
AWAVAUATSH
x[A\A]A^A_]
AWAVATSH
0[A\A^A_]
AWAVSH
8[A^A_]
AWAVATSH
P[A\A^A_]
AWAVATSH
0[A\A^A_]
AWAVAUATSH
8[A\A]A^A_]
AWAVATSH
0[A\A^A_]
AWAVSH
8[A^A_]
AWAVSH
8[A^A_]
AWAVSH
8[A^A_]
AWAVAUATSH
X[A\A]A^A_]
AWAVSH
8[A^A_]
AWAVSH
8[A^A_]
AWAVATSH
@[A\A^A_]
AWAVSH
8[A^A_]
AWAVAUATSH
X[A\A]A^A_]
AWAVSH
8[A^A_]
AWAVSH
x[A^A_]
AWAVSH
8[A^A_]
AWAVSH
8[A^A_]
AWAVSH
H[A^A_]
AWAVSH
8[A^A_]
AWAVATSH
0[A\A^A_]
AWAVSH
8[A^A_]
AWAVSH
X[A^A_]
AWAVATSH
@[A\A^A_]
AWAVSH
X[A^A_]
AWAVSH
[A^A_]
AWAVSH
8[A^A_]
AWAVSH
8[A^A_]
AWAVSH
8[A^A_]
AWAVSH
8[A^A_]
AWAVATSH
0[A\A^A_]
AWAVAUATSH
8[A\A]A^A_]
AWAVSH
8[A^A_]
AWAVAUATSH
h[A\A]A^A_]
AWAVATSH
0[A\A^A_]
AWAVAUATSH
53G,
8[A\A]A^A_]
AWAVSH
8[A^A_]
AWAVSH
8[A^A_]
AWAVATSH
0[A\A^A_]
AWAVSH
8[A^A_]
AWAVATSH
P[A\A^A_]
AWAVSH
8[A^A_]
AWAVSH
X[A^A_]
AWAVAUATSH
5S;,
8[A\A]A^A_]
AWAVSH
8[A^A_]
AWAVATSH
P[A\A^A_]
AWAVSH
8[A^A_]
AWAVAUATSH
X[A\A]A^A_]
AWAVSH
H[A^A_]
AWAVATSH
P[A\A^A_]
AWAVSH
H[A^A_]
AWAVAUATSH
8[A\A]A^A_]
AWAVATSH
0[A\A^A_]
AWAVSH
8[A^A_]
AWAVAUATSH
8[A\A]A^A_]
AWAVSH
8[A^A_]
AWAVSH
H[A^A_]
AWAVATSH
P[A\A^A_]
AWAVATSH
@[A\A^A_]
AWAVATSH
@[A\A^A_]
AWAVSH
8[A^A_]
AWAVAUATSH
8[A\A]A^A_]
AWAVSH
8[A^A_]
AWAVSH
8[A^A_]
AWAVAUATSH
H[A\A]A^A_]
AWAVSH
H[A^A_]
AWAVATSH
0[A\A^A_]
AWAVSH
8[A^A_]
AWAVAUATSH
8[A\A]A^A_]
AWAVSH
8[A^A_]
AWAVATSH
0[A\A^A_]
AWAVSH
H[A^A_]
AWAVATSH
@[A\A^A_]
AWAVSH
8[A^A_]
AWAVSH
8[A^A_]
AWAVSH
8[A^A_]
AWAVATSH
P[A\A^A_]
AWAVSH
X[A^A_]
AWAVSH
8[A^A_]
AWAVATSH
0[A\A^A_]
0[A\A^A_]
0[A\A^A_]
AWAVSH
8[A^A_]
8[A^A_]
AWAVSH
8[A^A_]
8[A^A_]
AWAVSH
8[A^A_]
8[A^A_]
AWAVSH
8[A^A_]
AWAVSH
8[A^A_]
AWAVATSH
0[A\A^A_]
0[A\A^A_]
0[A\A^A_]
AWAVATSH
0[A\A^A_]
0[A\A^A_]
0[A\A^A_]
AWAVSH
8[A^A_]
AWAVSH
8[A^A_]
8[A^A_]
AWAVSH
8[A^A_]
8[A^A_]
AWAVSH
8[A^A_]
AWAVSH
8[A^A_]
AWAVSH
8[A^A_]
8[A^A_]
AWAVSH
8[A^A_]
8[A^A_]
AWAVATSH
@[A\A^A_]
AWAVSH
8[A^A_]
AWAVSH
8[A^A_]
8[A^A_]
AWAVSH
8[A^A_]
AWAVSH
8[A^A_]
8[A^A_]
AWAVATSH
0[A\A^A_]
0[A\A^A_]
0[A\A^A_]
AWAVSH
8[A^A_]
AWAVATSH
0[A\A^A_]
0[A\A^A_]
0[A\A^A_]
AWAVSH
8[A^A_]
8[A^A_]
AWAVSH
8[A^A_]
8[A^A_]
AWAVSH
H[A^A_]
AWAVSH
H[A^A_]
AWAVSH
8[A^A_]
8[A^A_]
AWAVSH
8[A^A_]
AWAVSH
8[A^A_]
AWAVSH
8[A^A_]
8[A^A_]
AWAVSH
8[A^A_]
AWAVSH
8[A^A_]
AWAVSH
8[A^A_]
AWAVSH
8[A^A_]
8[A^A_]
AWAVSH
H[A^A_]
AWAVSH
8[A^A_]
AWAVSH
8[A^A_]
AWAVSH
H[A^A_]
AWAVSH
8[A^A_]
8[A^A_]
AWAVATSH
@[A\A^A_]
AWAVSH
8[A^A_]
AWAVSH
8[A^A_]
8[A^A_]
AWAVSH
8[A^A_]
AWAVSH
H[A^A_]
AWAVATSH
0[A\A^A_]
0[A\A^A_]
0[A\A^A_]
AWAVSH
8[A^A_]
AWAVSH
8[A^A_]
AWAVAUATSH
fffff.
8[A\A]A^A_]
AWAVAUATSH
8HiX
fffff.
h[A\A]A^A_]
AWAVAUATSH
8HiX
[A\A]A^A_]
AWAVAUATSH
fffff.
X[A\A]A^A_]
AWAVAUATSH
fffff.
8[A\A]A^A_]
AWAVAUATSH
t$@I
8[A\A]A^A_]
AWAVAUATSH
fff.
t$PI
8[A\A]A^A_]
AWAVAUATSH
fffff.
8[A\A]A^A_]
AWAVATSH
P[A\A^A_]
AWAVAUATSH
8[A\A]A^A_]
AWAVAUATSH
H[A\A]A^A_]
AWAVAUATSH
8[A\A]A^A_]
AWAVAUATSH
8[A\A]A^A_]
AWAVATSH
0[A\A^A_]
AWAVAUATSH
fffff.
8[A\A]A^A_]
AWAVAUATSH
H[A\A]A^A_]
AWAVAUATSH
h[A\A]A^A_]
AWAVAUATSH
8[A\A]A^A_]
AWAVAUATSH
X[A\A]A^A_]
AWAVAUATSH
8HiX
fffff.
x[A\A]A^A_]
AWAVAUATSH
fffff.
X[A\A]A^A_]
AWAVAUATSH
fffff.
fffff.
8[A\A]A^A_]
AWAVAUATSH
+ffffff.
8[A\A]A^A_]
AWAVAUATSH
X[A\A]A^A_]
AWAVAUATSH
.M;n
fffff.
9rlib
9dyliu
9cdylu
staticliH9
proc-macH9
ffff.
fff.
.M;n
[A\A]A^A_]
AWAVSPH
t)ffff.
[A^A_]
AWAVSPI
[A^A_]
AWAVAUATSH
ffff.
[A\A]A^A_]
AVSH
[A^]
AWAVSPI
[A^A_]
AWAVSPI
[A^A_]
AWAVAUATSH
fff.
d$`f
D$pI
(D$`A
(D$ 
(L$0
(T$@
(\$PA
)D$p
)D$`
)\$P
)T$@
)L$0
)D$ H
)D$`
)\$P
)T$@
)L$0
)D$ A
(t$ 
(|$0
D$pH
[A\A]A^A_]
L$pI
(D$`A
(D$ 
(L$0
(T$@
(\$PA
AWAVAUATSH
fff.
d$`f
D$pI
(D$`A
(D$ 
(L$0
(T$@
(\$PA
)D$p
)D$`
)\$P
)T$@
)L$0
)D$ H
)D$`
)\$P
)T$@
)L$0
)D$ A
(t$ 
(|$0
D$pH
[A\A]A^A_]
L$pI
(D$`A
(D$ 
(L$0
(T$@
(\$PA
AVSH
W8I9
G M1
WH[A^]
AWAVAUATSH
5ex+
5:w+
5%v+
5Wt+
5&r+
5Eq+
5*p+
5	g+
[A\A]A^A_]
=wc+
AVSH
`[A^]
AWAVAUATSH
fff.
{t0M
fffff.
fff.
{t=M
[A\A]A^A_]
AWAVAUATSH
fff.
{t0M
fffff.
fff.
{t=M
[A\A]A^A_]
AWAVSH
[A^A_]
AWAVAUATSH
HiCX
fffff.
[A\A]A^A_]
AWAVAUATSH
[A\A]A^A_]
AWAVAUATSH
D	 I
T	(L
fffff.
BPH9
w*D9JXv$H
R0H9
9A8v
fff.
w	D9
T	 A
yPH9
w*D9QXv$H
I0H9
P H9
H(A9O(v
fff.
[0M9
ffffff.
ffffff.
ffff.
[A\A]A^A_]
=?9+
=+9+
=	.+
AWAVAUATSH
fff.
H[A\A]A^A_]
AWAVSH
[A^A_]
AWAVAUATSH
fffff.
\$@H
D$`I
fff.
D$0H
L$0I
L$(I
T$ L9
S`H9
L$0H
[A\A]A^A_]
=G)+
AWAVAUATSH
fff.
|$ L
oD$ 
|$ t%H
(\$0
(d$ 
)D$ A
(D$ A
D$ L
)\$P
)T$@
)L$0f
S`H9
CHHk
D$ H
t$@H
D$PH
|$ H
D$(D
D$ H
L$@H
D$PH
oD$ 
)\$P
)T$@
)L$0f
D$ E
fff.
|$ t)
D$@H
|$ t$H
\$ L
\$ L
)T$@
)L$0f
D$ H
D$8<
D$@H
|$@H
D$ H
L$(H
t$@H
t$(H
L$(H
L$(H
D$ 	
T$(H
oD$ 
T$@H
t$PH
oD$ f
D$0H
oD$ f
D$0H
t$8H
|$@H
D$HH
L$PH
)\$@
)T$0
)L$ 
D$XH
\$hD
|$pH
\$xD
|$ u
(D$ 
(L$0
(T$@
(\$P
(d$`
(l$p
)D$ 
)L$0
)D$ 
(D$ 
(D$0
(D$@
)D$ 
)D$p
)D$`f
)\$P
)T$@
)L$0f
D$ H
D$0H
(D$ 
)D$p
)D$`f
)\$P
)T$@
)L$0f
D$ H
(D$ 
(L$0
(T$@
(\$P
(d$`
(l$p
D$`H
oD$ f
D$0H
(D$ 
)D$p
)D$`f
)\$P
)T$@
)L$0f
D$ H
(D$ 
(L$0
(T$@
(\$P
(d$`
(l$p
D$`H
oD$ f
\$PH
D$ H
D$(H
L$(H
L$PH
L$Pf
)T$@
)L$0f
D$ L
d$XH
L$`H
T$pL
t$xD
|$ u
oD$ 
(L$0
(T$@
(\$P
(d$`
(l$p
\$PH
D$ H
D$(H
L$(H
L$PH
L$Pf
)T$@
)L$0f
D$ L
d$XH
L$`H
T$pL
t$xD
|$ u
oD$ 
(L$0
(T$@
(\$P
(d$`
(l$p
\$PH
D$ H
D$(H
L$PH
L$Pf
)T$@
)L$0f
D$ H
L$XL
d$`H
T$pL
t$xD
|$ u
oD$ 
(L$0
(T$@
(\$P
(d$`
(l$p
oD$ 
\$PH
ffffff.
[A\A]A^A_]
)L$0f
D$HH
D$@H
L$ H
D$ H
D$(H
L$0H
D$8H
D$ H
D$0H
D$@H
|$ I
|$(L
|$ L
|$ L
t%fffff.
AWAVAUATS
SPARH
tcHk
[A\A]A^A_]
Bffffff.
fff.
fff.
<@fff.
PASS
AVARH
4@E1
t4I)
t<M)
AWAVAUATSH
[A\A]A^A_]
AWAVSH
8[A^A_]
AWAVAUATSH
[A\A]A^A_]
AWAVAUATSH
8[A\A]A^A_]
AWAVSPH
[A^A_]
AWAVAUATSH
|$pH
)T$`
)L$P
)D$@
D$0H
T$PH
L$`H
(D$0
(L$@
(T$P
oD$`
)\$`
)T$P
)L$@
)D$0H
L$8L
L$8L
T$hH
l$ H
D$(L
fffff.
ffff.
D$(H
D$pf
t&Lk
<@fff.
|$0H
D$pH
[A\A]A^A_]
D$8H
u(AR
57d*
(D$0
(L$@
(T$P
oD$`
)\$`
)T$P
)L$@
)D$0L
(D$0
(L$@
(T$P
oD$`
)\$`
)T$P
)L$@
)D$0H
oD$0
(L$@
(T$P
(\$`
)\$`
)T$P
)L$@
)D$0H
(D$0
(L$@
(T$P
oD$`
)\$`
)T$P
)L$@
)D$0L
(D$0
(L$@
(T$P
oD$`
)\$`
)T$P
)L$@f
D$0H
D$0H
T$hH
L$PL
D$`H
t$0E1
D$`H
\$PH
D$0H
D$0H
D$0H
D$ H
T$(A
D$ H
T$(H
D$ H
T$(E1
D$ L
L$0H
T$ H
D$ L
L$0H
T$ H
(D$@
(L$P
(T$`
oD$0f
=|1*
\$xE
t#fff.
\$xH
AVSH
[A^]
AWAVAUATSH
|$ M
[A\A]A^A_]
AWAVAUATSH
fff.
fff.
fff.
[A\A]A^A_]
ffffff.
fff.
ffff.
ffff.
fffff.
AWAVAUATSH
h[A\A]A^A_]
AWAVAUATSH
[A\A]A^A_]
AWAVAUATSH
[A\A]A^A_]
AWAVAUATSH
x[A\A]A^A_]
AWAVAUATSH
x[A\A]A^A_]
AWAVAUATSH
x[A\A]A^A_]
AWAVAUATSH
x[A\A]A^A_]
AWAVAUATSH
x[A\A]A^A_]
AWAVAUATSH
x[A\A]A^A_]
AWAVAUATSH
x[A\A]A^A_]
AWAVAUATSH
fffff.
Fffffff.
X[A\A]A^A_]
AWAVAUATSH
8[A\A]A^A_]
AWAVAUATSH
[A\A]A^A_]
t	E1
fffff.
tTI)
ffffff.
ffffff.
ffffff.
~eI9
ffffff.
AWAVAUATSH
uespemosH
arenegylH
odnarodH
setybdetH
ffffff.
tKM9
fff.
[A\A]A^A_]
AWAVAUATSH
ffffff.
tBH9
[A\A]A^A_]
AWAVAUATSH
normu
identifiI9E
hir,typeI9E
lledt
expandedI9E
[A\A]A^A_]
AWAVAUATSH
[A\A]A^A_]
AWAVAUATSH
[A\A]A^A_]
AWAVAUATSH
[A\A]A^A_]
AWAVAUATSH
[A\A]A^A_]
AWAVAUATSH
4vfff.
[A\A]A^A_]
AWAVAUATSH
4vfff.
[A\A]A^A_]
AWAVATSH
t:L9
[A\A^A_]
AWAVATSH
[A\A^A_]
AWAVATSH
[A\A^A_]
AWAVAUATSH
([A\A]A^A_]
AWAVATSH
tRH9
[A\A^A_]
AWAVAUATSH
[A\A]A^A_]
ffffff.
AWAVSH
AWAVAUATSH
([A\A]A^A_]
([A\A]A^A_]
AWAVAUATSH
[A\A]A^A_]
AWAVAUATSH
[A\A]A^A_]
AWAVAUATSH
[A\A]A^A_]
AWAVAUATSH
fffff.
^fffff.
t?M9
[A\A]A^A_]
AWAVATSH
[A\A^A_]
AVSH
[A^]
AWAVSH
X[A^A_]
AWAVATSH
[A\A^A_]
AWAVAUATSH
[A\A]A^A_]
AWAVAUATSH
T$ I
ARPH
PAVAS
h[A\A]A^A_]
AWAVAUATS
uPf.
u AUARAS
u AWARAS
u AWARAS
$@fff.
u AWARAS
[A\A]A^A_]
u AVARAS
AWAVAUATSH
T$ I
ARPH
PAVAS
h[A\A]A^A_]
AWAVAUATSH
ARPH
PAVAS
h[A\A]A^A_]
AWAVAUATSH
D$ I
ARPH
T$HI
L$XH
L$DH
<fff.
fffff.
D$XH
\$HH
D$PH
D$XH
\$HH
4@f.
D$PH
[A\A]A^A_]
AWAVAUATSH
[A\A]A^A_]
AVSH
AWAVAUATSH
fffff.
[A\A]A^A_]
AWAVAUATSH
ffff.
rCffffff.
fff.
fff.
[A\A]A^A_]
AVSH
[A^]
AWAVAUATSH
ffff.
X[A\A]A^A_]
AWAVAUATSH
AOqH9
fff.
fff.
[A\A]A^A_]
AVSH
[A^]
AVSH
 [A^]
AWAVAUATSH
Effff.
ffffff.
[A\A]A^A_]
AVSH
[A^]
AWAVAUATS
SATH
[A\A]A^A_]
AWAVAUATSH
!ffff.
[A\A]A^A_]
AWAVAUATS
[A\A]A^A_]
fffff.
fffff.
fffff.
AWAVAUATSPM
[A\A]A^A_]
[A\A]A^A_]
AWAVAUATSH
[A\A]A^A_]
tNfD
AVSH
[A^]
AWAVAUATSH
PSAVAT
AWASAR
[A\A]A^A_]
AVSH
[A^]
AVSH
[A^]
AWAVAUATSH
[A\A]A^A_]
=Ux(
AWAVAUATSH
[A\A]A^A_]
AWAVAUATSH
w	Hc
crt-statI9
fff.
fffff.
fff.
t7I)
ffffff.
rSfffff.
ffffff.
[A\A]A^A_]
AWAVAUATSH
x[A\A]A^A_]
AWAVAUATSH
{(H9]
hfff.
[A\A]A^A_]
AWAVAUATSH
ffff.
[fffff.
ffffff.
ffffff.
fff.
=+s(
~(E1
ffffff.
ffff.
fff.
ffff.
[A\A]A^A_]
AWAVAUATSH
prm1
tQ H
tQ0H
tQ@H
tQPH
tQ`H
tQpH
E D8
B D8
fffff.
fffff.
ffffff.
ffff.
fffff.
ffffff.
fffff.
fff.
D$ D8
ffff.
[A\A]A^A_]
="D(
=@;(
AWAVAUATSH
^v\H
fff.
t5ff.
fffff.
Nff.
;ffffff.
ffff.
D$(H
m(H;M
ffffff.
fffff.
[A\A]A^A_]
=>6(
=*6(
=q-(
AWAVAUATSH
8[A\A]A^A_]
AWAVAUATSH
fff.
[A\A]A^A_]
AWAVAUATSH
8[A\A]A^A_]
AWAVAUATSH
(ff.
[A\A]A^A_]
AWAVAUATSH
EgH=
[A\A]A^A_]
<-u:M
,@fffff.
<@f.
8help
8help
F0L9
8helptoH
FHL9
8helptWH
8helpu
H8E1
8help
8help
F0L9
8helptoH
FHL9
8helptWH
8helpu
H8E1
5:9(
<$L9
|$0L9
|$HL9
L$`H
<$L9
<@fff.
<@ffff.
t$ffff.
AVSH
5uJ(
 [A^]
AWAVSH
[A^A_]
AVSH
 [A^]
AVSH
 [A^]
AWAVSPH
[A^A_]
[A^A_]
AWAVATSH
0[A\A^A_]
AVSH
0[A^]
AVSH
0[A^]
AVSH
0[A^]
AVSH
[A^]
AWAVSPI
ffffff.
[A^A_]
[A^A_]
tDf.
AWAVSPI
ffffff.
[A^A_]
[A^A_]
AWAVSPI
ffffff.
[A^A_]
[A^A_]
AWAVAUATSH
r.I9
t=;H
8[A\A]A^A_]
AVSH
[A^]
5[E(
AVSH
[A^]
AVSH
0[A^]
AWAVAUATSH
fff.
t$ H
D$ L
I;D$
[A\A]A^A_]
=jU(
5#;(
 u2H
t^E1
AWAVAUATSH
fffff.
ffff.
J0H9
fffff.
z0L9
fffff.
v L9
ffffff.
fff.
[A\A]A^A_]
AVSH
[A^]
 u2H
t^E1
AWAVAUATSPH
ffff.
[A\A]A^A_]
AWAVAUATSH
t2H9
s}L9
6u]H
fffff.
[A\A]A^A_]
=M#(
=W#(
=^#(
-P;(
-*;(
AWAVATSH
0[A\A^A_]
AWAVSPI
[A^A_]
=s (
AWAVSPI
[A^A_]
-P3(
-b2(
AWAVSH
8[A^A_]
AWAVAUATSH
\$ H
[A\A]A^A_]
AWAVATSH
 [A\A^A_]
AVSH
 [A^]
AVSH
 [A^]
vsE1
fff.
fffff.
vqE1
fff.
AWAVAUATSH
([A\A]A^A_]
AWAVAUATSH
[A\A]A^A_]
AWAVATSI
[A\A^A_]
t1UH
t1UH
AVS1
[A^]t
 uoM
AWAVAUATSH
[A\A]A^A_]
t]fH
u!fH
t]fH
u!fH
5vcA
6tvA
7txA
5vcA
6tvA
7txA
w9fH
w,H	
x#H9
w4fH
w'H	
x#H9
w9fH
w,H	
x#H9
w9fH
w,H	
x#H9
w9fH
w,H	
x#H9
w4fH
w'H	
x#H9
AWAVATSI
[A\A^A_]
fff.
AWAVATSI
s7M	
~#L!
tuL!
[A\A^A_]
AWAVSI
[A^A_]
0Eexpanded,hygieneflowgraph,unlabe
?333333
MbP?
libstd/sync/mpsc/spsc_queue.rs
assertion failed: (*next).value.is_some()
assertion failed: (*n).value.is_none()lohi
librustc_save_analysis/lib.rs
assertion failed: analysis.glob_map.is_some()Dumping crate 
rustc_save_analysis
assertion failed: index <= lenliballoc/vec.rs
assertion failed: index < lenalready borrowed
already mutably borrowed
called `Option::unwrap()` on a `None` value
libcore/option.rs
/builddir/build/BUILD/rustc-1.25.0-src/src/libstd/collections/hash/map.rs
attempt to calculate the remainder with a divisor of zero
libstd/collections/hash/map.rsraw_cap overflow
raw_capacity overflow
libstd/collections/hash/table.rsstream did not contain valid UTF-8
failed to write whole bufferformatter error
failed to fill whole buffer
/builddir/build/BUILD/rustc-1.25.0-src/src/libstd/io/impls.rs
libstd/sync/mpsc/sync.rs
internal error: entered unreachable code
libstd/sync/mpsc/mod.rs
a Display implementation return an error unexpectedly
cannot access a TLS value during or after it is destroyed
called `Result::unwrap()` on an `Err` value
/builddir/build/BUILD/rustc-1.25.0-src/src/libstd/sync/mpsc/sync.rs
assertion failed: guard.buf.size() > 0 || (deadline.is_some() && !woke_up_after_waiting)
capacity overflow
Tried to shrink to a larger capacity
liballoc/raw_vec.rs
libstd/sync/mpsc/shared.rs
assertion failed: ptr != 0
assertion failed: `(left == right)`
  left: ``,
 right: ``
inconsistent => empty
assertion failed: *self.steals.get() >= 0
assertion failed: n >= 0
bad number of channels left 
libstd/sync/mpsc/stream.rs
assertion failed: second.is_none()
assertion failed: *self.queue.consumer_addition().steals.get() >= 0
/builddir/build/BUILD/rustc-1.25.0-src/src/libcore/str/pattern.rs: 
libcore/result.rs
libstd/sync/mpsc/oneshot.rs
assertion failed: (*self.data.get()).is_none()upgrading again
libstd/sync/mpsc/mpsc_queue.rs
assertion failed: (*tail).value.is_none()
assertion failed: mid <= len
libcore/slice/mod.rs
local_def_id: no entry for `
`, which has a map of `
librustc/hir/map/mod.rsfalseUnwindfalseEdgesgenerator_drop_1 = suspend()assert(!, 
generator resumed after panicking
generator resumed after completion
index out of bounds: the len is {} but the index is {} = (replace( <- drop(unreachablereturnabortresumeswitchInt(goto
can't buffer lints after HIR lowering
librustc/session/mod.rs
/builddir/build/BUILD/rustc-1.25.0-src/src/librustc_data_structures/array_vec.rslibrustc_data_structures/small_vec.rsSomeNoneTyidnodespanMsp430InterruptSysV64AapcsFastcallRustIntrinsicCPtxKernelCdecl
PlatformIntrinsicUnadjustedRustStdcallSystemVectorcallRustCallThiscallX86InterruptWin64typatattrspatsguardbodyModinneritemsExprItemidentvistokenspathttsPathsegmentsDerefNotNeg
libsyntax/tokenstream.rs
libsyntax/fold.rs
a crate cannot expand to more than one item
fold converted a module to not a module
expected fold to produce exactly one item
expected fold to produce exactly one statementBlockstmtsrulesrecoveredCratemoduleFieldexpris_shorthandI128IsizeI16I32I8I64Localinitmutblposition_field0inputsoutputvariadicNoYesImplicitSelfTraitObjectNeverInferPtrBareFnArrayRptrSliceParenTypeofTupImplTraitMacErrU32U64U8UsizeU16U128
assertion failed: self.table.size() <= new_raw_cap
assertion failed: new_raw_cap.is_power_of_two() || new_raw_cap == 0reserve overflowSendError(..)variantsF32F64BoolCharFloatUnsuffixedIntStrFloatByteStrByteTupleStructIdentBoxWildTupleStructRangeLitRefboundsdefaultkindprefixunsafetyabigeneric_paramsdeclYieldForLoopUnaryTryInPlaceClosureIndexCatchIfBreakRepeatLoopAssignOpBinaryIfLetAssignMatchContinueRetInlineAsmWhileCastMethodCallAddrOfTypeCallWhileLetTupFieldparamswhere_clausedefaultnessgenericsTraitForeignModExternCrateMacroDefUnionImplConstGlobalAsmFnTraitAliasStaticEnumUseLifetimelegacyMetaItemnameExcludedIncludedSemiCookedRawref_idUnsafeNormaldatadisr_exprOuterInnerstyleis_sugared_docLeMulBitXorBitAndSubGtDivNeRemLtAndOrShrGeEqAddShlBitOrValueNotConstasmctxtasm_str_styleoutputsclobbersvolatilealignstackdialectconstnessAttIntelJustCratePubCrateUnsignedSignedUnsuffixedMovableMutableImmutableRestrictedPublicInheritedByRefByValueFinalDefaultlifetimeidentifierparametersHalfOpenClosedDotDotDotDotDotEqGlobSimpleNestedUnitpredicatesMethodMacroPositiveNegativeSemicolonNoBracesBracesNameValueListWord
bound_generic_paramstrait_ref
RegionTyParamBound
TraitTyParamBoundUserProvided
CompilerGeneratedStr_StrRawByteStrRawInteger#AngleBracketedParenthesizedBoundPredicateRegionPredicateEqPredicateTokenColonBinOpEqLArrowAtTildeCommentUnderscoreDotModSepRArrowDocCommentLiteralShebangOpenDelimOrOrBinOpWhitespaceQuestionInterpolatedCloseDelimFatArrowCommaPoundDollarDotEqEofEqEqAndAndDotDot--
/builddir/build/BUILD/rustc-1.25.0-src/src/vendor/getopts/src/lib.rs
assertion failed: guard.queue.dequeue().is_none()
assertion failed: guard.canceled.is_none()constraintis_rwis_indirect
/builddir/build/BUILD/rustc-1.25.0-src/src/liballoc/vec.rslhs_tyrhs_ty
PoisonError { inner: .. }DynDelimiteddelimMaybebounded_tyPlusSlashMinusStarCaretPercentNoDelimBracketBraceNtPathNtWhereClauseNtItemNtVisNtArmNtBlockNtPatNtLifetimeNtGenericsNtTyNtStmtNtImplItemNtMetaNtExprNtArgNtTraitItemNtTTNtIdent{},{"variant":,"fields":[]}:[]digraph  {
    [label=
 -> }
lifetimestypesbindings
 [shape="none", label=<>];
 [label=""];
<table border="0" cellborder="1" cellspacing="0"><tr><td  colspan=""></td></tr>
bgcolor="gray" align="center"
<tr><td align="left" balign="left"><br/>
<tr><td align="left"></table>
    label=<fn ) -&gt; 
<br align="left"/>let mut let mut 
;<br align="left"/>; // >;
digraph Mir_
    graph [fontname="monospace"];
    node [fontname="monospace"];
    edge [fontname="monospace"];
librustc_driver/profile/trace.rsassertion failed: cons.len() > 0 && cons[0] != "" task-begintime-begin misshitfrac-50frac-40frac-30frac-20frac-10frac-05frac-02frac-01frac-001frac-0%
< 0.1%
<div class="trace depth- extent-">
 important
<div class="eff"></div>
<div class="dur">
<div class="frc">
TimeBegin with non-unique, repeat message
body {
    font-family: sans-serif;
    background: black;
.trace {
    color: black;
    display: inline-block;
    border-style: solid;
    border-color: red;
    border-width: 1px;
    border-radius: 5px;
    padding: 0px;
    margin: 1px;
    font-size: 0px;
.task-begin {
    border-width: 1px;
    color: white;
    border-color: #ff8;
    font-size: 0px;
.miss {
    border-color: red;
    border-width: 1px;
.extent-0 {
    padding: 2px;
.time-begin {
    border-width: 4px;
    font-size: 12px;
    color: white;
    border-color: #afa;
.important {
    border-width: 3px;
    font-size: 12px;
    color: white;
    border-color: #f77;
.hit {
    padding: 0px;
    border-color: blue;
    border-width: 3px;
.eff {
  color: #fff;
  display: inline-block;
.frc {
  color: #7f7;
  display: inline-block;
.dur {
  display: none
.frac-50 {
  padding: 10px;
  border-width: 10px;
  font-size: 32px;
.frac-40 {
  padding: 8px;
  border-width: 8px;
  font-size: 24px;
.frac-30 {
  padding: 6px;
  border-width: 6px;
  font-size: 18px;
.frac-20 {
  padding: 4px;
  border-width: 6px;
  font-size: 16px;
.frac-10 {
  padding: 2px;
  border-width: 6px;
  font-size: 14px;
librustc_driver/profile/mod.rs
parse error: unexpected ProviderEnd; expected something else to follow BeginQuery for 
internal parse error: malformed parse stack
parse error: expected a stack frame; found an empty stack
parse error: expected QueryBegin before beginning a provider
parse error: unexpected CacheHit; expected QueryBegin
parse error: unexpected QueryBegin; earlier query is unfinished:  and now parse error
parse error; did not expect time begin here
assertion failed: stack.len() == 0
assertion failed: frame.parse_st == ParseState::Clear.log.txt.html.counts.txt<html>
<head>
<link rel="stylesheet" type="text/css" href="
profile_queries.css<style>
</style>
</head>
<body>
</body>
</html>
.ackthe input file "
" would be overwritten by the generated executable
the generated executable for the input file "
" conflicts with the existing directory ""
failed to find or create the directory specified by --out-dirindexing hir
rustc_driver::driverPre-trans
Post-trans
could not emit MIR: parsing
Lines of code:             
Pre-expansion node count:  
PRE EXPANSION AST STATS
garbage collect incremental cache directoryrecursion limitcrate injectionplugin loading
plugin registrationexpansion
maybe building test harness
maybe creating a macro crate
creating allocators
Post-expansion node count: 
POST EXPANSION AST STATSAST validationname resolution
complete gated feature checking
blocked while dep-graph loading finishes
lowering ast -> hir
early lint checks
Error while trying to garbage collect incremental compilation cache directory: 
librustc_driver/driver.rs
__diagnostic_used
__register_diagnostic
__build_diagnostic_array
missing fragment specifier
Could not join with background dep_graph thread
load query result cache
looking for entry point
looking for plugin registrarloop checking
static item recursion checking
attribute checking
stability checkingconst checkingprivacy checkingintrinsic checkingmatch checkingliveness checkingborrow checkingMIR borrow checking
MIR effect checkingdeath checking
unused lib feature checkinglint checking
resolving dependency formatstranslationprofile_queries\ 
error writing dependencies to ``: 
crate_type`crate_type` requires a value
for example: `#![crate_type="lib"]`rlibdylibcdylibstaticlibproc-macrobin
invalid `crate_type` value
dropping unsupported crate type `` for target `
metadataexe
due to multiple output types requested, the explicitly specified output file name will be adapted for each output type
ignoring --out-dir flag due to -o flag
ignoring -C extra-filename flag due to -o flag
librustc_driver/pretty.rsinvalid statenormalidentifiedeverybody_loopsexpanded
expanded,identifiedexpanded,hygienehirhir,identifiedhir,typedhir-treemirmir-cfgflowgraph
flowgraph,unlabelled
argument to `unpretty` must be one of `normal`, `expanded`, `flowgraph[,unlabelled]=<nodeid>`, `identified`, `expanded,identified`, `everybody_loops`, `hir`, `hir,identified`, `hir,typed`, or `mir`; got 
argument to `pretty` must be one of `normal`, `expanded`, `identified`, or `expanded,identified`; got 
Should use call_with_pp_support_hir
Should use call_with_pp_support::pat block pat node_id:  hir local_id: node_id: block node_id: as
does not resolve uniquely
does not resolve to any item
assertion failed: seen == 1
 needs NodeId (int) or unique path suffix (b::c::d); got , which 
assertion failed: node_id != parentnode_
--pretty flowgraph with -Z flowgraph-print annotations requires fn-like node id.graphviz::render failed: 
print-print failed to open  due to 
-Z unpretty missing HIR map
-Z unpretty missing node paths-Z unpretty
--pretty flowgraph couldn't find id: 
`pretty flowgraph=..` needs NodeId (int) or unique path suffix (b::c::d)
--pretty=flowgraph needs block, fn, or method; got 
rustc_derive_registrartarget_featurecrt-static
librustc_driver/lib.rs
error reported but abort_if_errors didn't abort???
compilation terminated
aborting due to previous error(s)
couldn't load codegen backend 
__rustc_codegen_backend
couldn't load codegen backend as it doesn't export the `__rustc_codegen_backend` symbol: metadata_only.
cannot load the default trans backend twiceprobing 
 for a codegen backendrustc_driver
failed to load default codegen backend, couldn't read `rustc_trans-.so
duplicate codegen backends found
first:  
second: 
failed to load default codegen backend for `
`, no appropriate codegen dylib found in `
failed to find a `codegen-backends` folder in the sysroot candidates:
* codegen-backends
codegen backend candidate: dladdr failed
dladdr returned null pointerout-diro-
couldn't read from stdin, as it did not contain valid UTF-8prettyE
```# 
no extended information for PAGERlessexplain
multiple input filenames provided
make_input should have provided valid inputs
no input filename givenFuel used by save analysisZls
cannot list metadata for stdin="no input file provided1.25.0verbosebinary: commit-hash: commit-date: host: release: llvmunknown
Usage: rustc [OPTIONS] INPUT
    -Z help             Print internal options for debugging rustc
    --help -v           Print the full set of options rustc accepts
Additional help:
    -C help             Print codegen options
    -W help             Print 'lint' options and default settings
Available lint options:
    -W <foo>           Warn about <foo>
    -A <foo>           Allow <foo>
    -D <foo>           Deny <foo>
    -F <foo>           Forbid <foo> (deny <foo> and all attempts to override)
Lint checks provided by rustc:
  meaning
-----------warnings
Lint groups provided by rustc:
sub-lints---------
all lints that are set to issue warnings
Lint checks provided by plugins loaded by this crate:
Lint groups provided by plugins loaded by this crate:
This crate does not load any lint plugins or lint groups.
didn't load lint plugins but got them anyway!
Compiler plugins can provide additional lints and lint groups. To see a listing of these, re-run `rustc -W help` with a crate filename.
Available debug options:
-Zcodegen_backenda string
the backend to use
in general, enable more debug printouts
span_free_formats
when debug-printing compiler state, do not include spansidentify_regions
make unnamed regions display as '# (where # is some non-ident unique id)emit_end_regions
emit EndRegion as part of MIR; enable transforms that solely process EndRegionborrowck
select which borrowck is used (`ast`, `mir`, or `compare`)
two_phase_borrows
use two-phase reserved/active distinction for `&mut` borrows in MIR borrowck
two_phase_beyond_autoref
when using two-phase-borrows, allow two phases even for non-autoref `&mut` borrowstime_passes
measure time of each rustc passcount_llvm_insns
count where LLVM instrs originatetime_llvm_passes
measure time of each LLVM passinput_stats
gather statistics about the inputtrans_stats
gather trans statisticsasm_comments
generate comments into the assembly (may change behavior)no_verify
skip LLVM verificationborrowck_stats
gather borrowck statisticsno_landing_pads
omit landing pads for unwindingfewer_names
reduce memory use by retaining fewer names within compilation artifacts (LLVM-IR)meta_stats
gather metadata statisticsprint_link_args
print the arguments passed to the linker
print_llvm_passes
prints the llvm optimization passes being runast_json
print the AST as JSON and haltquery_threadsa number
execute queries on a thread pool with N threads
ast_json_noexpand
print the pre-expansion AST as JSON and halt
list the symbols defined by a library cratesave_analysis
write syntax and type analysis (in JSON format) information, in addition to normal output
flowgraph_print_loans
include loan analysis data in -Z unpretty flowgraph output
flowgraph_print_moves
include move analysis data in -Z unpretty flowgraph output
flowgraph_print_assigns
include assignment analysis data in -Z unpretty flowgraph outputflowgraph_print_all
include all dataflow analysis data in -Z unpretty flowgraph output
print_region_graph
prints region inference graph. Use with RUST_REGION_GRAPH=help for more infoparse_only
parse only; do not compile, assemble, or linkno_trans
run all passes except translation; no outputtreat_err_as_bug
treat all errors that occur as bugs
external_macro_backtrace
show macro backtraces even for non-local macrosteach
show extended diagnostic help
continue_parse_after_error
attempt to recover from parse errors (experimental)incremental
enable incremental compilation (experimental)
incremental_queries
enable incremental compilation support for queries (experimental)incremental_info
print high-level information about incremental reuse (or the lack thereof)
incremental_dump_hash
dump hash information in textual format to stdout
incremental_verify_ich
verify incr. comp. hashes of green query instances
incremental_ignore_spans
ignore spans during ICH computation -- used for testingdump_dep_graph
dump the dependency graph to $RUST_DEP_GRAPH (default: /tmp/dep_graph.gv)query_dep_graph
enable queries of the dependency graph for regression testing
trace and profile the queries of the incremental compilation framework
profile_queries_and_keys
trace and profile the queries and keys of the incremental compilation frameworkno_analysis
parse and expand the source, but run no analysisextra_plugins
a space-separated list of strings
load extra pluginsunstable_options
adds unstable command line options to rustc interface
force_overflow_checks
one of: `y`, `yes`, `on`, `n`, `no`, or `off`
force overflow checks on or offtrace_macros
for every macro invocation, print its name and argumentsdebug_macros
emit line numbers debug info inside macros
enable_nonzeroing_move_hints
force nonzeroing move optimization on
keep_hygiene_data
don't clear the hygiene data after analysiskeep_ast
keep the AST after lowering it to HIRshow_span
show spans for compiler debugging (expr|pat|ty)print_type_sizes
print layout information for each type encountered
print_trans_items
print the result of the translation item collection passmir_opt_level
set the MIR optimization level (0-3, default: 1)mutable_noalias
emit noalias metadata for mutable referencesdump_mir
dump MIR state at various points in translationdump_mir_dir
the directory the MIR is dumped into
dump_mir_graphviz
in addition to `.mir` files, create graphviz `.dot` files
dump_mir_exclude_pass_number
if set, exclude the pass number when dumping MIR (used in tests)mir_emit_validate
emit Validate MIR statements, interpreted e.g. by miri (0: do not emit; 1: if function contains unsafe block, only validate arguments; 2: always emit full validation)perf_statsprint some performance-related statisticshir_stats
print some statistics about AST and HIRmir_statsprint some statistics about MIR
always_encode_mir
encode MIR of all functions into the crate metadatamiri
check the miri const evaluator against the old ctfe
osx_rpath_install_name
pass `-install_name @rpath/...` to the macOS linkersanitizer
one of: `address`, `leak`, `memory` or `thread`Use a sanitizerlinker_flavor
one of: em binaryen gcc ld msvc Linker flavorfuelcrate=integer
set the optimization fuel quota for a crateprint_fuel
make Rustc print the total optimization fuel used by a crate
remap_path_prefix_froma path
add a source pattern to the file path remapping config
remap_path_prefix_to
add a mapping target to the file path remapping config
force_unstable_if_unmarked
force all crates to be `rustc_private` unstablepre_link_arg
a single extra argument to prepend the linker invocation (can be used several times)pre_link_args
extra arguments to prepend to the linker invocation (space separated)profile
insert profiling coderelro_levelone of: `full`, `partial`, or `off`
choose which RELRO level to usenll
run the non-lexical lifetimes MIR passnll_dump_cause
dump cause information when reporting errors from NLLtrans_time_graph
generate a graphical HTML report of time spent in trans and LLVMthinlto
enable ThinLTO when possible
inline_in_all_cgus
control whether #[inline] functions are in all cgustls_model
choose the TLS model to use (rustc --print tls-models for details)
saturating_float_casts
make float->int casts UB-free: numbers outside the integer type's range are clipped to the max/min integer respectively, and NaN is mapped to 0lower_128bit_ops
rewrite operators on i128 and u128 into lang item calls (typically provided by compiler-builtins) so translation doesn't need to support them,
         overriding the default for the current target
human_readable_cgu_names
generate human-readable, predictable names for codegen units
dep_info_omit_d_target
in dep-info output, omit targets for tracking dependencies of the dep-info files themselves
approximate_suggestions
include machine-applicability of suggestions in JSON outputunpretty
`string` or `string=string`
Present the input source, unstable (and less-pretty) variants;
        valid types are any of the types for `--pretty`, as well as:
        `flowgraph=<nodeid>` (graphviz formatted flowgraph for node),
        `everybody_loops` (all function bodies replaced with `loop {}`),
        `hir` (the HIR), `hir,identified`, or
        `hir,typed` (HIR with types for each node).epoch
one of: `2015`, `2018`
The epoch to build Rust with. Newer epochs may include features
         that require breaking changes. The default epoch is 2015 (the first
         epoch). Crates compiled with different epochs can be linked together.
Available codegen options:
-Car
this option is deprecated and does nothinglinkersystem linker to link outputs withlink_arg
a single extra argument to append to the linker invocation (can be used several times)link_args
extra arguments to append to the linker invocation (space separated)link_dead_code
don't let linker strip dead code (turning it on can be used for code coverage)lto
one of `thin`, `fat`, or omittedperform LLVM link-time optimizationstarget_cpu
select target processor (rustc --print target-cpus for details)
target specific attributes (rustc --print target-features for details)passes
a list of extra LLVM passes to run (space separated)llvm_args
a list of arguments to pass to llvm (space separated)save_temps
save all temporary output files during compilationrpath
set rpath values in libs/exesoverflow_checks
use overflow checks for integer arithmetic
no_prepopulate_passes
don't pre-populate the pass manager with a list of passes
no_vectorize_loops
don't run the loop vectorization optimization passesno_vectorize_slp
don't run LLVM's SLP vectorization passsoft_float
use soft float ABI (*eabihf targets only)prefer_dynamic
prefer dynamic linking to static linkingno_integrated_as
use an external assembler rather than LLVM's integrated oneno_redzone
disable the use of the redzonerelocation_model
choose the relocation model to use (rustc --print relocation-models for details)code_model
choose the code model to use (rustc --print code-models for details)
metadata to mangle symbol names withextra_filename
extra data to put in each output filenamecodegen_units
divide crate into N units to optimize in parallelremark
a space-separated list of passes, or `all`
print remarks for these optimization passes (space separated, or "all")no_stack_check
the --no-stack-check flag is deprecated and does nothingdebuginfo
debug info emission level, 0 = no debug info, 1 = line tables only, 2 = full debug info with variable and type informationopt_level
optimize with possible levels 0-3, s, or zdebug_assertions
explicitly enable the cfg(debug_assertions) directiveinline_threshold
set the threshold for inlining a function (default: 225)panic
either `panic` or `abort`
panic strategy to compile crate with
enable incremental compilation=val -- 
hhelppasses=listversionrustcno-stack-checkRUST_MIN_STACKunexpected panicthe compiler unexpectedly panicked. this is a bug.
we would appreciate a bug report: 
https://github.com/rust-lang/rust/blob/master/CONTRIBUTING.md#bug-reportsrustc  running on E0020
This error indicates that an attempt was made to divide by zero (or take the
remainder of a zero divisor) in a static or constant expression. Erroneous
code example:
```compile_fail
#[deny(const_err)]
const X: i32 = 42 / 0;
// error: attempt to divide by zero in a constant expression
E0038
Trait objects like `Box<Trait>` can only be constructed when certain
requirements are satisfied by the trait in question.
Trait objects are a form of dynamic dispatch and use a dynamically sized type
for the inner type. So, for a given trait `Trait`, when `Trait` is treated as a
type, as in `Box<Trait>`, the inner type is 'unsized'. In such cases the boxed
pointer is a 'fat pointer' that contains an extra pointer to a table of methods
(among other things) for dynamic dispatch. This design mandates some
restrictions on the types of traits that are allowed to be used in trait
objects, which are collectively termed as 'object safety' rules.
Attempting to create a trait object for a non object-safe trait will trigger
this error.
There are various rules:
### The trait cannot require `Self: Sized`
When `Trait` is treated as a type, the type does not implement the special
`Sized` trait, because the type does not have a known size at compile time and
can only be accessed behind a pointer. Thus, if we have a trait like the
following:
trait Foo where Self: Sized {
We cannot create an object of type `Box<Foo>` or `&Foo` since in this case
`Self` would not be `Sized`.
Generally, `Self : Sized` is used to indicate that the trait should not be used
as a trait object. If the trait comes from your own crate, consider removing
this restriction.
### Method references the `Self` type in its arguments or return type
This happens when a trait has a method like the following:
trait Trait {
    fn foo(&self) -> Self;
impl Trait for String {
    fn foo(&self) -> Self {
        "hi".to_owned()
    }
impl Trait for u8 {
    fn foo(&self) -> Self {
        1
    }
(Note that `&self` and `&mut self` are okay, it's additional `Self` types which
cause this problem.)
In such a case, the compiler cannot predict the return type of `foo()` in a
situation like the following:
```compile_fail
trait Trait {
    fn foo(&self) -> Self;
fn call_foo(x: Box<Trait>) {
    let y = x.foo(); // What type is y?
    // ...
If only some methods aren't object-safe, you can add a `where Self: Sized` bound
on them to mark them as explicitly unavailable to trait objects. The
functionality will still be available to all other implementers, including
`Box<Trait>` which is itself sized (assuming you `impl Trait for Box<Trait>`).
trait Trait {
    fn foo(&self) -> Self where Self: Sized;
    // more functions
Now, `foo()` can no longer be called on a trait object, but you will now be
allowed to make a trait object, and that will be able to call any object-safe
methods. With such a bound, one can still call `foo()` on types implementing
that trait that aren't behind trait objects.
### Method has generic type parameters
As mentioned before, trait objects contain pointers to method tables. So, if we
have:
trait Trait {
    fn foo(&self);
impl Trait for String {
    fn foo(&self) {
        // implementation 1
    }
impl Trait for u8 {
    fn foo(&self) {
        // implementation 2
    }
// ...
At compile time each implementation of `Trait` will produce a table containing
the various methods (and other items) related to the implementation.
This works fine, but when the method gains generic parameters, we can have a
problem.
Usually, generic parameters get _monomorphized_. For example, if I have
fn foo<T>(x: T) {
    // ...
The machine code for `foo::<u8>()`, `foo::<bool>()`, `foo::<String>()`, or any
other type substitution is different. Hence the compiler generates the
implementation on-demand. If you call `foo()` with a `bool` parameter, the
compiler will only generate code for `foo::<bool>()`. When we have additional
type parameters, the number of monomorphized implementations the compiler
generates does not grow drastically, since the compiler will only generate an
implementation if the function is called with unparametrized substitutions
(i.e., substitutions where none of the substituted types are themselves
parametrized).
However, with trait objects we have to make a table containing _every_ object
that implements the trait. Now, if it has type parameters, we need to add
implementations for every type that implements the trait, and there could
theoretically be an infinite number of types.
For example, with:
trait Trait {
    fn foo<T>(&self, on: T);
    // more methods
impl Trait for String {
    fn foo<T>(&self, on: T) {
        // implementation 1
    }
impl Trait for u8 {
    fn foo<T>(&self, on: T) {
        // implementation 2
    }
// 8 more implementations
Now, if we have the following code:
```compile_fail,E0038
# trait Trait { fn foo<T>(&self, on: T); }
# impl Trait for String { fn foo<T>(&self, on: T) {} }
# impl Trait for u8 { fn foo<T>(&self, on: T) {} }
# impl Trait for bool { fn foo<T>(&self, on: T) {} }
# // etc.
fn call_foo(thing: Box<Trait>) {
    thing.foo(true); // this could be any one of the 8 types above
    thing.foo(1);
    thing.foo("hello");
We don't just need to create a table of all implementations of all methods of
`Trait`, we need to create such a table, for each different type fed to
`foo()`. In this case this turns out to be (10 types implementing `Trait`)*(3
types being fed to `foo()`) = 30 implementations!
With real world traits these numbers can grow drastically.
To fix this, it is suggested to use a `where Self: Sized` bound similar to the
fix for the sub-error above if you do not intend to call the method with type
parameters:
trait Trait {
    fn foo<T>(&self, on: T) where Self: Sized;
    // more methods
If this is not an option, consider replacing the type parameter with another
trait object (e.g. if `T: OtherTrait`, use `on: Box<OtherTrait>`). If the number
of types you intend to feed to this method is limited, consider manually listing
out the methods of different types.
### Method has no receiver
Methods that do not take a `self` parameter can't be called since there won't be
a way to get a pointer to the method table for them.
trait Foo {
    fn foo() -> u8;
This could be called as `<Foo as Foo>::foo()`, which would not be able to pick
an implementation.
Adding a `Self: Sized` bound to these methods will generally make this compile.
trait Foo {
    fn foo() -> u8 where Self: Sized;
### The trait cannot contain associated constants
Just like static functions, associated constants aren't stored on the method
table. If the trait or any subtrait contain an associated constant, they cannot
be made into an object.
```compile_fail,E0038
trait Foo {
    const X: i32;
impl Foo {}
A simple workaround is to use a helper method instead:
trait Foo {
    fn x(&self) -> i32;
### The trait cannot use `Self` as a type parameter in the supertrait listing
This is similar to the second sub-error, but subtler. It happens in situations
like the following:
```compile_fail
trait Super<A> {}
trait Trait: Super<Self> {
struct Foo;
impl Super<Foo> for Foo{}
impl Trait for Foo {}
Here, the supertrait might have methods as follows:
trait Super<A> {
    fn get_a(&self) -> A; // note that this is object safe!
If the trait `Foo` was deriving from something like `Super<String>` or
`Super<T>` (where `Foo` itself is `Foo<T>`), this is okay, because given a type
`get_a()` will definitely return an object of that type.
However, if it derives from `Super<Self>`, even though `Super` is object safe,
the method `get_a()` would return an object of unknown type when called on the
function. `Self` type parameters let us make object safe traits no longer safe,
so they are forbidden when specifying supertraits.
There's no easy fix for this, generally code will need to be refactored so that
you no longer need to derive from `Super<Self>`.
E0072
When defining a recursive struct or enum, any use of the type being defined
from inside the definition must occur behind a pointer (like `Box` or `&`).
This is because structs and enums must have a well-defined size, and without
the pointer, the size of the type would need to be unbounded.
Consider the following erroneous definition of a type for a list of bytes:
```compile_fail,E0072
// error, invalid recursive struct type
struct ListNode {
    head: u8,
    tail: Option<ListNode>,
This type cannot have a well-defined size, because it needs to be arbitrarily
large (since we would be able to nest `ListNode`s to any depth). Specifically,
```plain
size of `ListNode` = 1 byte for `head`
                   + 1 byte for the discriminant of the `Option`
                   + size of `ListNode`
One way to fix this is by wrapping `ListNode` in a `Box`, like so:
struct ListNode {
    head: u8,
    tail: Option<Box<ListNode>>,
This works because `Box` is a pointer, so its size is well-known.
E0080
This error indicates that the compiler was unable to sensibly evaluate an
constant expression that had to be evaluated. Attempting to divide by 0
or causing integer overflow are two ways to induce this error. For example:
```compile_fail,E0080
enum Enum {
    X = (1 << 500),
    Y = (1 / 0)
Ensure that the expressions given can be evaluated as the desired integer type.
See the FFI section of the Reference for more information about using a custom
integer type:
https://doc.rust-lang.org/reference.html#ffi-attributes
E0106
This error indicates that a lifetime is missing from a type. If it is an error
inside a function signature, the problem may be with failing to adhere to the
lifetime elision rules (see below).
Here are some simple examples of where you'll run into this error:
```compile_fail,E0106
struct Foo1 { x: &bool }
              // ^ expected lifetime parameter
struct Foo2<'a> { x: &'a bool } // correct
struct Bar1 { x: Foo2 }
              // ^^^^ expected lifetime parameter
struct Bar2<'a> { x: Foo2<'a> } // correct
enum Baz1 { A(u8), B(&bool), }
                  // ^ expected lifetime parameter
enum Baz2<'a> { A(u8), B(&'a bool), } // correct
type MyStr1 = &str;
           // ^ expected lifetime parameter
type MyStr2<'a> = &'a str; // correct
Lifetime elision is a special, limited kind of inference for lifetimes in
function signatures which allows you to leave out lifetimes in certain cases.
For more background on lifetime elision see [the book][book-le].
The lifetime elision rules require that any function signature with an elided
output lifetime must either have
 - exactly one input lifetime
 - or, multiple input lifetimes, but the function must also be a method with a
   `&self` or `&mut self` receiver
In the first case, the output lifetime is inferred to be the same as the unique
input lifetime. In the second case, the lifetime is instead inferred to be the
same as the lifetime on `&self` or `&mut self`.
Here are some examples of elision errors:
```compile_fail,E0106
// error, no input lifetimes
fn foo() -> &str { }
// error, `x` and `y` have distinct lifetimes inferred
fn bar(x: &str, y: &str) -> &str { }
// error, `y`'s lifetime is inferred to be distinct from `x`'s
fn baz<'a>(x: &'a str, y: &str) -> &str { }
Lifetime elision in implementation headers was part of the lifetime elision
RFC. It is, however, [currently unimplemented][iss15872].
[book-le]: https://doc.rust-lang.org/nightly/book/first-edition/lifetimes.html#lifetime-elision
[iss15872]: https://github.com/rust-lang/rust/issues/15872
E0119
There are conflicting trait implementations for the same type.
Example of erroneous code:
```compile_fail,E0119
trait MyTrait {
    fn get(&self) -> usize;
impl<T> MyTrait for T {
    fn get(&self) -> usize { 0 }
struct Foo {
    value: usize
impl MyTrait for Foo { // error: conflicting implementations of trait
                       //        `MyTrait` for type `Foo`
    fn get(&self) -> usize { self.value }
When looking for the implementation for the trait, the compiler finds
both the `impl<T> MyTrait for T` where T is all types and the `impl
MyTrait for Foo`. Since a trait cannot be implemented multiple times,
this is an error. So, when you write:
trait MyTrait {
    fn get(&self) -> usize;
impl<T> MyTrait for T {
    fn get(&self) -> usize { 0 }
This makes the trait implemented on all types in the scope. So if you
try to implement it on another one after that, the implementations will
conflict. Example:
trait MyTrait {
    fn get(&self) -> usize;
impl<T> MyTrait for T {
    fn get(&self) -> usize { 0 }
struct Foo;
fn main() {
    let f = Foo;
    f.get(); // the trait is implemented so we can use it
E0136
A binary can only have one entry point, and by default that entry point is the
function `main()`. If there are multiple such functions, please rename one.
E0137
More than one function was declared with the `#[main]` attribute.
Erroneous code example:
```compile_fail,E0137
#![feature(main)]
#[main]
fn foo() {}
#[main]
fn f() {} // error: multiple functions with a #[main] attribute
This error indicates that the compiler found multiple functions with the
`#[main]` attribute. This is an error because there must be a unique entry
point into a Rust program. Example:
#![feature(main)]
#[main]
fn f() {} // ok!
E0138
More than one function was declared with the `#[start]` attribute.
Erroneous code example:
```compile_fail,E0138
#![feature(start)]
#[start]
fn foo(argc: isize, argv: *const *const u8) -> isize {}
#[start]
fn f(argc: isize, argv: *const *const u8) -> isize {}
// error: multiple 'start' functions
This error indicates that the compiler found multiple functions with the
`#[start]` attribute. This is an error because there must be a unique entry
point into a Rust program. Example:
#![feature(start)]
#[start]
fn foo(argc: isize, argv: *const *const u8) -> isize { 0 } // ok!
E0139
#### Note: this error code is no longer emitted by the compiler.
There are various restrictions on transmuting between types in Rust; for example
types being transmuted must have the same size. To apply all these restrictions,
the compiler must know the exact types that may be transmuted. When type
parameters are involved, this cannot always be done.
So, for example, the following is not allowed:
use std::mem::transmute;
struct Foo<T>(Vec<T>);
fn foo<T>(x: Vec<T>) {
    // we are transmuting between Vec<T> and Foo<F> here
    let y: Foo<T> = unsafe { transmute(x) };
    // do something with y
In this specific case there's a good chance that the transmute is harmless (but
this is not guaranteed by Rust). However, when alignment and enum optimizations
come into the picture, it's quite likely that the sizes may or may not match
with different type parameter substitutions. It's not possible to check this for
_all_ possible types, so `transmute()` simply only accepts types without any
unsubstituted type parameters.
If you need this, there's a good chance you're doing something wrong. Keep in
mind that Rust doesn't guarantee much about the layout of different structs
(even two structs with identical declarations may have different layouts). If
there is a solution that avoids the transmute entirely, try it instead.
If it's possible, hand-monomorphize the code by writing the function for each
possible type substitution. It's possible to use traits to do this cleanly,
for example:
use std::mem::transmute;
struct Foo<T>(Vec<T>);
trait MyTransmutableType: Sized {
    fn transmute(_: Vec<Self>) -> Foo<Self>;
impl MyTransmutableType for u8 {
    fn transmute(x: Vec<u8>) -> Foo<u8> {
        unsafe { transmute(x) }
    }
impl MyTransmutableType for String {
    fn transmute(x: Vec<String>) -> Foo<String> {
        unsafe { transmute(x) }
    }
// ... more impls for the types you intend to transmute
fn foo<T: MyTransmutableType>(x: Vec<T>) {
    let y: Foo<T> = <T as MyTransmutableType>::transmute(x);
    // do something with y
Each impl will be checked for a size match in the transmute as usual, and since
there are no unbound type parameters involved, this should compile unless there
is a size mismatch in one of the impls.
It is also possible to manually transmute:
# use std::ptr;
# let v = Some("value");
# type SomeType = &'static [u8];
unsafe {
    ptr::read(&v as *const _ as *const SomeType) // `v` transmuted to `SomeType`
Note that this does not move `v` (unlike `transmute`), and may need a
call to `mem::forget(v)` in case you want to avoid destructors being called.
E0152
A lang item was redefined.
Erroneous code example:
```compile_fail,E0152
#![feature(lang_items)]
#[lang = "panic_fmt"]
struct Foo; // error: duplicate lang item found: `panic_fmt`
Lang items are already implemented in the standard library. Unless you are
writing a free-standing application (e.g. a kernel), you do not need to provide
them yourself.
You can build a free-standing crate by adding `#![no_std]` to the crate
attributes:
```ignore (only-for-syntax-highlight)
#![no_std]
See also https://doc.rust-lang.org/book/first-edition/no-stdlib.html
E0214
A generic type was described using parentheses rather than angle brackets.
For example:
```compile_fail,E0214
fn main() {
    let v: Vec(&str) = vec!["foo"];
This is not currently supported: `v` should be defined as `Vec<&str>`.
Parentheses are currently only used with generic types when defining parameters
for `Fn`-family traits.
E0230
The `#[rustc_on_unimplemented]` attribute lets you specify a custom error
message for when a particular trait isn't implemented on a type placed in a
position that needs that trait. For example, when the following code is
compiled:
```compile_fail
#![feature(on_unimplemented)]
fn foo<T: Index<u8>>(x: T){}
#[rustc_on_unimplemented = "the type `{Self}` cannot be indexed by `{Idx}`"]
trait Index<Idx> { /* ... */ }
foo(true); // `bool` does not implement `Index<u8>`
There will be an error about `bool` not implementing `Index<u8>`, followed by a
note saying "the type `bool` cannot be indexed by `u8`".
As you can see, you can specify type parameters in curly braces for
substitution with the actual types (using the regular format string syntax) in
a given situation. Furthermore, `{Self}` will substitute to the type (in this
case, `bool`) that we tried to use.
This error appears when the curly braces contain an identifier which doesn't
match with any of the type parameters or the string `Self`. This might happen
if you misspelled a type parameter, or if you intended to use literal curly
braces. If it is the latter, escape the curly braces with a second curly brace
of the same type; e.g. a literal `{` is `{{`.
E0231
The `#[rustc_on_unimplemented]` attribute lets you specify a custom error
message for when a particular trait isn't implemented on a type placed in a
position that needs that trait. For example, when the following code is
compiled:
```compile_fail
#![feature(on_unimplemented)]
fn foo<T: Index<u8>>(x: T){}
#[rustc_on_unimplemented = "the type `{Self}` cannot be indexed by `{Idx}`"]
trait Index<Idx> { /* ... */ }
foo(true); // `bool` does not implement `Index<u8>`
there will be an error about `bool` not implementing `Index<u8>`, followed by a
note saying "the type `bool` cannot be indexed by `u8`".
As you can see, you can specify type parameters in curly braces for
substitution with the actual types (using the regular format string syntax) in
a given situation. Furthermore, `{Self}` will substitute to the type (in this
case, `bool`) that we tried to use.
This error appears when the curly braces do not contain an identifier. Please
add one of the same name as a type parameter. If you intended to use literal
braces, use `{{` and `}}` to escape them.
E0232
The `#[rustc_on_unimplemented]` attribute lets you specify a custom error
message for when a particular trait isn't implemented on a type placed in a
position that needs that trait. For example, when the following code is
compiled:
```compile_fail
#![feature(on_unimplemented)]
fn foo<T: Index<u8>>(x: T){}
#[rustc_on_unimplemented = "the type `{Self}` cannot be indexed by `{Idx}`"]
trait Index<Idx> { /* ... */ }
foo(true); // `bool` does not implement `Index<u8>`
there will be an error about `bool` not implementing `Index<u8>`, followed by a
note saying "the type `bool` cannot be indexed by `u8`".
For this to work, some note must be specified. An empty attribute will not do
anything, please remove the attribute or add some helpful note for users of the
trait.
E0261
When using a lifetime like `'a` in a type, it must be declared before being
used.
These two examples illustrate the problem:
```compile_fail,E0261
// error, use of undeclared lifetime name `'a`
fn foo(x: &'a str) { }
struct Foo {
    // error, use of undeclared lifetime name `'a`
    x: &'a str,
These can be fixed by declaring lifetime parameters:
fn foo<'a>(x: &'a str) {}
struct Foo<'a> {
    x: &'a str,
E0262
Declaring certain lifetime names in parameters is disallowed. For example,
because the `'static` lifetime is a special built-in lifetime name denoting
the lifetime of the entire program, this is an error:
```compile_fail,E0262
// error, invalid lifetime parameter name `'static`
fn foo<'static>(x: &'static str) { }
E0263
A lifetime name cannot be declared more than once in the same scope. For
example:
```compile_fail,E0263
// error, lifetime name `'a` declared twice in the same scope
fn foo<'a, 'b, 'a>(x: &'a str, y: &'b str) { }
E0264
An unknown external lang item was used. Erroneous code example:
```compile_fail,E0264
#![feature(lang_items)]
extern "C" {
    #[lang = "cake"] // error: unknown external lang item: `cake`
    fn cake();
A list of available external lang items is available in
`src/librustc/middle/weak_lang_items.rs`. Example:
#![feature(lang_items)]
extern "C" {
    #[lang = "panic_fmt"] // ok!
    fn cake();
E0271
This is because of a type mismatch between the associated type of some
trait (e.g. `T::Bar`, where `T` implements `trait Quux { type Bar; }`)
and another type `U` that is required to be equal to `T::Bar`, but is not.
Examples follow.
Here is a basic example:
```compile_fail,E0271
trait Trait { type AssociatedType; }
fn foo<T>(t: T) where T: Trait<AssociatedType=u32> {
    println!("in foo");
impl Trait for i8 { type AssociatedType = &'static str; }
foo(3_i8);
Here is that same example again, with some explanatory comments:
```compile_fail,E0271
trait Trait { type AssociatedType; }
fn foo<T>(t: T) where T: Trait<AssociatedType=u32> {
//                    ~~~~~~~~ ~~~~~~~~~~~~~~~~~~
//                        |            |
//         This says `foo` can         |
//           only be used with         |
//              some type that         |
//         implements `Trait`.         |
//                                     |
//                             This says not only must
//                             `T` be an impl of `Trait`
//                             but also that the impl
//                             must assign the type `u32`
//                             to the associated type.
    println!("in foo");
impl Trait for i8 { type AssociatedType = &'static str; }
//~~~~~~~~~~~~~~~   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//      |                             |
// `i8` does have                     |
// implementation                     |
// of `Trait`...                      |
//                     ... but it is an implementation
//                     that assigns `&'static str` to
//                     the associated type.
foo(3_i8);
// Here, we invoke `foo` with an `i8`, which does not satisfy
// the constraint `<i8 as Trait>::AssociatedType=u32`, and
// therefore the type-checker complains with this error code.
Here is a more subtle instance of the same problem, that can
arise with for-loops in Rust:
```compile_fail
let vs: Vec<i32> = vec![1, 2, 3, 4];
for v in &vs {
    match v {
        1 => {},
        _ => {},
    }
The above fails because of an analogous type mismatch,
though may be harder to see. Again, here are some
explanatory comments for the same example:
```compile_fail
    let vs = vec![1, 2, 3, 4];
    // `for`-loops use a protocol based on the `Iterator`
    // trait. Each item yielded in a `for` loop has the
    // type `Iterator::Item` -- that is, `Item` is the
    // associated type of the concrete iterator impl.
    for v in &vs {
//      ~    ~~~
//      |     |
//      |    We borrow `vs`, iterating over a sequence of
//      |    *references* of type `&Elem` (where `Elem` is
//      |    vector's element type). Thus, the associated
//      |    type `Item` must be a reference `&`-type ...
//      |
//  ... and `v` has the type `Iterator::Item`, as dictated by
//  the `for`-loop protocol ...
        match v {
            1 => {}
//          ~
//          |
// ... but *here*, `v` is forced to have some integral type;
// only types like `u8`,`i8`,`u16`,`i16`, et cetera can
// match the pattern `1` ...
            _ => {}
        }
// ... therefore, the compiler complains, because it sees
// an attempt to solve the equations
// `some integral-type` = type-of-`v`
//                      = `Iterator::Item`
//                      = `&Elem` (i.e. `some reference type`)
// which cannot possibly all be true.
    }
To avoid those issues, you have to make the types match correctly.
So we can fix the previous examples like this:
// Basic Example:
trait Trait { type AssociatedType; }
fn foo<T>(t: T) where T: Trait<AssociatedType = &'static str> {
    println!("in foo");
impl Trait for i8 { type AssociatedType = &'static str; }
foo(3_i8);
// For-Loop Example:
let vs = vec![1, 2, 3, 4];
for v in &vs {
    match v {
        &1 => {}
        _ => {}
    }
E0275
This error occurs when there was a recursive trait requirement that overflowed
before it could be evaluated. Often this means that there is unbounded
recursion in resolving some type bounds.
For example, in the following code:
```compile_fail,E0275
trait Foo {}
struct Bar<T>(T);
impl<T> Foo for T where Bar<T>: Foo {}
To determine if a `T` is `Foo`, we need to check if `Bar<T>` is `Foo`. However,
to do this check, we need to determine that `Bar<Bar<T>>` is `Foo`. To
determine this, we check if `Bar<Bar<Bar<T>>>` is `Foo`, and so on. This is
clearly a recursive requirement that can't be resolved directly.
Consider changing your trait bounds so that they're less self-referential.
E0276
This error occurs when a bound in an implementation of a trait does not match
the bounds specified in the original trait. For example:
```compile_fail,E0276
trait Foo {
    fn foo<T>(x: T);
impl Foo for bool {
    fn foo<T>(x: T) where T: Copy {}
Here, all types implementing `Foo` must have a method `foo<T>(x: T)` which can
take any type `T`. However, in the `impl` for `bool`, we have added an extra
bound that `T` is `Copy`, which isn't compatible with the original trait.
Consider removing the bound from the method or adding the bound to the original
method definition in the trait.
E0277
You tried to use a type which doesn't implement some trait in a place which
expected that trait. Erroneous code example:
```compile_fail,E0277
// here we declare the Foo trait with a bar method
trait Foo {
    fn bar(&self);
// we now declare a function which takes an object implementing the Foo trait
fn some_func<T: Foo>(foo: T) {
    foo.bar();
fn main() {
    // we now call the method with the i32 type, which doesn't implement
    // the Foo trait
    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied
In order to fix this error, verify that the type you're using does implement
the trait. Example:
trait Foo {
    fn bar(&self);
fn some_func<T: Foo>(foo: T) {
    foo.bar(); // we can now use this method since i32 implements the
               // Foo trait
// we implement the trait on the i32 type
impl Foo for i32 {
    fn bar(&self) {}
fn main() {
    some_func(5i32); // ok!
Or in a generic context, an erroneous code example would look like:
```compile_fail,E0277
fn some_func<T>(foo: T) {
    println!("{:?}", foo); // error: the trait `core::fmt::Debug` is not
                           //        implemented for the type `T`
fn main() {
    // We now call the method with the i32 type,
    // which *does* implement the Debug trait.
    some_func(5i32);
Note that the error here is in the definition of the generic function: Although
we only call it with a parameter that does implement `Debug`, the compiler
still rejects the function: It must work with all possible input types. In
order to make this example compile, we need to restrict the generic type we're
accepting:
use std::fmt;
// Restrict the input type to types that implement Debug.
fn some_func<T: fmt::Debug>(foo: T) {
    println!("{:?}", foo);
fn main() {
    // Calling the method is still fine, as i32 implements Debug.
    some_func(5i32);
    // This would fail to compile now:
    // struct WithoutDebug;
    // some_func(WithoutDebug);
Rust only looks at the signature of the called function, as such it must
already specify all requirements that will be used for every type parameter.
E0281
#### Note: this error code is no longer emitted by the compiler.
You tried to supply a type which doesn't implement some trait in a location
which expected that trait. This error typically occurs when working with
`Fn`-based types. Erroneous code example:
```compile-fail
fn foo<F: Fn(usize)>(x: F) { }
fn main() {
    // type mismatch: ... implements the trait `core::ops::Fn<(String,)>`,
    // but the trait `core::ops::Fn<(usize,)>` is required
    // [E0281]
    foo(|y: String| { });
The issue in this case is that `foo` is defined as accepting a `Fn` with one
argument of type `String`, but the closure we attempted to pass to it requires
one arguments of type `usize`.
E0282
This error indicates that type inference did not result in one unique possible
type, and extra information is required. In most cases this can be provided
by adding a type annotation. Sometimes you need to specify a generic type
parameter manually.
A common example is the `collect` method on `Iterator`. It has a generic type
parameter with a `FromIterator` bound, which for a `char` iterator is
implemented by `Vec` and `String` among others. Consider the following snippet
that reverses the characters of a string:
```compile_fail,E0282
let x = "hello".chars().rev().collect();
In this case, the compiler cannot infer what the type of `x` should be:
`Vec<char>` and `String` are both suitable candidates. To specify which type to
use, you can use a type annotation on `x`:
let x: Vec<char> = "hello".chars().rev().collect();
It is not necessary to annotate the full type. Once the ambiguity is resolved,
the compiler can infer the rest:
let x: Vec<_> = "hello".chars().rev().collect();
Another way to provide the compiler with enough information, is to specify the
generic type parameter:
let x = "hello".chars().rev().collect::<Vec<char>>();
Again, you need not specify the full type if the compiler can infer it:
let x = "hello".chars().rev().collect::<Vec<_>>();
Apart from a method or function with a generic type parameter, this error can
occur when a type parameter of a struct or trait cannot be inferred. In that
case it is not always possible to use a type annotation, because all candidates
have the same return type. For instance:
```compile_fail,E0282
struct Foo<T> {
    num: T,
impl<T> Foo<T> {
    fn bar() -> i32 {
        0
    }
    fn baz() {
        let number = Foo::bar();
    }
This will fail because the compiler does not know which instance of `Foo` to
call `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.
E0283
This error occurs when the compiler doesn't have enough information
to unambiguously choose an implementation.
For example:
```compile_fail,E0283
trait Generator {
    fn create() -> u32;
struct Impl;
impl Generator for Impl {
    fn create() -> u32 { 1 }
struct AnotherImpl;
impl Generator for AnotherImpl {
    fn create() -> u32 { 2 }
fn main() {
    let cont: u32 = Generator::create();
    // error, impossible to choose one of Generator trait implementation
    // Impl or AnotherImpl? Maybe anything else?
To resolve this error use the concrete type:
trait Generator {
    fn create() -> u32;
struct AnotherImpl;
impl Generator for AnotherImpl {
    fn create() -> u32 { 2 }
fn main() {
    let gen1 = AnotherImpl::create();
    // if there are multiple methods with same name (different traits)
    let gen2 = <AnotherImpl as Generator>::create();
E0296
This error indicates that the given recursion limit could not be parsed. Ensure
that the value provided is a positive integer between quotes.
Erroneous code example:
```compile_fail,E0296
#![recursion_limit]
fn main() {}
And a working example:
#![recursion_limit="1000"]
fn main() {}
E0308
This error occurs when the compiler was unable to infer the concrete type of a
variable. It can occur for several cases, the most common of which is a
mismatch in the expected type that the compiler inferred for a variable's
initializing expression, and the actual type explicitly assigned to the
variable.
For example:
```compile_fail,E0308
let x: i32 = "I am not a number!";
//     ~~~   ~~~~~~~~~~~~~~~~~~~~
//      |             |
//      |    initializing expression;
//      |    compiler infers type `&str`
//      |
//    type `i32` assigned to variable `x`
E0309
Types in type definitions have lifetimes associated with them that represent
how long the data stored within them is guaranteed to be live. This lifetime
must be as long as the data needs to be alive, and missing the constraint that
denotes this will cause this error.
```compile_fail,E0309
// This won't compile because T is not constrained, meaning the data
// stored in it is not guaranteed to last as long as the reference
struct Foo<'a, T> {
    foo: &'a T
This will compile, because it has the constraint on the type parameter:
struct Foo<'a, T: 'a> {
    foo: &'a T
To see why this is important, consider the case where `T` is itself a reference
(e.g., `T = &str`). If we don't include the restriction that `T: 'a`, the
following code would be perfectly legal:
```compile_fail,E0309
struct Foo<'a, T> {
    foo: &'a T
fn main() {
    let v = "42".to_string();
    let f = Foo{foo: &v};
    drop(v);
    println!("{}", f.foo); // but we've already dropped v!
E0310
Types in type definitions have lifetimes associated with them that represent
how long the data stored within them is guaranteed to be live. This lifetime
must be as long as the data needs to be alive, and missing the constraint that
denotes this will cause this error.
```compile_fail,E0310
// This won't compile because T is not constrained to the static lifetime
// the reference needs
struct Foo<T> {
    foo: &'static T
This will compile, because it has the constraint on the type parameter:
struct Foo<T: 'static> {
    foo: &'static T
E0317
This error occurs when an `if` expression without an `else` block is used in a
context where a type other than `()` is expected, for example a `let`
expression:
```compile_fail,E0317
fn main() {
    let x = 5;
    let a = if x == 5 { 1 };
An `if` expression without an `else` block has the type `()`, so this is a type
error. To resolve it, add an `else` block having the same type as the `if`
block.
E0391
This error indicates that some types or traits depend on each other
and therefore cannot be constructed.
The following example contains a circular dependency between two traits:
```compile_fail,E0391
trait FirstTrait : SecondTrait {
trait SecondTrait : FirstTrait {
E0398
#### Note: this error code is no longer emitted by the compiler.
In Rust 1.3, the default object lifetime bounds are expected to change, as
described in [RFC 1156]. You are getting a warning because the compiler
thinks it is possible that this change will cause a compilation error in your
code. It is possible, though unlikely, that this is a false alarm.
The heart of the change is that where `&'a Box<SomeTrait>` used to default to
`&'a Box<SomeTrait+'a>`, it now defaults to `&'a Box<SomeTrait+'static>` (here,
`SomeTrait` is the name of some trait type). Note that the only types which are
affected are references to boxes, like `&Box<SomeTrait>` or
`&[Box<SomeTrait>]`. More common types like `&SomeTrait` or `Box<SomeTrait>`
are unaffected.
To silence this warning, edit your code to use an explicit bound. Most of the
time, this means that you will want to change the signature of a function that
you are calling. For example, if the error is reported on a call like `foo(x)`,
and `foo` is defined as follows:
# trait SomeTrait {}
fn foo(arg: &Box<SomeTrait>) { /* ... */ }
You might change it to:
# trait SomeTrait {}
fn foo<'a>(arg: &'a Box<SomeTrait+'a>) { /* ... */ }
This explicitly states that you expect the trait object `SomeTrait` to contain
references (with a maximum lifetime of `'a`).
[RFC 1156]: https://github.com/rust-lang/rfcs/blob/master/text/1156-adjust-default-object-bounds.md
E0452
An invalid lint attribute has been given. Erroneous code example:
```compile_fail,E0452
#![allow(foo = "")] // error: malformed lint attribute
Lint attributes only accept a list of identifiers (where each identifier is a
lint name). Ensure the attribute is of this form:
#![allow(foo)] // ok!
// or:
#![allow(foo, foo2)] // ok!
E0453
A lint check attribute was overruled by a `forbid` directive set as an
attribute on an enclosing scope, or on the command line with the `-F` option.
Example of erroneous code:
```compile_fail,E0453
#![forbid(non_snake_case)]
#[allow(non_snake_case)]
fn main() {
    let MyNumber = 2; // error: allow(non_snake_case) overruled by outer
                      //        forbid(non_snake_case)
The `forbid` lint setting, like `deny`, turns the corresponding compiler
warning into a hard error. Unlike `deny`, `forbid` prevents itself from being
overridden by inner attributes.
If you're sure you want to override the lint check, you can change `forbid` to
`deny` (or use `-D` instead of `-F` if the `forbid` setting was given as a
command-line option) to allow the inner lint check attribute:
#![deny(non_snake_case)]
#[allow(non_snake_case)]
fn main() {
    let MyNumber = 2; // ok!
Otherwise, edit the code to pass the lint check, and remove the overruled
attribute:
#![forbid(non_snake_case)]
fn main() {
    let my_number = 2;
E0478
A lifetime bound was not satisfied.
Erroneous code example:
```compile_fail,E0478
// Check that the explicit lifetime bound (`'SnowWhite`, in this example) must
// outlive all the superbounds from the trait (`'kiss`, in this example).
trait Wedding<'t>: 't { }
struct Prince<'kiss, 'SnowWhite> {
    child: Box<Wedding<'kiss> + 'SnowWhite>,
    // error: lifetime bound not satisfied
In this example, the `'SnowWhite` lifetime is supposed to outlive the `'kiss`
lifetime but the declaration of the `Prince` struct doesn't enforce it. To fix
this issue, you need to specify it:
trait Wedding<'t>: 't { }
struct Prince<'kiss, 'SnowWhite: 'kiss> { // You say here that 'kiss must live
                                          // longer than 'SnowWhite.
    child: Box<Wedding<'kiss> + 'SnowWhite>, // And now it's all good!
E0491
A reference has a longer lifetime than the data it references.
Erroneous code example:
```compile_fail,E0491
// struct containing a reference requires a lifetime parameter,
// because the data the reference points to must outlive the struct (see E0106)
struct Struct<'a> {
    ref_i32: &'a i32,
// However, a nested struct like this, the signature itself does not tell
// whether 'a outlives 'b or the other way around.
// So it could be possible that 'b of reference outlives 'a of the data.
struct Nested<'a, 'b> {
    ref_struct: &'b Struct<'a>, // compile error E0491
To fix this issue, you can specify a bound to the lifetime like below:
struct Struct<'a> {
    ref_i32: &'a i32,
// 'a: 'b means 'a outlives 'b
struct Nested<'a: 'b, 'b> {
    ref_struct: &'b Struct<'a>,
E0496
A lifetime name is shadowing another lifetime name. Erroneous code example:
```compile_fail,E0496
struct Foo<'a> {
    a: &'a i32,
impl<'a> Foo<'a> {
    fn f<'a>(x: &'a i32) { // error: lifetime name `'a` shadows a lifetime
                           //        name that is already in scope
    }
Please change the name of one of the lifetimes to remove this error. Example:
struct Foo<'a> {
    a: &'a i32,
impl<'a> Foo<'a> {
    fn f<'b>(x: &'b i32) { // ok!
    }
fn main() {
E0497
A stability attribute was used outside of the standard library. Erroneous code
example:
```compile_fail
#[stable] // error: stability attributes may not be used outside of the
          //        standard library
fn foo() {}
It is not possible to use stability attributes outside of the standard library.
Also, for now, it is not possible to write deprecation messages either.
E0512
Transmute with two differently sized types was attempted. Erroneous code
example:
```compile_fail,E0512
fn takes_u8(_: u8) {}
fn main() {
    unsafe { takes_u8(::std::mem::transmute(0u16)); }
    // error: transmute called with types of different sizes
Please use types with same size or use the expected type directly. Example:
fn takes_u8(_: u8) {}
fn main() {
    unsafe { takes_u8(::std::mem::transmute(0i8)); } // ok!
    // or:
    unsafe { takes_u8(0u8); } // ok!
E0517
This error indicates that a `#[repr(..)]` attribute was placed on an
unsupported item.
Examples of erroneous code:
```compile_fail,E0517
#[repr(C)]
type Foo = u8;
#[repr(packed)]
enum Foo {Bar, Baz}
#[repr(u8)]
struct Foo {bar: bool, baz: bool}
#[repr(C)]
impl Foo {
    // ...
* The `#[repr(C)]` attribute can only be placed on structs and enums.
* The `#[repr(packed)]` and `#[repr(simd)]` attributes only work on structs.
* The `#[repr(u8)]`, `#[repr(i16)]`, etc attributes only work on enums.
These attributes do not work on typedefs, since typedefs are just aliases.
Representations like `#[repr(u8)]`, `#[repr(i64)]` are for selecting the
discriminant size for enums with no data fields on any of the variants, e.g.
`enum Color {Red, Blue, Green}`, effectively setting the size of the enum to
the size of the provided type. Such an enum can be cast to a value of the same
type as well. In short, `#[repr(u8)]` makes the enum behave like an integer
with a constrained set of allowed values.
Only field-less enums can be cast to numerical primitives, so this attribute
will not apply to structs.
`#[repr(packed)]` reduces padding to make the struct size smaller. The
representation of enums isn't strictly defined in Rust, and this attribute
won't work on enums.
`#[repr(simd)]` will give a struct consisting of a homogeneous series of machine
types (i.e. `u8`, `i32`, etc) a representation that permits vectorization via
SIMD. This doesn't make much sense for enums since they don't consist of a
single list of data.
E0518
This error indicates that an `#[inline(..)]` attribute was incorrectly placed
on something other than a function or method.
Examples of erroneous code:
```compile_fail,E0518
#[inline(always)]
struct Foo;
#[inline(never)]
impl Foo {
    // ...
`#[inline]` hints the compiler whether or not to attempt to inline a method or
function. By default, the compiler does a pretty good job of figuring this out
itself, but if you feel the need for annotations, `#[inline(always)]` and
`#[inline(never)]` can override or force the compiler's decision.
If you wish to apply this attribute to all methods in an impl, manually annotate
each method; it is not possible to annotate the entire impl with an `#[inline]`
attribute.
E0522
The lang attribute is intended for marking special items that are built-in to
Rust itself. This includes special traits (like `Copy` and `Sized`) that affect
how the compiler behaves, as well as special functions that may be automatically
invoked (such as the handler for out-of-bounds accesses when indexing a slice).
Erroneous code example:
```compile_fail,E0522
#![feature(lang_items)]
#[lang = "cookie"]
fn cookie() -> ! { // error: definition of an unknown language item: `cookie`
    loop {}
E0525
A closure was used but didn't implement the expected trait.
Erroneous code example:
```compile_fail,E0525
struct X;
fn foo<T>(_: T) {}
fn bar<T: Fn(u32)>(_: T) {}
fn main() {
    let x = X;
    let closure = |_| foo(x); // error: expected a closure that implements
                              //        the `Fn` trait, but this closure only
                              //        implements `FnOnce`
    bar(closure);
In the example above, `closure` is an `FnOnce` closure whereas the `bar`
function expected an `Fn` closure. In this case, it's simple to fix the issue,
you just have to implement `Copy` and `Clone` traits on `struct X` and it'll
be ok:
#[derive(Clone, Copy)] // We implement `Clone` and `Copy` traits.
struct X;
fn foo<T>(_: T) {}
fn bar<T: Fn(u32)>(_: T) {}
fn main() {
    let x = X;
    let closure = |_| foo(x);
    bar(closure); // ok!
To understand better how closures work in Rust, read:
https://doc.rust-lang.org/book/first-edition/closures.html
E0580
The `main` function was incorrectly declared.
Erroneous code example:
```compile_fail,E0580
fn main() -> i32 { // error: main function has wrong type
    0
The `main` function prototype should never take arguments or return type.
Example:
fn main() {
    // your code
If you want to get command-line arguments, use `std::env::args`. To exit with a
specified exit code, use `std::process::exit`.
E0562
Abstract return types (written `impl Trait` for some trait `Trait`) are only
allowed as function return types.
Erroneous code example:
```compile_fail,E0562
#![feature(conservative_impl_trait)]
fn main() {
    let count_to_ten: impl Iterator<Item=usize> = 0..10;
    // error: `impl Trait` not allowed outside of function and inherent method
    //        return types
    for i in count_to_ten {
        println!("{}", i);
    }
Make sure `impl Trait` only appears in return-type position.
#![feature(conservative_impl_trait)]
fn count_to_n(n: usize) -> impl Iterator<Item=usize> {
    0..n
fn main() {
    for i in count_to_n(10) {  // ok!
        println!("{}", i);
    }
See [RFC 1522] for more details.
[RFC 1522]: https://github.com/rust-lang/rfcs/blob/master/text/1522-conservative-impl-trait.md
E0591
Per [RFC 401][rfc401], if you have a function declaration `foo`:
// For the purposes of this explanation, all of these
// different kinds of `fn` declarations are equivalent:
struct S;
fn foo(x: S) { /* ... */ }
# #[cfg(for_demonstration_only)]
extern "C" { fn foo(x: S); }
# #[cfg(for_demonstration_only)]
impl S { fn foo(self) { /* ... */ } }
the type of `foo` is **not** `fn(S)`, as one might expect.
Rather, it is a unique, zero-sized marker type written here as `typeof(foo)`.
However, `typeof(foo)` can be _coerced_ to a function pointer `fn(S)`,
so you rarely notice this:
# struct S;
# fn foo(_: S) {}
let x: fn(S) = foo; // OK, coerces
The reason that this matter is that the type `fn(S)` is not specific to
any particular function: it's a function _pointer_. So calling `x()` results
in a virtual call, whereas `foo()` is statically dispatched, because the type
of `foo` tells us precisely what function is being called.
As noted above, coercions mean that most code doesn't have to be
concerned with this distinction. However, you can tell the difference
when using **transmute** to convert a fn item into a fn pointer.
This is sometimes done as part of an FFI:
```compile_fail,E0591
extern "C" fn foo(userdata: Box<i32>) {
    /* ... */
# fn callback(_: extern "C" fn(*mut i32)) {}
# use std::mem::transmute;
# unsafe {
let f: extern "C" fn(*mut i32) = transmute(foo);
callback(f);
Here, transmute is being used to convert the types of the fn arguments.
This pattern is incorrect because, because the type of `foo` is a function
**item** (`typeof(foo)`), which is zero-sized, and the target type (`fn()`)
is a function pointer, which is not zero-sized.
This pattern should be rewritten. There are a few possible ways to do this:
- change the original fn declaration to match the expected signature,
  and do the cast in the fn body (the prefered option)
- cast the fn item fo a fn pointer before calling transmute, as shown here:
    ```
    # extern "C" fn foo(_: Box<i32>) {}
    # use std::mem::transmute;
    # unsafe {
    let f: extern "C" fn(*mut i32) = transmute(foo as extern "C" fn(_));
    let f: extern "C" fn(*mut i32) = transmute(foo as usize); // works too
    # }
    ```
The same applies to transmutes to `*mut fn()`, which were observedin practice.
Note though that use of this type is generally incorrect.
The intention is typically to describe a function pointer, but just `fn()`
alone suffices for that. `*mut fn()` is a pointer to a fn pointer.
(Since these values are typically just passed to C code, however, this rarely
makes a difference in practice.)
[rfc401]: https://github.com/rust-lang/rfcs/blob/master/text/0401-coercions.md
E0593
You tried to supply an `Fn`-based type with an incorrect number of arguments
than what was expected.
Erroneous code example:
```compile_fail,E0593
fn foo<F: Fn()>(x: F) { }
fn main() {
    // [E0593] closure takes 1 argument but 0 arguments are required
    foo(|y| { });
E0601
No `main` function was found in a binary crate. To fix this error, add a
`main` function. For example:
fn main() {
    // Your program will start here.
    println!("Hello world!");
If you don't know the basics of Rust, you can go look to the Rust Book to get
started: https://doc.rust-lang.org/book/
E0602
An unknown lint was used on the command line.
Erroneous example:
```sh
rustc -D bogus omse_file.rs
Maybe you just misspelled the lint name or the lint doesn't exist anymore.
Either way, try to update/remove it in order to fix the error.
E0621
This error code indicates a mismatch between the lifetimes appearing in the
function signature (i.e., the parameter types and the return type) and the
data-flow found in the function body.
Erroneous code example:
```compile_fail,E0621
fn foo<'a>(x: &'a i32, y: &i32) -> &'a i32 { // error: explicit lifetime
                                             //        required in the type of
                                             //        `y`
    if x > y { x } else { y }
In the code above, the function is returning data borrowed from either `x` or
`y`, but the `'a` annotation indicates that it is returning data only from `x`.
To fix the error, the signature and the body must be made to match. Typically,
this is done by updating the function signature. So, in this case, we change
the type of `y` to `&'a i32`, like so:
fn foo<'a>(x: &'a i32, y: &'a i32) -> &'a i32 {
    if x > y { x } else { y }
Now the signature indicates that the function data borrowed from either `x` or
`y`. Alternatively, you could change the body to not return data from `y`:
fn foo<'a>(x: &'a i32, y: &i32) -> &'a i32 {
    x
E0644
A closure or generator was constructed that references its own type.
Erroneous example:
```compile-fail,E0644
fn fix<F>(f: &F)
  where F: Fn(&F)
  f(&f);
fn main() {
  fix(&|y| {
    // Here, when `x` is called, the parameter `y` is equal to `x`.
  });
Rust does not permit a closure to directly reference its own type,
either through an argument (as in the example above) or by capturing
itself through its environment. This restriction helps keep closure
inference tractable.
The easiest fix is to rewrite your closure into a top-level function,
or into a method. In some cases, you may also be able to have your
closure call itself by capturing a `&Fn()` object or `fn()` pointer
that refers to itself. That is permitting, since the closure would be
invoking itself via a virtual call, and hence does not directly
reference its own *type*.
E0692
A `repr(transparent)` type was also annotated with other, incompatible
representation hints.
Erroneous code example:
```compile_fail,E0692
#![feature(repr_transparent)]
#[repr(transparent, C)] // error: incompatible representation hints
struct Grams(f32);
A type annotated as `repr(transparent)` delegates all representation concerns to
another type, so adding more representation hints is contradictory. Remove
either the `transparent` hint or the other hints, like this:
#![feature(repr_transparent)]
#[repr(transparent)]
struct Grams(f32);
Alternatively, move the other attributes to the contained type:
#![feature(repr_transparent)]
#[repr(C)]
struct Foo {
    x: i32,
    // ...
#[repr(transparent)]
struct FooWrapper(Foo);
Note that introducing another `struct` just to have a place for the other
attributes may have unintended side effects on the representation:
#![feature(repr_transparent)]
#[repr(transparent)]
struct Grams(f32);
#[repr(C)]
struct Float(f32);
#[repr(transparent)]
struct Grams2(Float); // this is not equivalent to `Grams` above
Here, `Grams2` is a not equivalent to `Grams` -- the former transparently wraps
a (non-transparent) struct containing a single float, while `Grams` is a
transparent wrapper around a float. This can make a difference for the ABI.
E0045
Rust only supports variadic parameters for interoperability with C code in its
FFI. As such, variadic parameters can only be used with functions which are
using the C ABI. Examples of erroneous code:
```compile_fail
#![feature(unboxed_closures)]
extern "rust-call" { fn foo(x: u8, ...); }
// or
fn foo(x: u8, ...) {}
To fix such code, put them in an extern "C" block:
extern "C" {
    fn foo (x: u8, ...);
E0131
It is not possible to define `main` with type parameters, or even with function
parameters. When `main` is present, it must take no arguments and return `()`.
Erroneous code example:
```compile_fail,E0131
fn main<T>() { // error: main function is not allowed to have type parameters
E0132
A function with the `start` attribute was declared with type parameters.
Erroneous code example:
```compile_fail,E0132
#![feature(start)]
#[start]
fn f<T>() {}
It is not possible to declare type parameters on a function that has the `start`
attribute. Such a function must have the following type signature (for more
information: http://doc.rust-lang.org/stable/book/first-edition/no-stdlib.html):
# let _:
fn(isize, *const *const u8) -> isize;
Example:
#![feature(start)]
#[start]
fn my_start(argc: isize, argv: *const *const u8) -> isize {
    0
E0023
A pattern used to match against an enum variant must provide a sub-pattern for
each field of the enum variant. This error indicates that a pattern attempted to
extract an incorrect number of fields from a variant.
enum Fruit {
    Apple(String, String),
    Pear(u32),
Here the `Apple` variant has two fields, and should be matched against like so:
enum Fruit {
    Apple(String, String),
    Pear(u32),
let x = Fruit::Apple(String::new(), String::new());
// Correct.
match x {
    Fruit::Apple(a, b) => {},
    _ => {}
Matching with the wrong number of fields has no sensible interpretation:
```compile_fail,E0023
enum Fruit {
    Apple(String, String),
    Pear(u32),
let x = Fruit::Apple(String::new(), String::new());
// Incorrect.
match x {
    Fruit::Apple(a) => {},
    Fruit::Apple(a, b, c) => {},
Check how many fields the enum was declared with and ensure that your pattern
uses the same number.
E0025
Each field of a struct can only be bound once in a pattern. Erroneous code
example:
```compile_fail,E0025
struct Foo {
    a: u8,
    b: u8,
fn main(){
    let x = Foo { a:1, b:2 };
    let Foo { a: x, a: y } = x;
    // error: field `a` bound multiple times in the pattern
Each occurrence of a field name binds the value of that field, so to fix this
error you will have to remove or alter the duplicate uses of the field name.
Perhaps you misspelled another field name? Example:
struct Foo {
    a: u8,
    b: u8,
fn main(){
    let x = Foo { a:1, b:2 };
    let Foo { a: x, b: y } = x; // ok!
E0026
This error indicates that a struct pattern attempted to extract a non-existent
field from a struct. Struct fields are identified by the name used before the
colon `:` so struct patterns should resemble the declaration of the struct type
being matched.
// Correct matching.
struct Thing {
    x: u32,
    y: u32
let thing = Thing { x: 1, y: 2 };
match thing {
    Thing { x: xfield, y: yfield } => {}
If you are using shorthand field patterns but want to refer to the struct field
by a different name, you should rename it explicitly.
Change this:
```compile_fail,E0026
struct Thing {
    x: u32,
    y: u32
let thing = Thing { x: 0, y: 0 };
match thing {
    Thing { x, z } => {}
To this:
struct Thing {
    x: u32,
    y: u32
let thing = Thing { x: 0, y: 0 };
match thing {
    Thing { x, y: z } => {}
E0027
This error indicates that a pattern for a struct fails to specify a sub-pattern
for every one of the struct's fields. Ensure that each field from the struct's
definition is mentioned in the pattern, or use `..` to ignore unwanted fields.
For example:
```compile_fail,E0027
struct Dog {
    name: String,
    age: u32,
let d = Dog { name: "Rusty".to_string(), age: 8 };
// This is incorrect.
match d {
    Dog { age: x } => {}
This is correct (explicit):
struct Dog {
    name: String,
    age: u32,
let d = Dog { name: "Rusty".to_string(), age: 8 };
match d {
    Dog { name: ref n, age: x } => {}
// This is also correct (ignore unused fields).
match d {
    Dog { age: x, .. } => {}
E0029
In a match expression, only numbers and characters can be matched against a
range. This is because the compiler checks that the range is non-empty at
compile-time, and is unable to evaluate arbitrary comparison functions. If you
want to capture values of an orderable type between two end-points, you can use
a guard.
```compile_fail,E0029
let string = "salutations !";
// The ordering relation for strings can't be evaluated at compile time,
// so this doesn't work:
match string {
    "hello" ... "world" => {}
    _ => {}
// This is a more general version, using a guard:
match string {
    s if s >= "hello" && s <= "world" => {}
    _ => {}
E0033
This error indicates that a pointer to a trait type cannot be implicitly
dereferenced by a pattern. Every trait defines a type, but because the
size of trait implementors isn't fixed, this type has no compile-time size.
Therefore, all accesses to trait types must be through pointers. If you
encounter this error you should try to avoid dereferencing the pointer.
```compile_fail,E0033
# trait SomeTrait { fn method_one(&self){} fn method_two(&self){} }
# impl<T> SomeTrait for T {}
let trait_obj: &SomeTrait = &"some_value";
// This tries to implicitly dereference to create an unsized local variable.
let &invalid = trait_obj;
// You can call methods without binding to the value being pointed at.
trait_obj.method_one();
trait_obj.method_two();
You can read more about trait objects in the [Trait Objects] section of the
Reference.
[Trait Objects]: https://doc.rust-lang.org/reference/types.html#trait-objects
E0034
The compiler doesn't know what method to call because more than one method
has the same prototype. Erroneous code example:
```compile_fail,E0034
struct Test;
trait Trait1 {
    fn foo();
trait Trait2 {
    fn foo();
impl Trait1 for Test { fn foo() {} }
impl Trait2 for Test { fn foo() {} }
fn main() {
    Test::foo() // error, which foo() to call?
To avoid this error, you have to keep only one of them and remove the others.
So let's take our example and fix it:
struct Test;
trait Trait1 {
    fn foo();
impl Trait1 for Test { fn foo() {} }
fn main() {
    Test::foo() // and now that's good!
However, a better solution would be using fully explicit naming of type and
trait:
struct Test;
trait Trait1 {
    fn foo();
trait Trait2 {
    fn foo();
impl Trait1 for Test { fn foo() {} }
impl Trait2 for Test { fn foo() {} }
fn main() {
    <Test as Trait1>::foo()
One last example:
trait F {
    fn m(&self);
trait G {
    fn m(&self);
struct X;
impl F for X { fn m(&self) { println!("I am F"); } }
impl G for X { fn m(&self) { println!("I am G"); } }
fn main() {
    let f = X;
    F::m(&f); // it displays "I am F"
    G::m(&f); // it displays "I am G"
E0040
It is not allowed to manually call destructors in Rust. It is also not
necessary to do this since `drop` is called automatically whenever a value goes
out of scope.
Here's an example of this error:
```compile_fail,E0040
struct Foo {
    x: i32,
impl Drop for Foo {
    fn drop(&mut self) {
        println!("kaboom");
    }
fn main() {
    let mut x = Foo { x: -7 };
    x.drop(); // error: explicit use of destructor method
E0044
You can't use type parameters on foreign items. Example of erroneous code:
```compile_fail,E0044
extern { fn some_func<T>(x: T); }
To fix this, replace the type parameter with the specializations that you
need:
extern { fn some_func_i32(x: i32); }
extern { fn some_func_i64(x: i64); }
E0046
Items are missing in a trait implementation. Erroneous code example:
```compile_fail,E0046
trait Foo {
    fn foo();
struct Bar;
impl Foo for Bar {}
// error: not all trait items implemented, missing: `foo`
When trying to make some type implement a trait `Foo`, you must, at minimum,
provide implementations for all of `Foo`'s required methods (meaning the
methods that do not have default implementations), as well as any required
trait items like associated types or constants. Example:
trait Foo {
    fn foo();
struct Bar;
impl Foo for Bar {
    fn foo() {} // ok!
E0049
This error indicates that an attempted implementation of a trait method
has the wrong number of type parameters.
For example, the trait below has a method `foo` with a type parameter `T`,
but the implementation of `foo` for the type `Bar` is missing this parameter:
```compile_fail,E0049
trait Foo {
    fn foo<T: Default>(x: T) -> Self;
struct Bar;
// error: method `foo` has 0 type parameters but its trait declaration has 1
// type parameter
impl Foo for Bar {
    fn foo(x: bool) -> Self { Bar }
E0050
This error indicates that an attempted implementation of a trait method
has the wrong number of function parameters.
For example, the trait below has a method `foo` with two function parameters
(`&self` and `u8`), but the implementation of `foo` for the type `Bar` omits
the `u8` parameter:
```compile_fail,E0050
trait Foo {
    fn foo(&self, x: u8) -> bool;
struct Bar;
// error: method `foo` has 1 parameter but the declaration in trait `Foo::foo`
// has 2
impl Foo for Bar {
    fn foo(&self) -> bool { true }
E0053
The parameters of any trait method must match between a trait implementation
and the trait definition.
Here are a couple examples of this error:
```compile_fail,E0053
trait Foo {
    fn foo(x: u16);
    fn bar(&self);
struct Bar;
impl Foo for Bar {
    // error, expected u16, found i16
    fn foo(x: i16) { }
    // error, types differ in mutability
    fn bar(&mut self) { }
E0054
It is not allowed to cast to a bool. If you are trying to cast a numeric type
to a bool, you can compare it with zero instead:
```compile_fail,E0054
let x = 5;
// Not allowed, won't compile
let x_is_nonzero = x as bool;
let x = 5;
// Ok
let x_is_nonzero = x != 0;
E0055
During a method call, a value is automatically dereferenced as many times as
needed to make the value's type match the method's receiver. The catch is that
the compiler will only attempt to dereference a number of times up to the
recursion limit (which can be set via the `recursion_limit` attribute).
For a somewhat artificial example:
```compile_fail,E0055
#![recursion_limit="2"]
struct Foo;
impl Foo {
    fn foo(&self) {}
fn main() {
    let foo = Foo;
    let ref_foo = &&Foo;
    // error, reached the recursion limit while auto-dereferencing &&Foo
    ref_foo.foo();
One fix may be to increase the recursion limit. Note that it is possible to
create an infinite recursion of dereferencing, in which case the only fix is to
somehow break the recursion.
E0057
When invoking closures or other implementations of the function traits `Fn`,
`FnMut` or `FnOnce` using call notation, the number of parameters passed to the
function must match its definition.
An example using a closure:
```compile_fail,E0057
let f = |x| x * 3;
let a = f();        // invalid, too few parameters
let b = f(4);       // this works!
let c = f(2, 3);    // invalid, too many parameters
A generic function must be treated similarly:
fn foo<F: Fn()>(f: F) {
    f(); // this is valid, but f(3) would not work
E0059
The built-in function traits are generic over a tuple of the function arguments.
If one uses angle-bracket notation (`Fn<(T,), Output=U>`) instead of parentheses
(`Fn(T) -> U`) to denote the function trait, the type parameter should be a
tuple. Otherwise function call notation cannot be used and the trait will not be
implemented by closures.
The most likely source of this error is using angle-bracket notation without
wrapping the function argument type into a tuple, for example:
```compile_fail,E0059
#![feature(unboxed_closures)]
fn foo<F: Fn<i32>>(f: F) -> F::Output { f(3) }
It can be fixed by adjusting the trait bound like this:
#![feature(unboxed_closures)]
fn foo<F: Fn<(i32,)>>(f: F) -> F::Output { f(3) }
Note that `(T,)` always denotes the type of a 1-tuple containing an element of
type `T`. The comma is necessary for syntactic disambiguation.
E0060
External C functions are allowed to be variadic. However, a variadic function
takes a minimum number of arguments. For example, consider C's variadic `printf`
function:
use std::os::raw::{c_char, c_int};
extern "C" {
    fn printf(_: *const c_char, ...) -> c_int;
Using this declaration, it must be called with at least one argument, so
simply calling `printf()` is invalid. But the following uses are allowed:
# #![feature(static_nobundle)]
# use std::os::raw::{c_char, c_int};
# #[cfg_attr(all(windows, target_env = "msvc"),
#            link(name = "legacy_stdio_definitions", kind = "static-nobundle"))]
# extern "C" { fn printf(_: *const c_char, ...) -> c_int; }
# fn main() {
unsafe {
    use std::ffi::CString;
    let fmt = CString::new("test\n").unwrap();
    printf(fmt.as_ptr());
    let fmt = CString::new("number = %d\n").unwrap();
    printf(fmt.as_ptr(), 3);
    let fmt = CString::new("%d, %d\n").unwrap();
    printf(fmt.as_ptr(), 10, 5);
E0061
The number of arguments passed to a function must match the number of arguments
specified in the function signature.
For example, a function like:
fn f(a: u16, b: &str) {}
Must always be called with exactly two arguments, e.g. `f(2, "test")`.
Note that Rust does not have a notion of optional function arguments or
variadic functions (except for its C-FFI).
E0062
This error indicates that during an attempt to build a struct or struct-like
enum variant, one of the fields was specified more than once. Erroneous code
example:
```compile_fail,E0062
struct Foo {
    x: i32,
fn main() {
    let x = Foo {
                x: 0,
                x: 0, // error: field `x` specified more than once
            };
Each field should be specified exactly one time. Example:
struct Foo {
    x: i32,
fn main() {
    let x = Foo { x: 0 }; // ok!
E0063
This error indicates that during an attempt to build a struct or struct-like
enum variant, one of the fields was not provided. Erroneous code example:
```compile_fail,E0063
struct Foo {
    x: i32,
    y: i32,
fn main() {
    let x = Foo { x: 0 }; // error: missing field: `y`
Each field should be specified exactly once. Example:
struct Foo {
    x: i32,
    y: i32,
fn main() {
    let x = Foo { x: 0, y: 0 }; // ok!
E0066
Box placement expressions (like C++'s "placement new") do not yet support any
place expression except the exchange heap (i.e. `std::boxed::HEAP`).
Furthermore, the syntax is changing to use `in` instead of `box`. See [RFC 470]
and [RFC 809] for more details.
[RFC 470]: https://github.com/rust-lang/rfcs/pull/470
[RFC 809]: https://github.com/rust-lang/rfcs/blob/master/text/0809-box-and-in-for-stdlib.md
E0067
The left-hand side of a compound assignment expression must be a place
expression. A place expression represents a memory location and includes
item paths (ie, namespaced variables), dereferences, indexing expressions,
and field references.
Let's start with some erroneous code examples:
```compile_fail,E0067
use std::collections::LinkedList;
// Bad: assignment to non-place expression
LinkedList::new() += 1;
// ...
fn some_func(i: &mut i32) {
    i += 12; // Error : '+=' operation cannot be applied on a reference !
And now some working examples:
let mut i : i32 = 0;
i += 12; // Good !
// ...
fn some_func(i: &mut i32) {
    *i += 12; // Good !
E0069
The compiler found a function whose body contains a `return;` statement but
whose return type is not `()`. An example of this is:
```compile_fail,E0069
// error
fn foo() -> u8 {
    return;
Since `return;` is just like `return ();`, there is a mismatch between the
function's return type and the value being returned.
E0070
The left-hand side of an assignment operator must be a place expression. An
place expression represents a memory location and can be a variable (with
optional namespacing), a dereference, an indexing expression or a field
reference.
More details can be found in the [Expressions] section of the Reference.
[Expressions]: https://doc.rust-lang.org/reference/expressions.html#places-rvalues-and-temporaries
Now, we can go further. Here are some erroneous code examples:
```compile_fail,E0070
struct SomeStruct {
    x: i32,
    y: i32
const SOME_CONST : i32 = 12;
fn some_other_func() {}
fn some_function() {
    SOME_CONST = 14; // error : a constant value cannot be changed!
    1 = 3; // error : 1 isn't a valid place!
    some_other_func() = 4; // error : we can't assign value to a function!
    SomeStruct.x = 12; // error : SomeStruct a structure name but it is used
                       // like a variable!
And now let's give working examples:
struct SomeStruct {
    x: i32,
    y: i32
let mut s = SomeStruct {x: 0, y: 0};
s.x = 3; // that's good !
// ...
fn some_func(x: &mut i32) {
    *x = 12; // that's good !
E0071
You tried to use structure-literal syntax to create an item that is
not a structure or enum variant.
Example of erroneous code:
```compile_fail,E0071
type U32 = u32;
let t = U32 { value: 4 }; // error: expected struct, variant or union type,
                          // found builtin type `u32`
To fix this, ensure that the name was correctly spelled, and that
the correct form of initializer was used.
For example, the code above can be fixed to:
enum Foo {
    FirstValue(i32)
fn main() {
    let u = Foo::FirstValue(0i32);
    let t = 4;
E0073
#### Note: this error code is no longer emitted by the compiler.
You cannot define a struct (or enum) `Foo` that requires an instance of `Foo`
in order to make a new `Foo` value. This is because there would be no way a
first instance of `Foo` could be made to initialize another instance!
Here's an example of a struct that has this problem:
struct Foo { x: Box<Foo> } // error
One fix is to use `Option`, like so:
struct Foo { x: Option<Box<Foo>> }
Now it's possible to create at least one instance of `Foo`: `Foo { x: None }`.
E0074
#### Note: this error code is no longer emitted by the compiler.
When using the `#[simd]` attribute on a tuple struct, the components of the
tuple struct must all be of a concrete, nongeneric type so the compiler can
reason about how to use SIMD with them. This error will occur if the types
are generic.
This will cause an error:
#![feature(repr_simd)]
#[repr(simd)]
struct Bad<T>(T, T, T);
This will not:
#![feature(repr_simd)]
#[repr(simd)]
struct Good(u32, u32, u32);
E0075
The `#[simd]` attribute can only be applied to non empty tuple structs, because
it doesn't make sense to try to use SIMD operations when there are no values to
operate on.
This will cause an error:
```compile_fail,E0075
#![feature(repr_simd)]
#[repr(simd)]
struct Bad;
This will not:
#![feature(repr_simd)]
#[repr(simd)]
struct Good(u32);
E0076
When using the `#[simd]` attribute to automatically use SIMD operations in tuple
struct, the types in the struct must all be of the same type, or the compiler
will trigger this error.
This will cause an error:
```compile_fail,E0076
#![feature(repr_simd)]
#[repr(simd)]
struct Bad(u16, u32, u32);
This will not:
#![feature(repr_simd)]
#[repr(simd)]
struct Good(u32, u32, u32);
E0077
When using the `#[simd]` attribute on a tuple struct, the elements in the tuple
must be machine types so SIMD operations can be applied to them.
This will cause an error:
```compile_fail,E0077
#![feature(repr_simd)]
#[repr(simd)]
struct Bad(String);
This will not:
#![feature(repr_simd)]
#[repr(simd)]
struct Good(u32, u32, u32);
E0081
Enum discriminants are used to differentiate enum variants stored in memory.
This error indicates that the same value was used for two or more variants,
making them impossible to tell apart.
```compile_fail,E0081
// Bad.
enum Enum {
    P = 3,
    X = 3,
    Y = 5,
// Good.
enum Enum {
    P,
    X = 3,
    Y = 5,
Note that variants without a manually specified discriminant are numbered from
top to bottom starting from 0, so clashes can occur with seemingly unrelated
variants.
```compile_fail,E0081
enum Bad {
    X,
    Y = 0
Here `X` will have already been specified the discriminant 0 by the time `Y` is
encountered, so a conflict occurs.
E0082
#### Note: this error code is no longer emitted by the compiler.
When you specify enum discriminants with `=`, the compiler expects `isize`
values by default. Or you can add the `repr` attibute to the enum declaration
for an explicit choice of the discriminant type. In either cases, the
discriminant values must fall within a valid range for the expected type;
otherwise this error is raised. For example:
```compile_fail
# #![deny(overflowing_literals)]
#[repr(u8)]
enum Thing {
    A = 1024,
    B = 5,
Here, 1024 lies outside the valid range for `u8`, so the discriminant for `A` is
invalid. Here is another, more subtle example which depends on target word size:
```compile_fail,E0080
# #[repr(i32)]
enum DependsOnPointerSize {
    A = 1 << 32,
Here, `1 << 32` is interpreted as an `isize` value. So it is invalid for 32 bit
target (`target_pointer_width = "32"`) but valid for 64 bit target.
You may want to change representation types to fix this, or else change invalid
discriminant values so that they fit within the existing type.
E0084
An unsupported representation was attempted on a zero-variant enum.
Erroneous code example:
```compile_fail,E0084
#[repr(i32)]
enum NightsWatch {} // error: unsupported representation for zero-variant enum
It is impossible to define an integer type to be used to represent zero-variant
enum values because there are no zero-variant enum values. There is no way to
construct an instance of the following type using only safe code. So you have
two solutions. Either you add variants in your enum:
#[repr(i32)]
enum NightsWatch {
    JonSnow,
    Commander,
or you remove the integer represention of your enum:
enum NightsWatch {}
E0087
Too many type parameters were supplied for a function. For example:
```compile_fail,E0087
fn foo<T>() {}
fn main() {
    foo::<f64, bool>(); // error, expected 1 parameter, found 2 parameters
The number of supplied parameters must exactly match the number of defined type
parameters.
E0088
You gave too many lifetime parameters. Erroneous code example:
```compile_fail,E0088
fn f() {}
fn main() {
    f::<'static>() // error: too many lifetime parameters provided
Please check you give the right number of lifetime parameters. Example:
fn f() {}
fn main() {
    f() // ok!
It's also important to note that the Rust compiler can generally
determine the lifetime by itself. Example:
struct Foo {
    value: String
impl Foo {
    // it can be written like this
    fn get_value<'a>(&'a self) -> &'a str { &self.value }
    // but the compiler works fine with this too:
    fn without_lifetime(&self) -> &str { &self.value }
fn main() {
    let f = Foo { value: "hello".to_owned() };
    println!("{}", f.get_value());
    println!("{}", f.without_lifetime());
E0089
Not enough type parameters were supplied for a function. For example:
```compile_fail,E0089
fn foo<T, U>() {}
fn main() {
    foo::<f64>(); // error, expected 2 parameters, found 1 parameter
Note that if a function takes multiple type parameters but you want the compiler
to infer some of them, you can use type placeholders:
```compile_fail,E0089
fn foo<T, U>(x: T) {}
fn main() {
    let x: bool = true;
    foo::<f64>(x);    // error, expected 2 parameters, found 1 parameter
    foo::<_, f64>(x); // same as `foo::<bool, f64>(x)`
E0090
You gave too few lifetime parameters. Example:
```compile_fail,E0090
fn foo<'a: 'b, 'b: 'a>() {}
fn main() {
    foo::<'static>(); // error, expected 2 lifetime parameters
Please check you give the right number of lifetime parameters. Example:
fn foo<'a: 'b, 'b: 'a>() {}
fn main() {
    foo::<'static, 'static>();
E0091
You gave an unnecessary type parameter in a type alias. Erroneous code
example:
```compile_fail,E0091
type Foo<T> = u32; // error: type parameter `T` is unused
// or:
type Foo<A,B> = Box<A>; // error: type parameter `B` is unused
Please check you didn't write too many type parameters. Example:
type Foo = u32; // ok!
type Foo2<A> = Box<A>; // ok!
E0092
You tried to declare an undefined atomic operation function.
Erroneous code example:
```compile_fail,E0092
#![feature(intrinsics)]
extern "rust-intrinsic" {
    fn atomic_foo(); // error: unrecognized atomic operation
                     //        function
Please check you didn't make a mistake in the function's name. All intrinsic
functions are defined in librustc_trans/trans/intrinsic.rs and in
libcore/intrinsics.rs in the Rust source code. Example:
#![feature(intrinsics)]
extern "rust-intrinsic" {
    fn atomic_fence(); // ok!
E0093
You declared an unknown intrinsic function. Erroneous code example:
```compile_fail,E0093
#![feature(intrinsics)]
extern "rust-intrinsic" {
    fn foo(); // error: unrecognized intrinsic function: `foo`
fn main() {
    unsafe {
        foo();
    }
Please check you didn't make a mistake in the function's name. All intrinsic
functions are defined in librustc_trans/trans/intrinsic.rs and in
libcore/intrinsics.rs in the Rust source code. Example:
#![feature(intrinsics)]
extern "rust-intrinsic" {
    fn atomic_fence(); // ok!
fn main() {
    unsafe {
        atomic_fence();
    }
E0094
You gave an invalid number of type parameters to an intrinsic function.
Erroneous code example:
```compile_fail,E0094
#![feature(intrinsics)]
extern "rust-intrinsic" {
    fn size_of<T, U>() -> usize; // error: intrinsic has wrong number
                                 //        of type parameters
Please check that you provided the right number of type parameters
and verify with the function declaration in the Rust source code.
Example:
#![feature(intrinsics)]
extern "rust-intrinsic" {
    fn size_of<T>() -> usize; // ok!
E0107
This error means that an incorrect number of lifetime parameters were provided
for a type (like a struct or enum) or trait:
```compile_fail,E0107
struct Foo<'a, 'b>(&'a str, &'b str);
enum Bar { A, B, C }
struct Baz<'a> {
    foo: Foo<'a>, // error: expected 2, found 1
    bar: Bar<'a>, // error: expected 0, found 1
E0109
You tried to give a type parameter to a type which doesn't need it. Erroneous
code example:
```compile_fail,E0109
type X = u32<i32>; // error: type parameters are not allowed on this type
Please check that you used the correct type and recheck its definition. Perhaps
it doesn't need the type parameter.
Example:
type X = u32; // this compiles
Note that type parameters for enum-variant constructors go after the variant,
not after the enum (`Option::None::<u32>`, not `Option::<u32>::None`).
E0110
You tried to give a lifetime parameter to a type which doesn't need it.
Erroneous code example:
```compile_fail,E0110
type X = u32<'static>; // error: lifetime parameters are not allowed on
                       //        this type
Please check that the correct type was used and recheck its definition; perhaps
it doesn't need the lifetime parameter. Example:
type X = u32; // ok!
E0116
You can only define an inherent implementation for a type in the same crate
where the type was defined. For example, an `impl` block as below is not allowed
since `Vec` is defined in the standard library:
```compile_fail,E0116
impl Vec<u8> { } // error
To fix this problem, you can do either of these things:
 - define a trait that has the desired associated functions/types/constants and
   implement the trait for the type in question
 - define a new type wrapping the type and define an implementation on the new
   type
Note that using the `type` keyword does not work here because `type` only
introduces a type alias:
```compile_fail,E0116
type Bytes = Vec<u8>;
impl Bytes { } // error, same as above
E0117
This error indicates a violation of one of Rust's orphan rules for trait
implementations. The rule prohibits any implementation of a foreign trait (a
trait defined in another crate) where
 - the type that is implementing the trait is foreign
 - all of the parameters being passed to the trait (if there are any) are also
   foreign.
Here's one example of this error:
```compile_fail,E0117
impl Drop for u32 {}
To avoid this kind of error, ensure that at least one local type is referenced
by the `impl`:
pub struct Foo; // you define your type in your crate
impl Drop for Foo { // and you can implement the trait on it!
    // code of trait implementation here
#   fn drop(&mut self) { }
impl From<Foo> for i32 { // or you use a type from your crate as
                         // a type parameter
    fn from(i: Foo) -> i32 {
        0
    }
Alternatively, define a trait locally and implement that instead:
trait Bar {
    fn get(&self) -> usize;
impl Bar for u32 {
    fn get(&self) -> usize { 0 }
For information on the design of the orphan rules, see [RFC 1023].
[RFC 1023]: https://github.com/rust-lang/rfcs/blob/master/text/1023-rebalancing-coherence.md
E0118
You're trying to write an inherent implementation for something which isn't a
struct nor an enum. Erroneous code example:
```compile_fail,E0118
impl (u8, u8) { // error: no base type found for inherent implementation
    fn get_state(&self) -> String {
        // ...
    }
To fix this error, please implement a trait on the type or wrap it in a struct.
Example:
// we create a trait here
trait LiveLongAndProsper {
    fn get_state(&self) -> String;
// and now you can implement it on (u8, u8)
impl LiveLongAndProsper for (u8, u8) {
    fn get_state(&self) -> String {
        "He's dead, Jim!".to_owned()
    }
Alternatively, you can create a newtype. A newtype is a wrapping tuple-struct.
For example, `NewType` is a newtype over `Foo` in `struct NewType(Foo)`.
Example:
struct TypeWrapper((u8, u8));
impl TypeWrapper {
    fn get_state(&self) -> String {
        "Fascinating!".to_owned()
    }
E0120
An attempt was made to implement Drop on a trait, which is not allowed: only
structs and enums can implement Drop. An example causing this error:
```compile_fail,E0120
trait MyTrait {}
impl Drop for MyTrait {
    fn drop(&mut self) {}
A workaround for this problem is to wrap the trait up in a struct, and implement
Drop on that. An example is shown below:
trait MyTrait {}
struct MyWrapper<T: MyTrait> { foo: T }
impl <T: MyTrait> Drop for MyWrapper<T> {
    fn drop(&mut self) {}
Alternatively, wrapping trait objects requires something like the following:
trait MyTrait {}
//or Box<MyTrait>, if you wanted an owned trait object
struct MyWrapper<'a> { foo: &'a MyTrait }
impl <'a> Drop for MyWrapper<'a> {
    fn drop(&mut self) {}
E0121
In order to be consistent with Rust's lack of global type inference, type
placeholders are disallowed by design in item signatures.
Examples of this error include:
```compile_fail,E0121
fn foo() -> _ { 5 } // error, explicitly write out the return type instead
static BAR: _ = "test"; // error, explicitly write out the type instead
E0122
An attempt was made to add a generic constraint to a type alias. This constraint
is entirely ignored. For backwards compatibility, Rust still allows this with a
warning. Consider the example below:
trait Foo{}
type MyType<R: Foo> = (R, ());
fn main() {
    let t: MyType<u32>;
We're able to declare a variable of type `MyType<u32>`, despite the fact that
`u32` does not implement `Foo`. As a result, one should avoid using generic
constraints in concert with type aliases.
E0124
You declared two fields of a struct with the same name. Erroneous code
example:
```compile_fail,E0124
struct Foo {
    field1: i32,
    field1: i32, // error: field is already declared
Please verify that the field names have been correctly spelled. Example:
struct Foo {
    field1: i32,
    field2: i32, // ok!
E0164
This error means that an attempt was made to match a struct type enum
variant as a non-struct type:
```compile_fail,E0164
enum Foo { B { i: u32 } }
fn bar(foo: Foo) -> u32 {
    match foo {
        Foo::B(i) => i, // error E0164
    }
Try using `{}` instead:
enum Foo { B { i: u32 } }
fn bar(foo: Foo) -> u32 {
    match foo {
        Foo::B{i} => i,
    }
E0184
Explicitly implementing both Drop and Copy for a type is currently disallowed.
This feature can make some sense in theory, but the current implementation is
incorrect and can lead to memory unsafety (see [issue #20126][iss20126]), so
it has been disabled for now.
[iss20126]: https://github.com/rust-lang/rust/issues/20126
E0185
An associated function for a trait was defined to be static, but an
implementation of the trait declared the same function to be a method (i.e. to
take a `self` parameter).
Here's an example of this error:
```compile_fail,E0185
trait Foo {
    fn foo();
struct Bar;
impl Foo for Bar {
    // error, method `foo` has a `&self` declaration in the impl, but not in
    // the trait
    fn foo(&self) {}
E0186
An associated function for a trait was defined to be a method (i.e. to take a
`self` parameter), but an implementation of the trait declared the same function
to be static.
Here's an example of this error:
```compile_fail,E0186
trait Foo {
    fn foo(&self);
struct Bar;
impl Foo for Bar {
    // error, method `foo` has a `&self` declaration in the trait, but not in
    // the impl
    fn foo() {}
E0191
Trait objects need to have all associated types specified. Erroneous code
example:
```compile_fail,E0191
trait Trait {
    type Bar;
type Foo = Trait; // error: the value of the associated type `Bar` (from
                  //        the trait `Trait`) must be specified
Please verify you specified all associated types of the trait and that you
used the right trait. Example:
trait Trait {
    type Bar;
type Foo = Trait<Bar=i32>; // ok!
E0192
Negative impls are only allowed for auto traits. For more
information see the [opt-in builtin traits RFC][RFC 19].
[RFC 19]: https://github.com/rust-lang/rfcs/blob/master/text/0019-opt-in-builtin-traits.md
E0193
#### Note: this error code is no longer emitted by the compiler.
`where` clauses must use generic type parameters: it does not make sense to use
them otherwise. An example causing this error:
trait Foo {
    fn bar(&self);
#[derive(Copy,Clone)]
struct Wrapper<T> {
    Wrapped: T
impl Foo for Wrapper<u32> where Wrapper<u32>: Clone {
    fn bar(&self) { }
This use of a `where` clause is strange - a more common usage would look
something like the following:
trait Foo {
    fn bar(&self);
#[derive(Copy,Clone)]
struct Wrapper<T> {
    Wrapped: T
impl <T> Foo for Wrapper<T> where Wrapper<T>: Clone {
    fn bar(&self) { }
Here, we're saying that the implementation exists on Wrapper only when the
wrapped type `T` implements `Clone`. The `where` clause is important because
some types will not implement `Clone`, and thus will not get this method.
In our erroneous example, however, we're referencing a single concrete type.
Since we know for certain that `Wrapper<u32>` implements `Clone`, there's no
reason to also specify it in a `where` clause.
E0194
A type parameter was declared which shadows an existing one. An example of this
error:
```compile_fail,E0194
trait Foo<T> {
    fn do_something(&self) -> T;
    fn do_something_else<T: Clone>(&self, bar: T);
In this example, the trait `Foo` and the trait method `do_something_else` both
define a type parameter `T`. This is not allowed: if the method wishes to
define a type parameter, it must use a different name for it.
E0195
Your method's lifetime parameters do not match the trait declaration.
Erroneous code example:
```compile_fail,E0195
trait Trait {
    fn bar<'a,'b:'a>(x: &'a str, y: &'b str);
struct Foo;
impl Trait for Foo {
    fn bar<'a,'b>(x: &'a str, y: &'b str) {
    // error: lifetime parameters or bounds on method `bar`
    // do not match the trait declaration
    }
The lifetime constraint `'b` for bar() implementation does not match the
trait declaration. Ensure lifetime declarations match exactly in both trait
declaration and implementation. Example:
trait Trait {
    fn t<'a,'b:'a>(x: &'a str, y: &'b str);
struct Foo;
impl Trait for Foo {
    fn t<'a,'b:'a>(x: &'a str, y: &'b str) { // ok!
    }
E0199
Safe traits should not have unsafe implementations, therefore marking an
implementation for a safe trait unsafe will cause a compiler error. Removing
the unsafe marker on the trait noted in the error will resolve this problem.
```compile_fail,E0199
struct Foo;
trait Bar { }
// this won't compile because Bar is safe
unsafe impl Bar for Foo { }
// this will compile
impl Bar for Foo { }
E0200
Unsafe traits must have unsafe implementations. This error occurs when an
implementation for an unsafe trait isn't marked as unsafe. This may be resolved
by marking the unsafe implementation as unsafe.
```compile_fail,E0200
struct Foo;
unsafe trait Bar { }
// this won't compile because Bar is unsafe and impl isn't unsafe
impl Bar for Foo { }
// this will compile
unsafe impl Bar for Foo { }
E0201
It is an error to define two associated items (like methods, associated types,
associated functions, etc.) with the same identifier.
For example:
```compile_fail,E0201
struct Foo(u8);
impl Foo {
    fn bar(&self) -> bool { self.0 > 5 }
    fn bar() {} // error: duplicate associated function
trait Baz {
    type Quux;
    fn baz(&self) -> bool;
impl Baz for Foo {
    type Quux = u32;
    fn baz(&self) -> bool { true }
    // error: duplicate method
    fn baz(&self) -> bool { self.0 > 5 }
    // error: duplicate associated type
    type Quux = u32;
Note, however, that items with the same name are allowed for inherent `impl`
blocks that don't overlap:
struct Foo<T>(T);
impl Foo<u8> {
    fn bar(&self) -> bool { self.0 > 5 }
impl Foo<bool> {
    fn bar(&self) -> bool { self.0 }
E0202
Inherent associated types were part of [RFC 195] but are not yet implemented.
See [the tracking issue][iss8995] for the status of this implementation.
[RFC 195]: https://github.com/rust-lang/rfcs/blob/master/text/0195-associated-items.md
[iss8995]: https://github.com/rust-lang/rust/issues/8995
E0204
An attempt to implement the `Copy` trait for a struct failed because one of the
fields does not implement `Copy`. To fix this, you must implement `Copy` for the
mentioned field. Note that this may not be possible, as in the example of
```compile_fail,E0204
struct Foo {
    foo : Vec<u32>,
impl Copy for Foo { }
This fails because `Vec<T>` does not implement `Copy` for any `T`.
Here's another example that will fail:
```compile_fail,E0204
#[derive(Copy)]
struct Foo<'a> {
    ty: &'a mut bool,
This fails because `&mut T` is not `Copy`, even when `T` is `Copy` (this
differs from the behavior for `&T`, which is always `Copy`).
E0206
You can only implement `Copy` for a struct or enum. Both of the following
examples will fail, because neither `i32` (primitive type) nor `&'static Bar`
(reference to `Bar`) is a struct or enum:
```compile_fail,E0206
type Foo = i32;
impl Copy for Foo { } // error
#[derive(Copy, Clone)]
struct Bar;
impl Copy for &'static Bar { } // error
E0207
Any type parameter or lifetime parameter of an `impl` must meet at least one of
the following criteria:
 - it appears in the self type of the impl
 - for a trait impl, it appears in the trait reference
 - it is bound as an associated type
### Error example 1
Suppose we have a struct `Foo` and we would like to define some methods for it.
The following definition leads to a compiler error:
```compile_fail,E0207
struct Foo;
impl<T: Default> Foo {
// error: the type parameter `T` is not constrained by the impl trait, self
// type, or predicates [E0207]
    fn get(&self) -> T {
        <T as Default>::default()
    }
The problem is that the parameter `T` does not appear in the self type (`Foo`)
of the impl. In this case, we can fix the error by moving the type parameter
from the `impl` to the method `get`:
struct Foo;
// Move the type parameter from the impl to the method
impl Foo {
    fn get<T: Default>(&self) -> T {
        <T as Default>::default()
    }
### Error example 2
As another example, suppose we have a `Maker` trait and want to establish a
type `FooMaker` that makes `Foo`s:
```compile_fail,E0207
trait Maker {
    type Item;
    fn make(&mut self) -> Self::Item;
struct Foo<T> {
    foo: T
struct FooMaker;
impl<T: Default> Maker for FooMaker {
// error: the type parameter `T` is not constrained by the impl trait, self
// type, or predicates [E0207]
    type Item = Foo<T>;
    fn make(&mut self) -> Foo<T> {
        Foo { foo: <T as Default>::default() }
    }
This fails to compile because `T` does not appear in the trait or in the
implementing type.
One way to work around this is to introduce a phantom type parameter into
`FooMaker`, like so:
use std::marker::PhantomData;
trait Maker {
    type Item;
    fn make(&mut self) -> Self::Item;
struct Foo<T> {
    foo: T
// Add a type parameter to `FooMaker`
struct FooMaker<T> {
    phantom: PhantomData<T>,
impl<T: Default> Maker for FooMaker<T> {
    type Item = Foo<T>;
    fn make(&mut self) -> Foo<T> {
        Foo {
            foo: <T as Default>::default(),
        }
    }
Another way is to do away with the associated type in `Maker` and use an input
type parameter instead:
// Use a type parameter instead of an associated type here
trait Maker<Item> {
    fn make(&mut self) -> Item;
struct Foo<T> {
    foo: T
struct FooMaker;
impl<T: Default> Maker<Foo<T>> for FooMaker {
    fn make(&mut self) -> Foo<T> {
        Foo { foo: <T as Default>::default() }
    }
### Additional information
For more information, please see [RFC 447].
[RFC 447]: https://github.com/rust-lang/rfcs/blob/master/text/0447-no-unused-impl-parameters.md
E0210
This error indicates a violation of one of Rust's orphan rules for trait
implementations. The rule concerns the use of type parameters in an
implementation of a foreign trait (a trait defined in another crate), and
states that type parameters must be "covered" by a local type. To understand
what this means, it is perhaps easiest to consider a few examples.
If `ForeignTrait` is a trait defined in some external crate `foo`, then the
following trait `impl` is an error:
```compile_fail,E0210
# #[cfg(for_demonstration_only)]
extern crate foo;
# #[cfg(for_demonstration_only)]
use foo::ForeignTrait;
# use std::panic::UnwindSafe as ForeignTrait;
impl<T> ForeignTrait for T { } // error
# fn main() {}
To work around this, it can be covered with a local type, `MyType`:
# use std::panic::UnwindSafe as ForeignTrait;
struct MyType<T>(T);
impl<T> ForeignTrait for MyType<T> { } // Ok
Please note that a type alias is not sufficient.
For another example of an error, suppose there's another trait defined in `foo`
named `ForeignTrait2` that takes two type parameters. Then this `impl` results
in the same rule violation:
```ignore (cannot-doctest-multicrate-project)
struct MyType2;
impl<T> ForeignTrait2<T, MyType<T>> for MyType2 { } // error
The reason for this is that there are two appearances of type parameter `T` in
the `impl` header, both as parameters for `ForeignTrait2`. The first appearance
is uncovered, and so runs afoul of the orphan rule.
Consider one more example:
```ignore (cannot-doctest-multicrate-project)
impl<T> ForeignTrait2<MyType<T>, T> for MyType2 { } // Ok
This only differs from the previous `impl` in that the parameters `T` and
`MyType<T>` for `ForeignTrait2` have been swapped. This example does *not*
violate the orphan rule; it is permitted.
To see why that last example was allowed, you need to understand the general
rule. Unfortunately this rule is a bit tricky to state. Consider an `impl`:
```ignore (only-for-syntax-highlight)
impl<P1, ..., Pm> ForeignTrait<T1, ..., Tn> for T0 { ... }
where `P1, ..., Pm` are the type parameters of the `impl` and `T0, ..., Tn`
are types. One of the types `T0, ..., Tn` must be a local type (this is another
orphan rule, see the explanation for E0117). Let `i` be the smallest integer
such that `Ti` is a local type. Then no type parameter can appear in any of the
`Tj` for `j < i`.
For information on the design of the orphan rules, see [RFC 1023].
[RFC 1023]: https://github.com/rust-lang/rfcs/blob/master/text/1023-rebalancing-coherence.md
E0220
You used an associated type which isn't defined in the trait.
Erroneous code example:
```compile_fail,E0220
trait T1 {
    type Bar;
type Foo = T1<F=i32>; // error: associated type `F` not found for `T1`
// or:
trait T2 {
    type Bar;
    // error: Baz is used but not declared
    fn return_bool(&self, _: &Self::Bar, _: &Self::Baz) -> bool;
Make sure that you have defined the associated type in the trait body.
Also, verify that you used the right trait or you didn't misspell the
associated type name. Example:
trait T1 {
    type Bar;
type Foo = T1<Bar=i32>; // ok!
// or:
trait T2 {
    type Bar;
    type Baz; // we declare `Baz` in our trait.
    // and now we can use it here:
    fn return_bool(&self, _: &Self::Bar, _: &Self::Baz) -> bool;
E0221
An attempt was made to retrieve an associated type, but the type was ambiguous.
For example:
```compile_fail,E0221
trait T1 {}
trait T2 {}
trait Foo {
    type A: T1;
trait Bar : Foo {
    type A: T2;
    fn do_something() {
        let _: Self::A;
    }
In this example, `Foo` defines an associated type `A`. `Bar` inherits that type
from `Foo`, and defines another associated type of the same name. As a result,
when we attempt to use `Self::A`, it's ambiguous whether we mean the `A` defined
by `Foo` or the one defined by `Bar`.
There are two options to work around this issue. The first is simply to rename
one of the types. Alternatively, one can specify the intended type using the
following syntax:
trait T1 {}
trait T2 {}
trait Foo {
    type A: T1;
trait Bar : Foo {
    type A: T2;
    fn do_something() {
        let _: <Self as Bar>::A;
    }
E0223
An attempt was made to retrieve an associated type, but the type was ambiguous.
For example:
```compile_fail,E0223
trait MyTrait {type X; }
fn main() {
    let foo: MyTrait::X;
The problem here is that we're attempting to take the type of X from MyTrait.
Unfortunately, the type of X is not defined, because it's only made concrete in
implementations of the trait. A working version of this code might look like:
trait MyTrait {type X; }
struct MyStruct;
impl MyTrait for MyStruct {
    type X = u32;
fn main() {
    let foo: <MyStruct as MyTrait>::X;
This syntax specifies that we want the X type from MyTrait, as made concrete in
MyStruct. The reason that we cannot simply use `MyStruct::X` is that MyStruct
might implement two different traits with identically-named associated types.
This syntax allows disambiguation between the two.
E0225
You attempted to use multiple types as bounds for a closure or trait object.
Rust does not currently support this. A simple example that causes this error:
```compile_fail,E0225
fn main() {
    let _: Box<std::io::Read + std::io::Write>;
Auto traits such as Send and Sync are an exception to this rule:
It's possible to have bounds of one non-builtin trait, plus any number of
auto traits. For example, the following compiles correctly:
fn main() {
    let _: Box<std::io::Read + Send + Sync>;
E0229
An associated type binding was done outside of the type parameter declaration
and `where` clause. Erroneous code example:
```compile_fail,E0229
pub trait Foo {
    type A;
    fn boo(&self) -> <Self as Foo>::A;
struct Bar;
impl Foo for isize {
    type A = usize;
    fn boo(&self) -> usize { 42 }
fn baz<I>(x: &<I as Foo<A=Bar>>::A) {}
// error: associated type bindings are not allowed here
To solve this error, please move the type bindings in the type parameter
declaration:
# struct Bar;
# trait Foo { type A; }
fn baz<I: Foo<A=Bar>>(x: &<I as Foo>::A) {} // ok!
Or in the `where` clause:
# struct Bar;
# trait Foo { type A; }
fn baz<I>(x: &<I as Foo>::A) where I: Foo<A=Bar> {}
E0243
This error indicates that not enough type parameters were found in a type or
trait.
For example, the `Foo` struct below is defined to be generic in `T`, but the
type parameter is missing in the definition of `Bar`:
```compile_fail,E0243
struct Foo<T> { x: T }
struct Bar { x: Foo }
E0244
This error indicates that too many type parameters were found in a type or
trait.
For example, the `Foo` struct below has no type parameters, but is supplied
with two in the definition of `Bar`:
```compile_fail,E0244
struct Foo { x: bool }
struct Bar<S, T> { x: Foo<S, T> }
E0321
A cross-crate opt-out trait was implemented on something which wasn't a struct
or enum type. Erroneous code example:
```compile_fail,E0321
#![feature(optin_builtin_traits)]
struct Foo;
impl !Sync for Foo {}
unsafe impl Send for &'static Foo {}
// error: cross-crate traits with a default impl, like `core::marker::Send`,
//        can only be implemented for a struct/enum type, not
//        `&'static Foo`
Only structs and enums are permitted to impl Send, Sync, and other opt-out
trait, and the struct or enum must be local to the current crate. So, for
example, `unsafe impl Send for Rc<Foo>` is not allowed.
E0322
The `Sized` trait is a special trait built-in to the compiler for types with a
constant size known at compile-time. This trait is automatically implemented
for types as needed by the compiler, and it is currently disallowed to
explicitly implement it for a type.
E0323
An associated const was implemented when another trait item was expected.
Erroneous code example:
```compile_fail,E0323
trait Foo {
    type N;
struct Bar;
impl Foo for Bar {
    const N : u32 = 0;
    // error: item `N` is an associated const, which doesn't match its
    //        trait `<Bar as Foo>`
Please verify that the associated const wasn't misspelled and the correct trait
was implemented. Example:
struct Bar;
trait Foo {
    type N;
impl Foo for Bar {
    type N = u32; // ok!
struct Bar;
trait Foo {
    const N : u32;
impl Foo for Bar {
    const N : u32 = 0; // ok!
E0324
A method was implemented when another trait item was expected. Erroneous
code example:
```compile_fail,E0324
struct Bar;
trait Foo {
    const N : u32;
    fn M();
impl Foo for Bar {
    fn N() {}
    // error: item `N` is an associated method, which doesn't match its
    //        trait `<Bar as Foo>`
To fix this error, please verify that the method name wasn't misspelled and
verify that you are indeed implementing the correct trait items. Example:
struct Bar;
trait Foo {
    const N : u32;
    fn M();
impl Foo for Bar {
    const N : u32 = 0;
    fn M() {} // ok!
E0325
An associated type was implemented when another trait item was expected.
Erroneous code example:
```compile_fail,E0325
struct Bar;
trait Foo {
    const N : u32;
impl Foo for Bar {
    type N = u32;
    // error: item `N` is an associated type, which doesn't match its
    //        trait `<Bar as Foo>`
Please verify that the associated type name wasn't misspelled and your
implementation corresponds to the trait definition. Example:
struct Bar;
trait Foo {
    type N;
impl Foo for Bar {
    type N = u32; // ok!
struct Bar;
trait Foo {
    const N : u32;
impl Foo for Bar {
    const N : u32 = 0; // ok!
E0326
The types of any associated constants in a trait implementation must match the
types in the trait definition. This error indicates that there was a mismatch.
Here's an example of this error:
```compile_fail,E0326
trait Foo {
    const BAR: bool;
struct Bar;
impl Foo for Bar {
    const BAR: u32 = 5; // error, expected bool, found u32
E0328
The Unsize trait should not be implemented directly. All implementations of
Unsize are provided automatically by the compiler.
Erroneous code example:
```compile_fail,E0328
#![feature(unsize)]
use std::marker::Unsize;
pub struct MyType;
impl<T> Unsize<T> for MyType {}
If you are defining your own smart pointer type and would like to enable
conversion from a sized to an unsized type with the
[DST coercion system][RFC 982], use [`CoerceUnsized`] instead.
#![feature(coerce_unsized)]
use std::ops::CoerceUnsized;
pub struct MyType<T: ?Sized> {
    field_with_unsized_type: T,
impl<T, U> CoerceUnsized<MyType<U>> for MyType<T>
    where T: CoerceUnsized<U> {}
[RFC 982]: https://github.com/rust-lang/rfcs/blob/master/text/0982-dst-coercion.md
[`CoerceUnsized`]: https://doc.rust-lang.org/std/ops/trait.CoerceUnsized.html
E0366
An attempt was made to implement `Drop` on a concrete specialization of a
generic type. An example is shown below:
```compile_fail,E0366
struct Foo<T> {
    t: T
impl Drop for Foo<u32> {
    fn drop(&mut self) {}
This code is not legal: it is not possible to specialize `Drop` to a subset of
implementations of a generic type. One workaround for this is to wrap the
generic type, as shown below:
struct Foo<T> {
    t: T
struct Bar {
    t: Foo<u32>
impl Drop for Bar {
    fn drop(&mut self) {}
E0367
An attempt was made to implement `Drop` on a specialization of a generic type.
An example is shown below:
```compile_fail,E0367
trait Foo{}
struct MyStruct<T> {
    t: T
impl<T: Foo> Drop for MyStruct<T> {
    fn drop(&mut self) {}
This code is not legal: it is not possible to specialize `Drop` to a subset of
implementations of a generic type. In order for this code to work, `MyStruct`
must also require that `T` implements `Foo`. Alternatively, another option is
to wrap the generic type in another that specializes appropriately:
trait Foo{}
struct MyStruct<T> {
    t: T
struct MyStructWrapper<T: Foo> {
    t: MyStruct<T>
impl <T: Foo> Drop for MyStructWrapper<T> {
    fn drop(&mut self) {}
E0368
This error indicates that a binary assignment operator like `+=` or `^=` was
applied to a type that doesn't support it. For example:
```compile_fail,E0368
let mut x = 12f32; // error: binary operation `<<` cannot be applied to
                   //        type `f32`
x <<= 2;
To fix this error, please check that this type implements this binary
operation. Example:
let mut x = 12u32; // the `u32` type does implement the `ShlAssign` trait
x <<= 2; // ok!
It is also possible to overload most operators for your own type by
implementing the `[OP]Assign` traits from `std::ops`.
Another problem you might be facing is this: suppose you've overloaded the `+`
operator for some type `Foo` by implementing the `std::ops::Add` trait for
`Foo`, but you find that using `+=` does not work, as in this example:
```compile_fail,E0368
use std::ops::Add;
struct Foo(u32);
impl Add for Foo {
    type Output = Foo;
    fn add(self, rhs: Foo) -> Foo {
        Foo(self.0 + rhs.0)
    }
fn main() {
    let mut x: Foo = Foo(5);
    x += Foo(7); // error, `+= cannot be applied to the type `Foo`
This is because `AddAssign` is not automatically implemented, so you need to
manually implement it for your type.
E0369
A binary operation was attempted on a type which doesn't support it.
Erroneous code example:
```compile_fail,E0369
let x = 12f32; // error: binary operation `<<` cannot be applied to
               //        type `f32`
x << 2;
To fix this error, please check that this type implements this binary
operation. Example:
let x = 12u32; // the `u32` type does implement it:
               // https://doc.rust-lang.org/stable/std/ops/trait.Shl.html
x << 2; // ok!
It is also possible to overload most operators for your own type by
implementing traits from `std::ops`.
String concatenation appends the string on the right to the string on the
left and may require reallocation. This requires ownership of the string
on the left. If something should be added to a string literal, move the
literal to the heap by allocating it with `to_owned()` like in
`"Your text".to_owned()`.
E0370
The maximum value of an enum was reached, so it cannot be automatically
set in the next enum value. Erroneous code example:
```compile_fail
#[deny(overflowing_literals)]
enum Foo {
    X = 0x7fffffffffffffff,
    Y, // error: enum discriminant overflowed on value after
       //        9223372036854775807: i64; set explicitly via
       //        Y = -9223372036854775808 if that is desired outcome
To fix this, please set manually the next enum value or put the enum variant
with the maximum value at the end of the enum. Examples:
enum Foo {
    X = 0x7fffffffffffffff,
    Y = 0, // ok!
enum Foo {
    Y = 0, // ok!
    X = 0x7fffffffffffffff,
E0371
When `Trait2` is a subtrait of `Trait1` (for example, when `Trait2` has a
definition like `trait Trait2: Trait1 { ... }`), it is not allowed to implement
`Trait1` for `Trait2`. This is because `Trait2` already implements `Trait1` by
definition, so it is not useful to do this.
Example:
```compile_fail,E0371
trait Foo { fn foo(&self) { } }
trait Bar: Foo { }
trait Baz: Bar { }
impl Bar for Baz { } // error, `Baz` implements `Bar` by definition
impl Foo for Baz { } // error, `Baz` implements `Bar` which implements `Foo`
impl Baz for Baz { } // error, `Baz` (trivially) implements `Baz`
impl Baz for Bar { } // Note: This is OK
E0374
A struct without a field containing an unsized type cannot implement
`CoerceUnsized`. An
[unsized type](https://doc.rust-lang.org/book/first-edition/unsized-types.html)
is any type that the compiler doesn't know the length or alignment of at
compile time. Any struct containing an unsized type is also unsized.
Example of erroneous code:
```compile_fail,E0374
#![feature(coerce_unsized)]
use std::ops::CoerceUnsized;
struct Foo<T: ?Sized> {
    a: i32,
// error: Struct `Foo` has no unsized fields that need `CoerceUnsized`.
impl<T, U> CoerceUnsized<Foo<U>> for Foo<T>
    where T: CoerceUnsized<U> {}
`CoerceUnsized` is used to coerce one struct containing an unsized type
into another struct containing a different unsized type. If the struct
doesn't have any fields of unsized types then you don't need explicit
coercion to get the types you want. To fix this you can either
not try to implement `CoerceUnsized` or you can add a field that is
unsized to the struct.
Example:
#![feature(coerce_unsized)]
use std::ops::CoerceUnsized;
// We don't need to impl `CoerceUnsized` here.
struct Foo {
    a: i32,
// We add the unsized type field to the struct.
struct Bar<T: ?Sized> {
    a: i32,
    b: T,
// The struct has an unsized field so we can implement
// `CoerceUnsized` for it.
impl<T, U> CoerceUnsized<Bar<U>> for Bar<T>
    where T: CoerceUnsized<U> {}
Note that `CoerceUnsized` is mainly used by smart pointers like `Box`, `Rc`
and `Arc` to be able to mark that they can coerce unsized types that they
are pointing at.
E0375
A struct with more than one field containing an unsized type cannot implement
`CoerceUnsized`. This only occurs when you are trying to coerce one of the
types in your struct to another type in the struct. In this case we try to
impl `CoerceUnsized` from `T` to `U` which are both types that the struct
takes. An [unsized type] is any type that the compiler doesn't know the length
or alignment of at compile time. Any struct containing an unsized type is also
unsized.
Example of erroneous code:
```compile_fail,E0375
#![feature(coerce_unsized)]
use std::ops::CoerceUnsized;
struct Foo<T: ?Sized, U: ?Sized> {
    a: i32,
    b: T,
    c: U,
// error: Struct `Foo` has more than one unsized field.
impl<T, U> CoerceUnsized<Foo<U, T>> for Foo<T, U> {}
`CoerceUnsized` only allows for coercion from a structure with a single
unsized type field to another struct with a single unsized type field.
In fact Rust only allows for a struct to have one unsized type in a struct
and that unsized type must be the last field in the struct. So having two
unsized types in a single struct is not allowed by the compiler. To fix this
use only one field containing an unsized type in the struct and then use
multiple structs to manage each unsized type field you need.
Example:
#![feature(coerce_unsized)]
use std::ops::CoerceUnsized;
struct Foo<T: ?Sized> {
    a: i32,
    b: T,
impl <T, U> CoerceUnsized<Foo<U>> for Foo<T>
    where T: CoerceUnsized<U> {}
fn coerce_foo<T: CoerceUnsized<U>, U>(t: T) -> Foo<U> {
    Foo { a: 12i32, b: t } // we use coercion to get the `Foo<U>` type we need
[unsized type]: https://doc.rust-lang.org/book/first-edition/unsized-types.html
E0376
The type you are trying to impl `CoerceUnsized` for is not a struct.
`CoerceUnsized` can only be implemented for a struct. Unsized types are
already able to be coerced without an implementation of `CoerceUnsized`
whereas a struct containing an unsized type needs to know the unsized type
field it's containing is able to be coerced. An
[unsized type](https://doc.rust-lang.org/book/first-edition/unsized-types.html)
is any type that the compiler doesn't know the length or alignment of at
compile time. Any struct containing an unsized type is also unsized.
Example of erroneous code:
```compile_fail,E0376
#![feature(coerce_unsized)]
use std::ops::CoerceUnsized;
struct Foo<T: ?Sized> {
    a: T,
// error: The type `U` is not a struct
impl<T, U> CoerceUnsized<U> for Foo<T> {}
The `CoerceUnsized` trait takes a struct type. Make sure the type you are
providing to `CoerceUnsized` is a struct with only the last field containing an
unsized type.
Example:
#![feature(coerce_unsized)]
use std::ops::CoerceUnsized;
struct Foo<T> {
    a: T,
// The `Foo<U>` is a struct so `CoerceUnsized` can be implemented
impl<T, U> CoerceUnsized<Foo<U>> for Foo<T> where T: CoerceUnsized<U> {}
Note that in Rust, structs can only contain an unsized type if the field
containing the unsized type is the last and only unsized type field in the
struct.
E0390
You tried to implement methods for a primitive type. Erroneous code example:
```compile_fail,E0390
struct Foo {
    x: i32
impl *mut Foo {}
// error: only a single inherent implementation marked with
//        `#[lang = "mut_ptr"]` is allowed for the `*mut T` primitive
This isn't allowed, but using a trait to implement a method is a good solution.
Example:
struct Foo {
    x: i32
trait Bar {
    fn bar();
impl Bar for *mut Foo {
    fn bar() {} // ok!
E0392
This error indicates that a type or lifetime parameter has been declared
but not actually used. Here is an example that demonstrates the error:
```compile_fail,E0392
enum Foo<T> {
    Bar,
If the type parameter was included by mistake, this error can be fixed
by simply removing the type parameter, as shown below:
enum Foo {
    Bar,
Alternatively, if the type parameter was intentionally inserted, it must be
used. A simple fix is shown below:
enum Foo<T> {
    Bar(T),
This error may also commonly be found when working with unsafe code. For
example, when using raw pointers one may wish to specify the lifetime for
which the pointed-at data is valid. An initial attempt (below) causes this
error:
```compile_fail,E0392
struct Foo<'a, T> {
    x: *const T,
We want to express the constraint that Foo should not outlive `'a`, because
the data pointed to by `T` is only valid for that lifetime. The problem is
that there are no actual uses of `'a`. It's possible to work around this
by adding a PhantomData type to the struct, using it to tell the compiler
to act as if the struct contained a borrowed reference `&'a T`:
use std::marker::PhantomData;
struct Foo<'a, T: 'a> {
    x: *const T,
    phantom: PhantomData<&'a T>
[PhantomData] can also be used to express information about unused type
parameters.
[PhantomData]: https://doc.rust-lang.org/std/marker/struct.PhantomData.html
E0393
A type parameter which references `Self` in its default value was not specified.
Example of erroneous code:
```compile_fail,E0393
trait A<T=Self> {}
fn together_we_will_rule_the_galaxy(son: &A) {}
// error: the type parameter `T` must be explicitly specified in an
//        object type because its default value `Self` references the
//        type `Self`
A trait object is defined over a single, fully-defined trait. With a regular
default parameter, this parameter can just be substituted in. However, if the
default parameter is `Self`, the trait changes for each concrete type; i.e.
`i32` will be expected to implement `A<i32>`, `bool` will be expected to
implement `A<bool>`, etc... These types will not share an implementation of a
fully-defined trait; instead they share implementations of a trait with
different parameters substituted in for each implementation. This is
irreconcilable with what we need to make a trait object work, and is thus
disallowed. Making the trait concrete by explicitly specifying the value of the
defaulted parameter will fix this issue. Fixed example:
trait A<T=Self> {}
fn together_we_will_rule_the_galaxy(son: &A<i32>) {} // Ok!
E0399
You implemented a trait, overriding one or more of its associated types but did
not reimplement its default methods.
Example of erroneous code:
```compile_fail,E0399
#![feature(associated_type_defaults)]
pub trait Foo {
    type Assoc = u8;
    fn bar(&self) {}
impl Foo for i32 {
    // error - the following trait items need to be reimplemented as
    //         `Assoc` was overridden: `bar`
    type Assoc = i32;
To fix this, add an implementation for each default method from the trait:
#![feature(associated_type_defaults)]
pub trait Foo {
    type Assoc = u8;
    fn bar(&self) {}
impl Foo for i32 {
    type Assoc = i32;
    fn bar(&self) {} // ok!
E0436
The functional record update syntax is only allowed for structs. (Struct-like
enum variants don't qualify, for example.)
Erroneous code example:
```compile_fail,E0436
enum PublicationFrequency {
    Weekly,
    SemiMonthly { days: (u8, u8), annual_special: bool },
fn one_up_competitor(competitor_frequency: PublicationFrequency)
                     -> PublicationFrequency {
    match competitor_frequency {
        PublicationFrequency::Weekly => PublicationFrequency::SemiMonthly {
            days: (1, 15), annual_special: false
        },
        c @ PublicationFrequency::SemiMonthly{ .. } =>
            PublicationFrequency::SemiMonthly {
                annual_special: true, ..c // error: functional record update
                                          //        syntax requires a struct
        }
    }
Rewrite the expression without functional record update syntax:
enum PublicationFrequency {
    Weekly,
    SemiMonthly { days: (u8, u8), annual_special: bool },
fn one_up_competitor(competitor_frequency: PublicationFrequency)
                     -> PublicationFrequency {
    match competitor_frequency {
        PublicationFrequency::Weekly => PublicationFrequency::SemiMonthly {
            days: (1, 15), annual_special: false
        },
        PublicationFrequency::SemiMonthly{ days, .. } =>
            PublicationFrequency::SemiMonthly {
                days, annual_special: true // ok!
        }
    }
E0439
The length of the platform-intrinsic function `simd_shuffle`
wasn't specified. Erroneous code example:
```compile_fail,E0439
#![feature(platform_intrinsics)]
extern "platform-intrinsic" {
    fn simd_shuffle<A,B>(a: A, b: A, c: [u32; 8]) -> B;
    // error: invalid `simd_shuffle`, needs length: `simd_shuffle`
The `simd_shuffle` function needs the length of the array passed as
last parameter in its name. Example:
#![feature(platform_intrinsics)]
extern "platform-intrinsic" {
    fn simd_shuffle8<A,B>(a: A, b: A, c: [u32; 8]) -> B;
E0440
A platform-specific intrinsic function has the wrong number of type
parameters. Erroneous code example:
```compile_fail,E0440
#![feature(repr_simd)]
#![feature(platform_intrinsics)]
#[repr(simd)]
struct f64x2(f64, f64);
extern "platform-intrinsic" {
    fn x86_mm_movemask_pd<T>(x: f64x2) -> i32;
    // error: platform-specific intrinsic has wrong number of type
    //        parameters
Please refer to the function declaration to see if it corresponds
with yours. Example:
#![feature(repr_simd)]
#![feature(platform_intrinsics)]
#[repr(simd)]
struct f64x2(f64, f64);
extern "platform-intrinsic" {
    fn x86_mm_movemask_pd(x: f64x2) -> i32;
E0441
An unknown platform-specific intrinsic function was used. Erroneous
code example:
```compile_fail,E0441
#![feature(repr_simd)]
#![feature(platform_intrinsics)]
#[repr(simd)]
struct i16x8(i16, i16, i16, i16, i16, i16, i16, i16);
extern "platform-intrinsic" {
    fn x86_mm_adds_ep16(x: i16x8, y: i16x8) -> i16x8;
    // error: unrecognized platform-specific intrinsic function
Please verify that the function name wasn't misspelled, and ensure
that it is declared in the rust source code (in the file
src/librustc_platform_intrinsics/x86.rs). Example:
#![feature(repr_simd)]
#![feature(platform_intrinsics)]
#[repr(simd)]
struct i16x8(i16, i16, i16, i16, i16, i16, i16, i16);
extern "platform-intrinsic" {
    fn x86_mm_adds_epi16(x: i16x8, y: i16x8) -> i16x8; // ok!
E0442
Intrinsic argument(s) and/or return value have the wrong type.
Erroneous code example:
```compile_fail,E0442
#![feature(repr_simd)]
#![feature(platform_intrinsics)]
#[repr(simd)]
struct i8x16(i8, i8, i8, i8, i8, i8, i8, i8,
             i8, i8, i8, i8, i8, i8, i8, i8);
#[repr(simd)]
struct i32x4(i32, i32, i32, i32);
#[repr(simd)]
struct i64x2(i64, i64);
extern "platform-intrinsic" {
    fn x86_mm_adds_epi16(x: i8x16, y: i32x4) -> i64x2;
    // error: intrinsic arguments/return value have wrong type
To fix this error, please refer to the function declaration to give
it the awaited types. Example:
#![feature(repr_simd)]
#![feature(platform_intrinsics)]
#[repr(simd)]
struct i16x8(i16, i16, i16, i16, i16, i16, i16, i16);
extern "platform-intrinsic" {
    fn x86_mm_adds_epi16(x: i16x8, y: i16x8) -> i16x8; // ok!
E0443
Intrinsic argument(s) and/or return value have the wrong type.
Erroneous code example:
```compile_fail,E0443
#![feature(repr_simd)]
#![feature(platform_intrinsics)]
#[repr(simd)]
struct i16x8(i16, i16, i16, i16, i16, i16, i16, i16);
#[repr(simd)]
struct i64x8(i64, i64, i64, i64, i64, i64, i64, i64);
extern "platform-intrinsic" {
    fn x86_mm_adds_epi16(x: i16x8, y: i16x8) -> i64x8;
    // error: intrinsic argument/return value has wrong type
To fix this error, please refer to the function declaration to give
it the awaited types. Example:
#![feature(repr_simd)]
#![feature(platform_intrinsics)]
#[repr(simd)]
struct i16x8(i16, i16, i16, i16, i16, i16, i16, i16);
extern "platform-intrinsic" {
    fn x86_mm_adds_epi16(x: i16x8, y: i16x8) -> i16x8; // ok!
E0444
A platform-specific intrinsic function has wrong number of arguments.
Erroneous code example:
```compile_fail,E0444
#![feature(repr_simd)]
#![feature(platform_intrinsics)]
#[repr(simd)]
struct f64x2(f64, f64);
extern "platform-intrinsic" {
    fn x86_mm_movemask_pd(x: f64x2, y: f64x2, z: f64x2) -> i32;
    // error: platform-specific intrinsic has invalid number of arguments
Please refer to the function declaration to see if it corresponds
with yours. Example:
#![feature(repr_simd)]
#![feature(platform_intrinsics)]
#[repr(simd)]
struct f64x2(f64, f64);
extern "platform-intrinsic" {
    fn x86_mm_movemask_pd(x: f64x2) -> i32; // ok!
E0516
The `typeof` keyword is currently reserved but unimplemented.
Erroneous code example:
```compile_fail,E0516
fn main() {
    let x: typeof(92) = 92;
Try using type inference instead. Example:
fn main() {
    let x = 92;
E0520
A non-default implementation was already made on this type so it cannot be
specialized further. Erroneous code example:
```compile_fail,E0520
#![feature(specialization)]
trait SpaceLlama {
    fn fly(&self);
// applies to all T
impl<T> SpaceLlama for T {
    default fn fly(&self) {}
// non-default impl
// applies to all `Clone` T and overrides the previous impl
impl<T: Clone> SpaceLlama for T {
    fn fly(&self) {}
// since `i32` is clone, this conflicts with the previous implementation
impl SpaceLlama for i32 {
    default fn fly(&self) {}
    // error: item `fly` is provided by an `impl` that specializes
    //        another, but the item in the parent `impl` is not marked
    //        `default` and so it cannot be specialized.
Specialization only allows you to override `default` functions in
implementations.
To fix this error, you need to mark all the parent implementations as default.
Example:
#![feature(specialization)]
trait SpaceLlama {
    fn fly(&self);
// applies to all T
impl<T> SpaceLlama for T {
    default fn fly(&self) {} // This is a parent implementation.
// applies to all `Clone` T; overrides the previous impl
impl<T: Clone> SpaceLlama for T {
    default fn fly(&self) {} // This is a parent implementation but was
                             // previously not a default one, causing the error
// applies to i32, overrides the previous two impls
impl SpaceLlama for i32 {
    fn fly(&self) {} // And now that's ok!
E0527
The number of elements in an array or slice pattern differed from the number of
elements in the array being matched.
Example of erroneous code:
```compile_fail,E0527
#![feature(slice_patterns)]
let r = &[1, 2, 3, 4];
match r {
    &[a, b] => { // error: pattern requires 2 elements but array
                 //        has 4
        println!("a={}, b={}", a, b);
    }
Ensure that the pattern is consistent with the size of the matched
array. Additional elements can be matched with `..`:
#![feature(slice_patterns)]
let r = &[1, 2, 3, 4];
match r {
    &[a, b, ..] => { // ok!
        println!("a={}, b={}", a, b);
    }
E0528
An array or slice pattern required more elements than were present in the
matched array.
Example of erroneous code:
```compile_fail,E0528
#![feature(slice_patterns)]
let r = &[1, 2];
match r {
    &[a, b, c, rest..] => { // error: pattern requires at least 3
                            //        elements but array has 2
        println!("a={}, b={}, c={} rest={:?}", a, b, c, rest);
    }
Ensure that the matched array has at least as many elements as the pattern
requires. You can match an arbitrary number of remaining elements with `..`:
#![feature(slice_patterns)]
let r = &[1, 2, 3, 4, 5];
match r {
    &[a, b, c, rest..] => { // ok!
        // prints `a=1, b=2, c=3 rest=[4, 5]`
        println!("a={}, b={}, c={} rest={:?}", a, b, c, rest);
    }
E0529
An array or slice pattern was matched against some other type.
Example of erroneous code:
```compile_fail,E0529
#![feature(slice_patterns)]
let r: f32 = 1.0;
match r {
    [a, b] => { // error: expected an array or slice, found `f32`
        println!("a={}, b={}", a, b);
    }
Ensure that the pattern and the expression being matched on are of consistent
types:
#![feature(slice_patterns)]
let r = [1.0, 2.0];
match r {
    [a, b] => { // ok!
        println!("a={}, b={}", a, b);
    }
E0559
An unknown field was specified into an enum's structure variant.
Erroneous code example:
```compile_fail,E0559
enum Field {
    Fool { x: u32 },
let s = Field::Fool { joke: 0 };
// error: struct variant `Field::Fool` has no field named `joke`
Verify you didn't misspell the field's name or that the field exists. Example:
enum Field {
    Fool { joke: u32 },
let s = Field::Fool { joke: 0 }; // ok!
E0560
An unknown field was specified into a structure.
Erroneous code example:
```compile_fail,E0560
struct Simba {
    mother: u32,
let s = Simba { mother: 1, father: 0 };
// error: structure `Simba` has no field named `father`
Verify you didn't misspell the field's name or that the field exists. Example:
struct Simba {
    mother: u32,
    father: u32,
let s = Simba { mother: 1, father: 0 }; // ok!
E0569
If an impl has a generic parameter with the `#[may_dangle]` attribute, then
that impl must be declared as an `unsafe impl.
Erroneous code example:
```compile_fail,E0569
#![feature(generic_param_attrs)]
#![feature(dropck_eyepatch)]
struct Foo<X>(X);
impl<#[may_dangle] X> Drop for Foo<X> {
    fn drop(&mut self) { }
In this example, we are asserting that the destructor for `Foo` will not
access any data of type `X`, and require this assertion to be true for
overall safety in our program. The compiler does not currently attempt to
verify this assertion; therefore we must tag this `impl` as unsafe.
E0570
The requested ABI is unsupported by the current target.
The rust compiler maintains for each target a blacklist of ABIs unsupported on
that target. If an ABI is present in such a list this usually means that the
target / ABI combination is currently unsupported by llvm.
If necessary, you can circumvent this check using custom target specifications.
E0572
A return statement was found outside of a function body.
Erroneous code example:
```compile_fail,E0572
const FOO: u32 = return 0; // error: return statement outside of function body
fn main() {}
To fix this issue, just remove the return keyword or move the expression into a
function. Example:
const FOO: u32 = 0;
fn some_fn() -> u32 {
    return FOO;
fn main() {
    some_fn();
E0581
In a `fn` type, a lifetime appears only in the return type,
and not in the arguments types.
Erroneous code example:
```compile_fail,E0581
fn main() {
    // Here, `'a` appears only in the return type:
    let x: for<'a> fn() -> &'a i32;
To fix this issue, either use the lifetime in the arguments, or use
`'static`. Example:
fn main() {
    // Here, `'a` appears only in the return type:
    let x: for<'a> fn(&'a i32) -> &'a i32;
    let y: fn() -> &'static i32;
Note: The examples above used to be (erroneously) accepted by the
compiler, but this was since corrected. See [issue #33685] for more
details.
[issue #33685]: https://github.com/rust-lang/rust/issues/33685
E0582
A lifetime appears only in an associated-type binding,
and not in the input types to the trait.
Erroneous code example:
```compile_fail,E0582
fn bar<F>(t: F)
    // No type can satisfy this requirement, since `'a` does not
    // appear in any of the input types (here, `i32`):
    where F: for<'a> Fn(i32) -> Option<&'a i32>
fn main() { }
To fix this issue, either use the lifetime in the inputs, or use
`'static`. Example:
fn bar<F, G>(t: F, u: G)
    where F: for<'a> Fn(&'a i32) -> Option<&'a i32>,
          G: Fn(i32) -> Option<&'static i32>,
fn main() { }
Note: The examples above used to be (erroneously) accepted by the
compiler, but this was since corrected. See [issue #33685] for more
details.
[issue #33685]: https://github.com/rust-lang/rust/issues/33685
E0599
This error occurs when a method is used on a type which doesn't implement it:
Erroneous code example:
```compile_fail,E0599
struct Mouth;
let x = Mouth;
x.chocolate(); // error: no method named `chocolate` found for type `Mouth`
               //        in the current scope
E0600
An unary operator was used on a type which doesn't implement it.
Example of erroneous code:
```compile_fail,E0600
enum Question {
    Yes,
    No,
!Question::Yes; // error: cannot apply unary operator `!` to type `Question`
In this case, `Question` would need to implement the `std::ops::Not` trait in
order to be able to use `!` on it. Let's implement it:
use std::ops::Not;
enum Question {
    Yes,
    No,
// We implement the `Not` trait on the enum.
impl Not for Question {
    type Output = bool;
    fn not(self) -> bool {
        match self {
            Question::Yes => false, // If the `Answer` is `Yes`, then it
                                    // returns false.
            Question::No => true, // And here we do the opposite.
        }
    }
assert_eq!(!Question::Yes, false);
assert_eq!(!Question::No, true);
E0608
An attempt to index into a type which doesn't implement the `std::ops::Index`
trait was performed.
Erroneous code example:
```compile_fail,E0608
0u8[2]; // error: cannot index into a value of type `u8`
To be able to index into a type it needs to implement the `std::ops::Index`
trait. Example:
let v: Vec<u8> = vec![0, 1, 2, 3];
// The `Vec` type implements the `Index` trait so you can do:
println!("{}", v[2]);
E0604
A cast to `char` was attempted on a type other than `u8`.
Erroneous code example:
```compile_fail,E0604
0u32 as char; // error: only `u8` can be cast as `char`, not `u32`
As the error message indicates, only `u8` can be cast into `char`. Example:
let c = 86u8 as char; // ok!
assert_eq!(c, 'V');
For more information about casts, take a look at The Book:
https://doc.rust-lang.org/book/first-edition/casting-between-types.html
E0605
An invalid cast was attempted.
Erroneous code examples:
```compile_fail,E0605
let x = 0u8;
x as Vec<u8>; // error: non-primitive cast: `u8` as `std::vec::Vec<u8>`
// Another example
let v = 0 as *const u8; // So here, `v` is a `*const u8`.
v as &u8; // error: non-primitive cast: `*const u8` as `&u8`
Only primitive types can be cast into each other. Examples:
let x = 0u8;
x as u32; // ok!
let v = 0 as *const u8;
v as *const i8; // ok!
For more information about casts, take a look at The Book:
https://doc.rust-lang.org/book/first-edition/casting-between-types.html
E0606
An incompatible cast was attempted.
Erroneous code example:
```compile_fail,E0606
let x = &0u8; // Here, `x` is a `&u8`.
let y: u32 = x as u32; // error: casting `&u8` as `u32` is invalid
When casting, keep in mind that only primitive types can be cast into each
other. Example:
let x = &0u8;
let y: u32 = *x as u32; // We dereference it first and then cast it.
For more information about casts, take a look at The Book:
https://doc.rust-lang.org/book/first-edition/casting-between-types.html
E0607
A cast between a thin and a fat pointer was attempted.
Erroneous code example:
```compile_fail,E0607
let v = 0 as *const u8;
v as *const [u8];
First: what are thin and fat pointers?
Thin pointers are "simple" pointers: they are purely a reference to a memory
address.
Fat pointers are pointers referencing Dynamically Sized Types (also called DST).
DST don't have a statically known size, therefore they can only exist behind
some kind of pointers that contain additional information. Slices and trait
objects are DSTs. In the case of slices, the additional information the fat
pointer holds is their size.
To fix this error, don't try to cast directly between thin and fat pointers.
For more information about casts, take a look at The Book:
https://doc.rust-lang.org/book/first-edition/casting-between-types.html
E0609
Attempted to access a non-existent field in a struct.
Erroneous code example:
```compile_fail,E0609
struct StructWithFields {
    x: u32,
let s = StructWithFields { x: 0 };
println!("{}", s.foo); // error: no field `foo` on type `StructWithFields`
To fix this error, check that you didn't misspell the field's name or that the
field actually exists. Example:
struct StructWithFields {
    x: u32,
let s = StructWithFields { x: 0 };
println!("{}", s.x); // ok!
E0610
Attempted to access a field on a primitive type.
Erroneous code example:
```compile_fail,E0610
let x: u32 = 0;
println!("{}", x.foo); // error: `{integer}` is a primitive type, therefore
                       //        doesn't have fields
Primitive types are the most basic types available in Rust and don't have
fields. To access data via named fields, struct types are used. Example:
// We declare struct called `Foo` containing two fields:
struct Foo {
    x: u32,
    y: i64,
// We create an instance of this struct:
let variable = Foo { x: 0, y: -12 };
// And we can now access its fields:
println!("x: {}, y: {}", variable.x, variable.y);
For more information about primitives and structs, take a look at The Book:
https://doc.rust-lang.org/book/first-edition/primitive-types.html
https://doc.rust-lang.org/book/first-edition/structs.html
E0611
Attempted to access a private field on a tuple-struct.
Erroneous code example:
```compile_fail,E0611
mod some_module {
    pub struct Foo(u32);
    impl Foo {
        pub fn new() -> Foo { Foo(0) }
    }
let y = some_module::Foo::new();
println!("{}", y.0); // error: field `0` of tuple-struct `some_module::Foo`
                     //        is private
Since the field is private, you have two solutions:
1) Make the field public:
mod some_module {
    pub struct Foo(pub u32); // The field is now public.
    impl Foo {
        pub fn new() -> Foo { Foo(0) }
    }
let y = some_module::Foo::new();
println!("{}", y.0); // So we can access it directly.
2) Add a getter function to keep the field private but allow for accessing its
value:
mod some_module {
    pub struct Foo(u32);
    impl Foo {
        pub fn new() -> Foo { Foo(0) }
        // We add the getter function.
        pub fn get(&self) -> &u32 { &self.0 }
    }
let y = some_module::Foo::new();
println!("{}", y.get()); // So we can get the value through the function.
E0612
Attempted out-of-bounds tuple index.
Erroneous code example:
```compile_fail,E0612
struct Foo(u32);
let y = Foo(0);
println!("{}", y.1); // error: attempted out-of-bounds tuple index `1`
                     //        on type `Foo`
If a tuple/tuple-struct type has n fields, you can only try to access these n
fields from 0 to (n - 1). So in this case, you can only index `0`. Example:
struct Foo(u32);
let y = Foo(0);
println!("{}", y.0); // ok!
E0614
Attempted to dereference a variable which cannot be dereferenced.
Erroneous code example:
```compile_fail,E0614
let y = 0u32;
*y; // error: type `u32` cannot be dereferenced
Only types implementing `std::ops::Deref` can be dereferenced (such as `&T`).
Example:
let y = 0u32;
let x = &y;
// So here, `x` is a `&u32`, so we can dereference it:
*x; // ok!
E0615
Attempted to access a method like a field.
Erroneous code example:
```compile_fail,E0615
struct Foo {
    x: u32,
impl Foo {
    fn method(&self) {}
let f = Foo { x: 0 };
f.method; // error: attempted to take value of method `method` on type `Foo`
If you want to use a method, add `()` after it:
# struct Foo { x: u32 }
# impl Foo { fn method(&self) {} }
# let f = Foo { x: 0 };
f.method();
However, if you wanted to access a field of a struct check that the field name
is spelled correctly. Example:
# struct Foo { x: u32 }
# impl Foo { fn method(&self) {} }
# let f = Foo { x: 0 };
println!("{}", f.x);
E0616
Attempted to access a private field on a struct.
Erroneous code example:
```compile_fail,E0616
mod some_module {
    pub struct Foo {
        x: u32, // So `x` is private in here.
    }
    impl Foo {
        pub fn new() -> Foo { Foo { x: 0 } }
    }
let f = some_module::Foo::new();
println!("{}", f.x); // error: field `x` of struct `some_module::Foo` is private
If you want to access this field, you have two options:
1) Set the field public:
mod some_module {
    pub struct Foo {
        pub x: u32, // `x` is now public.
    }
    impl Foo {
        pub fn new() -> Foo { Foo { x: 0 } }
    }
let f = some_module::Foo::new();
println!("{}", f.x); // ok!
2) Add a getter function:
mod some_module {
    pub struct Foo {
        x: u32, // So `x` is still private in here.
    }
    impl Foo {
        pub fn new() -> Foo { Foo { x: 0 } }
        // We create the getter function here:
        pub fn get_x(&self) -> &u32 { &self.x }
    }
let f = some_module::Foo::new();
println!("{}", f.get_x()); // ok!
E0617
Attempted to pass an invalid type of variable into a variadic function.
Erroneous code example:
```compile_fail,E0617
extern {
    fn printf(c: *const i8, ...);
unsafe {
    printf(::std::ptr::null(), 0f32);
    // error: can't pass an `f32` to variadic function, cast to `c_double`
Certain Rust types must be cast before passing them to a variadic function,
because of arcane ABI rules dictated by the C standard. To fix the error,
cast the value to the type specified by the error message (which you may need
to import from `std::os::raw`).
E0618
Attempted to call something which isn't a function nor a method.
Erroneous code examples:
```compile_fail,E0618
enum X {
    Entry,
X::Entry(); // error: expected function, found `X::Entry`
// Or even simpler:
let x = 0i32;
x(); // error: expected function, found `i32`
Only functions and methods can be called using `()`. Example:
// We declare a function:
fn i_am_a_function() {}
// And we call it:
i_am_a_function();
E0619
The type-checker needed to know the type of an expression, but that type had not
yet been inferred.
Erroneous code example:
```compile_fail,E0619
let mut x = vec![];
match x.pop() {
    Some(v) => {
        // Here, the type of `v` is not (yet) known, so we
        // cannot resolve this method call:
        v.to_uppercase(); // error: the type of this value must be known in
                          //        this context
    }
    None => {}
Type inference typically proceeds from the top of the function to the bottom,
figuring out types as it goes. In some cases -- notably method calls and
overloadable operators like `*` -- the type checker may not have enough
information *yet* to make progress. This can be true even if the rest of the
function provides enough context (because the type-checker hasn't looked that
far ahead yet). In this case, type annotations can be used to help it along.
To fix this error, just specify the type of the variable. Example:
let mut x: Vec<String> = vec![]; // We precise the type of the vec elements.
match x.pop() {
    Some(v) => {
        v.to_uppercase(); // Since rustc now knows the type of the vec elements,
                          // we can use `v`'s methods.
    }
    None => {}
E0620
A cast to an unsized type was attempted.
Erroneous code example:
```compile_fail,E0620
let x = &[1_usize, 2] as [usize]; // error: cast to unsized type: `&[usize; 2]`
                                  //        as `[usize]`
In Rust, some types don't have a known size at compile-time. For example, in a
slice type like `[u32]`, the number of elements is not known at compile-time and
hence the overall size cannot be computed. As a result, such types can only be
manipulated through a reference (e.g., `&T` or `&mut T`) or other pointer-type
(e.g., `Box` or `Rc`). Try casting to a reference instead:
let x = &[1_usize, 2] as &[usize]; // ok!
E0622
An intrinsic was declared without being a function.
Erroneous code example:
```compile_fail,E0622
#![feature(intrinsics)]
extern "rust-intrinsic" {
    pub static breakpoint : unsafe extern "rust-intrinsic" fn();
    // error: intrinsic must be a function
fn main() { unsafe { breakpoint(); } }
An intrinsic is a function available for use in a given programming language
whose implementation is handled specially by the compiler. In order to fix this
error, just declare a function.
E0624
A private item was used outside of its scope.
Erroneous code example:
```compile_fail,E0624
mod inner {
    pub struct Foo;
    impl Foo {
        fn method(&self) {}
    }
let foo = inner::Foo;
foo.method(); // error: method `method` is private
Two possibilities are available to solve this issue:
1. Only use the item in the scope it has been defined:
mod inner {
    pub struct Foo;
    impl Foo {
        fn method(&self) {}
    }
    pub fn call_method(foo: &Foo) { // We create a public function.
        foo.method(); // Which calls the item.
    }
let foo = inner::Foo;
inner::call_method(&foo); // And since the function is public, we can call the
                          // method through it.
2. Make the item public:
mod inner {
    pub struct Foo;
    impl Foo {
        pub fn method(&self) {} // It's now public.
    }
let foo = inner::Foo;
foo.method(); // Ok!
E0638
This error indicates that the struct or enum must be matched non-exhaustively
as it has been marked as `non_exhaustive`.
When applied within a crate, downstream users of the crate will need to use the
`_` pattern when matching enums and use the `..` pattern when matching structs.
For example, in the below example, since the enum is marked as
`non_exhaustive`, it is required that downstream crates match non-exhaustively
on it.
```rust,ignore (pseudo-Rust)
use std::error::Error as StdError;
#[non_exhaustive] pub enum Error {
   Message(String),
   Other,
impl StdError for Error {
   fn description(&self) -> &str {
        // This will not error, despite being marked as non_exhaustive, as this
        // enum is defined within the current crate, it can be matched
        // exhaustively.
        match *self {
           Message(ref s) => s,
           Other => "other or unknown error",
        }
   }
An example of matching non-exhaustively on the above enum is provided below:
```rust,ignore (pseudo-Rust)
use mycrate::Error;
// This will not error as the non_exhaustive Error enum has been matched with a
// wildcard.
match error {
   Message(ref s) => ...,
   Other => ...,
   _ => ...,
Similarly, for structs, match with `..` to avoid this error.
E0639
This error indicates that the struct or enum cannot be instantiated from
outside of the defining crate as it has been marked as `non_exhaustive` and as
such more fields/variants may be added in future that could cause adverse side
effects for this code.
It is recommended that you look for a `new` function or equivalent in the
crate's documentation.
E0643
This error indicates that there is a mismatch between generic parameters and
impl Trait parameters in a trait declaration versus its impl.
```compile_fail,E0643
#![feature(universal_impl_trait)]
trait Foo {
    fn foo(&self, _: &impl Iterator);
impl Foo for () {
    fn foo<U: Iterator>(&self, _: &U) { } // error method `foo` has incompatible
                                          // signature for trait
E0689
This error indicates that the numeric value for the method being passed exists
but the type of the numeric value or binding could not be identified.
The error happens on numeric literals:
```compile_fail,E0689
2.0.powi(2);
and on numeric bindings without an identified concrete type:
```compile_fail,E0689
let x = 2.0;
x.powi(2);  // same error as above
Because of this, you must give the numeric literal or binding a type:
let _ = 2.0_f32.powi(2);
let x: f32 = 2.0;
let _ = x.powi(2);
let _ = (2.0 as f32).powi(2);
E0690
A struct with the representation hint `repr(transparent)` had zero or more than
on fields that were not guaranteed to be zero-sized.
Erroneous code example:
```compile_fail,E0690
#![feature(repr_transparent)]
#[repr(transparent)]
struct LengthWithUnit<U> { // error: transparent struct needs exactly one
    value: f32,            //        non-zero-sized field, but has 2
    unit: U,
Because transparent structs are represented exactly like one of their fields at
run time, said field must be uniquely determined. If there is no field, or if
there are multiple fields, it is not clear how the struct should be represented.
Note that fields of zero-typed types (e.g., `PhantomData`) can also exist
alongside the field that contains the actual data, they do not count for this
error. When generic types are involved (as in the above example), an error is
reported because the type parameter could be non-zero-sized.
To combine `repr(transparent)` with type parameters, `PhantomData` may be
useful:
#![feature(repr_transparent)]
use std::marker::PhantomData;
#[repr(transparent)]
struct LengthWithUnit<U> {
    value: f32,
    unit: PhantomData<U>,
E0691
A struct with the `repr(transparent)` representation hint contains a zero-sized
field that requires non-trivial alignment.
Erroneous code example:
```compile_fail,E0691
#![feature(repr_transparent, repr_align, attr_literals)]
#[repr(align(32))]
struct ForceAlign32;
#[repr(transparent)]
struct Wrapper(f32, ForceAlign32); // error: zero-sized field in transparent
                                   //        struct has alignment larger than 1
A transparent struct is supposed to be represented exactly like the piece of
data it contains. Zero-sized fields with different alignment requirements
potentially conflict with this property. In the example above, `Wrapper` would
have to be aligned to 32 bytes even though `f32` has a smaller alignment
requirement.
Consider removing the over-aligned zero-sized field:
#![feature(repr_transparent)]
#[repr(transparent)]
struct Wrapper(f32);
Alternatively, `PhantomData<T>` has alignment 1 for all `T`, so you can use it
if you need to keep the field for some reason:
#![feature(repr_transparent, repr_align, attr_literals)]
use std::marker::PhantomData;
#[repr(align(32))]
struct ForceAlign32;
#[repr(transparent)]
struct Wrapper(f32, PhantomData<ForceAlign32>);
Note that empty arrays `[T; 0]` have the same alignment requirement as the
element type `T`. Also note that the error is conservatively reported even when
the alignment of the zero-sized type is less than or equal to the data field's
alignment.
E0908
A method was called on a raw pointer whose inner type wasn't completely known.
For example, you may have done something like:
```compile_fail
# #![deny(warnings)]
let foo = &1;
let bar = foo as *const _;
if bar.is_null() {
    // ...
Here, the type of `bar` isn't known; it could be a pointer to anything. Instead,
specify a type for the pointer (preferably something that makes sense for the
thing you're pointing to):
let foo = &1;
let bar = foo as *const i32;
if bar.is_null() {
    // ...
Even though `is_null()` exists as a method on any raw pointer, Rust shows this
error because  Rust allows for `self` to have arbitrary types (behind the
arbitrary_self_types feature flag).
This means that someone can specify such a function:
```ignore (cannot-doctest-feature-doesnt-exist-yet)
impl Foo {
    fn is_null(self: *const Self) -> bool {
        // do something else
    }
and now when you call `.is_null()` on a raw pointer to `Foo`, there's ambiguity.
Given that we don't know what type the pointer is, and there's potential
ambiguity for some types, we disallow calling methods on raw pointers when
the type is unknown.
E0401
Inner items do not inherit type parameters from the functions they are embedded
Erroneous code example:
```compile_fail,E0401
fn foo<T>(x: T) {
    fn bar(y: T) { // T is defined in the "outer" function
        // ..
    }
    bar(x);
Nor will this:
```compile_fail,E0401
fn foo<T>(x: T) {
    type MaybeT = Option<T>;
    // ...
Or this:
```compile_fail,E0401
fn foo<T>(x: T) {
    struct Foo {
        x: T,
    }
    // ...
Items inside functions are basically just like top-level items, except
that they can only be used from the function they are in.
There are a couple of solutions for this.
If the item is a function, you may use a closure:
fn foo<T>(x: T) {
    let bar = |y: T| { // explicit type annotation may not be necessary
        // ..
    };
    bar(x);
For a generic item, you can copy over the parameters:
fn foo<T>(x: T) {
    fn bar<T>(y: T) {
        // ..
    }
    bar(x);
fn foo<T>(x: T) {
    type MaybeT<T> = Option<T>;
Be sure to copy over any bounds as well:
fn foo<T: Copy>(x: T) {
    fn bar<T: Copy>(y: T) {
        // ..
    }
    bar(x);
fn foo<T: Copy>(x: T) {
    struct Foo<T: Copy> {
        x: T,
    }
This may require additional type hints in the function body.
In case the item is a function inside an `impl`, defining a private helper
function might be easier:
# struct Foo<T>(T);
impl<T> Foo<T> {
    pub fn foo(&self, x: T) {
        self.bar(x);
    }
    fn bar(&self, y: T) {
        // ..
    }
For default impls in traits, the private helper solution won't work, however
closures or copying the parameters should still work.
E0403
Some type parameters have the same name.
Erroneous code example:
```compile_fail,E0403
fn foo<T, T>(s: T, u: T) {} // error: the name `T` is already used for a type
                            //        parameter in this type parameter list
Please verify that none of the type parameterss are misspelled, and rename any
clashing parameters. Example:
fn foo<T, Y>(s: T, u: Y) {} // ok!
E0407
A definition of a method not in the implemented trait was given in a trait
implementation.
Erroneous code example:
```compile_fail,E0407
trait Foo {
    fn a();
struct Bar;
impl Foo for Bar {
    fn a() {}
    fn b() {} // error: method `b` is not a member of trait `Foo`
Please verify you didn't misspell the method name and you used the correct
trait. First example:
trait Foo {
    fn a();
    fn b();
struct Bar;
impl Foo for Bar {
    fn a() {}
    fn b() {} // ok!
Second example:
trait Foo {
    fn a();
struct Bar;
impl Foo for Bar {
    fn a() {}
impl Bar {
    fn b() {}
E0437
Trait implementations can only implement associated types that are members of
the trait in question. This error indicates that you attempted to implement
an associated type whose name does not match the name of any associated type
in the trait.
Erroneous code example:
```compile_fail,E0437
trait Foo {}
impl Foo for i32 {
    type Bar = bool;
The solution to this problem is to remove the extraneous associated type:
trait Foo {}
impl Foo for i32 {}
E0438
Trait implementations can only implement associated constants that are
members of the trait in question. This error indicates that you
attempted to implement an associated constant whose name does not
match the name of any associated constant in the trait.
Erroneous code example:
```compile_fail,E0438
trait Foo {}
impl Foo for i32 {
    const BAR: bool = true;
The solution to this problem is to remove the extraneous associated constant:
trait Foo {}
impl Foo for i32 {}
E0408
An "or" pattern was used where the variable bindings are not consistently bound
across patterns.
Erroneous code example:
```compile_fail,E0408
match x {
    Some(y) | None => { /* use y */ } // error: variable `y` from pattern #1 is
                                      //        not bound in pattern #2
    _ => ()
Here, `y` is bound to the contents of the `Some` and can be used within the
block corresponding to the match arm. However, in case `x` is `None`, we have
not specified what `y` is, and the block will use a nonexistent variable.
To fix this error, either split into multiple match arms:
let x = Some(1);
match x {
    Some(y) => { /* use y */ }
    None => { /* ... */ }
or, bind the variable to a field of the same type in all sub-patterns of the
or pattern:
let x = (0, 2);
match x {
    (0, y) | (y, 0) => { /* use y */}
    _ => {}
In this example, if `x` matches the pattern `(0, _)`, the second field is set
to `y`. If it matches `(_, 0)`, the first field is set to `y`; so in all
cases `y` is set to some value.
E0409
An "or" pattern was used where the variable bindings are not consistently bound
across patterns.
Erroneous code example:
```compile_fail,E0409
let x = (0, 2);
match x {
    (0, ref y) | (y, 0) => { /* use y */} // error: variable `y` is bound with
                                          //        different mode in pattern #2
                                          //        than in pattern #1
    _ => ()
Here, `y` is bound by-value in one case and by-reference in the other.
To fix this error, just use the same mode in both cases.
Generally using `ref` or `ref mut` where not already used will fix this:
let x = (0, 2);
match x {
    (0, ref y) | (ref y, 0) => { /* use y */}
    _ => ()
Alternatively, split the pattern:
let x = (0, 2);
match x {
    (y, 0) => { /* use y */ }
    (0, ref y) => { /* use y */}
    _ => ()
E0415
More than one function parameter have the same name.
Erroneous code example:
```compile_fail,E0415
fn foo(f: i32, f: i32) {} // error: identifier `f` is bound more than
                          //        once in this parameter list
Please verify you didn't misspell parameters' name. Example:
fn foo(f: i32, g: i32) {} // ok!
E0416
An identifier is bound more than once in a pattern.
Erroneous code example:
```compile_fail,E0416
match (1, 2) {
    (x, x) => {} // error: identifier `x` is bound more than once in the
                 //        same pattern
Please verify you didn't misspell identifiers' name. Example:
match (1, 2) {
    (x, y) => {} // ok!
Or maybe did you mean to unify? Consider using a guard:
# let (A, B, C) = (1, 2, 3);
match (A, B, C) {
    (x, x2, see) if x == x2 => { /* A and B are equal, do one thing */ }
    (y, z, see) => { /* A and B unequal; do another thing */ }
E0426
An undeclared label was used.
Erroneous code example:
```compile_fail,E0426
loop {
    break 'a; // error: use of undeclared label `'a`
Please verify you spelt or declare the label correctly. Example:
'a: loop {
    break 'a; // ok!
E0429
The `self` keyword cannot appear alone as the last segment in a `use`
declaration.
Erroneous code example:
```compile_fail,E0429
use std::fmt::self; // error: `self` imports are only allowed within a { } list
To use a namespace itself in addition to some of its members, `self` may appear
as part of a brace-enclosed list of imports:
use std::fmt::{self, Debug};
If you only want to import the namespace, do so directly:
use std::fmt;
E0430
The `self` import appears more than once in the list.
Erroneous code example:
```compile_fail,E0430
use something::{self, self}; // error: `self` import can only appear once in
                             //        the list
Please verify you didn't misspell the import name or remove the duplicated
`self` import. Example:
# mod something {}
# fn main() {
use something::{self}; // ok!
E0431
An invalid `self` import was made.
Erroneous code example:
```compile_fail,E0431
use {self}; // error: `self` import can only appear in an import list with a
            //        non-empty prefix
You cannot import the current module into itself, please remove this import
or verify you didn't misspell it.
E0432
An import was unresolved.
Erroneous code example:
```compile_fail,E0432
use something::Foo; // error: unresolved import `something::Foo`.
Paths in `use` statements are relative to the crate root. To import items
relative to the current and parent modules, use the `self::` and `super::`
prefixes, respectively. Also verify that you didn't misspell the import
name and that the import exists in the module from where you tried to
import it. Example:
use self::something::Foo; // ok!
mod something {
    pub struct Foo;
# fn main() {}
Or, if you tried to use a module from an external crate, you may have missed
the `extern crate` declaration (which is usually placed in the crate root):
extern crate core; // Required to use the `core` crate
use core::any;
# fn main() {}
E0433
An undeclared type or module was used.
Erroneous code example:
```compile_fail,E0433
let map = HashMap::new();
// error: failed to resolve. Use of undeclared type or module `HashMap`
Please verify you didn't misspell the type/module's name or that you didn't
forgot to import it:
use std::collections::HashMap; // HashMap has been imported.
let map: HashMap<u32, u32> = HashMap::new(); // So it can be used!
E0434
This error indicates that a variable usage inside an inner function is invalid
because the variable comes from a dynamic environment. Inner functions do not
have access to their containing environment.
Erroneous code example:
```compile_fail,E0434
fn foo() {
    let y = 5;
    fn bar() -> u32 {
        y // error: can't capture dynamic environment in a fn item; use the
          //        || { ... } closure form instead.
    }
Functions do not capture local variables. To fix this error, you can replace the
function with a closure:
fn foo() {
    let y = 5;
    let bar = || {
        y
    };
or replace the captured variable with a constant or a static item:
fn foo() {
    static mut X: u32 = 4;
    const Y: u32 = 5;
    fn bar() -> u32 {
        unsafe {
            X = 3;
        }
        Y
    }
E0435
A non-constant value was used in a constant expression.
Erroneous code example:
```compile_fail,E0435
let foo = 42;
let a: [u8; foo]; // error: attempt to use a non-constant value in a constant
To fix this error, please replace the value with a constant. Example:
let a: [u8; 42]; // ok!
const FOO: usize = 42;
let a: [u8; FOO]; // ok!
E0530
A binding shadowed something it shouldn't.
Erroneous code example:
```compile_fail,E0530
static TEST: i32 = 0;
let r: (i32, i32) = (0, 0);
match r {
    TEST => {} // error: match bindings cannot shadow statics
To fix this error, just change the binding's name in order to avoid shadowing
one of the following:
* struct name
* struct/enum variant
* static
* const
* associated const
Fixed example:
static TEST: i32 = 0;
let r: (i32, i32) = (0, 0);
match r {
    something => {} // ok!
E0128
Type parameter defaults can only use parameters that occur before them.
Erroneous code example:
```compile_fail,E0128
struct Foo<T=U, U=()> {
    field1: T,
    filed2: U,
// error: type parameters with a default cannot use forward declared
// identifiers
Since type parameters are evaluated in-order, you may be able to fix this issue
by doing:
struct Foo<U=(), T=U> {
    field1: T,
    filed2: U,
Please also verify that this wasn't because of a name-clash and rename the type
parameter if so.
E0404
You tried to implement something which was not a trait on an object.
Erroneous code example:
```compile_fail,E0404
struct Foo;
struct Bar;
impl Foo for Bar {} // error: `Foo` is not a trait
Please verify that you didn't misspell the trait's name or otherwise use the
wrong identifier. Example:
trait Foo {
    // some functions
struct Bar;
impl Foo for Bar { // ok!
    // functions implementation
E0405
The code refers to a trait that is not in scope.
Erroneous code example:
```compile_fail,E0405
struct Foo;
impl SomeTrait for Foo {} // error: trait `SomeTrait` is not in scope
Please verify that the name of the trait wasn't misspelled and ensure that it
was imported. Example:
# #[cfg(for_demonstration_only)]
// solution 1:
use some_file::SomeTrait;
// solution 2:
trait SomeTrait {
    // some functions
struct Foo;
impl SomeTrait for Foo { // ok!
    // implements functions
E0412
The type name used is not in scope.
Erroneous code examples:
```compile_fail,E0412
impl Something {} // error: type name `Something` is not in scope
// or:
trait Foo {
    fn bar(N); // error: type name `N` is not in scope
// or:
fn foo(x: T) {} // type name `T` is not in scope
To fix this error, please verify you didn't misspell the type name, you did
declare it or imported it into the scope. Examples:
struct Something;
impl Something {} // ok!
// or:
trait Foo {
    type N;
    fn bar(_: Self::N); // ok!
// or:
fn foo<T>(x: T) {} // ok!
Another case that causes this error is when a type is imported into a parent
module. To fix this, you can follow the suggestion and use File directly or
`use super::File;` which will import the types from the parent namespace. An
example that causes this error is below:
```compile_fail,E0412
use std::fs::File;
mod foo {
    fn some_function(f: File) {}
use std::fs::File;
mod foo {
    // either
    use super::File;
    // or
    // use std::fs::File;
    fn foo(f: File) {}
# fn main() {} // don't insert it for us; that'll break imports
E0422
You are trying to use an identifier that is either undefined or not a struct.
Erroneous code example:
```compile_fail,E0422
fn main () {
    let x = Foo { x: 1, y: 2 };
In this case, `Foo` is undefined, so it inherently isn't anything, and
definitely not a struct.
```compile_fail
fn main () {
    let foo = 1;
    let x = foo { x: 1, y: 2 };
In this case, `foo` is defined, but is not a struct, so Rust can't use it as
one.
E0423
A `struct` variant name was used like a function name.
Erroneous code example:
```compile_fail,E0423
struct Foo { a: bool };
let f = Foo();
// error: `Foo` is a struct variant name, but this expression uses
//        it like a function name
Please verify you didn't misspell the name of what you actually wanted to use
here. Example:
fn Foo() -> u32 { 0 }
let f = Foo(); // ok!
E0425
An unresolved name was used.
Erroneous code examples:
```compile_fail,E0425
something_that_doesnt_exist::foo;
// error: unresolved name `something_that_doesnt_exist::foo`
// or:
trait Foo {
    fn bar() {
        Self; // error: unresolved name `Self`
    }
// or:
let x = unknown_variable;  // error: unresolved name `unknown_variable`
Please verify that the name wasn't misspelled and ensure that the
identifier being referred to is valid for the given situation. Example:
enum something_that_does_exist {
    Foo,
mod something_that_does_exist {
    pub static foo : i32 = 0i32;
something_that_does_exist::foo; // ok!
let unknown_variable = 12u32;
let x = unknown_variable; // ok!
If the item is not defined in the current module, it must be imported using a
`use` statement, like so:
# mod foo { pub fn bar() {} }
# fn main() {
use foo::bar;
bar();
If the item you are importing is not defined in some super-module of the
current module, then it must also be declared as public (e.g., `pub fn`).
E0532
Pattern arm did not match expected kind.
Erroneous code example:
```compile_fail,E0532
enum State {
    Succeeded,
    Failed(String),
fn print_on_failure(state: &State) {
    match *state {
        // error: expected unit struct/variant or constant, found tuple
        //        variant `State::Failed`
        State::Failed => println!("Failed"),
        _ => ()
    }
To fix this error, ensure the match arm kind is the same as the expression
matched.
Fixed example:
enum State {
    Succeeded,
    Failed(String),
fn print_on_failure(state: &State) {
    match *state {
        State::Failed(ref msg) => println!("Failed with {}", msg),
        _ => ()
    }
E0411
The `Self` keyword was used outside an impl or a trait.
Erroneous code example:
```compile_fail,E0411
<Self>::foo; // error: use of `Self` outside of an impl or trait
The `Self` keyword represents the current type, which explains why it can only
be used inside an impl or a trait. It gives access to the associated items of a
type:
trait Foo {
    type Bar;
trait Baz : Foo {
    fn bar() -> Self::Bar; // like this
However, be careful when two types have a common associated type:
```compile_fail
trait Foo {
    type Bar;
trait Foo2 {
    type Bar;
trait Baz : Foo + Foo2 {
    fn bar() -> Self::Bar;
    // error: ambiguous associated type `Bar` in bounds of `Self`
This problem can be solved by specifying from which trait we want to use the
`Bar` type:
trait Foo {
    type Bar;
trait Foo2 {
    type Bar;
trait Baz : Foo + Foo2 {
    fn bar() -> <Self as Foo>::Bar; // ok!
E0424
The `self` keyword was used in a static method.
Erroneous code example:
```compile_fail,E0424
struct Foo;
impl Foo {
    fn bar(self) {}
    fn foo() {
        self.bar(); // error: `self` is not available in a static method.
    }
Please check if the method's argument list should have contained `self`,
`&self`, or `&mut self` (in case you didn't want to create a static
method), and add it if so. Example:
struct Foo;
impl Foo {
    fn bar(self) {}
    fn foo(self) {
        self.bar(); // ok!
    }
E0659
An item usage is ambiguous.
Erroneous code example:
```compile_fail,E0659
pub mod moon {
    pub fn foo() {}
pub mod earth {
    pub fn foo() {}
mod collider {
    pub use moon::*;
    pub use earth::*;
fn main() {
    collider::foo(); // ERROR: `foo` is ambiguous
This error generally appears when two items with the same name are imported into
a module. Here, the `foo` functions are imported and reexported from the
`collider` module and therefore, when we're using `collider::foo()`, both
functions collide.
To solve this error, the best solution is generally to keep the path before the
item when using it. Example:
pub mod moon {
    pub fn foo() {}
pub mod earth {
    pub fn foo() {}
mod collider {
    pub use moon;
    pub use earth;
fn main() {
    collider::moon::foo(); // ok!
    collider::earth::foo(); // ok!
E0603
A private item was used outside its scope.
Erroneous code example:
```compile_fail,E0603
mod SomeModule {
    const PRIVATE: u32 = 0x_a_bad_1dea_u32; // This const is private, so we
                                            // can't use it outside of the
                                            // `SomeModule` module.
println!("const value: {}", SomeModule::PRIVATE); // error: constant `CONSTANT`
                                                  //        is private
In order to fix this error, you need to make the item public by using the `pub`
keyword. Example:
mod SomeModule {
    pub const PRIVATE: u32 = 0x_a_bad_1dea_u32; // We set it public by using the
                                                // `pub` keyword.
println!("const value: {}", SomeModule::PRIVATE); // ok!
E0259
The name chosen for an external crate conflicts with another external crate
that has been imported into the current module.
Erroneous code example:
```compile_fail,E0259
# #![feature(libc)]
extern crate core;
extern crate libc as core;
fn main() {}
The solution is to choose a different name that doesn't conflict with any
external crate imported into the current module.
Correct example:
# #![feature(libc)]
extern crate core;
extern crate libc as other_name;
fn main() {}
E0254
Attempt was made to import an item whereas an extern crate with this name has
already been imported.
Erroneous code example:
```compile_fail,E0254
extern crate core;
mod foo {
    pub trait core {
        fn do_something();
    }
use foo::core;  // error: an extern crate named `core` has already
                //        been imported in this module
fn main() {}
To fix issue issue, you have to rename at least one of the two imports.
Example:
extern crate core as libcore; // ok!
mod foo {
    pub trait core {
        fn do_something();
    }
use foo::core;
fn main() {}
E0260
The name for an item declaration conflicts with an external crate's name.
Erroneous code example:
```compile_fail,E0260
extern crate core;
struct core;
There are two possible solutions:
Solution #1: Rename the item.
extern crate core;
struct xyz;
Solution #2: Import the crate with a different name.
extern crate core as xyz;
struct abc;
See the Declaration Statements section of the reference for more information
about what constitutes an Item declaration and what does not:
https://doc.rust-lang.org/reference.html#statements
E0428
A type or module has been defined more than once.
Erroneous code example:
```compile_fail,E0428
struct Bar;
struct Bar; // error: duplicate definition of value `Bar`
Please verify you didn't misspell the type/module's name or remove/rename the
duplicated one. Example:
struct Bar;
struct Bar2; // ok!
E0252
Two items of the same name cannot be imported without rebinding one of the
items under a new local name.
Erroneous code example:
```compile_fail,E0252
use foo::baz;
use bar::baz; // error, do `use bar::baz as quux` instead
fn main() {}
mod foo {
    pub struct baz;
mod bar {
    pub mod baz {}
You can use aliases in order to fix this error. Example:
use foo::baz as foo_baz;
use bar::baz; // ok!
fn main() {}
mod foo {
    pub struct baz;
mod bar {
    pub mod baz {}
Or you can reference the item with its parent:
use bar::baz;
fn main() {
    let x = foo::baz; // ok!
mod foo {
    pub struct baz;
mod bar {
    pub mod baz {}
E0255
You can't import a value whose name is the same as another value defined in the
module.
Erroneous code example:
```compile_fail,E0255
use bar::foo; // error: an item named `foo` is already in scope
fn foo() {}
mod bar {
     pub fn foo() {}
fn main() {}
You can use aliases in order to fix this error. Example:
use bar::foo as bar_foo; // ok!
fn foo() {}
mod bar {
     pub fn foo() {}
fn main() {}
Or you can reference the item with its parent:
fn foo() {}
mod bar {
     pub fn foo() {}
fn main() {
    bar::foo(); // we get the item by referring to its parent
E0154
#### Note: this error code is no longer emitted by the compiler.
Imports (`use` statements) are not allowed after non-item statements, such as
variable declarations and expression statements.
Here is an example that demonstrates the error:
fn f() {
    // Variable declaration before import
    let x = 0;
    use std::io::Read;
    // ...
The solution is to declare the imports at the top of the block, function, or
file.
Here is the previous example again, with the correct order:
fn f() {
    use std::io::Read;
    let x = 0;
    // ...
See the Declaration Statements section of the reference for more information
about what constitutes an Item declaration and what does not:
https://doc.rust-lang.org/reference.html#statements
E0251
#### Note: this error code is no longer emitted by the compiler.
Two items of the same name cannot be imported without rebinding one of the
items under a new local name.
An example of this error:
use foo::baz;
use bar::*; // error, do `use foo::baz as quux` instead on the previous line
fn main() {}
mod foo {
    pub struct baz;
mod bar {
    pub mod baz {}
E0253
Attempt was made to import an unimportable value. This can happen when trying
to import a method from a trait.
Erroneous code example:
```compile_fail,E0253
mod foo {
    pub trait MyTrait {
        fn do_something();
    }
use foo::MyTrait::do_something;
// error: `do_something` is not directly importable
fn main() {}
It's invalid to directly import methods belonging to a trait or concrete type.
E0256
#### Note: this error code is no longer emitted by the compiler.
You can't import a type or module when the name of the item being imported is
the same as another type or submodule defined in the module.
An example of this error:
```compile_fail
use foo::Bar; // error
type Bar = u32;
mod foo {
    pub mod Bar { }
fn main() {}
E0364
Private items cannot be publicly re-exported. This error indicates that you
attempted to `pub use` a type or value that was not itself public.
Erroneous code example:
```compile_fail
mod foo {
    const X: u32 = 1;
pub use foo::X;
fn main() {}
The solution to this problem is to ensure that the items that you are
re-exporting are themselves marked with `pub`:
mod foo {
    pub const X: u32 = 1;
pub use foo::X;
fn main() {}
See the 'Use Declarations' section of the reference for more information on
this topic:
https://doc.rust-lang.org/reference.html#use-declarations
E0365
Private modules cannot be publicly re-exported. This error indicates that you
attempted to `pub use` a module that was not itself public.
Erroneous code example:
```compile_fail,E0365
mod foo {
    pub const X: u32 = 1;
pub use foo as foo2;
fn main() {}
The solution to this problem is to ensure that the module that you are
re-exporting is itself marked with `pub`:
pub mod foo {
    pub const X: u32 = 1;
pub use foo as foo2;
fn main() {}
See the 'Use Declarations' section of the reference for more information
on this topic:
https://doc.rust-lang.org/reference.html#use-declarations
E0466
Macro import declarations were malformed.
Erroneous code examples:
```compile_fail,E0466
#[macro_use(a_macro(another_macro))] // error: invalid import declaration
extern crate core as some_crate;
#[macro_use(i_want = "some_macros")] // error: invalid import declaration
extern crate core as another_crate;
This is a syntax error at the level of attribute declarations. The proper
syntax for macro imports is the following:
```ignore (cannot-doctest-multicrate-project)
// In some_crate:
#[macro_export]
macro_rules! get_tacos {
    ...
#[macro_export]
macro_rules! get_pimientos {
    ...
// In your crate:
#[macro_use(get_tacos, get_pimientos)] // It imports `get_tacos` and
extern crate some_crate;               // `get_pimientos` macros from some_crate
If you would like to import all exported macros, write `macro_use` with no
arguments.
E0467
Macro re-export declarations were empty or malformed.
Erroneous code examples:
```compile_fail,E0467
#[macro_reexport]                    // error: no macros listed for export
extern crate core as macros_for_good;
#[macro_reexport(fun_macro = "foo")] // error: not a macro identifier
extern crate core as other_macros_for_good;
This is a syntax error at the level of attribute declarations.
Currently, `macro_reexport` requires at least one macro name to be listed.
Unlike `macro_use`, listing no names does not re-export all macros from the
given crate.
Decide which macros you would like to export and list them properly.
These are proper re-export declarations:
```ignore (cannot-doctest-multicrate-project)
#[macro_reexport(some_macro, another_macro)]
extern crate macros_for_good;
E0468
A non-root module attempts to import macros from another crate.
Example of erroneous code:
```compile_fail,E0468
mod foo {
    #[macro_use(debug_assert)]  // error: must be at crate root to import
    extern crate core;          //        macros from another crate
    fn run_macro() { debug_assert!(true); }
Only `extern crate` imports at the crate root level are allowed to import
macros.
Either move the macro import to crate root or do without the foreign macros.
This will work:
#[macro_use(debug_assert)]
extern crate core;
mod foo {
    fn run_macro() { debug_assert!(true); }
# fn main() {}
E0469
A macro listed for import was not found.
Erroneous code example:
```compile_fail,E0469
#[macro_use(drink, be_merry)] // error: imported macro not found
extern crate alloc;
fn main() {
    // ...
Either the listed macro is not contained in the imported crate, or it is not
exported from the given crate.
This could be caused by a typo. Did you misspell the macro's name?
Double-check the names of the macros listed for import, and that the crate
in question exports them.
A working version would be:
```ignore (cannot-doctest-multicrate-project)
// In some_crate crate:
#[macro_export]
macro_rules! eat {
    ...
#[macro_export]
macro_rules! drink {
    ...
// In your crate:
#[macro_use(eat, drink)]
extern crate some_crate; //ok!
E0470
A macro listed for re-export was not found.
Erroneous code example:
```compile_fail,E0470
#[macro_reexport(drink, be_merry)]
extern crate alloc;
fn main() {
    // ...
Either the listed macro is not contained in the imported crate, or it is not
exported from the given crate.
This could be caused by a typo. Did you misspell the macro's name?
Double-check the names of the macros listed for re-export, and that the crate
in question exports them.
A working version:
```ignore (cannot-doctest-multicrate-project)
// In some_crate crate:
#[macro_export]
macro_rules! eat {
    ...
#[macro_export]
macro_rules! drink {
    ...
// In your_crate:
#[macro_reexport(eat, drink)]
extern crate some_crate;
E0451
A struct constructor with private fields was invoked. Erroneous code example:
```compile_fail,E0451
mod Bar {
    pub struct Foo {
        pub a: isize,
        b: isize,
    }
let f = Bar::Foo{ a: 0, b: 0 }; // error: field `b` of struct `Bar::Foo`
                                //        is private
To fix this error, please ensure that all the fields of the struct are public,
or implement a function for easy instantiation. Examples:
mod Bar {
    pub struct Foo {
        pub a: isize,
        pub b: isize, // we set `b` field public
    }
let f = Bar::Foo{ a: 0, b: 0 }; // ok!
mod Bar {
    pub struct Foo {
        pub a: isize,
        b: isize, // still private
    }
    impl Foo {
        pub fn new() -> Foo { // we create a method to instantiate `Foo`
            Foo { a: 0, b: 0 }
        }
    }
let f = Bar::Foo::new(); // ok!
E0445
A private trait was used on a public type parameter bound. Erroneous code
examples:
```compile_fail,E0445
#![deny(private_in_public)]
trait Foo {
    fn dummy(&self) { }
pub trait Bar : Foo {} // error: private trait in public interface
pub struct Bar2<T: Foo>(pub T); // same error
pub fn foo<T: Foo> (t: T) {} // same error
To solve this error, please ensure that the trait is also public. The trait
can be made inaccessible if necessary by placing it into a private inner
module, but it still has to be marked with `pub`. Example:
pub trait Foo { // we set the Foo trait public
    fn dummy(&self) { }
pub trait Bar : Foo {} // ok!
pub struct Bar2<T: Foo>(pub T); // ok!
pub fn foo<T: Foo> (t: T) {} // ok!
E0446
A private type was used in a public type signature. Erroneous code example:
```compile_fail,E0446
#![deny(private_in_public)]
mod Foo {
    struct Bar(u32);
    pub fn bar() -> Bar { // error: private type in public interface
        Bar(0)
    }
To solve this error, please ensure that the type is also public. The type
can be made inaccessible if necessary by placing it into a private inner
module, but it still has to be marked with `pub`.
Example:
mod Foo {
    pub struct Bar(u32); // we set the Bar type public
    pub fn bar() -> Bar { // ok!
        Bar(0)
    }
E0447
#### Note: this error code is no longer emitted by the compiler.
The `pub` keyword was used inside a function. Erroneous code example:
fn foo() {
    pub struct Bar; // error: visibility has no effect inside functions
Since we cannot access items defined inside a function, the visibility of its
items does not impact outer code. So using the `pub` keyword in this context
is invalid.
E0448
The `pub` keyword was used inside a public enum. Erroneous code example:
```compile_fail
pub enum Foo {
    pub Bar, // error: unnecessary `pub` visibility
Since the enum is already public, adding `pub` on one its elements is
unnecessary. Example:
```compile_fail
enum Foo {
    pub Bar, // not ok!
This is the correct syntax:
pub enum Foo {
    Bar, // ok!
E0558
The `export_name` attribute was malformed.
Erroneous code example:
```ignore (error-emitted-at-codegen-which-cannot-be-handled-by-compile_fail)
#[export_name] // error: export_name attribute has invalid format
pub fn something() {}
fn main() {}
The `export_name` attribute expects a string in order to determine the name of
the exported symbol. Example:
#[export_name = "some_function"] // ok!
pub fn something() {}
fn main() {}
E0001
#### Note: this error code is no longer emitted by the compiler.
This error suggests that the expression arm corresponding to the noted pattern
will never be reached as for all possible values of the expression being
matched, one of the preceding patterns will match.
This means that perhaps some of the preceding patterns are too general, this
one is too specific or the ordering is incorrect.
For example, the following `match` block has too many arms:
match Some(0) {
    Some(bar) => {/* ... */}
    x => {/* ... */} // This handles the `None` case
    _ => {/* ... */} // All possible cases have already been handled
`match` blocks have their patterns matched in order, so, for example, putting
a wildcard arm above a more specific arm will make the latter arm irrelevant.
Ensure the ordering of the match arm is correct and remove any superfluous
arms.
E0002
#### Note: this error code is no longer emitted by the compiler.
This error indicates that an empty match expression is invalid because the type
it is matching on is non-empty (there exist values of this type). In safe code
it is impossible to create an instance of an empty type, so empty match
expressions are almost never desired. This error is typically fixed by adding
one or more cases to the match expression.
An example of an empty type is `enum Empty { }`. So, the following will work:
enum Empty {}
fn foo(x: Empty) {
    match x {
        // empty
    }
However, this won't:
```compile_fail
fn foo(x: Option<String>) {
    match x {
        // empty
    }
E0003
#### Note: this error code is no longer emitted by the compiler.
Not-a-Number (NaN) values cannot be compared for equality and hence can never
match the input to a match expression. So, the following will not compile:
```compile_fail
const NAN: f32 = 0.0 / 0.0;
let number = 0.1f32;
match number {
    NAN => { /* ... */ },
    _ => {}
To match against NaN values, you should instead use the `is_nan()` method in a
guard, like so:
let number = 0.1f32;
match number {
    x if x.is_nan() => { /* ... */ }
    _ => {}
E0004
This error indicates that the compiler cannot guarantee a matching pattern for
one or more possible inputs to a match expression. Guaranteed matches are
required in order to assign values to match expressions, or alternatively,
determine the flow of execution. Erroneous code example:
```compile_fail,E0004
enum Terminator {
    HastaLaVistaBaby,
    TalkToMyHand,
let x = Terminator::HastaLaVistaBaby;
match x { // error: non-exhaustive patterns: `HastaLaVistaBaby` not covered
    Terminator::TalkToMyHand => {}
If you encounter this error you must alter your patterns so that every possible
value of the input type is matched. For types with a small number of variants
(like enums) you should probably cover all cases explicitly. Alternatively, the
underscore `_` wildcard pattern can be added after all other patterns to match
"anything else". Example:
enum Terminator {
    HastaLaVistaBaby,
    TalkToMyHand,
let x = Terminator::HastaLaVistaBaby;
match x {
    Terminator::TalkToMyHand => {}
    Terminator::HastaLaVistaBaby => {}
// or:
match x {
    Terminator::TalkToMyHand => {}
    _ => {}
E0005
Patterns used to bind names must be irrefutable, that is, they must guarantee
that a name will be extracted in all cases. Erroneous code example:
```compile_fail,E0005
let x = Some(1);
let Some(y) = x;
// error: refutable pattern in local binding: `None` not covered
If you encounter this error you probably need to use a `match` or `if let` to
deal with the possibility of failure. Example:
let x = Some(1);
match x {
    Some(y) => {
        // do something
    },
    None => {}
// or:
if let Some(y) = x {
    // do something
E0007
This error indicates that the bindings in a match arm would require a value to
be moved into more than one location, thus violating unique ownership. Code
like the following is invalid as it requires the entire `Option<String>` to be
moved into a variable called `op_string` while simultaneously requiring the
inner `String` to be moved into a variable called `s`.
```compile_fail,E0007
let x = Some("s".to_string());
match x {
    op_string @ Some(s) => {}, // error: cannot bind by-move with sub-bindings
    None => {},
See also the error E0303.
E0008
Names bound in match arms retain their type in pattern guards. As such, if a
name is bound by move in a pattern, it should also be moved to wherever it is
referenced in the pattern guard code. Doing so however would prevent the name
from being available in the body of the match arm. Consider the following:
```compile_fail,E0008
match Some("hi".to_string()) {
    Some(s) if s.len() == 0 => {}, // use s.
    _ => {},
The variable `s` has type `String`, and its use in the guard is as a variable of
type `String`. The guard code effectively executes in a separate scope to the
body of the arm, so the value would be moved into this anonymous scope and
therefore becomes unavailable in the body of the arm.
The problem above can be solved by using the `ref` keyword.
match Some("hi".to_string()) {
    Some(ref s) if s.len() == 0 => {},
    _ => {},
Though this example seems innocuous and easy to solve, the problem becomes clear
when it encounters functions which consume the value:
```compile_fail,E0008
struct A{}
impl A {
    fn consume(self) -> usize {
        0
    }
fn main() {
    let a = Some(A{});
    match a {
        Some(y) if y.consume() > 0 => {}
        _ => {}
    }
In this situation, even the `ref` keyword cannot solve it, since borrowed
content cannot be moved. This problem cannot be solved generally. If the value
can be cloned, here is a not-so-specific solution:
#[derive(Clone)]
struct A{}
impl A {
    fn consume(self) -> usize {
        0
    }
fn main() {
    let a = Some(A{});
    match a{
        Some(ref y) if y.clone().consume() > 0 => {}
        _ => {}
    }
If the value will be consumed in the pattern guard, using its clone will not
move its ownership, so the code works.
E0009
In a pattern, all values that don't implement the `Copy` trait have to be bound
the same way. The goal here is to avoid binding simultaneously by-move and
by-ref.
This limitation may be removed in a future version of Rust.
Erroneous code example:
```compile_fail,E0009
struct X { x: (), }
let x = Some((X { x: () }, X { x: () }));
match x {
    Some((y, ref z)) => {}, // error: cannot bind by-move and by-ref in the
                            //        same pattern
    None => panic!()
You have two solutions:
Solution #1: Bind the pattern's values the same way.
struct X { x: (), }
let x = Some((X { x: () }, X { x: () }));
match x {
    Some((ref y, ref z)) => {},
    // or Some((y, z)) => {}
    None => panic!()
Solution #2: Implement the `Copy` trait for the `X` structure.
However, please keep in mind that the first solution should be preferred.
#[derive(Clone, Copy)]
struct X { x: (), }
let x = Some((X { x: () }, X { x: () }));
match x {
    Some((y, ref z)) => {},
    None => panic!()
E0158
`const` and `static` mean different things. A `const` is a compile-time
constant, an alias for a literal value. This property means you can match it
directly within a pattern.
The `static` keyword, on the other hand, guarantees a fixed location in memory.
This does not always mean that the value is constant. For example, a global
mutex can be declared `static` as well.
If you want to match against a `static`, consider using a guard instead:
static FORTY_TWO: i32 = 42;
match Some(42) {
    Some(x) if x == FORTY_TWO => {}
    _ => {}
E0162
An if-let pattern attempts to match the pattern, and enters the body if the
match was successful. If the match is irrefutable (when it cannot fail to
match), use a regular `let`-binding instead. For instance:
```compile_fail,E0162
struct Irrefutable(i32);
let irr = Irrefutable(0);
// This fails to compile because the match is irrefutable.
if let Irrefutable(x) = irr {
    // This body will always be executed.
    // ...
Try this instead:
struct Irrefutable(i32);
let irr = Irrefutable(0);
let Irrefutable(x) = irr;
println!("{}", x);
E0165
A while-let pattern attempts to match the pattern, and enters the body if the
match was successful. If the match is irrefutable (when it cannot fail to
match), use a regular `let`-binding inside a `loop` instead. For instance:
```compile_fail,E0165
struct Irrefutable(i32);
let irr = Irrefutable(0);
// This fails to compile because the match is irrefutable.
while let Irrefutable(x) = irr {
    // ...
Try this instead:
```no_run
struct Irrefutable(i32);
let irr = Irrefutable(0);
loop {
    let Irrefutable(x) = irr;
    // ...
E0170
Enum variants are qualified by default. For example, given this type:
enum Method {
    GET,
    POST,
You would match it using:
enum Method {
    GET,
    POST,
let m = Method::GET;
match m {
    Method::GET => {},
    Method::POST => {},
If you don't qualify the names, the code will bind new variables named "GET" and
"POST" instead. This behavior is likely not what you want, so `rustc` warns when
that happens.
Qualified names are good practice, and most code works well with them. But if
you prefer them unqualified, you can import the variants into scope:
use Method::*;
enum Method { GET, POST }
# fn main() {}
If you want others to be able to import variants from your module directly, use
`pub use`:
pub use Method::*;
pub enum Method { GET, POST }
# fn main() {}
E0297
#### Note: this error code is no longer emitted by the compiler.
Patterns used to bind names must be irrefutable. That is, they must guarantee
that a name will be extracted in all cases. Instead of pattern matching the
loop variable, consider using a `match` or `if let` inside the loop body. For
instance:
```compile_fail,E0005
let xs : Vec<Option<i32>> = vec![Some(1), None];
// This fails because `None` is not covered.
for Some(x) in xs {
    // ...
Match inside the loop instead:
let xs : Vec<Option<i32>> = vec![Some(1), None];
for item in xs {
    match item {
        Some(x) => {},
        None => {},
    }
Or use `if let`:
let xs : Vec<Option<i32>> = vec![Some(1), None];
for item in xs {
    if let Some(x) = item {
        // ...
    }
E0301
Mutable borrows are not allowed in pattern guards, because matching cannot have
side effects. Side effects could alter the matched object or the environment
on which the match depends in such a way, that the match would not be
exhaustive. For instance, the following would not match any arm if mutable
borrows were allowed:
```compile_fail,E0301
match Some(()) {
    None => { },
    option if option.take().is_none() => {
        /* impossible, option is `Some` */
    },
    Some(_) => { } // When the previous match failed, the option became `None`.
E0302
Assignments are not allowed in pattern guards, because matching cannot have
side effects. Side effects could alter the matched object or the environment
on which the match depends in such a way, that the match would not be
exhaustive. For instance, the following would not match any arm if assignments
were allowed:
```compile_fail,E0302
match Some(()) {
    None => { },
    option if { option = None; false } => { },
    Some(_) => { } // When the previous match failed, the option became `None`.
E0303
In certain cases it is possible for sub-bindings to violate memory safety.
Updates to the borrow checker in a future version of Rust may remove this
restriction, but for now patterns must be rewritten without sub-bindings.
Before:
```compile_fail,E0303
match Some("hi".to_string()) {
    ref op_string_ref @ Some(s) => {},
    None => {},
After:
match Some("hi".to_string()) {
    Some(ref s) => {
        let op_string_ref = &Some(s);
        // ...
    },
    None => {},
The `op_string_ref` binding has type `&Option<&String>` in both cases.
See also https://github.com/rust-lang/rust/issues/14587
E0454
A link name was given with an empty name. Erroneous code example:
```ignore (cannot-test-this-because-rustdoc-stops-compile-fail-before-trans)
#[link(name = "")] extern {} // error: #[link(name = "")] given with empty name
The rust compiler cannot link to an external library if you don't give it its
name. Example:
```no_run
#[link(name = "some_lib")] extern {} // ok!
E0455
Linking with `kind=framework` is only supported when targeting macOS,
as frameworks are specific to that operating system.
Erroneous code example:
```ignore (should-compile_fail-but-cannot-doctest-conditionally-without-macos)
#[link(name = "FooCoreServices", kind = "framework")] extern {}
// OS used to compile is Linux for example
To solve this error you can use conditional compilation:
#[cfg_attr(target="macos", link(name = "FooCoreServices", kind = "framework"))]
extern {}
See more:
https://doc.rust-lang.org/book/first-edition/conditional-compilation.html
E0458
An unknown "kind" was specified for a link attribute. Erroneous code example:
```ignore (cannot-test-this-because-rustdoc-stops-compile-fail-before-trans)
#[link(kind = "wonderful_unicorn")] extern {}
// error: unknown kind: `wonderful_unicorn`
Please specify a valid "kind" value, from one of the following:
* static
* dylib
* framework
E0459
A link was used without a name parameter. Erroneous code example:
```ignore (cannot-test-this-because-rustdoc-stops-compile-fail-before-trans)
#[link(kind = "dylib")] extern {}
// error: #[link(...)] specified without `name = "foo"`
Please add the name parameter to allow the rust compiler to find the library
you want. Example:
```no_run
#[link(kind = "dylib", name = "some_lib")] extern {} // ok!
E0463
A plugin/crate was declared but cannot be found. Erroneous code example:
```compile_fail,E0463
#![feature(plugin)]
#![plugin(cookie_monster)] // error: can't find crate for `cookie_monster`
extern crate cake_is_a_lie; // error: can't find crate for `cake_is_a_lie`
You need to link your code to the relevant crate in order to be able to use it
(through Cargo or the `-L` option of rustc example). Plugins are crates as
well, and you link to them the same way.
E0030
When matching against a range, the compiler verifies that the range is
non-empty.  Range patterns include both end-points, so this is equivalent to
requiring the start of the range to be less than or equal to the end of the
range.
For example:
```compile_fail
match 5u32 {
    // This range is ok, albeit pointless.
    1 ... 1 => {}
    // This range is empty, and the compiler can tell.
    1000 ... 5 => {}
E0130
You declared a pattern as an argument in a foreign function declaration.
Erroneous code example:
```compile_fail
extern {
    fn foo((a, b): (u32, u32)); // error: patterns aren't allowed in foreign
                                //        function declarations
Please replace the pattern argument with a regular one. Example:
struct SomeStruct {
    a: u32,
    b: u32,
extern {
    fn foo(s: SomeStruct); // ok!
extern {
    fn foo(a: (u32, u32)); // ok!
E0197
Inherent implementations (one that do not implement a trait but provide
methods associated with a type) are always safe because they are not
implementing an unsafe trait. Removing the `unsafe` keyword from the inherent
implementation will resolve this error.
```compile_fail,E0197
struct Foo;
// this will cause this error
unsafe impl Foo { }
// converting it to this will fix it
impl Foo { }
E0198
A negative implementation is one that excludes a type from implementing a
particular trait. Not being able to use a trait is always a safe operation,
so negative implementations are always safe and never need to be marked as
unsafe.
```compile_fail
#![feature(optin_builtin_traits)]
struct Foo;
// unsafe is unnecessary
unsafe impl !Clone for Foo { }
This will compile:
```ignore (ignore auto_trait future compatibility warning)
#![feature(optin_builtin_traits)]
struct Foo;
auto trait Enterprise {}
impl !Enterprise for Foo { }
Please note that negative impls are only allowed for auto traits.
E0265
This error indicates that a static or constant references itself.
All statics and constants need to resolve to a value in an acyclic manner.
For example, neither of the following can be sensibly compiled:
```compile_fail,E0265
const X: u32 = X;
```compile_fail,E0265
const X: u32 = Y;
const Y: u32 = X;
E0267
This error indicates the use of a loop keyword (`break` or `continue`) inside a
closure but outside of any loop. Erroneous code example:
```compile_fail,E0267
let w = || { break; }; // error: `break` inside of a closure
`break` and `continue` keywords can be used as normal inside closures as long as
they are also contained within a loop. To halt the execution of a closure you
should instead use a return statement. Example:
let w = || {
    for _ in 0..10 {
        break;
    }
w();
E0268
This error indicates the use of a loop keyword (`break` or `continue`) outside
of a loop. Without a loop to break out of or continue in, no sensible action can
be taken. Erroneous code example:
```compile_fail,E0268
fn some_func() {
    break; // error: `break` outside of loop
Please verify that you are using `break` and `continue` only in loops. Example:
fn some_func() {
    for _ in 0..10 {
        break; // ok!
    }
E0379
Trait methods cannot be declared `const` by design. For more information, see
[RFC 911].
[RFC 911]: https://github.com/rust-lang/rfcs/pull/911
E0380
Auto traits cannot have methods or associated items.
For more information see the [opt-in builtin traits RFC][RFC 19].
[RFC 19]: https://github.com/rust-lang/rfcs/blob/master/text/0019-opt-in-builtin-traits.md
E0449
A visibility qualifier was used when it was unnecessary. Erroneous code
examples:
```compile_fail,E0449
struct Bar;
trait Foo {
    fn foo();
pub impl Bar {} // error: unnecessary visibility qualifier
pub impl Foo for Bar { // error: unnecessary visibility qualifier
    pub fn foo() {} // error: unnecessary visibility qualifier
To fix this error, please remove the visibility qualifier when it is not
required. Example:
struct Bar;
trait Foo {
    fn foo();
// Directly implemented methods share the visibility of the type itself,
// so `pub` is unnecessary here
impl Bar {}
// Trait methods share the visibility of the trait, so `pub` is
// unnecessary in either case
impl Foo for Bar {
    fn foo() {}
E0579
When matching against an exclusive range, the compiler verifies that the range
is non-empty. Exclusive range patterns include the start point but not the end
point, so this is equivalent to requiring the start of the range to be less
than the end of the range.
For example:
```compile_fail
match 5u32 {
    // This range is ok, albeit pointless.
    1 .. 2 => {}
    // This range is empty, and the compiler can tell.
    5 .. 5 => {}
E0590
`break` or `continue` must include a label when used in the condition of a
`while` loop.
Example of erroneous code:
```compile_fail
while break {}
To fix this, add a label specifying which loop is being broken out of:
'foo: while break 'foo {}
E0571
A `break` statement with an argument appeared in a non-`loop` loop.
Example of erroneous code:
```compile_fail,E0571
# let mut i = 1;
# fn satisfied(n: usize) -> bool { n % 23 == 0 }
let result = while true {
    if satisfied(i) {
        break 2*i; // error: `break` with value from a `while` loop
    }
    i += 1;
The `break` statement can take an argument (which will be the value of the loop
expression if the `break` statement is executed) in `loop` loops, but not
`for`, `while`, or `while let` loops.
Make sure `break value;` statements only occur in `loop` loops:
# let mut i = 1;
# fn satisfied(n: usize) -> bool { n % 23 == 0 }
let result = loop { // ok!
    if satisfied(i) {
        break 2*i;
    }
    i += 1;
E0010
The value of statics and constants must be known at compile time, and they live
for the entire lifetime of a program. Creating a boxed value allocates memory on
the heap at runtime, and therefore cannot be done at compile time. Erroneous
code example:
```compile_fail,E0010
#![feature(box_syntax)]
const CON : Box<i32> = box 0;
E0013
Static and const variables can refer to other const variables. But a const
variable cannot refer to a static variable. For example, `Y` cannot refer to
`X` here:
```compile_fail,E0013
static X: i32 = 42;
const Y: i32 = X;
To fix this, the value can be extracted as a const and then used:
const A: i32 = 42;
static X: i32 = A;
const Y: i32 = A;
E0015
The only functions that can be called in static or constant expressions are
`const` functions, and struct/enum constructors. `const` functions are only
available on a nightly compiler. Rust currently does not support more general
compile-time function execution.
const FOO: Option<u8> = Some(1); // enum constructor
struct Bar {x: u8}
const BAR: Bar = Bar {x: 1}; // struct constructor
See [RFC 911] for more details on the design of `const fn`s.
[RFC 911]: https://github.com/rust-lang/rfcs/blob/master/text/0911-const-fn.md
E0016
Blocks in constants may only contain items (such as constant, function
definition, etc...) and a tail expression. Erroneous code example:
```compile_fail,E0016
const FOO: i32 = { let x = 0; x }; // 'x' isn't an item!
To avoid it, you have to replace the non-item object:
const FOO: i32 = { const X : i32 = 0; X };
E0017
References in statics and constants may only refer to immutable values.
Erroneous code example:
```compile_fail,E0017
static X: i32 = 1;
const C: i32 = 2;
// these three are not allowed:
const CR: &'static mut i32 = &mut C;
static STATIC_REF: &'static mut i32 = &mut X;
static CONST_REF: &'static mut i32 = &mut C;
Statics are shared everywhere, and if they refer to mutable data one might
violate memory safety since holding multiple mutable references to shared data
is not allowed.
If you really want global mutable state, try using `static mut` or a global
`UnsafeCell`.
E0018
The value of static and constant integers must be known at compile time. You
can't cast a pointer to an integer because the address of a pointer can
vary.
For example, if you write:
```compile_fail,E0018
static MY_STATIC: u32 = 42;
static MY_STATIC_ADDR: usize = &MY_STATIC as *const _ as usize;
static WHAT: usize = (MY_STATIC_ADDR^17) + MY_STATIC_ADDR;
Then `MY_STATIC_ADDR` would contain the address of `MY_STATIC`. However,
the address can change when the program is linked, as well as change
between different executions due to ASLR, and many linkers would
not be able to calculate the value of `WHAT`.
On the other hand, static and constant pointers can point either to
a known numeric address or to the address of a symbol.
static MY_STATIC: u32 = 42;
static MY_STATIC_ADDR: &'static u32 = &MY_STATIC;
const CONST_ADDR: *const u8 = 0x5f3759df as *const u8;
This does not pose a problem by itself because they can't be
accessed directly.
E0019
A function call isn't allowed in the const's initialization expression
because the expression's value must be known at compile-time. Erroneous code
example:
```compile_fail
enum Test {
    V1
impl Test {
    fn test(&self) -> i32 {
        12
    }
fn main() {
    const FOO: Test = Test::V1;
    const A: i32 = FOO.test(); // You can't call Test::func() here!
Remember: you can't use a function call inside a const's initialization
expression! However, you can totally use it anywhere else:
enum Test {
    V1
impl Test {
    fn func(&self) -> i32 {
        12
    }
fn main() {
    const FOO: Test = Test::V1;
    FOO.func(); // here is good
    let x = FOO.func(); // or even here!
E0022
Constant functions are not allowed to mutate anything. Thus, binding to an
argument with a mutable pattern is not allowed. For example,
```compile_fail
const fn foo(mut x: u8) {
    // do stuff
Is incorrect because the function body may not mutate `x`.
Remove any mutable bindings from the argument list to fix this error. In case
you need to mutate the argument, try lazily initializing a global variable
instead of using a `const fn`, or refactoring the code to a functional style to
avoid mutation if possible.
E0133
Unsafe code was used outside of an unsafe function or block.
Erroneous code example:
```compile_fail,E0133
unsafe fn f() { return; } // This is the unsafe code
fn main() {
    f(); // error: call to unsafe function requires unsafe function or block
Using unsafe functionality is potentially dangerous and disallowed by safety
checks. Examples:
* Dereferencing raw pointers
* Calling functions via FFI
* Calling functions marked unsafe
These safety checks can be relaxed for a section of the code by wrapping the
unsafe instructions with an `unsafe` block. For instance:
unsafe fn f() { return; }
fn main() {
    unsafe { f(); } // ok!
See also https://doc.rust-lang.org/book/first-edition/unsafe.html
E0373
This error occurs when an attempt is made to use data captured by a closure,
when that data may no longer exist. It's most commonly seen when attempting to
return a closure:
```compile_fail,E0373
fn foo() -> Box<Fn(u32) -> u32> {
    let x = 0u32;
    Box::new(|y| x + y)
Notice that `x` is stack-allocated by `foo()`. By default, Rust captures
closed-over data by reference. This means that once `foo()` returns, `x` no
longer exists. An attempt to access `x` within the closure would thus be
unsafe.
Another situation where this might be encountered is when spawning threads:
```compile_fail,E0373
fn foo() {
    let x = 0u32;
    let y = 1u32;
    let thr = std::thread::spawn(|| {
        x + y
    });
Since our new thread runs in parallel, the stack frame containing `x` and `y`
may well have disappeared by the time we try to use them. Even if we call
`thr.join()` within foo (which blocks until `thr` has completed, ensuring the
stack frame won't disappear), we will not succeed: the compiler cannot prove
that this behaviour is safe, and so won't let us do it.
The solution to this problem is usually to switch to using a `move` closure.
This approach moves (or copies, where possible) data into the closure, rather
than taking references to it. For example:
fn foo() -> Box<Fn(u32) -> u32> {
    let x = 0u32;
    Box::new(move |y| x + y)
Now that the closure has its own copy of the data, there's no need to worry
about safety.
E0381
It is not allowed to use or capture an uninitialized variable. For example:
```compile_fail,E0381
fn main() {
    let x: i32;
    let y = x; // error, use of possibly uninitialized variable
To fix this, ensure that any declared variables are initialized before being
used. Example:
fn main() {
    let x: i32 = 0;
    let y = x; // ok!
E0382
This error occurs when an attempt is made to use a variable after its contents
have been moved elsewhere. For example:
```compile_fail,E0382
struct MyStruct { s: u32 }
fn main() {
    let mut x = MyStruct{ s: 5u32 };
    let y = x;
    x.s = 6;
    println!("{}", x.s);
Since `MyStruct` is a type that is not marked `Copy`, the data gets moved out
of `x` when we set `y`. This is fundamental to Rust's ownership system: outside
of workarounds like `Rc`, a value cannot be owned by more than one variable.
Sometimes we don't need to move the value. Using a reference, we can let another
function borrow the value without changing its ownership. In the example below,
we don't actually have to move our string to `calculate_length`, we can give it
a reference to it with `&` instead.
fn main() {
    let s1 = String::from("hello");
    let len = calculate_length(&s1);
    println!("The length of '{}' is {}.", s1, len);
fn calculate_length(s: &String) -> usize {
    s.len()
A mutable reference can be created with `&mut`.
Sometimes we don't want a reference, but a duplicate. All types marked `Clone`
can be duplicated by calling `.clone()`. Subsequent changes to a clone do not
affect the original variable.
Most types in the standard library are marked `Clone`. The example below
demonstrates using `clone()` on a string. `s1` is first set to "many", and then
copied to `s2`. Then the first character of `s1` is removed, without affecting
`s2`. "any many" is printed to the console.
fn main() {
    let mut s1 = String::from("many");
    let s2 = s1.clone();
    s1.remove(0);
    println!("{} {}", s1, s2);
If we control the definition of a type, we can implement `Clone` on it ourselves
with `#[derive(Clone)]`.
Some types have no ownership semantics at all and are trivial to duplicate. An
example is `i32` and the other number types. We don't have to call `.clone()` to
clone them, because they are marked `Copy` in addition to `Clone`.  Implicit
cloning is more convienient in this case. We can mark our own types `Copy` if
all their members also are marked `Copy`.
In the example below, we implement a `Point` type. Because it only stores two
integers, we opt-out of ownership semantics with `Copy`. Then we can
`let p2 = p1` without `p1` being moved.
#[derive(Copy, Clone)]
struct Point { x: i32, y: i32 }
fn main() {
    let mut p1 = Point{ x: -1, y: 2 };
    let p2 = p1;
    p1.x = 1;
    println!("p1: {}, {}", p1.x, p1.y);
    println!("p2: {}, {}", p2.x, p2.y);
Alternatively, if we don't control the struct's definition, or mutable shared
ownership is truly required, we can use `Rc` and `RefCell`:
use std::cell::RefCell;
use std::rc::Rc;
struct MyStruct { s: u32 }
fn main() {
    let mut x = Rc::new(RefCell::new(MyStruct{ s: 5u32 }));
    let y = x.clone();
    x.borrow_mut().s = 6;
    println!("{}", x.borrow().s);
With this approach, x and y share ownership of the data via the `Rc` (reference
count type). `RefCell` essentially performs runtime borrow checking: ensuring
that at most one writer or multiple readers can access the data at any one time.
If you wish to learn more about ownership in Rust, start with the chapter in the
Book:
https://doc.rust-lang.org/book/first-edition/ownership.html
E0383
This error occurs when an attempt is made to partially reinitialize a
structure that is currently uninitialized.
For example, this can happen when a drop has taken place:
```compile_fail,E0383
struct Foo {
    a: u32,
impl Drop for Foo {
    fn drop(&mut self) { /* ... */ }
let mut x = Foo { a: 1 };
drop(x); // `x` is now uninitialized
x.a = 2; // error, partial reinitialization of uninitialized structure `t`
This error can be fixed by fully reinitializing the structure in question:
struct Foo {
    a: u32,
impl Drop for Foo {
    fn drop(&mut self) { /* ... */ }
let mut x = Foo { a: 1 };
drop(x);
x = Foo { a: 2 };
E0384
This error occurs when an attempt is made to reassign an immutable variable.
For example:
```compile_fail,E0384
fn main() {
    let x = 3;
    x = 5; // error, reassignment of immutable variable
By default, variables in Rust are immutable. To fix this error, add the keyword
`mut` after the keyword `let` when declaring the variable. For example:
fn main() {
    let mut x = 3;
    x = 5;
E0387
This error occurs when an attempt is made to mutate or mutably reference data
that a closure has captured immutably. Examples of this error are shown below:
```compile_fail,E0387
// Accepts a function or a closure that captures its environment immutably.
// Closures passed to foo will not be able to mutate their closed-over state.
fn foo<F: Fn()>(f: F) { }
// Attempts to mutate closed-over data. Error message reads:
// `cannot assign to data in a captured outer variable...`
fn mutable() {
    let mut x = 0u32;
    foo(|| x = 2);
// Attempts to take a mutable reference to closed-over data.  Error message
// reads: `cannot borrow data mutably in a captured outer variable...`
fn mut_addr() {
    let mut x = 0u32;
    foo(|| { let y = &mut x; });
The problem here is that foo is defined as accepting a parameter of type `Fn`.
Closures passed into foo will thus be inferred to be of type `Fn`, meaning that
they capture their context immutably.
If the definition of `foo` is under your control, the simplest solution is to
capture the data mutably. This can be done by defining `foo` to take FnMut
rather than Fn:
fn foo<F: FnMut()>(f: F) { }
Alternatively, we can consider using the `Cell` and `RefCell` types to achieve
interior mutability through a shared reference. Our example's `mutable`
function could be redefined as below:
use std::cell::Cell;
fn foo<F: Fn()>(f: F) { }
fn mutable() {
    let x = Cell::new(0u32);
    foo(|| x.set(2));
You can read more about cell types in the API documentation:
https://doc.rust-lang.org/std/cell/
E0388
E0388 was removed and is no longer issued.
E0389
An attempt was made to mutate data using a non-mutable reference. This
commonly occurs when attempting to assign to a non-mutable reference of a
mutable reference (`&(&mut T)`).
Example of erroneous code:
```compile_fail,E0389
struct FancyNum {
    num: u8,
fn main() {
    let mut fancy = FancyNum{ num: 5 };
    let fancy_ref = &(&mut fancy);
    fancy_ref.num = 6; // error: cannot assign to data in a `&` reference
    println!("{}", fancy_ref.num);
Here, `&mut fancy` is mutable, but `&(&mut fancy)` is not. Creating an
immutable reference to a value borrows it immutably. There can be multiple
references of type `&(&mut T)` that point to the same value, so they must be
immutable to prevent multiple mutable references to the same value.
To fix this, either remove the outer reference:
struct FancyNum {
    num: u8,
fn main() {
    let mut fancy = FancyNum{ num: 5 };
    let fancy_ref = &mut fancy;
    // `fancy_ref` is now &mut FancyNum, rather than &(&mut FancyNum)
    fancy_ref.num = 6; // No error!
    println!("{}", fancy_ref.num);
Or make the outer reference mutable:
struct FancyNum {
    num: u8
fn main() {
    let mut fancy = FancyNum{ num: 5 };
    let fancy_ref = &mut (&mut fancy);
    // `fancy_ref` is now &mut(&mut FancyNum), rather than &(&mut FancyNum)
    fancy_ref.num = 6; // No error!
    println!("{}", fancy_ref.num);
E0394
A static was referred to by value by another static.
Erroneous code examples:
```compile_fail,E0394
static A: u32 = 0;
static B: u32 = A; // error: cannot refer to other statics by value, use the
                   //        address-of operator or a constant instead
A static cannot be referred by value. To fix this issue, either use a
constant:
const A: u32 = 0; // `A` is now a constant
static B: u32 = A; // ok!
Or refer to `A` by reference:
static A: u32 = 0;
static B: &'static u32 = &A; // ok!
E0395
The value assigned to a constant scalar must be known at compile time,
which is not the case when comparing raw pointers.
Erroneous code example:
```compile_fail,E0395
static FOO: i32 = 42;
static BAR: i32 = 42;
static BAZ: bool = { (&FOO as *const i32) == (&BAR as *const i32) };
// error: raw pointers cannot be compared in statics!
The address assigned by the linker to `FOO` and `BAR` may or may not
be identical, so the value of `BAZ` can't be determined.
If you want to do the comparison, please do it at run-time.
For example:
static FOO: i32 = 42;
static BAR: i32 = 42;
let baz: bool = { (&FOO as *const i32) == (&BAR as *const i32) };
// baz isn't a constant expression so it's ok
E0161
A value was moved. However, its size was not known at compile time, and only
values of a known size can be moved.
Erroneous code example:
```compile_fail
#![feature(box_syntax)]
fn main() {
    let array: &[isize] = &[1, 2, 3];
    let _x: Box<[isize]> = box *array;
    // error: cannot move a value of type [isize]: the size of [isize] cannot
    //        be statically determined
In Rust, you can only move a value when its size is known at compile time.
To work around this restriction, consider "hiding" the value behind a reference:
either `&x` or `&mut x`. Since a reference has a fixed size, this lets you move
it around as usual. Example:
#![feature(box_syntax)]
fn main() {
    let array: &[isize] = &[1, 2, 3];
    let _x: Box<&[isize]> = box array; // ok!
E0396
The value behind a raw pointer can't be determined at compile-time
(or even link-time), which means it can't be used in a constant
expression. Erroneous code example:
```compile_fail,E0396
const REG_ADDR: *const u8 = 0x5f3759df as *const u8;
const VALUE: u8 = unsafe { *REG_ADDR };
// error: raw pointers cannot be dereferenced in constants
A possible fix is to dereference your pointer at some point in run-time.
For example:
const REG_ADDR: *const u8 = 0x5f3759df as *const u8;
let reg_value = unsafe { *REG_ADDR };
E0492
A borrow of a constant containing interior mutability was attempted. Erroneous
code example:
```compile_fail,E0492
use std::sync::atomic::{AtomicUsize, ATOMIC_USIZE_INIT};
const A: AtomicUsize = ATOMIC_USIZE_INIT;
static B: &'static AtomicUsize = &A;
// error: cannot borrow a constant which may contain interior mutability,
//        create a static instead
A `const` represents a constant value that should never change. If one takes
a `&` reference to the constant, then one is taking a pointer to some memory
location containing the value. Normally this is perfectly fine: most values
can't be changed via a shared `&` pointer, but interior mutability would allow
it. That is, a constant value could be mutated. On the other hand, a `static` is
explicitly a single memory location, which can be mutated at will.
So, in order to solve this error, either use statics which are `Sync`:
use std::sync::atomic::{AtomicUsize, ATOMIC_USIZE_INIT};
static A: AtomicUsize = ATOMIC_USIZE_INIT;
static B: &'static AtomicUsize = &A; // ok!
You can also have this error while using a cell type:
```compile_fail,E0492
use std::cell::Cell;
const A: Cell<usize> = Cell::new(1);
const B: &'static Cell<usize> = &A;
// error: cannot borrow a constant which may contain interior mutability,
//        create a static instead
// or:
struct C { a: Cell<usize> }
const D: C = C { a: Cell::new(1) };
const E: &'static Cell<usize> = &D.a; // error
// or:
const F: &'static C = &D; // error
This is because cell types do operations that are not thread-safe. Due to this,
they don't implement Sync and thus can't be placed in statics. In this
case, `StaticMutex` would work just fine, but it isn't stable yet:
https://doc.rust-lang.org/nightly/std/sync/struct.StaticMutex.html
However, if you still wish to use these types, you can achieve this by an unsafe
wrapper:
use std::cell::Cell;
use std::marker::Sync;
struct NotThreadSafe<T> {
    value: Cell<T>,
unsafe impl<T> Sync for NotThreadSafe<T> {}
static A: NotThreadSafe<usize> = NotThreadSafe { value : Cell::new(1) };
static B: &'static NotThreadSafe<usize> = &A; // ok!
Remember this solution is unsafe! You will have to ensure that accesses to the
cell are synchronized.
E0494
A reference of an interior static was assigned to another const/static.
Erroneous code example:
```compile_fail,E0494
struct Foo {
    a: u32
static S : Foo = Foo { a : 0 };
static A : &'static u32 = &S.a;
// error: cannot refer to the interior of another static, use a
//        constant instead
The "base" variable has to be a const if you want another static/const variable
to refer to one of its fields. Example:
struct Foo {
    a: u32
const S : Foo = Foo { a : 0 };
static A : &'static u32 = &S.a; // ok!
E0499
A variable was borrowed as mutable more than once. Erroneous code example:
```compile_fail,E0499
let mut i = 0;
let mut x = &mut i;
let mut a = &mut i;
// error: cannot borrow `i` as mutable more than once at a time
Please note that in rust, you can either have many immutable references, or one
mutable reference. Take a look at
https://doc.rust-lang.org/stable/book/references-and-borrowing.html for more
information. Example:
let mut i = 0;
let mut x = &mut i; // ok!
// or:
let mut i = 0;
let a = &i; // ok!
let b = &i; // still ok!
let c = &i; // still ok!
E0500
A borrowed variable was used in another closure. Example of erroneous code:
```compile_fail
fn you_know_nothing(jon_snow: &mut i32) {
    let nights_watch = || {
        *jon_snow = 2;
    };
    let starks = || {
        *jon_snow = 3; // error: closure requires unique access to `jon_snow`
                       //        but it is already borrowed
    };
In here, `jon_snow` is already borrowed by the `nights_watch` closure, so it
cannot be borrowed by the `starks` closure at the same time. To fix this issue,
you can put the closure in its own scope:
fn you_know_nothing(jon_snow: &mut i32) {
    {
        let nights_watch = || {
            *jon_snow = 2;
        };
    } // At this point, `jon_snow` is free.
    let starks = || {
        *jon_snow = 3;
    };
Or, if the type implements the `Clone` trait, you can clone it between
closures:
fn you_know_nothing(jon_snow: &mut i32) {
    let mut jon_copy = jon_snow.clone();
    let nights_watch = || {
        jon_copy = 2;
    };
    let starks = || {
        *jon_snow = 3;
    };
E0501
This error indicates that a mutable variable is being used while it is still
captured by a closure. Because the closure has borrowed the variable, it is not
available for use until the closure goes out of scope.
Note that a capture will either move or borrow a variable, but in this
situation, the closure is borrowing the variable. Take a look at
http://rustbyexample.com/fn/closures/capture.html for more information about
capturing.
Example of erroneous code:
```compile_fail,E0501
fn inside_closure(x: &mut i32) {
    // Actions which require unique access
fn outside_closure(x: &mut i32) {
    // Actions which require unique access
fn foo(a: &mut i32) {
    let bar = || {
        inside_closure(a)
    };
    outside_closure(a); // error: cannot borrow `*a` as mutable because previous
                        //        closure requires unique access.
To fix this error, you can place the closure in its own scope:
fn inside_closure(x: &mut i32) {}
fn outside_closure(x: &mut i32) {}
fn foo(a: &mut i32) {
    {
        let bar = || {
            inside_closure(a)
        };
    } // borrow on `a` ends.
    outside_closure(a); // ok!
Or you can pass the variable as a parameter to the closure:
fn inside_closure(x: &mut i32) {}
fn outside_closure(x: &mut i32) {}
fn foo(a: &mut i32) {
    let bar = |s: &mut i32| {
        inside_closure(s)
    };
    outside_closure(a);
    bar(a);
It may be possible to define the closure later:
fn inside_closure(x: &mut i32) {}
fn outside_closure(x: &mut i32) {}
fn foo(a: &mut i32) {
    outside_closure(a);
    let bar = || {
        inside_closure(a)
    };
E0502
This error indicates that you are trying to borrow a variable as mutable when it
has already been borrowed as immutable.
Example of erroneous code:
```compile_fail,E0502
fn bar(x: &mut i32) {}
fn foo(a: &mut i32) {
    let ref y = a; // a is borrowed as immutable.
    bar(a); // error: cannot borrow `*a` as mutable because `a` is also borrowed
            //        as immutable
To fix this error, ensure that you don't have any other references to the
variable before trying to access it mutably:
fn bar(x: &mut i32) {}
fn foo(a: &mut i32) {
    bar(a);
    let ref y = a; // ok!
For more information on the rust ownership system, take a look at
https://doc.rust-lang.org/stable/book/references-and-borrowing.html.
E0503
A value was used after it was mutably borrowed.
Example of erroneous code:
```compile_fail,E0503
fn main() {
    let mut value = 3;
    // Create a mutable borrow of `value`. This borrow
    // lives until the end of this function.
    let _borrow = &mut value;
    let _sum = value + 1; // error: cannot use `value` because
                          //        it was mutably borrowed
In this example, `value` is mutably borrowed by `borrow` and cannot be
used to calculate `sum`. This is not possible because this would violate
Rust's mutability rules.
You can fix this error by limiting the scope of the borrow:
fn main() {
    let mut value = 3;
    // By creating a new block, you can limit the scope
    // of the reference.
    {
        let _borrow = &mut value; // Use `_borrow` inside this block.
    }
    // The block has ended and with it the borrow.
    // You can now use `value` again.
    let _sum = value + 1;
Or by cloning `value` before borrowing it:
fn main() {
    let mut value = 3;
    // We clone `value`, creating a copy.
    let value_cloned = value.clone();
    // The mutable borrow is a reference to `value` and
    // not to `value_cloned`...
    let _borrow = &mut value;
    // ... which means we can still use `value_cloned`,
    let _sum = value_cloned + 1;
    // even though the borrow only ends here.
You can find more information about borrowing in the rust-book:
http://doc.rust-lang.org/stable/book/references-and-borrowing.html
E0504
This error occurs when an attempt is made to move a borrowed variable into a
closure.
Example of erroneous code:
```compile_fail,E0504
struct FancyNum {
    num: u8,
fn main() {
    let fancy_num = FancyNum { num: 5 };
    let fancy_ref = &fancy_num;
    let x = move || {
        println!("child function: {}", fancy_num.num);
        // error: cannot move `fancy_num` into closure because it is borrowed
    };
    x();
    println!("main function: {}", fancy_ref.num);
Here, `fancy_num` is borrowed by `fancy_ref` and so cannot be moved into
the closure `x`. There is no way to move a value into a closure while it is
borrowed, as that would invalidate the borrow.
If the closure can't outlive the value being moved, try using a reference
rather than moving:
struct FancyNum {
    num: u8,
fn main() {
    let fancy_num = FancyNum { num: 5 };
    let fancy_ref = &fancy_num;
    let x = move || {
        // fancy_ref is usable here because it doesn't move `fancy_num`
        println!("child function: {}", fancy_ref.num);
    };
    x();
    println!("main function: {}", fancy_num.num);
If the value has to be borrowed and then moved, try limiting the lifetime of
the borrow using a scoped block:
struct FancyNum {
    num: u8,
fn main() {
    let fancy_num = FancyNum { num: 5 };
    {
        let fancy_ref = &fancy_num;
        println!("main function: {}", fancy_ref.num);
        // `fancy_ref` goes out of scope here
    }
    let x = move || {
        // `fancy_num` can be moved now (no more references exist)
        println!("child function: {}", fancy_num.num);
    };
    x();
If the lifetime of a reference isn't enough, such as in the case of threading,
consider using an `Arc` to create a reference-counted value:
use std::sync::Arc;
use std::thread;
struct FancyNum {
    num: u8,
fn main() {
    let fancy_ref1 = Arc::new(FancyNum { num: 5 });
    let fancy_ref2 = fancy_ref1.clone();
    let x = thread::spawn(move || {
        // `fancy_ref1` can be moved and has a `'static` lifetime
        println!("child thread: {}", fancy_ref1.num);
    });
    x.join().expect("child thread should finish");
    println!("main thread: {}", fancy_ref2.num);
E0505
A value was moved out while it was still borrowed.
Erroneous code example:
```compile_fail,E0505
struct Value {}
fn eat(val: Value) {}
fn main() {
    let x = Value{};
    {
        let _ref_to_val: &Value = &x;
        eat(x);
    }
Here, the function `eat` takes the ownership of `x`. However,
`x` cannot be moved because it was borrowed to `_ref_to_val`.
To fix that you can do few different things:
* Try to avoid moving the variable.
* Release borrow before move.
* Implement the `Copy` trait on the type.
Examples:
struct Value {}
fn eat(val: &Value) {}
fn main() {
    let x = Value{};
    {
        let _ref_to_val: &Value = &x;
        eat(&x); // pass by reference, if it's possible
    }
struct Value {}
fn eat(val: Value) {}
fn main() {
    let x = Value{};
    {
        let _ref_to_val: &Value = &x;
    }
    eat(x); // release borrow and then move it.
#[derive(Clone, Copy)] // implement Copy trait
struct Value {}
fn eat(val: Value) {}
fn main() {
    let x = Value{};
    {
        let _ref_to_val: &Value = &x;
        eat(x); // it will be copied here.
    }
You can find more information about borrowing in the rust-book:
http://doc.rust-lang.org/stable/book/references-and-borrowing.html
E0506
This error occurs when an attempt is made to assign to a borrowed value.
Example of erroneous code:
```compile_fail,E0506
struct FancyNum {
    num: u8,
fn main() {
    let mut fancy_num = FancyNum { num: 5 };
    let fancy_ref = &fancy_num;
    fancy_num = FancyNum { num: 6 };
    // error: cannot assign to `fancy_num` because it is borrowed
    println!("Num: {}, Ref: {}", fancy_num.num, fancy_ref.num);
Because `fancy_ref` still holds a reference to `fancy_num`, `fancy_num` can't
be assigned to a new value as it would invalidate the reference.
Alternatively, we can move out of `fancy_num` into a second `fancy_num`:
struct FancyNum {
    num: u8,
fn main() {
    let mut fancy_num = FancyNum { num: 5 };
    let moved_num = fancy_num;
    fancy_num = FancyNum { num: 6 };
    println!("Num: {}, Moved num: {}", fancy_num.num, moved_num.num);
If the value has to be borrowed, try limiting the lifetime of the borrow using
a scoped block:
struct FancyNum {
    num: u8,
fn main() {
    let mut fancy_num = FancyNum { num: 5 };
    {
        let fancy_ref = &fancy_num;
        println!("Ref: {}", fancy_ref.num);
    }
    // Works because `fancy_ref` is no longer in scope
    fancy_num = FancyNum { num: 6 };
    println!("Num: {}", fancy_num.num);
Or by moving the reference into a function:
struct FancyNum {
    num: u8,
fn main() {
    let mut fancy_num = FancyNum { num: 5 };
    print_fancy_ref(&fancy_num);
    // Works because function borrow has ended
    fancy_num = FancyNum { num: 6 };
    println!("Num: {}", fancy_num.num);
fn print_fancy_ref(fancy_ref: &FancyNum){
    println!("Ref: {}", fancy_ref.num);
E0507
You tried to move out of a value which was borrowed. Erroneous code example:
```compile_fail,E0507
use std::cell::RefCell;
struct TheDarkKnight;
impl TheDarkKnight {
    fn nothing_is_true(self) {}
fn main() {
    let x = RefCell::new(TheDarkKnight);
    x.borrow().nothing_is_true(); // error: cannot move out of borrowed content
Here, the `nothing_is_true` method takes the ownership of `self`. However,
`self` cannot be moved because `.borrow()` only provides an `&TheDarkKnight`,
which is a borrow of the content owned by the `RefCell`. To fix this error,
you have three choices:
* Try to avoid moving the variable.
* Somehow reclaim the ownership.
* Implement the `Copy` trait on the type.
Examples:
use std::cell::RefCell;
struct TheDarkKnight;
impl TheDarkKnight {
    fn nothing_is_true(&self) {} // First case, we don't take ownership
fn main() {
    let x = RefCell::new(TheDarkKnight);
    x.borrow().nothing_is_true(); // ok!
use std::cell::RefCell;
struct TheDarkKnight;
impl TheDarkKnight {
    fn nothing_is_true(self) {}
fn main() {
    let x = RefCell::new(TheDarkKnight);
    let x = x.into_inner(); // we get back ownership
    x.nothing_is_true(); // ok!
use std::cell::RefCell;
#[derive(Clone, Copy)] // we implement the Copy trait
struct TheDarkKnight;
impl TheDarkKnight {
    fn nothing_is_true(self) {}
fn main() {
    let x = RefCell::new(TheDarkKnight);
    x.borrow().nothing_is_true(); // ok!
Moving a member out of a mutably borrowed struct will also cause E0507 error:
```compile_fail,E0507
struct TheDarkKnight;
impl TheDarkKnight {
    fn nothing_is_true(self) {}
struct Batcave {
    knight: TheDarkKnight
fn main() {
    let mut cave = Batcave {
        knight: TheDarkKnight
    };
    let borrowed = &mut cave;
    borrowed.knight.nothing_is_true(); // E0507
It is fine only if you put something back. `mem::replace` can be used for that:
# struct TheDarkKnight;
# impl TheDarkKnight { fn nothing_is_true(self) {} }
# struct Batcave { knight: TheDarkKnight }
use std::mem;
let mut cave = Batcave {
    knight: TheDarkKnight
let borrowed = &mut cave;
mem::replace(&mut borrowed.knight, TheDarkKnight).nothing_is_true(); // ok!
You can find more information about borrowing in the rust-book:
http://doc.rust-lang.org/book/first-edition/references-and-borrowing.html
E0508
A value was moved out of a non-copy fixed-size array.
Example of erroneous code:
```compile_fail,E0508
struct NonCopy;
fn main() {
    let array = [NonCopy; 1];
    let _value = array[0]; // error: cannot move out of type `[NonCopy; 1]`,
                           //        a non-copy fixed-size array
The first element was moved out of the array, but this is not
possible because `NonCopy` does not implement the `Copy` trait.
Consider borrowing the element instead of moving it:
struct NonCopy;
fn main() {
    let array = [NonCopy; 1];
    let _value = &array[0]; // Borrowing is allowed, unlike moving.
Alternatively, if your type implements `Clone` and you need to own the value,
consider borrowing and then cloning:
#[derive(Clone)]
struct NonCopy;
fn main() {
    let array = [NonCopy; 1];
    // Now you can clone the array element.
    let _value = array[0].clone();
E0509
This error occurs when an attempt is made to move out of a value whose type
implements the `Drop` trait.
Example of erroneous code:
```compile_fail,E0509
struct FancyNum {
    num: usize
struct DropStruct {
    fancy: FancyNum
impl Drop for DropStruct {
    fn drop(&mut self) {
        // Destruct DropStruct, possibly using FancyNum
    }
fn main() {
    let drop_struct = DropStruct{fancy: FancyNum{num: 5}};
    let fancy_field = drop_struct.fancy; // Error E0509
    println!("Fancy: {}", fancy_field.num);
    // implicit call to `drop_struct.drop()` as drop_struct goes out of scope
Here, we tried to move a field out of a struct of type `DropStruct` which
implements the `Drop` trait. However, a struct cannot be dropped if one or
more of its fields have been moved.
Structs implementing the `Drop` trait have an implicit destructor that gets
called when they go out of scope. This destructor may use the fields of the
struct, so moving out of the struct could make it impossible to run the
destructor. Therefore, we must think of all values whose type implements the
`Drop` trait as single units whose fields cannot be moved.
This error can be fixed by creating a reference to the fields of a struct,
enum, or tuple using the `ref` keyword:
struct FancyNum {
    num: usize
struct DropStruct {
    fancy: FancyNum
impl Drop for DropStruct {
    fn drop(&mut self) {
        // Destruct DropStruct, possibly using FancyNum
    }
fn main() {
    let drop_struct = DropStruct{fancy: FancyNum{num: 5}};
    let ref fancy_field = drop_struct.fancy; // No more errors!
    println!("Fancy: {}", fancy_field.num);
    // implicit call to `drop_struct.drop()` as drop_struct goes out of scope
Note that this technique can also be used in the arms of a match expression:
struct FancyNum {
    num: usize
enum DropEnum {
    Fancy(FancyNum)
impl Drop for DropEnum {
    fn drop(&mut self) {
        // Destruct DropEnum, possibly using FancyNum
    }
fn main() {
    // Creates and enum of type `DropEnum`, which implements `Drop`
    let drop_enum = DropEnum::Fancy(FancyNum{num: 10});
    match drop_enum {
        // Creates a reference to the inside of `DropEnum::Fancy`
        DropEnum::Fancy(ref fancy_field) => // No error!
            println!("It was fancy-- {}!", fancy_field.num),
    }
    // implicit call to `drop_enum.drop()` as drop_enum goes out of scope
E0595
Closures cannot mutate immutable captured variables.
Erroneous code example:
```compile_fail,E0595
let x = 3; // error: closure cannot assign to immutable local variable `x`
let mut c = || { x += 1 };
Make the variable binding mutable:
let mut x = 3; // ok!
let mut c = || { x += 1 };
E0596
This error occurs because you tried to mutably borrow a non-mutable variable.
Example of erroneous code:
```compile_fail,E0596
let x = 1;
let y = &mut x; // error: cannot borrow mutably
In here, `x` isn't mutable, so when we try to mutably borrow it in `y`, it
fails. To fix this error, you need to make `x` mutable:
let mut x = 1;
let y = &mut x; // ok!
E0597
This error occurs because a borrow was made inside a variable which has a
greater lifetime than the borrowed one.
Example of erroneous code:
```compile_fail,E0597
struct Foo<'a> {
    x: Option<&'a u32>,
let mut x = Foo { x: None };
let y = 0;
x.x = Some(&y); // error: `y` does not live long enough
In here, `x` is created before `y` and therefore has a greater lifetime. Always
keep in mind that values in a scope are dropped in the opposite order they are
created. So to fix the previous example, just make the `y` lifetime greater than
the `x`'s one:
struct Foo<'a> {
    x: Option<&'a u32>,
let y = 0;
let mut x = Foo { x: None };
x.x = Some(&y);
E0626
This error occurs because a borrow in a generator persists across a
yield point.
```compile_fail,E0626
# #![feature(generators, generator_trait)]
# use std::ops::Generator;
let mut b = || {
    let a = &String::new(); // <-- This borrow...
    yield (); // ...is still in scope here, when the yield occurs.
    println!("{}", a);
b.resume();
At present, it is not permitted to have a yield that occurs while a
borrow is still in scope. To resolve this error, the borrow must
either be "contained" to a smaller scope that does not overlap the
yield or else eliminated in another way. So, for example, we might
resolve the previous example by removing the borrow and just storing
the integer by value:
# #![feature(generators, generator_trait)]
# use std::ops::Generator;
let mut b = || {
    let a = 3;
    yield ();
    println!("{}", a);
b.resume();
This is a very simple case, of course. In more complex cases, we may
wish to have more than one reference to the value that was borrowed --
in those cases, something like the `Rc` or `Arc` types may be useful.
This error also frequently arises with iteration:
```compile_fail,E0626
# #![feature(generators, generator_trait)]
# use std::ops::Generator;
let mut b = || {
  let v = vec![1,2,3];
  for &x in &v { // <-- borrow of `v` is still in scope...
    yield x; // ...when this yield occurs.
b.resume();
Such cases can sometimes be resolved by iterating "by value" (or using
`into_iter()`) to avoid borrowing:
# #![feature(generators, generator_trait)]
# use std::ops::Generator;
let mut b = || {
  let v = vec![1,2,3];
  for x in v { // <-- Take ownership of the values instead!
    yield x; // <-- Now yield is OK.
b.resume();
If taking ownership is not an option, using indices can work too:
# #![feature(generators, generator_trait)]
# use std::ops::Generator;
let mut b = || {
  let v = vec![1,2,3];
  let len = v.len(); // (*)
  for i in 0..len {
    let x = v[i]; // (*)
    yield x; // <-- Now yield is OK.
b.resume();
// (*) -- Unfortunately, these temporaries are currently required.
// See <https://github.com/rust-lang/rust/issues/43122>.
E0178
In types, the `+` type operator has low precedence, so it is often necessary
to use parentheses.
For example:
```compile_fail,E0178
trait Foo {}
struct Bar<'a> {
    w: &'a Foo + Copy,   // error, use &'a (Foo + Copy)
    x: &'a Foo + 'a,     // error, use &'a (Foo + 'a)
    y: &'a mut Foo + 'a, // error, use &'a mut (Foo + 'a)
    z: fn() -> Foo + 'a, // error, use fn() -> (Foo + 'a)
More details can be found in [RFC 438].
[RFC 438]: https://github.com/rust-lang/rfcs/pull/438
E0534
The `inline` attribute was malformed.
Erroneous code example:
```ignore (compile_fail not working here; see Issue #43707)
#[inline()] // error: expected one argument
pub fn something() {}
fn main() {}
The parenthesized `inline` attribute requires the parameter to be specified:
#[inline(always)]
fn something() {}
#[inline(never)]
fn something() {}
Alternatively, a paren-less version of the attribute may be used to hint the
compiler about inlining opportunity:
#[inline]
fn something() {}
For more information about the inline attribute, read:
https://doc.rust-lang.org/reference.html#inline-attributes
E0535
An unknown argument was given to the `inline` attribute.
Erroneous code example:
```ignore (compile_fail not working here; see Issue #43707)
#[inline(unknown)] // error: invalid argument
pub fn something() {}
fn main() {}
The `inline` attribute only supports two arguments:
 * always
 * never
All other arguments given to the `inline` attribute will return this error.
Example:
#[inline(never)] // ok!
pub fn something() {}
fn main() {}
For more information about the inline attribute, https:
read://doc.rust-lang.org/reference.html#inline-attributes
E0536
The `not` cfg-predicate was malformed.
Erroneous code example:
```compile_fail,E0536
#[cfg(not())] // error: expected 1 cfg-pattern
pub fn something() {}
pub fn main() {}
The `not` predicate expects one cfg-pattern. Example:
#[cfg(not(target_os = "linux"))] // ok!
pub fn something() {}
pub fn main() {}
For more information about the cfg attribute, read:
https://doc.rust-lang.org/reference.html#conditional-compilation
E0537
An unknown predicate was used inside the `cfg` attribute.
Erroneous code example:
```compile_fail,E0537
#[cfg(unknown())] // error: invalid predicate `unknown`
pub fn something() {}
pub fn main() {}
The `cfg` attribute supports only three kinds of predicates:
 * any
 * all
 * not
Example:
#[cfg(not(target_os = "linux"))] // ok!
pub fn something() {}
pub fn main() {}
For more information about the cfg attribute, read:
https://doc.rust-lang.org/reference.html#conditional-compilation
E0552
A unrecognized representation attribute was used.
Erroneous code example:
```compile_fail,E0552
#[repr(D)] // error: unrecognized representation hint
struct MyStruct {
    my_field: usize
You can use a `repr` attribute to tell the compiler how you want a struct or
enum to be laid out in memory.
Make sure you're using one of the supported options:
#[repr(C)] // ok!
struct MyStruct {
    my_field: usize
For more information about specifying representations, see the ["Alternative
Representations" section] of the Rustonomicon.
["Alternative Representations" section]: https://doc.rust-lang.org/nomicon/other-reprs.html
E0554
Feature attributes are only allowed on the nightly release channel. Stable or
beta compilers will not comply.
Example of erroneous code (on a stable compiler):
```ignore (depends on release channel)
#![feature(non_ascii_idents)] // error: #![feature] may not be used on the
                              //        stable release channel
If you need the feature, make sure to use a nightly release of the compiler
(but be warned that the feature may be removed or altered in the future).
E0557
A feature attribute named a feature that has been removed.
Erroneous code example:
```compile_fail,E0557
#![feature(managed_boxes)] // error: feature has been removed
Delete the offending feature attribute.
E0565
A literal was used in an attribute that doesn't support literals.
Erroneous code example:
```ignore (compile_fail not working here; see Issue #43707)
#![feature(attr_literals)]
#[inline("always")] // error: unsupported literal
pub fn something() {}
Literals in attributes are new and largely unsupported. Work to support literals
where appropriate is ongoing. Try using an unquoted name instead:
#[inline(always)]
pub fn something() {}
E0583
A file wasn't found for an out-of-line module.
Erroneous code example:
```ignore (compile_fail not working here; see Issue #43707)
mod file_that_doesnt_exist; // error: file not found for module
fn main() {}
Please be sure that a file corresponding to the module exists. If you
want to use a module named `file_that_doesnt_exist`, you need to have a file
named `file_that_doesnt_exist.rs` or `file_that_doesnt_exist/mod.rs` in the
same directory.
E0585
A documentation comment that doesn't document anything was found.
Erroneous code example:
```compile_fail,E0585
fn main() {
    // The following doc comment will fail:
    /// This is a useless doc comment!
Documentation comments need to be followed by items, including functions,
types, modules, etc. Examples:
/// I'm documenting the following struct:
struct Foo;
/// I'm documenting the following function:
fn foo() {}
E0586
An inclusive range was used with no end.
Erroneous code example:
```compile_fail,E0586
#![feature(inclusive_range_syntax)]
fn main() {
    let tmp = vec![0, 1, 2, 3, 4, 4, 3, 3, 2, 1];
    let x = &tmp[1..=]; // error: inclusive range was used with no end
An inclusive range needs an end in order to *include* it. If you just need a
start and no end, use a non-inclusive range (with `..`):
fn main() {
    let tmp = vec![0, 1, 2, 3, 4, 4, 3, 3, 2, 1];
    let x = &tmp[1..]; // ok!
Or put an end to your inclusive range:
#![feature(inclusive_range_syntax)]
fn main() {
    let tmp = vec![0, 1, 2, 3, 4, 4, 3, 3, 2, 1];
    let x = &tmp[1..=3]; // ok!
E0658
An unstable feature was used.
Erroneous code example:
```compile_fail,E658
let x = ::std::u128::MAX; // error: use of unstable library feature 'i128'
If you're using a stable or a beta version of rustc, you won't be able to use
any unstable features. In order to do so, please switch to a nightly version of
rustc (by using rustup).
If you're using a nightly version of rustc, just add the corresponding feature
to be able to use it:
#![feature(i128)]
fn main() {
    let x = ::std::u128::MAX; // ok!
Argument 
 is not valid Unicode: QuerymsgPpmTyped
PpmExpandedHygiene
PpmExpandedIdentifiedPpmIdentifiedPpmExpanded
PpmEveryBodyLoopsPpmNormalUnlabelledEdgesPpmMirCFGPpmMirPpmFlowGraphPpmHirTreePpmHirPpmSourceItemViaPathItemViaNodeStop
assertion failed: index < lenliballoc/vec.rs
a Display implementation return an error unexpectedly
capacity overflow
Tried to shrink to a larger capacity
liballoc/raw_vec.rs
/builddir/build/BUILD/rustc-1.25.0-src/src/libcore/str/pattern.rs: 
libcore/result.rs
/builddir/build/BUILD/rustc-1.25.0-src/src/liballoc/vec.rs:RUST_LOG
warning: invalid logging spec '
', ignoring it (too many '/'s)
', ignoring it
StderrStdout
called `Option::unwrap()` on a `None` value
libcore/option.rs
()OFFERRORWARNINFODEBUGTRACE
MaxLogLevelFilter
attempted to set a logger after the logging system was already initialized
set_logger() called multiple times
attempted to shut down the logger without an active logger
shutdown_logger() called without an active logger<unknown>TraceDebugInfoWarnErrorOffLogLocation__module_path__file__lineSetLoggerError
ShutdownLoggerError
;*3$"
zPLR
rust
3gf2q7 B
]]]]]
wxHDTH
(i32
EK$N
RM]Mf]
m}-D
]Du[
3s6M
#'K3j
%jL]
3uf-
I{>^z1
EDwn
Qg2dt
&m']
7r 4
w%N.
R i1
JUmdblm
Y	$1
]DtYR'
AQgM
&V)^^I|I=R&
TDxER
sd05x
,^DIR
RDI<
10.>
{zxx8
|kR9
7O)]
ebKkH
WHHP
hRR=\
u*T)
U NX
~E|]
=aHTLlh
n~6f
)V^I
y{{;U
!ana
Hl'T
daUaW
qups
Lz&@
_hhl
F^-",
^qmd
lB4a
_{_{K
F0DD,n
)S5*
*S)>
h,H4
HmR&>
]&IMB
ZIMj
T@YM
I<)J
Q%4$a
&.E"HR
nn!^6
4B\,
~)xD
"UIe
j)q!
?18$
MUL 
rtH)V> 0
+U),,
Kg6w
3qv,d
@lR\
I(U->
(KUN
KQ8)
h4fq
/Di-
U E+TV
6J,Y
n*b_,"PS
BHdt
)I)R
[:4""
v|BD
Z\dp
akfL
$(IE
VMXs
O8^k2
%B!W
FnS[
%drr&eD
2)w|
7n]=v
wN88
EN!4
DIkD
OiKfd
GE<*
GM<j
-$Z(i
jZX`!*
oY'Gg
ZKg6
H;R3Mm
t}' K
~;vZKe
4Cfv
"='3
uH4j3
%e:n7:
-$Z(i
-liaG
[A|;
lgIM7d
36N2
wL3`
7hFB%o
-,iaE
-<iQ
-|iQ
fjQtl
(HGcE
PAV*2T
Zs;<a
TKkNk
[rD)*
\A'g
tx- 
bA($
@(T3
ReJa
3Jc2d
W`rl
s,}V
IOOw=
w:PH9&
&]gJ3
3bGO
@A$!
8)?UK2
DA#V
C@Au
P&l)
KKm~
efK)
Q/<Q2
%9N8
c|*Z
-,iaEN
%)/D.IjR	
Rn7$
z%sx#
@%Wn
g6>'c
	.=Za
{s4.
6Vei!
b5-6
H,pC
D!%-T
)e:R
V[*L
(Ls1e
uS>J
"231
Z*:N
g6,y
=zll
'f[aa
[nM0
VJ,=i
Q=TY
'{Om
+(2gZ
-es]
'c-:
2==?2
|o| %
hckZft:
nEcsb
gbqs
>66dJ
4u`V
f~oj
ye;y
X_~m
AxV,ym
`NLS
xt4e
>zay
oSoL
Us^>i
O[{`y
/-kW
nSmN
uJqxWS}
FKGW
]M,\
o[HSq
3etH\tr
^i^Z
isrDt
iW;))
>;N=
'6<Voi
}jfw<
F]Z>
nrvW
G.Ov
Max:
uN?{j
y2.~
vk?yz_
;]5g_
oA/j5\
e?^v<
w>Sb
]+]t
UQ5f
]_Hi
-"r^t
viYW
5(6'hj
M;W.
KY:$
%s>\
>tg{F
9~.7
76&9
_F\+
.W{,
~_}<
%dV=>
ZxeDx
sK3z?
{u}R
^fZ?
Q.;w
lb3,
<M|t
N<Xh
*ucK
;JSnVh
2mu.
hbRv
52\SY
3*.6
)%6>
XXP7
VmJTW
WM6O
cp-M
_[/-z
DW$k
{T9X
zlKh
s^azX
q54H
E.v2
vOK=\m
N^Rq
={Pp
^=#:
S+<}
;-m5
W+^*
[-*]
=-]uG
!`yn
U$,fD
CzD\q/
bj>k>W
9zSa
X>64*r
I^R7
!~o?
Sow~-t
onU+
9>kU
~{?m_
Wc/.
KVV\
#+D_}
oS-L
_V*cM
/,z#
fXH+
u[mn8
Okw;
S7sP
r<0m
5#KV?
S:_l
>"{n
F]+&f7~
MKio
vwtr:
93fx
oOku
#|53
9f5im
?}n =
9;NT
=?H|
ZkQu
kS|J
KzU&
N3"g}5>[
oS<R
WrwM
lU%x
En>Y|
-eP@
4J]C}
'rX?
WoT-
6-;G
oNh]
bS?NQ
XYrF
WY=l
b/{T}X
p\e}7
|3^}
}:-!
m;ll
VnWFv
4P{eM
1#& wJvp
V?|#
stuf
VaUj
R-Y3
nO/l
h3px
F]mF
fD\o
%77L
A'LW
Nx&YT{
*[[]
W7r\
=?ijM
| iSb
{sLv
nv_V
inau
+Snu
[;z,
rv?UUj^
rJO:uc
PoT_Q?Q
%Qxb/J
Y(v<
&*g*&
T1^9X9[8'
zeOuO
"=Q^P
WNULT
F}'mZW(
Z2>JS
.e}Cu
Vg6d
`R=s
,U;R"Ao
LmV:!O
hkEy(LZ
xG	+],)?
Y_/[
X@_w
k2Sg
rzmF
!Mk6
L!fj
bG;m
hO#0?
-uZcF
Z^Duu&
Ijv.
g#8d
6mM}
~HXJ`
/+.zvFN[}
${{*
]S;k
IgLJ
"9+MG
ijY9'3
6+=Cg$
eT$-
^6*:
]wYF
ig6g
SDHvV[\[c$
+ DM3E
T)yK
; qO
+uMZj
c-FZ
R}R}Q}S
WOVOU
IgNMk
VoWoT
M$n 
Rk][}
X=W=^
PX,,
V$@p
Q`/a
LP+\^\
np15P
*O`:
& (i
ZxtJ
}P=*
?AYH
zCN)
bT"@
6\Sz
EpDC
ZBpd{
 `2J
A	XKDP
7L?[T
0(Ch_
Z\,B
x&U4
h{fE
|9*V
9A6?s
{Q8t
Ek$S
3X6}
$8RP/
Xz^\N
$^r0
G#%5
CdRk
~wJg$
+Co6
6\ras
RFF%
2+u]
X8R6
BZ2Us
>==C
~8iB
rS;i3
9#d_(
1Rr`
83Bv
eW5j
i#d	
wX4J6
Fx'|
V\/n
xJ<#
"Wq@qHqDqLqBqJqFqNqAqIqEqMqCqG
Ha!8
[@l}
eK%%
HdhmD
R(%#
(WoI
Pm){+
E@!@
Z83O
y"!6
t]z*
XvA[
vlD;
F'Da
h=`a
TcVIo 
vzcj
X}TR
q\p"
Jj	@,p]0
Bri;*
	^4/:%i
$XsJ"Dt
-K5[
c^ha
i	pa
2z:O
6Z+n!
KoT!
?q |6AMk
]`d"
SAw~
;f_OI
\A` 
5v]>%M$8/
KOKJ
5@!*
RY	g0T
:N(7
l'aN.
=QQe
BQ`5@Q
"08J
!zb,
p"Ch
~WT1
(}qY
}(8>]+
P 1O
04l8LGg4
d@MI
-	1y@,
[&|,@%T
/Pe"
l4@M
R	ua
KCZD
fy@=`i
$n!4b
@S"C
R0	iZ
?c#>cH^
T`g@
D&[M
{|U4
)(F~
Q4w(
ZT	]
= @T
*x{^
wA"hZvK
r)Y/
<l>-
-E$`}
xHG	ce
dYrKaJ>45
$ "7
!:/_B(
}I2rA
Z[	s
5>m 
@ux|QrV	s
M&UB
VBoR
"Yp#r1
5`h%z5?
3RsdL
I,5D
Ojh%
5ZBI@
$zZ% 
qbPc
Da!_-@
ZIuK{
@/"i-
}Q;656
 b,2
?r`2
RpjR
&>H8z
(6}#
`K5%
6+n#
B?b\^<%
kCV[
4~Qt$
y	[|$;/
Vr/H
OMftz_
slQ/
'f?i
l4dh
H(@6-
9Z,$
w<}N
$""0
%\%.t
F37p5
r'qJ
y9%j
nJ>< (D
RAS2
A@}]
A7So
,FdL
Q3J>{4
wx)6
/5x:
3z.	
9pJ&O
GR(71
\Z>V
^.O4
JrCS
e66o
~eX"D
_jgRo.
 h~y
]oN*
%sf	
K.yN
[I~c
S9S/pE
|.>K
fx^r
8^^CLI9
7+_1
2|T4
}4wW`Bo
VRti\Bt
c6J4
:,oC
GV}	
G?Tc
1_$H
2LYH
}vER
)-@P
\dmK
	/+	
sf)OZ
"Re$
>Vg(
3ubK;
$j	U
ec9}4
b/+s
Zpzf7
k#2U
\m>oA
YhF#
E3cq<
5.zt
4|F6
d73z
Y6.	
,O^p
3G@EE
sNkB1#"A
umb,
A_00
Inn+_
,on]
O<<#v
|zO<
Gy*W+
Q`5N
=My[
C`[6JY,
,xp"
7%n#
z0nL
~8nM
G6K#
gd#$
Bt+C
h8en	
q9SG
"$00
xzn|%
H&BID7
dIW4
?Fwz
ck?C
Lt@G
WQ.1]D7]|i<
`fFU
f>;gGp4
B(lr
<o_`
VLb~
b`~VE
[u}<
GQNtv
\)rMV
euYyH
;RYk
U&5!
4k	/
^,K*
e"\q
.9+E
,O:V
)E?x
bN|d
mqlL
)=}g$
vUTF
>c@A
Wqh{
RJoi
<Vh7
jOT8E
9KRX
.k3y3h
 @3d
CKcA
)SRf
\Vg6
5$r.
i5@~n]"%~
9\D5qQ]
k 1\}78|M
jM,N
5vg5
Jd?4
hd0GCQb
d})0
VD0"
`8kwn
;qOn
<E63
<Bc=3
hU\4*EZ1
-^%BG
GvLN5vdM;
wXHW|D
;Y![
AOAs
f;Mf
)2<E
B?D)
rxdi
.^?F
r++^
9ED7+
rQII
4~B{kg
wPhR
dlp+7
)KS/M
VR2^*
K|QM
.0L<
LPN?
LWJ/_J
~rh\
:VR2
r)J~
i+ch
9er*
(#Q0
tMm-4
c0A=
sq-\
kX1B
EZRq K
diee
beE5
A.ad
{Nd{GY
?alY
o/NBW
P/N`
#1kU|H
{{XW%A
G3T6n
bQQn&\sO*k
_gj&C
{$n#<
Xl=8Lp
STDV
HPADt
C9R@
!YfF
4#	7
HTP2
vx&K
P\g<
KG.Op
d9MO
V@YA
b$p"[#
vqY<
T&DG
%jH\M
"htpY
|Jek
R4$F]
z,Y@
gFy1)
LF0@
0+,8
L7`#6
Dw`$
G#CK
fj[Q?G405
C`;Z
;NLI
xs1v
wBQu
b5Geo
mDo&
Y|{F?4H
E6NZ
$PXpW
9e._
**<9
8ZaOq
u);^	l
5Y=1
mIic
tSY~
vH7r
H%|L{
bVY\
0$<;
"#4MOnq:
FiNB
N zzV
j-1.~
G)=K3=
R?9Uh
7J/4q?/
u40x
0hho
4yJG
?nb['
V(D$
+\9W~
~c6H
"m0g
;[&- 
9v>"=
A fF:
 W<t
^h~hS'9
,N<"
C`cz
|b.q
5aX s
Iz 2
4:D0
'QcF
b|yd
FYy?
D;Y-
?p|{
Xvt"
tg6Tj
Me1b
lDN`
,7l"
)|rM|N,MH
)\}T
<$a:P(
]Z6i#
VK/*
/&YF
NhdIJ2
T`=E- 
8\$:x
2-R^
MEC7
<%Y n
~].Q
4Jfk
b-Iv
[B'(
a&F_
tO\c
M.gfP
m	4Q
>-iJ\/
;]+yz
~xcF
'CWF
KWwh
f&#l
Pq?F8r'
QeOw
/N`/
gXZe
_,RWJ"
#<jt
V=e}
%0$W
b"@D
6) K
e-		
[H6X
JgI2
Rh8c
r.)g8
(+5K
|xQr)
B}TO
Z.I	j
d30I=
	c['N
R6f,
sJG;J
ch57>
K5I"
"#:z9
^r7?;
Q:J4
ya$5
|N)F
)l.4
v`g{
CWFR
6*S^:
\K=>
C-f'
k1cr
N>|r
%mc[
*wUU
"J5"
EqV\w
bq,QD[
:}%=
f\(b
-4"j
!0@C
%FB-
5Bq:
`Pwi
k/D,
irL;U
']r^
pxaG
X0\0R0
,>>,
E^`*
>kvX
)Fn0
0ue,I
N"i8)
As\q
?eojQ
"0of
>"C%
Uyji
1.kq?
*o?B_
 `gx
)OHM
|a`8
md3d,
6;sk
 !B-
N\hp'
)25 
y>@	
!oxa
<rF@
NmL7
p1:J
8Aj]
,xU}
>|{^l
8:-E
<2--b
rA;V
s&:W<
<7:'
}	gAC.
YizEXc
29{F\
5Sqme
<.a7_-0
ho=`
ao^M
>96)
'&}Z
5Enc
Opu4
Mg6-4
hH;o
5RDS %
	<GE|
s8syy
>|FZ
;z[5;2
qhfC
)?iS
-ne@
yJpfs
{-E^
\FU(#x]
?b3B
GfZ,?
VcI	
hW+"
,H'c
Ih@D
LfL"
Jxfq
~}V2F'i
2#ENsx
g'?kq
M/HM
zQ@Z
Anv@
g45wg
rT!U
AO?GCr
_}nrC
u v=
	w`78x
Kun-
G-K"a-
p2("
.LjZ
)R-D
61Dp
E	Oc
y<|Q2l#
2b\G
ikXD
4A#N
q8cH
yE2X
,(FK,
!<wvl.'"
	cXD^t
hACh
$^+F
O8ht
3JLJ
KwkW
z_QN
kXSn
F'1~
\%`ViD|
;+Ef
!N,2f
EYj	
yRMx
LHQx
 /VZ
[}K|RU
iO:S
V^mzn
_3()|va<
N<kG
/&oe
Z|15#
y|65S
2NZ|
%7]bS
<pe$
I<fr
v|0/
A6gv
r~\k
G_eY_
{)F-}
3;Hu
xhI<80n<
t?pJ
<,"n
(3%xji\6
O.bF
\\+y
?`J'}
642^
,e$M
^*/f!
N}j$q
x,CL
<-y3k
susQ"
~BTN
TIw~WrAW
*eHiD
>,	i]
T--R
*}H	./g
Hm}p
6H#f
UgA*
>rmr0
}A+5
`8)'"O.
}a5d
=~b0
HA_Y
PU{S
H2H{
!0k&cI
^lTqS~$/
X,/~<
]bi[#
-	[L
Hy,OZ
8r5V
m?gI
$b@#
U?^g
$J\O
\+Y (
1sI"I
:0" 
0:6@Ra3
Jf|g{
Vbq!e
tF`H!
taP5p|+
-L8.
V	8'
6[Fs@
Bb3H0EV=tJ
%ur'
0w!j
I+B,
+byz
{V$=5/	yiy
`$~k
:h&v4Y
yx)&
	ayL^
U7AwA!
nc&M
e[2H
\?|</
_[]p
]yA4$
iXux
IyD^
YkeLT
SWAD
Okef
yPiL
pcuP
08ke
B"	>~:
	]bs
C`"c
OY4&
B`, 
ZL;[M
|i9L
+uva
.xaE
?Lp}
8~bg
(sh+
<_EZ
aJj"
eBzK
v{F1
0X,R<
wM8r
F8>PK
N%PA
23X,R
2)]hS%
VjK/f
^;KK
smMY
34ez
b3&:=
\3>6
3cBJ4
gP:|
R>Nr
ls1gg
bJf5V
BYk4
}{vqM
>KKV
<~]F]0
kjZPc+
x_@&={]
9xH)ugR
ZtG7O
D89Br
fy@o
H]KS
r7(R7
oK&C
fugw
dLG(
+Abk
%TGK
+`]}#
xK&e
smwK6M
rM-+
E<n&l
`{	4
J5wC
0YVE
bfBuv~
&7;@@GTMb^
v%g3~s
wgF3
!K%\)4
Ln^D
~Bdl
^5{@
`"0*:
c~	l?
SEiaBVE
%|gUD
zYV2
G8#Pz
NYmu
@7Cm
Q&Vw;#P
,ojf
a*Q.
%aK`
:6)~S
$oy"
$:e(
qOf)h
.xR=
6:_D
[YX@pT
|r'<h2
~B[w
x~q&yjn
C5Ww
	|]dVF
a_y&
ri+0
1pJ1w,
KY)s
xyqF]
kg##P
^H'3
R_o?
x` x4
_3A`H5
Xj|,=
VPBJi
 PeM
r.Pa
YN4S(
$/x=
3]{FN
}jhW
(-hyt
yluf
8.:8H
Z_QX
R. -
j	I^
:rc]
\HM>
?p1{
c.uS{
a)@fs8
X-	Z
#uVm
Y}"hg
8|I6E
NakM
2 eW5
/m_wz
Rs+E
15fh*
:$HY-J[)
x{IVkq
64	-n
 kiq[E
X|;Qa-
nVp|
/84	
lX d
L):B
an1H02
P	<~
p7+@`
=@`w._
	v]O
77@`.
>T9d3
X!w@d
q+vG
F{f)
%YMZ
=$v@G[
=6,-
	yAz
r7X9'
NV$A
so=e
D24 ;
J=3!kZ
_RO-
_3]x
yXS*
]Xo.
;WQz
T5O;
$Q/@
^P]F
~'LSR
PwR< h
zrS"GJ}
[RK+Y
a	G]
S},y
ggZ1
.kX`
2y"S
8vIS
u6q3w
}s}2;V
3(he<
D5zr
[5"lb&
<N?8
\yH.
(@`#0
#v*tp
Z4wZ
(3U0M0e
K]5I{
>4o?
.N>|
:"_	n
G={,
|gV_
4B2r
@G*$
+*gd
0*fS2
pJ3@*
t3`K!
w8zih
G/u*t
\ILMp
g77|
x!K=d
HWh`
SK@{
Ef(3:
Bm))
*E@p
U 	NS
S[#\)
{ObwO
bjW%O
`&XOc
o7ev
2iQ&
AyES*
Lu>~~|^
*n2g
QeHUD
3r#M
lB!n
9	STY
JzLy
OWPA
B5P+h?F1
]	GM
4u^2	o
T;4U;S
}{~n
z~4s
EyU4
mI3N
z_oo
w6=$m
}:>b-f
<#|Z
,N^J^I^K
?K/J/I/K
KoHoJoIoK
+-)}X
wrF$
L`q-K
D;Ao
'x4e\;
$K=9-;P
f3n}
*=1@`
WS79
cBAuQP=kr
n*"2-"
@Vqx)
aMp43P
y\Uwd
JCK`
uM+\
l:RY
tfNK,m.
bIKw
#'o5r
RjFI EPs
g)q>
\zXK
rx}	
!9O 
G+Nx7
X6mo
@SAuRz=k
km{u
)@GE
haet
5"\3@`M
$Juh
/jM~
0@`C
;ha(
OoQe
[lfz\P
0X9<s
3ik$
K3es
	2)f
*B<R
5Ec1E
A~~ERD(
r|sM
x;gu
z,Ui8
D0 .
aQNV7
\3J'7
+$mX
[F=&
">GW
f0dLN
Q	3#
htqCJ
J_sY
cc[`u[
76Rh
pC8-
\}Py
PV1-k0dLN
Vqwp
Czh6
d0dLN
f|0o
5d0)8=
9}.}!]
]\x>
Tww"x6
C0l=
zX[j
f`][
=X1u
q;Ze
V1-k0d
a6rZzX
zB<(4<
%Zg<ArL
HL1M
-x,r
,s4{6
|K6H
-CE^
*+8W
hE@=:HQkDoQc
fzBp
k^.<
@oi^o
>e+u
ec+E
ecQx
=G7t
Zzn9
ecn9
S7BpT
e4@V6
[u\d
40v	
AJWUP
3dX.
G+90.
u}	dr
s[[_
=8@Q
t	lL
QI<W
~ubJ
nkq*
jnqY
RCs:
`69k
eBCj	
`+R<)6
?m C(
=I3t
zYC	|
`"5jrtM
}y~Ts
MjI~
V>.m
z%><e
1`<*
xh7b
dejq
Ltj8
jy)mb
%L0\
kW8J\
p@!M
hS_,
7&@`
:TZh
R5w	
G!#qx42F
:{h!
,9-'G
w6GN]
@MqEYO-
#@J{
teK7g
?Z!j
5$P(
>Br=
N'w^
PZ\z
J	.U(p
=L/_
./xX
ti?6U
M?E^vg
Cq5t
[GW2
?dvD
*J5'
j(uXIP
U#\-@
U;ij
So5d)
#VG{
u<y7
K Xd
u5FN
&F8)@`
c05/
uPXs/p
3ytk
_sk`
JZskE
sBe\
"TfM
\tb%iv
[?@`}
pK\eU
C^9(
W6w9
/84	
	zbC
a2Wa
E,C6
W0{5
 8B[
RbM<
Yp..?
\<Ez
2q<3
1>Rk|
. )RK
YZKXo
_l%.
	 .$z
Ns*%
\l4Wd#
vZ5H
GU<8spwm
jkiAO
B5"z
QO>B
zFbT5
em3=
)k"=
.L )
Qp>@
sq4qI
KgU&
Ahs(
Q$v$
e*A3
)?asM
=L7?:
CacD
7P:65
YyV>
Zn+.5d
g=M~1
ugY}
&Wiq
ws>Y\
^s/l 
.TU<
J&\|!
GUI:
=mfp=J
D*8	
D|w0
J	|g-WIp
1muS
tieMq
Eg;m	aIn`
kcAG
{CJk
~Oq#gA
~Ya%q;
r%}$
++lhP7
:hbXfv-
QB9W
dgO:
>^,v
qWEP
5zbQE
,EAYRp
gRN4
b,P$
YTg	
<vZ0
aeHY
/FK=z(
yC)K
Yt$}v~q
F.oe
ew4z
.}-O;
g79qy
1nKI%J
Zx`A\
M4cD
q9PT	
,/nr
tUiq
4hF$
dZ[%
$XW0
l@%-
%6bM
[8>G[F
Ey#|
t Nj@
t+ki
?U$5
G3Ly
IVEH
_aQCh
NhPW
^%l3
,$Y+
ffW+
|P4[
[#uy?
Jq83
kk#@
!0dD!
4dH9x~k
L R+
Y;C&G
%CZ3
=C:2dj
<@`s6Q
Twb7
+	|&b
&3q;
wLx%
wDDv0
z_	HxY>Wo
AaI,.
@s]V
bOU-
FZ.-
[6"uy
%mv8a
J\{/
N%Xm
P;MX
=XZ\j
CO#JEj
4!>h
%?y0
NxPb
 ;(	
ANKZ
%gs`
Y?CFd
6SXJ
_{Z#y
4:q[D
}I7r
G?Rj
.@`;W
{"'<V
XvRMw
Tay`7
X/Zf
@$y|q#
 @Vi
BlXqw
{D8=@`
!.Mn/
M73@`&
(a&.y
(K{s
VvK!
+-?ig
`CGp
K`w6
98aq
}Wak
&o[l
v9gY:e}
P	{ e
xq)mu
?~*o
r:/"
hfG0@
pao,S
-G9r
8U4+
F'k#
p8nY\zQX
$geI
ppvK
pY	bN
gZb?qR
ilSi
7b2*
gQf2
e<UUL1
4	vC4
T	=_
CLEV
U>j4
,XKQ
HQ!z
Rbuj
~EmYW2J
52*N;liJ
ndY_!
j_!9pII
n`m:
V+u+
OZo&
EdZo
cV@3,
'n^D
IlM-
%_q_
r*Qq_
^D/{
3@`Or
&93|6q	
hF.t
lROP
BasN
>l9`tX
~tde
Q#mt
Q#mt,
1%iO
*E_ 
=",p2q
\n|.
#lUQz
)arX
:=L+
rW5<
Z^;G
wOWk
b5kN
 g	\
kyTc
o7aQ
~ca#
)`Nv
#$4Bf
%iz_
U.9W
S?Eu!
1~%)
\"#f
Mh5V
C)~R
[&yPz
/5[K07!+
iW;/"
C?I~
b8qx
(8CF
+?-p
>P[n!
k>P+Z
GF8*@
	[+k]
	j>Z
0iz7.C
vA[;y
4YL`4s
c#\!Bz
T<nS
NX&8u+
 8k7
ndq$&'
$0Y0i
+-`j
	6]Y&
[tpY
c{]fn
9@`g-
pK	*
sx{a
_rp9g
\ph9mr}aW
{G83@`&c
7?@`~"
55|U
V8=@`:
gD8=
	`VF
QM~O<p
}Xtx
WJS-
e:r?
Z/M9
ICe<
mc2KI<
vGwq
?i{b
@OuY
Hu/Mz
[Q^=Z
g!T6
:|~s 
W}tSv
-qEt
KyRu
W}ru_
;GC>
$L]F[
vHzXzDzTztzlz|zb
eWX:&
,a<8
g2s~
s/N(
+	<=
<;r%
V:&y}yi
oS9I
^RY m
Uv8|
%PNA
PA<_
9~]zU
%xEd
uh9(
7<&qZW
weGZ_
9A^`
TQN k
Sq-8n
;0,a
Q]?t(
V`8Y~
Zi8{
PF7L@
-<b5
Z3^A
W;M-
_RrF<
	NlV
6bE*
Kflb
H	kU|
ueHY
?XcI
J%-u
usd*
nW-r
5	; 
{B%G
#5DY
7.	o 
5R20
)8IQ
_nxy
g-ql
LM&tNDT
8N9P
-M8.q
IP-v
?;P}
j2LG
{q?;'
<A@/
'~C)
]EsB
D|3^
3DIlT
	g%^
ZEk9
QR%l6b
B84d
^M8'q
YL~1
	RAA
2U;,
2[L<
7 ~M
u2dB
$C.{!
"v1J
3djD
1NbW4a
Mt!os
4gHK
$C:3dj
Y)CV
gF.>
TI&?
6/LB
@(?S
5[Zm0
 }Yb7H
VoZ4)
 t-\e
xWQ#t
@6wmR
FY+M
c%Ui
M=YAP
bO/~
hsP=.}
>"y8U
P-	&S
t8#W~V m
i{$umf^
TKBl
`.3c
F/CO?
13_=(
4@d	e
\B-SJ
H5g3
CMVb
o:IS^`v
JL@]
UWwJ
VAdk
^:OZ
|eBR
!} }0}8}4
8vqo
ye#w
Br-?
t;bzS
\P/so
:>p9
pE)I-
_[8u
*CRE
$7D*
\nD_
(2CG
e.\j
#BZ(
HxH^fC
LgjG
zk$e
!n4\
aNa;xp
C\'\
aAa#\1@
p5\[
6W6}'
,hL)
lzHN
9A"`
Q`We
a!Bj
<l1H
Uq"I
%^@K
	T#XW
ysf9
{3sO
6?s;L
I.q_]
i<=S
P9=fi
,axA
txo@
nt3B
	o0T
!41(!
]s?*
?],H
&dXr
]_-M
@_Cn
,wPey
%@_9
=m^/G
Fu.a^8
F)8(
QQe;
r@$u
G]7x$CX
SXB<m=
 k(`
8z&Q
=FFNQg
@_C.P
SMK+
I<}#
v"03
 P}O
Tr6k
"hqp
~hna
9TrN
JK\[p
!m]i
YxDQ
FE8:@`4
OF;)
^j;*T
KD|(,
$"X]
MijF
W]i}
"\[ak
-vZl
EeJQ
X7UE)
U2dR
~kX.
NMPAX
!aj=
WE-w
z2hK
R)0Q
H&ZT
!-*G
T(9W
((Uk
;D;?
)g]7
&5]OW
dN`L)S
9h$K
$sKd
5j?`r
hpmR.
C)Q+
T\AM
Llj~1
35VH
XH<'
d'< -
 /L~*.0_
*4-"g
qfq!
[+ w#
$E7&C
&(tE71@@
&xTe
0V3o\Fg2
eMuS
owi!
.WvS"\?
0@`C
45#<
OLbO
S"\/H
 0U-Z!z
]G05<
,@`3
5an,
[KhT
nu\F
_Al5
XmFW
2UA;EAn
GA@Ok
2 %b
IJ|%
+GpW"
Xo}!
*QF	
|x]u
RVSJ
fW)sSXOk
rXnA
CDUj
Yszg
#iUU(A
st1 
@**m"
hE$@-
r4-a._
W#?4o
J\mF>l
A0R`
'RF6
4|.B
jaW_	2
*up9
zGa	
\)@@7
l=9oU
bk.?,Dp
d_qW
w]Q8#
"'9m-
P)1kny
Y)CV
L*IN
$Sf3M
Pe49N
z ys
(}.Y
|FuS
Q[	>#
G$^Gj"
/	uRD
Y-CV
G8 8,
[%W*
m"g]a
	 3S'
jm ^x(
W1fU
(k]+
BnEU(
)Y+`X
|3Xi
SgaD
bPmW
!ZB9
s--Y
^byhk
4hb%
ULCk0T
QisA
J[dbl
n&a@
 fV}
1}.1
OS%(
YI0i
L}LN
+|FM
jb0T,
opV,7	!
Y7`V
t`>p&
7	:(
Fa.p
Eo=m
);TI
d\7t
`	1d
&ysx
<J)u
vTN_
76U&
M!6W
]/|2bj
pSr\
)]K:
mc(Ql"
kH:M2e
\rEn
:cVv
'4ey
1dJ)
34$!
Pg#p
IQ$R
Bkh	u
 *2U
&ujS
g(X 
(9RQ
T1*b
NrIc
M	v;9J
S<l-
_aK-
MlXp&L63
#XK$*#
yf3w
u<m=
 vm<o
7D#d
tnhm
>y?'I
$iQI\
i~;w
\N!2#
`6qH)
K<C:
Tn&b&
?pZQ!
/)gE
wz,b
&5im
;%AVx
xDP?Y(w
::I0
-kgq
n?+fj
gKrh
C`=Z
":Sg
^E|y"
1<yn
S	~Z
`JQ~j5
E__8g
yqb-
 ^`7
C`N`'
s])0
M]i7
_na%
-*lkp
gj*/
%Z N
O/$C
|7BZ=)
+VH>J
&v/3
gUm)V
3znxa
~;%o
-ysN
vlH>
r@j}
Q 	g
i^ja6
tBka<y
N^Ex|#A
} Jk
2qzU
!@OGzZ=
7e8P
U2^9
d>te
-\0o
W<4M
q0m-
?p#q
^jFl
Q7rT
+AC,J
vY=Z
:2<q
E|]t
n:CK
p	p0
Qv	pg!Rrd
fhXe
=	v'
u w$
tXw[
_B#}
ytIo
&||yb
%@,G
5~R[
	~wi
yM8dlM
FU6)
}nZo
tj;e
mC|j
dsz)
v+N.
@VS8
msMx
|g|{
/'1J
XY8#
pFM4
g<xI
UBix
ig1E7
snq$
^`V=
8,)c
VKpu
1%[:
 0}LI
fylt
1%W1
14Jt
	NJp 
JZFq-
8|w{
N&10
NSuZFq-
!0DE>
*G+0B
ua#S
h28)
Ag|_+u
w)v"
~|0N
Iq:v6
ldVo{G
kTm&
NwP:G
#B+:
FtsUg
Aw]:
L'2C
g$89A
de{f*|ad
y[,Z8
{'9U
/DLnD
~9Nu
vXk\ 
,4L.
((tF
MMTj
cN;t=
nU8+?
^j2G
U(:+
&Jq=
MtW74
{2yg
2CNq
R35v`
fz`k
	<]u
6x`k
v`k$
uboE
VUx`
s}	d<
U]>Q
~=ud
?>X9
K+1r`
Q5jV
!U'f
,jNa
ZWGh
W+jNa
n.k+
P8^&)O
2Ii`&9
IzZ=
uw&v
aB%9!
a[ZV
$9sL
)	NNpR
	NLpB
.0al~
Z,1yl~
\gclV
34lU
r[/xy
O:(r
5wF?
xp(G
8_%et
FM,j
E{13
CDH:
J} oDV)
t%RI!
 Pc[
BlZ=Z
.[<w
]:o3ck
`f0r
,f '
Y/Ud)
-IqY5En
^`z[_;|s
Rxr%
?^Mh
vR'F
BP}T
Xf,gA
R5zi
Rx~%
75HX
# }"x
]9kh
@`nRE
il)z
9Dv=
gdj{
~@>2\
^KaU
jLg8
@-SD
Z""4J
Ndt_
v@[t
|d[t
EW-R
hQnz
g)"[
6>G1
BUd>
U"6h(
j`+"
X{uu
;XXN
Uk)&X
("%n
#pfB
P2:Qg:
r8ju&d02b-
vt<#H
N"U!z
71ZH
V8^<
a"%	*
8WhL
 PtD
`t]X
:UsS
O-5eS
+cn?
*c(Dc
-(oH
!0SM
oao{
X-L~x
4=[]
iq#9@s
-N79c[
c-e5
4fl"
"`d,Fb
q%w/>.
mvs_
hce0
VWmb
79b\$
PPY`
P92u
C.Q51
q9o/
j}k:
2<kM
e*i0
bH]P
	'l$
D4X;<)
\}5<9
wL8C
\'"R
^7<MY>
v!t9
YS]8
vlQ8
 ! @:^
O'O"4
^` _
>?XM
g%8=
}	v'
[&*`
Wqeb
%D-m
OIN-
qb6^
g(lVl
Qzgs(Z
e9#v
uOKu
L0O0
4$4`
7mMA
]	o&
/nzYv'
'">S3
kD)$9
)1/:
)Az?8/
n{~p^0
>}*(
;c"tq
C`V&
NB:cC
C`vFS=
2nvUX
"qzU
	5ia
bd-N
3r8[
J`_Zr
0]+}pZ
Q3O;
=}wM
 #/*
W5>?
t^d+
;Was
4dwd
~wp,
5C2~
#s	N;
Z"s8~
>p60
wufx
+CoO
{kxeB
_+"n
E[cRf
>4,s!i7
\wYb
y5<7
-Y:o
ol44g
librustc_driver-5530d44fdcaa93ab.so-1.25.0-1.fc28.x86_64.debug
7zXZ
ki!!gU
<oYy
_Tiq
O__>M
o49g
";Tt
*ka6
h6jVc
0WfA3
cg#d
Bp_6$
n,wMBQ
Gf	b\
m:'i
~sA#KJ
|1=@
mlet
%9khq
2G5}r
Zi)SdOr
Ei|_F
IU2C/
q,|C
~rK44
]=x0
[:1W
m?Ma}Q)
hOQw
R3F2n
*Z	k2{
u+PVa
5Q[_
xw+v
R5&je
Kh}zh
 $ww
w4\20(8'@
q<dn
1SAx
aEi]
aOu 
$3j238%%
zF |UR
ipa)
G	 j v
RVZGU+
L0=a
HnUFyz
|\Se 
0*5p
q9xB]P
;K_<s
R<8z>d
>0:g
%s@5
%$yg
Mfw7|
?} E
"R^NV
 Gl^
kOXX
?607
^)g/
VNMQ
*uPrQ
VSab
Q@#/
*SJ-c
31OY
@O\9\R
l"tEh
jhoW
gQR=
?=	wh&
isP5W
khB.
qv;q6
 #WUa
O,j<7{
2P7J
L`fm
&:$U
p BbjN
)n'%
fF45
{4bq
/Ah5
ffIM
e(r$!
!o\!
d.)\)
4B5:
D69j-
+c2T
kew)
%3Tk
H)mh
-/n}|?rW
Zv{6
u	Dv
glgH
g"8y
I(|E
IG=t[u
A J3
Q}h8
G"u;
Dw@)x
clUj
3O	r
$7xQ
ER57jN
:e8_;	;q
\NL5
r+_4B
'"O`
Z"G<gO
!nPw
%!}&
 .Hz
`al^
;%,;D
Hc _7
5?@}
+n _
)+5^
Oau0	
Z@n/W
JR*O
Mu.K
R($*
).XS
8KZq
l[#_s
[zlq
{UYx
MJ4#m
gE^)Du*
?5j]
@h[S
iG%b
}4GY
A';\G
CJ8;
y-}L
la?#M
@p[7^
rsPf
_y7U
&X	$
pstb
osDH
@~V!~
n?q9
j5{"FE)F
:.Qs
wgAs
d*?\
	Apd
N8pO
KW;3D
S'4w
,{|wa
/LG4%
t!+1AL$qa
ZZfX
wyFh
2R{ru
p0[T
dJb.
mrU-C
~D0>:m
7.sgp
pq^aK
,Mh@I
nbVe
+BT`
KRovCs
=\j7
&#O`3V
|u"5
Pz+T(!
o%;OB7
y at
+9\N
&mvy
jttB6J
O8WE
6s"e
(gs,
`4:w
lQ18
UM;,
[8t~
Q>#Y
%0S=
!FRl
^G|&
H$`;
S#-a.
{.F$
kz(V
yysOsz
S{p]<
qME>
>]T1
@t1l
OIx(W5
,}Sxh
OV8-z
:s3E
=834k
NvSp
)CC(3B
>|Z'
R\[\
hp%)W
CA;3K
Na{=m
3Mru0V(
j@^kg
DnqS
WqoX`
`0c\
<P=4"JrCA
cq*kSok,
b0a4k
E}#^
2A,1
!]A?
ufq0|
4O?4
FH2tN\K]
WJ[!
	q5?
H$K@#
[9ur
p_5A#m
R29=n
6/+j
aZm<
~W5+K
YOiq0
M1oE:
3fm5
?2yf
<taK
w:SF
w+l5+T
18I"
&	u@h
netTT
)&a|
G1>!
ph>e
/,04
i/AH
T0nD
t%Rt
\O|-
<}b\
ZjPe
7Qmh
a?;,tw
uHG}\
'/$WD
z%pF(
C69M
a0,q
0c^;Q*t
{waB
yDSD
yOwYa;Wnc:
EhJQ
-2d2
8(~1|1x
`? l=z
blAD
(Ra!_N0
6c 4
B*\W
bo}B
RUeK
%%N*
D#<A
%$	h
nmUA7
OC/u65d
		}U+
/LkO>["q
]#C$
/}k/X\%
+PW^
z6]G
Cl1=[
[PzM
#<0}dT
ccN=6
[HSu
*kaW8
"6rq
<vL&
U!Nv
wDgT
pl(nk-
[bjR
S2TU
;aE$
aKA2
mOh'H
zrj`
m_Fd
@rb509
}5	E
6}`A
Y+N*`-
"t`6
:Fu|
Rj!L
aB)Ir,
}bOR
p	UXS
?|7!
nM"-
C2"5FBY
>@~A
|L|y
MMU=U
B58S
JybV
K8_1U
:-_*
'Yr=
%;"A
E8Z{
(K}\
[sl;
HFeb
: /;
U&f<
;4P`
	SC"
cnS=
o|Aiy
x6nq
#64-
3c-d
FDu>[
XX@!-
2pFn
$[( 
K}@7
*Z]a
qe8m
VnK+,O
5`_(
5#ao
WX\5w
VF?e
Tbhe
j`8%
:%>)
j%&P
725Jf
ZIcGv/(
SeWtf
$Pi.
Zk[Tk*
e'#ngj
S=0Y
qy1wd
#baus#[=K
:F'L}
1rc)1
H,Nm
d7$c"
ze_9
6>qn
B?[8r
OeY`QiU
9AYX
Tq@&+
aoc<
/!=*|
@oa1M
;F[M
(y#!L
SvjuIQ
_}A|
}lEqG
?!f+
1wDQ6
|=e	
NH"B
sk4L
d%2;
z.,0
OP#W_~]
ScDo
qU%3X{
j($1e
]@p}
MPn'@
7q-)
^K`'
7f]h
Y g@
Jq%B
3TSR
4,@#OF3
7t)o
Tc2;
p=E<
K/Ij
j6g--
7c8TU
Kp|,
P$un
)Ar\_2=
U:+nZ
(\cy 
'-:4Q
fLv,
kpN>
Fh=BE
(h2-hc
<d<.hb
J'r5
;-s@
ig\N
TtT`
-m/-
msfI
't^t
39Z-.
q4qh
vD"O
4*w;$
{jO[
Eci*
|cuR
,kD&
3p:{
 Z f
hm7V(
D<t^
gB5~
A{EC
SX!#'
`YMt
:0pCkUq
.shstrtab
.note.gnu.build-id
.gnu.hash
.dynsym
.dynstr
.gnu.version
.gnu.version_r
.rela.dyn
.rela.plt
.init
.text
.fini
.rodata
.eh_frame_hdr
.eh_frame
.gcc_except_table
.init_array
.fini_array
.data.rel.ro
.dynamic
.got
.data
.bss
.rustc
.gnu_debuglink
.gnu_debugdata
