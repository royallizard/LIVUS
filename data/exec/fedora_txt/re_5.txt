 P8,
__gmon_start__
_init
_fini
__cxa_finalize
_Jv_RegisterClasses
PL_utf8skip
Perl_croak_nocontext
Perl_get_sv
Perl_PerlIO_stderr
PerlIO_printf
Perl_sv_setuv
Perl_sv_2iv_flags
Perl_pv_pretty
Perl_safesysfree
Perl_reginitcolors
PL_fold_locale
Perl_regclass_swash
Perl_swash_fetch
Perl_av_len
Perl_av_fetch
Perl_sv_2pv_flags
Perl_ckwarn
Perl_utf8n_to_uvuni
Perl_croak
PL_fold
__ctype_b_loc
Perl_to_utf8_fold
Perl_sv_newmortal
my_regprop
Perl_utf8_to_uvchr
Perl_is_uni_space_lc
Perl_is_uni_alnum_lc
Perl_push_scope
Perl_save_re_context
Perl_is_utf8_alnum
Perl_pop_scope
Perl_is_utf8_digit
Perl_is_utf8_space
PL_thr_key
pthread_getspecific
Perl_deb
Perl_newSVsv
Perl_sv_utf8_upgrade_flags
Perl_fbm_compile
Perl_sv_utf8_downgrade
Perl_sv_free2
Perl_sv_free
Perl_safesyscalloc
PL_memory_wrap
Perl_savestack_grow_cnt
Perl_save_int
Perl_save_sptr
Perl_mg_find
Perl_save_destructor_x
Perl_sv_setiv
Perl_safesysrealloc
Perl_save_vptr
PL_reg_name
Perl_savestack_grow
Perl_regnext
PL_regkind
Perl_safesysmalloc
Perl_gv_SVadd
Perl_to_utf8_lower
Perl_ibcmp_locale
Perl_leave_scope
Perl_pregfree
Perl_sv_setsv_flags
Perl_to_uni_fold
Perl_ibcmp_utf8
memset
Perl_sv_eq
Perl_sv_grow
Perl_hv_common_key_len
Perl_newSV
Perl_sv_2mortal
Perl_is_uni_alnum
Perl_warner
Perl_free_tmps
Perl_save_scalar
Perl_is_uni_digit_lc
Perl_pregcomp
Perl_sv_magic
Perl_newSViv
Perl_av_push
PL_vtbl_mglob
Perl_sv_magicext
Perl_sv_unmagic
Perl_is_utf8_mark
Perl_sv_2bool
Perl_ibcmp
Perl_reg_temp_copy
Perl_to_utf8_upper
Perl_uvuni_to_utf8_flags
my_re_intuit_start
Perl_fbm_instr
Perl_utf8_distance
Perl_screaminstr
Perl_sv_len_utf8
my_regexec
Perl_hv_iterinit
Perl_savepvn
Perl_rninstr
my_reg_numbered_buff_store
PL_no_modify
my_regdupe
memcpy
Perl_op_refcnt_lock
Perl_op_refcnt_unlock
Perl_sv_dup
my_regfree
Perl_op_free
my_re_intuit_string
strlen
Perl_sv_catpvn_flags
Perl_sv_catpvf
Perl_sv_setpvn
Perl_sv_catpv
Perl_savesvpv
PerlIO_putc
my_regdump
PL_reg_extflags_name
my_reg_qr_package
Perl_newSVpvn
my_reg_numbered_buff_length
Perl_is_utf8_string_loclen
Perl_report_uninit
my_reg_numbered_buff_fetch
Perl_is_utf8_string
Perl_sv_untaint
my_reg_named_buff_firstkey
my_reg_named_buff_nextkey
Perl_hv_iternext_flags
my_reg_named_buff_iter
my_reg_named_buff_all
Perl_newAV
Perl_newRV
my_reg_named_buff_scalar
my_reg_named_buff_exists
Perl_hv_common
my_reg_named_buff_fetch
my_reg_named_buff
Perl_warn_nocontext
Perl_is_utf8_idcont
__memcpy_chk
Perl_vmess
strchr
Perl_grok_hex
Perl_call_sv
Perl_newHV
Perl_stack_grow
Perl_markstack_grow
Perl_sv_recode_to_utf8
Perl_mg_set
Perl_av_store
Perl_newRV_noinc
Perl_grok_oct
strtol
Perl_sv_compile_2op
Perl_sv_backoff
Perl_sv_upgrade
Perl_sv_chop
PL_simple
Perl_save_freepv
memmove
PL_varies
Perl_ninstr
Perl_utf8_length
Perl_repeatcpy
Perl_sv_catsv_flags
Perl_utf8_hop
my_re_compile
Perl_bytes_to_utf8
my_reg_engine
boot_re
Perl_Istack_sp_ptr
Perl_Imarkstack_ptr_ptr
Perl_Istack_base_ptr
Perl_newSVpv
Perl_new_version
Perl_sv_derived_from
Perl_vcmp
XS_re_install
Perl_newXS
XS_re_regexp_pattern
Perl_newXS_flags
XS_re_regmust
Perl_Iunitcheckav_ptr
Perl_Iscopestack_ix_ptr
Perl_call_list
Perl_Isv_yes_ptr
Perl_form
Perl_vstringify
Perl_get_re_arg
Perl_Isv_no_ptr
Perl_Istack_max_ptr
Perl_Isv_undef_ptr
Perl_Iop_ptr
Perl_block_gimme
Perl_Icolorset_ptr
libc.so.6
__stack_chk_fail
_edata
__bss_start
_end
GLIBC_2.1.3
GLIBC_2.4
GLIBC_2.3
GLIBC_2.3.4
GLIBC_2.0
|^t-9
[^_]
[^_]
[^_]
[^_]
l[^_]
|	9}
|[^_]
\[^_]
|[^_]
<[^_]
<[^_]
0<	w
0<	v
<	tt< tp<
~	9}
? tJ
L[^_]
9G$~
9G$~
9F$~
9G$~
9F$~
9F$~
9F$~
9A$~
F,;F(
F 9G$~
9A$~
F0;F4
A0;A4
B$;B(
't.f
G$;A
;G$}
[^_]
't.f
G$;A
@$;A
A$;G
f;D:
A0;A4~
<Nv&
[^_]
< tZ<
< t'<
< tT<
B0;B4
A0;A4~
0<	w
0<	v
<	t7<
<	tj<
[^_]
+B(9
A0;A
A4;A 
[^_]
M +A
<!tAf
t;<=t7
0<	w
S<"v$
[^_]
L[^_]
<[^_]
<[^_]
[^_]
|(;u
tCf1
t	;}
[^_]
|[^_]
|[^_]
|[^_]
B(9E
\[^_]
\[^_]
B(9E
l[^_]
l[^_]
B(9E
9V,|
9W,|
<[^_]
 [^]
 [^]
(thf
[^_]
9F(t
[^_]
[^_]
[^_]
V(9U
<[^_]
F(+F 
<[^_]
V(9U
<[^_]
F(+F 
<[^_]
,[^_]
9F(t
[^_]
9B(t
9G(t
9A(t"
9B(t
;y(t;
G0;G4
9B(t
,[^_]
;q(t6
;q(tl
;F(t/
l[^_]
l[^_]
|[^_]
|[^_]
9F(t
;V(t"
[^_]
;P(tE
< t <
t%<]t!
;B(t(
;q(t
;r(t%
;F(t
9F(tX
;J(t
9B(t
[^_]
A4 tG
;A(t<
9B(t
9G(t
9A(t
;A(t\
;q(tA
9A(t
9F(to
;P(t;
9G(t
9B(t
;r(t(
0<	w
0<	v
9A(t(
9F(t
9B(t(
;P(u
9J(t
;J(t
;q(t(
9B(t	
9A(t
;P(t3
;q(t3
9A(t
9G(t
9B(t
;q(t
9G(t
9A(t
9A(t
0<	v
;G(t"
9B(t
9B(t
9G(t"
9B(t
9B(t
;F(t
;y(t(
B@<=w
<#u.
[^_]
;J(tB
9J(t4
;J(t
9B(t
9p(t
;A(t_
;P(t
tw;}
9~(t
;W(t"
;~(t"
;A(t9
9A(t(
9w(tj
9A(t
;G(t
B<+E
9N(t
;A(ta
;P(t3
9B(t
9G(t"
9F(t
9B(t
9J(t
9F(t
9B(t
9G(t
9B(t
<|tY<)tU
L[^_]
9p(t
;r(t=
9P(t
;A(t7
;A(t
;P(ti
[^_]
f;q$
f;q$r
N$f9
;x(ti
;y(t
;y(t
[^_]
@`+W
9A(t(
9A(t(
9A(t(
<=u-
[^_]
l[^_]
,[^_]
,[^_]
<[^_]
[^_]
((svtype)((_svi)->sv_flags & 0xff)) >= SVt_PV
Assertion %s failed: file "re_exec.c", line %d
((svtype)((_svi)->sv_flags & 0xff)) != SVt_PVAV
((svtype)((_svi)->sv_flags & 0xff)) != SVt_PVHV
!((((_svi)->sv_flags & (0x00004000|0x00008000)) == 0x00008000) && (((svtype)((_svi)->sv_flags & 0xff)) == SVt_PVGV || ((svtype)((_svi)->sv_flags & 0xff)) == SVt_PVLV))
((svtype)((_svi)->sv_flags & 0xff)) == SVt_IV || ((svtype)((_svi)->sv_flags & 0xff)) >= SVt_PVIV
((svtype)((_svi)->sv_flags & 0xff)) != SVt_PVCV
     restoring \%lu to %ld(%ld)..%ld%s
     restoring \%ld..\%ld to undef
Malformed UTF-8 character (fatal)
%*s  %s can match %ld times out of %ld...
!((((thwacke)->sv_flags & (0x00004000|0x00008000)) == 0x00008000) && (((svtype)((thwacke)->sv_flags & 0xff)) == SVt_PVGV || ((svtype)((thwacke)->sv_flags & 0xff)) == SVt_PVLV))
((svtype)((uggh)->sv_flags & 0xff)) == SVt_PVGV
((svtype)((sv)->sv_flags & 0xff)) >= SVt_PV
((svtype)((sv)->sv_flags & 0xff)) != SVt_PVAV
((svtype)((sv)->sv_flags & 0xff)) != SVt_PVHV
!((((sv)->sv_flags & (0x00004000|0x00008000)) == 0x00008000) && (((svtype)((sv)->sv_flags & 0xff)) == SVt_PVGV || ((svtype)((sv)->sv_flags & 0xff)) == SVt_PVLV))
panic: paren_elems_to_push < 0
     saving \%lu %ld(%ld)..%ld
  setting stack tmpbase at %ld
((svtype)((shplep)->sv_flags & 0xff)) == SVt_PVGV || ((svtype)((shplep)->sv_flags & 0xff)) == SVt_PVLV
((((shplep)->sv_flags & (0x00004000|0x00008000)) == 0x00008000) && (((svtype)((shplep)->sv_flags & 0xff)) == SVt_PVGV || ((svtype)((shplep)->sv_flags & 0xff)) == SVt_PVLV))
!(((_svi)->sv_flags & (0x40000000|0x00040000)) == (0x40000000|0x00040000))
  Setting an EVAL scope, savestack=%ld
%*s  %sfailed to match trie start class...%s
%*s  %smatched empty string...%s
((svtype)((sv_accept_buff)->sv_flags & 0xff)) >= SVt_PV
((svtype)((sv_accept_buff)->sv_flags & 0xff)) != SVt_PVAV
((svtype)((sv_accept_buff)->sv_flags & 0xff)) != SVt_PVHV
!((((sv_accept_buff)->sv_flags & (0x00004000|0x00008000)) == 0x00008000) && (((svtype)((sv_accept_buff)->sv_flags & 0xff)) == SVt_PVGV || ((svtype)((sv_accept_buff)->sv_flags & 0xff)) == SVt_PVLV))
((svtype)((_svi)->sv_flags & 0xff)) >= SVt_RV
((svtype)((_svi)->sv_flags & 0xff)) != SVt_PVFM
!((sv_accept_buff)->sv_flags & 0x00000800) || !(*({ SV *const _svi = (SV *) (sv_accept_buff); ((((svtype)((_svi)->sv_flags & 0xff)) >= SVt_RV) ? ((void) 0) : (Perl_croak_nocontext("Assertion %s failed: file \"" "re_exec.c" "\", line %d", "((svtype)((_svi)->sv_flags & 0xff)) >= SVt_RV", 2980), (void) 0)); ((((svtype)((_svi)->sv_flags & 0xff)) != SVt_PVAV) ? ((void) 0) : (Perl_croak_nocontext("Assertion %s failed: file \"" "re_exec.c" "\", line %d", "((svtype)((_svi)->sv_flags & 0xff)) != SVt_PVAV", 2980), (void) 0)); ((((svtype)((_svi)->sv_flags & 0xff)) != SVt_PVHV) ? ((void) 0) : (Perl_croak_nocontext("Assertion %s failed: file \"" "re_exec.c" "\", line %d", "((svtype)((_svi)->sv_flags & 0xff)) != SVt_PVHV", 2980), (void) 0)); ((((svtype)((_svi)->sv_flags & 0xff)) != SVt_PVCV) ? ((void) 0) : (Perl_croak_nocontext("Assertion %s failed: file \"" "re_exec.c" "\", line %d", "((svtype)((_svi)->sv_flags & 0xff)) != SVt_PVCV", 2980), (void) 0)); ((((svtype)((_svi)->sv_flags & 0xff)) != SVt_PVFM) ? ((void) 0) : (Perl_croak_nocontext("Assertion %s failed: file \"" "re_exec.c" "\", line %d", "((svtype)((_svi)->sv_flags & 0xff)) != SVt_PVFM", 2980), (void) 0)); ((!((((_svi)->sv_flags & (0x00004000|0x00008000)) == 0x00008000) && (((svtype)((_svi)->sv_flags & 0xff)) == SVt_PVGV || ((svtype)((_svi)->sv_flags & 0xff)) == SVt_PVLV))) ? ((void) 0) : (Perl_croak_nocontext("Assertion %s failed: file \"" "re_exec.c" "\", line %d", "!((((_svi)->sv_flags & (0x00004000|0x00008000)) == 0x00008000) && (((svtype)((_svi)->sv_flags & 0xff)) == SVt_PVGV || ((svtype)((_svi)->sv_flags & 0xff)) == SVt_PVLV))", 2980), (void) 0)); &((_svi)->sv_u.svu_rv); }))
%*s  %sState: %4lx Accepted: %4lx 
Charid:%3x CP:%4lx After State: %4lx%s
%*s  %sgot %ld possible matches%s
  Clearing an EVAL scope, savestack=%ld..%ld
%*s  %sonly one match left: #%d <%s>%s
%*s  %sgot %ld (%d) as best, looking at %ld (%d)%s
%*s  %strying alternation #%d <%s> at node #%d %s
Pattern subroutine nesting without pos change exceeded limit in regex
EVAL without pos change exceeded limit in regex
Pad 0x%lx[0x%lx] restore_local
((svtype)((_svi)->sv_flags & 0xff)) == SVt_NV || ((svtype)((_svi)->sv_flags & 0xff)) >= SVt_PVNV
%*s  whilem: matched %ld out of %ld..%ld
%*s  whilem: empty match detected, trying continuation...
%swhilem: Detected a super-linear match, switching on caching%s...
%*s  whilem: (cache) already tried at this position...
%*s  whilem: failed, trying continuation...
Complex regular subexpression recursion
%*s  CURLYM now matched %ld times, len=%ld...
%*s  CURLYM trying tail with matches=%ld...
%*s  CURLYM Fast bail c1=%ld c2=%ld
%*s  EVAL trying tail ... %lx
%sMatch possible, but length=%ld is smaller than requested=%ld, failing!%s
%*s  %ssubpattern success...%s
%*s  %ssetting cutpoint to mark:%-p...%s
    %*spop (no final) %s%s%s%s%s
((svtype)((sv_points)->sv_flags & 0xff)) >= SVt_PV
((svtype)((sv_points)->sv_flags & 0xff)) != SVt_PVAV
((svtype)((sv_points)->sv_flags & 0xff)) != SVt_PVHV
!((((sv_points)->sv_flags & (0x00004000|0x00008000)) == 0x00008000) && (((svtype)((sv_points)->sv_flags & 0xff)) == SVt_PVGV || ((svtype)((sv_points)->sv_flags & 0xff)) == SVt_PVLV))
!((sv_points)->sv_flags & 0x00000800) || !(*({ SV *const _svi = (SV *) (sv_points); ((((svtype)((_svi)->sv_flags & 0xff)) >= SVt_RV) ? ((void) 0) : (Perl_croak_nocontext("Assertion %s failed: file \"" "re_exec.c" "\", line %d", "((svtype)((_svi)->sv_flags & 0xff)) >= SVt_RV", 1538), (void) 0)); ((((svtype)((_svi)->sv_flags & 0xff)) != SVt_PVAV) ? ((void) 0) : (Perl_croak_nocontext("Assertion %s failed: file \"" "re_exec.c" "\", line %d", "((svtype)((_svi)->sv_flags & 0xff)) != SVt_PVAV", 1538), (void) 0)); ((((svtype)((_svi)->sv_flags & 0xff)) != SVt_PVHV) ? ((void) 0) : (Perl_croak_nocontext("Assertion %s failed: file \"" "re_exec.c" "\", line %d", "((svtype)((_svi)->sv_flags & 0xff)) != SVt_PVHV", 1538), (void) 0)); ((((svtype)((_svi)->sv_flags & 0xff)) != SVt_PVCV) ? ((void) 0) : (Perl_croak_nocontext("Assertion %s failed: file \"" "re_exec.c" "\", line %d", "((svtype)((_svi)->sv_flags & 0xff)) != SVt_PVCV", 1538), (void) 0)); ((((svtype)((_svi)->sv_flags & 0xff)) != SVt_PVFM) ? ((void) 0) : (Perl_croak_nocontext("Assertion %s failed: file \"" "re_exec.c" "\", line %d", "((svtype)((_svi)->sv_flags & 0xff)) != SVt_PVFM", 1538), (void) 0)); ((!((((_svi)->sv_flags & (0x00004000|0x00008000)) == 0x00008000) && (((svtype)((_svi)->sv_flags & 0xff)) == SVt_PVGV || ((svtype)((_svi)->sv_flags & 0xff)) == SVt_PVLV))) ? ((void) 0) : (Perl_croak_nocontext("Assertion %s failed: file \"" "re_exec.c" "\", line %d", "!((((_svi)->sv_flags & (0x00004000|0x00008000)) == 0x00008000) && (((svtype)((_svi)->sv_flags & 0xff)) == SVt_PVGV || ((svtype)((_svi)->sv_flags & 0xff)) == SVt_PVLV))", 1538), (void) 0)); &((_svi)->sv_u.svu_rv); }))
 Scanning for legal start char...
Matches word #%lx at position %ld. Trying full pattern...
Pattern failed. Looking for new start point...
Guessing start of match in string for
Guessing start of match in sv for
String too short... [re_intuit_start]
Non-utf8 string cannot match utf8 check string
Check offset min: %ld Start shift: %ld End shift %ld Real End Shift: %ld
({ SV *const thwacke = (SV *) (uggh); if ((thwacke)->sv_flags & 0x40000000) ((!((((thwacke)->sv_flags & (0x00004000|0x00008000)) == 0x00008000) && (((svtype)((thwacke)->sv_flags & 0xff)) == SVt_PVGV || ((svtype)((thwacke)->sv_flags & 0xff)) == SVt_PVLV))) ? ((void) 0) : (Perl_croak_nocontext("Assertion %s failed: file \"" "re_exec.c" "\", line %d", "!((((thwacke)->sv_flags & (0x00004000|0x00008000)) == 0x00008000) && (((svtype)((thwacke)->sv_flags & 0xff)) == SVt_PVGV || ((svtype)((thwacke)->sv_flags & 0xff)) == SVt_PVLV))", 530), (void) 0)); ((thwacke)->sv_flags & 0x40000000); })
, trying floating at offset %ld...
, trying anchored starting at offset %ld...
Check offset min:%ld max:%ld S:%ld t:%ld D:%ld end:%ld
Found /%s^%s/m at offset %ld, rescanning for anchored from offset %ld...
Found /%s^%s/m at offset %ld...
Found /%s^%s/m, restarting lookup for check-string at offset %ld...
Starting position does not contradict /%s^%s/m...
({ SV *const thwacke = (SV *) (uggh); if ((thwacke)->sv_flags & 0x40000000) ((!((((thwacke)->sv_flags & (0x00004000|0x00008000)) == 0x00008000) && (((svtype)((thwacke)->sv_flags & 0xff)) == SVt_PVGV || ((svtype)((thwacke)->sv_flags & 0xff)) == SVt_PVLV))) ? ((void) 0) : (Perl_croak_nocontext("Assertion %s failed: file \"" "re_exec.c" "\", line %d", "!((((thwacke)->sv_flags & (0x00004000|0x00008000)) == 0x00008000) && (((svtype)((thwacke)->sv_flags & 0xff)) == SVt_PVGV || ((svtype)((thwacke)->sv_flags & 0xff)) == SVt_PVLV))", 820), (void) 0)); ((thwacke)->sv_flags & 0x40000000); })
!((uggh)->sv_flags & 0x00000100)
Position at offset %ld does not contradict /%s^%s/m...
({ SV *const thwacke = (SV *) (uggh); if ((thwacke)->sv_flags & 0x40000000) ((!((((thwacke)->sv_flags & (0x00004000|0x00008000)) == 0x00008000) && (((svtype)((thwacke)->sv_flags & 0xff)) == SVt_PVGV || ((svtype)((thwacke)->sv_flags & 0xff)) == SVt_PVLV))) ? ((void) 0) : (Perl_croak_nocontext("Assertion %s failed: file \"" "re_exec.c" "\", line %d", "!((((thwacke)->sv_flags & (0x00004000|0x00008000)) == 0x00008000) && (((svtype)((thwacke)->sv_flags & 0xff)) == SVt_PVGV || ((svtype)((thwacke)->sv_flags & 0xff)) == SVt_PVLV))", 846), (void) 0)); ((thwacke)->sv_flags & 0x40000000); })
({ SV *const thwacke = (SV *) (uggh); if ((thwacke)->sv_flags & 0x40000000) ((!((((thwacke)->sv_flags & (0x00004000|0x00008000)) == 0x00008000) && (((svtype)((thwacke)->sv_flags & 0xff)) == SVt_PVGV || ((svtype)((thwacke)->sv_flags & 0xff)) == SVt_PVLV))) ? ((void) 0) : (Perl_croak_nocontext("Assertion %s failed: file \"" "re_exec.c" "\", line %d", "!((((thwacke)->sv_flags & (0x00004000|0x00008000)) == 0x00008000) && (((svtype)((thwacke)->sv_flags & 0xff)) == SVt_PVGV || ((svtype)((thwacke)->sv_flags & 0xff)) == SVt_PVLV))", 850), (void) 0)); ((thwacke)->sv_flags & 0x40000000); })
... Disabling check substring...
start_shift: %ld check_at: %ld s: %ld endpos: %ld
This position contradicts STCLASS...
Looking for %s substr starting at offset %ld...
Looking for anchored substr starting at offset %ld...
Looking for /%s^%s/m starting at offset %ld...
By STCLASS: moving %ld --> %ld
Does not contradict STCLASS...
({ SV *const thwacke = (SV *) (uggh); if ((thwacke)->sv_flags & 0x40000000) ((!((((thwacke)->sv_flags & (0x00004000|0x00008000)) == 0x00008000) && (((svtype)((thwacke)->sv_flags & 0xff)) == SVt_PVGV || ((svtype)((thwacke)->sv_flags & 0xff)) == SVt_PVLV))) ? ((void) 0) : (Perl_croak_nocontext("Assertion %s failed: file \"" "re_exec.c" "\", line %d", "!((((thwacke)->sv_flags & (0x00004000|0x00008000)) == 0x00008000) && (((svtype)((thwacke)->sv_flags & 0xff)) == SVt_PVGV || ((svtype)((thwacke)->sv_flags & 0xff)) == SVt_PVLV))", 985), (void) 0)); ((thwacke)->sv_flags & 0x40000000); })
%sMatch rejected by optimizer%s
String too short [regexec_flags]...
Did not find anchored character...
Did not find %s substr %s%s...
Matching stclass %.*s against %s (%d chars)
Contradicts stclass... [regexec_flags]
%sCan't trim the tail, match fails (should not happen)%s
E_DEBUG_FLAGS
i == 21
(no)
%4ld <%.*s%.*s%s%.*s>%*s|
%s%s REx%s %s against %s
 and 
string
UTF-8 %s%s%s...
re_exec.c
ENTER
%s scope %ld at %s:%d
LEAVE
regmatch start
%3ld:%*s%s(%ld)
not compiled under -Dr
%*s  %sTRIE failed...%s
Infinite recursion in regex
  re_eval 0x%lx
Pad 0x%lx[0x%lx] save_local
REGMARK
Matching embedded
next
cur_curlyx
%s limit (%d) exceeded
%*s  trying longer...
%*s  %sBRANCH failed...%s
%lx %d
regexp memory corruption
%*s#%-3d %-10s %s
    %*spush %s%s%s%s%s
corrupted regexp pointers
st != yes_state
    %*spop (yes) %s%s%s%s%s
%sMatch successful!%s
%*s  %sfailed...%s
    %*spop %s%s%s%s%s
REGERROR
 Charid:%3u CP:%4lx 
 Fail transition to 
%sState: %4lx, word=%lx
 - legal
 - fail
 - accepting
No match.
panic: unknown regstclass %d
Not at start...
String too long...
String not equal...
fbm_instr len=%d str=<%.*s>
 at offset 
Did not find
Found
%s %s substr %s%s%s
Contradicts
%s anchored substr %s%s
, giving up...
 at offset %ld...
%s floating substr %s%s
Did not find /%s^%s/m...
Could not match STCLASS...
Giving up
Guessed
%s%s:%s match at offset %ld
NULL regexp parameter
Matching
corrupted regexp program
Not present...
%sMatch failed%s
Aand_with->type == 17
%sFreeing REx:%s %s
panic: pregfree comppad
panic: regfree data code '%c'
utf8 
[%d]
 {%d,%d}
[%d/%d]
 '%-p'
%s%ld
%d[%+d]
:%-p
[0x%lX]
{loc}
{unicode}
{unicode_all}
 (%ld nodes)
%4ld:%*s%s
 (0)
 (FAIL)
 (%ld)
%*s%s 
(%lu)
anchored %s%s at %ld 
anchored utf8 %s%s at %ld 
floating %s%s at %ld..%lu 
(checking floating
(checking anchored
 noscan
 isall
stclass %s 
(BOL)
(MBOL)
(SBOL)
(GPOS)
GPOS:%lu 
plus 
implicit 
minlen %ld 
with eval 
r->extflags: 
%s[none-set]
 >%.*s%-*s
%16s
|%4d
|%4s
tail
|%*s%-4s
~ %s (%d) %s %s
tsdy
~ %s (%d) -> %s
Regexp
%s in regex m/%.*s%s/
Overwriting end of array!
reganode
reg_node
Missing braces on \N{}
Missing right brace on \N{}
charnames
re_comp.c
inst
 - %s
reg_insert
reginsert
INF 
clas
# comment
*t == c
word
alph
spac
grap
asci
blan
cntr
alnu
lowe
uppe
digi
prin
punc
xdigit
POSIX class [:%.*s:] unknown
posixcc[skip] == ':'
posixcc[skip+1] == ']'
Empty \%c{}
Missing right brace on \%c{}
%cutf8::%.*s
Missing right brace on \x{}
%04lx
%04lx
Word
Alnum
Alpha
Blank
Cntrl
Graph
Lower
Print
Punct
SpacePerl
Upper
XDigit
VertSpace
HorizSpace
ASCII
Invalid [::] class
Invalid [] range "%*.*s"
%04lx	%04lx
%cutf8::Is%s
reg 
Unterminated verb pattern
ACCEPT
COMMIT
FAIL
PRUNE
SKIP
THEN
Unknown verb pattern '%.*s'
Sequence (?R) not terminated
Illegal pattern
Expecting close bracket
Recurse #%lu to %ld
Sequence (? incomplete
don't 
Useless use of (?-p)
!(pRExC_state->opend)
Unmatched (
Unmatched )
Junk on end of regexp
piec
atom
Unmatched [
Internal urp
Quantifier follows nothing
Reference to invalid group 0
Unterminated \g... pattern
Unterminated \g{...} pattern
Trailing \
Internal disaster
Can't do {n,m} with n > m
Nested quantifiers
brnc
tuuu
E_TRIE_MAXBUF
NATIVE
UTF8
%*s %4lX :
%5s| 
W%4x| 
%*s:%3X=%4lX | 
%*s| 
%*sChar : 
%*sState+-
--------
%.*s
%*s%4lX : 
%*lX
 (%4lX)
 (%4lX) W%4X
Base
Match
%*sChar : %-6s%-6s%-4s 
%*s#%4lX|
 W%4X
 @%4lX 
+%2lX[ 
   .
%*sPeep>%3d: %s (%d)
%*sjoin>%3d: %s (%d)
%*sskip:>%3d: %s (%d)
%*smerg>%3d: %s (%d)
%*sfinl>%3d: %s (%d)
!and_withp
%*s%s%s
%*s- %s (%d)
 -> %s
	=> %s	
(First==%d,Last==%d,Cur==%d)
%*s- %s (%d) <SCAN FINISHED>
start
data
Panic opt close
!frame
%sCompiling REx%s %s
Starting first pass (sizing)
Regexp out of space
msix
Couldn't get
Restudying
%*sfirst:>%3d: %s (%d)
, %lu
first at %ld
synthetic stclass "%s".
Multi Top Level
minlen: %ld r->minlen:%ld
Final program:
Offsets: [%lu]
%lu:%lu[%lu] 
[:alnum:]
[:^alnum:]
[:alpha:]
[:^alpha:]
[:ascii:]
[:^ascii:]
[:ctrl:]
[:^ctrl:]
[:graph:]
[:^graph:]
[:lower:]
[:^lower:]
[:print:]
[:^print:]
[:punct:]
[:^punct:]
[:upper:]
[:^upper:]
[:xdigit:]
[:^xdigit:]
[:space:]
[:^space:]
[:blank:]
[:^blank:]
Assertion %s failed: file "re_comp.c", line %d
panic: re_dup unknown data code '%c'
%sUsing REx %ssubstr:%s "%s%.60s%s%s"
Corrupted regexp opcode %d > %d
<S:%lu/%ld W:%lu L:%lu/%lu C:%lu/%lu>
floating utf8 %s%s at %ld..%lu 
~ attach to %s (%ld) offset to %ld
rx->sublen >= (s - rx->subbeg) + i
((svtype)((sv)->sv_flags & 0xff)) >= SVt_PVMG
((svtype)((_svi)->sv_flags & 0xff)) >= SVt_PVMG
panic: Unknown flags %d in named_buff_iter
panic: Unknown flags %d in named_buff_scalar
panic: Unknown flags %d in named_buff
Sequence (?#... not terminated
panic: reg_node overrun trying to emit %d
%s(%d): (op %s) %s %lu <- %lu (max %lu).
** (%d) offset of node %d is %d.
value of node is %d in Offset macro
%s:%d: (op %s) %s %lu (len %lu) (max %lu).
panic: no svname in reg_scan_name
Reference to nonexistent named group
%s in regex; marked by <-- HERE in m/%.*s <-- HERE %s/
panic: bad flag in reg_scan_name
Constant(\N{%s}) unknown: (possibly a missing "use charnames ...")
Constant(\N{%s}): $^H{charnames} is not defined
Constant(\N{%s}): Call to &{$^H{charnames}} did not return a defined value
Ignoring excess chars from \N{%s} in character class in regex; marked by <-- HERE in m/%.*s <-- HERE %s/
Ignoring zero length \N{%s} in character class in regex; marked by <-- HERE in m/%.*s <-- HERE %s/
** (%d) size of node %d is %d.
value of node is %d in Length macro
%s(%d): (op %s) %s copy %lu -> %lu (max %lu).
((svtype)((data->last_found)->sv_flags & 0xff)) >= SVt_PV
((svtype)((data->last_found)->sv_flags & 0xff)) != SVt_PVAV
((svtype)((data->last_found)->sv_flags & 0xff)) != SVt_PVHV
!((((data->last_found)->sv_flags & (0x00004000|0x00008000)) == 0x00008000) && (((svtype)((data->last_found)->sv_flags & 0xff)) == SVt_PVGV || ((svtype)((data->last_found)->sv_flags & 0xff)) == SVt_PVLV))
%*scommit: Pos:%ld/%ld Flags: 0x%lX Whilem_c: %ld Lcp: %ld %s
Last:'%s' %ld:%ld/%ld %sFixed:'%s' @ %ld %sFloat: '%s' @ %ld/%ld
POSIX syntax [%c %c] belongs inside character classes in regex; marked by <-- HERE in m/%.*s <-- HERE %s/
POSIX syntax [%c %c] is reserved for future extensions
Invalid escape in the specified encoding
Unrecognized escape \%c in character class passed through in regex; marked by <-- HERE in m/%.*s <-- HERE %s/
False [] range "%*.*s" in regex; marked by <-- HERE in m/%.*s <-- HERE %s/
Unterminated verb pattern argument
Verb pattern '%.*s' may not have an argument
Verb pattern '%.*s' has a mandatory argument
Sequence %.3s... not terminated
Sequence (%.*s...) not recognized
Sequence (?%c... not terminated
panic: reg_scan_name returned NULL
panic: paren_name hash element allocation failed
((svtype)((sv_dat)->sv_flags & 0xff)) >= SVt_PV
((svtype)((sv_dat)->sv_flags & 0xff)) != SVt_PVAV
((svtype)((sv_dat)->sv_flags & 0xff)) != SVt_PVHV
!((((sv_dat)->sv_flags & (0x00004000|0x00008000)) == 0x00008000) && (((svtype)((sv_dat)->sv_flags & 0xff)) == SVt_PVGV || ((svtype)((sv_dat)->sv_flags & 0xff)) == SVt_PVLV))
Sequence (?%c...) not implemented
Reference to nonexistent group
Sequence (?{...}) not terminated or not {}-balanced
Eval-group not allowed at runtime, use re 'eval'
Eval-group in insecure regular expression
Sequence (?(%c... not terminated
Switch condition not recognized
(?(DEFINE)....) does not allow branches
Switch (?(condition)... contains too many branches
Unknown switch condition (?(%.2s
Useless (%s%c) - %suse /%c modifier in regex; marked by <-- HERE in m/%.*s <-- HERE %s/
Useless (%sc) - %suse /gc modifier in regex; marked by <-- HERE in m/%.*s <-- HERE %s/
Setting open paren #%ld to %d
Setting close paren #%ld to %d
Sequence %.2s... not terminated
Reference to nonexistent or unclosed group
Unrecognized escape \%c passed through in regex; marked by <-- HERE in m/%.*s <-- HERE %s/
Quantifier in {,} bigger than %d
%.*s matches null string many times in regex; marked by <-- HERE in m/%.*s <-- HERE %s/
%*smake_trie start==%d, first==%d, last==%d, tail==%d depth=%d
((svtype)((zlopp)->sv_flags & 0xff)) >= SVt_PV
((svtype)((zlopp)->sv_flags & 0xff)) != SVt_PVAV
((svtype)((zlopp)->sv_flags & 0xff)) != SVt_PVHV
!((((zlopp)->sv_flags & (0x00004000|0x00008000)) == 0x00008000) && (((svtype)((zlopp)->sv_flags & 0xff)) == SVt_PVGV || ((svtype)((zlopp)->sv_flags & 0xff)) == SVt_PVLV))
!((zlopp)->sv_flags & 0x00000800) || !(*({ SV *const _svi = (SV *) (zlopp); ((((svtype)((_svi)->sv_flags & 0xff)) >= SVt_RV) ? ((void) 0) : (Perl_croak_nocontext("Assertion %s failed: file \"" "re_comp.c" "\", line %d", "((svtype)((_svi)->sv_flags & 0xff)) >= SVt_RV", 1410), (void) 0)); ((((svtype)((_svi)->sv_flags & 0xff)) != SVt_PVAV) ? ((void) 0) : (Perl_croak_nocontext("Assertion %s failed: file \"" "re_comp.c" "\", line %d", "((svtype)((_svi)->sv_flags & 0xff)) != SVt_PVAV", 1410), (void) 0)); ((((svtype)((_svi)->sv_flags & 0xff)) != SVt_PVHV) ? ((void) 0) : (Perl_croak_nocontext("Assertion %s failed: file \"" "re_comp.c" "\", line %d", "((svtype)((_svi)->sv_flags & 0xff)) != SVt_PVHV", 1410), (void) 0)); ((((svtype)((_svi)->sv_flags & 0xff)) != SVt_PVCV) ? ((void) 0) : (Perl_croak_nocontext("Assertion %s failed: file \"" "re_comp.c" "\", line %d", "((svtype)((_svi)->sv_flags & 0xff)) != SVt_PVCV", 1410), (void) 0)); ((((svtype)((_svi)->sv_flags & 0xff)) != SVt_PVFM) ? ((void) 0) : (Perl_croak_nocontext("Assertion %s failed: file \"" "re_comp.c" "\", line %d", "((svtype)((_svi)->sv_flags & 0xff)) != SVt_PVFM", 1410), (void) 0)); ((!((((_svi)->sv_flags & (0x00004000|0x00008000)) == 0x00008000) && (((svtype)((_svi)->sv_flags & 0xff)) == SVt_PVGV || ((svtype)((_svi)->sv_flags & 0xff)) == SVt_PVLV))) ? ((void) 0) : (Perl_croak_nocontext("Assertion %s failed: file \"" "re_comp.c" "\", line %d", "!((((_svi)->sv_flags & (0x00004000|0x00008000)) == 0x00008000) && (((svtype)((_svi)->sv_flags & 0xff)) == SVt_PVGV || ((svtype)((_svi)->sv_flags & 0xff)) == SVt_PVLV))", 1410), (void) 0)); &((_svi)->sv_u.svu_rv); }))
error creating/fetching widecharmap entry for 0x%lX
!((zlopp)->sv_flags & 0x00000800) || !(*({ SV *const _svi = (SV *) (zlopp); ((((svtype)((_svi)->sv_flags & 0xff)) >= SVt_RV) ? ((void) 0) : (Perl_croak_nocontext("Assertion %s failed: file \"" "re_comp.c" "\", line %d", "((svtype)((_svi)->sv_flags & 0xff)) >= SVt_RV", 1444), (void) 0)); ((((svtype)((_svi)->sv_flags & 0xff)) != SVt_PVAV) ? ((void) 0) : (Perl_croak_nocontext("Assertion %s failed: file \"" "re_comp.c" "\", line %d", "((svtype)((_svi)->sv_flags & 0xff)) != SVt_PVAV", 1444), (void) 0)); ((((svtype)((_svi)->sv_flags & 0xff)) != SVt_PVHV) ? ((void) 0) : (Perl_croak_nocontext("Assertion %s failed: file \"" "re_comp.c" "\", line %d", "((svtype)((_svi)->sv_flags & 0xff)) != SVt_PVHV", 1444), (void) 0)); ((((svtype)((_svi)->sv_flags & 0xff)) != SVt_PVCV) ? ((void) 0) : (Perl_croak_nocontext("Assertion %s failed: file \"" "re_comp.c" "\", line %d", "((svtype)((_svi)->sv_flags & 0xff)) != SVt_PVCV", 1444), (void) 0)); ((((svtype)((_svi)->sv_flags & 0xff)) != SVt_PVFM) ? ((void) 0) : (Perl_croak_nocontext("Assertion %s failed: file \"" "re_comp.c" "\", line %d", "((svtype)((_svi)->sv_flags & 0xff)) != SVt_PVFM", 1444), (void) 0)); ((!((((_svi)->sv_flags & (0x00004000|0x00008000)) == 0x00008000) && (((svtype)((_svi)->sv_flags & 0xff)) == SVt_PVGV || ((svtype)((_svi)->sv_flags & 0xff)) == SVt_PVLV))) ? ((void) 0) : (Perl_croak_nocontext("Assertion %s failed: file \"" "re_comp.c" "\", line %d", "!((((_svi)->sv_flags & (0x00004000|0x00008000)) == 0x00008000) && (((svtype)((_svi)->sv_flags & 0xff)) == SVt_PVGV || ((svtype)((_svi)->sv_flags & 0xff)) == SVt_PVLV))", 1444), (void) 0)); &((_svi)->sv_u.svu_rv); }))
%*sTRIE(%s): W:%d C:%d Uq:%d Min:%d Max:%d
%*sCompiling trie using list compiler
panic! In trie construction, no char mapping for %ld
------:-----+-----------------
%*sState :Word | Transition Data
%*s%s
%*sCompiling trie using table compiler
%*sAlloc: %d Orig: %ld elements, Final:%ld. Savings of %%%5.2f
%*sStatecount:%lx Lasttrans:%lx
%*sState|-----------------------
%*sMJD offset:%lu MJD length:%lu
%*sNew Start State=%lu Class: [
%*sPrefix State: %lu Idx:%lu Char='%s'
%*sPeep:Pos:%ld/%ld Flags: 0x%lX Whilem_c: %ld Lcp: %ld %s
Looking for TRIE'able sequences. Tail node is: 
Quantifier unexpected on zero-length expression
((svtype)((last_str)->sv_flags & 0xff)) >= SVt_PV
((svtype)((last_str)->sv_flags & 0xff)) != SVt_PVAV
((svtype)((last_str)->sv_flags & 0xff)) != SVt_PVHV
!((((last_str)->sv_flags & (0x00004000|0x00008000)) == 0x00008000) && (((svtype)((last_str)->sv_flags & 0xff)) == SVt_PVGV || ((svtype)((last_str)->sv_flags & 0xff)) == SVt_PVLV))
Variable length lookbehind not implemented
Lookbehind longer than %lu not implemented in regex m/%.*s%s/
%*spre-fin:Pos:%ld/%ld Flags: 0x%lX Whilem_c: %ld Lcp: %ld %s
%*spost-fin:Pos:%ld/%ld Flags: 0x%lX Whilem_c: %ld Lcp: %ld %s
UTF8 mismatch! Converting to utf8 for resizing and compile
Required size %ld nodes
Starting second pass (creation)
%s %lu bytes for offset annotations.
%*sStclass Failtable (%lu states): 0
=!<,>
XS_VERSION
%s::%s
0.08
version
bootstrap parameter
re.c
re::install
re::regexp_pattern
re::regmust
Usage: %s(%s)
msixp
Assertion %s failed: file "re.c", line %d
%s object version %-p does not match %s%s%s%s %-p
re.so.debug
.shstrtab
.note.gnu.build-id
.gnu.hash
.dynsym
.dynstr
.gnu.version
.gnu.version_r
.rel.dyn
.rel.plt
.init
.text
.fini
.rodata
.eh_frame_hdr
.eh_frame
.ctors
.dtors
.jcr
.data.rel.ro
.dynamic
.got
.got.plt
.bss
.gnu_debuglink
