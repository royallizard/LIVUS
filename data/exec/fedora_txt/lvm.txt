/lib64/ld-linux-x86-64.so.2
@@(K
fJQ$
J$a0
 1@H@
B@!`
H!P9 
?~N{
ZT23
23P}
6xD7p6j
@4?$
 DA"Y;
|L'<
.nt_T
.0$+
sLc?
}=8N
s'q1
?s34
f(2c/
,A/(3
 }k..7
c)2m
!6+0
5FWU
_:mA
K}in
[5WT
:5z7u
-\2|
Rw#^
'7[Z	
,]j$
:!yw
.`!J
9_VQ
Rcq*XBg=m
Ngyv<
E0<j
E4~-Qh
t{K^'\
)eyJ
U	tk
[}W4
FGa+p
wLCo`R
]iv3
I~hG
=(NaZM
#m49s#
mh OG
kaf	
BKL:
(" uY
`3y)
:MMVD
/tzl
,E:m
libudev.so.1
__gmon_start__
_ITM_deregisterTMCloneTable
_ITM_registerTMCloneTable
_Jv_RegisterClasses
udev_queue_get_udev_is_active
udev_list_entry_get_next
udev_enumerate_new
udev_new
udev_queue_unref
udev_device_new_from_devnum
udev_list_entry_get_name
udev_device_get_sysattr_value
udev_unref
udev_enumerate_unref
udev_queue_new
udev_device_unref
udev_enumerate_get_list_entry
udev_device_get_property_value
udev_device_new_from_syspath
udev_enumerate_add_match_subsystem
udev_device_get_devlinks_list_entry
udev_device_get_devnode
udev_enumerate_scan_devices
libdl.so.2
dlclose
dlsym
dlopen
dlerror
libblkid.so.1
blkid_probe_lookup_value
blkid_probe_enable_partitions
blkid_new_probe_from_filename
blkid_probe_set_partitions_flags
blkid_probe_enable_superblocks
blkid_do_probe
blkid_probe_set_superblocks_flags
blkid_free_probe
libdevmapper-event.so.1.02
dm_event_handler_create
dm_event_unregister_handler
dm_event_handler_set_uuid
dm_event_handler_set_dmeventd_path
dm_event_handler_set_event_mask
dm_event_get_registered_device
dm_event_handler_destroy
dm_event_register_handler
dm_event_handler_set_dso
dm_event_handler_set_timeout
dm_event_handler_get_event_mask
libdevmapper.so.1.02
dm_tree_children_use_uuid
dm_get_suspended_counter
dm_config_tree_find_str_allow_empty
dm_config_tree_find_str
dm_pool_alloc
dm_pool_free
dm_create_dir
dm_get_status_thin
dm_free_wrapper
dm_report_compact_fields
dm_tree_create
dm_get_status_cache
dm_report_field_string_list
dm_tree_node_add_snapshot_origin_target
dm_pool_unlock
dm_task_get_info
dm_config_create
dm_config_clone_node_with_mem
dm_report_object
dm_size_to_string
dm_config_remove_node
dm_strdup_wrapper
dm_hash_insert
dm_task_get_uuid
dm_tree_find_node
dm_list_end
dm_task_set_uuid
dm_config_get_uint32
dm_list_move
dm_unescape_colons_and_at_signs
dm_build_dm_name
dm_config_tree_find_node
dm_task_no_flush
dm_udev_get_checking
dm_tree_node_add_cache_target
dm_escaped_len
dm_pool_locked
dm_tree_add_new_dev_with_udev_flags
dm_tree_node_set_presuspend_node
dm_report_object_is_selected
dm_list_last
dm_sysfs_dir
dm_udev_get_sync_support
dm_mknodes
dm_report_output
dm_udev_set_sync_support
dm_tree_add_new_dev
dm_report_field_percent
dm_config_clone_node
dm_config_parent_name
dm_hash_remove
dm_tree_free
dm_pool_lock
dm_tree_add_dev_with_udev_flags
dm_report_field_string
dm_tree_node_add_mirror_target_log
dm_tree_suspend_children
dm_config_create_node
dm_tree_node_add_linear_target
dm_config_parse
dm_hash_lookup
dm_hash_wipe
dm_tree_node_add_snapshot_target
dm_config_flatten
dm_config_get_list
dm_report_field_uint64
dm_make_percent
dm_task_get_name
dm_list_add
dm_task_set_name
dm_task_get_versions
dm_tree_use_no_flush_suspend
dm_tree_node_get_info
dm_config_maybe_section
dm_pool_zalloc
dm_pool_strdup
dm_regex_create
dm_hash_get_data
dm_units_to_factor
dm_task_no_open_count
dm_tree_node_get_uuid
dm_tree_deactivate_children
dm_tree_node_add_zero_target
dm_tree_activate_children
dm_task_set_message
dm_tree_skip_lockfs
dm_hash_insert_binary
dm_config_destroy
dm_config_from_string
dm_task_destroy
dm_log_is_non_default
dm_set_dev_dir
dm_config_value_get_format_flags
dm_config_find_int
dm_report_field_set_value
dm_list_first
dm_is_dm_major
dm_report_set_output_field_name_prefix
dm_hash_lookup_binary
dm_config_insert_cascaded_tree
dm_list_prev
dm_realloc_wrapper
dm_escape_double_quotes
dm_get_status_thin_pool
dm_regex_match
dm_tree_node_set_thin_pool_error_if_no_space
dm_config_create_value
dm_device_has_mounted_fs
dm_report_value_cache_set
dm_bitset_create
dm_task_enable_checks
dm_hash_get_first
dm_zalloc_wrapper
dm_config_get_str
dm_tree_node_add_error_target
dm_tree_node_add_target_area
dm_hash_iter
dm_udev_wait
dm_config_get_uint64
dm_get_next_target
dm_pool_abandon_object
dm_get_status_snapshot
dm_task_set_minor
dm_tree_next_child
dm_hash_destroy
dm_snprintf
dm_config_value_set_format_flags
dm_tree_node_add_raid_target_with_params
dm_config_set_custom
dm_pool_grow_object
dm_tree_node_get_name
dm_hash_get_num_entries
dm_tree_set_optional_uuid_suffixes
dm_log
dm_config_find_str
dm_log_with_errno_init
dm_config_write_one_node
dm_tree_node_set_read_ahead
dm_lib_release
dm_tree_preload_children
dm_set_uuid_prefix
dm_lib_exit
dm_tree_node_set_thin_pool_discard
dm_fclose
dm_tree_find_node_by_uuid
dm_config_get_custom
dm_tree_node_add_thin_target
dm_tree_node_add_striped_target
dm_pool_strndup
dm_config_write_one_node_out
dm_prepare_selinux_context
dm_driver_version
dm_list_empty
dm_list_add_h
dm_tree_add_dev
dm_list_size
dm_get_library_version
dm_set_sysfs_dir
dm_hash_get_key
dm_pool_begin_object
dm_list_next
dm_tree_set_cookie
dm_config_value_is_bool
dm_pool_create
dm_config_tree_find_int64
dm_task_set_major_minor
dm_dir
dm_report_free
dm_split_words
dm_task_create
dm_tree_node_get_context
dm_config_write_node
dm_get_status_raid
dm_tree_get_cookie
dm_tree_node_add_mirror_target
dm_config_get_section
dm_tree_node_add_thin_pool_message
dm_config_tree_find_float
dm_config_write_node_out
dm_pool_empty
dm_list_splice
dm_report_value_cache_get
dm_percent_to_float
dm_report_field_string_list_unsorted
dm_device_has_holders
dm_tree_node_add_thin_pool_target
dm_config_find_str_allow_empty
dm_config_find_int64
dm_asprintf
dm_report_field_int
dm_task_set_major
dm_config_tree_find_bool
dm_tree_node_add_null_area
dm_set_name_mangling_mode
dm_list_init
dm_config_has_node
dm_config_tree_find_int
dm_pool_end_object
dm_config_find_node
dm_tree_node_set_thin_external_origin
dm_report_init_with_selection
dm_list_del
dm_log_with_errno
dm_task_run
dm_task_set_event_nr
dm_task_get_read_ahead
dm_tree_retry_remove
dm_daemon_is_running
dm_report_field_uint32
dm_hash_create
dm_hash_get_next
dm_report_field_int32
dm_tree_node_add_snapshot_merge_target
dm_malloc_wrapper
dm_tree_node_set_callback
dm_build_dm_uuid
dm_tree_node_size_changed
dm_strncpy
dm_split_lvm_name
dm_pool_destroy
libreadline.so.6
write_history
rl_readline_name
history_length
read_history
remove_history
readline
rl_completion_matches
rl_line_buffer
rl_attempted_completion_over
stifle_history
rl_attempted_completion_function
add_history
librt.so.1
libc.so.6
__xpg_basename
fflush
strcpy
__printf_chk
setlocale
strncmp
optind
strrchr
pipe
__strdup
perror
munlock
mmap64
__fdelt_chk
closedir
nanosleep
getpriority
fork
sigprocmask
sigfillset
__stack_chk_fail
unlink
putchar
select
mkdir
fsync
abort
stdin
strtoll
getpid
strftime
__assert_fail
localtime_r
strtod
strtol
ctime_r
symlink
alphasort64
fgets
getppid
strlen
openlog
memset
dirname
strstr
rmdir
__errno_location
memcmp
mlock
dup2
unsetenv
rand_r
__fxstat64
__fprintf_chk
sigaddset
ctime
stdout
fputc
fputs
memcpy
__vsnprintf_chk
strtoul
munlockall
malloc
umask
strcasecmp
__strncpy_chk
__lxstat64
opendir
__xstat64
__ctype_b_loc
getenv
sscanf
optarg
stderr
sigdelset
ioctl
munmap
wait4
__snprintf_chk
getuid
readlink
fscanf
getopt_long
execvp
mallinfo
strncasecmp
strtoull
gethostname
usleep
__getdelim
fwrite
sigaction
geteuid
__memcpy_chk
sigismember
setlinebuf
mlockall
waitpid
localtime
lseek64
strchr
scandir64
rindex
__vfprintf_chk
mktime
mallopt
fdopen
readdir64
qsort
__vsyslog_chk
__ctype_toupper_loc
__strcpy_chk
__ctype_tolower_loc
__cxa_finalize
setvbuf
setsid
fcntl
getrlimit64
__sprintf_chk
memmove
uname
fopen64
access
_IO_getc
strcmp
strerror
__libc_start_main
dirfd
ferror
setpriority
closelog
_edata
__bss_start
dev_manager_create
lvmcache_drop_metadata
dev_manager_device_uses_vg
get_mirror_log_name
fid_get_mda_indexed
dev_manager_cache_status
export_uuids
collapse_mirrored_lv
vg_change_tag
config_file_check
pvcreate
lv_is_origin
init_snapshot_segtype
dev_open_readonly_buffered
alloc_snapshot_seg
check_lv_segments
create_toolcontext
tag_arg
dev_discard_blocks
move_pv
str_list_add_no_dup_check
get_default_config_profile_dir_CFG
pvdisplay
remote_lock_held
lvid_from_lvnum
dev_manager_info
dev_manager_thin_pool_percent
attach_pool_message
lv_remove_mirrors
lockd_free_vg_before
lv_is_active_locally
lvmcache_get_vgids
lv_layer
arg_sign_value
init_debug
lockd_lv_uses_lock
init_filters
archive_enable
lockd_lv
dev_manager_exit
pvck
lv_empty
arg_value
import_pool_lvs
release_flocks
text_vg_export_raw
process_profilable_config
find_vgname_from_pvid
chain_node
vg_max_lv
init_debug_classes_logged
import_pvs
pvdisplay_short
lv_snapshot_percent
set_lv_segment_area_lv
vgextend
lvmlockd_init
init_syslog
dev_write
lvmcache_update_pv
lvid_in_restricted_range
lockd_start_vg
init_pvmove
lvresize
alloc_policy_char
lvmcache_foreach_mda
lvmcache_vgname_is_locked
check_current_backup
consume_pv_area
lockd_start_wait
init_ignore_lvm_mirrors
vg_reduce
__libc_csu_fini
dev_md_stripe_width
emit_to_buffer
lv_mirror_percent
dev_optimal_io_size
lvs_in_vg_activated
poll_daemon
daemon_send
unlink_log_file
init_security_level
lv_mirror_log_dup
uuid_suffix_list
config_file_read
label_get_handler
lockd_free_lv
lvmcache_foreach_pv
init_ignore_suspended_devices
config_make_nodes_v
init_cache_segtypes
vgdisplay_full
text_vg_import_file
mirrorlog_arg
lvpoll
vg_lock_newname
lock_vol
get_default_allocation_cache_pool_chunk_size_CFG
config_file_open_and_read
lv_tags_dup
dev_destroy_file
import_pool_pv
sigint_caught
lvmcache_get_vgnames
find_pvmove_lv_from_pvname
load_profile
arg_percent_value
sync_dev_names
vgchange
arg_uint_value
locktype_arg
set_pool_discards
report_init
size_kb_arg
backup_list
handle_pool_metadata_spare
uuid_from_num
validate_pool_chunk_size
validate_lv_cache_create_pool
backup_enable
lvmetad_pvscan_single
discard_pv_segment
dev_discard_max_bytes
usable_filter_create
find_pv
lvmlockd_disconnect
lvmetad_pv_lookup_by_dev
read_pvs_in_vg
get_lock_type_from_string
find_pv_in_vg
export_vg_to_config_tree
critical_section_inc
lvmcache_foreach_da
detach_pool_metadata_lv
lvmcache_device
vg_set_clustered
dev_open
pv_mda_set_ignored
check_dev_block_size_for_vg
add_mirrors_to_segments
lvmetad_init
lvmlockd_set_socket
init_cmd_name
vg_mda_count
lvconvert
get_free_pool_device_id
fs_rename_lv
config_make_nodes
scan_vgs_for_pvs
init_external_locking
vg_lock_type_dup
fwraid_filter_create
export_lvs
lvremove_single
btree_get_data
vgmknodes
lvmcache_fmt_from_vgname
wait_for_single_lv
lvmcache_update_vgname_and_id
pv_analyze
lv_cache_status
vg_visible_lvs
release_pv_segment
lvm_run_command
vg_flag_write_locked
pv_max_name_len
calc_crc
dev_is_md
lv_calculate_readahead
vg_set_fid
init_thin_segtypes
lv_is_replicator
vgscan
vgcreate
lvmetad_pv_gone_by_dev
dev_cache_check_for_open_devices
lv_thin_device_id
_really_wipe
vgck
rlocn_is_ignored
init_lvm
init_mirror_in_sync
import_vg_from_lvmetad_config_tree
process_each_pv_in_vg
exec_cmd
get_config_tree_check_handle
dev_get_size
vg_mark_partial_lvs
vg_set_system_id
set_pe_align_offset
vgcreate_params_set_defaults
grouped_arg_str_value
lvseg_chunksize
lockd_init_vg
dev_open_readonly_quiet
lvmcache_destroy
poll_merge_progress
wipe_lv
init_dmeventd_monitor
vg_size
mdas_empty_or_ignored
pv_pe_start
fs_unlock
raw_read_mda_header
init_full_scan_done
make_config_node
str_list_match_list
export_vg_to_buffer
lvmcache_get_vgnameids
lvmdiskscan
lv_add_mirror_areas
import_vg
lv_modules_dup
init_log_direct
alloc_lv
get_pool_uuid
archive_vg
display_formats
lv_lock_args_dup
lvm1_present
get_pv_from_vg_by_id
dev_subsystem_name
out_size
dev_close
lv_resume
strip_dir
find_config_tree_bool
target_register_events
lvmetad_pvscan_foreign_vgs
create_pv_maps
vg_has_unknown_segments
pool_below_threshold
buffer_realloc
replicator_dev_add_rimage
lvmetad_connect_or_warn
detach_thin_external_origin
import_lvs
stored_errmsg_with_clear
revert_lvs
import_pool_vg
remove_config_tree_by_source
lvmcache_vgname_from_vgid
get_default_allocation_thin_pool_chunk_size_CFG
copy_percent
init_dev_disable_after_error_count
init_error_message_produced
lvdisplay_segments
target_present
check_new_thin_pool
pv_dev
export_numbers
lv_has_target_type
make_int_node
read_pool_label
activation_release
init_indent
archive_display_file
pool_label_in
dev_cache_init
dev_get_read_ahead
lv_refresh_suspend_resume
str_list_create
id_format_and_copy
lvmetad_vg_lookup
buffer_write
lv_data_lv_dup
mda_get_device
lvmcache_fid_add_mdas_pv
daemon_reply_destroy
pvmove_update_metadata
add_profile
sigint_allow
lvmetad_set_active
vg_set_max_pv
lvmcache_smallest_mda_size
lvs_in_vg_opened
log_suppress
lvscan
daemon_request_extend
remove_seg_from_segs_using_this_lv
out_text_with_comment
test_mode
list_segment_modules
dev_manager_mirror_percent
lvmetad_set_token
init_pv_min_size
permission_arg
set_cmd_name
silent_mode
lv_check_transient
vgcfgrestore
is_reserved_lvname
vgdisplay
lvseg_tags_dup
alloc_fid
extents_from_percent_size
lvmcache_uncertain_ownership
validate_tag
vg_max_pv
pvdisplay_colons
cmd_vg_lookup
set_activation
dev_iter_get
import_pool_pvs
pv_is_in_vg
process_each_label
arg_long_option_name
mpath_filter_create
lv_is_active_but_not_locally
make_text_node
cmd_vg_read
find_config_bool
discards_arg
find_config_node
major_max_partitions
lvmcache_verify_lock_order
import_extents
lvmcache_del
is_real_vg
int_arg_with_sign
init_test
text_vg_vsn1_init
pv_tags_dup
replicator_add_replicator_dev
arg_from_list_is_negative
lv_layout_and_role
pool_supports_external_origin
lv_parent
override_config_tree_from_profile
lv_mirror_count
dev_manager_release
vg_fmt_dup
arg_uint64_value
arg_count_increment
lv_lock_holder
buffer_destroy
vg_set_lock_type
vgdisplay_extents
daemon_close
dev_read_circular
backup_to_file
add_areas_line
lv_origin_dup
get_cache_mode_name
debug_class_is_logged
memlock_dec_daemon
lvnum_from_lvid
buffer_line
metadatacopies_arg
lvm_fin
lvmcache_del_das
text_vg_import_fd
out_newline
print_flags
dev_manager_mknodes
vg_refresh_visible
init_udev_checking
lv_suspend_if_active
thin_pool_feature_supported
init_log_fn
first_grouped_arg_int_value
str_list_dup
display_tags
vgreduce
pipe_open
archive_display
lv_remove
lv_host_dup
display_size
dev_manager_destroy
lv_is_cow
lv_is_merging_origin
generate_lvm1_system_id
locking_is_clustered
lvmcache_lock_vgname
set_flag
get_default_unconfigured_backup_archive_dir_CFG
get_default_activation_mirror_image_fault_policy_CFG
daemon_request_extend_v
vg_status
activation_arg
lvconvert_mirror_finish
config_def_check
get_default_backup_archive_dir_CFG
process_each_lv
pvmove_mode
lv_remove_with_dependencies
lv_read_replicator_vgs
arg_int64_value
lvmlockd_set_use
skip_dev_dir
config_files_changed
_IO_stdin_used
target_registered_with_dmeventd
create_text_format
archive_exit
shift_mirror_images
label_create
id_write_format
lv_kernel_read_ahead
lvconvert_merge_finish
vgrename
text_vgname_import
set_mirror_log_count
pv_fmt_dup
_text_ops
out_config_node
attach_pool_data_lv
lvseg_segtype_dup
wipe_cache_pool
cmirrord_is_running
get_percent_string
get_default_unconfigured_backup_backup_dir_CFG
lv_is_cow_covering_origin
activate_lvs
process_each_segment_in_pv
vgexport
lv_add_segment
init_striped_segtype
lvmcache_vgname_from_info
lvmpolld_use
unlink_lv_from_vg
first_replicator_dev
find_vgname_from_pvname
lockd_rename_vg_final
print_log
lv_raid_image_count
lvseg_discards_dup
lvmcache_vginfo_holders_dec_and_test_for_zero
memlock_init
lv_dmpath_dup
lv_cache_create
pv_pe_count
replicator_remove_rlog
is_lockd_type
dev_manager_deactivate
attach_thin_external_origin
text_labeller_create
lvseg_name
lvmcache_get_pvids
read_vgd
lv_kernel_major
fs_set_create
is_temporary_mirror_layer
__data_start
lv_set_creation
out_inc_indent
poll_thin_merge_progress
dev_fd
vgsplit
vg_mda_size
cmd_vg_add
pv_disks_found
get_default_unconfigured_devices_cache_CFG
config_file_changed
init_selection_handle
adjusted_mirror_region_size
backup_init
vg_rename
lockd_running_lock_type
lvmetad_vg_remove
lv_rename
lv_extend
pvchange
lv_release_replicator_vgs
lvmcache_init
arg_from_list_is_set
vg_attr_dup
dev_subsystem_part_major
lvseg_seg_pe_ranges
dev_manager_suspend
label_register_handler
add_linear_area_to_dtree
lv_is_virtual_origin
lv_mirror_image_in_sync
lv_raid_percent
replicator_add_rlog
vg_mda_copies
dev_iter_create
lvmlockd_connect
load_pending_profiles
init_processing_handle
add_pv_to_vg
label_read
lvm_shell
backup_locally
lvmconfig
lvmsadc
verbose_level
pvresize
vg_remove_pvs
lvmetad_pv_found
lv_reduce
lockd_init_lv_args
udev_get_library_context
partial_raid_lv_supports_degraded_activation
calculate_layout
vg_write_lock_held
peg_dup
remove_layers_for_segments
lv_is_thin_origin
pv_size
vgmerge
attach_mirror_log
clear_snapshot_merge
out_hint
lv_raid_reshape
find_config_tree_node
pv_vgid
init_zero_segtype
lvmcache_add
btree_next
init_snapshot_merge
lockd_free_vg_final
monitor_dev_for_events
find_lv_in_vg
lv_size
lv_raid_split
get_lock_type_string
lvseg_devices
dev_manager_activate
find_config_tree_float
recalculate_pool_chunk_size_with_dev_hints
init_unknown_segtype
get_default_region_size
sigint_clear
grouped_arg_is_set
cache_set_mode
thin_merge_finish
config_file_read_fd
dumpconfig
lvs_using_lv
lvmcache_add_da
vg_max_name_len
extents_from_size
init_snapshot_seg
read_disk
lv_metadata_size
display_stripe
text_import_areas
vg_set_extent_size
lvmcache_is_orphan
lv_raid_sync_action
dev_cache_get_by_devt
vgimport
lvmetad_vg_clear_outdated_pvs
export_pv_act
set_lv_segment_area_pv
remove_mirror_log
lvmcache_vginfo_from_vgname
build_parallel_areas_from_lv
mda_copy
yes_no_prompt
lv_raid_change_image_count
vg_set_mda_copies
activation_exit
find_lv_in_vg_by_lvid
fid_remove_mda
lvconvert_poll
lv_add_mirrors
label_destroy
lvmcache_populate_pv_fields
vg_set_max_lv
buffer_init
reset_log_duplicated
pool_has_message
lvmcache_fid_add_mdas
release_and_discard_lv_segment_area
memlock_inc_daemon
lvmcache_lookup_mda
pv_list_extents_free
lvmetad_pv_gone
lvseg_size
add_pvl_to_vgs
lv_is_active_exclusive_remotely
lv_status
pool_check_overprovisioning
read_pool_disk
lvseg_monitor_dup
vg_read_internal
archive_list_file
dev_flush
remove_layers_for_segments_all
export_pv
lv_add_log_segment
vgs_are_compatible
pv_mda_count
dev_is_partitioned
pv_id
activate_lv_excl
init_mirrored_segtype
generate_lv_name
vg_validate
report_init_for_selection
is_global_vg
vg_tags_dup
dev_ext_name
str_list_lists_equal
lvmcache_info_from_pvid
pool_is_active
systemid
replicator_dev_remove_rimage
backup_restore
init_raid_segtypes
pv_set_fid
move_lv_segments
vg_add_snapshot
handle_sanlock_lv
get_segtype_from_string
lv_has_unknown_segments
init_abort_on_internal_errors
pool_labeller_create
is_empty_dir
backup_remove
resume_lvs
alloc_arg
find_config_tree_str_allow_empty
find_pv_in_vg_by_uuid
export_vg
lv_resume_if_active
lv_convert_lv_dup
pvcreate_params_set_defaults
assign_peg_to_lvseg
vgname_from_mda
cache_mode_is_set
import_pool_segments
rlocn_set_ignored
lvdisplay_full
find_replicator_vgs
lv_raid_mismatch_count
copy_systemid_chars
partitioned_filter_create
dmeventd_monitor_mode
str_list_add_h_no_dup_check
dev_cache_scan
init_pool_format
lvm_return_code
regex_filter_create
archive
pv_vg_name
lvdisplay_colons
str_list_add_list
pv_dev_name
vgchange_activate
init_readonly_locking
dev_set
is_pv
arg_outside_list_is_set
lvseg_cachemode_dup
vgremove
cache_set_policy
last_seg
dev_get_primary_dev
yes_no_arg
set_pe_align
alloc_destroy
lv_set_activation_skip
lvmcache_vgname_from_pvid
lv_info_by_lvid
label_init
lvmcache_vgs_locked
lv_kernel_minor
lvmcache_get_label
lvm_fclose
lv_raid_merge
lv_activation_skip
lv_is_cache_origin
lv_uuid_dup
btree_insert
__libc_csu_init
attach_pool_metadata_lv
help
backup_restore_from_file
extract_vgname
lv_is_rimage
lvmetad_socket_present
init_external_device_info_source
get_default_backup_backup_dir_CFG
lv_create_empty
check_pv_segments
set_sysfs_dir_path
cow_max_extents
vg_extent_size
sigint_restore
dev_ext_disable
lv_pool_lv_dup
daemon_request_destroy
clvmd_is_running
pvdisplay_segments
lv_ondisk
lv_is_visible
pvcreate_single
pv_split_segment
lvmetad_pv_list_to_lvmcache
fid_add_mda
lvmetad_pv_lookup
dev_manager_raid_status
init_detect_internal_vg_cache_corruption
lv_check_not_in_use
id_equal
lvrename
vg_check_status
daemon_send_simple_v
lvmcache_add_mda
out_areas
get_only_segment_using_this_lv
pv_write_orphan
is_mirror_image_removable
suspend_lvs
lv_time_dup
get_monitor_dso_path
dev_cache_exit
read_pool_pds
buffer_append_f
apply_lvname_restrictions
init_dummy_locking
lv_resize
lv_name_dup
find_lv
alloc_pv_segment_whole_pv
mda_is_ignored
find_pvmove_lv_in_lv
vg_max_lv_reached
lv_remove_single
vgconvert
update_thin_pool_params
for_each_sub_lv
mirror_remove_missing
import_vg_from_config_tree
init_cluster_locking
stored_errno
get_alloc_string
lv_is_merging_thin_snapshot
find_config_tree_int
lv_raid_healthy
critical_section
lv_is_raid_with_tracking
pvdisplay_full
backup_exit
pv_maps_size
lvm_register_segtype
lv_is_replicator_dev
vg_missing_pv_count
lvm_split
vg_create
free_pv_fid
import_lv
lvseg_start
init_locking
get_default_unconfigured_devices_cache_dir_CFG
get_default_devices_cache_dir_CFG
dev_iter_destroy
dev_test_excl
udev_fin_library_context
export_vg_number
get_and_validate_major_minor
fs_add_lv
sync_local_dev_names
lv_raid_message
snapshot_count
lv_is_active
lvmcache_fid_add_mdas_vg
lvm_even_rand
vg_free
get_alloc_from_string
lvmetad_pvscan_all_devs
lvmcache_update_das
lv_add_virtual_segment
validate_restricted_lvname_param
fs_del_lv
mda_locns_match
lvm_register_commands
link_lv_to_vg
get_pvmove_pvname_from_lv
lv_mknodes
lockd_rename_vg_before
vg_set_alloc_policy
buffer_append_vf
init_silent
find_mirror_seg
init_activation_checks
refresh_toolcontext
fixup_imported_mirrors
lvmcache_vginfo_from_vgid
pv_uuid_dup
clone_pv_list
fs_get_cookie
lvmcache_add_orphan_vginfo
process_each_vg
write_disks
get_pvs_internal
check_lvm1_vg_inactive
vg_mda_used_count
vg_free_count
vg_remove_check
vg_name_dup
backup_read_vg
target_version
update_cache_pool_params
dev_is_luks
path_exists
find_config_tree_array
lvmcache_device_size
pvcreate_params_validate
lv_raid_dev_health
fin_log
pv_mda_free
pv_size_field
vg_system_id_dup
vg_remove_mdas
remove_mirrors_from_segments
lv_update_and_reload
vg_seqno
config_write
pvremove
export_extents
pv_change_metadataignore
get_pvmove_pvname_from_lv_mirr
select_match_pv
init_connections
dev_ext_enable
btree_lookup
lvmcache_pvid_from_devname
read_flags
grouped_arg_count
release_lv_segment_area
free_orphan_vg
display_size_units
pv_label
vg_write
import_snapshots
lv_change_tag
dev_open_readonly
replace_lv_with_error_segment
daemon_open
lv_config_profile
report_devtypes
str_list_match_item
pvmove_finish
lvmetad_active
origin_from_cow
module_present
dev_close_all
lvmpolld_set_socket
init_trust_cache
vg_uuid_dup
lv_set_visible
label_exit
create_pv_list
dev_create_file
pvcreate_vol
lv_passes_auto_activation_filter
lvmcache_found_duplicate_pvs
find_pv_by_name
lv_info_with_seg_status
lvmcache_replace_dev
lvm_dm_prefix_check
check_replicator_segment
archive_list
lv_is_active_replicator_dev
lv_split_segment
lv_activate_with_filter
lv_spawn_background_polling
vg_pv_count
readahead_arg
lv_refresh
find_snapshot
reset_locking
validate_lv_cache_create_origin
display_lvname
add_seg_to_segs_using_this_lv
size_mb_arg
lv_set_hidden
add_mirror_log
lvmcache_make_valid
display_name_error
dev_discard_granularity
locking_supports_remote_queries
lvdisplay
daemon_request_make
validate_name_detailed
lvmetad_get_vgnameids
lv_thin_pool_percent
dev_manager_snapshot_percent
find_temporary_mirror
swap_lv_identifiers
sysfs_filter_create
init_error_segtype
init_retry_deactivation
get_default_unconfigured_config_profile_dir_CFG
init_log_file
lv_activation_filter
lv_profile_dup
lvmcache_set_device_size
pv_ba_start
for_each_sub_lv_except_pools
dev_manager_preload
vg_profile_dup
get_pv_list_for_lv
stored_errmsg
insert_layer_for_segments_on_pv
lv_raid_split_and_track
init_obtain_device_list_from_udev
del_pvl_from_vgs
reset_lvm_errno
dir_exists
allocate_extents
lv_attr_dup_with_info_and_seg_status
create_temp_name
dev_append
lvmpolld_disconnect
fs_has_non_delete_ops
lv_origin_size
lvmetad_disconnect
init_no_locking
validate_vg_rename_params
lv_parent_dup
lv_is_on_pv
vgcreate_params_set_from_args
log_command_name
init_is_static
reinsert_changed_pv_area
dev_alignment_offset
vg_mda_free
dev_manager_thin_device_id
remove_layer_from_lv
lvmcache_foreach_ba
debug_level
lvmcache_del_mdas
lockd_gl
dev_open_quiet
dev_manager_thin_percent
lvmcache_fmt
lvreduce
lvmetad_used
lvmcache_get_vg
init_verbose
persistent_filter_load
lvmcache_del_bas
lv_fullname_dup
vg_lock_args_dup
init_flock
remove_mirror_images
dev_ext_release
fs_del_lv_byname
move_pvs_used_by_lv
lvmcache_add_ba
detach_pool_lv
vgcfgbackup
get_shared_library_path
vg_check_new_extent_size
alloc_lv_segment
find_config_tree_int64
dev_is_rotational
lockd_stop_vg
lvmcache_vgid_is_cached
display_size_long
update_pool_params
lvmcache_check_format
lvmcache_info_mda_free
lvmcache_mda_count
persistent_filter_create
list_lv_modules
lv_change_activate
dev_cache_add_loopfile
size_mb_arg_with_percent
vg_read_error
insert_layer_for_lv
lvmlockd_use
lv_split_mirror_images
vgcreate_params_validate
attach_pool_lv
vg_extend
lvcreate
pool_label_out
vg_remove_pool_metadata_spare
out_text
get_pool_params
pv_ba_size
config_open
lvchange
pv_mda_size
lockd_vg_update
vgdisplay_colons
find_pool_lv
init_msg_prefix
pv_pe_size
init_md_filtering
lv_is_active_exclusive_locally
tags_format_and_copy
fcntl_unlock_file
get_config_tree_by_source
replicator_dev_remove_slog
pv_free
pv_status
find_config_tree_str
dev_minimum_io_size
get_format_by_name
validate_new_vg_name
validate_name
lvmetad_set_socket
compare_config
report_for_selection
btree_first
dev_manager_thin_pool_status
detach_mirror_log
lv_metadata_lv_dup
lvremove
pv_dev_size
wipe_known_signatures
pv_create
find_free_lvnum
lv_path_dup
vgdisplay_short
pv_name_dup
lvmpolld_poll_init
create_dev_types
vg_check_pv_dev_block_sizes
dev_close_immediate
lvm2_main
get_free_vg_number
process_each_pv
get_default_devices_cache_CFG
init_ignorelockingfailure
config_file_timestamp
text_vg_export_file
vg_split_mdas
lv_resize_prepare
lvm_getpagesize
lvmetad_vg_list_to_lvmcache
buffer_append
vg_remove_snapshot
id_read_format
alloc_vg
init_log_while_suspended
lv_is_slog
int_arg_with_sign_and_percent
vg_check_write_mode
read_urandom
poll_mirror_progress
get_cmd_name
memlock_unlock
dev_cache_add_dir
fcntl_lock_file
munge_pvd
critical_section_dec
pv_pe_alloc_count
lv_raid_remove_missing
lv_add_mirror_lvs
become_daemon
lockd_vg
config_def_create_tree
lv_info
config_def_get_path
find_pool_seg
_pe_size_may_not_be_negative_msg
destroy_processing_handle
get_stripe_params
add_mirror_images
lvmsar
dev_reset_error_count
udev_is_running
dev_manager_transient
dev_open_flags
find_seg_by_le
init_lvm1_format
lvmetad_validate_global_cache
pvremove_single
pv_parts_found
load_shared_library
alloc_pool_metadata
str_list_del
metadatatype_arg
sync_dir
find_min_mda_size
move_lv_segment_area
system_id_from_string
select_match_vg
dev_read
lv_active_change
composite_filter_create
lv_is_on_pvs
cluster_mirror_is_available
btree_create
config_get_source_type
pv_resize_single
_lvm1_ops
display_segtypes
init_lvmcache_orphans
lvmetad_vg_update
dev_manager_raid_message
dev_name_confirmed
pv_uses_vg
lv_add_segmented_mirror_image
lv_raid_image_in_sync
lvm1_labeller_create
replicator_dev_add_slog
lvmcache_device_from_pvid
fs_set_cookie
lvmpolld_set_active
fin_locking
lvm_type_filter_create
lv_raid_replace
arg_from_list_is_zero
lvmetad_release_token
lockd_gl_create
lvmcache_seed_infos_from_lvmetad
init_file_locking
string_arg
lv_deactivate
dev_ext_get
dev_get_block_size
find_pv_in_pv_list
get_cache_params
str_list_add
first_seg
_pool_ops
pv_used
pvmove_poll
cow_has_min_chunks
id_valid
lv_update_and_reload_origin
process_each_lv_in_vg
lv_from_lvid
label_verify
vgreduce_single
is_orphan_vg
dev_cache_has_scanned
split_parent_segments_for_layer
lvm_rename
out_dec_indent
lv_merge_segments
lvmcache_label_scan
free_cmd_vgs
import_pv
vg_set_pool_metadata_spare
override_config_tree_from_string
lv_cache_remove
merge_config_tree
lv_activate
dev_is_swap
lv_rename_update
archive_init
lv_thin_percent
label_remove
memlock_reset
vg_read_for_update
release_vg
update_pool_lv
label_write
lvextend
lvmcache_unlock_vgname
lv_is_active_exclusive
vg_remove_direct
destroy_toolcontext
segtype_arg
lv_is_merging_cow
refresh_filters
lvid_create
lvmcache_update_bas
pipe_close
lvmcache_set_preferred_duplicates
lockd_init_lv
lvmcache_commit_metadata
lvmcache_pvid_is_locked
validate_lvname_param
pv_format_type
merge_pv_segments
dev_cache_get
get_pool_discards_name
int_arg
pv_mda_used_count
is_missing_pv
vg_extent_count
pvremove_many
pv_attr_dup
vg_commit
lv_create_single
init_background_polling
lv_thin_pool_transaction_id
replicator_remove_replicator_dev
lvmchange
calculate_extent_count
daemon_send_simple
lv_active_dup
lv_attr_dup
vg_revert
max_len
lv_move_pv_dup
lvmcache_update_vg
get_activation_monitoring_mode
percent_of_extents
pv_write
backup_restore_vg
init_fwraid_filtering
select_match_lv
lockd_lv_name
unblock_signals
lvm_stat_ctim
dev_set_preferred_name
udev_init_library_context
find_pvmove_lv
process_each_segment_in_lv
buffer_read
find_lv_in_lv_list
lvmpolld_request_info
md_filter_create
major_is_scsi_device
pvscan
release_log_memory
fin_syslog
pvdata
read_only_lv
device_is_usable
lvmcache_contains_lock_type_sanlock
GLIBC_2.2.5
Base
LIBUDEV_183
BLKID_2.17
BLKID_2.15
GLIBC_2.15
GLIBC_2.14
GLIBC_2.4
GLIBC_2.3
GLIBC_2.3.4
DM_1_02_104
DM_1_02_100
DM_1_02_97
DM_1_02_101
DM_1_02_103
[]A\
[]A\
AWAVAUATI
D$X1
D$ H
 t-L
t#WH
AWPL
KHH%
A;D$@
\$XdH3
|$ L;|$
|$01
T$XH
t$PH
H;l$
{Pu0
h[]A\A]A^A_
AWAVAUATI
[A\A]A^A_]
AWAVH
AUATE1
7L;|$
[]A\A]A^A_1
[]A\A]A^A_H
[]A\A]A^A_
G\ H
AYAZ
AWAVAUATI
vPdH
FY@t|H
EY@VH
ATSR
H	CX
[]A\A]A^A_
AWAVE
AUATI
T$hA
L$xj
L$8E
CZ@t+L
L$xL
PAVj
L$8E
L$HL
D$Xu
D$Xu
ZYu&L
tDD9|$
[]A\A]A^A_
AWAVAUATI
AYAZ
T$lD
D$lE
|$lA
T$hH
;Pxt'L
L$(1
A[A]
D+t$
L$lD
AXAYA
L$lE
UAWA)
[]A\A]A^A_
AWAVL
AUATA
D$H1
L$HdH3
X[]A\A]A^A_
AUATI
Z[]A\A]
fffff.
fffff.
fffff.
=iC4
AUATUSH
]A\A]
[]A\A]
]A\A]
fff.
AWAVI
AUAT1
D$X1
L$XdH3
h[]A\A]A^A_
t$ H
t$8H
L$F 
L$F@
D$(H
|$8H
D$ H
D$ H
T$ H
t$ D
D$@	
t$ H
l$0H
t$ H
l$0H
t$ H
l$0H
t$ H
l$0H
t$ H
AWAVI
AUATUSH
[]A\A]A^A_
GXuX
AXAYA
A;G`
A^XM
_AXE
OpE9
L$PE1
OpE9
A[A]L
L$PE1
AXAY
L$PE1
A[A]E1
|$PH
L$PE1
L$PE1
AUAVL
_AXI
L$PH
T$H1
t$PL
l$HL
A;E8
GPHct$
D$ H
T$ H9T$
L$(t
D$8H
HcL$
T$0H
L$(H
T$0L
D$8H
:tmH
|$PH
A9W@vsH
T$(L
T$(t
<ytQ<nt.<tuhI
H1HX
H!HX
H	HX
A[A]
ffff.
AWAVAUATA
[]A\A]A^A_
[]A\A]A^A_
AWAVI
AUATI
[]A\A]A^A_
fff.
AVAUL
ATUSL
A9n@vN
A9n@w
[]A\A]A^
]A\A]A^
AUATUSH
GXE1
;X@s`H
[]A\A]
AUATI
[]A\A]
[]A\A]
AWAVI
AUATI
[]A\A]A^A_
]A\A]A^A_
AVAUA
ATUI
]A\A]A^
]A\A]A^
ATUSH
[]A\
[]A\
[]A\
AWAVAUATUSH
D$HA
L9l$
D$HH
T$hu/
[]A\A]A^A_
d$`Hc
t$HH
t$HH
D$HD
t$HH
t$`H
D$HD
t$HH
D$HD
t$HH
{PL;
t$HH
t$HL
t$H1
D$HD
D$HL
D$HD
t$HD
t$HH
t$HH
D$HD
D$HH
t$HH
T$<H
A_XD
T$ L
|$`H
D$hH
D$PH
T$ L
T$ t>H
T$ t%H
T$@H
D$HD
t$HH
I!EXL
A[A^D
t$@L9
T$@H
T$,L
T$ L
T$(L
AWAV1
D$HRL
ffff.
fffff.
CdPH
C`PH
 []A\
AWAVAUATI
fPdH
D$pH
D$xH
[]A\A]A^A_
\$ H
L$(H
L$(H
D$(H
D$0H
D$8E
t$HH
\$8H
T$0H
t$H1
T$(1
tlWL
l$xj
AXAYu-RAVH
D$(H
A^A_
@H9Ed
D$ H
L$(L
T$(1
U,XZE
\$ u
\$ u
T$(L
\$ D
\$(L
D$ H
I	CXL
t$hL
\$8t(I
\$8u
T$01
D$0L
\$8E1
D$pL
D$HH
D$0H
\$8H
L$0H
\$8t_H
\$8H
D$0H
\$0H
E|PH
AYAZ
L$(L
\$ D
\$ H
\$(D
T$ L
D$0H
AYAZ
ffffff.
AUATA
[]A\A]
[]A\A]
AVAUI
ATUH
}PA)
[]A\A]A^
]A\A]A^
[]A\A]A^
[]A\A]A^
fffff.
AWAVAUATUSH
D$H1
BY@tyL
L$HdH3
X[]A\A]A^A_
A[[L
L$ E1
L$ E1
AYAZ
AYAZH
PAV1
@uMH
t$ H
H!CX
t$ H
t]PH
A]A^
AYAZ
+ElA
AWAV
AUATA
|$@H
AYAZ
[]A\A]A^A_
T$@E
\$HE
L$dE
C0I9
$$M9
Hct$$H
T$$H
D$xH
L$$L
L$$L
D$(u
AYAZL
t$<H
D$<H
t$xH
_AXH
AXAY
A]A^
l$xH
BZ@u
AVATH
L$H1
T$ L
L$(L
D$0H
L$8H
T$@L
|$HdH3<%(
X[]A\A^
AUATI
]A\A]
[]A\A]
[]A\A]
fffff.
AUATI
[]A\A]
t$`1
D$`H
[]A\A]
[]A\A]
tkATUH
[]A\
Z[]A\
AUATI
[]A\A]
AYAZ
[]A\A]
AWAVM
AUATL
D$81
jmj^1
jmj~1
jCj-H
j%j,h
j7jah
KXE1
T$(H
L$ L
L$ H
L$8dH3
H[]A\A]A^A_
j?j=
jujyj
j7j.j
j?j=A
jujyj
j@j?j=j,h
j~j^A
j?j=A
C PH
AYAZ
T$0H
L$0M
QAPL
H;\$
t$0H
AWAV
AUATUSH
|$@H
l$@L
[]A\A]A^A_
AXAYI
T$lH
T$pH
@tt1
t$ H
AVPH
L$DE
E4PH
EtPH
E8PD
@] H
I3EX
AXAY
l$0E
4$t_I
A[]L
L$(A
L$`H
EXu}L
EXu~E
A[A]
A^A_
fff.
[]A\L
[]A\
su)D
nt:E
fffff.
fffff.
ffffff.
AUATI
<-t~
[]A\A]
]A\A]
fff.
fffff.
ATUH
[]A\
[]A\
[]A\
D$X1
T$XdH3
[]A\
[]A\
ATUL
[]A\
AVAUI
D$(1
D$(dH3
0[]A\A]A^
ffffff.
ffff.
AWAVI
AUAT
T$ L
A9H$
@(Hc
T$ H
[]A\A]A^A_
fffff.
fffff.
ffffff.
AWAVAUATA
([]A\A]A^A_
8%t"1
H9C w
AWAVE1
AUATI
D$(1
D$0H
D$ H
t$0E
t$ thA
L$ H
twHc
D$(dH3
z$u:H
h[]A\A]A^A_
fffff.
AUATUSH
tI~L
[]A\A]
]A\A]
fffff.
AWAVAUATLc
[]A\A]A^A_
ffff.
ATUH
D$pH
T$0H
L$8L
D$@L
L$HH
P[]A\
ATUI
T$0H
L$8L
D$@L
L$HdH
L$p1
D$ H
dH3<%(
P[]A\
fff.
ATUHc
D$(H
ATUHc
ffffff.
ATUHc
AVAUA
ATUL
g0SH
_0L9
]A\A]A^
]A\A]A^
fff.
ATUHc
[]A\
ffffff.
AUATI
T$0H
L$8L
D$@L
L$HH
X[]A\A]
fff.
ATUHc
ffffff.
ATUHc
D$(H
ATUHc
D$(H
P [H
ATUHc
ffffff.
AUATE1
T$0H
L$8L
D$@L
L$HH
X[]A\A]
fffff.
ATUHc
ffffff.
fffff.
jqjfjpjojnjjjYjXj*j'h
jhjbh
j6j3j2j
jqjfjpjojnjjjYjXj*j'h
jsjrh
j\j[h
jIjOh
jGjFjEjCjDj;h
j%j-j1j,j*h
jejdjujwjyj
jijcjaj_j^h
jZjWjVjUjTh
jLjKh
j@j?H
j>j9j8h
j.j&h
j~jejdj
jmjaj^h
jCjDj@j?h
j8j7h
j%j-j1h
j.j,j*h
j~jejdj
jujwjyj
jgjbjSjRh
jQjHh
j6j3h
jijah
j?j8j7h
jqjfjpjojnjjjYjXj*j'h
jhjgjbj`h
jSjRh
jQjPjHh
j6j4j3j2j
j	jHh
jyjth
jMjBj:j5j)j+j(h
jgjbh
jSjRh
j6j3h
j{jyj
jhjgjbj`h
jSjRh
jQjPjHh
j6j4j3j2j
j	j|ju
j!j$j#j"h
j]j\h
jIj;h
jlj(j8j1j*H
jujwjyjtj
j+jBj(h
j!j$j]jSj
jlj(jBj+j h
jgjbh
j6j3j
j)j(jBj+h
jJj/h
jhjgjbj`h
jSjRh
jPjHh
j6j4j3j2j
AWAVAUATUSH
-u#E
$$A9
([]A\A]A^A_
A^A_L
AZA[
@  t
 t!L
A\A]
AXAY
@ @u1
AWAVI
AUATI
"tq1
Mc7L
[]A\A]A^A_
ffff.
|((H
[]A\
fff.
AWAVAUATUSH
l$ H
D$ 1
t$0H
|$0#
|$1!
[]A\A]A^A_
;\$ |
ATUH
 []A\
ffff.
AUATI
[]A\A]
[]A\A]
AWAV
AUATI
D$81
|$ H
D$0H
T$01
L$8dH3
H[]A\A]A^A_
T$ H
AWAVAUATUSH
[]A\A]A^A_
AVAU
ATUA
d$xL
[]A\A]A^
D$8d
T$xM
AWAVAUATUSH
L$ E1
AWAVU
SATL
L$8H
[]A\A]A^A_
d$ L
l$ L
l$PL9
AVAUE1
ATUH
F H=
]A\A]A^
]A\A]A^
fff.
AWAVI
AUATI
[]A\A]A^A_
t E1
$u	H
fff.
AUATI
[]A\A]
AWAVI
AUATL
D$H1
D$ I9
l$(L
ZYL9
L$HdH3
X[]A\A]A^A_
fffff.
AWAVAUATUSH
D$X1
l$ I
D$0H
l$ H
FXt0I
T$XdH3
h[]A\A]A^A_
|$HH
D$8I
D$0H
ATUSH
dH34%(
 []A\
AWAVAUATI
D$ H=
_AXH
D$ H
([]A\A]A^A_
ffffff.
AWAVA
AUAT1
D$x1
D$HD
T$DL
l$`L
d$htL
D$PA]A^
t$LH
T$@H
D$LL
L$xdH3
[]A\A]A^A_
d$@H
\$LE
L$HE
D$@I
d$(H
D$@H
l$ L
|$(M9
thL9
t$ L
T$ H
AWAVI
AUATUSH
D$X1
L$XdH3
h[]A\A]A^A_
fff.
AWAVAUATA
([]A\A]A^A_
AUATUSH
[]A\A]
AWAVAUATA
[]A\A]A^A_
L$XL
AVAUATUH
]A\A]A^
]A\A]A^
AX[]A\A]A^
fff.
[]A\
[]A\
ATUH
[]A\
[]A\
[]A\
fffff.
AVAUI
ATUI
[]A\A]A^
]A\A]A^
AWAVE
AUATUSH
[]A\A]A^A_
[]A\A]A^A_
[]A\A]A^A_
[]A\A]A^A_L
AWAVAUATI
[]A\A]A^A_
<$/t
$</t
D$8H
T$ H
T$@H
t$ L
T$@H
t$(L
D$8H
t$ H
t$(L
T$@H
t$ L
t$(L
D$0H
D$0H
H;\$0H
H9D$ t
t$(L
t$(L
D$ I
T$`H9
l$DH
l$XH
D$HL
L9l$ 
t$PL
D$0H
/H9|$0t1H
D$HH
H9D$`H
l$XH
t$PH
_AXH
D$HH
D$HH
L$HH9L$`
D$HH
H9\$ t
t$pt
D$LP
t$@j
t$ L
D$ H
L$PH
L$(L
D$ D
;X@wNH
[H9l
AUATL
[]A\A]
[]A\A]
AWAVI
AUATI
D$(1
ZYuPL
L$(dH3
8[]A\A]A^A_
AWAVAUATUSH
([]A\A]A^A_
AUATUSH
[]A\A]
[]A\A]
[]A\A]
[]A\A]
AVAUATUSH
 []A\A]A^
XZE)
AWAVAUATUS
D$81
T$8dH3
H[]A\A]A^A_
ATUA
 []A\
fffff.
AWAVAUATA
[A\A]A^A_]
}0M9
$$L9e
SAW1
RQS1
PAW1
fff.
fffff.
fffff.
AVAUI
ATUI
[]A\A]A^
D$8D
[]A\A]A^
ATUH
[]A\H
ATUH
[]A\H
ATUH
[]A\H
ATUH
[]A\H
AWAVI
AUATM
l$PL
\$0H
D$ `
PAUAW
[]A\A]A^A_
ffffff.
fffff.
AUATI
D$X1
|$8H
T$XdH3
h[]A\A]
fff.
fff.
ffffff.
AUATI
D$X1
|$8H
L$XdH3
h[]A\A]
fff.
fff.
ffffff.
AWAVAUATUSH
L$<H
D$h1
L$hdH3
x[]A\A]A^A_
L$ 1
l$8D
l$8D
D$(E1
t$<R
PAUAT
D$<PL
D$`H
T$XH
|$8H
L$LH
T$HM
|$`A
D$P1
|$LH
T$01
t$ E1
D$<E1
D$P1
L$PL
|$HE
l$LL
D$P1
\$HE
L$LH
L$(H
D$0L
T$0H
t$LL
T$LL
D$LH
D$<A
AWAVM
AUATI
[]A\A]A^A_
fffff.
ATUI
[]A\
fffff.
ATUI
[]A\
fff.
ATUSVH
ZYH9
QRVH
[]A\A]A^
[]A\A]A^
AWAVA
AUATI
[]A\A]A^A_
AWAVI
AUATI
[]A\A]A^A_
[]A\A]A^A_
fff.
AUATI
u)I9,$t
[]A\A]
]A\A]
AWAVI
AUATA
D$81
W@H9P@u
H9P@
D$ I
D$0H
D$,H
L$$D
D$(D9
t$0H
D$(A
T$(L
|$0A
D$,L
D$(A
|$8dH3<%(
H[]A\A]A^A_
[]A\
ffff.
AWAVI
AUATI
D$(1
L$(dH3
8[]A\A]A^A_
<+/u
D$ H
AWAVI
AUATI
[]A\A]A^A_
[]A\A]A^A_
AWAVL
AUATI
\$ H
D$X1
H9\$
~;E1
T$XdH3
h[]A\A]A^A_
ffffff.
AWAVH
AUATI
[]A\A]A^A_
[]A\A]A^A_
t{USH
AWAVI
AUAT
D$h1
|$8H
D$0H
T$0H
T$0M
H;\$
D$8H
H;l$ t
t$(H
H;l$ u
L$hdH3
x[]A\A]A^A_
L$(L
AUATI
[]A\A]
[]A\A]
ATUSH
[]A\
D$pH
[]A\
AVAUATI
]A\A]A^
[]A\A]A^
D$0H
D$0H
fff.
AVAUATUI
F] H
[]A\A]A^
[]A\A]A^
[]A\A]A^
AUATI
[]A\A]
[]A\A]
ffffff.
ATUI
[]A\
[]A\
fffff.
AUATI
[]A\A]
ATUS
[]A\
[]A\
ffffff.
AWAVM
AUATM
[]A\A]A^A_
AUATI
[]A\A]
[]A\A]
[]A\A]
AWAVI
AUATI
[]A\A]A^A_
[]A\A]A^A_
AWAVAUATL
g0USH
o0M9
[]A\A]A^A_
ffff.
AWAVM
AUATI
([]A\A]A^A_
AVAUI
]A\A]A^
AUATUSH
[]A\A]
AUATI
[]A\A]
[]A\A]
t;USH
fffff.
AUATUSH
[]A\A]
[]A\A]
ffffff.
AUATUSH
[]A\A]
[]A\A]
L$HL
AUATUSH
[]A\A]
[]A\A]
AWAVAUATA
L$4L
D$pH
[]A\A]A^A_
t$(H
t$81
\$8H
|$ H
H;\$ A
D$dL
t$8I
D$lH
D$4%
D$HH
D$hH
H;\$ 
L$4L
L$HL
|$(I
L$PH
t$8L
L$8L
T$@A
D$8H
DD$X
D$XA
L$\E9
T$ H
t$8I
t$8A
AWAVI
AUATI
L$ D
D$<L
D$0dH
D$x1
D$`H
D$ 1
D$\H
D$@D
PXte
D$8E
\$`H;\$(A
|$@L
DD$8
D$8A
L$ D
T$<E9
D$@L
|$(H
|$ 1
|$ I
L$8E1
L$8A
|$@E
AXL9
L$xdH3
[]A\A]A^A_
AWAVI
AUATUS
L$hL
D$@L
l$ H
<$/t
l$ 1
D$@H
t$PL
t$(H
D$@H
D$PH
[]A\A]A^A_
\$HH
|$8H
H;D$8
D$ H
D$xH
D$HH
D$|H
D$h%
D$lf.
|$ 1
D$HH
H;D$8H
t$ H
L$hL
L$lL
D$HH
T$8H
t$hL
L$`H
T$0H
XZt.L
D$49
\$4L
t$H1
ffff.
AWAVI
AUATA
L$xH
D$ dH
t$8H
[]A\A]A^A_
H;D$P
D$HH
H;D$PH
D$HL
L$`1
\$`D
D$XH
D$xH
D$0H9
6L;t$0
L$,H
D$@H
L$ 1
C@L9
\$XE
D$\E
K@H9
t(H;O
D$@H
t$`H
L$xH
|$8H
D$@H
L$ 1
L$ 1
t$hL
l$pI9
L$ 1
AYAZH
t$hL
D;|$
AWAVH
AUATI
H;\$
([]A\A]A^A_
[]A\A]A^A_
AWAVAUATI
[]A\A]A^A_
[]A\A]A^A_
[]A\A]A^A_
[]A\A]A^A_
[]A\A]A^A_
AUATI
[]A\A]
ATUSH
[]A\
[]A\
AWAVAUATUSH
EY u
[]A\A]A^A_
AVAU1
ATUI
t$pH
t$pH
D$pH
]A\A]A^
]A\A]A^
]A\A]A^
fffff.
AUATL
[]A\A]
AWAV1
AUATI
[]A\A]A^A_
<nulL
AWAVL
AUAT1
<$du&A
[]A\A]A^A_
[]A\A]A^A_
ffffff.
;CXtHH
fff.
ATUH
[]A\
[]A\
[]A\
ffff.
fffff.
AWAV
AUATI
L$(1
A]A_
L$(dH3
8[]A\A]A^A_
AYAZ
AWAVAUATI
D$81
L$8dH3
H[]A\A]A^A_
L;,$
?L9<$
AVAUATU
]A\A]A^
[]A\A]A^
ffffff.
ATUI
[]A\L
AWAVAUATUSH
[]A\A]A^A_
|$`1
t$`L
T$HH
t$(L
t$ L
t$0L
t$4L
t$@L
t$8L
H9D$(I
H9D$ I
m0L9
T$H1
L$HL
AUAWA
RATI
AWAVAUATI
[]A\A]A^A_
L$hI9
l$ H
\$(I
AXAYL
6L;t$
D$hI
D$pI
D$xI
L$(E1
l$ H
\$(L
ATUSu8L
[]A\L
[]A\L
[]A\
AUATI
[]A\A]
[]A\A]
[]A\L
AWAVAUATI
[]A\A]A^A_
AWAVAUATUSH
[]A\A]A^A_
[]A\A]A^A_
fff.
AWAVAUATI
[]A\A]A^A_
ATUI
[]A\
D$pH
[]A\
[]A\L
AWAVAUATUSH
[]A\A]A^A_
D$`H
L;|$
l$0H
|$(D
t$8I
|$(H
l$0D
t$8H
D$0H9
D$XI
|$8L
|$ H
t$LL
d$(I
l$@I
l$PI9
$$M9
D$(H
H;\$0M
|$8H
l$@D
t$LL
d$(L
l$PH
|$XH9
|$(H
\$XL
|$(H
|$8H
l$@D
t$LL
d$(L
|$8H
l$@D
t$LL
d$(L
D$XI
[]A\L
AUATI
D$X1
L$XdH3
h[]A\A]
l$ I
D$8H
D$8H
D$8H
D$8H
ATUH
[]A\
AWAVI
AUATUS
([]A\A]A^A_
H;,$u
H;,$
AVAUI
 []A\A]A^
fffff.
fffff.
AWAVAUATI
D$,H
L$,L
[]A\A]A^A_
L$,L
D$PH
AYAZ
AUATH
[]A\A]
fffff.
ATUSt8L
[]A\
[]A\
AUATI
[]A\A]
AWAVAUATA
[]A\A]A^A_
T$lL
L$lE
T$lL
H9C@
L$pL
L$ I9
\$0I
|$(H
D$HL
\$PH
l$XL
D$@L;t$@
E;f@
L$8H
L$8u
|$(H
t$xH
|$(H
\$0M
L;d$ I
L$8L
\$(L
T$0E
L;vP@
L;vP@
|$8L
\$(M
L;d$ I
L$8L
\$0L
|$(L
t$ H
D$HH
L$@L
D$HE
H;ZP
D$PH
t$HH
t$HL
H9ZP@
D9n@
D9n@
|$8L
|$(H
|$(H
H9XP@
D9n@w
|$(H
\$0I
H;L$ 
t[L;rPA
H9xPu
H;zPtuM
L;rPu
D$(H
L9T$
\$PH
|$HL
|$(H
|$(L
H;T$ L
L;d$ I
L$(H
H;^P
H;XPu
H;hP
L$(H
H;^P
H;XP
H;hP
$$H;D$ u
H;hPt
H;nP
H;hPt
H;nP
AWAVI
AUATUSH
[]A\A]A^A_
[]A\A]A^A_
ffff.
AWAVAUATUSH
dH3<%(
([]A\A]A^A_
D$(I
l$$9
D$(I
AWAVAUATUSH
l$ L
dH34%(
[]A\A]A^A_
AWAVA
AUATI
D$H1
L$HdH3
X[]A\A]A^A_
ffffff.
AWAVA
AUATI
[]A\A]A^A_
[]A\A]A^A_
AWAVA
AUATI
t_<@
[]A\A]A^A_
[]A\A]A^A_
<*uGA
AVAUI
[]A\A]A^
]A\A]A^
AVAUA
ATUH
[]A\A]A^
]A\A]A^
fff.
H#FXu"H
ffffff.
ATUI
[]A\
ffff.
AVAUI
ATUL
]A\A]A^
]A\A]A^
AVAUI
ATUI
]A\A]A^
]A\A]A^
9]@v
]A\A]A^
ffffff.
ffffff.
fffff.
AWAVL
AUATI
[]A\A]A^A_
[]A\A]A^A_
fffff.
AUATA
[]A\A]
[]A\A]
|$ H
AWAVI
AUATA
([]A\A]A^A_
AWAVE
AUATI
AWAVL
[]A\A]A^A_
D$(1
T$(dH3
AWAVI
AUATH
CPRL
[]A\A]A^A_
xRE1
AWAVE
AUATA
[]A\A]A^A_
ffffff.
AUATI
[]A\A]
AWAVE
AUATI
D$@H9
tuPAWE1
[]A\A]A^A_
L$8j
[]A\A]A^A_
L$8AWI
AXAY
ATUH
D$(1
T$(dH3
0[]A\
CPE1
AXAY
CPZYH
ATUI
u	[]A\
CPZYH
[]A\
ATUSA
[]A\A]A^
CPZYH
[]A\A]A^
AUATI
[]A\A]
CPZYH
AUATI
[]A\A]
CPZYH
ATUH
[]A\
CPZYH
AUATI
C\ t8H
hXutH
hXu_H
[]A\A]
CPE1
ATPH
AUATH
[]A\A]
CPE1
AUATA
CPZYH
[]A\A]
AUATA
[]A\A]
CPZYH
[]A\A]
ATUI
[]A\
CPZYH
ATUI
u	[]A\
CPZYH
[]A\
AUATI
[]A\A]
AWAVAUATI
D$(1
T$(dH3
8[]A\A]A^A_
AUATI
[]A\A]
ATUH
[]A\
ATUS
[]A\
AVAUATUS
Z[]A\A]A^
]A\A]A^
AWAVAUATI
D$x1
E\ t>I
L$PE1
D$ H
L$LH
T$0H
L$(f.
A9o@v
L$(1
^A9o@_
G) ulH
t$(L
?L;|$
L$xdH3
[]A\A]A^A_
DD$ H
L$P1
d$81
UPPL
AYAZ
ED$ 
d$8E
AZA[
AVAUA
ATUE1
D$(1
AZA[M
|$(dH3<%(
0[]A\A]A^
sPQPR1
AVAUI
ATU1
D$(1
L$(dH3
0[]A\A]A^
t$ A
AZA[
H#CXH
AWAVI
AUATI
\$TH
dH34%(
[]A\A]A^A_
T$TH
D$Y@u
D$,L
|$PL
T$0H
d$0L
|$8H
D$T1
@j t
D$Y@
L$,L
t$,H
t$PI9
?L;|$
|$PH
AhH9D$
|$PH
L$,L
|$PH
|$PH
T$,L
A`RH
P RL
ATUM
D$(1
t$(dH34%(
0[]A\
ffff.
ATUI
D$(1
L$(dH3
0[]A\
AWAVAUATI
D$81
t[E1
L$8dH3
H[]A\A]A^A_
AXAYE1
H9D$
EPSL
AVAUI
ATUI
tCE1
[]A\A]A^
[]A\A]A^
]A\A]A^
ATUM
D$(1
t$(dH34%(
0[]A\
ffffff.
ATUM
D$(1
t$(dH34%(
0[]A\
fff.
St*H
fff.
fffff.
t|SH
ffff.
ffff.
fffff.
AUATI
n4SI
]A\A]
[]A\A]
ATUSH
[]A\
D$ H
AUATI
[]A\A]
]A\A]
[]A\A]
[]A\A]
]A\A]
fffff.
t6SH
ffff.
AWAVAUATL
ChE1
[]A\A]A^A_
[]A\A]A^A_
t*SH
D$(1
L$(dH3
ffff.
[]A\
Z[]A\
ffff.
fff.
AVAUI
ATUI
D$H1
D$ H
L$HdH3
P[]A\A]A^
D$4H
D$ I
D$<H9
D$(I
D$DH
D$0I
D$LH
D$8A
D$@L
\$ L
ffffff.
fffff.
ATUSH
P`H9
B`H9
[]A\
AWAVAUATUSH
T$@H
|$(dH
L$TL
D$XL
D$ H
\$(L
|$ H
|$HH
D$8I
D$(H
l$`H
D$(H
AVAT
[]A\A]A^A_
t$ H
t$@H
D$ tpH
T$8L
T$ H
D$ H
D$`H
D$0H
D$0H
D$XH
T$ H
t$ H
D$01
D$0L
L9|$
ATAU1
H;\$
t$01
T$@H
t$ 1
\$ H
D$ H
D$ L
D$0L
t$ H
D$01
D$01
D$01
D$0H
D$ H
D$ H
T$0H
D$01
D$01
ATUSH
D$(1
L$(dH3
0[]A\
fffff.
ATUH
[]A\
ffff.
AUATI
\$PM
l$PI9
t-f.
[]A\A]
AWAVA
AUATI
D$(1
L$(dH3
8[]A\A]A^A_
l$ H
ffffff.
AWAVA
AUAT1
[]A\A]A^A_
[]A\A]A^A_
AVAUA
ATU1
]A\A]A^
]A\A]A^
fffff.
AVAUA
ATU1
]A\A]A^
]A\A]A^
fffff.
AUATI
[]A\A]
[]A\A]
AVAUI
ATUH
[]A\A]A^
]A\A]A^
AWAVL
AUATI
m@t=M
D$0L
L$(H
|$8I
\$0E
t$(M
E0D1
u0t M
\$HtkH
d$@E;ext[I;
SATI
[]A\A]A^A_
[]A\A]A^A_
|$8I
\$0E
t$(L
AWAV
AUATI
l$pdH
D$ I
D$(I
D$0I
D$8I
D$@I
D$HI
D$Xt>
[]A\A]A^A_
ATUI
D$(1
\$@H
D$(dH3
0[]A\
=[	1
=K	1
[]A\
[]A\L
fff.
fffff.
fffff.
AUATL
[]A\A]
]A\A]
fffff.
AUATUSH
[]A\A]
E I9
t!f.
E0I9
[]A\A]
fffff.
WPH9
tGSH
AWAVI
AUATI
t$0H
T$0H
D$Xt
L;kX
D$.E
D$.t
_AXH
kXL;
}XH9
[]A\A]A^A_
ATAVI
kXL;
T$/D
T$ H
T$/D
_AXH
AZA[L
]A\L
PAPI
fff.
fff.
fff.
ffffff.
ffffff.
AVAUI
ATUL
]A\A]A^
]A\A]A^
AVAUI
ATUL
]A\A]A^
]A\A]A^
AVAUI
ATUL
g SH
]A\A]A^
]A\A]A^
AVAUI
ATUL
g0SH
]A\A]A^
]A\A]A^
ffff.
ATUL
Cx9E@u
H9EHu
[]A\
ffff.
AWAVI
AUAT
t+PL
[]A\A]A^A_
[]A\A]A^A_
fffff.
AUAT1
D$81
D$8dH3
H[]A\A]
ATUI
[]A\
AVAUATUH
[]A\A]A^
[]A\A]A^
]A\A]A^
AVAUATUL
g`SH
D$X1
\$ H
T$(H
D$ H
T$0H
T$8H
L$XdH3
`[]A\A]A^
H;}(u
AUATUSH
,$tk
l$(I
H;h(u
[]A\A]
AVAUI
ATUI
]A\A]A^
ffff.
AUAT
[]A\A]
[]A\A]
fffff.
AUATI
[]A\A]
[]A\A]
AVAU1
]A\A]A^
]A\A]A^
]A\A]A^
ATUS
[]A\
[]A\
[]A\
[]A\
AWAV
AUATI
\$ H
[]A\A]A^A_
ATUL
=a~1
=!~1
[]A\
[]A\
[]A\
AUATL
[]A\A]
]A\A]
ffff.
AWAVAUATUSH
\$(1
l$ L
t <#L
#t#H
t$(dH34%(
8[]A\A]A^A_
fffff.
AWAV1
AUAT
[]A\A]A^A_
[]A\A]A^A_
[]A\A]A^A_
AUAT1
[]A\A]
={`1
=E`1
=	P1
=z_1
=B[1
ffffff.
AWAVAUATUSH
[]A\A]A^A_
H9T$
AUATL
oPUSH
_PL9
[]A\A]
[]A\A]
ATUL
gPSH
_PL9
[]A\
[]A\
AWAVAUATI
\$`I
F(L9
[]A\A]A^A_
ffffff.
AWAVL
AUATH
[]A\A]A^A_
ATUH
[]A\
AWAVE
AUATI
=v/	
([]A\A]A^A_
/etc/lvmH
=Oz1
5(z1
=/Y1
AWAVI
AUATUSH
[]A\A]A^A_
ffffff.
AWAVAUATUSH
4$dH
L$81
@t5H
D$ H
D$0E1
SuXH
D$(L
L$8dH3
H[]A\A]A^A_
t$(L
D$ 1
D$ L
D$ L
D$ L
AVAUI
ATUH
[]A\A]A^
[]A\A]A^
u,HcE
ffff.
AWAVI
AUATI
C(t}H
[]A\A]A^A_
uGHcE
{ Hc
AUATA
~ dH
D$(1
D$(dH3
8[]A\A]
Hc:H
AWAVAUI
L$ H
f9{"w
f9{"
f9{"
D$(H
L$ H
[]A\A]A^A_
[]A\A]A^A_
AWAVLc
t$XL
_AXD
L$PA
Y^xJH
[]A\A]A^A_
AWAVAUATUSH
Hco(dH
[]A\A]A^A_
d$0L
D$ L
d$HL
T$,L
#uBL
 t#H
d$,L
t$f;P
IcV(H
fff.
ASARRH
fffff.
ATUA
XZ[]A\
AWAVI
AUATI
l$PM
[]A\A]A^A_
[]A\A]A^A_
[]A\A]A^A_
AYAZ
_AXL
AWAVAUATUSH
d$`M
([]A\A]A^A_
IcL$(H
t$(H
AWAVAUATUSH
Hc_(dH
[]A\A]A^A_
|$(j
 t:H
ffffff.
AWAVA
AUATI
[]A\A]A^A_
AVAUI
ATUSH
[]A\A]A^
AUATUSH
D$(%
[]A\A]
$H9C
D$@H9E
tkSH
fffff.
AUATI
D9 t#H
[]A\A]
[]A\A]
AUATI
[]A\A]
AWAVM
AUATI
[]A\A]A^A_
T$`;D$h
ATUH
L$`H
[]A\
ATUA
[]A\
USHc
dH3<%(
fffff.
AWAVI
AUATL
-no0
USHc
XZt'L
[]A\A]A^A_
AWAVH
AUATI
[]A\A]A^A_
ffff.
AWAVAUATA
H;8t	
([]A\A]A^A_
AWAVAUATI
-Fh0
[]A\A]A^A_
AVAUATU
[]A\A]A^
AVAUATUI
[]A\A]A^
[]A\A]A^
ATUI
[]A\
[]A\
fff.
AVAUHc
ATUI
[]A\A]A^
AWAVI
AUATL
-N_0
USHc
 ZYt'L
@tPH
[]A\A]A^A_
AWAVI
AUATL
USHc
 ZYt'L
@tXI
[]A\A]A^A_
AUATH
=:P1
[]A\A]
[]A\A]
AWAVI
AUATL
USHc
ZYt'L
[]A\A]A^A_
fffff.
AWAVI
AUATL
USHc
ZYt'L
[]A\A]A^A_
uDHcQ
AWAVI
AUATL
USHc
ZYt'L
B tN
[]A\A]A^A_
AWAVI
AUATL
-.T0
USHc
ZYt'L
[]A\A]A^A_
fffff.
AWAVAUATUSH
52R0
dH34%(
[]A\A]A^A_
HcC(H
AXAYH
AWAVL
AUATLc
[]A\A]A^A_
D$ @
AUATUSH
[]A\A]
ffff.
ffff.
AUATI
[]A\A]
ATUSH
ATUSt?H
[]A\
[]A\
AVAUATUStsH
]A\A]A^
]A\A]A^
AVAUI
ATUI
]A\A]A^
]A\A]A^
AUATI
[]A\A]
[]A\A]
ATUI
AVAUI
ATUI
[]A\A]A^
]A\A]A^
[]A\A]A^
=Hn1
=1n1
ffffff.
AWAVAUATI
[]A\A]A^A_
D$ H
D$8%
ffffff.
AUATI
[]A\A]
=)h1
AVAUATI
USu0H
=>f1
[]A\A]A^
=he1
[]A\A]A^
=id1
[]A\A]A^
AUATA
[]A\A]
D$(%
AWAV1
AUATI
H9\$
([]A\A]A^A_
AWAVAUATUSH
5A]1
[]A\A]A^A_
l$ L9
D$8%
ATUH
[]A\
ATUH
[]A\
=1V1
=HV1
AVAUATUI
[]A\A]A^
[]A\
=[S1
[]A\
fffff.
t<USH
fff.
=<R1
AUATUS
]A\A]A^
=pQ1
=4Q1
AVAU
ATUSH
=4P1
=#P1
d$ H
]A\A]A^
[]A\A]A^
]A\A]A^
=YM1
AWAVL
AUATA
H9D$(
[]A\A]A^A_
AUATI
=+J1
H9D$(t?H
[]A\A]
ATUSH
[]A\
[]A\
ffff.
AWAVAUATA
[]A\A]A^A_
AWAVI
[]A\A]A^A_
fffff.
AWAVA
AUATA
AUUI
dH34%(
[]A\A]A^A_
H9D$8
fff.
ffffff.
AUATUSH
([]A\A]
UAUI
AWAVAUATI
[]A\A]A^A_
AWAVI
AUATUSH
D$81
D$ I
T$0H!
T$0L
|$0H
L+l$(I
\$8dH3
H[]A\A]A^A_
D$(H
H+|$(I
ffffff.
AWAVAUATUSH
,$	H
[]A\A]A^A_
D$0H
PAT1
ffffff.
AUATUSH
[]A\A]
ffffff.
G$9G H
AWAVI
AUATL
[]A\A]A^A_
G$9G H
ATUS
[]A\
[]A\
AWAVA
AUATI
[]A\A]A^A_
dH34%(
T$@H
ffffff.
AWAVE
AUATI
t$`H
([]A\A]A^A_
AWAV
AUATUSH
t$ H
dH34%(
[]A\A]A^A_
d$01
|$0 
|,0 t
T,2H
T,6H
T,4H
T,8H
T,6H
T,=H
T,2H
D$ H
T,4H
L$8H
thHc
tYHcO
tIHcO
t9HcO
t)HcO
ffff.
t9HcU
ffffff.
AWAVAUATI
tWA)
dH3<%(
[]A\A]A^A_
HcT$
t5HcW
t)HcW
t HcW
AWAVAUATI
dH34%(
[]A\A]A^A_
D$ L
UAWI
l$8H
AWAVI
AUAT1
D$ H
A[A\u.
[]A\A]A^A_
AYAZt
D$LH
D$pH
D$xH
D$ H
D$hH
D$Xt
T$PH
L$h1
T$PH
A]A^
T$`H
T$`H
D$hH
|$P1
T$ H
t$hM
t$x1
L$PH
t$01
T$(H
ffffff.
ffffff.
ffffff.
ffffff.
ffffff.
ATUH
u%[]A\
ffff.
ffff.
='o	
ffff.
AWAVAUATUSH
D$X1
PAVL
AUAW1
D$XdH3
h[]A\A]A^A_
XZH9
C Y^H
AVAUATUSH
D$X1
D$XdH3
`[]A\A]A^
ATUSH
D$H1
L$HdH3
P[]A\
AUATH
D$(1
sPH	
ASAPL
ARAQL
AUPQ1
sHQ1
D$(dH3
8[]A\A]
AWAVI
AUATH
~ US
l$`dH
D$01
_AXH
t$ 1
A[XI
GhI9
D$PH
D$PL
t$HL
L$PD9Kpt!L
L$L1
T$0E
L$DE
[]A\A]A^A_
D$PL
AYAZ
D$PL
D$PL
L$8L
D$0E
T$,1
T$$1
D$PL
fff.
ATUSH
_AXH
XZ[]A\
]A\1
ATUSH
]A\A]A^
fffff.
AUATUSH
D$H1
_AXH
D$HdH3
X[]A\A]
AWAVAUATUSH
D$h1
t'H=
d$ H
T$(1
t$4VD
T$DH
ARAUAWP
D$hdH3
x[]A\A]A^A_
ATUSH
 []A\
_PH9
_`H9
fff.
AUATI
t$(H
T$0H
L$8L
D$@L
L$Ht7
)D$P
)L$`
)T$p
[]A\A]
fffff.
ffff.
ATUI
[]A\
[]A\
fff.
ATUA
[]A\
[]A\
AUATUSH
[]A\A]
AVAUATUSH
]A\A]A^
[]A\A]A^H
AVAUI
ATUH
[]A\A]A^
AUATI
o dH
[]A\A]
AWAVAUATI
[A\A]A^A_]
u)E1
D$ H9
AUATI
[]A\A]
AWAVAUATUSH
[]A\A]A^A_
[]A\A]A^A_
[]A\A]A^A_
fffff.
AWAV
AUATUSH
([]A\A]A^A_
[]A\A]A^A_
AWAVAUATUSH
D$0L
L$,H
T$(H
T$(L
[]A\A]A^A_
t H;P
AWAVAUATUSH
[]A\A]A^A_
ATUSH
[]A\
fffff.
ATUSH
[]A\
fffff.
AWAVAUATUSH
[]A\A]A^A_
AZA[L
T$ L
D$8%
L$ 1
AXAY
t>VPH
PAUM
ATUS
Y[]A\
ATUSH
ffff.
AUATUSH
[]A\A]
C t_L
AUATA
[]A\A]
t,SH
AWAVA
AUATA
[]A\A]A^A_
ATUH
t$SH
fffff.
AVAUA
ATUI
]A\A]A^
]A\A]A^
D$81
T$ H
D$0H
D$ H
@ H9
L$8dH3
AWAVI
AUATA
D$(1
L$(dH3
8[]A\A]A^A_
rXuvH
[]A\
AUATA
[]A\A]
AVAUL
ATUI
D$@1
t$8H
D$0H
\$ I9
L$8dH3
@[]A\A]A^
ATU1
[]A\
ATUSH
@49C4
[]A\
AUATI
IcT$0
[]A\A]
ffff.
fff.
AUATUSH
D$h1
d$ H
D$pH
|$hdH3<%(
[]A\A]
ATUI
T$0H
L$8L
D$@L
L$Ht7
)D$P
)L$`
)T$p
D$ H
[]A\
AUATI
L$8L
D$@L
L$Ht7
)D$P
)L$`
)T$p
D$ H
[]A\A]
ATUI
T$0H
L$8L
D$@L
L$Ht7
)D$P
)L$`
)T$p
D$ H
[]A\
fffff.
fff.
AVAUI
ATUI
[]A\A]A^
AWAVAUATL
[A\A]A^A_]
AWAVAUATA
D$(1
T$(dH3
8[]A\A]A^A_
d$ H
AWAVAUATUSH
nXdH
NC0L
[]A\A]A^A_
D$$A
T$ 1
fff.
AWAVI
AUATH
S0tdH
L;l$
[]A\A]A^A_
AVAU
ATUI
[]A\A]A^
ffffff.
AWAVAUATUSH
D$H1
D$ 1
H;l$
T$HdH3
X[]A\A]A^A_
fffff.
AWAVAUATI
D$X1
\$XdH3
h[]A\A]A^A_
AUATI
[]A\A]
[]A\A]
AUATI
[]A\A]
[]A\A]
AVAUA
ATUH
[]A\A]A^
[]A\A]A^
[]A\A]A^
AWAVA
AUATUSH
[]A\A]A^A_
[]A\A]A^A_
H9J@u
H9J@t
2H91t
ffffff.
AVAUATUSH
]A\A]A^
]A\A]A^
ffff.
ATUI
D$4H
AXAY
[]A\
D$4H
Z[]A\
[]A\
AVAUI
ATUSH
[]A\A]A^
PAVL
ffff.
AVAUI
ATUH
dH34%(
 []A\A]A^
ATUH
[]A\
[]A\
ffff.
AWAVI
AUATUSH
~XdH
D$H1
D$(H
\$ L
\$ L
T$0H
\$8L
L$HdH3
X[]A\A]A^A_
vKUS
AWAVI
AUATA
l$8L
XZE1
[]A\A]A^A_
D$(I
D$0I
D$8I
L+d$(H
L;d$ 
D$ I9
D$ H
H+l$
|$0H
D$ H
_AXD
L$ I
t$ 1
D$(H
d$ H
L$ H9
Hct$
|$8L
T$0H
t$0H
T$(H
t$0E
t$0H
ffff.
AWAVI
AUATI
[]A\A]A^A_
[]A\A]A^A_
AWAVAUATL
f USI
[]A\A]A^A_
t	H9
t$8H
T$@H
D$0H
t$HA
]A\A]A^
[]A\A]A^
t$HA
]A\A]A^
ffffff.
AVAUA
ATUH
[]A\A]A^
fffff.
AVAUATUH
[]A\A]A^
ATUI
[]A\
AVAUI
[]A\A]A^
D$(t
M9l$
[]A\A]A^
[]A\A]A^
AWAVAUATUSH
[]A\A]A^A_
AVAUI
I+\$
AXAYI
[]A\A]A^
AWAVL
r(AUATI
#orphansH
_lvmH
[]A\A]A^A_
J@H;J(t
l$PH
L<PH
 LVM2 x[UH
5A%r0N*>I
[]A\
[]A\
ATUH
[]A\
ATUI
AWAVL
AUAT1
H9\$
u;I9
H9\$
AUAWM
[]A\A]A^A_
fffff.
AWAVI
AUATI
l$(L
[]A\A]A^A_
D$(I
AWAVAUATUSH
D$(1
H9r@u
H9r@t6H
\$(dH3
8[]A\A]A^A_
D$$H
M9P@u
M9P@t
ffffff.
AWAVH
AUATUSH
oHdH
H;z@u
H9z@t6H
([]A\A]A^A_
K(H9
sqH)
txI9}
AWAVI
AUATI
D$(1
|$ I
|$ WA
ATUPQ1
\$(dH3
8[]A\A]A^A_
ATUP1
AYAZ
AVAUM
ATUI
[]A\A]A^
[]A\A]A^
AWAVE
AUATI
[]A\A]A^A_
ffff.
AWAVAUATUSH
D$H1
D$0H
L$HdH3
X[]A\A]A^A_
D$,H
AWAVAUATI
GhdH
L$ H
l$@L
?L9|$
[]A\A]A^A_
L$ H
AWAVI
AUATI
l$pI
D$HA
l$0I
L$ H
t$81
L$8H
T$@RL
dH3<%(
[]A\A]A^A_
AWAVAUATI
t$`L
\$hL
[]A\A]A^A_
t$pE1
AWAVH
AUAT
D$ H
55#/
[]A\A]A^A_
D$@L
|$HH
D$(H
D$PH
D$8H
D$ H
D$`H
d$H	
T$ H
d$P	
t$8H
H9T$
H9T$
t$(H
t$@H
L$8L
AUATA
[]A\A]
[]A\A]
[]A\A]
AWAVE
AUATI
D$`M
[]A\A]A^A_
T$`H
AWAVI
AUATI
t$x90
L$`AW
[]A\A]A^A_
T$xH
L$hE1
AVAUA
ATUH
[]A\A]A^
AWAVAUATI
[]A\A]A^A_
AWAVAUATM
D$(1
T$ H
L$(dH3
8[]A\A]A^A_
D$ H
T$ u
D$ H
T$ t
t$ H
AUATUSH
]A\A]
]A\A]
[]A\A]
AWAVM
AUATI
D$(1
D$ H
D$ H
_AXH
L$(dH3
8[]A\A]A^A_
AYAZ
H	CXI
H	CXI
ffff.
AWAVAUATUSH
D$H1
T$0H
t$0H
|$(H
T$8H
D$F H
D$@H
L$8H
t$(H
|$$M
T$ H
T$ H
L$HdH3
X[]A\A]A^A_
L$8H
AXAY
L$@H
AZA[
L$8H
ffffff.
AWAV
AUATI
T$8H
T$0H
T$8H
T$(H
D$@ZYv/L
[]A\A]A^A_
L$0H
T$(H
D$HI
D$@I
AXAY
fff.
AWAVI
AUATUSH
D$h1
D$PH
D$TH
D$`H
D$(H
D$XH
T$(H
t$`H
\$8H
t$LL
L$TH
D$|L
L$8H
T$0H
Q 9P v
L$ H
_AXL
L$hdH3
x[]A\A]A^A_
T$`H
D;|$`tZL
T$XH
|$ H
AUATUSH
[]A\A]
[]A\A]
[]A\A]
[]A\A]
AWAVM
AUATI
A9l$@
[]A\A]A^A_
D$@9
fffff.
LVM2 001H
ffff.
AVAUL
ATUE1
 []A\A]A^
AWAV
AUATI
D$X1
T$XdH3
h[]A\A]A^A_
AWAV
AUATUSH
LVM2 001H
l$hL
l$pL
D$0L
|$`H
|$hH
|$pH
t$0H
l$ H
T$\D
\$XH
t$PL
t$hATI
L$T1
[]A\A]A^A_
l$hL
ffffff.
[]A\
ffff.
ATUI
[]A\
AWAVAUATI
t$PL
[]A\A]A^A_
[]A\A]A^A_
ATUI
[]A\
D$X1
D$XdH3
`[]A\
fff.
AWAVAUATUSH
t$ H
L$0H
T$(H
6XZM9
[]A\A]A^A_
|$ H
D$(H
AYAZI9
fffff.
ATUL
[]A\H
ATUI
ATUH
[]A\
AWAV
AUATI
|$ H
uxH9]
[]A\A]A^A_
ffffff.
AVAUI
g`US
[]A\A]A^
AVAUATUSH
LABELONEL
AVS1
[]A\A]A^
ATUH
dH34%(
[]A\
AWAVI
AUAT
[]A\A]A^A_
ffff.
dH34%(
ffffff.
[]A\
ffffff.
AWAVI
AUATI
[]A\A]A^A_
ffff.
AWAVAUATUSH
[]A\A]A^A_
AWAVAUATUSH
[]A\A]A^A_
AVAUATUSH
]A\A]A^
]A\A]A^
AUATI
CXt:H
[]A\A]
[]A\A]
ffff.
AWAVAUATA
[]A\A]A^A_
fff.
fffff.
fffff.
fffff.
ffff.
ffff.
fffff.
fff.
AWAVAUATA
L$(M
D$0H
D$((
D$,0
[]A\A]A^A_
D$8(
D$<0
D$@H
D$HAYAZH
L$(L
D$((
D$0H
D$,0
\$@H
        
Zt`H
D$0H
D$((
D$,0
D$8Hc
D$((
D$,0
D$0H
D$8H
(H;*
L$HAVI
A^XH
D$((
D$,0
D$0H
D$8H
|$@H
D$((
D$,0
D$0H
AUATA
!tvH
([]A\A]
fff.
AWAVA
AUATM
D$XL
[]A\A]A^A_
wgL9
ATUH
@u!H
[]A\
[]A\
Z[]A\
CXtXH
fff.
AUATUSH
C\ uvH
[]A\A]
[]A\A]
AVAUATUH
H	EX
H!EXf.
I	FX
[]A\A]A^
ffffff.
H#QXH
AVAUI
ATUI
=~C	
 []A\A]A^
ATUSH
G] t
 []A\
H	CX
H!CXH
AWAVA
AUATI
D$H1
d$ H
|$HdH3<%(
X[]A\A]A^A_
ATUH
D$81
T$8dH3
@[]A\
D$) t;H
fff.
 t7H
D$(1
GPE1
|$(dH3<%(
ET$ 
ATUH
uX[1
pP]A\
ffffff.
FHdH
fff.
ATUI
[]A\
ffffff.
H#WXH
ffffff.
D$(1
GPE1
T$(dH3
D$(1
GPE1
T$(dH3
t^USH
@) t
ffff.
AUATUSH
C\ t
[]A\A]
[]A\A]
t}ATU1
[]A\
ffffff.
fff.
AUATUSH
([]A\A]
<(AA
ATUA
[]A\
AUATI
C	-H
([]A\A]
C	kH
D$$E
EXt`
ATUI
D$X1
ZYt9H
T$XdH3
`[]A\
AUATI
[]A\A]
=Iv/
%pv/
ATUL
[]A\
ffff.
AVAUA
]A\A]A^
]A\A]A^
CXutH
fff.
AWAVI
AUATI
sXt{L
[]A\A]A^A_
cXu;H
PXt6L
[]A\A]A^A_
ffffff.
9A@v 
9A@w
AWAVAUATUSH
9]@vh
D$@H
[]A\A]A^A_
[]A\A]A^A_
[]A\A]A^A_
ffff.
AWAVA
AUATI
A9^@
T$PPL
t$HH
A9^@
6L;t$
[]A\A]A^A_
[]A\A]A^A_
AWAVI
AUATI
_tGH
_AXE1
[]A\A]A^A_
AVAUA
ATUSL
]A\A]A^
CXt%f
]A\A]A^
fffff.
9H9~
ATUH
[]A\
ATUH
@uqH
[]A\
AWAVAUATUSH
D$H1
L$,M
L$ D
D$@H
\$HdH3
X[]A\A]A^A_
<@t4E
H9\$
H;\$
|$0H
T$8H
t$0H
L$LH
51~	
5B}	
ffff.
AWAVA
AUATI
WAVRPH
PATH
52{	
([]A\A]A^A_
VAVAUPH
PATL
5jz	
5=z	
VAVAUPH
5lz	
VAVRPH
AWAVI
AUATL
f USH
H90u
([]A\A]A^A_
ffffff.
AWAVI
AUATI
 tdH
dH3<%(
[]A\A]A^A_
L$(L
d$`H
AUATI
[]A\A]
5Hu	
AWAVAUATUSL
l$`D
M$D+L$
t	D9
;]@s
([]A\A]A^A_
L$LH
([]A\A]A^A_
5~r	
5)r	
fff.
D$81
t$ H
D$PH
t$8dH34%(
5 q	
fffff.
AWAVAUATI
D$(1
5Oo	
5.o	
L$(dH3
8[]A\A]A^A_
D$PH
t$HL
H#EXH=
5Hj	
5Xi	
57i	
5}h	
5Xh	
5hg	
58f	
5>e	
50d	
5Mc	
5ha	
58a	
t$$H
5M_	
=g^	
58^	
5*^	
5^\	
5"\	
5^[	
5 [	
5{Z	
fff.
ATUH
t#H;p
HHR1
[]A\
[]A\
5JY	
fff.
t4H;s
t H9s
HHR1
HHR1
AUATUSH
[]A\A]
[]A\A]
ATAUI
5QW	
fffff.
ATUI
D$PH
D$PH
[]A\
AWAVAUATUSH
D$hA
D$pA
D$xA
t$`L
([]A\A]A^A_
5WT	
H	CX
5 T	
ffffff.
ATUI
[]A\
5`R	
AVAUM
ATUH
L	uXL
[]A\A]A^
5hQ	
[]A\A]A^
58Q	
[]A\A]A^
ffffff.
ATUH
5xP	
[]A\
AVAUI
[]A\A]A^
5tN	
fffff.
AWAVAUATI
D$(H
D$8dH
T$ H
T$DH
D\$D
L$@E
D$@I
D$8H
GPt#H
x E1
D$xH
T$(H
,$I9
5 I	
5aH	
D$HH
t$hA
GX+D$lM
D$l1
B$A9
B A9
|$`H
d$`L
E I9
|$`L
L$ QP
L$`H
D$TI
t#H9P
L$@E
t$pH
;H9:
\$8A
C I9
L$(E
tl;D$
D$p1
A+w(
L$@9
D$P1
t$(H
D$@D
9t$T
D$HPD
L$dH
5$>	
|$0L
 t:I
\$XH
AZA[L
\$XH
D$P1
t$HD
5_<	
5@<	
dH3<%(
[]A\A]A^A_
9T$P
\$(E
D$@9
D$P1
D$XD
|$HH
\$XH
L$H1
D$P1
9L$@
T$(E
5P8	
5'8	
D$@;D$
9L$l
L$lA
+D$lD
D$hA;G
|$x1
T$0I
5:5	
T$@A
|$ L
+D$lE1
\$PI
t$8I
T$XA+W V
L$TH
5]4	
QE+O
\$0D
A+_0
t$(E
5l3	
L$HH
+D$lE
5,2	
D$xH
|$x1
D$xL
AZA[L
5./	
A^XL
5i.	
D;d$
tlA9
5C,	
5$,	
w09w
5Y+	
55+	
\$0A
5C)	
t$ L
A[[L
fffff.
AWAVAUATUSH
L$LL
5o'	
5P'	
5/'	
[]A\A]A^A_
L9t$
5O&	
5&&	
5u%	
ffff.
AUATI
[]A\A]
fffff.
ATUH
D$(1
5[$	
\$(dH3
0[]A\
ATUI
ATUL
D$ 1
5B#	
 []A\
AWAVAUATI
V@E1
E9~@
5y!	
[]A\A]A^A_
tzE1
E9~@vfD
AWAVI
AUATUSH
D$X1
\$XdH3
h[]A\A]A^A_
F\ u\L
w	A9
<$H)
D$ A
D$ 1
D$ 1
t$TL
<$H)
T$TH
D$(u
D+d$(H
e(E)
e(XZD9d$
D$HH
D$ PAT1
E(A9
D$4H
L9|$
t$HE1
\$DA
D;d$4
?L;|$
\$DL
l$(E1
9\$4
A]A_
AYAZ
AYAZ
L$(9M(
E(A9
L$ D
D$ D
m(A_ZA)
D$4H
\$DL
t$HA
E(E)
\$DD
t$HH
l$(A)
H@+O
T$(D
e(Y^
D+d$
A^A_
AWAVI
AUATI
([]A\A]A^A_
AWAVAUATA
AWPj
w D)
([]A\A]A^A_
([]A\A]A^A_
([]A\A]A^A_
[]A\A]A^A_
H!EXH
AWAVI
AUATI
FptOI
D$ I
D$(I
D$0I
D$8I
D$@I
[]A\A]A^A_
fff.
H	CX
ffff.
AWAVAUATUSH
E9g$
 tsI
E;w@sn
[]A\A]A^A_
A)o$A)_DA)
AZA[L
H!VXH
fff.
ATUSD
H!CXH
[]A\
[]A\
fffff.
AVAUATL
$@USI
tYD;mD
D;mDuz
[]A\A]A^
D;mDu
teD;mD
AUATUH
[]A\A]A^
AWAVL
AUAT
D$PD
T$,ARAWAVAUSj
L$XL
;]@sH
[]A\A]A^A_
[]A\A]A^A_
[]A\A]A^A_
AWAVH
G`AUATI
E9|$
[]A\A]A^A_
H;l$
D$ L
KX@H
AWAVE
AUATI
[]A\A]A^A_
D;}x
L	bXH9
D;l$
D9l$
AWAVI
AUATA
L$ H
[]A\A]A^A_
I#FXH
D$$A
F] t
\$(I
t$$H
t$$H
L$ H
\$(D
F] t
FXuyL
AXu[E
AWAVA
AUATI
D$H1
\$HdH3
X[]A\A]A^A_
L$ E1
L$ E
D$8E
AWAVI
AUATA
[]A\A]A^A_
AWAVI
AUATH
nPdH
([]A\A]A^A_
AWAVI
AUAT1
|$(H
v@E1
L$ A
C D9
[]A\A]A^A_
6L;t$
|$(H
[]A\A]A^A_
L$ I
AWAU1
AWAV1
AUATI
|$0L
D$(L
D$(I9
AXAY
A9_@
D$PH
|$ L
A9_@
?L;|$
[]A\A]A^A_
AWAVI
AUATI
[]A\A]A^A_
ffff.
AVAUI
ATUI
]A\A]A^
H#p(H
A\A]A^
AUATL
D$ 1
_AXH
XZE1
([]A\A]
AWAVI
AUATI
D$0H
AXAY1
[]A\A]A^A_
EXuaH
T$ H
D$ H
fff.
AWAVAUATUSH
D$(1
t$`I
l$`D
l$`I9
t$`H
E9t$
L$(dH3
8[]A\A]A^A_
D$ L
AWAVAUATI
|$@H
L$HL
L$HH
D$@I9
AXAY
d$8I
E;g@
y@H9~@u
d$(L
I;l$ 
M@A9
L$ A
h[]A\A]A^A_
d$(M
E;g@
?L9|$0
|$XL
D$hZYH
L;|$X
D$PA
A9o@
H;z@u
D$ H
AVAU
L$H1
h[]A\A]A^A_
D$PH
|$ H
D$8I
|$ E
L$0H
L$0L
T$01
\$xL
|$PL
T$PA
GDE1
?L;|$X
AWAVAUATUS
AVATI
I!GX
dH34%(
[]A\A]A^A_
AWAVI
AUATE
T$(H
T$(H
E9g@w
t$,L
|$ E
L$$H
D$(H
w@E1
D$(D
[]A\A]A^A_
m@E1
AZA[j
D9e@
A_XD
AXE1
AWAVAUATE
ATPAV
[A\A]A^A_]
T$0A
T$$)
AYAZH
AWAVAUATUSH
D$h1
L$HH
D$(L
_AXD
SLA+
D$\ t
\$hdH3
x[]A\A]A^A_
D$\ tK1
E\ H
D$8H
D$(u
D$ H
D$0H
L$8QAW1
s AP
|$0W
9T$ 
T$0A
D$(L
D$ H
D$01
PAW1
D$XuoL
L$HL
|$@E1
D$@E
T$HL
L$@E
D$Xt
D$ H
D$ L
PAW1
AYAZ
+s(L
H	CX[
AWAVI
AUATUSH
E9gp
GpXE
WtI9
D$] 
D;Hpt(L
MtP1
_AXH
OpAPA
G|WH
H	EXE
H	EXI
L$(1
D$\ 
D$\ 
EY@L
\$ I
wPE1
[]A\A]A^A_
H	EX
EY@L
H!EX
D$ A
D$4A
D$8A
t$8j
D$Xt
AYAZ
l$@H
fffff.
ATUH
[]A\
CXf.
[]A\
[]A\
L$ L
AUATI
[]A\A]
fffff.
AWAVAUATUSH
H;\$
WAV1
AZA\A
A[A]
GXuG
AYAZ
I;l$P
t$ L
T$ A
D$$H
([]A\A]A^A_
H;SP
uPH9wP
D9{@
H;\$
H;h8t
H;h0u
AYAZ
H9X 
AQPP
D$$P1
PAW1
D9x(
A_XA
A\A]A
AXAY
AYAZ
L$ H
D$$AQ
AYAZ
MHPL
A]A_
EXE1
A\A]
AWAVI
AUATA
h A9
C@PD
A)D$D
CDE1
A)L$$
pHAVAU
C PH
D;k@
[]A\A]A^A_
AVAU
fffff.
ATUI
[]A\
[]A\
fff.
AWAVAUATI
D$81
B8H9
T$ L
D$(1
A9_@vw
L$8dH3
H[]A\A]A^A_
fffff.
AUATL
9]@v8
9]@w
[]A\A]
fffff.
ATUI
WXdH
 []A\
AWAV
AUATI
^_E1
A9_@
A9_@ZYw
?L;|$
[]A\A]A^A_
AWAVA
AUATE1
Y^E1
[]A\A]A^A_
AWAVA
AUATA)
\$81
\$8dH3
H[]A\A]A^A_
PAUL
CHtdH
ffff.
AWAVL
AUATUSH
G@H9E
[]A\A]A^A_
AWAVAUATI
[]A\A]A^A_
ATUSH
Y[]A\
ffffff.
=:C.
AUATI
[]A\A]
[]A\A]
[]A\A]
[]A\A]
ffffff.
AVAUI
ATUI
[]A\A]A^
]A\A]A^
AUATI
[]A\A]
AUATL
[]A\A]
ATUSH
[]A\
[]A\
^[]A\
Z[]A\
ATUSH
[]A\
[]A\
[]A\
Z[]A\
ATUI
[]A\
fff.
ATUI
[]A\
[]A\
[]A\
ffff.
ffffff.
]A\A]
[]A\A]
ffffff.
AVATSE
[A\A^]
[A\A^]
tLH)
[A\A^]
[A\A^]
ATUI
t:f.
[]A\
[]A\
ffff.
H;A@u
fff.
AUATI
[]A\A]
[]A\A]
Y^E1
[]A\A]
fff.
ATUH
[]A\
[]A\
fff.
ATUH
[]A\
fff.
H;p@u
H9p@t
fffff.
ATUH
G H9
G H9
[]A\
[]A\
AWAVH
AUATI
[]A\A]A^A_
H;D$
$$M9
$$I9
ffff.
St/H
ffffff.
ATUL
G H9
G H9
[]A\
[]A\L
ATUL
[]A\
AVAUI
ATUH
[]A\A]A^
uPM9
t$HH
$$M9
[]A\A]A^
[]A\A]A^
ffff.
ffff.
StRH
[]A\
[]A\
ffffff.
AWAVAUATI
tKM9
[]A\A]A^A_
fff.
AWAVAUATI
[]A\A]A^A_
s@E1
AWAVAUATI
EXY^
[]A\A]A^A_
ffff.
AWAVI
AUATUSH
[]A\A]A^A_
AUATI
]A\A]
[]A\A]
[]A\A]
AWAVAUATUSH
D$X1
O@H;J@u
H9J@
t$XdH34%(
h[]A\A]A^A_
ffff.
X XZH
wt7L
fffff.
fffff.
AUATI
[]A\A]
t.USH
AWAVI
AUATL
D$`1
AYAZ
CHI;F
_AXH
L$XdH3
h[]A\A]A^A_
L$pH
L$xH
AWAVAUATUSH
t$(H
\$pL
d$xD
t$ L
8[]A\A]A^A_
[]A\A]A^A_
AVAUI
ATUH
[]A\A]A^
[]A\A]A^
Z[]A\A]A^
AWAVAUATI
[]A\A]A^A_
A9^@
fffff.
AVAUL
ATUSH
[]A\A]A^
AUATH
t$XH
]A\A]
[]A\A]
[]A\A]
[]A\A]
ATUI
AUATI
H;J@u
H9J@t$H
[]A\A]
[]A\A]
fffff.
AWAVAUATUSH
D$81
D$`1
D$0H
D$0H
L$8dH3
H[]A\A]A^A_
t$01
D$0H
T$,L
AUATUSH
[]A\A]
ATUH
 []A\
ffff.
AWAVI
AUATE
[]A\A]A^A_
ATUH
[]A\
fffff.
AUATUSH
A I9
4$H9
Y H9
Q H9
([]A\A]
AVAUE
ATUI
]A\A]A^
]A\A]A^
]A\A]A^
AWAVAUATUSH
H9\$
[]A\A]A^A_
[]A\A]A^A_
fff.
AUATUS
[]A\A]
AWAVAUATI
[]A\A]A^A_
AWP1
H0I9
P0I9
[]A\A]A^A_
ATUH
[]A\
fffff.
AUATUS
[]A\A]
[]A\A]
[]A\A]
ffffff.
AUATI
t_L;#tRH
[]A\A]
[]A\A]
ffff.
St*H
=UK	
ffff.
AWAVI
AUATUS
XZL9
l$`E1
AZA[1
AXAY
|$PH
H;\$
^_L9
D$ H
D$`H
D$(H
D$0f
D$ H
A[]1
AYAZ
H;\$
T$8D
|$HH
|$@H
|$PH
|$XH
[]A\A]A^A_
t$8H
PAUL
D$ H
l$`I
|$@H
|$@H
_AXH
T$@H
AYAZI
|$XH
|$XH
A]A^
AWAVAUATL
[]A\A]A^A_
PAU1
G H9
P H9
P H9
` L9
P I9
P H9
P H9
ffffff.
ATUH
[]A\
[]A\
[]A\
AWAVI
AUATH
t$xH
T$pH
[]A\A]A^A_
D$dD
l$HH
l$PM
D$ H
D$h1
l$0I
D$ L
L;l$
D$ L
L$dE
\$@L
\$@L
C4_AXA
l$HH
L$ H
D9t$@
t$p1
L$(E
D$0E
l$pL9
CX@A
|$8A
L;t$ 
D$`L
|$HH
l$PH
\$@L
|$8H
D$XL
T$XH
D$ I9
\$ H
\$8H
l$8L
\$ H
t$pL
ET$0
T$0H
D$d1
D$ H
D$h1
D$ H
L$(L
t$8H
C49E4
$$L9d$
D$ H
L$(L
L$ H
AZA[
t$8H
l$pL9
\$@L
|$HH
l$PH
\$ H
l$pH
t$(D
\$pL9
|$4I
H;A@u
|$4L
l$pH
\$@L
|$HH
l$PL
ZYL9
l$pL9
t$8H
l$pL9
t$8H
\$pI
l$pL9
l$pL9
\$@H
AWAVE1
AUATI
[]A\A]A^A_
AWAVI
AUATM
[]A\A]A^A_
fffff.
AWAVI
AUATI
D$(1
L$$H
?L9|$
L$(dH3
8[]A\A]A^A_
?L9|$
?L9|$
?L9|$
fffff.
AWAVA
AUATI
H;o@u
[]A\A]A^A_
AWAVA
AUATI
L$,A
ZtBH
[]A\A]A^A_
D$,D
K<E1
A[A_
AWAVAUATI
([]A\A]A^A_
ATUI
[]A\
fff.
AWAVL
AUATL
D$ 1
([]A\A]A^A_
AWAVI
AUATA
D$(1
D$ L
|$ A
L$(dH3
8[]A\A]A^A_
AZA[
ffff.
AVAUATSI
[A\A]A^]
AWAVAUATUSH
E;e@s
L;l$
[]A\A]A^A_
ATUSH
[]A\
[]A\
[]A\
AWAVI
AUATI
[]A\A]A^A_
fffff.
AWAVAUATA
D$X1
L$XdH3
h[]A\A]A^A_
D$@j
t$HR
D$ rRiM
L$ 1
EXu`H
EXuc
EXugH
EXuG
AWAVAUATI
[A\A]A^A_]
AWAVAUATA
[A\A]A^A_]
ffffff.
AWAVAUATI
PASM
[A\A]A^A_]
AWAVAUATI
t1H)
[A\A]A^A_]
ffff.
AUATUSH
[]A\A]
CY ubA
E@E1
A;]@s/
AWAVE
AUATA
[]A\A]A^A_
AWAVE
AUATM
AUPL
[]A\A]A^A_
[]A\A]A^A_
W@A9
ffff.
AWAVI
AUATUSH
D$,D
L$4H
D$8dH
D$X1
D$,H
t$8P
t$XdH34%(
h[]A\A]A^A_
l$@H
D$0A9E@L
A9]@
T$0E
L$,E1
\$ L
H!CXH
D$X%
L$HL
E9|$@
DD$0
|$ L
|$ H
\$,I
D$Xu+L
L$HL
D$PL
L$HL
d$ L
l$@I9
D$8H
D$(1
\$ H
|$PD
D$PL
|$PD
D$PL
L$HL
L$ H
H!AX
AWAVI
AUATI
l$$D
D$(1
;h@A
ATAUE1
L$$E
tN9l$
L$,H
XZE1
t$(dH34%(
8[]A\A]A^A_
tH+l$$
L$$H
[]A\
[]A\
[]A\
[]A\
ffff.
AWAVAUATUSH
CD9C|
D9{@
[]A\A]A^A_
L$HL
;C@A
L$HRL
D$PH
fffff.
ffffff.
@Y t
AVAUI
ATUL
L9h@u
]A\A]A^
L;h@t
]A\A]A^
fff.
ATU1
[]A\
AWAVAUATI
[]A\A]A^A_
[]A\A]A^A_
ffffff.
AVAUL
ATUI
]A\A]A^
]A\A]A^
fff.
AWAVA
AUATI
vPdH
[]A\A]A^A_
fffff.
fff.
AWAVM
AUATI
~PdH
D$(1
L$(dH3
8[]A\A]A^A_
AWPAUD+L$4
L$$1
AWAVA
AUAT1
L$hE
t$hD
RATH
T$`E
L$hH
AXAY
[]A\A]A^A_
[]A\A]A^A_
[]A\A]A^A_
fff.
AWAVAUATUSH
D$hD
l$`H
t$pD
|$xH
[]A\A]A^A_
]A\A]A^A_
D$PH
[]A\A]A^A_
t$hD
D$`H
([]A\A]A^A_
AWAVAUATI
AXAYH
[A\A]A^A_]
|$HH
L$HH
I!EX
L$HL
AWAV
AUATUSH
[]A\A]A^A_
[]A\A]A^A_
]A\A]A^A_
ffffff.
H	FXH
ATUH
CXu=H
H!CXI
[]A\
ffffff.
ATUSH
H	BX
[]A\
[]A\
[]A\
AVAUI
ATUSH
]A\A]A^
Z[]A\A]A^
]A\A]A^
]A\A]A^
AVAUI
ATUSH
]A\A]A^
H9~P
H!GXI
]A\A]A^
H!PX
]A\A]A^
]A\A]A^
]A\A]A^
ATUSL
tY[]A\
Z[]A\
AWAVAUATUSH
[]A\A]A^A_
[]A\A]A^A_
ffffff.
AWAVAUATUSH
[]A\A]A^A_
ATUI
AWAVM
AUATI
D$@L
AWPA
[]A\A]A^A_
t$XA
AWAVAUATUSH
l$0I
AYA[
[]A\A]A^A_
H	CX
CXt!H
D$(H
H!CXD
fffff.
ATUI
t$lH
D$pD
[]A\
AVAUH
ATUSH
ATAU
[]A\A]A^
ATUSH
gPdH
t H9
H	CXI
[]A\
CXunH
[]A\
AUATI
[]A\A]
D$@1
L$0I
U`RAUSE
AVAUI
ATUI
I;l$
I;l$
I;l$
]A\A]A^
ffff.
ffffff.
fffff.
ffff.
ffff.
D$(1
H;\$
L$(dH3
0[]A\
fff.
AWAVI
AUAT
[]A\A]A^A_
ffff.
AUATI
[]A\A]
[]A\A]
ATUH
[]A\
[]A\
ffffff.
AWAVAUATUSH
@PD)
dH34%(
[]A\A]A^A_
ATUSH
D$H1
L$HdH3
P[]A\
ffffff.
AUATUSH
L$ M
$$M9
[]A\A]
$$M9
[]A\A]
fffff.
AWAVH
AUATH
|$HH
D$ I9
AWAT
XZE1
F E1
F E1
A]A_E
L$0D
6L;t$ tJD
L;t$ u
+\$0H
A[A\E1
AYAZE1
\$<H
H;D$@H
_AXE1
Y^E1
XZE1
[]A\A]A^A_
ffffff.
AWAVI
AUATE1
D$(1
L$(dH3
8[]A\A]A^A_
t$ H
|$ H
|$0XZ
L;|$ 
|$0Y^
_AXL
t(f.
A[A^
AYAZ
AWAVAUATM
([]A\A]A^A_
L;z@L
ATAW
AWAVA
AUATI
[]A\A]A^A_
AUATI
[]A\A]
[]A\A]
[]A\A]
t ;r
AWAVD
AUATA
[]A\A]A^A_
[]A\A]A^A_
AWAVAUATUSH
E H9
H;P@u
$$L9d$
([]A\A]A^A_
([]A\A]A^A_
ffffff.
AUATI
A9l$@w
[]A\A]
ATUH
[]A\
AVAUI
ATUI
]A\A]A^
H!JXH
I!D$X[
]A\A]A^
]A\A]A^
]A\A]A^
AWAVAUATUSH
[]A\A]A^A_
I!FXI
AUATUSH
[]A\A]
AWAVA
AUATI
[]A\A]A^A_
AWAVI
AUATI
L$HL
D$(L
\$ A
A]A^E1
[]A\A]A^A_
d$ E
t$Lc
D$ E
H9T$
AYAZ
I!D$XH
I!EX_AXL
\$ H
t$PI
|$HH
d$PL
l$X1
\$LM
AYAZH
\$LM
d$PL
t$$H
L$8H
|$(Ic
|$0D
|$ A
D$ I
A[[L
AWAVM
AUATUSH
AWE1
dH34%(
[]A\A]A^A_
AWAVAUATI
[]A\A]A^A_
PATj
sPE1
AWAVA
AUATI
D$PH
T$`I
|$P1
PAV1
\$<A
t$HH
|$ H
H9\$(
[]A\A]A^A_
D$PH
[]A\A]A^A_
D$PH
[]A\A]A^A_
AVAUATUSD
F@E1
E;n@r
]A\A]A^
fffff.
AWAVI
AUATUS
D$X1
t$0L
d$@L
|$@M9
\$(H
JHL9
|$ I
d$@L
A\A]H
L$XdH3
h[]A\A]A^A_
|$0A
L!oXAZA[
L!h(1
\$0L9
CPATL
A^A_D
l$@I
H!CXH
\$@L9
l$@M
L!oXAXAY
L!h(1
l$0L9
l$@L9
l$@I
H	P(H
H	CXH
H	PXH
l$@L9
l$0L9
fff.
AWAVI
AUATA
D$h1
l$0L
d$@H
AYAZH
L$hdH3
x[]A\A]A^A_
t$(L
\$PH
t$(H
\$@H
l$0H
^XuqH
l$0H
^XupH
^Xu[E
AWAVI
AUATUSH
x9Ic
G@D9
_AXN
D$Xt
AYAZH
[]A\A]A^A_
D$Xt
AVAUATUS
T$XH
l$HL
]A\A]A^
AWAVAUATI
D$ H
AUPH
[A\A]A^A_]
]@E1
E;u@
AXAY
CHE1
H	PXE;}@XZ
H#CXH
CXI	U(
ffff.
AWAVAUATI
WPPA
[A\H
[A\A]A^A_]
E;e@
AZA[I9
^_I9
E;e@
A]A^E
AVAUI
ATUS
}@Y^
D9e@
]A\A]A^
]A\A]A^
AY[]A\A]A^
]A\A]A^
]A\A]A^
G[ H
F[@H
AWAVAUATUSH
L$\E
L$XE
L$PM
t$0M
A^A_
L$@D;K@
H;\$
t$(H
t$0ZM
AXAY1
([]A\A]A^A_
t$(H
?L;|$
H;\$
O L;K 
H;\$
H;C8
O L;K _
t$(L
t$(H
t$(L
AZA[E
AXAY
$$L;d$
([]A\A]A^A_
D$PE
\$XE
t$(M
T$XAXAYE
t$(H
L$X^E
t$(L
L$PZM
t$(L
t$(M
[A^I
t$(M
A_XA
G[ t
G[ u
G[ u
H9x0
ffff.
H9x8
ffff.
AUATUSH
[]A\A]
[]A\A]
AWAVE
AUATI
[]A\A]A^A_
ATUI
h(tX
ATUH
[]A\
S0E1
fffff.
AVAUI
ATUS
]A\A]A^
FPE1
m8L9
]A\A]A^
AUATL
g`USI
_`I9
[]A\A]
[]A\A]
AUATI
dH3<%(
[]A\A]
ffffff.
fff.
fff.
ATUSH
[]A\
uiSH
CX[H
fffff.
AUATI
[]A\A]
fffff.
AWAVI
AUATI
D$PH
[]A\A]A^A_
AVAUATUH
]A\A]A^
]A\A]A^
]A\A]A^
ffffff.
AWAVAUATUSH
L$H1
[]A\A]A^A_
D$(1
t$(dH34%(
EPE1
ATUS
G\ H
[]A\
[]A\
fffff.
AUATUSH
D;d$
[]A\A]
D;d$
AWAVI
AUATUSH
L$ L
L$ D9
D$,L
AWAVH
D$(I
T$(L
[]A\A]A^A_
GPE1
AVAUATUSD
]A\A]A^
AVATI
[]A\A]A^
AVAUATUSH
D$(1
T$(dH3
0[]A\A]A^
CPE1
CXt!f.
AWAVAUATM
D$$L
D$$J
D$ E
D$$J
T$ H
[]A\A]A^A_
H;YPu
[]A\
ATUSH
[]A\
fff.
AUATI
[]A\A]
[]A\A]
[]A\A]
StZH
H;xPtGH
fffff.
ffff.
fff.
ffffff.
ffffff.
ATUL
[]A\
ATUL
[]A\
ATUSH
[]A\
ATUI
B H9
B H9
[]A\
[]A\
ffffff.
GY H
fff.
AWAVAUATI
H;D$
t^E1
D9c@w
H;D$
[]A\A]A^A_
ffffff.
;wXt
AUATUS
[]A\A]
tvSH
@Y@u4H
AWAVAUATI
[]A\A]A^A_
AYAZ
AVAUATUS
[]A\A]A^
AUATUSH
_AXH
[]A\A]
ARPH
ATUI
[]A\
ATPH
ARPH
AQPH
APPH
ASPH
AWAVI
AUATI
|$ L
D$ 1
[]A\A]A^A_
nohostna
D$`f
t$hH
fff.
ATUI
[]A\
fff.
fff.
ATUI
[]A\
[]A\
AVAUA
ATUA
D$(1
L$(dH3
0[]A\A]A^
PAT1
D$(1
D$(dH3
=r=,
=^=,
=J=,
=6=,
=V<,
=r<,
fff.
fff.
=&;,
fff.
fff.
AYAZ
ffffff.
ffff.
.txH
L$8L
D$@L
L$Ht7
)D$P
)L$`
)T$p
dH3<%(
twUS1
s(f.
ATUSH
[]A\
ATUH
ATUH
H#NXH9
[]A\
[]A\
AWAVAUATH
5I<,
-/<,
 u	E
[A\A]A^A_]
ffff.
AWAVAUATUS
D$h1
L$hdH3
x[]A\A]A^A_
=;9,
D$(H
l$DH
|$HH
D$ H
D$QH
D$PH
D$`H
D$XH
D$\L
D$cPH
D$jPL
L$ 1
D$(H
L$0H
|$Pr
Hcl$TL
ATAUL
=M&,
D$`H
L$XI
D$0H
L$8I)
D$(L
D$HL
D$[P
D$bP
D$iPI
t$hH
L$`1
L$DL
l$DL
|$HH
=G2,
=5!,
5n0,
fff.
fffff.
fff.
AWAVM
AUATI
([]A\A]A^A_
ffffff.
fffff.
fffff.
dH34%(
ffff.
dH34%(
fffff.
dH34%(
dH34%(
fff.
dH34%(
fff.
dH34%(
fff.
dH34%(
fff.
AUATL
[]A\A]
[]A\A]
AUATL
[]A\A]
[]A\A]
ATUI
 []A\
ATUI
 []A\
ATUI
 []A\
ATUI
 []A\
ATUI
 []A\
ATUI
 []A\
ATUI
 []A\
yXdH
dH34%(
y`dH
dH34%(
dH34%(
fff.
dH34%(
fff.
ATUI
 []A\
ATUI
 []A\
ATUI
 []A\
ATUI
 []A\
ATUI
 []A\
dH34%(
fffff.
D$(1
L$ H
\$(dH3
ffffff.
ATUI
dH34%(
 []A\
ffff.
ATUSH
dH34%(
[]A\
fffff.
ATUSH
dH34%(
[]A\
AUATI
CXu2H
([]A\A]
CPE1
ATUI
dH34%(
 []A\
AUATI
[]A\A]
AVAUM
ATUH
 []A\A]A^
ATUI
[]A\
ffff.
AWAVM
AUATI
[]A\A]A^A_
[]A\A]A^A_
ffffff.
AWAVI
AUATI
[]A\A]A^A_
AWAVAUATUSH
D$0H
D$0H
<QfA
l$0A
D$ H
m E1
L$ H
[]A\A]A^A_
|$0H
D$ -
;L$ 
t	D9
H I9N rQH
D$ -
D$PL
D$XL9
D$`H
D$pH
D$8D
d$,I
HcL$hH
d$,A
|$ -
|$ !H
|$ #
D$HH
|$@H
|$HH
D$HH
d$@H
D$@H
D$@H
D$@H
dH34%(
AWAVAUATI
|$HH
FhI9
[]A\A]A^A_
|$HH
6L;t$
L;hPt	L;
ATUI
[]A\
[]A\
[]A\
@tkH
ffff.
fff.
ATUH
[]A\
ATUH
fff.
ATUH
ffff.
ffff.
AXATUH
P<]A\
AXATUH
P8]A\
AXATUH
P4]A\
fff.
ATUI
dH34%(
[]A\
ffff.
dH34%(
dH34%(
fff.
ffff.
ffff.
ffff.
AWAVM
AUATI
[]A\A]A^A_
[]A\A]A^A_
AUATI
[]A\A]
[]A\A]
$t(H
ATUH
[]A\
fffff.
AUATM
([]A\A]
ffff.
AUATM
([]A\A]
ffff.
AUATM
$u9H
[]A\A]
AXu7H
ATUM
ATUM
ATUI
[]A\
[]A\
AWAVI
AUATI
[]A\A]A^A_
]A\A]A^A_
AWAVM
AUATI
H#CXH
{Xu+H
[]A\A]A^A_
]A\A]A^A_
AXu'H
AVAUI
ATUH
dH34%(
 []A\A]A^
ffffff.
AVAUI
ATUH
dH34%(
 []A\A]A^
ffffff.
ffff.
ffff.
ffff.
ffff.
ffff.
fffff.
fff.
dH34%(
$t(H
$t(H
AXu'H
AXu'H
t$ A
T$(E
\$0D
t$8D
T$@D
t$XRL
ffffff.
AUATI
l$pH
|$pH
\$ L
L$(H
D$8H
[]A\A]
D$8H
D$PH
D$XH
D$@H
ATUSA
l$ H
[]A\
AUATI
[]A\A]
9]@w
ATUSD
O@D;N@t
F09G0u
;]@s7
;]@r
fffff.
w AUL
ATUH
o@S1
[]A\A]A^
fffff.
AWAVAUATUSH
&vtI
[]A\A]A^A_
[]A\A]A^A_
 t-L
fffff.
ffff.
AWAVE1
AUATE1
D$(1
L$ 1
Lcd$
T$(dH3
8[]A\A]A^A_
t{I;
D$X1
t$XdH34%(
AUATI
ZYt(I
[]A\A]
[]A\A]
AWAVI
AUATH
D$81
|$ I
H;l$
T$8dH3
H[]A\A]A^A_
AWAVAUATUSH
\$PH
D$h1
\$PH
\$Xt
|$PH9
D$PH
|$ H
D$ H9
L;d$
T$ 9
D$ H
T$`H
t$hdH34%(
x[]A\A]A^A_
D$P1
missf
T$TA
|$<D
T$LD
T$DAXAYI
t$TV
L$XQ
T$\RD
\$`ASAUM
T$lARD
D$pAP
D$XL
t$hV
D$xH
SASAV
D$LAP
t$PL
L$TQ
AVAUD
T$tARD
\$xAS
D$hP
t$xV
CX0R
AVAU1
l$PI
Sxt1L
XZt$
[]A\A]A^A_
ATUI
D$xH
AWAV1
ATUI
PV_Ef
[]A\A]A^A_
AUATI
[]A\A]
[]A\A]
ATU1
[]A\
AUATI
[]A\A]
ffff.
AWAVAUATL
t$HL
[]A\A]A^A_
L$HL
[]A\A]A^A_
fffff.
AWAVAUATUSH
XZtsH
[]A\A]A^A_
AWAVH
NpAUATUSH
[]A\A]A^A_
6L9t$
[]A\A]A^A_
fff.
AWAVI
AUATUSH
T$(L9
L;,$
t$(A
|$(H
L;,$
[]A\A]A^A_
8[]A\A]A^A_
AWAV
AUATUSH
[]A\A]A^A_
AUATL
[]A\A]
[]A\A]
ffff.
AWAVAUATI
D$ H
[]A\A]A^A_
6L9t$
ATUI
ffff.
AWAVAUATI
|$ H
t$(L
|$ A
8H;:uqH
[]A\A]A^A_
APARj
|$HH
@@E1
E;|$@
|$ H
H98u
f$D;
[]A\A]A^A_
AVAUA
[]A\A]A^
]A\A]A^
]A\A]A^
fffff.
LVM1
AWAVI
AUATI
[]A\A]A^A_
ffff.
AWAVI
AUATH
t$ H
T$ 1
ctnA
[]A\A]A^A_
AUATI
[]A\A]
[]A\A]
AWAVAUATI
D$(1
<$Ic
L$(dH3
8[]A\A]A^A_
ARAPL
AVAUATUSH
]A\A]A^
fffff.
AWAVI
AUATI
]A\A]A^A_
[]A\A]A^A_
AVAUI
ATUSH
L$pH
L$xH
[]A\A]A^
[]A\A]A^
AWAVAUATUSH
[]A\A]A^A_
[]A\A]A^A_
[]A\A]A^A_
AWAVAUATUSH
L$4H
|$(H
D$ L
D$8L
[]A\A]A^A_
{$E;&
 L9t$
D$ H
H9D$(H
[]A\A]A^A_
fffff.
POOL
ffffff.
US~9
AVAUI
ATUHc
[]A\A]A^
AUAT
D$x1
L$xdH3
[]A\A]
AWAVAUATA
=^	*
[A\A]A^A_]
.u+A
^ukA
AWAVAUATSH
[A\A]A^A_]
fff.
AWAVAUATI
dH34%(
[]A\A]A^A_
 ASH
AVAU
fffff.
Xt*L
AWAVAUATI
XYD9
[A\A]A^A_]
ATUI
 []A\
ffffff.
AUATH
d$@L
l$HdH
[]A\A]
AWAVAUATI
[]A\A]A^A_
fff.
ATUI
]A\H
ffff.
ATUI
PHu]H
[]A\
[]A\
[]A\
ATUA
]A\H
ATUA
]A\H
fff.
AUATI
[]A\A]
[]A\A]
[]A\A]
ATUSH
[]A\
d$0L
L$(H
T$$I
D$,H
D$ H
D$(H
D$,=
AWAVAUATI
E;~@
AYAZ
_AXw
A9F@
<+AXZt
[A\A]A^A_]
ZYtCH
A[A]
AUATI
([]A\A]
C) ubH
ffffff.
9]@w
AWAVAUATM
D$81
T$ H
LcL$$
HcD$$A
D9|$ 
L$8dH3
H[]A\A]A^A_
L$0H
T$(H
|$(H
t$0H
ffff.
AWAVAUATM
\$@H
l$pL
|$xL
D$) 
t$xE
D$) u
D$DA9D$|
tkE1
[]A\A]A^A_
t$DA
D$) 
[]A\A]A^A_
D$(L
L$ H
t$@I
L$ L
ffff.
ATUA
RPE1
ATUI
[]A\H
ffff.
AWAVL
AUATI
l$`L
d$hdH
([]A\A]A^A_
AUATI
D;c@
[]A\A]
C@A9
H	C(
ffffff.
9]@Y^w
ATUA
[]A\E1
ffff.
AWAV
AUATM
D$h1
VXt	L
D$xH
l$(L
|$0L
D$ A
D$$A
D$DA
D$@1
\$hdH3
x[]A\A]A^A_
ATUA
[]A\E1
AVAUI
ATUL
]A\A]A^
]A\A]A^
ffffff.
AVAUI
ATUH
 []A\A]A^
%~M)
_AXu
-&L)
AWAVH
AUATI
l$`L
d$hdH
([]A\A]A^A_
D$ H
AWAVAUATUSL
l$`H
([]A\A]A^A_
t$hD
AWAVAUATUSH
_AXH
([]A\A]A^A_
L$ H
AVAUH
ATUI
d$@H
l$HdH
$tqH
[]A\A]A^
AWAVM
AUATI
T$$H
D$X1
D$0H
D$(H
L;l$
L$XdH3
h[]A\A]A^A_
T$0E
|$4E
D$(H
AXAY
ffff.
[]A\
[]A\
[]A\
ATUI
[]A\
[]A\
[]A\
ATUA
AVAUATUH
D$(1
T$HH
l$ L
t$ H
AYAZH
L$(dH3
0[]A\A]A^
L$ H
AWAVAUATI
t$HH
[]A\A]A^A_
ffff.
AWAVI
AUATI
[]A\A]A^A_
ATUI
 []A\
AYAZ
AVAUATUSI
 u7L
[]A\A]A^
t$HH
VPQH
t$XL
[]A\A]A^
[]A\A]A^
AWAVAUATI
T$HH
[]A\A]A^A_
ffff.
AUATI
[]A\A]
[]A\A]
ATUSH
[]A\
[]A\
[]A\
[]A\
fffff.
ATUI
[]A\
[]A\
[]A\
[]A\
ffffff.
[]A\
[]A\
[]A\
[]A\
ATUA
D$81
T$8dH3
@[]A\
AWAVAUATI
[A\A]A^A_]
ffff.
AWAVE
AUATI
[]A\A]A^A_
fffff.
AWAVH
AUATI
\$81
\$8dH3
H[]A\A]A^A_
|$0L
t$(L
l$ H
H;T$
H;T$ u
d$0M
D$(L
AWAVI
AUATH
D$PH
AYAZ
D$\ 
[]A\A]A^A_
D$0H
D$(H
D$ H
D$@H
D$|H
D$XH
D$`H
D$|H
L$0L
D$(H
L$ H
|$@H
D$8H
t$`I
t$pI
D$HH
t$hI
L$HL
L$HL
T$TH
AWAVM
AUATI
D$XE
[]A\A]A^A_
D$XP
[]A\A]A^A_
D$XM
D$h1
L$hdH3
AUATI
D$XH
[]A\A]
[]A\A]
ffffff.
AWAVI
AUATA
\$PdH
[]A\A]A^A_
D$PA
ARPH
L$PL
AUATI
[]A\A]
AWAVA
AUATA
L$h1
-wu)
L$8L
L$hdH3
x[]A\A]A^A_
L$8L
|$,H
ffff.
AWAVI
AUATI
E\ u]M
[]A\A]A^A_
fffff.
AWAVI
AUATI
D$x1
XZE1
\$xdH3
[]A\A]A^A_
t$0H
A[[D
L$@RPj
T$@E
_AXD
L$,9
L$0L
AWAVA
AUATI
D$81
D$XH
D$Y 
F@E1
E9~@
L$8dH3
H[]A\A]A^A_
6L94$
L;l$
AWAVAUATI
[]A\A]A^A_
D$8H
D$0H
D$(H
D$ H
D$pH
D$xH
L$8L
D$0L
L$(H
T$ H
<AtDL
_AXH
|$`L
t$hE1
t$pH
D$@H
|$xH
D$HH
D$PH
L$PL
D$XH
L$@H
T$H1
L$@H
T$HH
|$`L
t$hH
|$`L
D$p1
L$xH
|$`L
|$`L
t$XM
t$pL
|$xL
D$@H;
T$PH
T$HL
T$Pt
l$XL
|$`L
AZA[
AVATI
D$p1
L$xH
fffff.
AWAVM
AUATI
L$XL
D$PH
[]A\A]A^A_
[]A\A]A^A_
ffffff.
AWAVAUATI
D$x1
L$xdH3
[]A\A]A^A_
t$@H
D$8E1
D$0H
D$(H
D$ H
|$0I
D$H1
ATUH
$uvA
[]A\
[]A\
AWAVAUATI
D$X1
D$DH
D$PI
T$HH
\$XdH3
h[]A\A]A^A_
|$8A
D$XH
T$@H
RAWL
D$XH
D$XH
D$0I9
d$HL
T$ H
D$(I
L$01
G@E1
E;o@
|$8H
L$@A
L;|$0
d$HI
D$XH
t$8L
D$XH
t$T1
D$Y 
t$8H
AZA[
D$\ t
D$PI
L$HH
|$8H
|$81
D$PI
T$H1
D$\ 
D$xA
t$8L
t$TL
|$8H
|$8L
L$HL
L$HL
AWAVI
AUATI
D$x1
F] t
I#FXH
L$xdH3
[]A\A]A^A_
AZA[
D$ u
D$pL
l$XH
D$hH
D$`H
D$ H
D$pL
l$XL
D$`H
D$XH
D$ H
D$PH
D$(H
D$HH
D$0H
D$pH
D$8f
D$ H
L$(L
T$0H
D$8H
L$hH
T$`L
L$PH
T$HL
AWAVAUATI
D$x1
L$xdH3
[]A\A]A^A_
t$@H
D$0M
|$8H
D$(M
D$ H
t$8H
L$HL
L$HL
ffff.
AVAUI
[]A\A]A^
AVAUE1
ATUH
[]A\A]A^
[]A\A]A^
[]A\A]A^
AWAVM
AUATUSH
t$(L
\$8L
D$,L
[]A\A]A^A_
ATUH
D$X1
t$ H
L$XdH3
`[]A\
AUATI
[]A\A]
[]A\A]
AUATI
D$X1
L$XdH3
h[]A\A]
t$ H
AUATI
D$X1
t$ H
L$XdH3
h[]A\A]
AWAVA
AUATI
[]A\A]A^A_
AWAVA
AUATI
[]A\A]A^A_
ATUI
D$X1
t$ H
L$XdH3
`[]A\
L$HL
ATUH
WHdH
D$81
\$8dH3
@[]A\
AWAVAUATUSH
D$@H
D$pH
D$ A
D$4H
D$81
t$XH
[]A\A]A^A_
|$0E1
AZA[
t$4H
T$8H
L$h1
AXAYL
AUAT
[]A\A]
[]A\A]
[]A\A]
ATUI
[]A\
[]A\
D$(1
L$(dH3
fffff.
AUATI
D$(1
$LVM-H
L$(dH3
8[]A\A]
ffffff.
ffffff.
AWAVAUATA
=Mq*
51q*
[]A\A]A^A_
D$(H9
=|]*
5]]*
=9l*
AUATI
[]A\A]
[]A\A]
[]A\A]
AVAUATI
[]A\A]A^
L$0L
D$0L
D$0L
]A\A]A^
L$0L
AWAVI
AUATI
D$81
|'EL
D$(I
|$(H
|$ H
d$0I
T$0H
\$8dH3
H[]A\A]A^A_
L;d$
L;d$
L;|$
t$(H
t$ L
AWAVI
AUATI
AXAYuUH
[]A\A]A^A_
[]A\A]A^A_
[]A\A]A^A_
ATUS
[]A\
fff.
fffff.
AVAUATUS
[]A\A]A^
]A\A]A^
AUATI
>/t@H
[]A\A]
AVAUI
ATUI
_AXt.H
[]A\A]A^
B49G4w
AUATA
D$(1
ZYt*
T$(dH3
8[]A\A]
fffff.
fffff.
fffff.
AUATA
D$(1
T$(dH3
8[]A\A]
fffff.
AUATI
[]A\A]
[]A\A]
[]A\A]
fffff.
AWAVI
AUATUSH
|$0H
d$0H
D$ u	M
D$pH
D$@E1
L$(H
T$ H
t$HH
L$ H
X H9
[]A\A]A^A_
|$0L
D$hH
t$`H
T$hH
t$`L
D$hL
t$`E1
T$hH
t$`L
D$8L
\$0L
D$@E1
L$(H
|$ I
L$81
t$X1
ATUI
C@tsH
[]A\
[]A\
[]A\
fffff.
D$H1
D$HdH3
T$(H
t$HR
t$HPR
D$8L
L$0H
D$@H
D$HdH3
ffffff.
fff.
ATUE1
[]A\
[]A\L
AVAUA
ATUI
D$81
t$ H
T$ 1
L$8dH3
@[]A\A]A^
AWAVA
AUATI
D$81
\$8dH3
H[]A\A]A^A_
ffffff.
AWAVI
AUATUSH
D$x1
D$ 1
D$`H
D$@H
\$XS
t$81
D$d0
D$hH
t$8H
t$pH
D$@H
D$HH
D$PH
D$XH
L$xdH3
[]A\A]A^A_
D$@H
\$XH
D$HH
D$PH
D$(1
8Ot9
L$(dH3
ffffff.
ATUH
D$h1
T$hdH3
p[]A\
d$ H
AUATI
D$h1
l$ H
L$hdH3
x[]A\A]
AUATI
D$(1
T$(dH3
8[]A\A]
ATUH
D$(1
L$(dH3
0[]A\
fff.
AWAVL
AUATI
D$X1
D$(P
L$XdH3
h[]A\A]A^A_
AWAVI
AUATI
D$x1
\$xdH3
[]A\A]A^A_
AVQAWH
D$@M
|$ H
|$ H
d$HH
d$(AT
S4H9
AVQAWH
|$@M
|$ H
d$(H
AWAVAUATUS1
[]A\A]A^A_
|$0L
t$8H
|$ E1
l$@L
$$M9
AWAVI
AUATI
^AXH
D$<H
[]A\A]A^A_
l$`H
D$XI
D$pE1
D$ H
D$@H
L;l$
t$ H
T$(H
|$@H
t$pH
$$M9
$$M9
AUATI
D$H1
L$HdH3
X[]A\A]
fff.
D$81
T$8dH3
AVAUL
ATUI
D$(1
L$(dH3
0[]A\A]A^
d$ dH
D$h1
T$hdH3
p[]A\
AWAVAUATI
l$ H
\$0dH
[]A\A]A^A_
L$`H
t$XH
t$XI
L$`L
d$xH
|$ H
d$`H
T$0I9
d$ I9
$$I9
l$0I
RATH
ffffff.
AWAVM
AUATI
D$X1
t$H1
t$HL
t$(1
t$(L
l$`L
d$xH
l$0L
d$HAT
\$XdH3
h[]A\A]A^A_
t$(1
t$(1
ffff.
D$H1
L$HdH3
D$ H
D$8H
t$HPj
D$8L
L$0H
D$@H
56~*
5(~*
ATUSH
RAQL
A[XL
ffffff.
AWAVAUATUSH
D$x1
|$@Y^H
t$H1
t$HH
t$H1
t$HL
56z*
5(z*
|$PL
d$hAT
t$/D
t$4D
l$8D
l$HD
T$0H
T$0H
t$D	
T$@H
D$@H
t$pH
\$xdH3
[]A\A]A^A_
t$H1
t$HD
T$pH
L$xL
D$X1
D$D0
D$HH
D$`H
D$XH
|$@H
D$@H
D$HH
D$PH
D$XH
T$XdH3
AVAUATUS
8Ot4L
]A\A]A^
Z[]A\A]A^
]A\A]A^
AUATI
[]A\A]
[]A\A]
ffffff.
AUATI
[]A\A]
[]A\A]
ffffff.
[]A\
AWAVAUATI
D$ H
D$(L
D$X1
au5A
|$XdH3<%(
h[]A\A]A^A_
52m*
5$m*
T$ M
|$(H
|$0L
ASQH
ARQH
AURH
VQAWL
t$@L
d$XXZAT
|$0L
AURH
VQAWL
t$xH
PAUAWL
L$8H
t$0L
d$HAT
t$81
AUAWL
|$0L
QAWL
t$XH
D$pL
PAWL
ffffff.
AVAUATUSH
[]A\A]A^
D$XHc
AVQRH
\$hH
H	PXH
D$H1
D$HdH3
L$ H
L$8H
t$HQ
t$HPQ
D$8L
L$0H
D$@H
D$HdH3
fffff.
AVAUATUSH
[]A\A]A^
|$01
D$8Ic
l$0L
AUATI
D$81
L$8dH3
H[]A\A]
l$HH
ATUSH
D$81
D$8dH3
@[]A\
AWAV
AUATI
d$@dH
_AXH
|$ H
AWRH
AUQH
ATRSH
L$hH
|$ H
dH34%(
[]A\A]A^A_
ATUI
D$81
|$ L
L$8dH3
@[]A\
D$81
\$8dH3
AWAVAUATI
([]A\A]A^A_
AWAVE1
AWAVAUATUSH
>eu;
AWAVE1
[]A\A]A^A_
fff.
AWAVM
AUATI
([]A\A]A^A_
t!=-
vd=.
D$81
L$8dH3
ffff.
AWAVAUATUSH
D$x1
\$xdH3
[]A\A]A^A_
l$0I
D$,H
AUU1
UAVM
PATM
ffff.
AVAUI
ATUI
M ATM
[]A\A]A^
[]A\A]A^
A[[]A\A]A^
>uu#A
UHATH
AXAY
AVAUL
ATUI
Z[]A\A]A^
]A\A]A^
AVAUI
ATUI
D$81
L$8dH3
@[]A\A]A^
AVAUATI
[]A\A]A^A_
t$@H
|$ H
t$@H
L$X1
|$ H
ffff.
AUATUI
[]A\A]A^
[]A\A]A^
t$XH
t$PH
t$PL
t$XL
t$PL
AXAY
AWAVI
AUATI
D$x1
ATVH
AUVH
AVVH
L$xdH3
[]A\A]A^A_
ffff.
AVAUATUI
D$81
L$8dH3
@[]A\A]A^
L$,H
L$,H
AWAVAUATI
D$81
L$8dH3
H[]A\A]A^A_
D$81
\$8dH3
AUAT
[]A\A]
ffffff.
fff.
ffff.
AUATUSH
cXM9
[]A\A]
fff.
tzAUATUSH
[]A\A]
[]A\A]
ffffff.
ATUSH
9wTt
[]A\
[]A\
[]A\
AWAVM
AUATI
T$ H
[]A\A]A^A_
AWAVI
AUATI
WTdH
([]A\A]A^A_
AWAVH
AUATH
D$X1
L$XdH3
h[]A\A]A^A_
A[A^I
AYAZ
Lcl$
_AXE
AVAUI
ATUI
D$(1
	H;D$
L$(dH3
0[]A\A]A^
AUATU1
[]A\A]A^
fff.
fffff.
[]A\
ATUH
[]A\
ATUL
D$H1
D$01
D$HdH3
P[]A\
AWAVAUATUSH
t$81
|$8L
l$@H
D$(H
D$4E1
8.uV
T$ H
l$(1
|$8H
[]A\A]A^A_
D$8H
D$4L
<$I9
AWAVI
AUATI
L$,L
|$,H
[]A\A]A^A_
D;d$
l$0L
L9d$
AUATI
eHH9
[]A\A]
[]A\A]
D$(1
T$(dH3
fffff.
D$(1
L$(dH3
AVAUA
ATUA
[]A\A]A^
L$XI
L$XI
AYAZ
H9D$
AWAVAUATL
[]A\A]A^A_
[]A\A]A^A_
fff.
AWAVL
AUATI
_AXI
H9D$
H9D$
[]A\A]A^A_
AWAVAUATA
:aux
[A\A]A^A_]
fff.
AVAUA
]A\A]A^
 RAU
]A\A]A^
[]A\A]A^
[]A\A]A^
ffff.
AWAVI
AUATI
[]A\A]A^A_
[]A\A]A^A_
ATUS
>Hu	
[]A\
	+F$
AWAVI
AUATI
D$ 1
T$ H
T$(H
T$0H
T$8H
T$@H
T$HH
T$PH
T$XH
T$`H
T$hH
T$pH
T$xH
sHE1
[]A\A]A^A_
L$ 1
sHE1
L$ 1
AXAY
AVAUATUH
]A\A]A^
]A\A]A^
AVAUM
ATUI
D$(1
4$t-1
\$(dH3
0[]A\A]A^
AWAVAUATUSH
ATP1
L$01
\$ L
[]A\A]A^A_
L9l$
[]A\A]A^A_
\$ A
D$ L9
\$(L
L;l$ 
\$(A
L$01
|$ L
|$(L
ffff.
ffff.
AUATI
POOL0000f
0000
[]A\A]
AWAVI
AUATH
D$x1
\$PI
d$0L
<$E1
D$ I
D$(I
T$xdH3
[]A\A]A^A_
AVAUI
ATUH
[]A\A]A^
AWAVAUATI
D$H1
t$(H
L$HdH3
X[]A\A]A^A_
t	D9
ffffff.
ATUI
|$0H
[]A\
[]A\
[]A\
AWAVAUATUSH
D$81
L$8dH3
H[]A\A]A^A_
_AXH
AYAZ
AWAVI
AUATUSH
([]A\A]A^A_
D$ t
ATUI
[]A\
ATUI
[]A\
fff.
ATUI
[]A\
fff.
AWAVI
AUATE1
[]A\A]A^A_
<duWA
<lt\<s
[]A\A]A^A_
[]A\A]A^A_
[]A\A]A^A_
[]A\A]A^A_
L$8L
D$@L
L$Ht7
)D$P
)L$`
)T$p
AUATI
[]A\A]
[]A\A]
[]A\A]
fffff.
ATUH
[]A\
ffffff.
AVAUI
ATUH
[]A\A]A^
t$(H
T$0H
L$8L
D$@L
L$Ht7
)D$P
)L$`
)T$p
ffffff.
ATUSH
l$`H
D$81
D$xI
H9D$
L$8dH3
D$ H
D$(H
@[]A\
|$(H
fffff.
ATU1
D$X1
D$@H
D$HH
D$P1
d$@H
L$XdH3
`[]A\
D$ H
D$(H
D$0H
D$8H
ffffff.
T$PH
L$XL
D$`L
L$ht=
)D$p
D$81
D$(H
D$$0
D$8H
D$ H
D$(H
D$0H
D$8H
L$8dH3
AWAV
AUATE1
l$PL
_AX1
|$0L
l$HAU
l$ D
t$$H
D$ H
[]A\A]A^A_
PAW1
|$0H
t$(H
t$(1
l$PH
D$hH
D$(H
A[A^E1
T$ A
<$A9
D$HP
l$0H
d$8L
D$@H
AYAZ
ATUI
 []A\
D$@dH
|$ H
t$(H
T$0H
L$8L
D$@L
L$Ht7
)D$P
)L$`
)T$p
|$ H
AWAVAUATI
[]A\A]A^A_
AWAVA
AUATE1
}]Ic
[]A\A]A^A_
AWAVA
AUATL
[]A\A]A^A_
<backtrace>
dumpconfig.c
current
diff
2.02.130(2) (2015-09-05)
%u.%u.%u
Incorrect version format.
Failed to load profile %s.
LVM configuration valid.
LVM configuration invalid.
profilable
profilable-command
profilable-metadata
Only one of --type and --validate permitted.
Only one of --type and --list permitted.
--atversion requires --type or --list
Only one of --ignoreunsupported and --showunsupported permitted.
--atversion has no effect with --type %s
--ignoreadvanced and --ignoreunsupported has no effect with --type current
--mergedconfig has no effect without --type current or --type full
Failed to merge configuration.
--withcomments has no effect with --type list
Incorrect type of configuration specified. Expected one of: current, default, diff, full, list, missing, new, profilable, profilable-command, profilable-metadata.
core-logged 
disk-logged 
metadata area
lvchange.c
Failed to clear %s %s for %s
does not 
(inherited)
Unable to change pvmove LV %s
 and %u other snapshot(s)
Failed to prepare message.
%s device number not changed.
Cannot deactivate %s.
%s: reactivation failed
raid1
%s:y
LV %s is not a cache LV.
Logical volume "%s" changed.
Unable to resync %s.  It is not RAID or mirrored.
Unable to resync pvmove volume %s
Unable to resync locked volume %s
Can't resync open logical volume "%s"
Do you really want to deactivate logical volume %s to resync it? [y/n]: 
Logical volume "%s" not resynced
RAID logical volume %s/%s cannot be active remotely.
Unable to deactivate %s for resync
Can't get exclusive access to clustered volume %s
Starting resync of %s%s%s%s "%s"
Updating logical volume "%s" on disk(s)
Failed to update metadata on disk.
Failed to reactivate %s to resynchronize mirror
Failed to update intermediate VG metadata on disk.
Unable to activate %s for %s clearing
Unable to reset sync status for %s
Failed to deactivate log LV after wiping failed
Unable to deactivate %s LV %s after wiping for resync
Failed to sync local devices after updating %s
Failed to reattach %s device after clearing
Failed to reactivate %s after resync
Only -a permitted with read-only volume group "%s"
Can't change logical volume "%s" under snapshot
Use 'pvmove --abort' to abandon a pvmove
Unable to change mirror log LV %s directly
Unable to change mirror image LV %s directly
Unable to change internal LV %s directly
Change of snapshot %s will also change its origin %s%s. Proceed? [y/n]: 
Logical volume %s not changed.
Option --errorwhenfull is only supported with thin pools.
Persistent major and minor numbers are not supported with pools.
Cannot change permissions of external origin "%s".
Logical volume "%s" is already read-only.  Refreshing kernel state.
Logical volume "%s" is already read only
Logical volume "%s" is already writable.  Refreshing kernel state.
Logical volume "%s" is already writable
Cannot change permissions of mirror "%s" while active.
Cannot change permissions of RAID %s "%s"
Change permissions of thin pool "%s" not yet supported.
Setting logical volume "%s" read/write
Setting logical volume "%s" read-only
Allocation policy of logical volume "%s" is already %s
Setting contiguous allocation policy for "%s" to %s
Error when full is already %sset for %s.
Metadata only supports readahead values between 2 and 120.
WARNING: Overriding readahead to %u sectors, a multiple of %uK page size.
Read ahead is already auto for "%s"
Read ahead is already %u for "%s"
Setting read ahead to %u for "%s"
Minor number is already not persistent for %s.
Disabling persistent device number for %s.
Logical volume %s will be deactivated temporarily. Continue? [y/n]: 
Remotely active LV %s needs individual reactivation.
Setting persistent device number to (%d, %d) for %s.
Updating logical volume %s on disk(s).
Re-activating logical volume %s
Logical volume "%s" is not a thin pool.
Cannot change support for discards while pool volume "%s" is active.
Logical volume "%s" already uses --discards %s.
Logical volume "%s" already %szero new blocks.
--write%s can only be used with 'raid1' segment type
%s not found in volume group, %s
Unable to change the recovery rate of non-RAID logical volume.
Minumum recovery rate cannot be higher than maximum.
Changing configuration profile for LV %s: %s -> %s.
Changing activation skip flag to %s for LV %s.
Only cache or cache pool devices can have --cachepolicy set.
Cannot activate LVs in a foreign VG.
Refreshing logical volume "%s" (if active)
Logical volume, %s, is not active
Need 1 or more of -a, -C, -M, -p, -r, -Z, --resync, --refresh, --alloc, --addtag, --deltag, --monitor, --poll or --discards
Only one of --metadataprofile and --detachprofile permitted.
Only one of -a and --refresh permitted.
Only -a permitted with --ignorelockingfailure and --sysinit
Please give logical volume path(s) or use --select for selection.
--major and --minor require -My
Only give one logical volume when specifying minor
Only one of --alloc and --contiguous permitted
Only one of --poll and --sysinit permitted
lvmetad is not active yet, using direct activation during sysinit
lvmetad is active, skipping direct activation during sysinit
Poll operation ID allocation failed.
Internal error: Name "%s/%s" is too long.
Failed to copy one or more poll operation ID members.
Allocation of list of failed_pvs failed.
Allocation of failed_pvs list entry failed.
lvconvert: layer name allocation failed.
lvconvert: layer name generation failed.
%d missing and now unallocated Physical Volumes removed from VG.
Converting thin%s segment type for "%s/%s" to %s is not supported.
For pool data volume conversion use "%s/%s".
For pool metadata volume conversion use "%s/%s".
Detaching cache pool %s from cached LV %s.
Logical volume %s is not cached and cache pool %s is unused.
Thin repair commnand is not configured. Repair is disabled.
Failed to build thin metadata path.
Failed to build pool metadata spare path.
Internal error: Unable to find configuration for global/thin_repair_options
Invalid string in config file: global/thin_repair_options
Too many options for thin repair command.
Only inactive pool can be repaired.
Cannot activate pool metadata spare volume %s.
Cannot activate thin pool metadata volume %s.
Repair of thin metadata volume of thin pool %s/%s failed (status:%d). Manual repair required!
WARNING: Cannot read output from %s %s.
Transaction id %lu from pool "%s/%s" does not match repaired transaction id %lu from %s.
Cannot deactivate thin pool metadata volume %s.
Can't prepare new metadata name for %s.
Can't generate new name for %s.
WARNING: If everything works, remove "%s/%s".
WARNING: Use pvmove command to move "%s/%s" on the best fitting PV.
Converted volume %s and pool volume must differ.
Can't convert thin pool LV %s.
Cached LV %s could be only converted into a thin pool volume.
Cannot convert cache pool %s as pool data volume.
Mirror logical volumes cannot be used as pools.
Try "%s" segment type instead.
Pool data LV %s is of an unsupported type.
Can't use same LV for pool data and metadata LV %s.
Mirror logical volumes cannot be used for pool metadata.
Pool metadata LV %s is of an unsupported type.
Logical volume %s is too small for metadata.
--%s and pool metadata swap is not supported.
Cannot convert pool %s with active volumes.
Chunk size can be only changed with --force. Conversion aborted.
WARNING: Changing chunk size %s to %s for %s pool volume.
Do you really want to change chunk size for %s pool volume? [y/n]: 
Do you want to swap metadata of %s pool with metadata volume %s? [y/n]: 
WARNING: Converting logical volume %s%s%s to pool's data%s.
THIS WILL DESTROY CONTENT OF LOGICAL VOLUME (filesystem etc.)
Do you really want to convert %s%s%s? [y/n]: 
Failed to create internal lv names, pool name is too long.
Aborting. Failed to deactivate %s.
Aborting. Failed to activate metadata lv.
Aborting. Failed to wipe metadata lv.
Aborting. Failed to deactivate metadata lv. Manual intervention required.
Aborting. Failed to deactivate logical volume %s.
WARNING: Pool zeroing and large %s chunk size slows down provisioning.
Failed to activate pool logical volume %s.
Failed to deactivate pool data logical volume.
Failed to deactivate pool metadata logical volume.
Failed to unlock pool data LV %s/%s
Failed to unlock pool metadata LV %s/%s
Can't use same LV %s for thin pool and thin volume.
Can't use%s%s %s %s as external origin.
Can't use lock_type %s LV as external origin.
Aborting. Unable to deactivate new LV. Manual intervention required.
Converted %s to thin volume with external origin %s.
Unable to deactivate failed new LV. Manual intervention required.
Manual intervention may be required to remove abandoned LV(s) before retrying.
Logical volume %s is already not mirrored.
Can't add mirror to out-of-sync mirrored LV: use lvchange --resync first.
Can't add additional mirror images to mirrors that are under snapshots
%s is already being converted.  Unable to start another conversion.
ABORTING: Failed to remove temporary mirror layer %s.
Manual cleanup with vgcfgrestore and dmsetup may be required.
--trackchanges is not available to 'mirror' segment type
Failed to allocate poll identifier for lvconvert.
Unable to merge mirror imagesof segment type 'mirror'
Mirror segment type cannot be used for thinpool%s.
Try "%s" segment type instead.
Mirrors are not yet supported on cache LVs %s.
Unable to split mirrors in VG with lock_type %s
Only up to %d images in mirror supported currently.
Unable to reduce images by specified amount - only %d in %s
Adjusting mirror image count of %s
Log type, "mirrored", is unavailable to cluster mirrors
Mirror log region size cannot be changed on an existing mirror.
Logical volume %s has multiple mirror segments.
Cannot both allocate and free extents when specifying physical volumes to use.
Please specify the operation in two steps.
%s is consistent. Nothing to repair.
Mirror status: %d of %d images failed.
Mirror log status: %d of %d images failed.
Attempt to replace failed mirror log? [y/n]: 
Attempt to replace failed mirror images (requires full device resync)? [y/n]: 
Trying to up-convert to %d images, %d logs.
WARNING: Failed to replace %d of %d images in volume %s
WARNING: Failed to replace %d of %d logs in volume %s
Can't convert snapshot logical volume "%s"
Unable to convert pvmove LV %s
Unable to split LV %s/%s that is a snapshot origin.
Unable to split off snapshot %s/%s being merged into its origin.
Unable to split off snapshot %s/%s with virtual origin.
Unable to split off LV %s/%s needed by thin volume(s).
Unable to split off snapshot %s/%s using old LVM1-style metadata.
Unable to split snapshots in VG with lock_type %s
LV %s/%s type is unsupported with --splitsnapshot.
Do you really want to split off active logical volume %s? [y/n]: 
Splitting snapshot %s/%s from its origin.
Logical Volume %s/%s split from its origin.
Cannot uncache non-cached logical volume %s.
Logical volume %s is not cached.
Can't convert %s %s to external origin.
Can't repair LV "%s" of segtype %s.
WARNING: Selected operation does not work with cache-type LVs.
Proceeding using the cache origin LV %s instead
"%s" is not a mergeable logical volume.
Snapshot %s is already merging into the origin.
"%s" is read-only external origin "%s".
Merging into the old snapshot origin %s is not supported.
Delaying merge since snapshot is open.
Delaying merge since origin volume is open.
Failed to reactivate origin %s.
Merging of thin snapshot %s will occur on next activation of %s.
Snapshot %s is already merging.
Snapshot %s has virtual origin.
Cannot merge snapshot "%s" into the read-only external origin "%s".
Unable to merge invalidated snapshot LV "%s".
Can't initialize snapshot merge. Missing support in kernel?
Can't merge over open origin volume.
Can't merge when snapshot is open.
Can't check whether remotely active snapshot is open.
Merging of snapshot %s will occur on next activation of %s.
Unable to merge LV "%s" into its origin.
Snapshots are not yet supported with cache type LVs %s.
Unable to convert mirrored LV "%s" into a snapshot.
Unable to convert origin "%s" into a snapshot.
Unable to convert pool LVs %s into a snapshot.
Couldn't find origin volume %s in Volume group %s.
Unable to use %s as both snapshot and origin.
Unable to convert an LV into a snapshot of a %s LV.
WARNING: Converting logical volume %s to snapshot exception store.
Do you really want to convert %s? [y/n]: 
Aborting. Failed to wipe snapshot exception store.
Failed to deactivate zeroed snapshot exception store.
Logical volume %s converted to snapshot.
Logical volume %s is now cached.
'--mirrors/-m' is not compatible with %s
Unable to convert %s/%s from %s to %s
Unable to %s images by specified amount
%s/%s must be active %sto perform this operation.
Unable to determine sync status of %s/%s.
WARNING: %s/%s is not in-sync.
WARNING: Portions of the array may be unrecoverable.
Attempt to replace failed RAID images (requires full device resync)? [y/n]: 
Failed to replace faulty devices in %s/%s.
Faulty devices in %s/%s successfully replaced.
Use 'lvconvert --repair %s/%s' to replace failed device.
Conversion operation not yet supported.
Conversion starts after activation.
Convert poll ID list allocation failed.
Failed to initialize processing handle.
--type mirror requires -m/--mirrors
Conversion using --type %s is not supported.
--mirrorlog and --corelog are incompatible.
cannot be used with --splitsnapshot
cannot be used with --splitcache
--snapshot/--type snapshot or --merge argument cannot be mixed with --mirrors/--type mirror/--type raid*, --mirrorlog, --repair or --thinpool.
--stripes or --stripesize argument is only valid with --mirrors/--type mirror/--type raid*, --repair and --thinpool
--cache is incompatible with --type %s
--thin is incompatible with --type %s
--cachepool argument is only valid with  the cache or cache-pool segment type.
--thinpool argument is only valid with  the thin or thin-pool segment type.
Failed to parse cache policy and/or settings.
is invalid with --poolmetadata
Please specify the pool data LV.
--snapshot and --merge are mutually exclusive.
--mirrors/--type mirror/--type raid* and --splitmirrors are mutually exclusive.
Please name the new logical volume using '--name'
The 'name' argument is only valid with --splitmirrors
Please provide logical volume path for snapshot origin.
--regionsize is only available with mirrors
--stripes and --stripesize are only available with striped mirrors
Negative chunk size is invalid.
Chunk size must be a power of 2 in the range 4K to 512K
Failed to get '--replace' argument
--chunksize is only available with snapshots or pools.
--zero is only available with snapshots or thin pools.
Negative regionsize is invalid
Negative regionsize in configuration file is invalid
Region size (%u) must be a multiple of machine memory page size (%d)
Region size (%u) must be a power of 2
Non-zero region size must be supplied.
%s: Required device-mapper target(s) not detected in your kernel
Please specify a logical volume path.
Logical volume name for caching is missing.
Please specify a logical volume to act as the external origin.
Please specify a logical volume to act as the snapshot exception store.
Logical volume for split is missing.
Cache logical volume for split is missing.
Cache logical volume for uncache is missing.
Please provide logical volume path.
Please use a single volume group name ("%s" or "%s")
Please provide a valid volume group name
Too many arguments provided for snapshots.
Too many arguments provided with --splitsnapshot.
Too many arguments provided with --splitcache.
Too many arguments provided with --split.
Too many arguments provided with --uncache.
Too many arguments provided for pool.
Can't use same name %s for %s and %s volume.
lvconvert.c
%s_mimage_%%d
_mimagetmp_%d
layer name allocation failed.
Failed to insert resync layer
Merged
Converted
transaction="
%s_meta%%d
 and 
_cmeta
_cdata
_tdata
Unknown pool data LV %s.
Can't convert internal LV %s.
Can't convert locked LV %s.
Unknown pool metadata LV %s.
LV %s is already pool.
Conversion aborted.
Continuing with swap...
pvmove_tmeta
Creation of pool LV failed.
Failed to lock pool LV %s/%s
Converted %s to %s pool.
is invalid with existing pool
 and metadata volumes
 hidden
raid
mirror
No usable images left in %s.
Setting logging type to %s
Logical volume %s converted.
cache type
thin type
pvmove
mirrored
exclusive locally 
Cannot convert locked LV %s
%s/%s is not a snapshot.
Logical volume %s not split.
Split of %s is not cache.
Split of %s is unsupported.
Merging of volume %s started.
Couldn't deactivate LV %s.
WARNING: "%s" not zeroed
Couldn't create snapshot.
allocate
thin-pool
cache-pool
cannot be used with --repair
cannot be used with --split
cannot be used with --uncache
--cache requires --cachepool.
is valid only with thin pools
--thin requires --thinpool.
is invalid with pools
is valid only with pools
_rimage_
cannot be used with --merge
Setting chunk size to %s.
striped
converted
pool metadata
Can't find LV %s in VG %s
Failed to remove temporary sync layer.
Failed to swap %s with merging %s.
Logical volume %s has no merging snapshot.
Merge of snapshot into logical volume %s has finished.
Could not remove snapshot %s merged into %s.
%s: Failed query for merging percentage. Aborting merge.
%s: Merging snapshot invalidated. Aborting merge.
%s: Merge failed. Retry merge or inspect manually.
lvconvert_poll.c
%s: %s: %.1f%%
LV %s is not merged.
Y@Inconsistent volume group names given: "%s" and "%s"
Segment type %s cannot use pool %s.
Logical volume %s already exists in Volume group %s.
Persistent major and minor numbers are unsupported with pools.
Ambigous --readahead parameter specified. Please use either with pool or volume.
Please specify name of existing pool.
Pool %s not found in Volume group %s.
Logical volume %s is not a cache pool.
Logical volume %s is not a thin pool.
Unable to create LV with unknown segment type %s.
is unsupported with cache pools
Cannot create read-only cache pool.
Snapshot segment type is incompatible with thin pools.
is unsupported with snapshots and --thinpool
Snapshot segment type requires size or extents.
is supported only with sparse snapshots
is supported only with mirrors
Please specify either size or pooldatasize.
is supported only with thin pool creation
Thin segment type requires --virtualsize.
Switching from thin to thin pool segment type.
is unsupported with thin pools
Cannot create read-only thin pool.
is supported only with mirrors or raids
--mirrors is supported only with mirrors or raids
is supported only with pools and snapshots
is supported only with sparse snapshots and thins
Segment type %s does not support --errorwhenfull.
%s: Required device-mapper target(s) not detected in your kernel.
RAID module does not support RAID10.
Please specify a logical volume to act as the cache pool or origin.
Unsupported syntax, cannot use cache origin %s and --cachepool %s.
The cache pool or cache origin name should include the volume group.
Creation of cached volume and cache pool in one command is not yet supported.
Please specify a logical volume to act as the snapshot origin.
The origin name should include the volume group.
Ambiguous %s name specified, %s and %s.
The %s name should include the volume group.
Please provide a volume group name
Volume group name expected (no slash)
Logical volume name %s and pool name must be different.
Volume group name %s has invalid characters
Please specify either size or extents (not both).
Please specify either size or extents.
Only up to 8 images in mirror supported currently.
RAID10 currently supports only 2-way mirroring (i.e. '-m 1')
--mirrors must be at least 1 with segment type %s.
Redundant mirrors argument: default is 0
regionsize in configuration file is invalid.
Please use only one of --corelog or --mirrorlog.
Segment type 'raid10' requires 2 or more stripes.
Stripe argument cannot be used with segment type, %s
Mirror argument cannot be used with segment type, %s
Minimum recovery rate cannot be higher than maximum.
Cannot use stripes with linear type.
Chunk size must be a power of 2 in the range 4K to 512K.
Conflicting contiguous and alloc arguments.
Unable to allocate memory for tag %s.
Snapshot origin LV %s not found in Volume group %s.
Thin pool volume %s not found in Volume group %s.
Logical volume %s is not a thin pool volume.
Please specify either size or extents with snapshots.
Logical volume %s is not a thin volume. Thin snapshot supports only thin origins.
Switching from snapshot to thin segment type.
Change of volume permission is unsupported with cache conversion, use lvchange.
is unsupported with cache conversion
Skipping activation of cache origin %s.
Cannot activate cache origin %s.
Cannot deactivate activate cache origin %s.
Ambiguous syntax, please create --type cache-pool %s separately.
Number of stripes must be at least %d for %s
Unable to create RAID10 LV, insufficient number of devices.
Please either create snapshot or thin volume.
Please specify device size(s).
is only available when creating thin pool
Only specify Physical volumes when allocating thin pool.
Internal error: Buffer is too small for dm_snprintf().
Cannot zero %slogical volume with option -Zy or -Wy.
Ignoring option -Zy or -Wy for unzeroable %s volume.
Please express size as %%FREE%s, %%PVS or %%VG.
Couldn't find origin volume '%s'.
Internal error: Unsupported percent type %u.
Converted %u%%%s into %u extents.
Internal error: Missing snapshot chunk size.
Reducing COW size %s down to maximum usable size %s.
Rounding size (%d extents) down to stripe boundary size (%d extents)
Not enough space for thin pool creation.
Internal error: --thinpool not identified.
Internal error: Inconsistent snapshot and origin parameters identified.
Internal error: Failed to identify what type of thin target to use.
Making pool %s in VG %s using segtype %s
No space for sanlock lock, extend the internal lvmlock LV.
Making thin LV %s in pool %s in VG %s%s%s using segtype %s
Internal error: Couldn't find origin volume.
lvcreate.c
is only available with pools
is unsupported with cache
is supported only with cache
is unsupported with snapshots
is unsupported with mirrors
is unsupported with raids
is supported only with raids
is unsupported with thins
is supported only with thins
raid10
may not be zero
Setting chunksize to %s.
Failed to get tag.
may not be negative
skipped from activation 
inactive 
auto activated 
read-only 
origin 
, %ORIGIN
with generated name
 as snapshot of 
Finding volume group "%s"
%s%s%s%s%s%s%s
Incompatible options selected
lvdisplay.c
Incompatible options selected.
Options -c and -m are incompatible.
With LVM2 and the device mapper, this program is obsolete.
lvmchange.c
Command not implemented yet.
stub.h
system ID: %s
lvmcmdline.c
Available lvm commands:
%-16.16s%s
unmanaged
LVM version:     %s
Library version: %s
Driver version:  %s
/proc/%u/cmdline
%s%s%s failed: %s
/proc/self/fd/%u
 Parent PID %d: %s
%s.lvm1
execvp
Unrecognised option.
Option requires argument.
Invalid argument for %s: %s
Specified %%%s is unknown.
kmgtpebs
Size is too big (>=16EiB).
none
Couldn't allocate memory.
Out of memory.
%s: no such command.
%s: %s
Option %s %s.
devtypes
dumpconfig
formats
formats
help <command>
Display help for commands
lvchange
Change logical volume layout
lvconvert
Create a logical volume
lvcreate
lvdisplay
Add space to a logical volume
lvextend
lvmchange
lvmconfig
lvmdiskscan
Collect activity data
lvmsadc
Create activity report
lvmsar
lvreduce
lvremove
Rename a logical volume
lvrename
Resize a logical volume
lvresize
lvscan
pvchange
Resize physical volume(s)
pvresize
pvck
pvcreate
pvdata
pvdisplay
lvpoll
pvremove
List all physical volumes
pvscan
segtypes
List available segment types
systemid
tags
vgcfgbackup
vgcfgrestore
vgchange
vgck
vgconvert
Create a volume group
vgcreate
vgdisplay
vgexport
vgextend
vgimport
Merge volume groups
vgmerge
vgmknodes
vgreduce
Remove volume group(s)
vgremove
Rename a volume group
vgrename
Search for all volume groups
vgscan
vgsplit
version
degraded
Couldn't copy command line.
Parsing: %s
complete
Invalid units specification
Processing: %s
O_DIRECT will be used
Failed to scan devices.
Completed: %s
/run/lvm/lvmlockd.socket
LVM_LVMLOCKD_SOCKET
lvm.static
initrd-lvm
/dev/null
stdin stream open
stdin stream open: %s
stdout stream open
stderr stream open: %s
opendir
RLIMIT_NOFILE
getrlimit
closedir
/usr/sbin/lvm
LVM_DID_EXEC
unsetenv
2.4.
Please supply an LVM command.
Too many arguments: %s
quit
exit
fclose
No such command.  Try 'help'.
LVM_SUPPRESS_FD_WARNINGS
--abort
--activationmode
--addtag
--aligned
--alloc
--atomic
--atversion
--binary
--bootloaderareasize
--cache
--cachemode
--cachepool
--commandprofile
--config
--type
--corelog
--dataalignment
--dataalignmentoffset
--deltag
--detachprofile
--discards
--driverloaded
--errorwhenfull
--force
--foreign
--handlemissingpvs
--ignoreadvanced
--ignorelocal
--ignorelockingfailure
--ignoremonitoring
--ignoreskippedcluster
--ignoreunsupported
--labelsector
--lockopt
--lockstart
--lockstop
--locktype
--maxrecoveryrate
--mergedconfig
--metadatacopies
--metadataignore
--metadataprofile
--metadatasize
--minor
--minrecoveryrate
--mirrorlog
--mirrorsonly
--mknodes
--monitor
--nameprefixes
--noheadings
--nolocking
--norestorefile
--nosuffix
--nosync
--noudevsync
--originname
--setphysicalvolumesize
--poll
--polloperation
--pooldatasize
--poolmetadata
--poolmetadatasize
--poolmetadataspare
--profile
--pvmetadatacopies
--raidmaxrecoveryrate
--raidminrecoveryrate
--raidsyncaction
--raidwritebehind
--raidwritemostly
--readonly
--refresh
--removemissing
--replace
--restorefile
--restoremissing
--resync
--rows
--segments
--separator
--shared
--splitcache
--splitmirrors
--splitsnapshot
--showdeprecated
--showunsupported
--stripes
--syncaction
--sysinit
--systemid
--thinpool
--trackchanges
--trustcache
--unbuffered
--cachepolicy
--cachesettings
--unconfigured
--units
--unquoted
--usepolicies
--validate
--version
--vgmetadatacopies
--virtualoriginsize
--withsummary
--withcomments
--withspaces
--withversions
--writebehind
--writemostly
--allocation
--available
--resizable
--activate
--all
--autobackup
--activevolumegroups
--background
--blockdevice
--chunksize
--clustered
--colon
--columns
--contiguous
--debug
--exported
--physicalextent
--file
--full
--help
--interval
--iop_version
--stripesize
--logicalvolume
--maxlogicalvolumes
--extents
--list
--lvmpartition
--logicalextent
--size
--persistent
--major
--setactivationskip
--ignoreactivationskip
--maps
--mirrors
--metadatatype
--name
--nofsck
--novolumegroup
--oldpath
--options
--sort
--maxphysicalvolumes
--permission
--partial
--physicalvolume
--quiet
--readahead
--resizefs
--reset
--regionsize
--physicalextentsize
--snapshot
--short
--stdin
--select
--test
--thin
--uuid
--uuidlist
--verbose
--volumegroup
--virtualsize
--wipesignatures
--allocatable
--resizeable
--yes
--zero
There's no 'pvdata' command in LVM2.
Use lvs, pvs, vgs instead; or use vgcfgbackup and read the text file backup.
Metadata in LVM1 format can still be displayed using LVM1's pvdata command.
Use 'lvm help <command>' for more information
File descriptor %d (%s) leaked on %s invocation.
Close failed on stray file descriptor %d (%s): %s
Failed to create LVM1 tool pathname
WARNING: Running as a non-root user. Functionality may be unavailable.
Unable to allocate memory for command line arguments.
Option%s%c%s%s may not be repeated.
Percentage is too big (>=%d%%).
Size is not a multiple of 512. Try using %lu or %lu.
%s and %s are synonyms.  Please only supply one.
config
	[-f|--file filename]
	[--type {current|default|diff|full|list|missing|new|profilable|profilable-command|profilable-metadata}
	[--atversion version]]
	[--ignoreadvanced]
	[--ignoreunsupported]
	[--ignorelocal]
	[-l|--list]
	[--config ConfigurationString]
	[--commandprofile ProfileName]
	[--profile ProfileName]
	[--metadataprofile ProfileName]
	[--mergedconfig]
	[--showdeprecated]
	[--showunsupported]
	[--validate]
	[--withsummary]
	[--withcomments]
	[--withspaces]
	[--unconfigured]
	[--withversions]
	[ConfigurationNode...]
Display and manipulate configuration information
devtypes
	[--aligned]
	[--binary]
	[--commandprofile ProfileName]
	[-d|--debug]
	[-h|--help]
	[--nameprefixes]
	[--noheadings]
	[--nosuffix]
	[-o|--options [+]Field[,Field]]
	[-O|--sort [+|-]key1[,[+|-]key2[,...]]]
	[--rows]
	[-S|--select Selection]
	[--separator Separator]
	[--unbuffered]
	[--unquoted]
	[--version]
Display recognised built-in block device types
dumpconfig
	[-f|--file filename]
	[--type {current|default|diff|full|list|missing|new|profilable|profilable-command|profilable-metadata}
	[--atversion version]]
	[--ignoreadvanced]
	[--ignoreunsupported]
	[--ignorelocal]
	[-l|--list]
	[--config ConfigurationString]
	[--commandprofile ProfileName]
	[--profile ProfileName]
	[--metadataprofile ProfileName]
	[--mergedconfig]
	[--showdeprecated]
	[--showunsupported]
	[--validate]
	[--withsummary]
	[--withcomments]
	[--withspaces]
	[--unconfigured]
	[--withversions]
	[ConfigurationNode...]
List available metadata formats
lvchange
	[-A|--autobackup y|n]
	[-a|--activate [a|e|l]{y|n}]
	[--activationmode {complete|degraded|partial}	[--addtag Tag]
	[--alloc AllocationPolicy]
	[-C|--contiguous y|n]
	[--cachepolicy policyname] [--cachesettings parameter=value]
	[--commandprofile ProfileName]
	[-d|--debug]
	[--deltag Tag]
	[--detachprofile]
	[--errorwhenfull {y|n}]
	[-f|--force]
	[-h|--help]
	[--discards {ignore|nopassdown|passdown}]
	[--ignorelockingfailure]
	[--ignoremonitoring]
	[--ignoreskippedcluster]
	[-k|--setactivationskip {y|n}]
	[-K|--ignoreactivationskip]
	[--monitor {y|n}]
	[--poll {y|n}]
	[--noudevsync]
	[-M|--persistent y|n] [-j|--major major] [--minor minor]
	[--metadataprofile ProfileName]
	[-P|--partial]
	[-p|--permission r|rw]
	[--[raid]minrecoveryrate Rate]
	[--[raid]maxrecoveryrate Rate]
	[--[raid]syncaction {check|repair}
	[--[raid]writebehind IOCount]
	[--[raid]writemostly PhysicalVolume[:{t|n|y}]]
	[-r|--readahead ReadAheadSectors|auto|none]
	[--refresh]
	[--resync]
	[-S|--select Selection]
	[--sysinit]
	[-t|--test]
	[-v|--verbose]
	[--version]
	[-y|--yes]
	[-Z|--zero {y|n}]
	LogicalVolume[Path] [LogicalVolume[Path]...]
Change the attributes of logical volume(s)
lvconvert [-m|--mirrors Mirrors [{--mirrorlog {disk|core|mirrored}|--corelog}]]
	[--type SegmentType]
	[--repair [--use-policies]]
	[--replace PhysicalVolume]
	[-R|--regionsize MirrorLogRegionSize]
	[--alloc AllocationPolicy]
	[-b|--background]
	[-f|--force]
	[-i|--interval seconds]
	[--stripes Stripes [-I|--stripesize StripeSize]]
	[--commandprofile ProfileName] [-d|--debug] [-h|-?|--help]
	[--noudevsync] [-t|--test] [-v|--verbose] [--version] [-y|--yes]
	LogicalVolume[Path] [PhysicalVolume[Path]...]
lvconvert [--splitmirrors Images --trackchanges]
	[--splitmirrors Images --name SplitLogicalVolumeName]
	[--commandprofile ProfileName] [-d|--debug] [-h|-?|--help]
	[--noudevsync] [-t|--test] [-v|--verbose] [--version] [-y|--yes]
	LogicalVolume[Path] [SplittablePhysicalVolume[Path]...]
lvconvert --splitsnapshot
	[--commandprofile ProfileName] [-d|--debug] [-h|-?|--help]
	[--noudevsync] [-t|--test] [-v|--verbose] [--version] [-y|--yes]
	SnapshotLogicalVolume[Path]
lvconvert --splitcache
	[--commandprofile ProfileName] [-d|--debug] [-h|-?|--help]
	[--noudevsync] [-t|--test] [-v|--verbose] [--version] [-y|--yes]
	CacheLogicalVolume[Path]
lvconvert --split
	[--name SplitLogicalVolumeName]
	[--commandprofile ProfileName] [-d|--debug] [-h|-?|--help]
	[--noudevsync] [-t|--test] [-v|--verbose] [--version] [-y|--yes]
	SplitableLogicalVolume[Path]
lvconvert --uncache
	[--commandprofile ProfileName] [-d|--debug] [-h|-?|--help]
	[--noudevsync] [-t|--test] [-v|--verbose] [--version] [-y|--yes]
	CacheLogicalVolume[Path]
lvconvert [--type snapshot|-s|--snapshot]
	[-c|--chunksize]
	[-Z|--zero {y|n}]
	[--commandprofile ProfileName] [-d|--debug] [-h|-?|--help]
	[--noudevsync] [-t|--test] [-v|--verbose] [--version] [-y|--yes]
	OriginalLogicalVolume[Path] SnapshotLogicalVolume[Path]
lvconvert --merge
	[-b|--background]
	[-i|--interval seconds]
	[--commandprofile ProfileName] [-d|--debug] [-h|-?|--help]
	[--noudevsync] [-t|--test] [-v|--verbose] [--version] [-y|--yes]
	LogicalVolume[Path]
lvconvert [--type thin[-pool]|-T|--thin]
	[--thinpool ThinPoolLogicalVolume[Path]]
	[--chunksize size]
	[--discards {ignore|nopassdown|passdown}]
	[--poolmetadataspare {y|n}]
	[{--poolmetadata ThinMetadataLogicalVolume[Path] |
	 --poolmetadatasize size}]
	[-r|--readahead ReadAheadSectors|auto|none]
	[--stripes Stripes [-I|--stripesize StripeSize]]]
	[--originname NewExternalOriginVolumeName]]
	[-Z|--zero {y|n}]
	[--commandprofile ProfileName] [-d|--debug] [-h|-?|--help]
	[--noudevsync] [-t|--test] [-v|--verbose] [--version] [-y|--yes]
	[ExternalOrigin|ThinDataPool]LogicalVolume[Path] [PhysicalVolumePath...]
lvconvert [--type cache[-pool]|-H|--cache]
	[--cachepool CacheDataLogicalVolume[Path]]
	[--cachemode CacheMode]
	[--cachepolicy policy]
	[--cachesettings key=value]
	[--chunksize size]
	[--poolmetadataspare {y|n}]]
	[{--poolmetadata CacheMetadataLogicalVolume[Path] |
	 --poolmetadatasize size}]
	[--commandprofile ProfileName] [-d|--debug] [-h|-?|--help]
	[--noudevsync] [-t|--test] [-v|--verbose] [--version] [-y|--yes]
	[Cache|CacheDataPool]LogicalVolume[Path] [PhysicalVolumePath...]
lvcreate
	[-A|--autobackup {y|n}]
	[-a|--activate [a|e|l]{y|n}]
	[--addtag Tag]
	[--alloc AllocationPolicy]
	[-H|--cache
	  [--cachemode {writeback|writethrough}]
	  [--cachepolicy policy]
	  [--cachesettings key=value]
	[--cachepool CachePoolLogicalVolume{Name|Path}]
	[-c|--chunksize ChunkSize]
	[-C|--contiguous {y|n}]
	[--commandprofile ProfileName]
	[-d|--debug]
	[-h|-?|--help]
	[--errorwhenfull {y|n}]
	[--ignoremonitoring]
	[--monitor {y|n}]
	[-i|--stripes Stripes [-I|--stripesize StripeSize]]
	[-k|--setactivationskip {y|n}]
	[-K|--ignoreactivationskip]
	{-l|--extents LogicalExtentsNumber[%{VG|PVS|FREE}] |
	 -L|--size LogicalVolumeSize[bBsSkKmMgGtTpPeE]}
	[-M|--persistent {y|n}] [-j|--major major] [--minor minor]
	[--metadataprofile ProfileName]
	[-m|--mirrors Mirrors [--nosync]
	  [{--mirrorlog {disk|core|mirrored}|--corelog}]]
	[-n|--name LogicalVolumeName]
	[--noudevsync]
	[-p|--permission {r|rw}]
	[--poolmetadatasize MetadataSize[bBsSkKmMgG]]
	[--poolmetadataspare {y|n}]]
	[--[raid]minrecoveryrate Rate]
	[--[raid]maxrecoveryrate Rate]
	[-r|--readahead {ReadAheadSectors|auto|none}]
	[-R|--regionsize MirrorLogRegionSize]
	[-T|--thin
	  [--discards {ignore|nopassdown|passdown}]
	[--thinpool ThinPoolLogicalVolume{Name|Path}]
	[-t|--test]
	[--type VolumeType]
	[-v|--verbose]
	[-W|--wipesignatures {y|n}]
	[-Z|--zero {y|n}]
	[--version]
	VolumeGroupName [PhysicalVolumePath...]
lvcreate
	{ {-s|--snapshot} OriginalLogicalVolume[Path] |
	  [-s|--snapshot] VolumeGroupName[Path] -V|--virtualsize VirtualSize}
	  {-H|--cache} VolumeGroupName[Path][/OriginalLogicalVolume]
	  {-T|--thin} VolumeGroupName[Path][/PoolLogicalVolume]
	              -V|--virtualsize VirtualSize}
	[-A|--autobackup {y|n}]
	[--addtag Tag]
	[--alloc AllocationPolicy]
	[--cachepolicy Policy] [--cachesettings Key=Value]
	[-c|--chunksize]
	[-C|--contiguous {y|n}]
	[--commandprofile ProfileName]
	[-d|--debug]
	[--discards {ignore|nopassdown|passdown}]
	[-h|-?|--help]
	[--ignoremonitoring]
	[--monitor {y|n}]
	[-i|--stripes Stripes [-I|--stripesize StripeSize]]
	[-k|--setactivationskip {y|n}]
	[-K|--ignoreactivationskip]
	{-l|--extents LogicalExtentsNumber[%{VG|FREE|ORIGIN}] |
	 -L|--size LogicalVolumeSize[bBsSkKmMgGtTpPeE]}
	[--poolmetadatasize MetadataVolumeSize[bBsSkKmMgG]]
	[-M|--persistent {y|n}] [-j|--major major] [--minor minor]
	[--metadataprofile ProfileName]
	[-n|--name LogicalVolumeName]
	[--noudevsync]
	[-p|--permission {r|rw}]
	[-r|--readahead ReadAheadSectors|auto|none]
	[-t|--test]
	[{--thinpool ThinPoolLogicalVolume[Path] |
	  --cachepool CachePoolLogicalVolume[Path]}]
	[-v|--verbose]
	[--version]
	[PhysicalVolumePath...]
lvdisplay
	[-a|--all]
	[-c|--colon]
	[--commandprofile ProfileName]
	[-d|--debug]
	[--foreign]
	[-h|--help]
	[--ignorelockingfailure]
	[--ignoreskippedcluster]
	[-m|--maps]
	[--nosuffix]
	[-P|--partial]
	[--readonly]
	[-S|--select Selection]
	[--units hHbBsSkKmMgGtTpPeE]
	[-v|--verbose]
	[--version]
	[LogicalVolume[Path] [LogicalVolume[Path]...]]
lvdisplay --columns|-C
	[--aligned]
	[-a|--all]
	[--binary]
	[--commandprofile ProfileName]
	[-d|--debug]
	[--foreign]
	[-h|--help]
	[--ignorelockingfailure]
	[--ignoreskippedcluster]
	[--noheadings]
	[--nosuffix]
	[-o|--options [+]Field[,Field]]
	[-O|--sort [+|-]key1[,[+|-]key2[,...]]]
	[-S|--select Selection]
	[-P|--partial]
	[--readonly]
	[--segments]
	[--separator Separator]
	[--unbuffered]
	[--units hHbBsSkKmMgGtTpPeE]
	[-v|--verbose]
	[--version]
	[LogicalVolume[Path] [LogicalVolume[Path]...]]
Display information about a logical volume
lvextend
	[-A|--autobackup y|n]
	[--alloc AllocationPolicy]
	[--commandprofile ProfileName]
	[-d|--debug]
	[-f|--force]
	[-h|--help]
	[-i|--stripes Stripes [-I|--stripesize StripeSize]]
	{-l|--extents [+]LogicalExtentsNumber[%{VG|LV|PVS|FREE|ORIGIN}] |
	 -L|--size [+]LogicalVolumeSize[bBsSkKmMgGtTpPeE]}
	 --poolmetadatasize [+]MetadataVolumeSize[bBsSkKmMgG]}
	[-m|--mirrors Mirrors]
	[--nosync]
	[--use-policies]
	[-n|--nofsck]
	[--noudevsync]
	[-r|--resizefs]
	[-t|--test]
	[--type VolumeType]
	[-v|--verbose]
	[--version]
	LogicalVolume[Path] [ PhysicalVolumePath... ]
lvmchange
	[--commandprofile ProfileName]
	[-d|--debug]
	[-h|--help]
	[-R|--reset]
	[-v|--verbose]
	[--version]
With the device mapper, this is obsolete and does nothing.
lvmconfig
	[-f|--file filename]
	[--type {current|default|diff|full|list|missing|new|profilable|profilable-command|profilable-metadata}
	[--atversion version]]
	[--ignoreadvanced]
	[--ignoreunsupported]
	[--ignorelocal]
	[-l|--list]
	[--config ConfigurationString]
	[--commandprofile ProfileName]
	[--profile ProfileName]
	[--metadataprofile ProfileName]
	[--mergedconfig]
	[--showdeprecated]
	[--showunsupported]
	[--validate]
	[--withsummary]
	[--withcomments]
	[--withspaces]
	[--unconfigured]
	[--withversions]
	[ConfigurationNode...]
lvmdiskscan
	[--commandprofile ProfileName]
	[-d|--debug]
	[-h|--help]
	[-l|--lvmpartition]
	[--readonly]
	[--version]
List devices that may be used as physical volumes
lvmsadc
	[--commandprofile ProfileName]
	[-d|--debug]
	[-h|--help]
	[-v|--verbose]
	[--version]
	[LogFilePath]
lvmsar
	[--commandprofile ProfileName]
	[-d|--debug]
	[-f|--full]
	[-h|--help]
	[-s|--stdin]
	[-v|--verbose]
	[--version]
	LogFilePath
lvreduce
	[-A|--autobackup y|n]
	[--commandprofile ProfileName]
	[-d|--debug]
	[-f|--force]
	[-h|--help]
	{-l|--extents [-]LogicalExtentsNumber[%{VG|LV|FREE|ORIGIN}] |
	 -L|--size [-]LogicalVolumeSize[bBsSkKmMgGtTpPeE]}
	[-n|--nofsck]
	[--noudevsync]
	[-r|--resizefs]
	[-t|--test]
	[-v|--verbose]
	[--version]
	[-y|--yes]
	LogicalVolume[Path]
Reduce the size of a logical volume
lvremove
	[-A|--autobackup y|n]
	[--commandprofile ProfileName]
	[-d|--debug]
	[-f|--force]
	[-h|--help]
	[--noudevsync]
	[-S|--select Selection]
	[-t|--test]
	[-v|--verbose]
	[--version]
	LogicalVolume[Path] [LogicalVolume[Path]...]
Remove logical volume(s) from the system
lvrename
	[-A|--autobackup {y|n}]
	[--commandprofile ProfileName]
	[-d|--debug]
	[-h|-?|--help]
	[--noudevsync]
	[-t|--test]
	[-v|--verbose]
	[--version]
	{ OldLogicalVolumePath NewLogicalVolumePath |
	  VolumeGroupName OldLogicalVolumeName NewLogicalVolumeName }
lvresize
	[-A|--autobackup y|n]
	[--alloc AllocationPolicy]
	[--commandprofile ProfileName]
	[-d|--debug]
	[-f|--force]
	[-h|--help]
	[-i|--stripes Stripes [-I|--stripesize StripeSize]]
	{-l|--extents [+|-]LogicalExtentsNumber[%{VG|LV|PVS|FREE|ORIGIN}] |
	 -L|--size [+|-]LogicalVolumeSize[bBsSkKmMgGtTpPeE]}
	 --poolmetadatasize [+]MetadataVolumeSize[bBsSkKmMgG]}
	[-n|--nofsck]
	[--noudevsync]
	[-r|--resizefs]
	[-t|--test]
	[--type VolumeType]
	[-v|--verbose]
	[--version]
	LogicalVolume[Path] [ PhysicalVolumePath... ]
	[-a|--all]
	[--aligned]
	[--binary]
	[--commandprofile ProfileName]
	[-d|--debug]
	[--foreign]
	[-h|--help]
	[--ignorelockingfailure]
	[--ignoreskippedcluster]
	[--nameprefixes]
	[--noheadings]
	[--nosuffix]
	[-o|--options [+]Field[,Field]]
	[-O|--sort [+|-]key1[,[+|-]key2[,...]]]
	[-P|--partial]
	[--readonly]
	[--rows]
	[--segments]
	[-S|--select Selection]
	[--separator Separator]
	[--trustcache]
	[--unbuffered]
	[--units hHbBsSkKmMgGtTpPeE]
	[--unquoted]
	[-v|--verbose]
	[--version]
	[LogicalVolume[Path] [LogicalVolume[Path]...]]
Display information about logical volumes
lvscan
	[-a|--all]
	[-b|--blockdevice]
	[--cache]
	[--commandprofile ProfileName]
	[-d|--debug]
	[-h|-?|--help]
	[--ignorelockingfailure]
	[-P|--partial]
	[--readonly]
	[-v|--verbose]
	[--version]
List all logical volumes in all volume groups
pvchange
	[-a|--all]
	[-A|--autobackup y|n]
	[--commandprofile ProfileName]
	[-d|--debug]
	[-f|--force]
	[-h|--help]
	[--ignoreskippedcluster]
	[--metadataignore y|n]
	[-S|--select Selection]
	[-t|--test]
	[-u|--uuid]
	[-x|--allocatable y|n]
	[-v|--verbose]
	[--addtag Tag]
	[--deltag Tag]
	[--version]
	[PhysicalVolumePath...]
Change attributes of physical volume(s)
pvresize
	[--commandprofile ProfileName]
	[-d|--debug]
	[-h|-?|--help]
	[--setphysicalvolumesize PhysicalVolumeSize[bBsSkKmMgGtTpPeE]
	[-t|--test]
	[-v|--verbose]
	[--version]
	PhysicalVolume [PhysicalVolume...]
pvck 	[--commandprofile ProfileName]
	[-d|--debug]
	[-h|--help]
	[--labelsector sector]
	[-v|--verbose]
	[--version]
	PhysicalVolume [PhysicalVolume...]
Check the consistency of physical volume(s)
pvcreate
	[--norestorefile]
	[--restorefile file]
	[--commandprofile ProfileName]
	[-d|--debug]
	[-f[f]|--force [--force]]
	[-h|-?|--help]
	[--labelsector sector]
	[-M|--metadatatype 1|2]
	[--pvmetadatacopies #copies]
	[--bootloaderareasize BootLoaderAreaSize[bBsSkKmMgGtTpPeE]]
	[--metadatasize MetadataSize[bBsSkKmMgGtTpPeE]]
	[--dataalignment Alignment[bBsSkKmMgGtTpPeE]]
	[--dataalignmentoffset AlignmentOffset[bBsSkKmMgGtTpPeE]]
	[--setphysicalvolumesize PhysicalVolumeSize[bBsSkKmMgGtTpPeE]
	[-t|--test]
	[-u|--uuid uuid]
	[-v|--verbose]
	[-y|--yes]
	[-Z|--zero {y|n}]
	[--version]
	PhysicalVolume [PhysicalVolume...]
Initialize physical volume(s) for use by LVM
pvdata
	[-a|--all]
	[--commandprofile ProfileName]
	[-d|--debug]
	[-E|--physicalextent]
	[-h|-?|--help]
	[-L|--logicalvolume]
	[-P[P]|--physicalvolume [--physicalvolume]]
	[-U|--uuidlist]
	[-v[v]|--verbose [--verbose]]
	[-V|--volumegroup]
	[--version]
	PhysicalVolume [PhysicalVolume...]
Display the on-disk metadata for physical volume(s)
pvdisplay
	[-c|--colon]
	[--commandprofile ProfileName]
	[-d|--debug]
	[--foreign]
	[-h|--help]
	[--ignorelockingfailure]
	[--ignoreskippedcluster]
	[-m|--maps]
	[--nosuffix]
	[--readonly]
	[-S|--select Selection]
	[-s|--short]
	[--units hHbBsSkKmMgGtTpPeE]
	[-v|--verbose]
	[--version]
	[PhysicalVolumePath [PhysicalVolumePath...]]
pvdisplay --columns|-C
	[--aligned]
	[-a|--all]
	[--binary]
	[--commandprofile ProfileName]
	[-d|--debug]
	[--foreign]
	[-h|--help]
	[--ignorelockingfailure]
	[--ignoreskippedcluster]
	[--noheadings]
	[--nosuffix]
	[-o|--options [+]Field[,Field]]
	[-O|--sort [+|-]key1[,[+|-]key2[,...]]]
	[-S|--select Selection]
	[--readonly]
	[--separator Separator]
	[--unbuffered]
	[--units hHbBsSkKmMgGtTpPeE]
	[-v|--verbose]
	[--version]
	[PhysicalVolumePath [PhysicalVolumePath...]]
Display various attributes of physical volume(s)
pvmove
	[--abort]
	[--alloc AllocationPolicy]
	[--atomic]
	[-A|--autobackup {y|n}]
	[-b|--background]
	[--commandprofile ProfileName]
	[-d|--debug]
 	[-h|-?|--help]
	[-i|--interval seconds]
	[--noudevsync]
	[-t|--test]
 	[-v|--verbose]
 	[--version]
	[{-n|--name} LogicalVolume]
	SourcePhysicalVolume[:PhysicalExtent[-PhysicalExtent]...]}
	[DestinationPhysicalVolume[:PhysicalExtent[-PhysicalExtent]...]...]
Move extents from one physical volume to another
	[--abort]
	[-A|--autobackup {y|n}]
	[--commandprofile ProfileName]
	[-d|--debug]
 	[-h|-?|--help]
	[--handlemissingpvs]
	[-i|--interval seconds]
	[--polloperation]
	[-t|--test]
 	[-v|--verbose]
 	[--version]
Continue already initiated poll operation on a logical volume
pvremove
	[--commandprofile ProfileName]
	[-d|--debug]
	[-f[f]|--force [--force]]
	[-h|-?|--help]
	[-t|--test]
	[-v|--verbose]
	[--version]
	[-y|--yes]
	PhysicalVolume [PhysicalVolume...]
Remove LVM label(s) from physical volume(s)
	[-a|--all]
	[--aligned]
	[--binary]
	[--commandprofile ProfileName]
	[-d|--debug]
	[--foreign]
	[-h|-?|--help]
	[--ignorelockingfailure]
	[--ignoreskippedcluster]
	[--nameprefixes]
	[--noheadings]
	[--nosuffix]
	[-o|--options [+]Field[,Field]]
	[-O|--sort [+|-]key1[,[+|-]key2[,...]]]
	[-P|--partial]
	[--readonly]
	[--rows]
	[--segments]
	[-S|--select Selection]
	[--separator Separator]
	[--trustcache]
	[--unbuffered]
	[--units hHbBsSkKmMgGtTpPeE]
	[--unquoted]
	[-v|--verbose]
	[--version]
	[PhysicalVolume [PhysicalVolume...]]
Display information about physical volumes
pvscan
	[-b|--background]
	[--cache [-a|--activate ay] [ DevicePath | -j|--major major --minor minor]...]
	[--commandprofile ProfileName]
	[-d|--debug]
	{-e|--exported | -n|--novolumegroup}
	[-h|-?|--help]
	[--ignorelockingfailure]
	[-P|--partial]
	[--readonly]
	[-s|--short]
	[-u|--uuid]
	[-v|--verbose]
	[--version]
Display the system ID, if any, currently set on this host
List tags defined on this host
vgcfgbackup
	[--commandprofile ProfileName]
	[-d|--debug]
	[-f|--file filename]
	[--foreign]
	[-h|-?|--help]
	[--ignorelockingfailure]
	[-P|--partial]
	[--readonly]
	[-v|--verbose]
	[--version]
	[VolumeGroupName...]
Backup volume group configuration(s)
vgcfgrestore
	[--commandprofile ProfileName]
	[-d|--debug]
	[-f|--file filename]
	[--force]
	[-l[l]|--list [--list]]
	[-M|--metadatatype 1|2]
	[-h|--help]
	[-t|--test]
	[-v|--verbose]
	[--version]
	VolumeGroupName
Restore volume group configuration
vgchange
	[-A|--autobackup {y|n}]
	[--alloc AllocationPolicy]
	[-P|--partial]
	[--commandprofile ProfileName]
	[-d|--debug]
	[--detachprofile]
	[-h|--help]
	[--ignorelockingfailure]
	[--ignoremonitoring]
	[--ignoreskippedcluster]
	[-K|--ignoreactivationskip]
	[--metadataprofile ProfileName]
	[--monitor {y|n}]
	[--[vg]metadatacopies #copies]
	[--poll {y|n}]
	[--noudevsync]
	[--refresh]
	[-S|--select Selection]
	[--sysinit]
	[--systemid SystemID]
	[-t|--test]
	[-u|--uuid]
	[-v|--verbose]
	[--version]
	{-a|--activate [a|e|l]{y|n}  |
	[--activationmode {complete|degraded|partial}]
	 -c|--clustered {y|n} |
	 -x|--resizeable {y|n} |
	 -l|--logicalvolume MaxLogicalVolumes |
	 -p|--maxphysicalvolumes MaxPhysicalVolumes |
	 -s|--physicalextentsize PhysicalExtentSize[bBsSkKmMgGtTpPeE] |
	 --addtag Tag |
	 --deltag Tag}
	[VolumeGroupName...]
Change volume group attributes
vgck 	[--commandprofile ProfileName]
	[-d|--debug]
	[-h|--help]
	[-v|--verbose]
	[--version]
	[VolumeGroupName...]
Check the consistency of volume group(s)
vgconvert
	[--commandprofile ProfileName]
	[-d|--debug]
	[-h|--help]
	[--labelsector sector]
	[-M|--metadatatype 1|2]
	[--pvmetadatacopies #copies]
	[--metadatasize MetadataSize[bBsSkKmMgGtTpPeE]]
	[--bootloaderareasize BootLoaderAreaSize[bBsSkKmMgGtTpPeE]]
	[-t|--test]
	[-v|--verbose]
	[--version]
	VolumeGroupName [VolumeGroupName...]
Change volume group metadata format
vgcreate
	[-A|--autobackup {y|n}]
	[--addtag Tag]
	[--alloc AllocationPolicy]
	[-c|--clustered {y|n}]
	[--commandprofile ProfileName]
	[-d|--debug]
	[-h|--help]
	[-l|--maxlogicalvolumes MaxLogicalVolumes]
	[--metadataprofile ProfileName]
	[-M|--metadatatype 1|2]
	[--[vg]metadatacopies #copies]
	[-p|--maxphysicalvolumes MaxPhysicalVolumes]
	[-s|--physicalextentsize PhysicalExtentSize[bBsSkKmMgGtTpPeE]]
	[--systemid SystemID]
	[-t|--test]
	[-v|--verbose]
	[--version]
	[-y|--yes]
	[ PHYSICAL DEVICE OPTIONS ]
	VolumeGroupName PhysicalDevicePath [PhysicalDevicePath...]
vgdisplay
	[-A|--activevolumegroups]
	[-c|--colon | -s|--short | -v|--verbose]
	[--commandprofile ProfileName]
	[-d|--debug]
	[--foreign]
	[-h|--help]
	[--ignorelockingfailure]
	[--ignoreskippedcluster]
	[--nosuffix]
	[-P|--partial]
	[--readonly]
	[-S|--select Selection]
	[--units hHbBsSkKmMgGtTpPeE]
	[--version]
	[VolumeGroupName [VolumeGroupName...]]
vgdisplay --columns|-C
	[--aligned]
	[--binary]
	[--commandprofile ProfileName]
	[-d|--debug]
	[--foreign]
	[-h|--help]
	[--ignorelockingfailure]
	[--ignoreskippedcluster]
	[--noheadings]
	[--nosuffix]
	[-o|--options [+]Field[,Field]]
	[-O|--sort [+|-]key1[,[+|-]key2[,...]]]
	[-P|--partial]
	[-S|--select Selection]
	[--readonly]
	[--separator Separator]
	[--unbuffered]
	[--units hHbBsSkKmMgGtTpPeE]
	[--verbose]
	[--version]
	[VolumeGroupName [VolumeGroupName...]]
Display volume group information
vgexport
	[-a|--all]
	[--commandprofile ProfileName]
	[-d|--debug]
	[-h|--help]
	[-S|--select Selection]
	[-v|--verbose]
	[--version]
	VolumeGroupName [VolumeGroupName...]
Unregister volume group(s) from the system
vgextend
	[-A|--autobackup y|n]
	[--restoremissing]
	[--commandprofile ProfileName]
	[-d|--debug]
	[-f|--force]
	[-h|--help]
	[-t|--test]
	[-v|--verbose]
	[--version]
	[-y|--yes]
	[ PHYSICAL DEVICE OPTIONS ]
	VolumeGroupName PhysicalDevicePath [PhysicalDevicePath...]
Add physical volumes to a volume group
vgimport
	[-a|--all]
	[--commandprofile ProfileName]
	[-d|--debug]
	[-f|--force]
	[-h|--help]
	[-S|--select Selection]
	[-t|--test]
	[-v|--verbose]
	[--version]
	VolumeGroupName...
Register exported volume group with system
vgmerge
	[-A|--autobackup y|n]
	[--commandprofile ProfileName]
	[-d|--debug]
	[-h|--help]
	[-l|--list]
	[-t|--test]
	[-v|--verbose]
	[--version]
	DestinationVolumeGroupName SourceVolumeGroupName
vgmknodes
	[--commandprofile ProfileName]
	[-d|--debug]
	[-h|--help]
	[--ignorelockingfailure]
	[--refresh]
	[-v|--verbose]
	[--version]
	[VolumeGroupName...]
Create the special files for volume group devices in /dev
vgreduce
	[-a|--all]
	[-A|--autobackup y|n]
	[--commandprofile ProfileName]
	[-d|--debug]
	[-h|--help]
	[--mirrorsonly]
	[--removemissing]
	[-f|--force]
	[-t|--test]
	[-v|--verbose]
	[--version]
	VolumeGroupName
	[PhysicalVolumePath...]
Remove physical volume(s) from a volume group
vgremove
	[--commandprofile ProfileName]
	[-d|--debug]
	[-f|--force]
	[-h|--help]
	[--noudevsync]
	[-S|--select Selection]
	[-t|--test]
	[-v|--verbose]
	[--version]
	VolumeGroupName [VolumeGroupName...]
vgrename
	[-A|--autobackup y|n]
	[--commandprofile ProfileName]
	[-d|--debug]
	[-h|--help]
	[-t|--test]
	[-v|--verbose]
	[--version]
	OldVolumeGroupPath NewVolumeGroupPath |
	OldVolumeGroupName NewVolumeGroupName
	[--aligned]
	[--binary]
	[-a|--all]
	[--commandprofile ProfileName]
	[-d|--debug]
	[--foreign]
	[-h|--help]
	[--ignorelockingfailure]
	[--ignoreskippedcluster]
	[--nameprefixes]
	[--noheadings]
	[--nosuffix]
	[-o|--options [+]Field[,Field]]
	[-O|--sort [+|-]key1[,[+|-]key2[,...]]]
	[-P|--partial]
	[--readonly]
	[--rows]
	[-S|--select Selection]
	[--separator Separator]
	[--trustcache]
	[--unbuffered]
	[--units hHbBsSkKmMgGtTpPeE]
	[--unquoted]
	[-v|--verbose]
	[--version]
	[VolumeGroupName [VolumeGroupName...]]
Display information about volume groups
vgscan 	[--cache]
	[--commandprofile ProfileName]
	[-d|--debug]
	[-h|--help]
	[--ignorelockingfailure]
	[--mknodes]
	[-P|--partial]
	[-v|--verbose]
	[--version]
vgsplit
	[-A|--autobackup {y|n}]
	[--alloc AllocationPolicy]
	[-c|--clustered {y|n}]
	[--commandprofile ProfileName]
	[-d|--debug]
	[-h|--help]
	[-l|--maxlogicalvolumes MaxLogicalVolumes]
	[-M|--metadatatype 1|2]
	[--[vg]metadatacopies #copies]
	[-n|--name LogicalVolumeName]
	[-p|--maxphysicalvolumes MaxPhysicalVolumes]
	[-t|--test]
	[-v|--verbose]
	[--version]
	SourceVolumeGroupName DestinationVolumeGroupName
	[PhysicalVolumePath...]
Move physical volumes into a new or existing volume group
Display software and driver version information
Error during parsing of command line.
Updated config file invalid. Aborting.
Command profile '%s' requested via environment variable.
Only one of --profile or  --metadataprofile allowed.
Only one of --profile or --commandprofile allowed.
PARTIAL MODE. Incomplete logical volumes will be processed.
--partial and --activationmode are mutually exclusive arguments
Invalid activation mode given.
--trustcache is incompatible with --all
WARNING: Cache file of PVs will be trusted.  New devices holding PVs may get ignored.
DEGRADED MODE. Incomplete RAID LVs will be processed.
%s: Command not permitted while global/metadata_read_only is set.
Disabling use of lvmetad because read-only is set.
ERROR: configuration setting use_lvmlockd cannot be used with clustered locking_type 3.
Test mode: Wiping internal cache
Run `%s --help' for more information.
Falling back to LVM1 tools, but no command specified.
Line too long (max 255) beginning: %s
Internal error: Failed command did not use log_error
Command failed with status code %d.
/proc/self/fd
Failed to apply %s %s.
Setting global %s "%s".
Failed to add %s %s.
command profile
Giving preference to command profile specified on command line over the one specified via environment variable.
metadata profile
LVM_COMMAND_PROFILE
@%-*s [%15s] %s
lvmdiskscan.c
dev_iter_create failed
Couldn't get size of "%s"
LVM physical volume
dev_close on "%s" failed
%d disk%s
%d partition%s
%d LVM physical volume%s
WARNING: only considering LVM devices
%d LVM physical volume whole disk%s
Please enter one or more logical volume paths or use --select for selection.
lvremove.c
lvrename.c
Old and new logical volume names required
Logical volume names must have the same volume group ("%s" or "%s")
New logical volume name "%s" may not exceed %zu characters.
New logical volume name may not be blank
New logical volume name "%s" is invalid
Old and new logical volume names must differ
Checking for existing volume group "%s"
Existing logical volume "%s" not found in volume group "%s"
Cannot rename a RAID %s directly
Cannot rename %s while it is tracking a split image
Renamed "%s" to "%s" in volume group "%s"
lvresize.c
Finding volume group %s
Please specify either size or extents but not both.
Can't reduce pool metadata size.
Negative argument not permitted - use lvreduce
Positive sign not permitted - use lvextend
Please provide the logical volume name
Mirrors argument may not be negative
Stripesize may not be negative.
Logical volume %s not found in volume group %s
ACTIVE   
Original
Snapshot
        
lvscan.c
%s%s '%s%s/%s' [%s] %s
Ignoring lvscan --cache because lvmetad is not in use.
WARNING: Device for PV %s already missing, skipping.
No additional command line arguments allowed
Can't reread VG for %s
polldaemon.c
Missing LV uuid within: %s/%s
Can't find LV in %s for %s.
%s: No pvmove in progress - already finished or aborted.
Can't find LV in %s for %s. Already finished or removed.
%s: Interrupted: No longer active.
Failed to generate list of copied LVs: can't abort.
ABORTING: Failed to generate list of copied LVs
ABORTING: Segment progression failed.
Poll ID list allocation failed.
Failed to copy one or more poll_operation_id members.
Internal error: Handle is undefined.
Device name for LV %s not found in metadata. (unfinished pvmove mirror removal?)
%s: Skipping inactive LV. Try lvchange or vgchange.
Failed to create poll_id_list.
ABORTING: Mirror percentage check failed.
ABORTING: Can't lock VG for %s.
ABORTING: Can't reread VG for %s.
Argument to --interval cannot be negative.
Checking progress %s waiting every %u seconds.
Volume group containing %s does not support tags
Volume group containing %s has active logical volumes
Can't change tag on Physical Volume %s not in volume group
Allocatability not supported by orphan %s format PV %s
Physical volume "%s" is already allocatable.
Physical volume "%s" is already unallocatable.
Override preferred number of copies of VG %s metadata? [y/n]: 
Failed to generate new random UUID for %s.
pv_write with new uuid failed for %s.
Physical volume %s not changed
Failed to store physical volume "%s" in volume group "%s"
Failed to store physical volume "%s"
Setting physical volume "%s" allocatable
Setting physical volume "%s" NOT allocatable
Please give one or more of -x, -uuid, --addtag, --deltag or --metadataignore
Please give a physical volume path or use --select for selection.
Option --all and PhysicalVolumePath are exclusive.
%d physical volume%s changed / %d physical volume%s not changed
pvchange.c
Changing uuid of %s to %s.
Physical volume "%s" changed
Updating physical volume "%s"
#global
Unable to obtain global lock.
Scanning %s
pvck.c
pvcreate.c
--uuid is required with --restorefile
--restorefile is required with --uuid
Can only set uuid on one volume at once
Unable to read volume group from %s
Can't find uuid %s in backup file %s
Physical volume size may not be negative
Device "%s" has a capacity of %s
Physical volume "%s" of volume group "%s" is exported
"%s" is a new physical volume of "%s"
Option -c not allowed with option -m
Option -c is not allowed with option -s
pvdisplay.c
pvmove.c
Moved
converting
merging
cache-related
snapshot-related
thin-related
RAID
RAID-related
Failed to allocate lvid.
Failed to clone PV name.
pvmove%d
Skipping %s LV, %s
Skipping %s LV %s
Skipping locked LV %s
Logical volume %s not found.
No data to move for %s
Failed to clone VG or LV name.
Failed to allocate poll identifier for pvmove.
Required device-mapper target(s) not detected in your kernel
Enable lvmpolld when using lvmlockd.
Specify pvmove args when using lvmlockd.
--name takes a logical volume name
Named LV and old PV must be in the same VG
Incomplete LV name supplied with --name
Logical volume name %s is invalid
Detected pvmove in progress for %s
Ignoring remaining command line arguments
ABORTING: Failed to generate list of moving LVs
ABORTING: Temporary mirror activation failed.
No extents available for allocation
Creation of temporary pvmove LV failed
lvs_changed list struct allocation failed
Unable to pvmove when %s volumes are present
Skipping %s because a parent is of cache type
Skipping LV %s which is activated exclusively on remote node.
Moving %u extents of logical volume %s/%s
All data on source PV skipped. It contains locked, hidden or non-top level LVs only.
Cannot move in clustered VG %s, clustered mirror (cmirror) not detected and LVs are activated non-exclusively.
Cannot move in clustered VG %s if some LVs are activated exclusively while others don't.
Failed to convert pvmove LV to mirrored
Failed to split segments being moved
Setting up pvmove in on-disk volume group metadata.
ABORTING: Volume group metadata update failed.
ABORTING: Temporary pvmove mirror activation failed.
Unable to resume logical volumes.
ABORTING: Temporary pvmove mirror activation failed. Run pvmove --abort.
ABORTING: Can't read VG for %s.
Internal error: %s is not a proper mirror image
Internal error: %s is not a pvmove mirror of LV-type
Internal error: Mirror image %u not found in segment
Updating volume group metadata.
ABORTING: Temporary pvmove mirror reload failed.
Unable to reactivate logical volume "%s".
ABORTING: Removal of temporary mirror failed
ABORTING: Failed to write new data locations to disk.
ABORTING: Locking LVs to remove temporary mirror failed
Unable to reactivate logical volume "%s"
ABORTING: Unable to deactivate temporary logical volume "%s"
ABORTING: Removal of temporary pvmove LV failed
Writing out final volume group after pvmove
pvmove_poll.c
Removing temporary pvmove LV
Please enter a physical volume path
pvremove.c
Internal error: Invalid resize params.
Please supply physical volume(s)
%d physical volume(s) resized / %d physical volume(s) not resized
pvresize.c
pvscan.c
%s: autoactivation failed.
%i:%i
of exported volume group(s)
in no volume group
Physical Volume %s not found.
%-*s with UUID %s
Invalid PV name with uuid.
PV %-*s    %-*s %s [%s]
Failed to read Volume Group "%s" (%s) during autoactivation.
%s: refresh before autoactivation failed.
Device %s not found. Cleared from lvmetad cache.
Ignoring pvscan --cache command because lvmetad is not in use.
Only --activate ay allowed with pvscan.
Both --major and --minor required to identify devices.
Using physical volume(s) on command line
Failed to parse major:minor from %s
Too many parameters on command line.
--activate is only valid with --cache.
--major and --minor are only valid with --cache.
Options -e and -n are incompatible
WARNING: only considering physical volumes %s
Walking through all physical volumes
PV %-*s  is in exported VG %s [%s / %s free]
PV %-*s VG %-*s %s [%s / %s free]
No matching physical volumes found
Total: %d [%s] / in use: %d [%s] / in no VG: %d [%s]
Can't report LV and PV fields at the same time
Internal error: Unknown report type.
options string allocation failed
WARNING: devtypes currently ignores command line arguments.
Failed to compact report output.
report_for_selection: incorrect report type
reporter.c
reporter_pool
Invalid options string: %s
%s,%s
Internal error: %s for LVS
Internal error: %s for VGS
Internal error: %s for PVS
Internal error: %s
Adding PE range: start PE %u length %u on %s.
Overlapping PE ranges specified (%u-%u, %u-%u) on %s.
Cannot access VG %s with system ID %s with %slocal system ID%s%s.
Skipping foreign volume group %s
Cannot access VG %s with lock type %s that requires lvmlockd.
Cannot process volume group %s
vgnameid_list allocation failed.
Physical volume %s not allocatable.
Physical volume %s is missing.
No free extents on physical volume "%s".
Unable to allocate physical volume list.
Allocation of pe_ranges list failed.
PE range error: start extent %u to end extent %u.
Physical extent parsing error at %s.
Forking background process: %s
Failed to sync local devices before forking.
Background process failed to setsid: %s
skip_dev_dir: Couldn't split up device name %s.
"%s": Invalid path for Logical Volume.
"%s": Invalid environment var LVM_VG_NAME set for Volume Group.
Path required for Logical Volume "%s".
Physical Volume "%s" not found in Volume Group "%s".
No specified PVs have space available.
Physical extent size cannot be larger than %s.
Max Logical Volumes may not be negative.
Max Physical Volumes may not be negative.
VG with system ID %s might become inaccessible as local system ID is %s
WARNING: A VG without a system ID allows unsafe access from other hosts.
A lock type cannot be specified with --shared or --clustered.
lvmlockd is configured, use --shared with lvmlockd, and --clustered with clvmd.
The --clustered option requires clvmd (locking_type=3).
Failed to detect a running lock manager to select lock type.
Use --shared with lvmlockd, and --clustered with clvmd.
Using a shared lock type requires lvmlockd.
Using clvm requires locking_type 3.
Skipping activation of cache pool %s.
Skipping deactivation of used cache pool %s.
Refusing to activate merging "%s" while snapshot "%s" is still active.
Cannot fully deactivate merging origin "%s" while snapshot "%s" is still active.
Spawning background pvmove process for %s.
Spawning background lvconvert process for %s.
Please enter a physical volume path.
labelsector must be less than %lu.
Metadata and data alignment parameters only apply to text format.
Bootloader area parameters only apply to text format.
metadataignore only applies to metadatacopies > 0
Physical volume data alignment may not be negative.
Physical volume data alignment is too big.
Physical volume data alignment offset may not be negative
Physical volume data alignment offset is too big.
WARNING: Ignoring data alignment %s incompatible with restored pe_start value %s)
Metadata size may not be negative.
Bootloader area size may not be negative.
--ignoremonitoring or --sysinit option not allowed with --monitor option.
Setting pool chunk size to %s.
Negative pool metadata size is invalid.
Please specify either metadata logical volume or its size.
Negative stripesize is invalid.
Stripe size cannot be larger than %s.
Ignoring stripesize argument with single stripe.
Number of stripes (%d) must be between %d and %d.
Failed to add tag %s to physical volume %s.
No physical volume label read from %s.
Option --minor may not be repeated.
Option -j|--major may not be repeated.
Options --major and --minor are incompatible with -Mn.
Please specify minor number with --minor when using -My.
Please specify major number with --major when using -My.
WARNING: Ignoring supplied major number %d - kernel assigns major numbers dynamically. Using major number %d instead.
Please use a single volume group name ("%s" or "%s").
Logical volume name "%s" is invalid.
_init_processing_handle: failed to allocate memory for processing handle
_init_selection_handle: failed to allocate memory for selection handle
Using volume group(s) on command line.
This command does not yet support a tag to identify a Volume Group.
Ignoring virtual origin logical volume %s.
Adding %s/%s to the list of LVs to be processed.
Failed to allocate final LV list item.
Failed to find logical volume "%s/%s"
Processing lockd_sanlock_lv %s/%s.
Using logical volume(s) on command line.
Using physical volume(s) on command line.
Failed to find device for physical volume "%s".
Skipping PV %s in VG %s: not in device list.
Processing PV %s device %s in VG %s.
Failed to find physical volume "%s".
toollib.c
Allocation of list failed.
unknown 
Skipping volume group %s
fork failed: %s
redirect
dup2
(lvm2)
vg/lv string alloc failed.
Allocation of vg_name failed.
LVM_VG_NAME
Allocation of list failed
Skipping invalid tag %s.
clvm
lock_type %s is invalid
Setting lock_type to %s
Enabling
Disabling
%s pool zeroing.
Setting pool discards to %s.
Using default stripesize %s.
Invalid stripe size %s.
policy_settings
Failed to find device "%s".
dev_iter creation failed.
Selection failed for VG %s.
Selection failed for LV %s.
Selection failed for PV %s.
Skipping invalid tag: %s
strlist allocation failed.
Invalid volume group name %s.
No volume groups found.
Processing LV %s in VG %s.
device_id_list alloc failed.
Skipping PV %s in VG %s.
Processing PV %s in VG %s.
Processing device %s.
/dev/null
Physical extent size may not be negative.
vgcfgbackup.c
Failed to allocate filename.
Error processing filename template %s
VGs must be backed up into different files. Use %%s in filename for VG name.
No backup taken: specify filename with -f to backup an inconsistent VG
Volume group "%s" successfully backed up.
Volume group name "%s" is invalid
Please specify a *single* volume group to restore.
Unable to lock volume group %s
vgcfgrestore.c
#orphans
Unable to lock orphans
Restore failed.
Restored volume group %s
Volume group "%s" is already resizeable
Volume group "%s" is already not resizeable
Metadata format %s does not support this type of system ID.
Volume Group system ID is already "%s".
WARNING: Removing the system ID allows unsafe access from other hosts.
Remove system ID %s from volume group %s? [y/n]: 
System ID of volume group %s not changed.
Logical Volumes in VG %s must be deactivated before system ID can be changed.
WARNING: Requested system ID %s does not match local system ID %s.
WARNING: No local system ID is set.
WARNING: Volume group %s might become inaccessible from this machine.
Set foreign system ID %s on volume group %s? [y/n]: 
Volume group %s system ID not changed.
Changing system ID for VG %s from "%s" to "%s".
Changing configuration profile for VG %s: %s -> %s.
Number of metadata copies for VG %s is already unmanaged.
Number of metadata copies for VG %s is already %u.
lvmlockd requires using the vgchange --lock-type option.
WARNING: Clearing invalid system ID %s from volume group %s.
Volume group "%s" is already clustered
Setting missing system ID on Volume Group %s to %s.
Volume group "%s" is already not clustered
LVM cluster daemon (clvmd) is not running. Make volume group "%s" clustered anyway? [y/n]: 
LVM locking type is not clustered. Make volume group "%s" clustered anyway? [y/n]: 
Unable to convert %s to clustered mode: Mirror region size of %s is too small.
Forcibly change VG %s lock type to none? [y/n]: 
New lock type %s matches the current lock type %s.
Cannot change lock type directly from "%s" to "%s".
First change lock type to "none", then to "%s".
Changing to lock type %s requires lvmlockd.
Changing VG %s lock type not allowed with active LVs
New clvm lock type will not be usable with lvmlockd.
Failed to initialize lock args for lock type %s
Cannot change to unknown lock type %s
Ignoring invalid string in lock_start list
Ignoring empty string in config file
Volume group allocation policy is already %s
Volume group has active logical volumes
Failed to generate new random UUID for VG %s.
Physical extent size of VG %s is already %s.
Failed to change physical extent size for VG %s.
Can't deactivate volume group "%s" with %d open logical volume(s)
%d logical volume(s) in volume group "%s" already active
%d existing logical volume(s) in volume group "%s" %smonitored
%s/%s is exclusively active on a remote node
Failed to sync local devices for VG %s.
%s %d logical volumes in volume group %s
%d logical volume(s) in volume group "%s" now active
Volume group "%s" successfully changed
Can't reactive logical volume %s, please fix manually.
For clustered mirroring of %s deactivation and activation is needed.
%d logical volume(s) in volume group "%s" %smonitored
Background polling started for %d logical volume(s) in volume group "%s"
Not starting %s since it does not pass lock_start_list
Not starting %s since it does not pass auto_lock_start_list
Need one or more command options.
Only -ay* allowed with --monitor or --poll.
Only one of --poll and --sysinit permitted.
-A option not necessary with -a option
MaxPhysicalVolumes may not be negative
Physical extent size may not be negative
Change clustered property of all volumes groups? [y/n]: 
Using lock type requires lvmlockd.
Using lock start and lock stop requires lvmlockd.
Starting locking.  Waiting until locks are ready...
Starting locking.  VG can only be read until locks are ready.
vgchange.c
Unable to set system ID.
(no profile)
No volume groups changed.
VG lock type not changed.
Activated
Deactivated
Volume group "%s" is exported
Refreshing volume group "%s"
autonowait
vgck.c
The volume group is missing %d physical volumes.
Clustered 
Non-clustered 
 with system ID 
vgcreate.c
Can't get lock for %s.
Can't get lock for orphan PVs
Failed to get tag
Failed to start locking
Please provide volume group name and physical volumes
A volume group called %s already exists.
WARNING: Setting maxlogicalvolumes to %d (0 means unlimited)
WARNING: Setting maxphysicalvolumes to %d (0 means unlimited)
%s%colume group "%s" successfully created%s%s
Starting locking.  VG is read-only until locks are ready.
vgconvert.c
Please enter volume group(s)
Volume group "%s" already uses format %s
Metadata size may not be negative
Bootloader area size may not be negative
Archive of "%s" metadata failed.
Logical volume %s lvid format is incompatible with requested metadata format.
Unable to convert VG %s while it has a system ID set (%s).
Logical volume %s must be deactivated before conversion.
Deleting existing metadata for VG %s
Failed to setup physical volume "%s"
Use pvcreate and vgcfgrestore to repair from archived metadata.
Set up physical volume for "%s" with %lu available sectors
Failed to wipe existing label on %s
Writing physical volume data to disk "%s"
Failed to write physical volume "%s"
Physical volume "%s" successfully created
Removal of existing metadata for %s failed.
Test mode: Skipping metadata writing for VG %s in format %s
Writing metadata for VG %s using format %s
Conversion failed for volume group %s.
Volume group %s successfully converted
lvmetad must be disabled to change metadata types.
labelsector must be less than %lu
Invalid option --metadatacopies, use --pvmetadatacopies instead.
Metadata parameters only apply to text format
Metadatacopies may only be 0, 1 or 2
Bootloader area parameters only apply to text format
--- Physical volumes ---
vgdisplay.c
Option -A is not allowed with volume group names
Volume group "%s" has active logical volumes
LV %s/%s must be inactive on all hosts before vgexport.
Volume group "%s" successfully exported
Please supply volume groups or use --select for selection or use -a for all.
No arguments permitted when using -a for all.
vgexport.c
WARNING: Changing preferred number of copies of VG %s metadata from %u to %u
Volume group "%s" will be extended by %d new physical volumes
Volume group "%s" successfully extended
WARNING: PV %s not found in VG %s
WARNING: PV %s was not missing in VG %s
WARNING: The PV %s is still missing.
Please enter volume group name and physical volume(s)
Volume group %s not changed
vgextend.c
No PV has been restored.
Volume group "%s" is not exported
Volume group "%s" is partially missing
Volume group "%s" successfully imported
Please supply volume groups or -S for selection or use -a for all.
WARNING: Volume groups with missing PVs will be imported with --force.
vgimport.c
Checking for volume group "%s"
vgmerge not allowed for lock_type %s
Please enter 2 or more volume groups to merge
Duplicate volume group name "%s"
Failed to generate new random LVID for %s
Writing out updated volume group
Volume group "%s" successfully merged into "%s"
vgmerge.c
Changed LVID for %s to %s
vgmknodes.c
--polloperation parameter is mandatory
Argument to --interval cannot be negative
lvpoll.c
Provide LV name
merge_thin
Unknown polling operation %s
WARNING: Partial LV %s needs to be repaired or removed. 
There are still partial LVs in VG %s.
To remove them unconditionally use: vgreduce --removemissing --force.
Proceeding to remove empty missing PVs.
Volume Groups must always contain at least one PV
Removing PV with UUID %s from VG %s
LVs still present on PV with UUID %s: Can't remove from VG %s
Please give volume group name and physical volume paths
--mirrorsonly requires --removemissing
Please enter physical volume paths or option -a
Option -a and physical volume paths mutually exclusive
Please only specify the volume group
Volume group "%s" is already consistent
Trying to open VG %s for recovery...
Non-mirror-image LV %s found: can't remove.
Failed to write out a consistent VG for %s
Wrote out consistent volume group %s
vgreduce.c
Please give volume group name
Removing partial LV %s.
vgremove.c
Volume group "%s" not removed
WARNING: %d physical volumes are currently missing from the system.
Do you really want to remove volume group "%s" containing %u logical volumes? [y/n]: 
Please enter one or more volume group paths or use --select for selection.
vgrename.c
Can't get lock for %s
Renaming "%s" to "%s"
Test mode: Skipping rename.
Renaming "%s" to "%s" failed
Checking for new volume group "%s"
New volume group "%s" already exists
No complete volume groups found
Found more than one VG called %s. Please supply VG uuid.
Volume group "%s" successfully renamed to "%s"
Old and new volume group names need specifying
exported 
vgscan.c
Found %svolume group "%s" using metadata type %s
Too many parameters on command line
Cannot proceed since lvmetad is not active.
Reading all physical volumes.  This may take a while...
vgsplit not allowed for lock_type %s
Logical volume %s (part of %s) must be inactive.
Logical volume %s must be inactive.
Existing VG, new VG and either physical volumes or logical volume required.
A logical volume name cannot be given with physical volumes.
Unable to set new VG metadata type based on source VG format - use -M option.
Can't split Logical Volume %s between two Volume Groups
Can't split RAID %s between two Volume Groups
Can't split mirror %s between two Volume Groups
Can't split snapshot %s between two Volume Groups
Can't split external origin %s and pool %s between two Volume Groups.
Can't split pool data and metadata %s between two Volume Groups.
Unable to split VG while it contains cache LVs
Cannot split: Nowhere to store metadata for new Volume Group
Writing out updated volume groups
Volume group "%s" became inconsistent: please fix manually
%s volume group "%s" successfully split from "%s"
Volume group "%s" exists, but new VG option specified
vgsplit.c
Existing
Physical Volume %s not found
HOME
%s/.lvm_history
lvm.c
lvm> 
Too many arguments, sorry.
Exiting.
Couldn't write history to %s.
$HOME/.lvm_history: path too long
Couldn't read history from %s.
No such command '%s'.  Try 'help'.
activate/activate.c
No host tag matches %s/%s
tpool
real
%s/lvm/global
Getting driver version
Getting target version for %s
Found %s target v%u.%u.%u.
/usr/sbin/modprobe
dm-%s
%s/%s is %sactive%s%s
Logical volume %s/%s in use.
idle
Counted %d open LVs in VG %s
Unmonitored
Monitored
%s %s for events
 [Test mode: skipping this]
Not m
Failed to %smonitor %s
%s/%s already monitored.
%s/%s already not monitored.
%sonitoring %s/%s%s
%sonitoring %s/%s failed.
 (reverting)
 pool only
 thin only
 if active
Skipping: Resuming %s%s%s.
Resuming LV %s/%s%s%s%s.
already resumed
 temporary
 noscan
Skipping: Activating '%s'.
Activating %s/%s%s%s%s%s.
Volume is already active.
 origin without snapshots
Skipping: Suspending %s%s.
already suspended
suspending pvmove LV
failed precommitted suspend
failed suspend
failed suspend (pvmove)
suspending
Skipping: Deactivating '%s'.
Deactivating %s/%s.
deactivating
deactivated
%s configuration setting defined: Checking the list to match %s/%s
No item supplied in %s configuration setting matches %s/%s
Ignoring invalid string in config file %s.
Ignoring empty string in config file %s.
Ignoring empty tag in config file %s
activation/volume_list configuration setting not defined: Checking only host tags for %s/%s
LVM1 proc global snprintf failed
module string allocation failed
snap_seg module string allocation failed
activation/auto_activation_volume_list configuration setting not defined: All logical volumes will be auto-activated.
Activation enabled. Device-mapper kernel driver will be used.
WARNING: Activation disabled. No device-mapper interaction will be attempted.
Activation disabled. No device-mapper interaction will be attempted.
Failed to get %s target version
module_present module name too long: %s
Unable to determine exclusivity of %s
Logical volume %s/%s is used by another device.
Logical volume %s/%s contains a filesystem in use.
Retrying open_count check for %s/%s.
Checking transient status for LV %s/%s
Checking snapshot percent for LV %s/%s
Checking mirror percent for LV %s/%s
Checking raid device health for LV %s/%s
Checking raid mismatch count for LV %s/%s
Checking raid sync_action for LV %s/%s
Thin pool data or metadata volume must be specified. (E.g. "%s/%s_tdata")
%s/%s must be a RAID logical volume to perform this action.
Unable to send message to an inactive logical volume.
Failed to retrieve status of %s/%s
Kernel driver does not support this action: %s
"%s" is not a supported sync operation.
%s/%s state is currently "%s".  Unable to switch to "%s".
Checking cache status for LV %s.
Checking thin %sdata percent for LV %s/%s
Checking thin percent for LV %s/%s
Checking device id for LV %s/%s
Counted %d active LVs in VG %s
Failed to allocate dmeventd library path.
Skipping unmonitor of opened %s (open:%d)
Skipping monitor of snapshot larger then origin %s.
%s/%s: %s segment monitoring function failed.
%s/%s %smonitoring still pending: waiting...
Not activating %s/%s since it does not pass activation filter.
Refusing activation of partial LV %s.  Use '--activationmode partial' to override.
Refusing activation of partial LV %s.  Try '--activationmode degraded'.
Refusing activation of LV %s containing an unrecognised segment.
Shared cluster mirrors are not available.
Internal error: LV %s missing from preload metadata
Internal error: LV %s (%s) missing from preload metadata
failed precommitted suspend (pvmove)
LV %s/%s has open %d snapshot(s), not deactivating.
Deactivated volume is still %s present.
Releasing activation in critical section.
Metadata cache: VG %s wiped.
cache/lvmcache.c
#orphans_lvm2
#orphans_lvm1
#orphans_pool
Cache locking failure for %s
 with %u mdas
lvmcache: initialised VG %s
dev_iter creation failed
pre-committed 
VG %s reused %d times.
vgids list allocation failed
strlist allocation failed
pvids list allocation failed
vgname allocation failed
no longer
, precommitted
Wiping internal VG cache
_lvmcache_update: vgid hash insertion failed: %s
lvmcache: %s: setting %s VGID to %s
Internal error: VG lock %s hits NULL.
Internal error: VG lock %s must be requested before %s, not after.
Internal error: Internal cache cannot lookup vgid.
Metadata cache has no info for vgid "%s"
Internal error: Internal cache is no yet initialized.
Metadata cache has no info for vgname: "%s"
Metadata cache has not found vgname "%s" with vgid "%.32s".
Precommitted metadata cache: VG %s upgraded to committed.
Internal error: metadata commit (or revert) missing before dropping metadata from cache.
Internal cache initialisation failed
Internal error: Nested locking attempted on VG %s.
device_list element allocation failed
Internal error: Attempt to unlock unlocked VG %s.
_vgname_hash re-insertion for %s failed
lvmcache_update_vgname: list alloc failed
cache vgname alloc failed for %s
Internal error: Orphan vginfo %s lost from cache.
lvmcache: %s: now in VG %s%s%s%s%s
WARNING: Duplicate VG name %s: Existing %s takes precedence over exported %s
WARNING: Duplicate VG name %s: %s takes precedence over exported %s
WARNING: Duplicate VG name %s: Existing %s (created here) takes precedence over %s
WARNING: Duplicate VG name %s: %s (with creation_host) takes precedence over %s
WARNING: Duplicate VG name %s: %s (created here) takes precedence over %s
cache_update: vg hash insertion failed: %s
Using cached %smetadata for VG %s with %u holder(s).
VG %s decrementing %d holder(s) at %p.
vgnameid_list member allocation failed.
vgnames list allocation failed
Couldn't find device with uuid %s.
%s: Couldn't find device.  Check your filters?
Internal error: NULL vgname handed to cache
lvmcache: %s: VG %s %s exported
cache creation host alloc failed for %s
lvmcache: %s: VG %s: Set creation host to %s.
lvmcache: %s: VG %s: Stored metadata checksum %u with size %zu.
Metadata cache: VG %s (%s) stored (%zu bytes%s).
Internal error: Volume Group %s was not unlocked
Internal error: _vginfos list should be empty
Must be exactly one data area (found %d) on PV %s
Must be at most one bootloader area (found %d) on PV %s
PV %s is a different format (seqno %s)
lvmcache_info allocation failed
WARNING: duplicate PV %s is being used from both devices %s and %s
Found duplicate PV %s: using existing dev %s
Found duplicate PV %s: using %s not %s
Using duplicate PV %s from subsystem %s, ignoring %s
Using duplicate PV %s from subsystem %s, replacing %s
Using duplicate PV %s without holders, replacing %s
Using duplicate PV %s without holders, ignoring %s
Using duplicate PV %s which is last seen, replacing %s
Replacing dev %s pvid %s with dev %s pvid %s
Found same device %s with same pvid %s
_lvmcache_update: pvid insertion failed: %s
commands/toolcontext.c
dup2(%d, %d) returned %d
fdopen
Logging initialised at %s
_init_hostname
uname
profile_params alloc failed
init_format
segment type
init_multiple_segtypes
init_segtype
Setting host tag: %s
Failed to create config tree
DM_DISABLE_UDEV
/dev/
archive_init failed.
backup_init failed.
host_list
host_filter
host_filter not supported yet
%s/lvm%s%s.conf
localhost
WARNING: %s: fopen failed: %s
cCxXyY
deHImMSuUVwWy
Set umask from %04o to %04o
LVM-
%s/mounts
_get_sysfs_dir fopen
sysfs
/dev/ioerror
         stat failed: %s
lvmlocal
machineid
%s/machine-id
LVM_ configuration invalid.
/run/lvm/lvmetad.socket
/run/lvm/lvmpolld.socket
LVM_LVMETAD_SOCKET
LVM_LVMPOLLD_SOCKET
Reloading config files
stdout
setlocale failed
setvbuf
LVM_SYSTEM_DIR
Internal error: Unable to find configuration for log/debug_classes.
log/debug_classes contains a value which is not a string.  Ignoring.
Unrecognised value for log/debug_classes: %s
Setting log debug classes to %d
_init_hostname: dm_pool_strdup failed
_init_hostname: dm_pool_strdup kernel_vsn failed
_init_profiles: dm_strncpy failed
Invalid string in config file: global/format_libraries
Shared library %s does not contain format functions
_init_formats: Default format (%s) not found
Invalid string in config file: global/segment_libraries
WARNING: Shared lib %s has conflicting init fns.  Using init_multiple_segtypes().
init_multiple_segtypes() failed: Unloading shared library %s
Internal error: _destroy_config: cmd config tree not destroyed fully
_set_tag: str_list_add %s failed
DM_DISABLE_UDEV environment variable set. Overriding configuration to use udev_rules=0, udev_sync=0, verify_udev_operations=1.
Udev is running and DM_DISABLE_UDEV environment variable is set. Bypassing udev, LVM will %s.
obtain device list by scanning device directory
Internal error: Unable to find configuration for devices/scan.
Invalid string in config file: devices/scan
Non standard udev dir %s, resetting devices/obtain_device_list_from_udev.
Failed to add %s to internal device cache
Invalid string in config file: devices/loopfiles
Failed to add loopfile %s to internal device cache
WARNING: Metadata changes will NOT be backed up
Invalid tag in config file: %s
Invalid hostname string for tag %s
LVM_SYSTEM_DIR or tag was too long
config_tree_list allocation failed
WARNING: Empty system ID supplied.
WARNING: Failed to allocate system ID.
WARNING: Invalid system ID format: %s
WARNING: system ID may not begin with the string "localhost".
WARNING: Ignoring extra line(s) in system ID file %s.
aAbBcCdDeFGghHIjklmMpPrRsStTuUVwWxXyYzZ%
Configured time format is empty string.
Configured time format contains non-printable characters.
Invalid time format "%s" supplied.
Device directory given in config file too long
Invalid external device info source specification.
WARNING: proc dir %s not found - some checks will be bypassed
No proc filesystem found: skipping sysfs detection
Failed to create /proc/mounts string for sysfs detection
Failed to find sysfs mount point
Invalid readahead specification
manage logical volume symlinks in device directory
WARNING: activation/missing_stripe_filler = "%s" is invalid,
Falling back to "error" missing_stripe_filler.
WARNING: activation/missing_stripe_filler = "%s" is not a block device.
Ignoring invalid activation/mlock_filter entry in config file
Ignoring too small pv_min_size %ldKB, using default %dKB.
WARNING: local/system_id is set, so should global/system_id_source be "lvmlocal" not "%s"?
WARNING: Unrecognised system_id_source "%s".
WARNING: No system ID found from system_id_source %s.
Internal error: connections must be initialized before filters
Failed to create global regex device filter
Failed to create lvm type filter
Failed to create usabled device filter
Failed to create partitioned device filter
Failed to create usable device filter.
Failed to create persistent device filter.
Failed to load existing device cache from %s
Duplicate segment type %s: unloading shared library %s
Shared library %s does not contain segment type functions
WARNING: configuration setting use_lvmetad overridden to 0 due to locking_type 3. Clustered environment not supported by lvmetad yet.
Failed to allocate command context
Failed to allocate line buffer.
LVM_SYSTEM_DIR environment variable is too long.
Failed to create LVM2 system dir for metadata backups, config files and internal cache.
Set environment variable LVM_SYSTEM_DIR to alternative location or empty string.
Library memory pool creation failed
Command memory pool creation failed
@DEFAULT_SYS_DIR@/@DEFAULT_CACHE_SUBDIR@
@DEFAULT_SYS_DIR@/@DEFAULT_BACKUP_SUBDIR@
@DEFAULT_SYS_DIR@/@DEFAULT_ARCHIVE_SUBDIR@
@DEFAULT_SYS_DIR@/@DEFAULT_PROFILE_SUBDIR@
Couldn't create default backup path '%s/%s'.
Couldn't create default archive path '%s/%s'.
Couldn't create default profile path '%s/%s'.
Internal error: Profile %s already added as %s type, but requested type is %s.
Failed to create default empty array for %s.
_get_def_array_values: dm_strdup failed
Failed to create default config array value for %s.
Failed to duplicate token for default array value of %s.
Internal error: Default array value malformed for "%s", value: "%s", token: "%s".
Internal error: inconsistent state reached in _check_value_differs_from_default
Failed to create default config setting node.
Failed to create default config setting node value.
Internal error: _add_def_node: unknown type
_log_array_value_used: failed to write node value
%s not found in config: defaulting to %s
Internal error: couldn't determine missing config nodes - unknown status of last config check.
Failed to create default config section node.
_config_array_line: dm_pool_strdup failed
Internal error: _cfg_def_make_path: supplied buffer too small for %s/%s
_get_config_node_version: couldn't create version string
%s# This configuration %s is advanced.
%s# This configuration %s is not officially supported.
%s# This configuration %s has variable name.
%s# This configuration %s does not have a default value defined.
%s# This configuration %s has an automatic default value.
%s# Value defined in existing configuration has been used for this setting.
%s# Available since version %s.
%s# Deprecated since version %s.
%s# This configuration %s is deprecated.
Persistent cache directory name too long.
WARNING: Configuration setting %s is disabled. Using default value.
WARNING: Configuration setting "%s" has invalid type. Found%s but expected%s.
Failed to construct path for configuration node %s.
Configuration setting "%s" unknown.
Configuration section "%s" unknown.
Configuration setting "%s" invalid. Empty value not allowed.
Configuration setting "%s" invalid. Found string value "%s", expected boolean value: 0/1, "y/n", "yes/no", "on/off", "true/false".
Configuration setting "%s" invalid. It cannot be set to an empty value.
Configuration %s "%s" is not customizable by a profile.
Configuration %s "%s" is customizable by metadata profile only, not command profile.
Configuration %s "%s" is customizable by command profile only, not metadata profile.
Failed to allocate config source.
Failed to allocate config file.
Internal error: config_file_check: expected file, special file or profile config source, found %s config source.
Internal error: config_file_changed: expected file config source, found %s config source.
Config file %s has disappeared!
Failed to reload configuration files
Configuration file %s is not a regular file
Detected config file change to %s
Failed to allocate configuration check handle.
Internal error: override_config_tree_from_string: config cascade already contains a string config.
Failed to set overridden configuration entries.
Failed to allocate circular buffer.
Internal error: config_file_read_fd: expected file, special file or profile config source, found %s config source.
Internal error: %s cfg tree element not declared as boolean.
Configuration node %s not found
Failed to create default config tree.
Failed to create temporary config tree while creating full tree.
Failed to clone current config tree.
Failed to merge default and current config tree.
Internal error: add_profile: incorrect configuration source, expected %s or %s but %s requested
%s: bad profile name, it contains '/'.
Internal error: add_profile: loaded profile has incorrect type, expected %s but %s found
Internal error: trying to load profile %s in critical section.
LVM_SYSTEM_DIR or profile name too long
_check_profile: profile check handle allocation failed
Internal error: _override_config_tree_from_command_profile: config cascade already contains a command profile config.
Internal error: _override_config_tree_from_metadata_profile: config cascade already contains a metadata profile config.
Internal error: override_config_tree_from_profile: incorrect profile source type
Internal error: %s cfg tree element not declared as string.
Internal error: Cannot find configuration.
Thin pool chunk size calculation policy "%s" is unrecognised.
Internal error: %s cfg tree element not declared to allow empty values.
Persistent cache filename too long.
Internal error: %s cfg tree element not declared as integer.
Internal error: %s cfg tree element not declared as float.
Failed to create configuration definition hash.
Failed to insert configuration to hash.
Configuration setting "%s" invalid. It's not part of any section.
Internal error: %s cfg tree element not declared as array.
Failed to create default array node for %s.
How LVM configuration settings are handled.
How LVM selects space and applies properties to LVs.
How LVM log information is reported.
How LVM metadata is backed up and archived.
In LVM, a 'backup' is a copy of the metadata for the current system,
and an 'archive' contains old metadata configurations. They are
stored in a human readable text format.
Settings for running LVM in shell (readline) mode.
Miscellaneous global LVM settings.
LVM report command output formatting.
Settings for the LVM event daemon.
LVM settings that are specific to the local host.
If enabled, any LVM configuration mismatch is reported.
This implies checking that the configuration key is understood by
LVM and that the value of the key is the proper type. If disabled,
any configuration mismatch is ignored and the default value is used
without any warning (a message about the configuration key not being
found is issued in verbose mode only).
Abort the LVM process if a configuration mismatch is found.
Directory where LVM looks for configuration profiles.
Directory in which to create volume group device nodes.
Commands also accept this as a prefix on volume group names.
Directories containing device nodes to use with LVM.
Obtain the list of available devices from udev.
This avoids opening or using any inapplicable non-block devices or
subdirectories found in the udev directory. Any device node or
symlink not managed by udev in the udev directory is ignored. This
setting applies only to the udev-managed device directory; other
directories will be scanned fully. LVM needs to be compiled with
udev support for this setting to apply.
Select an external device information source.
Some information may already be available in the system and LVM can
use this information to determine the exact type or use of devices it
processes. Using an existing external device information source can
speed up device processing as LVM does not need to run its own native
routines to acquire this information. For example, this information
is used to drive LVM filtering like MD component detection, multipath
component detection, partition detection and others.
Accepted values:
  none
    No external device information source is used.
  udev
    Reuse existing udev database records. Applicable only if LVM is
    compiled with udev support.
#S^/dev/mpath/#S^/dev/mapper/mpath#S^/dev/[hs]d
Select which path name to display for a block device.
If multiple path names exist for a block device, and LVM needs to
display a name for the device, the path names are matched against
each item in this list of regular expressions. The first match is
used. Try to avoid using undescriptive /dev/dm-N names, if present.
If no preferred name matches, or if preferred_names are not defined,
the following built-in preferences are applied in order until one
produces a preferred name:
Prefer names with path prefixes in the order of:
/dev/mapper, /dev/disk, /dev/dm-*, /dev/block.
Prefer the name with the least number of slashes.
Prefer a name that is a symlink.
Prefer the path with least value in lexicographical order.
Example
preferred_names = [ "^/dev/mpath/", "^/dev/mapper/mpath", "^/dev/[hs]d" ]
Limit the block devices that are used by LVM commands.
This is a list of regular expressions used to accept or reject block
device path names. Each regex is delimited by a vertical bar '|'
(or any character) and is preceded by 'a' to accept the path, or
by 'r' to reject the path. The first regex in the list to match the
path is used, producing the 'a' or 'r' result for the device.
When multiple path names exist for a block device, if any path name
matches an 'a' pattern before an 'r' pattern, then the device is
accepted. If all the path names match an 'r' pattern first, then the
device is rejected. Unmatching path names do not affect the accept
or reject decision. If no path names for a device match a pattern,
then the device is accepted. Be careful mixing 'a' and 'r' patterns,
as the combination might produce unexpected results (test changes.)
Run vgscan after changing the filter to regenerate the cache.
See the use_lvmetad comment for a special case regarding filters.
Example
Accept every block device:
filter = [ "a|.*/|" ]
Reject the cdrom drive:
filter = [ "r|/dev/cdrom|" ]
Work with just loopback devices, e.g. for testing:
filter = [ "a|loop|", "r|.*|" ]
Accept all loop devices and ide drives except hdc:
filter = [ "a|loop|", "r|/dev/hdc|", "a|/dev/ide|", "r|.*|" ]
Use anchors to be very specific:
filter = [ "a|^/dev/hda8$|", "r|.*/|" ]
Limit the block devices that are used by LVM system components.
Because devices/filter may be overridden from the command line, it is
not suitable for system-wide device filtering, e.g. udev and lvmetad.
Use global_filter to hide devices from these LVM system components.
The syntax is the same as devices/filter. Devices rejected by
global_filter are not opened by LVM.
This has been replaced by the devices/cache_dir setting.
Directory in which to store the device cache file.
The results of filtering are cached on disk to avoid rescanning dud
devices (which can take a very long time). By default this cache is
stored in a file named .cache. It is safe to delete this file; the
tools regenerate it. If obtain_device_list_from_udev is enabled, the
list of devices is obtained from udev and any existing .cache file
is removed.
A prefix used before the .cache file name. See devices/cache_dir.
Enable/disable writing the cache file. See devices/cache_dir.
List of additional acceptable block device types.
These are of device type names from /proc/devices, followed by the
maximum number of partitions.
Example
types = [ "fd", 16 ]
Restrict device scanning to block devices appearing in sysfs.
This is a quick way of filtering out block devices that are not
present on the system. sysfs must be part of the kernel and mounted.)
Ignore devices that are components of DM multipath devices.
Ignore devices that are components of software RAID (md) devices.
Ignore devices that are components of firmware RAID devices.
LVM must use an external_device_info_source other than none for this
detection to execute.
Align PV data blocks with md device's stripe-width.
This applies if a PV is placed directly on an md device.
Default alignment of the start of a PV data area in MB.
If set to 0, a value of 64KiB will be used.
Set to 1 for 1MiB, 2 for 2MiB, etc.
Detect PV data alignment based on sysfs device information.
The start of a PV data area will be a multiple of minimum_io_size or
optimal_io_size exposed in sysfs. minimum_io_size is the smallest
request the device can perform without incurring a read-modify-write
penalty, e.g. MD chunk size. optimal_io_size is the device's
preferred unit of receiving I/O, e.g. MD stripe width.
minimum_io_size is used if optimal_io_size is undefined (0).
If md_chunk_alignment is enabled, that detects the optimal_io_size.
This setting takes precedence over md_chunk_alignment.
Alignment of the start of a PV data area in KiB.
If a PV is placed directly on an md device and md_chunk_alignment or
data_alignment_detection are enabled, then this setting is ignored.
Otherwise, md_chunk_alignment and data_alignment_detection are
disabled if this is set. Set to 0 to use the default alignment or the
page size, if larger.
data_alignment_offset_detection
Detect PV data alignment offset based on sysfs device information.
The start of a PV aligned data area will be shifted by the
alignment_offset exposed in sysfs. This offset is often 0, but may
be non-zero. Certain 4KiB sector drives that compensate for windows
partitioning will have an alignment_offset of 3584 bytes (sector 7
is the lowest aligned logical block, the 4KiB sectors start at
LBA -1, and consequently sector 63 is aligned on a 4KiB boundary).
pvcreate --dataalignmentoffset will skip this detection.
Ignore DM devices that have I/O suspended while scanning devices.
Otherwise, LVM waits for a suspended device to become accessible.
This should only be needed in recovery situations.
Do not scan 'mirror' LVs to avoid possible deadlocks.
This avoids possible deadlocks when using the 'mirror' segment type.
This setting determines whether LVs using the 'mirror' segment type
are scanned for LVM labels. This affects the ability of mirrors to
be used as physical volumes. If this setting is enabled, it is
impossible to create VGs on top of mirror LVs, i.e. to stack VGs on
mirror LVs. If this setting is disabled, allowing mirror LVs to be
scanned, it may cause LVM processes and I/O to the mirror to become
blocked. This is due to the way that the mirror segment type handles
failures. In order for the hang to occur, an LVM command must be run
just after a failure and before the automatic LVM repair process
takes place, or there must be failures in multiple mirrors in the
same VG at the same time with write failures occurring moments before
a scan of the mirror's labels. The 'mirror' scanning problems do not
apply to LVM RAID types like 'raid1' which handle failures in a
different way, making them a better choice for VG stacking.
Number of I/O errors after which a device is skipped.
During each LVM operation, errors received from each device are
counted. If the counter of a device exceeds the limit set here,
no further I/O is sent to that device for the remainder of the
operation. Setting this to 0 disables the counters altogether.
Allow use of pvcreate --uuid without requiring --restorefile.
Minimum size in KiB of block devices which can be used as PVs.
In a clustered environment all nodes must use the same value.
Any value smaller than 512KiB is ignored. The previous built-in
value was 512.
Issue discards to PVs that are no longer used by an LV.
Discards are sent to an LV's underlying physical volumes when the LV
is no longer using the physical volumes' space, e.g. lvremove,
lvreduce. Discards inform the storage that a region is no longer
used. Storage that supports discards advertise the protocol-specific
way discards should be issued by the kernel (TRIM, UNMAP, or
WRITE SAME with UNMAP bit set). Not all storage will support or
benefit from discards, but SSDs and thinly provisioned LUNs
generally do. If enabled, discards will only be issued if both the
storage and kernel provide support.
Advise LVM which PVs to use when searching for new space.
When searching for free space to extend an LV, the 'cling' allocation
policy will choose space on the same PVs as the last segment of the
existing LV. If there is insufficient space and a list of tags is
defined here, it will check whether any of them are attached to the
PVs concerned and then seek to match those PV tags between existing
extents and new extents.
Example
Use the special tag "@*" as a wildcard to match any PV tag:
cling_tag_list = [ "@*" ]
LVs are mirrored between two sites within a single VG, and
PVs are tagged with either @site1 or @site2 to indicate where
they are situated:
cling_tag_list = [ "@site1", "@site2" ]
Use a previous allocation algorithm.
Changes made in version 2.02.85 extended the reach of the 'cling'
policies to detect more situations where data can be grouped onto
the same disks. This setting can be used to disable the changes
and revert to the previous algorithm.
Use blkid to detect existing signatures on new PVs and LVs.
The blkid library can detect more signatures than the native LVM
detection code, but may take longer. LVM needs to be compiled with
blkid wiping support for this setting to apply. LVM native detection
code is currently able to recognize: MD device signatures,
swap signature, and LUKS signatures. To see the list of signatures
recognized by blkid, check the output of the 'blkid -k' command.
wipe_signatures_when_zeroing_new_lvs
Look for and erase any signatures while zeroing a new LV.
The --wipesignatures option overrides this setting.
Zeroing is controlled by the -Z/--zero option, and if not specified,
zeroing is used by default if possible. Zeroing simply overwrites the
first 4KiB of a new LV with zeroes and does no signature detection or
wiping. Signature wiping goes beyond zeroing and detects exact types
and positions of signatures within the whole LV. It provides a
cleaner LV after creation as all known signatures are wiped. The LV
is not claimed incorrectly by other tools because of old signatures
from previous use. The number of signatures that LVM can detect
depends on the detection code that is selected (see
use_blkid_wiping.) Wiping each detected signature must be confirmed.
When this setting is disabled, signatures on new LVs are not detected
or erased unless the --wipesignatures option is used directly.
mirror_logs_require_separate_pvs
Mirror logs and images will always use different PVs.
The default setting changed in version 2.02.85.
cache_pool_metadata_require_separate_pvs
Cache pool metadata and data will always use different PVs.
This has been replaced by the allocation/cache_mode setting.
The default cache mode used for new cache.
Accepted values:
  writethrough
    Data blocks are immediately written from the cache to disk.
  writeback
    Data blocks are written from the cache back to disk after some
    delay to improve performance.
This setting replaces allocation/cache_pool_cachemode.
The default cache policy used for new cache volume.
Since kernel 4.2 the default policy is smq (Stochastic multique),
otherwise the older mq (Multiqueue) policy is selected.
Individual settings for policies.
See the help for individual policies for more info.
Replace this subsection name with a policy name.
Multiple subsections for different policies can be created.
The minimal chunk size in KiB for cache pool volumes.
Using a chunk_size that is too large can result in wasteful use of
the cache, where small reads and writes can cause large sections of
an LV to be mapped into the cache. However, choosing a chunk_size
that is too small can result in more overhead trying to manage the
numerous chunks that become mapped into the cache. The former is
more of a problem than the latter in most cases, so the default is
on the smaller end of the spectrum. Supported values range from
32KiB to 1GiB in multiples of 32.
thin_pool_metadata_require_separate_pvs
Thin pool metdata and data will always use different PVs.
Thin pool data chunks are zeroed before they are first used.
Zeroing with a larger thin pool chunk size reduces performance.
The discards behaviour of thin pool volumes.
Accepted values:
  ignore
  nopassdown
  passdown
The chunk size calculation policy for thin pool volumes.
Accepted values:
  generic
    If thin_pool_chunk_size is defined, use it. Otherwise, calculate
    the chunk size based on estimation and device hints exposed in
    sysfs - the minimum_io_size. The chunk size is always at least
    64KiB.
  performance
    If thin_pool_chunk_size is defined, use it. Otherwise, calculate
    the chunk size for performance based on device hints exposed in
    sysfs - the optimal_io_size. The chunk size is always at least
    512KiB.
The minimal chunk size in KiB for thin pool volumes.
Larger chunk sizes may improve performance for plain thin volumes,
however using them for snapshot volumes is less efficient, as it
consumes more space and takes extra time for copying. When unset,
lvm tries to estimate chunk size starting from 64KiB. Supported
values are in the range 64KiB to 1GiB.
Default physical extent size in KiB to use for new VGs.
Controls the messages sent to stdout or stderr.
Suppress all non-essential messages from stdout.
This has the same effect as -qq. When enabled, the following commands
still produce output: dumpconfig, lvdisplay, lvmdiskscan, lvs, pvck,
pvdisplay, pvs, version, vgcfgrestore -l, vgdisplay, vgs.
Non-essential messages are shifted from log level 4 to log level 5
for syslog and lvm2_log_fn purposes.
Any 'yes' or 'no' questions not overridden by other arguments are
suppressed and default to 'no'.
Send log messages through syslog.
Write error and debug log messages to a file specified here.
Overwrite the log file each time the program is run.
The level of log messages that are sent to the log file or syslog.
There are 6 syslog-like log levels currently in use: 2 to 7 inclusive.
7 is the most verbose (LOG_DEBUG).
Indent messages according to their severity.
Display the command name on each line of output.
A prefix to use before the log message text.
(After the command name, if selected).
Two spaces allows you to see/grep the severity of each message.
To make the messages look similar to the original LVM tools use:
indent = 0, command_names = 1, prefix = " -- "
Log messages during activation.
Don't use this in low memory situations (can deadlock).
#Smemory#Sdevices#Sactivation#Sallocation#Slvmetad#Smetadata#Scache#Slocking#Slvmpolld
Select log messages by class.
Some debugging messages are assigned to a class and only appear in
debug output if the class is listed here. Classes currently
available: memory, devices, activation, allocation, lvmetad,
metadata, cache, locking, lvmpolld. Use "all" to see everything.
Maintain a backup of the current metadata configuration.
Think very hard before turning this off!
Location of the metadata backup files.
Remember to back up this directory regularly!
Maintain an archive of old metadata configurations.
Think very hard before turning this off.
Location of the metdata archive files.
Remember to back up this directory regularly!
Minimum number of archives to keep.
Minimum number of days to keep archive files.
Number of lines of history to store in ~/.lvm_history.
The file creation mask for any files and directories created.
Interpreted as octal if the first digit is zero.
No on-disk metadata changes will be made in test mode.
Equivalent to having the -t option on every command.
Default value for --units argument.
Distinguish between powers of 1024 and 1000 bytes.
The LVM commands distinguish between powers of 1024 bytes,
e.g. KiB, MiB, GiB, and powers of 1000 bytes, e.g. KB, MB, GB.
If scripts depend on the old behaviour, disable this setting
temporarily until they are updated.
Display unit suffix for sizes.
This setting has no effect if the units are in human-readable form
(global/units = "h") in which case the suffix is always displayed.
Enable/disable communication with the kernel device-mapper.
Disable to use the tools to manipulate LVM metadata without
activating any logical volumes. If the device-mapper driver
is not present in the kernel, disabling this should suppress
the error messages.
Try running LVM1 tools if LVM cannot communicate with DM.
This option only applies to 2.4 kernels and is provided to help
switch between device-mapper kernels and LVM1 kernels. The LVM1
tools need to be installed with .lvm1 suffices, e.g. vgscan.lvm1.
They will stop working once the lvm2 on-disk metadata format is used.
The default metadata format that commands should use.
The -M 1|2 option overrides this setting.
Accepted values:
  lvm1
  lvm2
Shared libraries that process different metadata formats.
If support for LVM1 metadata was compiled as a shared library use
format_libraries = "liblvm2format1.so"
Location of /etc system configuration directory.
Type of locking to use.
Accepted values:
    Turns off locking. Warning: this risks metadata corruption if
    commands run concurrently.
    LVM uses local file-based locking, the standard mode.
    LVM uses the external shared library locking_library.
    LVM uses built-in clustered locking with clvmd.
    This is incompatible with lvmetad. If use_lvmetad is enabled,
    LVM prints a warning and disables lvmetad use.
    LVM uses read-only locking which forbids any operations that
    might change metadata.
    Offers dummy locking for tools that do not need any locks.
    You should not need to set this directly; the tools will select
    when to use it instead of the configured locking_type.
    Do not use lvmetad or the kernel device-mapper driver with this
    locking type. It is used by the --readonly option that offers
    read-only access to Volume Group metadata that cannot be locked
    safely because it belongs to an inaccessible domain and might be
    in use, for example a virtual machine image or a disk that is
    shared by a clustered machine.
When disabled, fail if a lock request would block.
Attempt to use built-in cluster locking if locking_type 2 fails.
If using external locking (type 2) and initialisation fails, with
this enabled, an attempt will be made to use the built-in clustered
locking. Disable this if using a customised locking_library.
Use locking_type 1 (local) if locking_type 2 or 3 fail.
If an attempt to initialise type 2 or type 3 locking failed, perhaps
because cluster components such as clvmd are not running, with this
enabled, an attempt will be made to use local file-based locking
(type 1). If this succeeds, only commands against local VGs will
proceed. VGs marked as clustered will be ignored.
Directory to use for LVM command file locks.
Local non-LV directory that holds file-based locks while commands are
in progress. A directory like /tmp that may get wiped on reboot is OK.
Allow quicker VG write access during high volume read access.
When there are competing read-only and read-write access requests for
a volume group's metadata, instead of always granting the read-only
requests immediately, delay them to allow the read-write requests to
be serviced. Without this setting, write access may be stalled by a
high volume of read-only requests. This option only affects
locking_type 1 viz. local file-based locking.
Search this directory first for shared libraries.
The external locking library to use for locking_type 2.
Abort a command that encounters an internal error.
Treat any internal errors as fatal errors, aborting the process that
encountered the internal error. Please only enable for debugging.
detect_internal_vg_cache_corruption
Internal verification of VG structures.
Check if CRC matches when a parsed VG is used multiple times. This
is useful to catch unexpected changes to cached VG structures.
Please only enable for debugging.
No operations that change on-disk metadata are permitted.
Additionally, read-only commands that encounter metadata in need of
repair will still be allowed to proceed exactly as if the repair had
been performed (except for the unchanged vg_seqno). Inappropriate
use could mess up your system, so seek advice first!
The segment type used by the short mirroring option -m.
The --type mirror|raid1 option overrides this setting.
Accepted values:
  mirror
    The original RAID1 implementation from LVM/DM. It is
    characterized by a flexible log solution (core, disk, mirrored),
    and by the necessity to block I/O while handling a failure.
    There is an inherent race in the dmeventd failure handling logic
    with snapshots of devices using this type of RAID1 that in the
    worst case could cause a deadlock. (Also see
    devices/ignore_lvm_mirrors.)
  raid1
    This is a newer RAID1 implementation using the MD RAID1
    personality through device-mapper. It is characterized by a
    lack of log options. (A log is always allocated for every
    device and they are placed on the same device as the image,
    so no separate devices are required.) This mirror
    implementation does not require I/O to be blocked while
    handling a failure. This mirror implementation is not
    cluster-aware and cannot be used in a shared (active/active)
    fashion in a cluster.
The segment type used by the -i -m combination.
The --type raid10|mirror option overrides this setting.
The --stripes/-i and --mirrors/-m options can both be specified
during the creation of a logical volume to use both striping and
mirroring for the LV. There are two different implementations.
Accepted values:
  raid10
    LVM uses MD's RAID10 personality through DM. This is the
    preferred option.
  mirror
    LVM layers the 'mirror' and 'stripe' segment types. The layering
    is done by creating a mirror LV on top of striped sub-LVs,
    effectively creating a RAID 0+1 array. The layering is suboptimal
    in terms of providing redundancy and performance.
The segment type used by the -V -L combination.
The --type snapshot|thin option overrides this setting.
The combination of -V and -L options creates a sparse LV. There are
two different implementations.
Accepted values:
  snapshot
    The original snapshot implementation from LVM/DM. It uses an old
    snapshot that mixes data and metadata within a single COW
    storage volume and performs poorly when the size of stored data
    passes hundreds of MB.
  thin
    A newer implementation that uses thin provisioning. It has a
    bigger minimal chunk size (64KiB) and uses a separate volume for
    metadata. It has better performance, especially when more data
    is used. It also supports full snapshots.
lvdisplay_shows_full_device_path
Enable this to reinstate the previous lvdisplay name format.
The default format for displaying LV names in lvdisplay was changed
in version 2.02.89 to show the LV name and path separately.
Previously this was always shown as /dev/vgname/lvname even when that
was never a valid path in the /dev filesystem.
Use lvmetad to cache metadata and reduce disk scanning.
When enabled (and running), lvmetad provides LVM commands with VG
metadata and PV state. LVM commands then avoid reading this
information from disks which can be slow. When disabled (or not
running), LVM commands fall back to scanning disks to obtain VG
metadata. lvmetad is kept updated via udev rules which must be set
up for LVM to work correctly. (The udev rules should be installed
by default.) Without a proper udev setup, changes in the system's
block device configuration will be unknown to LVM, and ignored
until a manual 'pvscan --cache' is run. If lvmetad was running
while use_lvmetad was disabled, it must be stopped, use_lvmetad
enabled, and then started. When using lvmetad, LV activation is
switched to an automatic, event-based mode. In this mode, LVs are
activated based on incoming udev events that inform lvmetad when
PVs appear on the system. When a VG is complete (all PVs present),
it is auto-activated. The auto_activation_volume_list setting
controls which LVs are auto-activated (all by default.)
When lvmetad is updated (automatically by udev events, or directly
by pvscan --cache), devices/filter is ignored and all devices are
scanned by default. lvmetad always keeps unfiltered information
which is provided to LVM commands. Each LVM command then filters
based on devices/filter. This does not apply to other, non-regexp,
filtering settings: component filters such as multipath and MD
are checked during pvscan --cache. To filter a device and prevent
scanning from the LVM system entirely, including lvmetad, use
devices/global_filter.
Use lvmlockd for locking among hosts using LVM on shared storage.
See lvmlockd(8) for more information.
Retry lvmlockd lock requests this many times.
Size in MiB to extend the internal LV holding sanlock locks.
The internal LV holds locks for each LV in the VG, and after enough
LVs have been created, the internal LV needs to be extended. lvcreate
will automatically extend the internal LV when needed by the amount
specified here. Setting this to 0 disables the automatic extension
and can cause lvcreate to fail.
The full path to the thin_check command.
LVM uses this command to check that a thin metadata device is in a
usable state. When a thin pool is activated and after it is
deactivated, this command is run. Activation will only proceed if
the command has an exit status of 0. Set to "" to skip this check.
(Not recommended.) Also see thin_check_options.
(See package device-mapper-persistent-data or thin-provisioning-tools)
The full path to the thin_dump command.
LVM uses this command to dump thin pool metadata.
(See package device-mapper-persistent-data or thin-provisioning-tools)
The full path to the thin_repair command.
LVM uses this command to repair a thin metadata device if it is in
an unusable state. Also see thin_repair_options.
(See package device-mapper-persistent-data or thin-provisioning-tools)
#S-q#S--clear-needs-check-flag
List of options passed to the thin_check command.
With thin_check version 2.1 or newer you can add the option
--ignore-non-fatal-errors to let it pass through ignorable errors
and fix them later. With thin_check version 3.2 or newer you should
include the option --clear-needs-check-flag.
List of options passed to the thin_repair command.
Features to not use in the thin driver.
This can be helpful for testing, or to avoid using a feature that is
causing problems. Features include: block_size, discards,
discards_non_power_2, external_origin, metadata_resize,
external_origin_extend, error_if_no_space.
Example
thin_disabled_features = [ "discards", "block_size" ]
Features to not use in the cache driver.
This can be helpful for testing, or to avoid using a feature that is
causing problems. Features include: policy_mq, policy_smq.
Example
cache_disabled_features = [ "policy_smq" ]
The full path to the cache_check command.
LVM uses this command to check that a cache metadata device is in a
usable state. When a cached LV is activated and after it is
deactivated, this command is run. Activation will only proceed if the
command has an exit status of 0. Set to "" to skip this check.
(Not recommended.) Also see cache_check_options.
(See package device-mapper-persistent-data or thin-provisioning-tools)
The full path to the cache_dump command.
LVM uses this command to dump cache pool metadata.
(See package device-mapper-persistent-data or thin-provisioning-tools)
The full path to the cache_repair command.
LVM uses this command to repair a cache metadata device if it is in
an unusable state. Also see cache_repair_options.
(See package device-mapper-persistent-data or thin-provisioning-tools)
List of options passed to the cache_check command.
With cache_check version 5.0 or newer you should include the option
--clear-needs-check-flag.
List of options passed to the cache_repair command.
The method LVM uses to set the local system ID.
Volume Groups can also be given a system ID (by vgcreate, vgchange,
or vgimport.) A VG on shared storage devices is accessible only to
the host with a matching system ID. See 'man lvmsystemid' for
information on limitations and correct usage.
Accepted values:
  none
    The host has no system ID.
  lvmlocal
    Obtain the system ID from the system_id setting in the 'local'
    section of an lvm configuration file, e.g. lvmlocal.conf.
  uname
    Set the system ID from the hostname (uname) of the system.
    System IDs beginning localhost are not permitted.
  machineid
    Use the contents of the machine-id file to set the system ID.
    Some systems create this file at installation time.
    See 'man machine-id' and global/etc.
  file
    Use the contents of another file (system_id_file) to set the
    system ID.
The full path to the file containing a system ID.
This is used when system_id_source is set to 'file'.
Comments starting with the character # are ignored.
Perform internal checks of libdevmapper operations.
Useful for debugging problems with activation. Some of the checks may
be expensive, so it's best to use this only when there seems to be a
problem.
Use lvmpolld to supervise long running LVM commands.
When enabled, control of long running LVM commands is transferred
from the original LVM command to the lvmpolld daemon. This allows
the operation to continue independent of the original LVM command.
After lvmpolld takes over, the LVM command displays the progress
of the ongoing operation. lvmpolld itself runs LVM commands to
manage the progress of ongoing operations. lvmpolld can be used as
a native systemd service, which allows it to be started on demand,
and to use its own control group. When this option is disabled, LVM
commands will supervise long running operations by forking themselves.
Use udev notifications to synchronize udev and LVM.
The --nodevsync option overrides this setting.
When disabled, LVM commands will not wait for notifications from
udev, but continue irrespective of any possible udev processing in
the background. Only use this if udev is not running or has rules
that ignore the devices LVM creates. If enabled when udev is not
running, and LVM processes are waiting for udev, run the command
'dmsetup udevcomplete_all' to wake them up.
Use udev rules to manage LV device nodes and symlinks.
When disabled, LVM will manage the device nodes and symlinks for
active LVs itself. Manual intervention may be required if this
setting is changed while LVs are active.
Use extra checks in LVM to verify udev operations.
This enables additional checks (and if necessary, repairs) on entries
in the device directory after udev has completed processing its
events. Useful for diagnosing problems with LVM/udev interactions.
Retry failed LV deactivation.
If LV deactivation fails, LVM will retry for a few seconds before
failing. This may happen because a process run from a quick udev rule
temporarily opened the device.
Method to fill missing stripes when activating an incomplete LV.
Using 'error' will make inaccessible parts of the device return I/O
errors on access. You can instead use a device path, in which case,
that device will be used in place of missing stripes. Using anything
other than 'error' with mirrored or snapshotted volumes is likely to
result in data corruption.
Use the linear target to optimize single stripe LVs.
When disabled, the striped target is used. The linear target is an
optimised version of the striped target that only handles a single
stripe.
Stack size in KiB to reserve for use while devices are suspended.
Insufficent reserve risks I/O deadlock during device suspension.
Memory size in KiB to reserve for use while devices are suspended.
Insufficent reserve risks I/O deadlock during device suspension.
Nice value used while devices are suspended.
Use a high priority so that LVs are suspended
for the shortest possible time.
Only LVs selected by this list are activated.
If this list is defined, an LV is only activated if it matches an
entry in this list. If this list is undefined, it imposes no limits
on LV activation (all are allowed).
Accepted values:
  vgname
    The VG name is matched exactly and selects all LVs in the VG.
  vgname/lvname
    The VG name and LV name are matched exactly and selects the LV.
  @tag
    Selects an LV if the specified tag matches a tag set on the LV
    or VG.
  @*
    Selects an LV if a tag defined on the host is also set on the LV
    or VG. See tags/hosttags. If any host tags exist but volume_list
    is not defined, a default single-entry list containing '@*' is
    assumed.
Example
volume_list = [ "vg1", "vg2/lvol1", "@tag1", "@*" ]
Only LVs selected by this list are auto-activated.
This list works like volume_list, but it is used only by
auto-activation commands. It does not apply to direct activation
commands. If this list is defined, an LV is only auto-activated
if it matches an entry in this list. If this list is undefined, it
imposes no limits on LV auto-activation (all are allowed.) If this
list is defined and empty, i.e. "[]", then no LVs are selected for
auto-activation. An LV that is selected by this list for
auto-activation, must also be selected by volume_list (if defined)
before it is activated. Auto-activation is an activation command that
includes the 'a' argument: --activate ay or -a ay. The 'a' (auto)
argument for auto-activation is meant to be used by activation
commands that are run automatically by the system, as opposed to LVM
commands run directly by a user. A user may also use the 'a' flag
directly to perform auto-activation. Also see pvscan(8) for more
information about auto-activation.
Accepted values:
  vgname
    The VG name is matched exactly and selects all LVs in the VG.
  vgname/lvname
    The VG name and LV name are matched exactly and selects the LV.
  @tag
    Selects an LV if the specified tag matches a tag set on the LV
    or VG.
  @*
    Selects an LV if a tag defined on the host is also set on the LV
    or VG. See tags/hosttags. If any host tags exist but volume_list
    is not defined, a default single-entry list containing '@*' is
    assumed.
Example
volume_list = [ "vg1", "vg2/lvol1", "@tag1", "@*" ]
LVs in this list are activated in read-only mode.
If this list is defined, each LV that is to be activated is checked
against this list, and if it matches, it is activated in read-only
mode. This overrides the permission setting stored in the metadata,
e.g. from --permission rw.
Accepted values:
  vgname
    The VG name is matched exactly and selects all LVs in the VG.
  vgname/lvname
    The VG name and LV name are matched exactly and selects the LV.
  @tag
    Selects an LV if the specified tag matches a tag set on the LV
    or VG.
  @*
    Selects an LV if a tag defined on the host is also set on the LV
    or VG. See tags/hosttags. If any host tags exist but volume_list
    is not defined, a default single-entry list containing '@*' is
    assumed.
Example
volume_list = [ "vg1", "vg2/lvol1", "@tag1", "@*" ]
This has been replaced by the activation/raid_region_size setting.
Size in KiB of each copy operation when mirroring.
Size in KiB of each raid or mirror synchronization region.
For raid or mirror segment types, this is the amount of data that is
copied at once when initializing, or moved at once by pvmove.
Return errors if a thin pool runs out of space.
The --errorwhenfull option overrides this setting.
When enabled, writes to thin LVs immediately return an error if the
thin pool is out of data space. When disabled, writes to thin LVs
are queued if the thin pool is out of space, and processed when the
thin pool data space is extended. New thin pools are assigned the
behavior defined here.
Setting to use when there is no readahead setting in metadata.
Accepted values:
  none
    Disable readahead.
  auto
    Use default value chosen by kernel.
Defines how a device failure in a RAID LV is handled.
This includes LVs that have the following segment types:
raid1, raid4, raid5*, and raid6*.
If a device in the LV fails, the policy determines the steps
performed by dmeventd automatically, and the steps perfomed by the
manual command lvconvert --repair --use-policies.
Automatic handling requires dmeventd to be monitoring the LV.
Accepted values:
  warn
    Use the system log to warn the user that a device in the RAID LV
    has failed. It is left to the user to run lvconvert --repair
    manually to remove or replace the failed device. As long as the
    number of failed devices does not exceed the redundancy of the LV
    (1 device for raid4/5, 2 for raid6), the LV will remain usable.
  allocate
    Attempt to use any extra physical volumes in the VG as spares and
    replace faulty devices.
Defines how a device failure in a 'mirror' LV is handled.
An LV with the 'mirror' segment type is composed of mirror images
(copies) and a mirror log. A disk log ensures that a mirror LV does
not need to be re-synced (all copies made the same) every time a
machine reboots or crashes. If a device in the LV fails, this policy
determines the steps perfomed by dmeventd automatically, and the steps
performed by the manual command lvconvert --repair --use-policies.
Automatic handling requires dmeventd to be monitoring the LV.
Accepted values:
  remove
    Simply remove the faulty device and run without it. If the log
    device fails, the mirror would convert to using an in-memory log.
    This means the mirror will not remember its sync status across
    crashes/reboots and the entire mirror will be re-synced. If a
    mirror image fails, the mirror will convert to a non-mirrored
    device if there is only one remaining good copy.
  allocate
    Remove the faulty device and try to allocate space on a new
    device to be a replacement for the failed device. Using this
    policy for the log is fast and maintains the ability to remember
    sync state through crashes/reboots. Using this policy for a
    mirror device is slow, as it requires the mirror to resynchronize
    the devices, but it will preserve the mirror characteristic of
    the device. This policy acts like 'remove' if no suitable device
    and space can be allocated for the replacement.
  allocate_anywhere
    Not yet implemented. Useful to place the log device temporarily
    on the same physical volume as one of the mirror images. This
    policy is not recommended for mirror devices since it would break
    the redundant nature of the mirror. This policy acts like
    'remove' if no suitable device and space can be allocated for the
    replacement.
Defines how a device failure in a 'mirror' log LV is handled.
The mirror_image_fault_policy description for mirrored LVs also
applies to mirrored log LVs.
This has been replaced by the activation/mirror_image_fault_policy setting.
Define how a device failure affecting a mirror is handled.
Auto-extend a snapshot when its usage exceeds this percent.
Setting this to 100 disables automatic extension.
The minimum value is 50 (a smaller value is treated as 50.)
Also see snapshot_autoextend_percent.
Automatic extension requires dmeventd to be monitoring the LV.
Example
Using 70% autoextend threshold and 20% autoextend size, when a 1G
snapshot exceeds 700M, it is extended to 1.2G, and when it exceeds
840M, it is extended to 1.44G:
snapshot_autoextend_threshold = 70
Auto-extending a snapshot adds this percent extra space.
The amount of additional space added to a snapshot is this
percent of its current size.
Example
Using 70% autoextend threshold and 20% autoextend size, when a 1G
snapshot exceeds 700M, it is extended to 1.2G, and when it exceeds
840M, it is extended to 1.44G:
snapshot_autoextend_percent = 20
thin_pool_autoextend_threshold
Auto-extend a thin pool when its usage exceeds this percent.
Setting this to 100 disables automatic extension.
The minimum value is 50 (a smaller value is treated as 50.)
Also see thin_pool_autoextend_percent.
Automatic extension requires dmeventd to be monitoring the LV.
Example
Using 70% autoextend threshold and 20% autoextend size, when a 1G
thin pool exceeds 700M, it is extended to 1.2G, and when it exceeds
840M, it is extended to 1.44G:
thin_pool_autoextend_threshold = 70
Auto-extending a thin pool adds this percent extra space.
The amount of additional space added to a thin pool is this
percent of its current size.
Example
Using 70% autoextend threshold and 20% autoextend size, when a 1G
thin pool exceeds 700M, it is extended to 1.2G, and when it exceeds
840M, it is extended to 1.44G:
thin_pool_autoextend_percent = 20
Do not mlock these memory areas.
While activating devices, I/O to devices being (re)configured is
suspended. As a precaution against deadlocks, LVM pins memory it is
using so it is not paged out, and will not require I/O to reread.
Groups of pages that are known not to be accessed during activation
do not need to be pinned into memory. Each string listed in this
setting is compared against each line in /proc/self/maps, and the
pages corresponding to lines that match are not pinned. On some
systems, locale-archive was found to make up over 80% of the memory
used by the process.
Example
mlock_filter = [ "locale/locale-archive", "gconv/gconv-modules.cache" ]
Use the old behavior of mlockall to pin all memory.
Prior to version 2.02.62, LVM used mlockall() to pin the whole
process's memory while activating devices.
Monitor LVs that are activated.
The --ignoremonitoring option overrides this setting.
When enabled, LVM will ask dmeventd to monitor activated LVs.
Check pvmove or lvconvert progress at this interval (seconds).
When pvmove or lvconvert must wait for the kernel to finish
synchronising or merging data, they check and report progress at
intervals of this number of seconds. If this is set to 0 and there
is only one thing to wait for, there are no progress reports, but
the process is awoken immediately once the operation is complete.
Set the activation skip flag on new thin snapshot LVs.
The --setactivationskip option overrides this setting.
An LV can have a persistent 'activation skip' flag. The flag causes
the LV to be skipped during normal activation. The lvchange/vgchange
-K option is required to activate LVs that have the activation skip
flag set. When this setting is enabled, the activation skip flag is
set on new thin snapshot LVs.
How LVs with missing devices are activated.
The --activationmode option overrides this setting.
Accepted values:
  complete
    Only allow activation of an LV if all of the Physical Volumes it
    uses are present. Other PVs in the Volume Group may be missing.
  degraded
    Like complete, but additionally RAID LVs of segment type raid1,
    raid4, raid5, radid6 and raid10 will be activated if there is no
    data loss, i.e. they have sufficient redundancy to present the
    entire addressable range of the Logical Volume.
  partial
    Allows the activation of any LV even if a missing or failed PV
    could cause data loss with a portion of the LV inaccessible.
    This setting should not normally be used, but may sometimes
    assist with data recovery.
Locking is started only for VGs selected by this list.
The rules are the same as those for volume_list.
Locking is auto-started only for VGs selected by this list.
The rules are the same as those for auto_activation_volume_list.
Number of copies of metadata to store on each PV.
The --pvmetadatacopies option overrides this setting.
Accepted values:
    Two copies of the VG metadata are stored on the PV, one at the
    front of the PV, and one at the end.
    One copy of VG metadata is stored at the front of the PV.
    No copies of VG metadata are stored on the PV. This may be
    useful for VGs containing large numbers of PVs.
Number of copies of metadata to maintain for each VG.
The --vgmetadatacopies option overrides this setting.
If set to a non-zero value, LVM automatically chooses which of the
available metadata areas to use to achieve the requested number of
copies of the VG metadata. If you set a value larger than the the
total number of metadata areas available, then metadata is stored in
them all. The value 0 (unmanaged) disables this automatic management
and allows you to control which metadata areas are used at the
individual PV level using pvchange --metadataignore y|n.
Approximate number of sectors to use for each metadata copy.
VGs with large numbers of PVs or LVs, or VGs containing complex LV
structures, may need additional space for VG metadata. The metadata
areas are treated as circular buffers, so unused space becomes filled
with an archive of the most recent previous versions of the metadata.
Ignore metadata areas on a new PV.
The --metadataignore option overrides this setting.
If metadata areas on a PV are ignored, LVM will not store metadata
in them.
Directories holding live copies of text format metadata.
These directories must not be on logical volumes!
It's possible to use LVM with a couple of directories here,
preferably on different (non-LV) filesystems, and with no other
on-disk metadata (pvmetadatacopies = 0). Or this can be in addition
to on-disk metadata areas. The feature was originally added to
simplify testing and is not supported under low memory situations -
the machine could lock up. Never edit any files in these directories
by hand unless you are absolutely sure you know what you are doing!
Use the supplied toolset to make changes (e.g. vgcfgrestore).
Example
dirs = [ "/etc/lvm/metadata", "/mnt/disk2/lvm/metadata2" ]
Do not print empty report fields.
Fields that don't have a value set for any of the rows reported are
skipped and not printed. Compact output is applicable only if
report/buffered is enabled.
Align columns in report output.
Buffer report output.
When buffered reporting is used, the report's content is appended
incrementally to include each object being reported until the report
is flushed to output which normally happens at the end of command
execution. Otherwise, if buffering is not used, each object is
reported as soon as its processing is finished.
Show headings for columns on report.
A separator to use on report after each field.
A separator to use for list items when reported.
Use a field name prefix for each field reported.
Quote field values when using field name prefixes.
Output each column as a row.
If set, this also implies report/prefixes=1.
Use binary values 0 or 1 instead of descriptive literal values.
For columns that have exactly two valid values to report
(not counting the 'unknown' value which denotes that the
value could not be determined).
Set time format for fields reporting time values.
Format specification is a string which may contain special character
sequences and ordinary character sequences. Ordinary character
sequences are copied verbatim. Each special character sequence is
introduced by the '%' character and such sequence is then
substituted with a value as described below.
Accepted values:
  %a
    The abbreviated name of the day of the week according to the
    current locale.
  %A
    The full name of the day of the week according to the current
    locale.
  %b
    The abbreviated month name according to the current locale.
  %B
    The full month name according to the current locale.
  %c
    The preferred date and time representation for the current
    locale (alt E)
  %C
    The century number (year/100) as a 2-digit integer. (alt E)
  %d
    The day of the month as a decimal number (range 01 to 31).
    (alt O)
  %D
    Equivalent to %m/%d/%y. (For Americans only. Americans should
    note that in other countries%d/%m/%y is rather common. This
    means that in international context this format is ambiguous and
    should not be used.
  %e
    Like %d, the day of the month as a decimal number, but a leading
    zero is replaced by a space. (alt O)
  %E
    Modifier: use alternative local-dependent representation if
    available.
  %F
    Equivalent to %Y-%m-%d (the ISO 8601 date format).
  %G
    The ISO 8601 week-based year with century as adecimal number.
    The 4-digit year corresponding to the ISO week number (see %V).
    This has the same format and value as %Y, except that if the
    ISO week number belongs to the previous or next year, that year
    is used instead.
  %g
    Like %G, but without century, that is, with a 2-digit year
    (00-99).
  %h
    Equivalent to %b.
  %H
    The hour as a decimal number using a 24-hour clock
    (range 00 to 23). (alt O)
  %I
    The hour as a decimal number using a 12-hour clock
    (range 01 to 12). (alt O)
  %j
    The day of the year as a decimal number (range 001 to 366).
  %k
    The hour (24-hour clock) as a decimal number (range 0 to 23);
    single digits are preceded by a blank. (See also %H.)
  %l
    The hour (12-hour clock) as a decimal number (range 1 to 12);
    single digits are preceded by a blank. (See also %I.)
  %m
    The month as a decimal number (range 01 to 12). (alt O)
  %M
    The minute as a decimal number (range 00 to 59). (alt O)
  %O
    Modifier: use alternative numeric symbols.
  %p
    Either "AM" or "PM" according to the given time value,
    or the corresponding strings for the current locale. Noon is
    treated as "PM" and midnight as "AM".
  %P
    Like %p but in lowercase: "am" or "pm" or a corresponding
    string for the current locale.
  %r
    The time in a.m. or p.m. notation. In the POSIX locale this is
    equivalent to %I:%M:%S %p.
  %R
    The time in 24-hour notation (%H:%M). For a version including
    the seconds, see %T below.
  %s
    The number of seconds since the Epoch,
    1970-01-01 00:00:00 +0000 (UTC)
  %S
    The second as a decimal number (range 00 to 60). (The range is
    up to 60 to allow for occasional leap seconds.) (alt O)
  %t
    A tab character.
  %T
    The time in 24-hour notation (%H:%M:%S).
  %u
    The day of the week as a decimal, range 1 to 7, Monday being 1.
    See also %w. (alt O)
  %U
    The week number of the current year as a decimal number,
    range 00 to 53, starting with the first Sunday as the first
    day of week 01. See also %V and %W. (alt O)
  %V
    The ISO 8601 week number of the current year as a decimal number,
    range 01 to 53, where week 1 is the first week that has at least
    4 days in the new year. See also %U and %W. (alt O)
  %w
    The day of the week as a decimal, range 0 to 6, Sunday being 0.
    See also %u. (alt O)
  %W
    The week number of the current year as a decimal number,
    range 00 to 53, starting with the first Monday as the first day
    of week 01. (alt O)
  %x
    The preferred date representation for the current locale without
    the time. (alt E)
  %X
    The preferred time representation for the current locale without
    the date. (alt E)
  %y
    The year as a decimal number without a century (range 00 to 99).
    (alt E, alt O)
  %Y
    The year as a decimal number including the century. (alt E)
  %z
    The +hhmm or -hhmm numeric timezone (that is, the hour and minute
    offset from UTC).
  %Z
    The timezone name or abbreviation.
  %%
    A literal '%' character.
List of columns to sort by when reporting 'lvm devtypes' command.
See 'lvm devtypes -o help' for the list of possible fields.
devtype_name,devtype_max_partitions,devtype_description
List of columns to report for 'lvm devtypes' command.
See 'lvm devtypes -o help' for the list of possible fields.
List of columns to report for 'lvm devtypes' command in verbose mode.
See 'lvm devtypes -o help' for the list of possible fields.
List of columns to sort by when reporting 'lvs' command.
See 'lvs -o help' for the list of possible fields.
lv_name,vg_name,lv_attr,lv_size,pool_lv,origin,data_percent,metadata_percent,move_pv,mirror_log,copy_percent,convert_lv
List of columns to report for 'lvs' command.
See 'lvs -o help' for the list of possible fields.
lv_name,vg_name,seg_count,lv_attr,lv_size,lv_major,lv_minor,lv_kernel_major,lv_kernel_minor,pool_lv,origin,data_percent,metadata_percent,move_pv,copy_percent,mirror_log,convert_lv,lv_uuid,lv_profile
List of columns to report for 'lvs' command in verbose mode.
See 'lvs -o help' for the list of possible fields.
List of columns to sort by when reporting 'vgs' command.
See 'vgs -o help' for the list of possible fields.
vg_name,pv_count,lv_count,snap_count,vg_attr,vg_size,vg_free
List of columns to report for 'vgs' command.
See 'vgs -o help' for the list of possible fields.
vg_name,vg_attr,vg_extent_size,pv_count,lv_count,snap_count,vg_size,vg_free,vg_uuid,vg_profile
List of columns to report for 'vgs' command in verbose mode.
See 'vgs -o help' for the list of possible fields.
List of columns to sort by when reporting 'pvs' command.
See 'pvs -o help' for the list of possible fields.
pv_name,vg_name,pv_fmt,pv_attr,pv_size,pv_free
List of columns to report for 'pvs' command.
See 'pvs -o help' for the list of possible fields.
pv_name,vg_name,pv_fmt,pv_attr,pv_size,pv_free,dev_size,pv_uuid
List of columns to report for 'pvs' command in verbose mode.
See 'pvs -o help' for the list of possible fields.
List of columns to sort by when reporting 'lvs --segments' command.
See 'lvs --segments -o help' for the list of possible fields.
lv_name,vg_name,lv_attr,stripes,segtype,seg_size
List of columns to report for 'lvs --segments' command.
See 'lvs --segments -o help' for the list of possible fields.
lv_name,vg_name,lv_attr,seg_start,seg_size,stripes,segtype,stripesize,chunksize
List of columns to report for 'lvs --segments' command in verbose mode.
See 'lvs --segments -o help' for the list of possible fields.
List of columns to sort by when reporting 'pvs --segments' command.
See 'pvs --segments -o help' for the list of possible fields.
pv_name,vg_name,pv_fmt,pv_attr,pv_size,pv_free,pvseg_start,pvseg_size
pv_name,vg_name,pv_fmt,pv_attr,pv_size,pv_free,pvseg_start,pvseg_size,lv_name,seg_start_pe,segtype,seg_pe_ranges
List of columns to sort by when reporting 'pvs --segments' command in verbose mode.
See 'pvs --segments -o help' for the list of possible fields.
libdevmapper-event-lvm2mirror.so
The library dmeventd uses when monitoring a mirror device.
libdevmapper-event-lvm2mirror.so attempts to recover from
failures. It removes failed devices from a volume group and
reconfigures a mirror as necessary. If no mirror library is
provided, mirrors are not monitored through dmeventd.
libdevmapper-event-lvm2raid.so
libdevmapper-event-lvm2snapshot.so
The library dmeventd uses when monitoring a snapshot device.
libdevmapper-event-lvm2snapshot.so monitors the filling of snapshots
and emits a warning through syslog when the usage exceeds 80%. The
warning is repeated when 85%, 90% and 95% of the snapshot is filled.
libdevmapper-event-lvm2thin.so
The library dmeventd uses when monitoring a thin device.
libdevmapper-event-lvm2thin.so monitors the filling of a pool
and emits a warning through syslog when the usage exceeds 80%. The
warning is repeated when 85%, 90% and 95% of the pool is filled.
The full path to the dmeventd binary.
Create a host tag using the machine name.
The machine name is nodename returned by uname(2).
Replace this subsection name with a custom tag name.
Multiple subsections like this can be created. The '@' prefix for
tags is optional. This subsection can contain host_list, which is a
list of machine names. If the name of the local machine is found in
host_list, then the name of this subsection is used as a tag and is
applied to the local machine as a 'host tag'. If this subsection is
empty (has no host_list), then the subsection name is always applied
as a 'host tag'.
Example
The host tag foo is given to all hosts, and the host tag
bar is given to the hosts named machine1 and machine2.
tags { foo { } bar { host_list = [ "machine1", "machine2" ] } }
A list of machine names.
These machine names are compared to the nodename returned
by uname(2). If the local machine name matches an entry in
this list, the name of the subsection is applied to the
machine as a 'host tag'.
Defines the local system ID for lvmlocal mode.
This is used when global/system_id_source is set to 'lvmlocal' in the
main configuration file, e.g. lvm.conf. When used, it must be set to
a unique value among all hosts sharing access to the storage,
e.g. a host name.
Example
Set no system ID:
system_id = ""
Set the system_id to a specific name:
system_id = "host1"
A list of extra VG system IDs the local host can access.
VGs with the system IDs listed here (in addition to the host's own
system ID) can be fully accessed by the local host. (These are
system IDs that the host sees in VGs, not system IDs that identify
the local host, which is determined by system_id_source.)
Use this only after consulting 'man lvmsystemid' to be certain of
correct usage and possible dangers.
The lvmlockd sanlock host_id.
This must be unique among all hosts, and must be between 1 and 2000.
config/config.c
<unknown>
Setting %s to %s
option
%s# Configuration %s %s.
%s# %s
%s# %s
 string
 float
 integer
 boolean
 section
 array with values of type:
%s%s%s%s%s%s%s
Failed to duplicate filename.
%s is not a regular file
%s is empty
mmap
%s: Checksum error
munmap
config_tree allocation failed
Loading config file: %s
Failed to load config file %s
Dumping configuration to %s
Failure while writing to %s
command profile
metadata profile
Undefined profile name.
profile allocation failed
%s/%s.profile
Ignoring invalid %s %s.
generic
performance
%s%s%s/%s.cache
%s/%s/%s.cache
(root)
How LVM uses block devices.
shell
Host tag settings.
checks
abort_on_errors
profile_dir
#S/dev
loopfiles
obtain_device_list_from_udev
external_device_info_source
preferred_names
#Sa|.*/|
global_filter
Cache file path.
cache_dir
cache_file_prefix
write_cache_state
sysfs_scan
multipath_component_detection
md_component_detection
fw_raid_component_detection
md_chunk_alignment
default_data_alignment
data_alignment_detection
ignore_suspended_devices
ignore_lvm_mirrors
disable_after_error_count
require_restorefile_with_uuid
pv_min_size
issue_discards
cling_tag_list
maximise_cling
use_blkid_wiping
@DEFAULT_USE_BLKID_WIPING@
cache_pool_cachemode
writethrough
Cache mode.
cache_mode
cache_policy
cache_settings
cache_pool_chunk_size
thin_pool_zero
thin_pool_discards
thin_pool_chunk_size_policy
thin_pool_chunk_size
physical_extent_size
silent
syslog
overwrite
level
indent
command_names
activate_file
debug_classes
backup_dir
archive_dir
retain_min
retain_days
history_size
umask
si_unit_consistency
fallback_to_lvm1
@DEFAULT_FALLBACK_TO_LVM1@
format_libraries
segment_libraries
/proc
Location of proc filesystem.
/etc
@CONFDIR@
locking_type
wait_for_locks
fallback_to_clustered_locking
fallback_to_local_locking
locking_dir
/run/lock/lvm
@DEFAULT_LOCK_DIR@
prioritise_write_locks
library_dir
locking_library
liblvm2clusterlock.so
abort_on_internal_errors
metadata_read_only
mirror_segtype_default
@DEFAULT_MIRROR_SEGTYPE@
raid10_segtype_default
@DEFAULT_RAID10_SEGTYPE@
sparse_segtype_default
@DEFAULT_SPARSE_SEGTYPE@
use_lvmetad
@DEFAULT_USE_LVMETAD@
use_lvmlockd
lvmlockd_lock_retries
sanlock_lv_extend
thin_check_executable
/usr/sbin/thin_check
@THIN_CHECK_CMD@
thin_dump_executable
/usr/sbin/thin_dump
@THIN_DUMP_CMD@
thin_repair_executable
/usr/sbin/thin_repair
@THIN_REPAIR_CMD@
thin_check_options
thin_repair_options
thin_disabled_features
cache_disabled_features
cache_check_executable
/usr/sbin/cache_check
@CACHE_CHECK_CMD@
cache_dump_executable
/usr/sbin/cache_dump
@CACHE_DUMP_CMD@
cache_repair_executable
/usr/sbin/cache_repair
@CACHE_REPAIR_CMD@
cache_check_options
cache_repair_options
system_id_source
system_id_file
use_lvmpolld
@DEFAULT_USE_LVMPOLLD@
udev_sync
udev_rules
verify_udev_operations
retry_deactivation
missing_stripe_filler
use_linear_target
reserved_stack
reserved_memory
process_priority
auto_activation_volume_list
read_only_volume_list
mirror_region_size
raid_region_size
error_when_full
raid_fault_policy
warn
mirror_image_fault_policy
mirror_log_fault_policy
mirror_device_fault_policy
snapshot_autoextend_threshold
snapshot_autoextend_percent
thin_pool_autoextend_percent
mlock_filter
use_mlockall
polling_interval
auto_set_activation_skip
activation_mode
auto_lock_start_list
pvmetadatasize
pvmetadataignore
dirs
disk_areas
disk_area
start_sector
compact_output
list_item_separator
colums_as_rows
binary_values_as_numeric
time_format
%Y-%m-%d %T %z
devtypes_sort
devtype_name
devtypes_cols
devtypes_cols_verbose
lvs_sort
vg_name,lv_name
lvs_cols
lvs_cols_verbose
vgs_sort
vg_name
vgs_cols
vgs_cols_verbose
pvs_sort
pv_name
pvs_cols
pvs_cols_verbose
vg_name,lv_name,seg_start
pvsegs_sort
pv_name,pvseg_start
pvsegs_cols
pvsegs_cols_verbose
mirror_library
raid_library
snapshot_library
thin_library
/usr/sbin/dmeventd
@DMEVENTD_PATH@
hosttags
system_id
extra_system_ids
host_id
undefined
merged files
special purpose
4str_list allocation failed
datastruct/str_list.c
block/
disk/
%s: %s failed: %s
device/dev-cache.c
lstat
filename strdup failed
%s: Already in device cache
 (preferred name)
%s: Not a block device
%s: Not in udev db
%s: Not a regular file
%s: New preferred name
Ignoring %s: %s.
Ignoring %s: Not a directory.
dir_list allocation failed
%s/dev/block/%d:%d
dm_snprintf partition failed.
No sysfs entry for %d:%d.
dev_iter allocation failed
unknown device
not found in config
dev_cache
strdup dev_dir failed.
preferred device name matcher
Using %s
struct device allocation failed
struct dm_str_list allocation failed
Couldn't insert device into binary tree.
Failed to duplicate path string.
Couldn't add alias to dev cache.
%s: Added to device cache (%d:%d)
Couldn't add name to hash in dev cache.
%s: Aliased to %s in device cache%s (%d:%d)
%s: Symbolic link to directory
udev failed to return a device for entry %s.
udev failed to return a device node for entry %s.
udev failed to return a symlink name for entry %s.
Failed to enumerate udev device list.
%s: Failed to insert devices from udev-managed directory to device cache fully
%s: Failed to insert devices to device cache fully
Ignoring %s: Not a regular file.
dir_list allocation failed for file
Device '%s' has been left open (%d remaining references).
Internal error: %d device(s) were left open and have been closed.
Couldn't create binary tree for dev-cache.
devices/preferred_names %s: using built-in preferences
preferred_names patterns must be enclosed in quotes
Failed to allocate preferred device name pattern list.
Failed to allocate a preferred device name pattern.
Preferred device name pattern matcher creation failed.
Path %s no longer valid for device(%d,%d)
Aborting - please provide new pathname for what used to be %s
device/dev-io.c
Closed %s
Read size too large: %lu
%s: lseek %lu failed: %s
 O_EXCL
%s: Not using O_DIRECT
Opened %s %s%s%s
ioctl BLKBSZGET
%s: block size is %u bytes
ioctl BLKPBSZGET
Bounce buffer malloc failed
%s: size is %lu sectors
ioctl BLKGETSIZE64
ioctl BLKRAGET
%s: read_ahead is %u sectors
Read from %s failed
Circular read from %s failed
Wiping %s at %lu length %zu
Attempt to read an unopened device (%s).
%s: %s failed after %lu of %lu at %lu: %s
WARNING: Error counts reached a limit of %d. Device %s was disabled
Attempt to close device '%s' which is not open.
%s: Immediate close attempt while still referenced
%s already opened read-only. Upgrading to read-write.
dev_open(%s) called while suspended
%s: fstat failed: Has device name changed?
Discarding %lu bytes offset %lu bytes on %s.
%s: BLKDISCARD ioctl at offset %lu size %lu failed: %s.
%s: physical block size is %u bytes
Wiping %s at sector %lu length %zu sectors
device/dev-type.c
Aborted wiping of %s.
Wiping %s on %s.
Failed to wipe %s on %s.
%s/dev/block/%d:%d/%s
dm_snprintf %s failed.
%s/devices
blkext
drbd
dasd
emcpower
power2
device-mapper
DRBD
DASD
EMCPOWER
POWER2
BLKEXT
ID_PART_TABLE_TYPE
ID_PART_ENTRY_DISK
%s/dev/block/%d:%d/partition
dm_snprintf partition failed
readlink
%s/block/%s/dev
dm_snprintf dev failed
sysfs file %s does not exist
fgets
Device %s: %s is %lu%s.
LVM2_member
LVM1_member
DM_snapshot_cow
SBMAGIC
PTTYPE
PTMAGIC_OFFSET
PTMAGIC
partition table
USAGE
LABEL
UUID
software RAID md superblock
swap signature
LUKS signature
SBMAGIC_OFFSET
alignment_offset
queue/minimum_io_size
queue/optimal_io_size
queue/discard_max_bytes
queue/discard_granularity
queue/rotational
SCSI disk
IDE disk
Multiple Disk (MD/SoftRAID)
Loop device
RAM disk
Mapped device
Partitionable MD
DAC960
Network Block Device
Compaq SMART2
Compaq CCISS array
ATA Raid
EMC Powerpath
i2o Block Disk
iSeries disks
Network block device
ATA over Ethernet
Xen virtual block device
PlayStation 3 internal disk
VirtIO disk
MMC block device
Extended device partitions
Fusion IO
Micron PCIe SSD
Violin Memory
STEC
bcache block device cache
NVM Express
ZFS Zvols
Fatal error while trying to detect %s on %s.
WARNING: %s detected on %s. Wipe it? [y/n]: 
Failed to allocate device type register.
No proc filesystem found: using all block device types
Failed to create /proc/devices string
WARNING: /proc/devices line: %s, replacing major with %d.
Expecting string in devices/types in config file
Max partition count missing for %s in devices/types in config file
Zero partition count invalid for %s in devices/types in config file
%s: failed to open device, considering device is partitioned
Internal error: Missing hook for partition table recognition using external device info source %s
sysfs file %s not in expected MAJ:MIN format: %s
sysfs file %s not in expected format: %s
Failed to create a new blkid probe for device %s.
Failed to get offset of the %s signature on %s.
WARNING: Failed to get offset of the %s signature on %s. Wiping skipped.
Failed to get length of the %s signature on %s.
WARNING: Failed to get length of the %s signature on %s. Wiping skipped.
Found existing signature on %s at offset %s: LABEL="%s" UUID="%s" TYPE="%s" USAGE="%s"
WARNING: %s signature detected on %s at offset %s. Wipe it? [y/n]: 
Failed to wipe %s signature on %s.
%d existing signature%s left on the device.
DASD disk (IBM S/390, zSeries)
User-mode virtual block device
Distributed Replicated Block Device (DRBD)
SUN's LDOM virtual block device
Storage Class Memory (IBM S/390)
Wiping %s signature on %s.
device/dev-luks.c
LUKS
cling_by_tags
next free
display/display.c
--- Physical Segments ---
Physical extent %u to %u:
  Logical volume	%s%s/%s
  Logical extents	%d to %d
  FREE
NEW 
 (exported)
(but full)
--- %sPhysical volume ---
PV Name               %s
VG Name               %s%s
PV Size               %s
Allocatable           yes %s
Allocatable           NO
PE Size               %s
PE Size (KByte)       %u
Total PE              %u
Free PE               %u
Allocated PE          %u
PV UUID               %s
NOT 
PV Name               %s     
Total PE / Free PE    %u / %u
read only
read/write
INACTIVE
--- Logical volume ---
LV Name                %s
Internal LV Name       %s
VG Name                %s
LV UUID                %s
LV Write Access        %s
LV Creation host, time %s, %s
LV Pool name           %s
LV Thin origin name    %s
LV External origin name %s
LV merging to          %s
LV merged with         %s
LV Pool metadata       %s
LV Pool data           %s
# open                 %u
LV Size                %s
Allocated pool data    %.2f%%
Allocated metadata     %.2f%%
Mapped size            %.2f%%
Current LE             %u
COW-table size         %s
COW-table LE           %u
Allocated to snapshot  %.2f%%
Snapshot chunk size    %s
Mirrored volumes       %u
Segments               %u
Allocation             %s
Read ahead sectors     auto
Read ahead sectors     0
Read ahead sectors     %u
- currently set to     %u
Persistent major       %d
Persistent minor       %d
Block device           %d:%d
Missing
%sPhysical volume	%s
%sPhysical extents	%d to %d
%sLogical volume	%s
%sLogical extents	%d to %d
%sUnassigned area
Virtual
Logical
--- Segments ---
%s extents %u to %u:
  Type		%s
  Monitoring		%s
exported/
--- Volume group ---
VG Name               %s
System ID             %s
Format                %s
Metadata Areas        %d
Metadata Sequence No  %d
Clustered             yes
Shared                %s
MAX LV                %u
Cur LV                %u
Open LV               %u
Max PV                %u
Cur PV                %u
Act PV                %u
VG Size               %s
Alloc PE / Size       %u / %s
Free  PE / Size       %u / %s
VG UUID               %s
Name is zero length.
NONE
Unrecognised allocation policy %s
Full LV name "%s/%s" is too long.
%s:%s:%lu:-1:%lu:%lu:-1:%u:%u:%u:%u:%s
PV Size               %s / not usable %s
PV Status             %sallocatable
%s%s/%s:%s:%lu:%d:-1:%d:%lu:%d:-1:%d:%d:%d:%d
read/write (activated read only)
LV Name                %s%s/%s
LV Path                %s%s/%s
LV snapshot status     source of
                       %s%s/%s [%s]
                       %s [%s]
LV snapshot status     %s destination for %s%s/%s
LV snapshot status     %s destination for %s
LV Status              suspended
LV Status              %savailable
LV type        Mirror undergoing conversion
VG Access             %s%s%s%s
VG Status             %s%sresizable
%s:%s:%lu:-1:%u:%u:%u:-1:%u:%u:%u:%lu:%u:%u:%u:%u:%s
"%s" %-9s [%-9s used / %s free]
Name cannot start with hyphen.
Name starts with . or .. and has no following character(s).
Name contains invalid character, valid set includes: [a-zA-Z0-9.-_+].
Name length exceeds maximum limit of %d.
Internal error: Unknown error %d on name validation.
contiguous
cling
cling_by_tags
normal
anywhere
inherit
erro
error/errseg.c
Initialised segtype: %s
error module string list allocation failed
Internal error: Destroying composite filter while in use %u times.
Composite filters allocation failed.
filters/filter-composite.c
Composite filter initialised.
Internal error: Destroying persistent filter while in use %u times.
Wiping cache of LVM-capable devices
Failed to hash device to filter.
Failed to hash alias to filter.
Obtaining device list from udev. Removing obsolete %s.
persistent_filter_cache/valid_devices
Couldn't find %s array in '%s'
Devices array contains a value which is not a string ... ignoring
Couldn't add '%s' to filter ... ignoring
Loaded persistent filter cache from %s
Internal persistent device cache empty - not writing to %s
Device cache incomplete - not writing to %s
Dumping persistent device cache to %s
# This file is automatically maintained by lvm.
Allocation of persistent filter failed.
Filename duplication for persistent filter failed.
Couldn't create hash table for persistent filter.
Allocation of device filter for persistent filter failed.
Persistent filter initialised.
filters/filter-persistent.c
%s: Skipping (cached)
valid_devices
	%s=[
		"%s"
unlink
%s: stat failed: %s
fstat
%s.tmp
persistent_filter_cache {
%s: rename to %s failed: %s
Internal error: Destroying regex filter while in use %u times.
Filter patterns must be enclosed in quotes.
pattern must begin with 'a' or 'r'
invalid separator at end of regex
filters/filter-regex.c
%s: Skipping (regex)
filter regex
filter dm_regex
Failed to allocate regex.
Failed to create bitset.
Regex filter initialised.
Invalid filter pattern "%s".
Internal error: Destroying sysfs filter while in use %u times.
sysfs path name too long: %s in %s
sysfs device file not correct format
No proc filesystem found: skipping sysfs filter
filters/filter-sysfs.c
Empty sysfs device file: %s
%u:%u
%s: Skipping (sysfs)
sysfs pool creation failed
Sysfs filter initialised.
sysfs dev_set creation failed
subsystem/block/devices
class/block
block
Internal error: Destroying md filter while in use %u times.
%s: Skipping md component device
%s: Skipping md component device [%s:%p]
%s: Skipping: error in md component detection
filters/filter-md.c
md filter allocation failed
MD filter initialised.
Internal error: Destroying firmware RAID filter while in use %u times.
%s: Firmware RAID detection is not supported by LVM natively. Skipping firmware raid detection. 
Internal error: Missing hook for firmware RAID recognition using external device info source %s
%s: Skipping firmware RAID component device
%s: Skipping firmware RAID component device [%s:%p]
Firmware RAID filter allocation failed
Firmware RAID filter initialised.
filters/filter-fwraid.c
ID_FS_TYPE
linux_raid_member
Internal error: Destroying mpath filter while in use %u times.
Sysfs path string is too long.
Cannot find device name in sysfs path.
%s: Device is a partition, using primary device %s for mpath component detection
Cannot find '/' in device name.
Failed to get primary device for %d:%d.
Sysfs path to check mpath is too long.
Failed to parse major minor from %s
Internal error: Missing hook for mpath recognition using external device info source %s
%s: Skipping mpath component device
%s: Skipping mpath component device [%s:%p]
No proc filesystem found: skipping multipath filter
mpath filter allocation failed
filters/filter-mpath.c
Device name is not valid.
%s/block/%s/holders
Path %s is not a directory.
mpath-
mpath_member
DM_MULTIPATH_DEVICE_PATH
mpath filter initialised.
Internal error: Destroying partitioned filter while in use %u times.
%s: Skipping: Partition table signature found
%s: Skipping: Partition table signature found [%s:%p]
Partitioned filter allocation failed
Partitioned filter initialised.
filters/filter-partitioned.c
Internal error: Destroying lvm_type filter while in use %u times.
%s: Skipping: Unrecognised LVM device type %lu
LVM type filter allocation failed
filters/filter-type.c
LVM type filter initialised.
Internal error: Destroying usable device filter while in use %u times.
%s: Skipping: dev_get_size failed
%s: Skipping: failed to get size from sysfs [%s:%p]
%s: Skipping: failed to parse size from sysfs [%s:%p]
Internal error: Missing hook for PV min size check using external device info source %s
Usable device filter allocation failed
Usable device filter mode allocation failed
Usable device filter initialised.
filters/filter-usable.c
%s: Skipping unusable device.
%s: Skipping: open failed
%s: Skipping: %s
Too small to hold a PV
%s: Skipping: %s [%s:%p]
*before*
*after*
Failed to allocate desc.
format_text/archiver.c
Created %s executing '%s'
Failed to build desc.
archive_params alloc failed
backup_params alloc failed
Couldn't copy archive directory name.
Test mode: Skipping archiving of volume group.
Archiving volume group "%s" metadata (seqno %u).
Volume group "%s" metadata archive failed.
Couldn't copy backup directory name.
Failed to generate backup filename (for removal).
Couldn't create text format object.
Failed to allocate format instance
Failed to duplicate empty name.
Format-specific setup for %s failed
Consider using option --force to restore Volume Group %s with thin volumes.
WARNING: Forced restore of Volume Group %s with thin volumes.
Cannot restore Volume Group %s with %i PVs marked as missing.
Failed to generate backup filename (for restore).
Creating volume group backup "%s" (seqno %u).
Couldn't create backup object.
Internal error: No in use metadata areas to write.
Failed to generate volume group metadata backup filename.
WARNING: This metadata update is NOT backed up
Test mode: Skipping backup of volume group.
Backup of volume group %s metadata failed.
Skipping check for current backup, since backup is disabled.
Failed to generate backup filename.
Internal error: problem tracking indentation
Doubling metadata output buffer to %u
# Generated by LVM2 version %s: %s
contents = "Text Format Volume Group"
creation_host = "%s"	# %s %s %s %s %s
creation_host_system_id = "%s"
Could not allocate memory for string list buffer.
pv device name size is out of bounds.
RAID segment has non-RAID areas
text_export buffer allocation failed
Could not format metadata for VG %s.
Error parsing metadata for VG %s.
format_text/export.c
uname failed: %s
Buffer reallocation failed.
Megabytes
Kilobytes
# %g %s
# Hint only
status = %s
flags = %s
version = %d
description = "%s"
creation_time = %lu	# %s
%s = %s
%s {
creation_host = "%s"
creation_time = %lu
lock_args = "%s"
allocation_policy = "%s"
profile = "%s"
read_ahead = -1
# None
read_ahead = %u
major = %d
minor = %d
segment_count = %u
segment%u {
start_extent = %u
extent_count = %u
physical_volumes {
device = "%s"
dev_size = %lu
pe_start = %lu
ba_start = %lu
ba_size = %lu
seqno = %u
format = "%s"
# informational
system_id = "%s"
lock_type = "%s"
extent_size = %u
max_lv = %u
max_pv = %u
metadata_copies = %u
text pv_names
pv%d
logical_volumes {
%ss = [
"%s", %u%s
"%s", "%s"%s
Gigabytes
Terabytes
Petabytes
Exabytes
P?Unknown flag set requested.
format_text/flags.c
Status value is not a string.
PARTIAL
Unknown status flag '%s'.
READ
WRITE
WRITE_LOCKED
FIXED_MINOR
VISIBLE
PVMOVE
NOTSYNCED
REBUILD
WRITEMOSTLY
ACTIVATION_SKIP
ERROR_WHEN_FULL
ALLOCATABLE
EXPORTED
MISSING
RESIZEABLE
CLUSTERED
SHARED
Internal error: Metadata inconsistency: Not all flags successfully exported.
format_text/format-text.c
Unlinking %s
Committing %s metadata (%u)
Renaming %s to %s
Test mode: Skipping rename
Read volume group %s from %s
pe_start
MDA1 start
ba_start
disk size
MDA0 end
label scan size
pe_end
ba_end
PV %s missing from cache
mda_context allocation failed
 LVM2 x[5A%r0N*>
start = %ld
ignore = %ld
free_sectors = %ld
Writing %s metadata to %s
fsync
Pre-
VG %s metadata writing failed
pre-commit 
VG %s not found on %s
Name too long %s/%s
Using cached
Found
text
Failed to allocate dir_list
_add_dir allocation failed
Couldn't find device.
_add_raw allocation failed
text_orphan
Initialised format: %s
Test mode: Skipping committing %s metadata (%u)
'%s' does not contain volume group '%s'.
Creating metadata area on %s at sector %lu size %lu sectors
Internal error: can't remove metadata area with index %u from PV %s. Metadata layou not supported by %s format.
Internal error: invalid index of value %u used while trying to add metadata area on PV %s. Metadata layout not supported by %s format.
Internal error: metadata area with index %u already exists on PV %s and removal failed.
Using limited metadata area size on %s with value %lu (limited by %s of %lu).
Failed to wipe new metadata area at the %s of the %s
struct metadata_area allocation failed
struct mda_context allocation failed
Not enough space available for metadata area with index %u on PV %s.
Failed to move metadata area with index 1 while resizing PV %s.
PV %s too large for extent size %s.
%s: invalid data alignment of %lu sectors (requested %lu sectors)
%s: invalid data alignment offset of %lu sectors (requested %lu sectors)
%s: pe_align (%lu sectors) must not be less than pe_align_offset (%lu sectors)
%s: Data alignment must not exceed device size.
%s: Bootloader area with data-aligned start must not exceed device size.
%s: Bootloader area would overlap data area.
Physical extents end beyond end of device %s.
%s: Volume group filename may not end in .tmp
Couldn't allocate text format context object.
Incorrect metadata area header checksum on %s at offset %lu
Wrong magic number in metadata area header on %s at offset %lu
Incompatible metadata area header version: %d on %s at offset %lu
Incorrect start sector in metadata area header: %lu on %s at offset %lu
Text format failed to determine directory.
Couldn't create temporary text file name.
Failed to write metadata to %s.
Volume group name found in metadata does not match expected name %s.
Random lvid creation failed for %s/%s.
struct mda_header allocation failed
Found text metadata area: offset=%lu, size=%lu
Found LVM2 metadata record at offset=%lu, size=%zu, offset2=%lu size2=%zu
Failed to write metadata area header
%sCommitting %s metadata (%u) to %s header at %lu
Wiping pre-committed %s metadata from %s header at %lu
VG %s metadata too large for circular buffer
Writing %s metadata to %s at %lu len %lu
Writing metadata to %s at %lu len %lu
Read %s %smetadata (%u) from %s at %lu size %lu
Skipped reading %smetadata from %s at %lu size %lu with matching checksum.
Couldn't allocate text_fid_context.
Couldn't create metadata index for format instance of VG %s.
Internal error: vgname_from_mda called with NULL pointer for mda_header
%s: found metadata with offset 0.
%s: metadata too large for circular buffer
%s: %s metadata at %lu size %lu (in area at %lu size %lu) for %s (%s)
Failed to allocate text format type structure.
Couldn't create text label handler.
Couldn't register text label handler.
Invalid string in config file: metadata/dirs
Adding text format metadata dir: %s
Empty metadata disk_area section of config file
Missing start_sector in metadata disk_area section of config file
Missing size in metadata disk_area section of config file
Missing uuid in metadata disk_area section of config file
Invalid uuid in metadata disk_area section of config file: %s
Couldn't find device with uuid '%s'.
Failed to add %s to text format metadata directory list 
format_text/import.c
There are %d physical volumes missing.
Couldn't read volume group metadata.
Failed to allocate VG fmtdata for text format.
status
Could not find status flags.
format_text/import_vsn1.c
Could not read status flags.
Could not read flags.
description
creation_time
Couldn't find section '%s'.
Empty logical volume section.
creation_host
allocation_policy
read_ahead
contents
missing contents field
Text Format Volume Group
unrecognised contents field
missing version number
unrecognised version number
Couldn't find uuid.
Invalid uuid.
lock_type
seqno
max_lv
max_pv
metadata_copies
logical_volumes
Empty pv section.
dev_size
ba_size
%s: Couldn't get size.
Empty segment section.
start_extent
extent_count
Segment allocation failed
_mimagetmp
segment_count
NULL
Found an item that is not a string
Couldn't read status flags for logical volume %s.
Invalid creation_time for logical volume %s.
Couldn't read creation_host for logical volume %s.
Missing creation_time for logical volume %s.
WARNING: Ignoring unrecognised allocation policy %s for LV %s
Adding profile configuration %s for LV %s/%s.
Failed to add configuration profile %s for LV %s/%s
Couldn't read tags for logical volume %s/%s.
Couldn't use another pool metadata spare logical volume %s/%s.
Logical volume %s is pool metadata spare.
Logical volume %s is sanlock lv.
Can't process text format file - %s.
Couldn't create pv hash table.
Couldn't create lv hash table.
Unrecognised format %s for volume group %s.
Couldn't read uuid for volume group %s.
Couldn't read 'seqno' for volume group %s.
Error reading flags of volume group %s.
Failed to allocate memory for system_id in _read_vg.
Couldn't read extent size for volume group %s.
Couldn't read 'max_lv' for volume group %s.
Couldn't read 'max_pv' for volume group %s.
WARNING: Ignoring unrecognised allocation policy %s for VG %s
Adding profile configuration %s for VG %s.
Failed to add configuration profile %s for VG %s
Couldn't find all physical volumes for volume group %s.
Internal error: Unexpected outdated_pvs section in metadata of VG %s.
Couldn't read tags for volume group %s.
Couldn't read all logical volume names for volume group %s.
Couldn't read all logical volumes for volume group %s.
Failed to fixup mirror pointers after import for volume group %s.
Couldn't find volume group in file.
Couldn't read uuid for physical volume.
Couldn't read status flags for physical volume.
Recovering a previously MISSING PV %s with no MDAs.
Couldn't read dev size for physical volume.
Couldn't read extent start value (pe_start) for physical volume.
Couldn't find extent count (pe_count) for physical volume.
Found bootloader area specification for PV %s in metadata: ba_start=%lu, ba_size=%lu.
Found incomplete bootloader area specification for PV %s in metadata.
Couldn't read tags for physical volume %s in %s.
Fixing up missing size (%s) for PV %s
WARNING: Physical Volume %s is too large for underlying device
Lost logical volume reference %s
Couldn't read uuid for logical volume %s.
Couldn't read 'start_extent' for segment '%s' of logical volume %s.
Couldn't read 'extent_count' for segment '%s' of logical volume %s.
Segment type must be a string.
Couldn't read tags for a segment of %s/%s.
Only one segment permitted for snapshot
Couldn't read segment count for logical volume %s.
segment_count and actual number of segments disagree for logical volume %s.
Couldn't read minor number for logical volume %s.
WARNING: Couldn't read major number for logical volume %s.
WARNING: Ignoring invalid major, minor number for logical volume %s.
Couldn't find status flags for volume group %s.
Bad volume name in areas array for segment %s.
Missing offset in areas array for segment %s.
Bad offset in areas array for segment %s.
Zero areas not allowed for segment %s
Couldn't find volume '%s' for segment '%s'.
Incorrect number of areas in area array for segment '%s'.
format_text/text_label.c
 mda1 (
 da1 (
 ba1 (
 mda2 (
LVM2 001
%s: PV header extension version %u found
Ignoring mda on device %s at offset %lu
%s: Preparing PV label header %s size %lu with%s%.*lu%s%.*lu%s%s%.*lu%s%.*lu%s%s%.*lu%s%.*lu%s%s%.*lu%s%.*lu%s
Internal error: %s label header currently requires a data area.
struct data_area_list allocation failed
struct mda_list allocation failed
Couldn't allocate labeller object.
label/label.c
%s: Failed to read label area
LABELONE
%s: No label detected
Using cached label for %s
Failed to write label to %s
label allocaction failed
Ignoring additional label on %s at sector %lu
%s: Label for sector %lu found at sector %lu - ignoring
Label checksum incorrect on %s - ignoring
%s: %s label detected at sector %lu
Couldn't allocate memory for labeller list object.
Scanning for labels to wipe from %s
Failed to remove label from %s at sector %lu
%s: Wiping label at sector %lu
Label handler does not support label writes
Label sector %lu beyond range (%ld)
%s: Writing label to sector %lu with stored offset %u.
locking for suspend
locking/locking.c
unlocking on resume
%s/lvm/VGs/%s
Non-blocking 
External locking selected.
Cluster locking selected.
Unrecognised lock scope: %d
Failed to suspend %s
Failed to activate %s
#sync_names
Internal error: Use of P_orphans is deprecated.
Internal error: P_%s referenced
Operation prohibited while global/metadata_read_only is set.
LVM1 proc VG pathname too long for %s
%s exists: Is the original LVM driver using this volume group?
LVM_SUPPRESS_LOCKING_FAILURE_MESSAGES
WARNING: Locking disabled. Be careful! This could corrupt your metadata.
%sFile-based locking selected.
File-based locking initialisation failed.
External locking initialisation failed.
Falling back to internal clustered locking.
Internal cluster locking initialisation failed.
Read-only locking selected. Only read operations permitted.
Locking disabled for read-only access.
Unknown locking type requested.
Locking disabled - only read operations permitted.
WARNING: Falling back to local file-based locking.
Volume Groups with the clustered attribute will be inaccessible.
Internal error: %s: LCK_NONE lock requested
_lock_vol
Locking is disabled: Treating lock %s as not held.
Read-only locking type set. Write locks are prohibited.
locking/no_locking.c
activate_log file
failed to write log file: %s
failed to write log file
DM_ABORT_ON_INTERNAL_ERRORS
Internal error: 
log/log.c
#%s:%d 
%s:%d %s%s
LVM_LOG_FILE_EPOCH
%s_%s_%d_%lld
LVM_EXPECTED_EXIT_STATUS
vsnprintf failed: skipping external logging function
WARNING: Ignoring invalid LVM_LOG_FILE_EPOCH envvar "%s".
%d %*s %*c %*d %*d %*d %*d %*d %*u %*u %*u %*u %*u %*u %*u %*d %*d %*d %*d %*d %*d %llu
WARNING: Cannot parse content of %s.
WARNING: Debug log file path is too long for epoch.
/proc/self/stat
writeback
passthrough
metadata/cache_manip.c
another LV
_corig
cleaner
Flushing cache for %s.
Internal error: LV %s has uknown feature flags %lu.
Cannot set unknown cache mode "%s".
WARNING: Maximum supported pool metadata size is %s.
WARNING: Minimum required pool metadata size is %s (needs extra %s).
Cannot use locked cache pool %s.
Logical volume %s is already in use by %s
Cannot use locked origin volume %s.
Cache is not supported with %s segment type of the original logical volume %s.
Internal error: LV %s is not cache volume.
Internal error: LV %s is already dropped cache volume.
Cannot deactivate remotely active cache lv.
Failed to active cache locally %s.
%lu blocks must still be flushed.
Failed to duplicate policy name.
WARNING: Cannot detect default cache policy, using "mq".
Default cache policy is not available.
Detected default cache_policy "%s".
Internal error: Can't set policy settings without policy name.
Internal error: Failed to wipe cache pool for volume %s.
Aborting. Failed to activate cache pool %s.
Aborting. Failed to wipe cache pool %s.
Aborting. Could not deactivate cache pool %s.
unassigned
dm_pool_begin_object failed
metadata/lv.c
dm_pool_grow_object failed
%s%u%s
not monitored
lvfullname snprintf failed
dm_pool_alloc failed
lvpath snprintf failed
dm_build_dm_name failed
lv_dmpath snprintf failed
Failed to duplicate hostname
Thin volume "%s" is active.
remote exclusive
local exclusive
Internal error: Unknown area segtype.
Extent number dm_snprintf failed
modules str_list allocation failed
Internal error: Bad pvmove structure
Internal error: Cannot find mirror segment.
Internal error: %s is not a RAID image
Failed to find RAID segment for %s
%s on %s is not a RAID segment
Internal error: sub-LV %s was not found in raid segment
Internal error: %s is not of RAID type
Failed to lock logical volume %s/%s
Deactivating logical volume "%s"
Cannot deactivate remotely exclusive device locally.
Deactivating logical volume "%s" locally.
Activating logical volume "%s" exclusively locally.
Activating logical volume "%s" locally.
Activating logical volume "%s" exclusively.
Activating logical volume "%s".
Failed to unlock logical volume %s/%s
metadata/lv_manip.c
Failed to allocate memory
  %s/%s uses %s
Failed to create new name
Cannot rename locked LV %s
Changing   
 with PV tags: 
Considering
fsadm
--dry-run
%luK
pv_list allocation failed
raid4
raid5
raid5_la
raid5_ra
raid5_ls
raid5_rs
raid6
raid6_zr
raid6_nr
raid6_nc
sparse
multithinorigin
thinsnapshot
multiextthinorigin
cacheorigin
virtual
multithickorigin
thicksnapshot
public
private
Adding %s:%u as an user of %s
Stack %s:%u[%u] on LV %s:%u
Internal error: Meta le != 0
Failed to suspend %s.
Failed to reactivate %s.
up to 
contiguous 
Cling_to_allocated is %sset
  %u %s%s of %u extents each
Sorting %u log areas
Sorting %u areas
%s is %son %s
physical
logical
at most 
Can't resize locked LV %s
Extending %u mirror images.
Using default stripesize %s
New size of 0 not permitted
Invalid stripe size %s
Creating logical volume %s
LV %s in VG %s is now hidden.
Conflicting region_size
 and DISCARD
Can't remove locked LV %s
Logical volume %s not removed
Failed to uncache %s.
Failed to update pool %s.
Removing snapshot %s
Releasing logical volume "%s"
Failed to resume %s.
external origin
Layer segment found: %s:%u
Layer is not linear: %s:%u
Missing error segtype
lv_list alloc failed
Can't move snapshot segment.
Removing layer %s for %s
Failed to find layer %s in %s
_mimage
Creation of layer LV failed
Inserting layer %s for %s
_mimage_0
Inserting %s:%u-%u of %s/%s
No meta_areas for RAID type
Failed to extend %s in %s.
Failed to zero %s/%s
Failed to deactivate %s/%s
rimage
%s_%s_%u
%s_%s
%s_rmeta_%u
Failed to insert layer for %s
 and open
Reduc
Extend
lv_info failed: aborting
Logical volume %s NOT reduced
Filesystem check failed.
Filesystem resize failed.
Failed to activate %s.
Problem deactivating %s.
metadata 
lvol%d
snapshot exception store
start of new LV
Cache pool is prepared.
Failed to activate thin %s.
Failed to activate new LV.
Aborting. Failed to wipe %s.
%s_vorigin
Logical volume "%s" created.
Cannot rename "%s": name format not recognized for internal LV "%s"
Failed to allocate space for new name
Cannot rename "%s". New logical volume name "%s" is invalid.
Logical volume "%s" already exists in volume group "%s"
Failed to lock logical volume %s.
Updating logical volume %s in kernel.
Problem reactivating logical volume %s.
WARNING: Logical volume %s not zeroed.
Signature wiping on logical volume %s not requested.
PV tags string allocation failed
WARNING: Ignoring invalid string in config file entry allocation/cling_tag_list
WARNING: Ignoring empty string in config file entry allocation/cling_tag_list
WARNING: Ignoring string not starting with @ in config file entry allocation/cling_tag_list: %s
WARNING: Ignoring empty tag in config file entry allocation/cling_tag_list
PV tags string extension failed.
Matched allocation PV tag %s on existing %s with free space on %s.
Eliminating allocation area %u at PV %s start PE %u from consideration: PV tag %s already used.
Memory reallocation for parallel areas failed.
%s allocation area %u %s %s start PE %u length %u leaving %u%s%s.
Couldn't create LV path for %s
Couldn't generate new LV size string
Failed to find segment for %s extent %u
LV layout list allocation failed
LV role list allocation failed
Internal error: WARNING: Failed to properly detect layout and role for LV %s/%s.
Overriding default 'mirror_region_size' setting with 'raid_region_size' setting of %u kiB
Reducing mirror region size to %u kiB (power of 2).
Failed to allocate segment list
%s:%u is no longer a user of %s
Internal error: Segment %s:%u is not a user of %s.
Internal error: get_only_segment_using_this_lv() called with NULL LV.
%s is expected to have only one segment using it, while %s:%u uses it %d times.
%s is expected to have only one segment using it, while it has %d.
Internal error: alloc_lv_segment: Missing segtype.
Failed to find snapshot segtype
Couldn't allocate new snapshot segment.
Refusing refresh of partial LV %s. Use '--activationmode partial' to override.
Couldn't allocate new %s segment.
allocate_extents does not handle virtual segments
Internal error: Missing allocatable pvs.
Metadata format (%s) does not support required LV segment type (%s).
Consider changing the metadata format by running vgconvert.
allocation handle allocation failed
Internal error: _alloc_init called for non-virtual segment with no disk space.
allocation pool creation failed
Internal error: Bad metadata_area_count
Adjusted allocation request to %u logical extents. Existing size %u. New size %u.
_allocate called with no work to do!
Number of extents requested (%d) needs to be divisible by %d.
Parallel PVs at LE %u length %u: %s
Not enough PVs with free space available for parallel allocation.
Consider --alloc anywhere if desperate.
Couldn't allocate areas array.
Trying allocation using %s policy.
Insufficient free space: %u extents needed, but only %u available
%u preferred area(s) to be filled positionally.
Areas to be sorted and filled sequentially.
Still need %s%u total extents from %u remaining (%u positional slots):
  %u (%u data/%u parity) parallel areas of %u extents each
Found %u areas for %u parallel areas and %u log areas so far.
Filled %u out of %u preferred areas so far.
Internal error: _alloc_parallel_area called without any allocation to do.
alloced_area allocation failed
Allocating parallel metadata area %u on %s start PE %u length %u.
Allocating parallel area %u on %s start PE %u length %u.
Insufficient suitable %sallocatable extents for logical volume %s: %u more required
Insufficient suitable %sallocatable extents found for logical volume %s.
Found fewer %sallocatable extents for logical volume %s than requested: using %u extents (reduced by %u).
Insufficient free space for log allocation for logical volume %s.
Missing segtype in lv_add_segment().
lv_add_segment cannot handle virtual segments
Log segments can only be added to an empty LV
Couldn't allocate new LV segment.
Couldn't merge segments after extending logical volume.
Internal error: for_each_sub_lv failure.
Generating list of PVs that %s/%s uses:
Cannot resize external origin "%s".
Cannot resize a RAID %s directly
Cannot resize %s while it is tracking a split image
Varied striping not supported. Ignoring.
Mirrors not supported. Ignoring.
Stripe size cannot be larger than %s
Varied stripesize not supported. Ignoring.
Reducing stripe size %s to maximum, physical extent size %s
Stripe size must be power of 2
Policy-based resize is supported only for snapshot and thin pool volumes.
Can't resize internal logical volume %s
Can't resize %s while lvconvert in progress
--poolmetadatasize can be used only with thin pools.
Online metadata resize for %s/%s is not supported.
Rounding size to boundary between physical extents: %s
Specified LV does not have an origin LV.
Converted %u%%%s into %s%u %s extents.
VolumeType does not match (%s)
Cannot vary number of mirrors in LV yet.
Please specify number of stripes (-i) and stripesize (-I)
Unable to extend "%s" segment type with different number of stripes.
Using stripesize of last segment %s
Ignoring stripes, stripesize and mirrors arguments when reducing.
Unable to reduce %s below 1 extent.
Stripesize for striped segment should not be 0!
Unable to extend %s by %u logical extents: exceeds limit (%u).
Reached maximum COW size %s (%u extents).
New size (%d extents) matches existing size (%d extents)
Rounding size (%d extents) up to stripe boundary size for segment (%d extents)
Rounding size (%d extents) down to stripe boundary size for segment (%d extents)
New size given (%d extents) not larger than existing size (%d extents)
New size given (%d extents) not less than existing size (%d extents)
New size for %s: %u. Existing logical extents: %u / physical extents: %u.
Snapshot origin volumes cannot be reduced in size yet.
Snapshot origin volumes can be resized only while inactive: try lvchange -an
Thin pool volumes cannot be reduced in size yet.
Thin pool metadata volumes cannot be reduced.
Thin target does not support external origin smaller then thin volume.
Support for online metadata resize not detected.
Rounding pool metadata size to boundary between physical extents: %s
Unable to extend %s by %u extents, exceeds limit (%u).
Rounding size to maximum supported size 16GiB for metadata volume %s.
Metadata volume %s has already %s.
Maximum number of logical volumes (%u) reached in volume group %s
Unable to allocate logical volume structure
parallel_areas allocation failed
Failed to generate unique name for the new logical volume
Unable to create LV %s in Volume Group %s: name already in use.
Dropping snapshot merge of %s to removed origin %s.
Dropping snapshot merge of removed %s to origin %s.
Segment extent reduction %u not divisible by #stripes %u
Unable to reduce RAID LV - operation not implemented.
Failed to remove RAID image %s
Failed to remove RAID meta-device %s
Remove %s:%u[%u] from the top of LV %s:%u
Can't convert non-striped segment to mirrored.
Can't convert striped segment with multiple areas to mirrored.
Couldn't allocate converted LV segment
Failed to split segment at %s extent %u
LV %s in VG %s is now visible.
Mirror layer must be inserted before adding mirrors
Failed to allocate widened LV segment for %s.
Can't remove logical volume "%s" under snapshot
Can't remove external origin logical volume "%s".
Can't remove logical volume %s used by a mirror
Can't remove logical volume %s used as mirror log
Can't remove logical volume %s used as RAID device
Can't remove logical volume %s used by a pool.
Do you really want to remove%s active %slogical volume %s? [y/n]: 
Do you really want to remove and DISCARD logical volume %s? [y/n]: 
Ignoring uncache failure of %s.
Unable to deactivate logical volume %s.
Ignoring update failure of pool %s.
Error releasing logical volume %s with pending delete.
Error releasing logical volume "%s"
Unable to deactivate spare logical volume %s.
WARNING: Support for snapshots with old LVM1-style metadata is deprecated.
WARNING: Please use lvconvert to update to lvm2 metadata at your convenience.
Failed to refresh %s without snapshot.
Logical volume "%s" successfully removed
Failed to obtain merging snapshot progress percentage for logical volume %s.
Can't remove merging snapshot logical volume "%s"
Removing snapshot "%s" that failed to merge may leave origin "%s" inconsistent. Proceed? [y/n]: 
Removing origin %s will also remove %u snapshots(s). Proceed? [y/n]: 
Unable to fully deactivate merging origin "%s".
Unable to remove merging origin "%s".
Unable to remove "%s", volume is merged to "%s".
Removal of pool metadata spare logical volume "%s" disables automatic recovery attempts after damage to a thin or cache pool. Proceed? [y/n]: 
Logical volume "%s" not removed.
Removing %s "%s" will remove %u dependent volume(s). Proceed? [y/n]: 
Cannot rename internal LV "%s".
Failed to allocate space for new name.
Incompatible layer boundary: %s:%u[%u] on %s:%u
layer segment for %s:%u not found
Removing layer %s for segments of %s
Layer status does not match: %s:%u status: 0x%lx/0x%lx
Layer boundary mismatch: %s:%u-%u on %s:%u / %u-%u / 
Internal error: Wrong layer %s in %s
Layered name is too long. Please use shorter LV name.
Creating transient LV %s for mirror conversion in VG %s.
Creation of transient LV %s for mirror conversion in VG %s failed.
Aborting.  Unable to tag transient mirror layer.
Failed to write intermediate VG %s metadata for mirror conversion.
Failed to commit intermediate VG %s metadata for mirror conversion.
Failed to resume transient LV %s for mirror conversion in VG %s.
Internal error: Non-pvmove LV, %s, passed as argument
Internal error: Bad segment type for first segment area
Failed to build pvmove LV-type mirror, %s
Inserting layer %s for segments of %s on %s
Matched PE range %s:%u-%u against %s %u len %u
Failed to insert segment in layer LV %s under %s:%u-%u
Failed to sync local devices before wiping LV %s.
Volume "%s/%s" is not active locally.
Name too long - device not cleared (%s)
%s: not found: device not cleared
Wiping known signatures on logical volume "%s/%s"
Initializing %s of logical volume "%s/%s" with value %d.
Aborting. Failed to extend %s in %s.
Failed to activate %s/%s for clearing
Clearing metadata area of %s/%s
Adjusting RAID region_size from %uS to %uS to support large LV size
Adding segment of type %s to LV %s.
Internal error: Non-empty LV passed to _lv_insert_empty_sublv
Failed to create mapping segment for %s
%s/%s is not active locally.  Unable to get sync percent.
Do full resync of extended portion of %s/%s?  [y/n]: 
Failed to get sync percent for %s/%s
Skipping initial resync for extended portion of %s/%s
%s/%s cannot be extended while it is recovering.
Unable to resize logical volumes of cache type.
Ignoring --resizefs as thin pool volumes do not have filesystem.
Ignoring PVs on command line when reducing.
Logical volume %s must be activated before resizing filesystem
WARNING: Reducing active%s logical volume to %s
THIS MAY DESTROY YOUR DATA (filesystem etc.)
Do you really want to reduce %s? [y/n]: 
%sing logical volume %s to %s%s
Size of logical volume %s unchanged from %s (%u extents).
Size of logical volume %s changed from %s (%u extents) to %s (%u extents).
Logical volume %s successfully resized.
Extending logical volume %s to %s.
ACTIVATION_SKIP flag set for LV %s/%s, skipping activation.
Metadata does not support %s segments.
Volume group %s does not support tags.
Stripe size may not exceed %s.
Can't create %s without using device-mapper kernel driver.
Can't wipe start of new LV without using device-mapper kernel driver.
The extent size in volume group %s is too small to support striped RAID volumes.
Reducing requested stripe size %s to maximum, physical extent size %s.
Rounding size (%d extents) up to stripe boundary size (%d extents).
Internal error: Unable to create new logical volume with no extents.
Unable to create %s smaller than 1 chunk.
Number of stripes (%u) must not exceed number of physical volumes (%d)
Internal error: Cannot create %s volume without %s pool.
Couldn't find volume %s in Volume group %s.
Cannot use locked pool volume %s.
Rounding size (%d extents) up to chunk boundary size (%d extents).
Origin volume %s not found in Volume group %s.
Caching of origin cache volume smaller then chunk size is unsupported.
Cannot cache not exclusively active origin volume %s.
Internal error: Pool LV for cache is missing.
WARNING: New %s won't be synchronised. Don't read what you didn't write!
Snapshots of locked devices are not supported.
Cannot use writable LV as the external origin.
Cannot use active LV for the external origin.
Can't share virtual origins. Use --virtualsize.
Snapshots of snapshots are not supported yet.
Snapshots of an origin that has a merging snapshot is not supported
Snapshots of cache type volume %s is not supported.
Snapshots of thin pool %sdevices are not supported.
WARNING: Snapshots of mirrors can deadlock under rare device failures.
WARNING: Consider using the raid1 mirror type to avoid this.
WARNING: See global/mirror_segtype_default in lvm.conf.
%s must be active exclusively to create snapshot
Volume group "%s" has insufficient free space (%u extents): %u required.
Setting read ahead sectors %u.
Setting device number to (%d, %d).
Test mode: Skipping activation, zeroing and signature wiping.
Aborting. Failed to activate LV %s locally exclusively.
Failed to suspend thin snapshot origin %s/%s.
Failed to resume thin snapshot origin %s/%s.
Failed to activate thin pool %s.
Cannot activate thin pool %s, perhaps skipped in lvm.conf volume_list?
Failed to deactivate thin pool %s.
Aborting. Failed to activate snapshot exception store.
Aborting. Leaving cache pool %s and uncached origin volume %s.
Aborting. Manual intervention required.
Aborting. Couldn't deactivate snapshot COW area %s.
Failed to sync local devices before creating snapshot using %s.
Zero segment type for virtual origin not found
Virtual origin name is too long.
Failed to activate sparce volume %s.
Unable to deactivate failed new LV %s. Manual intervention required.
Internal error: Unsupported creation of cache and cache pool volume.
Internal error: Logical volume is not cache %s.
Internal error: Creation of pool for unsupported segment type %s.
Temporary logical volume "%s" created.
_tdata
_cdata
_corig
_tdata
_cdata
_corig
LV %s is thin volume without exactly one segment.
LV %s is thin volume without first thin volume segment.
LV %s is thin pool volume without exactly one segment.
LV %s is thin pool without first thin pool segment.
LV %s: segment 1 pool data LV does not point back to same LV
LV %s: segment 1 pool metadata LV does not point back to same LV
LV %s invalid: segment %u should begin at LE %u (found %u).
LV %s: segment %u has inconsistent area_len %u
LV %s: segment %u (%s) does not support flag ERROR_WHEN_FULL.
LV %s: segment %u log LV %s is not a mirror log or a RAID image
LV %s: segment %u log LV %s is not a mirror log
LV %s: segment %u log LV does not point back to mirror segment
LV %s: segment %u mirror image is not mirrored
LV %s is missing thin pool flag for segment %u
LV %s is a thin volume that must not contain thin pool segment %u
LV %s has invalid cache's feature flag.
LV %s is missing cache policy name.
LV %s: %s segment %u is missing a pool data LV
LV %s: %s segment %u data LV does not refer back to pool LV
LV %s: %s segment %u is missing a pool metadata LV
LV %s: %s segment %u metadata LV does not refer back to pool LV
LV %s: %s segment %u has invalid chunk size %u.
LV %s: segment %u must not have pool metadata LV set
LV %s is missing thin volume flag for segment %u
LV %s is a thin pool that must not contain thin volume segment %u
LV %s: segment %u is missing thin pool LV
LV %s: thin volume segment %u pool LV is not flagged as a pool LV
LV %s: thin volume segment %u has too large device id %u
LV %s: external origin %s is writable.
LV %s: thin volume segment %u merging LV %s is not flagged as a thin LV
LV %s: merging LV %s is not flagged as merging.
LV %s is missing cache flag for segment %u
LV %s: segment %u is missing cache_pool LV
LV %s: segment %u must not have pool LV set
LV %s: segment %u has same LV %s for both origin and snapshot
LV %s: segment %u has unassigned area %u.
LV %s: segment %u has inconsistent PV area %u
LV %s: segment %u has inconsistent LV area %u
LV %s: segment %u mirror image %u missing mirror ptr
LV %s segment %u uses LV %s, but missing ptr from %s to %s
LV %s has duplicated links to LV %s segment %u
LV %s: mirrored LV segment %u has wrong size %u (should be %u).
LV %s is used by LV %s:%u-%u, but missing ptr from %s to %s
Reference count mismatch: LV %s has %u links to LV %s:%u-%u, which has %u links
LV %s: inconsistent LE count %u != %u
LV segment %s:%u-%u is incorrectly listed as being used by LV %s
Segment with extent %u in LV %s not found
Unable to split the %s segment at LE %u in LV %s
Couldn't allocate cloned LV segment.
LV segment tags duplication failed
Split %s:%u[%u] at %u: %s LE %u
Split %s:%u[%u] at %u: %s PE %u
Unassigned area %u found in segment
metadata/merge.c
Skipping clustered volume group %s
Volume group %s is not resizeable.
Internal error: Referenced LV %s not listed in VG %s.
Internal error: Referenced PV %s not listed in VG %s.
Internal error: Invalid character at index %d of lock_args "%s"
Internal error: Invalid colon at index %d of lock_args "%s"
Failed to allocate bitset for setting random bits.
dm_pool_begin_object failed for random list of bits.
Failed to generate list of random bits.
Failed to finish list of random bits.
Selected %u random bits from %u: %s
Failed to allocate pv structure.
Missing device %s reappeared, updating metadata for VG %s to version %u.
Device still marked missing because of allocated data on it, remove volumes and consider vgreduce --removemissing.
%s: Setting PE alignment to %lu sectors.
%s: Setting PE alignment offset to %lu sectors.
New volume group name "%s" is invalid.
%s: already exists in filesystem
New volume group path exceeds maximum length of %d!
Old and new volume group names must differ
vg->name allocation failed for '%s'
pv->vg_name allocation failed for '%s'
Physical extent size used for volume group %s is less than physical block size that %s uses.
Logical volume %s/%s does not support tags
Failed to duplicate tag %s from %s/%s
Volume group %s does not support tags
Failed to duplicate tag %s from %s
Failed to add tag %s to volume group %s
Major number %d outside range 0-255.
Minor number %d outside range 0-255.
Major number %d outside range 0-4095.
Ignoring supplied major %d number - kernel assigns major numbers dynamically.
Minor number %d outside range 0-1048575.
Volume Group allocation policy cannot inherit from anything
Physical extent size may not be zero
Number of volumes may not exceed 255
Rounding up size to full physical extent %s
Volume too large (%s) for extent size %s. Upper limit is %s.
Specified size is smaller then physical extent boundary.
Rounding size to boundary between physical extents: %s.
No free extents in the list of physical volumes.
No free extents in Volume group %s.
Converted  %.2f%%%s into 0 extents.
Converted %.2f%%%s into %u extents.
Physical volume %s not in volume group %s.
Unable to remove physical volume '%s' from volume group '%s'.
Internal error: Read ahead data missing.
Logical volumes in "%s" must be inactive
Extent sizes differ: %d (%s) and %d (%s)
Maximum number of physical volumes (%d) exceeded  for "%s" and "%s"
Maximum number of logical volumes (%d) exceeded  for "%s" and "%s"
Metadata types differ for "%s" and "%s"
Clustered attribute differs for "%s" and "%s"
Duplicate logical volume name "%s" in "%s" and "%s"
Physical volume %s might be constructed from same volume group %s.
Calculated readahead of LV %s is %u
Attempt to drop cached metadata failed after reverted update for VG %s.
Format does not support writing physical volumes
Assertion failed: can't _pv_write non-orphan PV (in VG %s)
Removing physical volume "%s" from volume group "%s"
Failed to remove physical volume "%s" from volume group "%s"
Volume group "%s" successfully removed
Volume group "%s" not properly removed
%s not opened: device not zeroed
Failed to clear metadata from physical volume "%s" after removal from "%s"
WARNING: Removing PV %s (%s) that no longer belongs to VG %s
Unable to drop cached metadata for VG %s while wiping outdated PVs.
Device %s not found (or ignored by filtering).
Could not find LVM label on %s
Found label on %s, sector %lu, type=%.8s
Attempt to modify a read-only VG
Volume group "%s" not found, is inconsistent or has PVs missing.
Consider vgreduce --removemissing if metadata is inconsistent.
Volume group "%s" still contains %u logical volume(s)
Couldn't allocate format_instance object.
Adding physical volume '%s' to volume group '%s'
pv_list allocation for '%s' failed
Physical volume '%s' is already in volume group '%s'
Physical volume %s is of different format type (%s)
Physical volume %s might be constructed from same volume group %s
Format-specific setup of physical volume '%s' failed.
Physical volume '%s (%s)' already in the VG.
No space for '%s' - volume group '%s' holds max %d physical volume(s).
Unable to add %s to %s: new extent count (%lu) exceeds limit (%u).
pv_to_create allocation for '%s' failed
Failed to create random uuid for %s.
WARNING: %s: Overriding real size. You could lose data.
%s: Pretending size is %lu sectors.
%s: Size must exceed minimum of %lu sectors.
pv_list allocation in pv_create failed
Format-specific initialisation of physical volume %s failed.
Failed to add metadata area for new physical volume %s
Physical volume %s not in volume group %s
Logical volume %s not in volume group %s
No physical volume found in lvmetad cache for %s
No cache info in lvmetad cache for %s.
No physical volume label read from %s
Failed to read existing physical volume '%s'
Couldn't create uuid for volume group '%s'.
Failed to create format instance
Format specific setup of volume group '%s' failed.
metadata_area allocation failed
Internal error: Attempt to write new VG metadata without locking %s
Attempt to drop cached metadata failed after commit for VG %s.
%s ignored flag for mda %s at offset %lu.
Adjusting ignored mdas for %s: %u of %u mdas in use but %u required.  Changing %u mda.
Internal error: Unable to find %u metadata areas to unignore on volume group %s
Metadata areas on physical volume "%s" already ignored.
Metadata areas on physical volume "%s" already marked as in-use.
Physical volume "%s" has no metadata areas.
Marking metadata areas on physical volume "%s" as %s.
Internal error: LV %s (UUID %s) not found in ondisk metadata.
Internal error: VG %s allocation policy set to invalid cling_by_tags.
Internal error: VG %s has external flag LVM_WRITE_LOCKED set internally.
Internal error: VG %s tag %s has invalid form.
Internal error: PV list corruption detected in VG %s.
Internal error: VG %s PV list entry points to different VG %s.
Internal error: VG name for PV %s is corrupted.
Internal error: Duplicate PV id %s detected for %s in %s.
Internal error: PV %s tag %s has invalid form.
Internal error: PV segments corrupted in %s.
Internal error: LV %s is not marked as removed while it's part of removed LV list for VG %s
Internal error: LV %s is marked as removed while it's still part of the VG %s
Internal error: LV %s has external flag LVM_WRITE_LOCKED set internally.
Internal error: LV name "%s/%s" length %zu is not supported.
Internal error: LV %s has VG UUID %s but its VG %s has UUID %s
Internal error: LV %s is extra pool metadata spare volume. %u found but only 1 allowed.
Internal error: LV %s is not the VG's pool metadata spare volume.
Internal error: LV segments corrupted in %s.
Internal error: LV %s allocation policy set to invalid cling_by_tags.
Internal error: LV name %s has invalid form.
Internal error: LV %s tag %s has invalid form.
Internal error: #LVs (%u) != #visible LVs (%u) + #snapshots (%u) + #internal LVs (%u) in VG %s
Failed to allocate lv_name hash
Internal error: Duplicate LV name %s detected in %s.
Internal error: Duplicate LV id %s detected for %s in %s.
Internal error: Segment in %s is not 2-way.
Internal error: Segment in %s has wrong number of areas: %d.
Internal error: Volume group %s has limited PV/LV count but limit is not set.
Internal error: VG references non pool metadata spare LV %s.
Failed to allocate lv_lock_args hash
Internal error: VG %s with lock_type %s without lock_args
Internal error: VG %s with lock_type %s is clustered
Internal error: VG %s with lock_type %s has system_id %s
Internal error: VG %s has unknown lock_type %s
Internal error: VG %s has invalid lock_args chars
Internal error: VG %s has lock_args %s without lock_type
Internal error: LV %s/%s has invalid lock_args chars
Internal error: LV %s/%s has invalid lock_args "%s"
Internal error: LV %s/%s has duplicate lock_args %s.
Internal error: LV %s/%s shouldn't have lock_args
Internal error: LV %s/%s with no lock_type has lock_args %s
Cannot allocate lock for new LV.
Cannot update partial volume group %s.
Cannot update volume group %s while physical volumes are missing.
Cannot update volume group %s with unknown segments in it!
Internal error: Unable to find %u metadata areas to ignore on volume group %s
Aborting vg_write: No metadata areas to write to!
Unable to drop cached metadata for VG %s.
Internal error: Writing metadata in critical section.
Format does not support writing volumegroup metadata areas
WARNING: Failed to write an MDA of VG %s.
Automatic metadata correction failed
Automatic metadata correction commit failed
Internal error: vg_read_internal requires vgname with pre-commit.
Not repairing VG %s metadata seqno (%d != %d) as global/metadata_read_only is set.
Cached VG %s had incorrect PV list
Inconsistent pre-commit metadata copies for volume group %s
Internal error: Too many inconsistent MDAs.
WARNING: Inconsistent metadata UUIDs found for volume group %s.
WARNING: Inconsistent metadata found for VG %s - updating to use version %u
Interrupted pvmove detected in volume group %s.
Please restore the metadata by running vgcfgrestore.
Updating cache for PVs without mdas in VG %s.
WARNING: Volume Group %s is not consistent.
get_pv_from_vg_by_id: vg_read_internal failed to read VG %s
internal PV duplication failed
VG list element allocation failed
Physical volume %s not in a volume group
uuid %s already in use on "%s"
Can't initialize physical volume "%s" of volume group "%s" without -ff
Really INITIALIZE physical volume "%s" of volume group "%s" [y/n]? 
%s: physical volume not initialized
Can't open %s exclusively.  Mounted filesystem?
WARNING: Forcing physical volume creation on %s%s%s%s
Failed to duplicate pv name %s.
%s not identified as an existing physical volume
Unable to add physical volume '%s' to volume group '%s'.
Rescan for PVs without metadata areas failed.
Finding %svolume group for uuid %s
Internal error: vg_read_by_vgid failed with lvmlockd
vg_read_by_vgid: get_vgnames failed
Can't find logical volume id %s
Volume group for uuid not found: %s
Volume group name "%s" has invalid characters.
Cannot access VG %s due to failed lock.
Cannot access VG %s with LVM1 system ID %s when host system ID is set.
WARNING: Found LVs active in VG %s with foreign system ID %s.  Possible data corruption.
Cannot access VG %s with system ID %s with unknown local system ID.
Cannot access VG %s with system ID %s with local system ID %s.
Cannot change VG %s while PVs are missing.
Consider vgreduce --removemissing.
Cannot change VG %s with unknown segments in it!
Recovery of volume group "%s" failed.
metadata/metadata.c
Volume group %s is exported
Volume group %s is read-only
snprintf random bit failed.
Failed to add tag %s to %s/%s
vg_make_handle
vg_remove_mdas %s failed
Zeroing start of device %s
%s not wiped: aborting
format_instance
pv allocation for '%s' failed
Invalid vg name %s
vg_create
Failed to hash mda.
Setting
Clearing
in-use
Failed to allocate pvid hash.
Failed to hash pvid.
Failed to allocate uuid hash
Failed to hash lvname.
Failed to hash lvid.
Failed to write VG %s.
Empty mda found for VG %s.
Checking inconsistent MDA: %s
get_pvs: get_vgids failed
PV list allocation failed
Physical volume %s not found
 of volume group "
Aborting pvcreate on %s.
precommitted 
Found volume group "%s"
Volume group "%s" not found
Reading VG %s without a lock.
.AUnable to determine mirror sync status of remotely active LV, %s/%s
Unable to determine mirror sync status of %s/%s.
Intermediate VG commit for orphan volume failed.
Failed to sync local devices when reactivating %s.
Test mode: Skipping mirror log initialisation.
Aborting. Unable to create in-sync mirror log while activation is disabled.
Aborting. Unable to deactivate mirror log.
Aborting. Unable to tag mirror log.
Aborting. Failed to sync local devices before initialising mirror log %s.
Aborting. Failed to activate mirror log.
Aborting. Failed to wipe mirror log.
Name allocation failed - log header not written (%s)
Name too long - log header not written (%s)
Writing log header to device, %s
%s: not found: log header not written
Failed to write log header to %s
Aborting. Failed to deactivate mirror log. Manual intervention required.
Unable to deactivate mirror log LV. Manual intervention required.
Manual intervention may be required to remove abandoned log LV before retrying.
Manual intervention may be required to remove/restore abandoned log LV before retrying.
Aborting. Failed to write mirror log header.
img_name allocation failed. Remove new LV and retry.
Aborting. Failed to create mirror image LV. Remove new LV and retry.
Failed to add mirror image segment to %s. Remove new LV and retry.
Aborting. Failed to add mirror image segment to %s. Remove new LV and retry.
Aborting. Failed to add mirror segment. Remove new LV and retry.
Failed to initialise mirror log.
Failed to find mirror_seg for %s
%s on %s is not a mirror segments
Using reduced mirror region size of %u sectors.
Increasing mirror region size from %u to %lu sectors.
Unable to allocate mirror extents for %s.
Failed to add mirror areas to %s
Internal error: Unknown mirror flag
Invalid index (%u) of mirror image supplied to shift_mirror_images()
Reducing mirror set %s from %u to %u image(s)%s.
Incompatible parameters to _remove_mirror_images
Internal error: _remove_mirror_images called incorrectly with is_removable undefined.
Unable to remove primary mirror image while mirror is not in-sync
%s being removed due to failures
Failed error target substitution for %s
Problem suspending temporary LV %s
Problem resuming temporary LV, %s
Failed to initialize log device
No mirror images found using specified PVs.
%u images are removed out of requested %u.
Failed to find mirrored LV for %s
Not collapsing %s: out-of-sync
Failed to release mirror images
Segment is not mirrored: %s:%u
Segment status does not match: %s:%u status:0x%lx/0x%lx
Multiple-segment mirror is not supported
Unable to determine mirror sync status.
Unable to determine sync status of remotely active mirror, %s
Unable to convert the log of an inactive cluster mirror, %s
Full resync required to convert inactive mirror %s to core log. Proceed? [y/n]: 
Logical volume %s NOT converted.
Unable to convert the log of a mirror, %s, that is active remotely but not locally
Unable to allocate extents for mirror log.
Unable to allocate extents for mirror(s).
Persistent log is not supported on segment-by-segment mirroring
Striped-mirroring is not supported on segment-by-segment mirroring
Unsupported mirror conversion type
Logical Volume "%s" already exists in volume group "%s"
Unable to split mirror that is not in-sync.
Unable to split non-mirrored LV, %s
Internal error: split_count is zero!
Detaching %d images from mirror, %s
Insufficient removable PVs given to satisfy request
Unable to rename newly split LV
Failed to build new mirror, %s
Failed to build new image name.
Failed to generate new image names
Failed to group split images into new mirror
Intermediate VG metadata write failed.
Failed to rename newly split LV in the kernel
Removing more than existing: %d <= %d
Mirror log type "%s" is unknown.
Internal error: Unknown mirror log count %d.
metadata/mirror.c
Aborting. Unable to tag.
log_name allocation failed.
_mimage_%d
_mlogtmp_%d
_mlog
Failed to create mirror log.
Failed to form mirrored log.
 and no log volume
Failed to add mirror images
All mimages of %s are gone
intermediate VG write failed.
Failed to resume %s
Failed to lock %s
Problem reactivating %s
%u image(s) removed from %s
Updating "%s" in kernel
lvs list alloc failed
core
Mirror already has a %s log
Failed to convert mirror log
No conversion is requested
%s assigned to be split
Unable to allocate memory
Problem resuming %s
Not a mirror segment
Internal error: Unable to attach pool metadata LV to %s segtype.
Internal error: Logical volume %s is not valid pool.
Internal error: Unable to attach pool data LV to %s segtype.
Internal error: Unable to attach pool to %s/%s that is not cache or thin volume.
Internal error: No pool associated with %s LV, %s.
Internal error: Cannot detach pool from LV %s.
Internal error: Trying to delete %u again.
Internal error: Unsupported message type %u.
%s is referenced by more then one segments (%s, %s).
Pool segment not found for %s.
%s on %s is not a %s pool segment
Internal error: Cannot validate chunk size of %s segtype.
%s pool chunk size %s is not in the range %s to %s.
%s pool chunk size %s must be a multiple of %s.
Internal error: %s is not a pool logical volume.
No usable device hint found while recalculating pool chunk size for %s.
Calculated chunk size %s for pool %s is out of allowed range (%s-%s).
Size of %s data volume cannot be smaller than chunk size %s.
Internal error: Pool %s already has extents.
Name of logical volume %s is too long to be a pool name.
WARNING: Pool %s is created without initialization.
Aborting. Failed to activate pool metadata %s.
Aborting. Failed to wipe pool metadata %s.
Aborting. Could not deactivate pool metadata %s.
Internal error: LV %s is not pool metadata spare.
Internal error: LV %s has no suffix for pool metadata spare.
Failed to generate unique name for pool metadata spare logical volume.
Renaming existing pool metadata spare logical volume "%s/%s" to "%s/%s".
Can't create pool metadata spare. Name of pool LV %s is too long.
Renaming %s as pool metadata spare volume %s.
Preparing pool metadata spare volume for Volume group %s.
Unable to deactivate pool metadata spare LV. Manual intervention required.
WARNING: recovery of pools without pool metadata spare LV is not automated.
metadata/pool_manip.c
Discarding message for LV %s.
Cache
Thin
Using pool metadata size %s.
%s_pmspare
metadata/pv.c
Cannot disable all metadata areas in volume group %s.
Internal error: PV %s unexpectedly not in cache.
pv_segment allocation failed
metadata/pv_manip.c
%s %u: %6u %6u: %s(%u:%u)
Gap in pvsegs: %u, %u
Wrong lvseg area type
Inconsistent pvseg pointers
Inconsistent length: %u %u
Device %s not found
No PV label found on %s.
Segment with extent %u in PV %s not found
Missing PV segment on %s at %u.
discard_pv_segment with unallocated segment: %s PE %u
Skipping discard on missing device with uuid %s.
Discarding %u extents offset %lu sectors on %s.
release_pv_segment with unallocated segment: %s PE %u
Internal error: _merge_free_pv_seg called on a segment that is not free.
Internal error: WARNING: PV %s is without initialized PE ranges.
PV segment pe_count mismatch: %u != %u
PV segment pe_alloc_count mismatch: %u != %u
PV segment VG pv_count mismatch: %u != %u
PV segment VG free_count mismatch: %u != %u
PV segment VG extent_count mismatch: %u != %u
Physical volume %s format does not support resizing.
%s: Pretending size is %lu not %lu sectors.
Resizing volume "%s" to %lu sectors.
Size must exceed minimum of %lu sectors on PV %s.
Size must exceed physical extent start of %lu sectors on PV %s.
Format specific resize of PV %s failed.
Size must leave space for at least one physical extent of %u sectors on PV %s.
No change to size of physical volume %s.
Resizing physical volume %s from %u to %u extents.
%s: cannot resize to %u extents as there is only room for %lu.
%s: cannot resize to %u extents as %u are allocated.
%s: cannot resize to %u extents as later ones are allocated.
Internal error: Physical Volume %s has a label, but is neither in a VG nor orphan.
PV %s belongs to Volume Group %s so please use vgreduce first.
(If you are certain you need pvremove, then confirm by using --force twice.)
Really WIPE LABELS from physical volume "%s" of volume group "%s" [y/n]? 
%s: physical volume label not removed
WARNING: Wiping physical volume label from %s%s%s%s
Can't open %s exclusively - not removing. Mounted filesystem?
Failed to wipe existing label(s) on %s
Labels on physical volume "%s" successfully wiped
Really WIPE LABELS from physical volume "%s" of volume group "%s" [y/n]? 
metadata/pv_map.c
create_pv_maps alloc failed
pvl->pv->dev
to_go <= pva->count
Allowing allocation on %s start PE %u length %u
Couldn't create physical volume maps in %s
consume_pv_area
_create_maps
WARNING: Sync status for %s is inconsistent.
Internal error: Unable to remove RAID layer from segment type %s
Internal error: Unable to remove RAID layer when there is more than one sub-lv
Internal error: Empty list of LVs given for clearing
Internal error: LVs must be set visible before clearing
Failed to activate localy %s for clearing
New logical volume name "%s" is not valid.
Logical volume %s already exists in volume group %s.
Unable to remove %d images:  Only %d device%s given.
%s has components with error targets that must be removed first: %s.
Try removing the PV list and rerun the command.
LVs with error segments to be removed: %s %s
Unable to extract %sRAID image while RAID array is not in-sync
Extracting image components %s and %s from %s
Unable handle arrays with more than 10 devices
Internal error: Metadata segment area #%d should be AREA_UNASSIGNED
Unable to extract enough images to satisfy request
Failed to shift and rename image components
Internal error: Stand-alone %s area allocation not implemented
Internal error: Bad type provided to _alloc_raid_component.
Component name for raid %s is too long.
Failed to allocate new raid component, %s.
Failed to add segment to LV, %s
Internal error: Unable to allocate RAID metadata area for non-linear LV, %s
Failed to build list of PVs for %s/%s
An entire mirror group has failed in %s.
All components of raid LV %s have failed.
More than %u components from %s %s have failed.
%s contains a segment incapable of degraded activation
%s/%s already has image count of %d.
%s/%s must be active exclusive locally to perform this operation.
Failed to extract images from %s/%s
Failed to remove RAID layer after linear conversion
Failed to write changes to %s in %s
Failed to suspend %s/%s before committing changes
Failed to commit changes to %s in %s
Failed to resume extracted LVs
Failed to resume %s/%s after committing changes
Failed to sync local devices after committing changes for %s.
Can't add image to out-of-sync RAID LV: use 'lvchange --resync' first.
Can't add image to RAID LV that is still initializing.
Unable to add RAID images to %s of segment type %s
Setting RAID1 region_size to %uS
Allocation of new areas failed.
Allocation of new meta areas failed.
Failed to clear REBUILD flag for %s/%s components
Splitting raid image is not allowed with lock_type %s
Unable to split more than one image from %s/%s
Unable to split logical volume of segment type, %s
Logical Volume "%s" already exists in %s
Unable to split %s/%s while it is not in-sync.
Unable to split additional image from %s while tracking changes for %s
Unable to split images from non-mirrored RAID
Unable to split image from %s/%s while not in-sync
Cannot track more than one split image at a time
Unable to find image to satisfy request
%s split from %s for read-only purposes.
Use 'lvconvert --merge %s/%s' to merge back into %s
%s is not read-only - refusing to merge.
Unable to merge non-mirror image %s.
Unable to find containing RAID array for %s.
Failed to find meta for %s in RAID array %s.
Failed to deactivate %s before merging.
%s/%s successfully merged back into %s/%s
Internal error: New segtype not specified
Unable to convert %s/%s while it is not in-sync
Failed to allocate meta areas memory.
Clearing newly allocated metadata LVs
Allocating new metadata LV for %s
Failed to allocate metadata LV for %s in %s
Failed to initialize metadata LVs
Converting the segment type for %s/%s from %s to %s is not yet supported.
Unable to replace devices in %s/%s while it is not in-sync.
%s/%s does not contain devices specified for replacement
Unable to replace RAID images while the array has unassigned areas
Unable to remove all PVs from %s/%s at once.
Unable to replace more than %u PVs from (%s) %s/%s
Unable to replace all the devices in a RAID10 mirror group.
Failed to prevent PVs holding image components from being used for allocation.
Failed to replace %u devices.  Attempting to replace %u instead.
%u extents needed to repair %s
Failed to allocate replacement images for %s/%s
Failed to remove the specified images from %s/%s
Internal error: %s/%s is not a partial LV
Attempting to remove missing devices from %s LV, %s
Replacing %s and %s segments with error target
Failed to replace %s's extents with error target.
metadata/raid_manip.c
Failed to zero %s
Failed to deactivate %s
Failed to allocate new name.
primary 
Extracting %u %s from %s/%s
_extracted
Shifting images in %s
Shifting %s and %s by %u
Memory allocation failed.
Failed to extract %s from %s
rmeta
%s_%s_%%d
_mimage_
Memory allocation failed
_rimage_0
Adding %s to %s
Failed to add %s to %s
Removing mirror log, %s
Failed to remove mirror log
Setting new segtype for %s
LV %s in not partial.
%s has enough space for %s
Not enough space on %s for %s
metadata/replicator_manip.c
FIXME: not implemented.
<local>
Allocation of cmd_vg failed.
Allocation of vgid failed.
Failed to vg_read %s
VG: %s added as missing.
Replicator device in site %s already has sync log.
Sync log %s is already used by replicator %s.
Replicator device in site %s does not have sync log.
Replicator device %s is already part of replicator.
Rlog device %s is already used.
Replog segment %s does not have rlog.
Volume Group %s of replicator %s is clustered
Replicator %s segment size %d != 1
Defined fall_behind_timeout=%d for sync replicator %s/%s.
Defined fall_behind_ios=%d for sync replicator %s/%s.
Defined fall_behind_data=%lu for sync replicator %s/%s.
Defined fall_behind_timeout and fall_behind_ios for async replicator %s/%s.
Defined fall_behind_timeout and fall_behind_data for async replicator %s/%s.
Defined fall_behind_ios and fall_behind_data for async replicator %s/%s.
fall_behind_timeout, fall_behind_ios and fall_behind_data are undefined for async replicator %s/%s.
Duplicate site name %s detected for replicator %s.
Duplicate VG name %s detected for replicator %s.
Duplicate site index %d detected for replicator site %s/%s.
Site index %d > %d (too high) for replicator site %s/%s.
Duplicate sync log %s detected for replicator %s.
Duplicate device name %s detected for replicator %s.
Duplicate device index %ld detected for replicator site %s/%s.
Device index %lu > %lu (too high) for replicator site %s/%s.
Logical volume %s is already part of other replicator.
Logical volume %s can not be attached to an already defined replicator device
Either vg_name or vgid must be set.
Unable to read volume group %s
Unable to find %s in volume group %s
metadata/segtype.c
WARNING: Unrecognised segment type %s
metadata/snapshot_manip.c
snapshot%d
snapshot-merge
Snapshot volume cannot be smaller than 3 chunks (%u extents, %s).
'%s' is already in use as a snapshot.
Snapshot and origin LVs must differ.
Failed to deactivate logical volume "%s"
Failed to remove internal snapshot LV %s
Unable to activate logical volume "%s"
Internal error: LV "%s" already has external origin.
Setting logical volume "%s" read-only.
Internal error: Inconsitent external origin.
Internal error: LV %s is not pool.
Internal error: Cannot attach message to non-pool LV %s.
Message referring LV %s already queued in pool %s.
Delete for device %u already queued in pool %s.
Failed to allocate memory for message.
Internal error: pool_is_active called with non-pool LV %s.
Internal error: LV %s is not thin pool.
 and the size of whole volume group
 and the amount of free space in volume group
WARNING: Sum of all thin volume sizes (%s) exceeds the size of thin pool%s%s%s (%s)!
For thin pool auto extension activation/thin_pool_autoextend_threshold should be below 100.
For thin pool auto extension activation/thin_pool_autoextend_percent should be above 0.
Can't use "%s" as external origin with "%s" pool. Size %s is not a multiple of pool's chunk size %s.
Internal error: Segment in %s is not a thin pool segment.
Internal error: Updated LV %s is not pool.
Pool %s needs to be locally active for threshold check.
Free space in pool %s is above threshold, new volumes are not allowed.
Failed to suspend and send message %s.
Thin pool discards type "%s" is unknown.
Internal error: Could not find configuration.
Chunk size must be a power of 2 for this thin target version.
WARNING: Chunk size is too small for pool, suggested minimum is %s.
WARNING: Chunk size is smaller then suggested minimum size %s.
WARNING: Minimum supported pool metadata size is %s.
Internal error: Unknown discards type encountered.
Aborting. Failed to locally activate thin pool %s.
Cannot read thin pool %s transaction id locally, perhaps skipped in lvm.conf volume_list?
Cannot use thin pool %s with transaction id %lu for thin volumes. Expected transaction id %lu.
Deactivating public thin pool %s
Aborting. Could not deactivate thin pool %s.
metadata/thin_manip.c
delete
Added %s message.
no free space in volume group
LV %s has no segment
Cannot find free device_id.
Found free pool device_id %u.
nopassdown
Setting chunk size %s.
New size %lu for %s%s not an exact number of new extents.
New extent count %lu for %s%s exceeds 32 bits.
Internal error: global memory pool used for VG %s
Failed to allocate VG systemd id.
Failed to allocate VG hostname hashtable.
Failed to allocate volume group structure
Setting mda_copies to %u for VG %s
Physical Extent size must be a multiple of %s when not a power of 2.
Metadata format only supports Physical Extent sizes that are powers of 2.
Extent size must be between %s and %s
Extent size must be multiple of %s
Volume group "%s" must be resizeable to change PE size
New extent size is not a perfect fit
Volume group "%s" must be resizeable to change MaxLogicalVolume
MaxLogicalVolume is less than the current number %d of LVs for %s
Volume group "%s" must be resizeable to change MaxPhysicalVolumes
MaxPhysicalVolume limit is 255
MaxPhysicalVolumes is less than the current number %d of PVs for "%s"
Can't change cluster attribute with active logical volume %s.
Conversion is supported only for locally exclusive volumes.
Setting volume group %s as %sclustered.
Failed to allocate memory for system_id in vg_set_system_id.
Physical volume "%s" still in use
Can't remove final physical volume "%s" from volume group "%s"
Removing "%s" from volume group "%s"
Cannot remove final metadata area on "%s" from "%s"
Removal of physical volume "%s" from "%s" failed
Removed "%s" from volume group "%s"
metadata/vg.c
Freeing VG %s at %p.
Failed to allocate VG name.
Allocated VG %s at %p.
 free space
 allocated space
 PV segment start
 PV segment length
 area length
 extents moved
 pvseg start
 pvseg length
 area start
MaxLogicalVolume limit is 255
vg_set_lock_type %s no mem
Internal error: VG is NULL.
 n;^
Qkkbal
i]Wb
9a&g
MGiI
wn>Jj
#.zf
+o*7
-misc/lvm-exec.c
Executing:%s
fork
Child %u exited abnormally
%s failed: %u
pipe
Piping:%s
pipe[0]
STDOUT
pipe[1]
STDIN
waitpid
Internal error: Missing command.
Failed to sync local device names before forking.
wait4 child process %u failed: %s
misc/lvm-file.c
gethostname
%s/.lvm_%s_%d_%d
%s: rename to %s failed
sync_dir failed in strdup
F_WRLCK
F_RDLCK
Locking %s (%s, %hd)
fcntl
Unlocking fd %d
%s: write error
Not enough space to build temporary file string.
fcntl_lock_file failed in strdup.
TEST MODE: Metadata will NOT be updated and volumes will not be (de)activated.
LVM activation checks disabled
misc/lvm-globals.c
LVM udev checking enabled
LVM udev checking disabled
LVM activation checks enabled
Interrupted...
misc/lvm-signal.c
SIGINT
sigaction
sigprocmask
SIG_SETMASK
SIGINT restore
_block_signals
sigfillset
Names starting "%s" are reserved. Please choose a different LV name.
Names including "%s" are reserved. Please choose a different LV name.
misc/lvm-string.c
_cdata
_cmeta
_corig
_mimage
_mlog
_pmspare
_rimage
_rmeta
_tdata
_tmeta
_vorigin
pvmove
snapshot
Failed to create udev library context.
misc/lvm-wrappers.c
Udev library context not set.
Could not get udev state.
Assuming udev is not running.
read_urandom: /dev/urandom
/run/clvmd.pid
/run/cmirrord.pid
WARNING: Failed to reserve memory, %d bytes missing.
Allocation of maps buffer failed.
%s area unreadable %s : Skipping.
%s ignore filter '%s' matches '%s': Skipping.
%s default filter '%s' matches '%s': Skipping.
%s_filter '%s' matches '%s': Skipping.
%s %10ldKiB %12lx - %12lx %c%c%c%c%s
Internal error: Reserved memory (%ld) not enough: used %ld. Increase activation/reserved_memory?
Suppressed internal error: Maps lock %ld < unlock %ld, a one-page difference.
Lock:   Memlock counters: locked:%d critical:%d daemon:%d suspended:%d
Unlock: Memlock counters: locked:%d critical:%d daemon:%d suspended:%d
Entering critical section (%s).
Leaving critical section (%s).
Internal error: _memlock_inc_daemon used in critical section.
memlock_count_daemon inc to %d
Internal error: _memlock_count_daemon has dropped below 0.
memlock_count_daemon dec to %d
Unlocking daemon memory in critical section.
mm/memlock.c
[vdso]
locale/locale-archive
munlockall
lseek
munlock
%lx-%lx %c%c%c%c%n
Failed to parse maps line: %s
%socked %ld bytes
Unlocking memory
setpriority %u failed: %s
Locking memory
%s/self/maps
proc_dir too long
getpriority
setpriority %d failed: %s
memlock reset.
/LC_MESSAGES/
gconv/gconv-modules.cache
/libblkid.so.
/liblzma.so.
/libncurses.so.
/libpcre.so.
/libreadline.so.
/libselinux.so.
/libsepol.so.
/libtinfo.so.
/libudev.so.
/libuuid.so.
/libdl-
/etc/selinux
[vsyscall]
[vectors]
report/report.c
dm_pool_strdup failed
refresh needed
mismatches exist
out_of_data
time_now
@%ld:@%ld
skip activation
queue
Failed to get segtype name.
lvname snprintf failed
lvm2_
Description of Device Type.
Unique identifier.
LV layout.
LV role.
Set if LV is being converted.
LV allocation policy.
Set if snapshot merge failed.
Active state of the LV.
Size of LV in current units.
Number of segments in LV.
Ancestors of this LV.
Descendants of this LV.
Tags, if any.
LV permissions.
Set if LV is suspended.
Set if LV device is open.
Total cache blocks.
Used cache blocks.
Dirty cache blocks.
Cache read hits.
Cache read misses.
Cache write hits.
Cache write misses.
LV health status.
Type of metadata.
Name.
Size of PV in current units.
VG permissions.
Set if VG is extendable.
Set if VG is exported.
Set if VG is partial.
VG allocation policy.
Set if VG is clustered.
Number of PVs.
Number of LVs.
Number of snapshots.
Type of LV segment.
Number of extents in segment.
Device Types
devtype_
Logical Volume
Logical Volume Device Info
Logical Volume Device Status
Physical Volume
Physical Volume Label
Logical Volume Segment
Physical Volume Segment
pvseg_
queue when full
queue if no space
error when full
error if no space
read-only-override
ro-override
r-override
writeable
read-write
inactive table present
inactive table
inactive
live table present
live table
live
snapshot invalid
merge failed
active exclusively
active remotely
active locally
fixed minor
fixed
allocation locked
image synced
initial image sync
extendable
undef
today
yesterday
Sunday
Monday
Tuesday
Wednesday
Thursday
Friday
Saturday
noon
midnight
second
minute
hour
week
month
year
January
February
March
April
June
July
August
September
October
November
December
alloc_time_item: dm_pool_zalloc failed
_get_now: dm_pool_zalloc failed
_get_now: failed to cache current time
_preparse_fuzzy_time: dm_pool_alloc failed
Unrecognized string in date/time specification at "%s".
Unrecognized number in date/time specification at "%s".
Mixed absolute and relative date specification found at "%s".
Ambiguous date specification found at "%s".
Mixed absolute and relative time specification found at "%s".
Ambiguous time specification found at "%s".
_translate_time_items: dm_snprintf failed
_translate_time_items: dm_pool_strdup failed
Failed to get value for parsed time specification.
Failed to allocate space to store time range.
Internal error: Unexpected NULL policy name.
Failed to allocate buffer for host.
Failed to allocate buffer for time.
Failed to allocate buffer for active.
Failed to display role for LV %s/%s.
Failed to display layout for LV %s/%s.
Name of Device Type exactly as it appears in /proc/devices.
Maximum number of partitions. (How many device minor numbers get reserved for each device.)
Name.  LVs created for internal use are enclosed in brackets.
Full name of LV including its VG, namely VG/LV.
Full pathname for LV. Blank for internal LVs.
Internal device-mapper pathname for LV (in /dev/mapper directory).
For LVs that are components of another LV, the parent LV.
Various attributes - see man page.
Set if mirror/RAID images underwent initial resynchronization.
Set if mirror/RAID image is synchronized.
Set if snapshot LV is being merged to origin.
Set if LV is locked against allocation changes.
Set if LV has fixed minor number assigned.
Set if snapshot LV is invalid.
Set if LV is skipped on activation.
For thin pools, behavior when full.
Set if the LV is active locally.
Set if the LV is active remotely.
Set if the LV is active exclusively.
Persistent major number or -1 if not persistent.
Persistent minor number or -1 if not persistent.
Read ahead setting in current units.
For thin and cache pools, the size of the LV that holds the metadata.
For snapshots, the origin device of this LV.
For snapshots, the size of the origin device of this LV.
For snapshot and thin pools and volumes, the percentage full if LV is active.
For snapshots, the percentage full if LV is active.
For thin pools, the percentage of metadata full if LV is active.
For RAID, mirrors and pvmove, current percentage in-sync.
For RAID, number of mismatches found or repaired.
For RAID, the current synchronization action being performed.
For RAID1, the number of outstanding writes allowed to writemostly devices.
For RAID1, the minimum recovery I/O load in kiB/sec/disk.
For RAID1, the maximum recovery I/O load in kiB/sec/disk.
For pvmove, Source PV of temporary LV created by pvmove.
For lvconvert, Name of temporary LV created by lvconvert.
For mirrors, the LV holding the synchronisation log.
For thin and cache pools, the LV holding the associated data.
For thin and cache pools, the LV holding the associated metadata.
For thin volumes, the thin pool LV for this volume.
Configuration profile attached to this LV.
Lock args of the LV used by lvmlockd.
Creation time of the LV, if known
Creation host of the LV, if known.
Kernel device-mapper modules required for this LV.
Currently assigned major number or -1 if LV is not active.
Currently assigned minor number or -1 if LV is not active.
Currently-in-use read ahead setting in current units.
Set if LV has live table present.
Set if LV has inactive table present.
Size of underlying device in current units.
Free metadata area space on this device in current units.
Size of smallest metadata area on this device in current units.
Offset to the start of data on the underlying device.
Total amount of unallocated space in current units.
Total amount of allocated space in current units.
Set if this device can be used for allocation.
Set if this device is exported.
Set if this device is missing in system.
Total number of Physical Extents.
Total number of allocated Physical Extents.
Number of metadata areas on this device.
Number of metadata areas in use on this device.
Offset to the start of PV Bootloader Area on the underlying device in current units.
Size of PV Bootloader Area in current units.
Total size of VG in current units.
Total amount of free space in current units.
System ID of the VG indicating which host owns it.
Lock type of the VG used by lvmlockd.
Lock args of the VG used by lvmlockd.
Size of Physical Extents in current units.
Total number of unallocated Physical Extents.
Maximum number of LVs allowed in VG or 0 if unlimited.
Maximum number of PVs allowed in VG or 0 if unlimited.
Revision number of internal metadata.  Incremented whenever it changes.
Configuration profile attached to this VG.
Number of metadata areas on this VG.
Number of metadata areas in use on this VG.
Free metadata area space for this VG in current units.
Size of smallest metadata area for this VG in current units.
Target number of in use metadata areas in the VG.
Number of stripes or mirror legs.
For stripes, amount of data placed on one device before switching to the next.
For mirrors, the unit of data copied when synchronising devices.
For snapshots, the unit of data used when tracking changes.
For thin pools, the number of thin volumes in this pool.
For thin pools, how discards are handled.
For cache pools, how writes are cached.
For thin pools, if zeroing is enabled.
For thin pools, the transaction id.
For thin volume, the thin device id.
Offset within the LV to the start of the segment in current units.
Offset within the LV to the start of the segment in physical extents.
Size of segment in current units.
Size of segment in physical extents.
Ranges of Physical Extents of underlying devices in command line format.
Underlying devices used with starting extent numbers.
Dmeventd monitoring status of the segment.
The cache policy (cached segments only).
Cache settings/parameters (cached segments only).
Physical Extent number of start of segment.
Logical Volume Device Info and Status Combined
Logical Volume Device Segment Status
Reserved value for undefined numeric value.
unknown
striped/striped.c
stripe_size
  Stripes		%u
  Stripe size		%s
  Stripe size		%u KB
  Stripe %d:
stripe_count
# linear
stripe_count = %u
stripe_size = %u
stripe
Internal error: striped add_target_line called with no areas for %s.
Couldn't read stripe_size for segment %s of logical volume %s.
Couldn't find stripes array for segment %s of logical volume %s.
Couldn't read 'stripe_count' for segment '%s'.
UUID contains invalid character
Couldn't write uuid, buffer too small.
Too many characters to be uuid.
Couldn't read uuid: incorrect number of characters.
uuid/uuid.c
0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!#
zero/zero.c
zero module string list allocation failed
format1/format1.c
lvm1 pv_write
lvm1 pv_read
lvm1 vg_write
format1_vg_read
format1_orphan
Physical volumes cannot be bigger than %s
Metadata would overwrite physical extents
Reading physical volume data %s from disk
logical volumes cannot contain more than %d extents.
logical volumes cannot be larger than %s
Unable to allocate metadata area structure for lvm1 format
VG data differs between PVs %s and %s
VG data on %s: %s %s %u %u  %u %u %u %u %u %u %u %u %u %u %u %u %u
%d PV(s) found for VG %s: expected %d
Partial mode support for missing lvm1 PVs and partially available LVs is currently not implemented.
%s: partial VG, allocated missing PV using %d extents.
Failed to allocate format1 format type structure.
Couldn't create lvm1 label handler.
Couldn't register lvm1 label handler.
Couldn't create lvm1 orphan VG.
Volume Group name allocation failed.
System ID %s on %s differs from %s for volume group
Fixing up missing format1 size (%s) for PV %s
Generated LVM1 format system_id too long
Volume group name %s too long to export
Segment type %s in LV %s: unsupported by format1
Non-PV stripe found in LV %s: unsupported by format1
Logical volume number out of bounds.
Couldn't find logical volume '%s'.
Couldn't find origin logical volume for snapshot '%s'.
format1/import-export.c
%s%s%lu
PV_EXP
PV_IMP
Couldn't add snapshot.
PV %s not found.
format1/import-extents.c
lvm1 import_extents
Physical volume (%s) contains an unknown logical volume (%s).
Invalid LV in extent map (PV %s, PE %u, LV %u, LE %u)
logical extent number out of bounds
logical extent (%u) already mapped.
Unable to create hash table for holding extent maps.
Couldn't fill logical volume maps.
Logical volume (%s) contains an incomplete mapping table.
Number of stripes (%u) incompatible with logical extent count (%u) for %s
Failed to allocate striped segment.
Failed to allocate linear segment.
Couldn't allocate logical volume maps.
Couldn't build extent segments.
MaxLogicalVolumes of %d exceeds format limit of %d for VG '%s'
MaxPhysicalVolumes of %d exceeds format limit of %d for VG '%s'
Insufficient space for metadata and PE's.
Too few extents on %s.  Try smaller extent size.
Metadata extent limit (%u) exceeded for %s - %u required
format1/layout.c
format1/lvm1-label.c
The '%s' operation is not supported for the lvm1 labeller.
lvm1 vg_number
format1/vg_number.c
pool pv_read
format_pool/format_pool.c
pool_vg_read
Missing subpool %d in pool %s
pool_orphan
Unable to allocate %d subpool structures
Unable to allocate %d pool_device structures
Missing device %u for subpool %d in pool %s
Unable to allocate metadata area structure for pool format
Unable to allocate format type structure for pool format
Couldn't create pool label handler.
Couldn't register pool label handler.
Couldn't create pool orphan VG.
gfs_journal
gfs_data
format_pool/import_export.c
Found sptype %X and converted it to %s
Calculated lv uuid for lv %s: %s
Unable to duplicate vg_name string
Unable to allocate pv list structure
Unable to allocate pv structure
Stripe size must be a power of 2
Unable to allocate striped lv_segment structure
Allocation failed for str_list.
Unable to allocate linear lv_segment structure
format_pool/pool_label.c
The '%s' operation is not supported for the pool labeller.
locking/cluster_locking.c
EOF reading CLVMD
cluster request failed: %s
clvmd not running on node %s
Error locking on node %s: %s
|REVERT
|ORIGIN_ONLY
|CACHE
|REMOTE
|LOCAL
|CLUSTER
|HOLD
|NONBLOCK
Requesting sync names.
%c_%s
Locking resource %s too long.
Unrecognised lock type: %u
Error writing data to clvmd: %s
Error reading data from clvmd: %s
%s: clvmd socket name too long.
Local socket creation failed: %s
connect() failed on local socket: %s
Skipping redundant local sync command.
strlen(resource) < sizeof(lockname)
Requesting backup of VG metadata for %s
Locking %s %s %s (%s%s%s%s%s%s%s%s%s) (0x%x)
Lock held for %s, node %s : %s
_lock_for_cluster
_lock_resource
/run/lvm/clvmd.sock
snapshot-origin
snapshot/snapshot.c
merging_store
cow_store
chunk_size = %u
cow_store = "%s"
merging_store = "%s"
Target snapshot may leak metadata.
Couldn't read chunk size for snapshot.
Merging store must be a string in segment %s of logical volume %s.
Both snapshot cow and merging storage were specified in segment %s of logical volume %s.
Cow store must be a string in segment %s of logical volume %s.
Snapshot origin not specified in segment %s of logical volume %s.
Snapshot origin must be a string in segment %s of logical volume %s.
Unknown logical volume %s specified for snapshot cow store in segment %s of logical volume %s.
Unknown logical volume %s specified for snapshot origin in segment %s of logical volume %s.
Snapshot cow storage not specified in segment %s of logical volume %s.
snapshot string list allocation failed
mirror/mirrored.c
clog
log-clustered
log-userspace
Found mirror log at %d:%d
Status of log (%s): %s
Found mirror image at %d:%d
Failed to find image %d (%s).
Status of image %d: %c
extents_moved
mirror_log
mirror_count = %u
extents_moved = %u
mirror_log = "%s"
region_size = %u
  Mirrors		%u
  Mirror size		%u
  Mirror log volume	%s
  Mirror region size	%s
  Mirror original:
  Mirror destinations:
Mirror status: %s
%u %n
%*x:%*x %n
%lu/%lu%n
mirror_count
cluster log string list allocation failed
mirror string list allocation failed
Cluster mirror log module is not available.
Cluster mirror log daemon is not running.
Mirrored transient status: "%s"
Unexpectedly many (%d) mirror images in %s.
Unexpectedly many (%d) log arguments in %s.
Active mirror has a wrong number of mirror images!
Metadata says %d, kernel says %d.
Check for existence of mirror log %s failed.
Mirror log mismatch. Metadata says %s, kernel says %s.
Check for existence of mirror image %s failed.
Match: metadata image %d matches kernel image %d
Couldn't read 'extents_moved' for segment %s of logical volume %s.
Couldn't read 'region_size' for segment %s of logical volume %s.
Unrecognised mirror log in segment %s of logical volume %s.
Missing region size for mirror log for segment %s of logical volume %s.
Couldn't find mirrors array for segment %s of logical volume %s.
struct mirr_state allocation failed
Failure parsing mirror status mirror count: %s
Failure parsing mirror status devices: %s
Failure parsing mirror status fraction: %s
Missing region size for mirror segment.
Failed to build uuid for log LV %s.
Failed to build uuid for mirror LV %s.
Couldn't read 'mirror_count' for segment '%s'.
raid/raid.c
min_recovery_rate
max_recovery_rate
No areas found for segment %s
Failed to import RAID images
device_count = %u
writebehind = %u
min_recovery_rate = %u
max_recovery_rate = %u
  Raid Data LV%2d
  Raid Metadata LV%2d	%s
device_count
Target raid does not support %s.
Cannot read target version of RAID kernel module.
Failed to parse %s status fraction: %s
Couldn't read 'stripe_size' for segment %s of logical volume %s.
Couldn't read 'writebehind' for segment %s of logical volume %s.
Couldn't read 'min_recovery_rate' for segment %s of logical volume %s.
Couldn't read 'max_recovery_rate' for segment %s of logical volume %s.
Couldn't find RAID array for segment %s of logical volume %s.
Missing data device in areas array for segment %s.
raid module string list allocation failed
Internal error: _raid_add_target_line called with no areas for %s.
Unable to handle more than 64 devices in a single RAID array
Couldn't read 'device_count' for segment '%s'.
Failed to allocate memory for %s segtype
raid1
raid10
raid4
raid5
raid5_la
raid5_ls
raid5_ra
raid5_rs
raid6
raid6_nc
raid6_nr
raid6_zr
  Device ID		%u
thin/thin.c
thin_pool
transaction_id
device_id
external_origin
Thin pool delete %u.
snap
Thin pool create_%s %s.
  Chunk size		%s
  Discards		%s
  Thin count		%u
  Transaction ID	%lu
  Zero new blocks	%s
thin_pool = "%s"
transaction_id = %lu
device_id = %d
external_origin = "%s"
merge = "%s"
low_water_mark
zero_new_blocks
metadata = "%s"
discards = "%s"
low_water_mark = %lu
zero_new_blocks = 1
message%d {
create = "%s"
delete = %d
block_size
discards_non_power_2
metadata_resize
error_if_no_space
external_origin_extend
Cannot read %s target version.
Target %s does not support %s.
Target %s %s support disabled by %s
WARNING: LV %s maps %s while the size is only %s.
Internal error: Segment %s has no pool.
Failed to build uuid for pool LV %s.
Internal error: Failed to add merged segment of %s.
Thin target does not support smaller size of external origin LV %s.
Failed to build uuid for external origin LV %s.
Thin pool must be a string in segment %s of logical volume %s.
Unknown thin pool %s in segment %s of logical volume %s.
Could not read transaction_id for segment %s of logical volume %s.
Origin must be a string in segment %s of logical volume %s.
Unknown origin %s in segment %s of logical volume %s.
Merge lv must be a string in segment %s of logical volume %s.
Unknown merge lv %s in segment %s of logical volume %s.
Could not read device_id for segment %s of logical volume %s.
Unsupported value %u for device_id segment %s of logical volume %s.
External origin must be a string in segment %s of logical volume %s.
Unknown external origin %s in segment %s of logical volume %s.
Internal error: Thin pool is missing metadata device.
Thin pool target does not support %uKiB chunk size (needs kernel >= 3.6).
Failed to build uuid for metadata LV %s.
WARNING: Thin pool target does not support discards (needs kernel >= 3.4).
WARNING: Thin pool target does not support error if no space (needs version >= 1.10).
Can't create snapshot %s as origin %s is not suspended.
Internal error: Unsupported message.
Thin pool set transaction id %lu.
String list allocation failed for thin_pool.
String list allocation failed for thin.
Metadata must be a string in segment %s of logical volume %s.
Unknown metadata %s in segment %s of logical volume %s.
Pool must be a string in segment %s of logical volume %s.
Unknown pool %s in segment %s of logical volume %s.
Could not read chunk_size segment %s of logical volume %s.
Could not read discards for segment %s of logical volume %s.
Discards option unsupported for segment %s of logical volume %s.
Could not read low_water_mark segment %s of logical volume %s.
Unsupported value %u for chunk_size segment %s of logical volume %s.
Could not read zero_new_blocks for segment %s of logical volume %s.
Unknown LV %s for create message in segment %s of logical volume %s.
Unknown message in segment %s of logical volume %s.
Internal error: Invalid discards value %d.
Internal error: LV %s is not a thin volume.
Internal error: Passed unsupported message.
global/thin_disabled_features
thin
thin-pool
cache_segtype/cache.c
cache_pool
cache_pool = "%s"
cleaner = 1
cache_mode = "%s"
Failed to determine version of cache kernel module
The cache kernel module is version %u.%u.%u. Version 1.3.0+ is required.
Internal error: Passed segment is not cache.
Cache data not specified in segment %s of logical volume %s.
Cache data must be a string in segment %s of logical volume %s.
Unknown logical volume %s specified for cache data in segment %s of logical volume %s.
Cache metadata not specified in segment %s of logical volume %s.
Cache metadata must be a string in segment %s of logical volume %s.
Unknown logical volume %s specified for cache metadata in segment %s of logical volume %s.
Couldn't read cache chunk_size in segment %s of logical volume %s.
cache_mode must be a string in segment %s of logical volume %s.
Unknown cache_mode in segment %s of logical volume %s.
policy must be a string in segment %s of logical volume %s.
Failed to duplicate policy in segment %s of logical volume %s.
policy_settings must have a policy_name in segment %s of logical volume %s.
policy_settings must be a section in segment %s of logical volume %s.
String list allocation failed for cache module.
cache_pool not specified in segment %s of logical volume %s.
cache_pool must be a string in segment %s of logical volume %s.
Unknown logical volume %s specified for cache_pool in segment %s of logical volume %s.
Cache origin not specified in segment %s of logical volume %s.
Cache origin must be a string in segment %s of logical volume %s.
Unknown logical volume %s specified for cache origin in segment %s of logical volume %s.
Could not read cache cleaner in segment %s of logical volume %s.
Internal error: Incorrect policy_settings tree, %s.
Failed to allocate memory for cache_pool segtype
Failed to allocate memory for cache segtype
global/cache_disabled_features
policy_mq
cache-mq
policy_smq
cache-smq
cache
Internal error: _emit_target cannot handle segment type %s
Failed to get info for device %d:%d
Allocation of log string failed.
Failed to parse log's device number from %s.
Allocation of images string failed.
WARNING: Failed to disable open_count.
Internal error: _info_run: unhandled info type
Internal error: _get_segment_status_from_target_params: segment type %s found does not match expected segment type %s
Internal error: Unsupported segment type %s.
Number of segments in active LV %s does not match metadata
Kernel driver has incomplete udev support so LVM will check and perform some operations itself.
Failed to allocated path for callback.
Internal error: Registering unsupported pool callback.
Internal error: Unable to find configuration for pool check options.
Invalid string in config file: global/%s_check_options
Too many options for %s command.
Failed to build pool metadata path.
%s skipped, detect empty disk header on %s.
Check of pool %s failed (status:%d). Manual repair required!
WARNING: Integrity check of metadata for pool %s failed.
Failed to get info from tree node for %s.
Getting device info for %s [%s]
Failed to get info for %s [%s].
Volume %s (%u:%u) differs from already active device (%u:%u)
The requested major:minor pair (%u:%u) is already used
Failed to add device (%u:%u) to dtree
Tracking pending delete for %s (%s).
Failed to get state of mapped device
%s: Empty device %s not usable.
%s: Suspended device %s not usable.
%s: Reserved uuid %s on internal LV device %s not usable.
%s: Reserved internal LV device %s/%s%s%s not usable.
%s: Scanning mirror devices is disabled.
%s: Mirror image %d marked as failed
%s: Mirror log device marked as failed
%s: I/O blocked to mirror device
%s: Mirror device %s not usable.
Failed to get state of snapshot or snapshot origin device
Incorrect snapshot table found
Incorrect snapshot-origin table found
Failed to get state of mapped device.
Failed to get thin-pool major:minor for thin device %d:%d.
WARNING: %s: Thin's thin-pool needs inspection.
%s: Error device %s not usable.
WARNING: Using linear target for %s/%s: Striped requires extent size (%u sectors) >= page size (%u).
_add_new_lv_to_dtree: pool alloc failed for %s %s.
Internal error: LV %s is not merging snapshot.
Couldn't find snapshot for '%s'.
Checking kernel supports %s segment type for %s%s%s
Can't process LV %s: %s target support missing from kernel?
Adding external origin lv %s and all active users.
Finished adding  external origin lv %s and all active users.
Using error for pending delete %s.
Internal error: Cannot create tree for %s.
Partial dtree creation failed for %s.
Lost dependency tree root node
_clean_tree: Couldn't split up device name %s.
Failed to remove all device symlinks associated with %s.
_create_lv_symlinks: Couldn't split up old device name %s
_create_lv_symlinks: Couldn't split up new device name %s
Failed to create symlinks for %s.
Internal error: _tree_action: Action %u not supported.
Getting device %s status percentage for %s
Expected raid segment type but got %s instead
Internal error: %s/%s is not a RAID logical volume
Expected cache segment type but got %s instead
Getting device status percentage for %s
More then one table line found for %s.
Unexpected target type %s found for thin %s.
Cannot parse table like parameters %s for %s.
Aborting.  LV %s is now incomplete and '--activationmode partial' was not specified.
_add_error_device called with bad segment
Internal error: Unassigned area found in LV %s.
Cannot activate %s%s: pool incomplete.
Failed to add device %s (%u:%u) to dtree
activate/dev_manager.c
Can't set no_flush flag.
LV percent: %.2f
Failed to build dlid for %s.
 block_on_error
 handle_errors
%d:%d %d:%d
%s: %s device %s not usable.
unusable_thins
Can't set no_flush.
name build failed for %s
dlid build failed for %s
 origin-only
Creating %s%s tree for %s.
Deleting tracked UUID %s.
dev_manager
frozen
recover
reshape
Unknown RAID message: %s
%*u:%*u %u
missing_%d_%d
partial dtree creation failed
PRELOAD
ACTIVATE
DEACTIVATE
SUSPEND
SUSPEND_WITH_LOCKFS
CLEAN
activate/fs.c
Removing link %s
%s/group
Couldn't create path for %s
Removing %s
Linking %s -> %s
symlink
Creating directory %s
mkdir
Removing directory %s
Syncing device names
Couldn't determine link pathname.
The link %s should have been removed by udev but it is still present. Falling back to direct link removal.
%s not symbolic link - not removing
Couldn't create destination pathname for logical volume link for %s
Couldn't create pathname for LVM1 group file for %s
Non-LVM1 character device found at %s
Symbolic link %s not created: file exists
Symlink %s that should have been created by udev does not have correct target. Falling back to direct link creation
Symlink %s that should have been created by udev could not be checked for its correctness. Falling back to direct link creation.
The link %s should have been created by udev but it was not found. Falling back to direct link creation.
Couldn't create path for volume group dir %s
Couldn't create source pathname for logical volume link %s
Couldn't construct name of volume group directory.
No space to stack fs operation
locking/external_locking.c
locking_init
lock_resource
reset_locking
locking_end
query_resource
External locking already initialised
Shared library %s does not contain locking functions
WARNING: %s: _query_resource() missing: Using inferior activation method.
Loaded external locking library %s
misc/sharedlib.c
Opening shared %s library %s
Not loading shared %s library %s in static mode.
Unable to open external %s library %s: %s
%s%d
offset = %ld
mda%d
cache/lvmetad.c
<missing>
reason
devices_alternate
vgid
vgname
label_sector
ba%d
/run/lvmetad.pid
LVM_LVMETAD_PIDFILE
lvmetad_socket_present
filter:%u
update in progress
pv_clear_all
clear info about all PVs
token = %s
token_mismatch
expected
<NONE>
token_update
vg_remove
remove VG
Asking lvmetad for PV %s
pv_lookup
lookup PV
physical_volume
Asking lvmetad for PV on %s
device = %ld
pv_list
list PVs
vg_list
list VGs
volume_groups
vg_list no name found.
dev_size = %ld
label_sector = %ld
format = %s
vgname = %s
pvmeta = %t
pv_found
metadata = %t
update PV
seqno_after
seqno_before
vg_update
update VG
name unknown
Asking lvmetad for VG %s (%s)
vg_lookup
Asking lvmetad for VG %s
lookup VG
metadata/format
metadata/physical_volumes
metadata/outdated_pvs
vg_invalid
VG metadata comparison failed
pv_gone
drop PV
lvmetad message failed.
vgid = %s
vg_clear_outdated_pvs
get_global_info
global_invalid
global_invalid = %d
set_global_info
Request to %s %s%sin lvmetad gave response %s.
Request to %s %s%sin lvmetad did not find any matching object.
Request to %s %s%sin lvmetad gave response %s. Reason: %s
PV %s not recognised. Is the device missing?
WARNING: Device for PV %s not found or rejected by a filter.
Missing or ill-formatted PVID for PV: %s.
Duplicate of PV %s dev %s exists on unknown device %ld:%ld
No PV label found on duplicate device %s.
device %d:%d open to update udev
_update_pv_in_udev no dev found
WARNING: lvmetad is running but disabled. Restart lvmetad before enabling it!
Internal error: Refreshing lvmetad global handle while connection with the daemon is active
WARNING: Failed to connect to lvmetad. Falling back to internal scanning.
Successfully connected to lvmetad on fd %d.
WARNING: Failed to set lvmetad token. Out of memory?
WARNING: Ignoring obsolete format of metadata (%s) on device %s when using lvmetad
Update of lvmetad failed. This is a serious problem.
  It is strongly recommended that you restart lvmetad immediately.
Telling lvmetad to clear its cache
Sending updated token to lvmetad: %s
Telling lvmetad to remove VGID %s (%s)
Asking lvmetad for complete list of known PVs
Asking lvmetad for complete list of known VG ids/names
Telling lvmetad to store PV %s (%s) in VG %s
Telling lvmetad to store PV %s (%s)
WARNING: Inconsistent metadata found for VG %s
Skip pvscan activation for lockd type VG %s
Request to %s %s in lvmetad gave status %s.
Internal error: VG update without precommited
Sending lvmetad updated metadata for VG %s (seqno %u)
Internal error: VG name required (VGID not available)
Internal error: metadata config node not found.
Internal error: We do not know the format (%s) reported by lvmetad.
Rescan VG %s because including shared
Rescan VG %s because no lvmlockd lock is held
Rescan VG %s because lvmetad returned invalid
Failed to find cached info for PV %s.
VG export to config tree failed
VG import from config tree failed
Failed to update lvmetad with new VG meta
Update invalid lvmetad cache for VG %s
VG %s from lvmetad not found during rescan.
Asking lvmetad for complete list of known VGs
Telling lvmetad to forget any PV on %s
pv_cache_list allocation failed.
clear the list of outdated PVs
Internal error: validate global cache without lvmlockd
Validating global lvmetad cache
lvmetad_validate_global_cache get_global_info error %d
lvmetad_validate_global_cache get_global_info not ok
lvmetad_validate_global_cache set_global_info error %d
lvmetad_validate_global_cache set_global_info not ok
device %d:%d changed pvid from %s to %s
device %d:%d changed vg from %s to %s
device %d:%d pvid %s vg %s is gone
<empty>
lvmpolld/lvmpolld-client.c
lvname = %s
lvid = %s
cmdline = %s
interval = %s
Failed to create %s request.
abort = %d
handle_missing_pvs = %d
sysdir = %s
 abort
progress_info
in_progress
finished
signal
value
not_found
lvmpolld failed to process a request. The reason was: %s.
lvmpolld couldn't handle a request. It might be due to daemon internal state. The reason was: %s.
Unexpected response %s. The reason: %s.
For more information see lvmpolld messages in syslog or lvmpolld log file.
Interval string conversion got truncated.
Failed to process request with error %s (errno: %d).
Sucessfully connected to lvmpolld on fd %d.
WARNING: Failed to connect to lvmpolld. Proceeding with polling without using lvmpolld.
WARNING: Check global/use_lvmpolld in lvm.conf or the lvmpolld daemon state.
Internal error: Use of lvmpolld requires uuid set
Internal error: Use of lvmpolld requires vgname set
Internal error: Use of lvmpolld requires lvname set
Asking lvmpolld for pvmove%s on %s/%s.
Asking lvmpolld for mirror conversion on %s/%s.
Asking lvmpolld for snapshot merge on %s/%s.
Asking lvmpolld for thin snapshot merge on %s/%s.
Internal error: Unsupported poll operation.
Internal error: Unsupported poll operation
Internal error: use of lvmpolld requires uuid being set
Asking lvmpolld for progress status of an operation on %s/%s.
Failed to create progress_info request.
No polling operation in progress regarding LV %s.
Command executed by lvmpolld got terminated by signal (%d).
LVM command run by lvmpolld responded with: 'No such command.'
LVM command run by lvmpolld failed due to invalid parameters.
LVM command executed by lvmpolld failed.
lvmpolld failed to duplicate file descriptors.
lvmpolld failed to exec() lvm binary.
lvmpolld responded with unexpected return code.
Polling finished successfully.
lockd_result reply error %d
locking/lvmlockd.c
lockd_result bad response
lockd_result no op_result
result_flags
NO_LOCKSPACES
NO_GL_LS
DUP_GL_LS
WARN_GL_REMOVED
pid = %d
cmd = %s
lv_lock_args = %s
vg_lock_args = %s
vg_lock_type = %s
lv_uuid = %s
lv_name = %s
vg_name = %s
opts = %s
mode = %s
lvmlockd %s %s result %d %x
init_vg
VG %s init failed: %d
vg_lock_args
Failed to create internal lv.
/run/lvmlockd.pid
Failed to refresh %s.
find_free_lock
Unknown lock_type.
free_vg
start_vg
host_id = %d
vg_uuid = %s
VG %s starting %s lockspace
VG %s start failed: %d
lockd stop VG %s lock_type %s
stop_vg
VG %s stop failed: %d
start_wait
Lock start failed
lockd global lock_type %s
Unknown lock-gl mode
lock_gl
Retrying %s global lock
Enabling sanlock global lock
Global lock failed: error %d
lockd global mode %s
Global lock failed: error %d.
lockd VG %s mode %s
lock_vg
Retrying %s lock on VG %s
VG %s lock failed: removed
VG %s lock skipped: error %d
VG %s lock failed: error %d
lock_lv
Locking failed for LV %s/%s
Refresh lvmlock
Failed to unlock LV %s/%s.
init_lv
lv_lock_args
lv_lock_args not returned
free_lv
_free_lv lvmlockd result %d
rename_vg_before
rename_vg_final
running_lm
lvmlockd found sanlock
lvmlockd found dlm
lockd_result %d flags %s lm %s
Failed to deactivate sanlock lv %s/%s
Failed to activate sanlock lv %s/%s
Failed to remove sanlock LV %s/%s
lvmlockd %s %s vg %s lv %s result %d %x
lvmlockd %s %s vg %s result %d %x
lvmlockd %s %s failed no result
Failed to create sanlock lv %s in vg %s
VG %s init failed: lvmlockd not available
VG %s init failed: invalid parameters for sanlock
VG %s init failed: lock manager sanlock is not running
VG %s init failed: lock manager sanlock is not supported by lvmlockd
VG %s init failed: no disk space for leases
VG %s init failed: lock_args not returned
VG %s init failed: lock_args alloc failed
VG %s init failed: vg_write vg_commit
Should not initialize lvmlockd with use_lvmlockd=0.
WARNING: lvmlockd socket location is not configured.
WARNING: lvmlockd process is not running.
Should not connect to lvmlockd with use_lvmlockd=0.
lvmlockd is already connected.
Successfully connected to lvmlockd on fd %d.
WARNING: lvmlockd connect failed.
Extend LV %s/%s to size %llu failed.
VG %s init failed: invalid parameters for dlm
VG %s init failed: lock manager dlm is not running
VG %s init failed: lock manager dlm is not supported by lvmlockd
_free_vg_dlm lvmlockd result %d
VG %s start failed: lvmlockd is not enabled
VG %s start failed: lvmlockd is not running
lockd start VG %s lock_type %s
VG %s start failed: lvmlockd not available
VG %s start error: already started
VG %s start failed: invalid parameters for %s
VG %s start failed: invalid sanlock host_id, set in lvmlocal.conf
VG %s start failed: lock manager %s is not running
VG %s start failed: lock manager %s is not supported by lvmlockd
VG %s stop failed: LVs must first be deactivated
lockd_stop_vg deactivate sanlock lv
Cannot create VG with lock_type %s without lvmlockd.
Global lock failed: check that lvmlockd is running.
Global lock failed: start existing sanlock VGs to access global lock.
(If all sanlock VGs are started, enable global lock with lvmlockctl.)
Global lock failed: check that VG holding global lock exists and is started.
Global lock failed: check that global lockspace is started.
Global lock failed: lockspace is starting.
Global lock failed: held by other host.
VG create failed: lock manager %s is not supported by lvmlockd.
Exclusive locks are not allowed with readonly option.
Reading without shared global lock.
Global lock failed: lockspace is starting
Global lock failed: check that global lockspace is started
Global lock failed: storage errors for sanlock leases
Global lock failed: storage failed for sanlock leases
Skipping global lock: lockspace is starting
Skipping global lock: storage %s for sanlock leases
Skipping global lock: lockspace not found or started
Duplicate sanlock global locks should be corrected
VG %s unlock skipped: lockd_state is failed
VG %s lock skipped: lock start in progress
VG %s lock failed: lock start in progress
VG %s lock skipped: storage %s for sanlock leases
VG %s lock failed: storage %s for sanlock leases
Duplicate sanlock global lock in VG %s
LV locks are not allowed with readonly option.
Shared activation not compatible with LV type: %s/%s
lockd LV %s/%s mode %s uuid %s
LV locked by other host: %s/%s
LV %s/%s lock failed: lockspace is inactive
LV %s/%s lock failed: storage %s for sanlock leases
LV %s/%s lock failed: error %d
LV in VG %s with lock_type %s requires lvmlockd.
Lock on incorrect thin lv type %s/%s
Cannot find thin pool for %s/%s
LV %s/%s must be inactive on all hosts.
Cannot change VG %s with active LVs
Global lock failed: global lock was lost by removing a previous VG.
_free_vg_sanlock %s no lock_args
Lockspace for "%s" not stopped on other hosts
_free_vg_sanlock lvmlockd result %d
VG %s held the sanlock global lock, enable global lock in another VG.
Lock already exists for LV %s/%s
No sanlock space for lock for LV %s/%s
_init_lv_sanlock lvmlockd result %d
lv_lock_args allocation failed
lockd_init_lv: unknown lock_type.
Use lvconvert for cache with lock type %s
Failed to find origin LV %s/%s
Failed to lock origin LV %s/%s
Failed to find thin pool %s/%s
Failed to lock thin pool %s/%s
Create thin pool and thin LV separately with lock type %s
Unknown thin options for lock init.
lockd_free_lv: unknown lock_type.
LVs must be inactive before vgrename.
Cannot rename VG %s with active LVs
lockd_rename_vg_before lvmlockd result %d
lockd_rename_vg_before deactivate sanlock lv
Failed to restart VG %s lockspace.
lockd_rename_vg_final lvmlockd result %d
Failed to start VG %s lockspace.
Failed to get result from lvmlockd
lvmlockd found multiple lock managers, use --lock-type to select one.
lvmlockd found no lock manager running.
Failed to find a running lock manager.
datastruct/btree.c
device/dev-ext.c
%s %s [%s:%p]
Failed to get external handle for device %s [%s].
External handle attached to device
Failed to release external handle for device %s [%s:%p].
External handle detached from device %s [%s:%p]
Failed to enable external handle for device %s [%s].
Failed to disable external handle for device %s [%s].
%s/dev/block/%d:%d/md/%s
dm_snprintf md %s failed
device/dev-md.c
%s/block/md%d/md/%s
dm_snprintf old md %s failed
Device %s %s is %lu bytes.
Device %s %s is %s.
raid%d
raid_disks
Device %s %s is %d.
%s sysfs attr %s not in expected format: %s
Internal error: Missing hook for MD device recognition using external device info source %s
Device %s has an unknown md raid level: %d
Device %s stripe-width is %lu bytes.
device/dev-swap.c
SWAP-SPACE
SWAPSPACE2
S1SUSPEND
S2SUSPEND
ULSUSPEND
importing unknown segment
unknown/unknown.c
Failed to allocate memory for unknown segtype
format_text/archive.c
<No description>
File:		%s
Unable to read archive file.
VG name:    	%s
Description:	%s
Backup Time:	%s
%s/%s_%05u-%d.vg
Archive file name too long.
Expiring archive %s
Archive rename failed for %s
No archives found in %s.
Archive file %s not found.
Couldn't create text instance object.
Couldn't scan the archive directory (%s).
Couldn't create new archive file.
Couldn't create temporary archive name.
Couldn't create FILE object for archive.
%s/A_%s
locking/file_locking.c
%s/P_%s
%s/V_%s
Unlocking LV %s%s%s
Locking LV %s (NL)
Locking LV %s (R)
Locking LV %s (PR) - ignored
Locking LV %s (W)%s
Locking LV %s (EX)
Too long locking filename %s/A_%s.
Too long locking filename %s/P_%s.
Too long locking filename %s/V_%s.
Path for locking_dir %s is invalid.
_undo_flock %s
misc/lvm-flock.c
Unlocking %s
flock
_drop_shared_flock %s.
_do_flock %s %c%c
Giving up waiting for lock.
Unrecognised lock type: %d
Locking %s %c%c
format1/disk-rep.c
Duplicate PV %s - using %s %s
Found %s in %sVG %s
Failed to read LV's from %s
Invalid PV structure size.
Failed to write VG data to %s
Too many uuids to fit on %s
lv_number %d too large
Failed to write extents to %s
Successfully wrote data to %s
Failed to write LV's to %s
Ignoring duplicate PV %s on %s
%s does not have a valid LVM1 PV identifier
format1: Unknown metadata version %d found on %s
Failed to read PV data from %s
%s is not a member of any format1 VG
Failed to read VG data from PV (%s)
%s is not a member of the VG %s
Failed to read PV uuid list from %s
Failed to read extents from %s
read_pvs_in_vg: dev_iter_create failed
Couldn't allocate temporary PV buffer.
Writing %s PV metadata to %s at %lu len %zu
Writing %s VG metadata to %s at %lu len %zu
Writing %s uuidlist to %s at %lu len %d
Couldn't zero lv area on device '%s'
Writing %s LV %s metadata to %s at %lu len %zu
Failed to write PV structure onto %s
Failed to write PV uuid list to %s
Writing %s extents metadata to %s at %lu len %zu
Calculated uuid %s for %s
format_pool/disk_rep.c
pool read_vg
No devices for vg %s found in cache
Unable to allocate pool list structure
Internal error: device is missing
Unable to allocate %d 32-bit uints
Internal error: Bad format string '%s'
Internal error: Bad format string at '%s'
config-util.c
Failed to duplicate node key.
%.*s= %ld
%.*s= "%s"
%.*s%s
<Internal error: Daemon send: socket fd cannot be negative %d
Internal error: Daemon send: no memory available
%s: Opening daemon socket to %s for protocol %s version %d.
%s: Daemon socket path too long.
Daemon %s: requested protocol %s != %s
Daemon %s: requested protocol version %d != %d
Closing daemon socket (fd %d).
daemon-client.c
request = %s
connect
Sending daemon %s: hello
Daemon %s returned error %d
protocol
daemon_open
daemon_close
request
;*3$"
loop
ramdisk
device-mapper
dasd
dac960
cciss
ataraid
drbd
emcpower
power2
i2o_block
iseries/vd
gnbd
vdisk
ps3disk
virtblk
blkext
mtip32xx
vtms
bcache
nvme
zvol
devtype_name
DevType
devtype_max_partitions
MaxParts
devtype_description
Description
lv_uuid
LV UUID
lv_name
lv_full_name
lv_path
Path
lv_dm_path
DMPath
lv_parent
Parent
lv_attr
Attr
lv_layout
Layout
lv_role
Role
lv_initial_image_sync
InitImgSync
lv_image_synced
ImgSynced
lv_merging
Merging
lv_converting
Converting
lv_allocation_policy
AllocPol
lv_allocation_locked
AllocLock
lv_fixed_minor
FixMin
lv_merge_failed
MergeFailed
lv_snapshot_invalid
SnapInvalid
lv_skip_activation
SkipAct
lv_when_full
WhenFull
lv_active
Active
lv_active_locally
ActLocal
lv_active_remotely
ActRemote
lv_active_exclusively
ActExcl
lv_major
lv_minor
lv_read_ahead
Rahead
lv_size
LSize
lv_metadata_size
MSize
seg_count
#Seg
origin
Origin
origin_size
OSize
lv_ancestors
Ancestors
lv_descendants
Descendants
data_percent
Data%
snap_percent
Snap%
metadata_percent
Meta%
copy_percent
Cpy%Sync
sync_percent
Cpy%Sync
raid_mismatch_count
Mismatches
raid_sync_action
SyncAction
raid_write_behind
WBehind
raid_min_recovery_rate
MinSync
raid_max_recovery_rate
MaxSync
move_pv
Move
convert_lv
Convert
mirror_log
data_lv
Data
metadata_lv
Meta
pool_lv
Pool
lv_tags
LV Tags
lv_profile
LProfile
lv_lockargs
Lock Args
lv_time
Time
lv_host
Host
lv_modules
Modules
lv_kernel_major
KMaj
lv_kernel_minor
KMin
lv_kernel_read_ahead
KRahead
lv_permissions
LPerms
lv_suspended
Suspended
lv_live_table
LiveTable
lv_inactive_table
InactiveTable
lv_device_open
DevOpen
cache_total_blocks
CacheTotalBlocks
cache_used_blocks
CacheUsedBlocks
cache_dirty_blocks
CacheDirtyBlocks
cache_read_hits
CacheReadHits
cache_read_misses
CacheReadMisses
cache_write_hits
CacheWriteHits
cache_write_misses
CacheWriteMisses
lv_health_status
Health
pv_fmt
pv_uuid
PV UUID
dev_size
DevSize
pv_name
pv_mda_free
PMdaFree
pv_mda_size
PMdaSize
pe_start
1st PE
pv_size
PSize
pv_free
PFree
pv_used
Used
pv_attr
Attr
pv_allocatable
Allocatable
pv_exported
Exported
pv_missing
Missing
pv_pe_count
pv_pe_alloc_count
Alloc
pv_tags
PV Tags
pv_mda_count
#PMda
pv_mda_used_count
#PMdaUse
pv_ba_start
BA start
pv_ba_size
BA size
vg_fmt
vg_uuid
VG UUID
vg_name
vg_attr
Attr
vg_permissions
VPerms
vg_extendable
Extendable
vg_exported
Exported
vg_partial
Partial
vg_allocation_policy
AllocPol
vg_clustered
Clustered
vg_size
VSize
vg_free
VFree
vg_sysid
SYS ID
vg_systemid
System ID
vg_locktype
Lock Type
vg_lockargs
Lock Args
vg_extent_size
vg_extent_count
#Ext
vg_free_count
Free
max_lv
MaxLV
max_pv
MaxPV
pv_count
lv_count
snap_count
vg_seqno
vg_tags
VG Tags
vg_profile
VProfile
vg_mda_count
#VMda
vg_mda_used_count
#VMdaUse
vg_mda_free
VMdaFree
vg_mda_size
VMdaSize
vg_mda_copies
#VMdaCps
segtype
Type
stripes
#Str
stripesize
Stripe
stripe_size
Stripe
regionsize
Region
region_size
Region
chunksize
Chunk
chunk_size
Chunk
thin_count
#Thins
discards
Discards
cachemode
Cachemode
zero
Zero
transaction_id
TransId
thin_id
ThId
seg_start
Start
seg_start_pe
Start
seg_size
SSize
seg_size_pe
SSize
seg_tags
Seg Tags
seg_pe_ranges
PE Ranges
devices
Devices
seg_monitor
Monitor
cache_policy
Cache Policy
cache_settings
Cache Settings
pvseg_start
Start
pvseg_size
SSize
loop
ramdisk
device-mapper
dasd
dac960
cciss
ataraid
drbd
emcpower
power2
i2o_block
iseries/vd
gnbd
vdisk
ps3disk
virtblk
blkext
mtip32xx
vtms
bcache
nvme
zvol
thin-pool
thin
lvm.debug
7zXZ
P&Q\
0g/i
pu?$
w9w8u9
gT}r
zZv;u
n8gr& y
LeThn
7O!@
W	Y^#~I
9`\a
8|!z
EQ#A
S?5	E
0.fX
k`?u
f:\2
/,-d
))mR=j
_Tf.
~t'c/F1
iYg.J
KvZ2i
HRJe
W0O{
{bD@
/$BJ
cq*M#
AjmzP
)8zV
%OIp/
55rTd6
h,.r
y5q'
FBG5
SimW
5\LV
b!@;
6 AN
5+'Y
+/l"
M15k/
"ks=!
7@~?
3\ob
5 6Q
8M1|
Ywqw
;_s$
1~i3
{x%.IR;A9{
4:0s
)WG~#
$@4&a
l_Y%
k#A{
e0ZUI
.TXFz
>7a5
=bw>
7'	f
^Zy*&ah
<ZC~
K?hY
?r5\K
a6]L
3 8vf"
zZQOT
huOy1
ZSKN
FZE	
QW-@
RdaY
4rq#+
S}0xp
V;4k
{(I}
9>k2:
f}1e
PAd I>
*s:(e
EhyQ{
GI&v
\$sR
jhI$y
6%`dW
A^JAX
g%`i$R~!}
%/}f
FMD(%
p@rV
~=h[
O@aeg
~noS
v{;u
Z2Hy
tTdj
R1{)
>(;A"
wLqBm
P@-iJ9
	lg4
r&fd1
ELa_D
9/cHM
i5,_
f"HY	6+
m<a,
>|Fp
eFRs
9Z`t
;(cf
?4eo
v4S<~
{'b%
yJpq
p9X.
WSNklm
=.ql
{h}!7K0
N3D.%
.shstrtab
.interp
.note.ABI-tag
.note.gnu.build-id
.gnu.hash
.dynsym
.dynstr
.gnu.version
.gnu.version_r
.rela.dyn
.rela.plt
.init
.text
.fini
.rodata
.eh_frame_hdr
.eh_frame
.init_array
.fini_array
.jcr
.data.rel.ro
.dynamic
.got
.data
.bss
.gnu_debuglink
.gnu_debugdata
