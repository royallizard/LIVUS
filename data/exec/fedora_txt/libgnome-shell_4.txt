T$2e
`@@@
Bf(p
EB$ 
	z	<4$
m@6E
!H2(
(@@`0R
}:	;
m.,=
|lRR
L[k,
Q{|UQ
o<%Sv7y
<_ha@)~
-:$]
c"V[_
6zr?:b2
{}]XbP
-6YB
+0ED
\z+zTs
3vA|U
4&-6?
ESH)
z=xT
rv#g
w3G}
	Sp^
|>+:
[6|j:
[[#L
-bf	
-j-&
}`MC>77)^gr"
npq8;
_cAI'
P`Wt
?B6A
L$!O
X=tf
ZYl~
__gmon_start__
_ITM_deregisterTMCloneTable
_ITM_registerTMCloneTable
__cxa_finalize
_Jv_RegisterClasses
g_type_class_peek_parent
g_type_class_adjust_private_offset
meta_plugin_get_type
g_type_check_class_cast
shell_global_get
g_object_get
g_object_unref
__stack_chk_fail
_shell_wm_confirm_display_change
_shell_wm_filter_keybinding
_shell_wm_show_window_menu_for_rect
_shell_wm_show_window_menu
_shell_wm_hide_tile_preview
_shell_wm_show_tile_preview
_shell_wm_kill_switch_workspace
_shell_wm_kill_window_effects
_shell_wm_switch_workspace
_shell_wm_destroy
_shell_wm_size_change
_shell_wm_unminimize
_shell_wm_minimize
_shell_wm_map
gnome_shell_plugin_get_type
g_once_init_enter
g_intern_static_string
g_type_register_static_simple
g_once_init_leave
g_type_check_instance_cast
meta_is_wayland_compositor
_shell_global_check_xdnd_event
clutter_get_default_backend
clutter_backend_get_cogl_context
cogl_context_get_display
cogl_display_get_renderer
cogl_renderer_get_winsys_id
shell_perf_log_get_default
shell_perf_log_define_event
_shell_global_set_plugin
_shell_global_get_gjs_context
gjs_context_eval
meta_plugin_get_screen
clutter_x11_get_default_display
cogl_get_proc_address
meta_screen_get_screen_number
strstr
g_log
g_error_free
exit
clutter_micro_version
clutter_minor_version
clutter_major_version
meta_window_get_user_time
meta_window_showing_on_its_workspace
sd_journal_stream_fd
dup2
__errno_location
g_assertion_message_expr
meta_window_get_workspace
g_slist_prepend
g_signal_emit
g_return_if_fail_warning
shell_app_system_get_default
_shell_app_system_notify_app_state_changed
g_object_notify
meta_window_is_skip_taskbar
shell_app_get_type
g_signal_new
shell_app_state_get_type
g_param_spec_enum
g_object_class_install_property
g_param_spec_boolean
g_param_spec_string
g_action_group_get_type
g_param_spec_object
g_menu_model_get_type
g_desktop_app_info_get_type
g_type_check_instance_is_a
shell_org_gtk_application_proxy_new_finish
g_signal_connect_data
shell_org_gtk_application_get_busy
shell_app_get_id
g_app_info_get_type
g_app_info_get_id
shell_app_create_icon_texture
st_icon_new
st_icon_get_type
st_icon_set_icon_size
st_icon_set_fallback_icon_name
g_app_info_get_icon
st_icon_set_gicon
shell_global_get_stage
st_theme_context_get_for_stage
st_texture_cache_get_default
st_texture_cache_bind_cairo_surface_property
g_object_set
clutter_texture_new
shell_app_get_name
g_app_info_get_name
meta_window_get_wm_class
g_dpgettext
shell_app_get_description
g_app_info_get_description
shell_app_is_window_backed
shell_app_update_window_actions
meta_window_get_gtk_window_object_path
g_object_get_data
gtk_action_muxer_insert
meta_window_get_gtk_unique_bus_name
g_dbus_action_group_get
g_object_set_data_full
shell_app_can_open_new_window
g_action_group_has_action
g_desktop_app_info_has_key
meta_window_get_gtk_application_id
g_desktop_app_info_get_boolean
shell_app_get_state
shell_app_get_windows
shell_global_get_screen
meta_screen_get_active_workspace
g_slist_sort_with_data
shell_app_activate_window
g_slist_find
meta_screen_get_display
meta_display_get_last_user_time
meta_display_xserver_time_is_before
g_slist_copy
g_slist_reverse
g_slist_free
meta_window_foreach_transient
meta_display_sort_windows_by_stacking
meta_window_get_window_type
meta_workspace_activate_with_focus
meta_window_set_demands_attention
meta_window_raise
meta_window_activate
shell_app_get_n_windows
g_slist_length
shell_app_is_on_workspace
meta_workspace_index
shell_app_compare
_shell_app_new
g_object_new
_shell_app_set_app_info
g_object_ref
g_utf8_collate_key
g_type_name
g_value_get_object
shell_app_get_busy
g_value_set_object
g_value_set_enum
g_value_set_boolean
g_value_set_string
_shell_app_remove_window
g_signal_handlers_disconnect_matched
g_slist_remove
g_signal_handler_disconnect
g_cancellable_cancel
g_slice_free1
shell_app_get_pids
meta_window_get_pid
_shell_app_handle_startup_sequence
sn_startup_sequence_get_completed
sn_startup_sequence_get_timestamp
meta_display_focus_the_no_focus_window
sn_startup_sequence_get_workspace
shell_app_request_quit
shell_global_get_current_time
meta_window_delete
shell_app_launch_context
g_desktop_app_info_launch_uris_as_manager
shell_app_launch
shell_global_create_app_launch_context
shell_app_activate_full
g_dgettext
g_strdup_printf
shell_global_notify_error
g_clear_error
shell_app_activate
shell_app_open_new_window
shell_app_launch_action
g_desktop_app_info_launch_action
shell_app_get_app_info
shell_app_update_app_menu
g_strcmp0
meta_window_get_gtk_application_object_path
meta_window_get_gtk_app_menu_object_path
g_strdup
g_dbus_menu_model_get
_shell_app_add_window
g_object_freeze_notify
g_object_thaw_notify
g_slist_nth_data
g_cancellable_new
shell_org_gtk_application_proxy_new
g_slice_alloc0
g_bus_get_sync
gtk_action_muxer_new
_shell_app_new_for_window
meta_window_get_stable_sequence
shell_app_compare_by_name
strcmp
g_desktop_app_info_new
g_hash_table_remove_all
g_app_info_get_all
g_desktop_app_info_get_startup_wm_class
g_hash_table_lookup
g_hash_table_insert
g_list_free_full
g_hash_table_foreach_remove
g_hash_table_new_full
g_str_equal
g_str_hash
g_app_info_monitor_get
shell_app_system_get_type
g_type_add_instance_private
g_hash_table_destroy
shell_app_system_lookup_app
shell_app_system_lookup_heuristic_basename
g_strconcat
shell_app_system_lookup_desktop_wmclass
g_ascii_strdown
g_strdelimit
shell_app_system_lookup_startup_wmclass
g_warn_message
g_hash_table_remove
shell_app_system_get_running
g_hash_table_iter_init
g_hash_table_iter_next
g_slist_sort
shell_app_system_search
g_desktop_app_info_search
g_utf8_validate
g_data_output_stream_put_string
g_markup_escape_text
g_malloc0
strtoul
g_markup_error_quark
g_set_error
g_ascii_strtod
g_ascii_strtoull
g_file_read
g_markup_parse_context_new
g_markup_parse_context_parse
g_input_stream_read
g_markup_parse_context_free
g_input_stream_close
g_get_current_time
g_hash_table_iter_remove
shell_window_tracker_get_default
_shell_window_tracker_get_app_context
g_timeout_add_seconds
g_source_set_name_by_id
g_settings_get_boolean
g_source_remove
g_dbus_proxy_new_sync
g_build_filename
g_file_new_for_path
g_settings_new
shell_app_usage_get_type
g_variant_get
g_file_replace
g_output_stream_get_type
g_buffered_output_stream_new
g_data_output_stream_new
g_ascii_dtostr
g_output_stream_close_async
shell_app_usage_get_most_used
g_hash_table_get_keys
g_list_free
shell_app_usage_compare
shell_app_usage_get_default
g_getenv
g_file_test
g_get_user_data_dir
g_mkdir_with_parents
XDisplayName
g_get_user_runtime_dir
ca_gtk_context_get
setlocale
ca_context_change_props
ca_context_open
g_strsplit
gjs_context_get_type
g_strfreev
meta_screen_get_type
gdk_screen_get_type
g_param_spec_int
meta_display_get_type
clutter_actor_get_type
shell_wm_get_type
g_settings_get_type
st_focus_manager_get_type
meta_set_stage_input_region
clutter_stage_get_key_focus
meta_screen_set_cursor
ca_proplist_sets
clutter_event_type
clutter_event_get_position
ca_proplist_setf
clutter_event_get_button
g_file_get_child
g_variant_get_data
g_variant_get_size
g_file_replace_contents
g_file_delete
g_file_get_path
g_mapped_file_new
g_mapped_file_get_bytes
g_variant_type_checked_
g_variant_new_from_bytes
g_bytes_unref
g_mapped_file_unref
g_file_error_quark
g_error_matches
gtk_main_do_event
clutter_device_manager_get_default
clutter_device_manager_get_device
clutter_event_new
clutter_stage_get_type
gdk_keyval_to_unicode
clutter_event_put
clutter_event_free
meta_stage_is_focused
clutter_stage_set_key_focus
g_idle_add_full
cogl_flush
shell_perf_log_event
shell_global_get_type
g_value_get_string
g_value_get_boolean
g_value_init
gdk_screen_get_setting
clutter_settings_get_default
gdk_display_get_default
gdk_x11_display_set_window_scale
g_value_get_int
_shell_global_init
g_object_new_valist
shell_global_set_stage_input_region
g_malloc_n
XFixesCreateRegion
XFixesDestroyRegion
shell_global_get_gdk_screen
shell_global_get_display
shell_global_get_window_actors
meta_get_window_actors
meta_window_actor_is_destroyed
g_list_prepend
g_list_reverse
shell_wm_new
meta_display_get_xdisplay
gdk_x11_lookup_xdisplay
gdk_display_get_screen
meta_get_stage_for_screen
clutter_x11_get_stage_window
gdk_x11_window_foreign_new_for_display
st_im_text_set_event_window
st_entry_set_cursor_func
clutter_threads_add_repaint_func_full
gtk_settings_get_default
gdk_event_handler_set
st_focus_manager_get_for_stage
gdk_window_new
shell_global_begin_modal
meta_plugin_begin_modal
shell_global_log_structured
sd_journal_sendv_with_location
g_signal_emit_by_name
shell_global_init_xdnd
meta_get_overlay_window
gdk_x11_get_xatom_by_name
XChangeProperty
shell_global_get_pointer
meta_cursor_tracker_get_for_screen
meta_cursor_tracker_get_pointer
shell_global_get_settings
shell_global_get_overrides_settings
meta_display_get_current_time
clutter_get_current_event_time
meta_display_get_current_time_roundtrip
meta_focus_stage_window
meta_screen_focus_default_window
shell_global_end_modal
meta_plugin_end_modal
shell_global_reexec_self
g_file_get_contents
g_ptr_array_new
g_ptr_array_add
opendir
readdir
strtol
dirfd
fcntl
closedir
meta_display_unmanage_screen
execvp
g_strerror
g_ptr_array_free
getrlimit
sysconf
shell_global_sync_pointer
gdk_display_get_app_launch_context
gdk_app_launch_context_set_timestamp
gdk_app_launch_context_set_desktop
meta_screen_get_active_workspace_index
shell_global_begin_work
shell_global_end_work
shell_global_run_at_leisure
g_slice_alloc
g_slist_append
shell_global_play_theme_sound
ca_proplist_create
ca_context_play_full
ca_proplist_destroy
shell_global_play_theme_sound_full
shell_global_play_sound_file_full
shell_global_play_sound_file
shell_global_cancel_theme_sound
ca_context_cancel
XSendEvent
shell_global_get_session_mode
meta_screen_get_size
g_value_set_int
meta_get_window_group_for_screen
meta_get_top_window_group_for_screen
shell_global_set_runtime_state
shell_global_get_runtime_state
shell_global_set_persistent_state
shell_global_get_persistent_state
shell_embedded_window_get_type
clutter_clone_get_type
clutter_clone_set_source
_shell_embedded_window_set_actor
clutter_actor_queue_relayout
meta_window_get_xwindow
gtk_widget_get_type
gtk_widget_get_window
gdk_x11_window_get_xid
meta_window_get_compositor_private
clutter_actor_set_opacity
cairo_region_create
gdk_window_input_shape_combine_region
cairo_region_destroy
gdk_window_lower
shell_gtk_embed_get_type
_shell_embedded_window_unmap
_shell_embedded_window_map
clutter_actor_get_position
clutter_actor_get_anchor_point
clutter_actor_get_parent
_shell_embedded_window_allocate
gtk_widget_get_visible
gtk_widget_get_preferred_size
shell_gtk_embed_new
clutter_stage_capture
shell_util_composite_capture_images
cairo_surface_destroy
cairo_surface_reference
g_task_new
g_task_run_in_thread
meta_cursor_tracker_get_sprite
cairo_region_create_rectangle
cairo_region_contains_point
meta_cursor_tracker_get_hot
cogl_texture_get_width
cogl_texture_get_height
g_malloc
cogl_texture_get_data
cairo_image_surface_create_for_data
cairo_create
cairo_set_source_surface
cairo_paint
cairo_destroy
meta_screen_get_n_monitors
meta_screen_get_monitor_geometry
cairo_region_union_rectangle
cairo_region_xor
cairo_region_get_rectangle
cairo_rectangle
cairo_fill
cairo_region_num_rectangles
meta_display_get_focus_window
meta_window_get_frame_rect
meta_shaped_texture_get_type
meta_window_actor_get_type
meta_window_actor_get_texture
meta_shaped_texture_get_image
meta_window_frame_rect_to_client_rect
shell_screenshot_get_type
g_path_is_absolute
g_get_user_special_dir
g_get_home_dir
g_strrstr
g_strndup
g_file_create
cairo_image_surface_get_height
cairo_image_surface_get_width
gdk_pixbuf_get_from_surface
gdk_pixbuf_save_to_stream
g_task_return_boolean
g_task_get_type
g_task_propagate_boolean
meta_enable_unredirect_for_screen
shell_screenshot_screenshot
meta_disable_unredirect_for_screen
clutter_actor_queue_redraw
shell_screenshot_screenshot_area
shell_screenshot_screenshot_window
shell_screenshot_new
g_param_spec_uint
shell_tray_icon_get_type
na_tray_child_get_type
gtk_bin_get_type
gtk_bin_get_child
na_tray_child_get_title
na_tray_child_get_wm_class
gtk_socket_get_type
gtk_socket_get_plug_window
gtk_widget_get_display
gdk_error_trap_push
gdk_x11_get_xatom_by_name_for_display
gdk_x11_display_get_xdisplay
XGetWindowProperty
gdk_error_trap_pop
XFree
g_value_set_uint
shell_tray_icon_new
shell_tray_icon_click
gdk_window_get_display
gdk_window_get_screen
gdk_screen_get_root_window
gdk_window_get_origin
clutter_event_get_time
gdk_window_get_width
gdk_window_get_height
clutter_event_get_state
clutter_event_get_key_code
gdk_error_trap_pop_ignored
na_tray_manager_new
shell_embedded_window_new
gtk_container_get_type
gtk_container_add
gtk_widget_get_visual
gtk_widget_set_visual
gtk_widget_show_all
g_object_ref_sink
gtk_widget_destroy
clutter_color_get_type
g_param_spec_boxed
st_widget_get_theme_node
st_theme_node_get_icon_colors
na_tray_manager_set_colors
na_tray_child_has_alpha
cairo_pattern_create_rgb
gdk_window_set_background_pattern
cairo_pattern_destroy
shell_tray_manager_get_type
g_value_set_boxed
g_value_get_boxed
shell_tray_manager_new
shell_tray_manager_manage_screen
na_tray_manager_manage_screen
g_signal_stop_emission_by_name
shell_util_set_hidden_from_pick
g_object_set_data
shell_util_get_transformed_allocation
clutter_actor_get_abs_allocation_vertices
shell_util_format_date
g_date_time_new_from_timeval_local
g_date_time_format
g_date_time_unref
shell_util_get_week_start
nl_langinfo
shell_util_translate_time_string
strchr
shell_write_string_to_stream
g_output_stream_write_all
shell_get_file_contents_utf8_sync
g_io_error_quark
shell_util_wifexited
shell_util_create_pixbuf_from_data
gdk_pixbuf_new_from_data
shell_util_cursor_tracker_to_clutter
clutter_actor_show
clutter_texture_set_cogl_texture
clutter_actor_hide
shell_util_need_background_refresh
clutter_check_windowing_backend
shell_util_get_content_for_window_actor
clutter_canvas_new
clutter_canvas_get_type
clutter_canvas_set_size
clutter_content_invalidate
cairo_image_surface_get_format
cairo_image_surface_create
cairo_surface_get_device_scale
cairo_save
cairo_translate
cairo_restore
sn_startup_sequence_ref
shell_window_tracker_get_type
meta_screen_get_workspaces
shell_window_tracker_get_window_app
meta_window_get_transient_for
shell_window_tracker_get_app_from_pid
shell_window_tracker_get_startup_sequences
meta_screen_get_startup_sequences
shell_startup_sequence_get_type
sn_startup_sequence_unref
g_boxed_type_register_static
shell_startup_sequence_get_id
sn_startup_sequence_get_id
shell_startup_sequence_get_app
sn_startup_sequence_get_application_id
g_path_get_basename
meta_window_is_remote
meta_window_get_flatpak_id
meta_window_get_wm_class_instance
meta_window_get_startup_id
meta_window_get_group
meta_group_list_windows
g_direct_equal
g_direct_hash
meta_workspace_list_windows
shell_startup_sequence_get_name
sn_startup_sequence_get_name
shell_startup_sequence_get_completed
shell_startup_sequence_get_workspace
shell_startup_sequence_create_icon
sn_startup_sequence_get_icon_name
g_themed_icon_new
st_texture_cache_load_gicon
clutter_actor_set_size
meta_rectangle_get_type
meta_size_change_get_type
meta_window_get_type
meta_key_binding_get_type
g_signal_accumulator_true_handled
shell_wm_completed_switch_workspace
meta_plugin_switch_workspace_completed
shell_wm_completed_minimize
meta_plugin_minimize_completed
shell_wm_completed_unminimize
meta_plugin_unminimize_completed
shell_wm_completed_size_change
meta_plugin_size_change_completed
shell_wm_completed_map
meta_plugin_map_completed
shell_wm_completed_destroy
meta_plugin_destroy_completed
shell_wm_complete_display_change
meta_plugin_complete_display_change
fopen
__isoc99_fscanf
fgets
feof
fclose
gst_init
shell_recorder_src_register
gdk_screen_get_default
gst_element_get_clock
gst_element_get_base_time
gst_clock_get_time
gst_object_unref
gst_util_uint64_scale_int
cairo_image_surface_get_data
cairo_image_surface_get_stride
gst_buffer_new
gst_memory_new_wrapped
gst_buffer_insert_memory
shell_recorder_src_get_type
shell_recorder_src_add_buffer
gst_mini_object_unref
g_timeout_add
gst_buffer_map
gst_buffer_unmap
clutter_actor_get_allocation_box
_gst_fraction_type
gst_caps_new_simple
shell_recorder_get_type
shell_recorder_new
shell_recorder_set_draw_cursor
shell_recorder_set_area
shell_recorder_record
g_string_new
g_string_append_len
g_string_append_printf
g_string_append
g_string_free
gst_parse_launch_full
gst_bin_get_type
gst_bin_find_unlinked_pad
gst_element_factory_make
gst_bin_add
gst_element_link_many
gst_element_get_static_pad
gst_pad_link
g_date_time_new_now_local
g_printerr
gst_element_set_state
gst_pipeline_get_type
gst_pipeline_get_bus
gst_bus_add_watch
clutter_threads_add_repaint_func
g_string_insert_c
shell_recorder_close
gst_event_new_eos
gst_element_send_event
clutter_threads_remove_repaint_func
shell_recorder_set_framerate
shell_recorder_set_pipeline
g_signal_connect_object
shell_recorder_set_file_template
gtk_recent_manager_get_default
g_file_get_uri
gtk_recent_manager_add_item
gst_message_parse_error
shell_recorder_is_recording
g_dbus_method_invocation_get_type
g_cclosure_marshal_generic
g_strv_get_type
g_object_interface_install_property
g_value_unset
g_dbus_gvalue_to_gvariant
g_variant_new
g_dbus_proxy_get_type
g_dbus_proxy_call
g_variant_unref
g_dbus_proxy_call_finish
g_quark_to_string
g_mutex_init
g_main_context_ref_thread_default
g_value_get_variant
g_value_get_uchar
g_value_get_int64
g_value_get_uint64
g_value_get_double
memcmp
g_value_get_uint
g_variant_equal
g_strv_length
g_dbus_proxy_get_cached_property
g_dbus_gvariant_to_gvalue
shell_org_gtk_application_interface_info
g_dbus_proxy_set_interface_info
shell_org_gtk_application_override_properties
g_object_class_override_property
g_dbus_interface_skeleton_get_type
shell_org_gtk_application_get_type
g_type_interface_add_prerequisite
g_dbus_interface_info_lookup_signal
g_variant_n_children
g_malloc0_n
g_variant_iter_init
g_value_set_variant
g_variant_iter_next_value
g_signal_lookup
g_signal_emitv
g_type_interface_peek
shell_org_gtk_application_set_busy
shell_org_gtk_application_call_activate
shell_org_gtk_application_call_activate_sync
g_dbus_proxy_call_sync
shell_org_gtk_application_call_open
shell_org_gtk_application_call_open_finish
shell_org_gtk_application_call_activate_finish
shell_org_gtk_application_call_open_sync
shell_org_gtk_application_call_command_line
shell_org_gtk_application_call_command_line_finish
shell_org_gtk_application_call_command_line_sync
shell_org_gtk_application_complete_open
g_dbus_method_invocation_return_value
shell_org_gtk_application_complete_activate
shell_org_gtk_application_complete_command_line
shell_org_gtk_application_proxy_get_type
g_type_add_interface_static
g_variant_get_boolean
g_dbus_interface_info_lookup_property
g_quark_try_string
g_datalist_id_set_data_full
g_variant_iter_next
g_variant_iter_free
g_datalist_clear
g_async_initable_new_async
shell_org_gtk_application_proxy_new_sync
g_initable_new
shell_org_gtk_application_proxy_new_for_bus
shell_org_gtk_application_proxy_new_for_bus_finish
g_async_result_get_source_object
g_async_initable_get_type
g_async_initable_new_finish
shell_org_gtk_application_proxy_new_for_bus_sync
shell_org_gtk_application_skeleton_get_type
g_mutex_lock
g_mutex_unlock
g_object_class_find_property
g_object_set_property
g_dbus_error_quark
g_object_get_property
g_dbus_method_invocation_get_method_info
g_unix_fd_list_get_type
g_dbus_method_invocation_get_message
g_dbus_message_get_unix_fd_list
g_dbus_method_invocation_return_error
g_variant_builder_init
g_variant_builder_add
g_variant_ref_sink
g_dbus_interface_skeleton_get_connections
g_dbus_interface_skeleton_get_object_path
g_dbus_connection_emit_signal
g_variant_builder_clear
g_source_destroy
g_dbus_interface_skeleton_get_connection
g_variant_take_ref
g_variant_builder_end
g_idle_source_new
g_source_set_priority
g_source_set_callback
g_source_set_name
g_source_attach
g_source_unref
g_value_copy
g_object_notify_by_pspec
g_main_context_unref
g_mutex_clear
shell_org_gtk_application_skeleton_new
g_enum_register_static
shell_snippet_hook_get_type
shell_action_mode_get_type
g_flags_register_static
shell_network_agent_response_get_type
shell_js_resources_get_resource
g_static_resource_get_resource
g_static_resource_init
g_static_resource_fini
gst_base_src_get_type
gst_base_src_set_format
gst_base_src_set_live
g_queue_new
g_cond_init
gst_element_get_type
gst_push_src_get_type
_gst_caps_type
gst_static_pad_template_get
gst_element_class_add_pad_template
gst_element_class_set_metadata
g_idle_add
g_cond_wait
g_queue_pop_head
gst_buffer_get_size
g_queue_foreach
g_queue_clear
g_cond_signal
gst_base_src_set_caps
gst_value_set_caps
gst_value_get_caps
gst_mini_object_copy
g_queue_free_full
g_cond_clear
gst_element_register
gst_mini_object_ref
g_queue_push_tail
shell_recorder_src_close
gst_plugin_register_static
gtk_window_get_type
g_type_class_peek
clutter_actor_is_realized
gtk_widget_map
clutter_actor_is_mapped
gtk_widget_get_realized
gdk_window_move_resize
gtk_widget_size_allocate
gtk_widget_unmap
g_hash_table_new
clutter_actor_get_first_child
clutter_actor_get_next_sibling
clutter_actor_paint
st_widget_get_type
st_widget_paint_background
clutter_actor_set_allocation
st_theme_node_get_content_box
st_theme_node_adjust_for_width
st_theme_node_adjust_preferred_height
st_theme_node_adjust_for_height
st_theme_node_adjust_preferred_width
shell_generic_container_get_type
clutter_container_get_type
shell_generic_container_get_n_skip_paint
g_hash_table_size
shell_generic_container_get_skip_paint
clutter_actor_is_visible
clutter_actor_has_allocation
st_theme_node_get_paint_box
clutter_paint_volume_set_origin
clutter_paint_volume_set_width
clutter_paint_volume_set_height
clutter_actor_get_clip_to_allocation
clutter_actor_get_transformed_paint_volume
clutter_paint_volume_union
shell_generic_container_set_skip_paint
shell_generic_container_allocation_get_type
clutter_allocation_flags_get_type
clutter_actor_box_get_type
clutter_paint_volume_set_from_allocation
shell_glsl_quad_get_type
clutter_actor_get_paint_opacity
cogl_pipeline_set_color4ub
cogl_get_draw_framebuffer
cogl_framebuffer_draw_rectangle
cogl_object_unref
cogl_pipeline_copy
cogl_pipeline_set_layer_null_texture
cogl_pipeline_new
cogl_pipeline_set_blend
shell_glsl_quad_add_glsl_snippet
cogl_snippet_new
cogl_pipeline_add_snippet
cogl_snippet_set_replace
cogl_pipeline_add_layer_snippet
shell_glsl_quad_get_uniform_location
cogl_pipeline_get_uniform_location
shell_glsl_quad_set_uniform_float
cogl_pipeline_set_uniform_float
clutter_effect_get_type
clutter_offscreen_effect_get_type
shell_invert_lightness_effect_get_type
clutter_actor_meta_get_type
clutter_actor_meta_get_enabled
clutter_feature_available
clutter_offscreen_effect_get_texture
cogl_pipeline_set_layer_texture
clutter_actor_meta_set_enabled
clutter_actor_meta_get_actor
shell_invert_lightness_effect_new
clutter_text_get_type
g_cclosure_marshal_VOID__VOID
g_ascii_table
g_type_check_value_holds
g_task_get_source_object
g_async_result_is_tagged
g_task_propagate_int
g_task_propagate_pointer
shell_keyring_prompt_get_type
gcr_prompt_get_type
g_task_set_source_tag
clutter_text_get_text
shell_keyring_prompt_new
shell_keyring_prompt_get_password_actor
shell_keyring_prompt_get_confirm_actor
shell_keyring_prompt_set_password_actor
shell_secure_text_buffer_new
clutter_text_set_buffer
shell_keyring_prompt_set_confirm_actor
g_value_dup_string
shell_keyring_prompt_complete
g_task_return_pointer
g_task_return_int
dcgettext
gcr_prompt_set_warning
shell_keyring_prompt_cancel
gcr_prompt_close
shell_menu_tracker_ref
shell_menu_tracker_new
gtk_menu_tracker_new
shell_menu_tracker_new_for_item_submenu
gtk_menu_tracker_new_for_item_submenu
shell_menu_tracker_destroy
gtk_menu_tracker_free
shell_menu_tracker_unref
shell_menu_tracker_get_type
g_mount_operation_get_type
shell_mount_operation_get_type
g_array_unref
g_array_ref
g_strdupv
shell_mount_operation_new
shell_mount_operation_get_show_processes_pids
shell_mount_operation_get_show_processes_choices
shell_mount_operation_get_show_processes_message
memcpy
shell_perf_log_get_type
shell_perf_log_set_enabled
g_get_monotonic_time
shell_perf_log_event_i
shell_perf_log_event_x
shell_perf_log_event_s
shell_perf_log_define_statistic
shell_perf_log_update_statistic_i
shell_perf_log_update_statistic_x
shell_perf_log_add_statistics_callback
shell_perf_log_collect_statistics
shell_perf_log_replay
g_value_set_int64
shell_perf_log_dump_events
shell_perf_log_dump_log
g_propagate_error
polkit_agent_listener_get_type
polkit_unix_user_get_uid
getpwuid_r
polkit_unix_user_get_type
g_list_remove
g_cancellable_disconnect
polkit_error_quark
g_task_return_new_error
g_list_foreach
g_list_length
shell_polkit_authentication_agent_get_type
g_list_copy
g_cancellable_connect
g_list_append
shell_polkit_authentication_agent_register
getpid
polkit_unix_session_new_for_process_sync
polkit_agent_listener_register
g_error_new
shell_polkit_authentication_agent_new
shell_polkit_authentication_agent_unregister
polkit_agent_listener_unregister
shell_polkit_authentication_agent_complete
clutter_text_buffer_get_type
shell_secure_text_buffer_get_type
g_utf8_offset_to_pointer
memmove
clutter_text_buffer_emit_deleted_text
gcr_secure_memory_realloc
clutter_text_buffer_emit_inserted_text
g_utf8_find_prev_char
g_utf8_strlen
gcr_secure_memory_strfree
st_widget_get_can_focus
clutter_actor_contains
clutter_actor_get_last_child
st_widget_navigate_focus
clutter_actor_grab_key_focus
clutter_actor_allocate
clutter_actor_get_preferred_height
clutter_actor_get_preferred_width
shell_stack_get_type
tp_asv_new
tp_base_client_get_type
tp_base_client_set_observer_recover
tp_base_client_add_observer_filter
tp_base_client_add_approver_filter
tp_base_client_add_handler_filter
g_hash_table_unref
shell_tp_client_get_type
shell_tp_client_set_observe_channels_func
shell_tp_client_set_approve_channels_func
shell_tp_client_set_handle_channels_func
nm_secret_agent_get_type
nm_connection_get_type
nm_setting_connection_get_type
nm_connection_get_setting
nm_setting_connection_get_uuid
secret_password_clear
secret_password_clear_finish
nm_secret_agent_error_quark
nm_secret_agent_delete_secrets
nm_setting_get_secret_flags
secret_service_search_finish
secret_item_get_secret
secret_item_get_attributes
secret_value_unref
secret_value_get
nm_connection_update_secrets
nm_connection_for_each_setting_value
nm_setting_get_name
nm_setting_connection_get_id
secret_attributes_build
secret_password_storev
nm_setting_vpn_get_type
nm_setting_vpn_foreach_secret
nm_setting_vpn_get_service_type
nm_connection_get_id
shell_network_agent_get_type
g_hash_table_replace
nm_setting_connection_get_connection_type
nm_connection_get_setting_by_name
nm_setting_enumerate_values
nm_connection_get_uuid
secret_service_search
dbus_g_type_get_map
g_value_take_boxed
nm_setting_wireless_get_type
nm_setting_wired_get_type
nm_setting_pppoe_get_type
nm_setting_wireless_security_get_type
nm_setting_802_1x_get_type
shell_network_agent_set_password
shell_network_agent_respond
nm_connection_duplicate
nm_secret_agent_save_secrets
g_param_spec_double
st_adjustment_get_type
g_value_set_double
st_adjustment_new
st_adjustment_get_value
st_adjustment_set_value
st_adjustment_clamp_page
st_adjustment_set_values
st_adjustment_get_values
st_adjustment_adjust_for_scroll_event
st_align_get_type
st_widget_popup_menu
st_get_align_factors
clutter_actor_allocate_align_fill
_st_actor_get_preferred_height
_st_actor_get_preferred_width
clutter_actor_destroy
st_bin_new
st_bin_set_child
clutter_actor_remove_child
clutter_actor_add_child
st_bin_get_child
st_bin_set_alignment
st_bin_get_alignment
st_bin_set_fill
g_value_get_enum
st_bin_get_fill
st_border_image_get_type
st_border_image_new
st_border_image_get_file
st_border_image_get_borders
st_border_image_equal
g_file_equal
clutter_child_meta_get_type
clutter_child_meta_get_actor
clutter_child_meta_get_container
clutter_actor_get_layout_manager
clutter_layout_manager_get_child_meta
st_box_layout_child_get_type
g_param_spec_get_name
clutter_box_layout_new
clutter_actor_set_layout_manager
clutter_box_layout_get_type
st_theme_node_get_length
clutter_box_layout_set_spacing
st_box_layout_get_type
st_scrollable_get_type
clutter_box_layout_get_orientation
clutter_box_layout_get_pack_start
clutter_actor_get_n_children
cogl_framebuffer_pop_matrix
cogl_framebuffer_push_rectangle_clip
cogl_framebuffer_pop_clip
cogl_framebuffer_push_matrix
cogl_framebuffer_translate
clutter_paint_volume_get_origin
cogl_matrix_translate
clutter_actor_box_get_size
clutter_layout_manager_get_preferred_width
clutter_layout_manager_get_preferred_height
st_box_layout_new
st_box_layout_set_vertical
clutter_box_layout_set_orientation
st_box_layout_get_vertical
st_box_layout_set_pack_start
clutter_box_layout_set_pack_start
st_box_layout_get_pack_start
clutter_actor_set_reactive
st_widget_set_track_hover
st_button_mask_get_type
g_param_spec_flags
st_widget_accessible_get_type
atk_object_get_type
st_widget_add_style_pseudo_class
st_button_get_type
st_theme_node_lookup_length
_st_set_text_from_style
clutter_event_get_device
clutter_grab_pointer
g_value_set_flags
st_button_new
st_button_new_with_label
st_button_get_label
atk_gobject_accessible_get_type
atk_gobject_accessible_get_object
st_button_set_label
st_widget_style_changed
clutter_text_set_text
st_button_get_button_mask
st_button_set_button_mask
st_button_get_toggle_mode
atk_object_set_role
st_button_set_toggle_mode
st_button_get_checked
st_button_set_checked
st_widget_remove_style_pseudo_class
clutter_event_get_event_sequence
clutter_input_device_sequence_ungrab
clutter_input_device_sequence_grab
st_widget_get_hover
clutter_ungrab_pointer
g_value_get_flags
st_button_fake_release
gdk_x11_get_default_root_xwindow
XCreateSimpleWindow
XInternAtom
gdk_window_add_filter
gdk_x11_display_error_trap_push
XSync
gdk_x11_display_error_trap_pop
gdk_window_remove_filter
st_clipboard_get_type
st_clipboard_get_default
st_clipboard_get_text
XConvertSelection
st_clipboard_set_text
XSetSelectionOwner
clutter_actor_set_content
clutter_actor_get_content
st_drawing_area_get_type
clutter_cairo_clear
st_drawing_area_queue_repaint
st_drawing_area_get_context
st_drawing_area_get_surface_size
clutter_content_get_preferred_size
st_im_text_get_type
clutter_text_set_cursor_visible
clutter_text_delete_selection
clutter_text_get_cursor_position
clutter_text_insert_text
gtk_input_purpose_get_type
gtk_input_hints_get_type
st_theme_node_get_foreground_color
clutter_text_set_color
st_theme_node_lookup_color
st_theme_node_get_font
pango_font_description_to_string
clutter_text_get_font_name
clutter_text_set_font_name
clutter_text_set_selected_text_color
clutter_text_set_cursor_color
clutter_text_set_cursor_size
clutter_text_set_selection_color
clutter_text_get_buffer
clutter_text_buffer_delete_text
clutter_text_get_password_char
clutter_text_delete_text
clutter_text_get_selection
clutter_actor_get_text_direction
st_im_text_get_input_hints
st_im_text_get_input_purpose
clutter_text_get_editable
st_entry_get_type
clutter_actor_get_accessible
gdk_keymap_get_for_display
st_entry_new
st_entry_get_text
st_entry_set_text
clutter_actor_get_stage
st_entry_get_clutter_text
st_entry_set_hint_text
st_entry_get_hint_text
st_entry_set_input_purpose
st_im_text_set_input_purpose
st_entry_get_input_purpose
st_entry_set_input_hints
st_im_text_set_input_hints
st_entry_get_input_hints
st_entry_set_primary_icon
st_entry_set_secondary_icon
gdk_keymap_get_caps_lock_state
st_clipboard_type_get_type
st_texture_cache_policy_get_type
st_side_get_type
st_corner_get_type
st_text_decoration_get_type
st_text_align_get_type
st_gradient_type_get_type
st_icon_style_get_type
st_background_size_get_type
st_focus_manager_add_group
st_focus_manager_remove_group
st_focus_manager_get_group
st_focus_manager_navigate_from_event
st_generic_accessible_get_type
atk_value_get_type
st_generic_accessible_new_for_actor
atk_object_initialize
st_icon_colors_ref
st_icon_colors_unref
st_icon_colors_new
st_icon_colors_copy
st_icon_colors_get_type
clutter_bin_layout_new
g_icon_get_type
clutter_texture_get_type
clutter_texture_get_base_size
_st_create_shadow_pipeline_from_actor
clutter_actor_set_x_align
clutter_actor_set_y_align
st_widget_peek_theme_node
clutter_actor_get_opacity
st_shadow_unref
st_theme_node_get_shadow
_st_paint_shadow_with_opacity
st_icon_get_icon_name
g_themed_icon_get_type
g_themed_icon_get_names
st_icon_set_icon_name
g_themed_icon_new_with_default_fallbacks
g_icon_equal
st_icon_get_gicon
st_icon_get_icon_size
st_icon_get_fallback_icon_name
gtk_im_multicontext_new
clutter_text_buffer_get_text
clutter_text_buffer_get_bytes
gtk_im_context_set_surrounding
clutter_text_buffer_get_length
gtk_im_context_get_preedit_string
clutter_text_set_preedit_string
pango_attr_list_unref
clutter_actor_get_transformed_position
gtk_im_context_set_cursor_location
gtk_im_context_focus_out
gtk_im_context_focus_in
gtk_im_context_reset
gdk_event_new
gtk_im_context_filter_keypress
gdk_event_free
g_unichar_to_utf8
gtk_im_context_set_client_window
st_im_text_new
st_im_text_has_preedit
st_label_get_type
st_theme_node_get_text_shadow
st_label_new
st_label_get_text
st_widget_has_style_class_name
st_label_set_text
st_label_get_clutter_text
g_memdup
clutter_actor_get_request_mode
clutter_text_set_font_description
st_theme_node_get_text_decoration
clutter_text_set_attributes
st_theme_node_get_text_align
clutter_text_set_justify
clutter_text_set_line_alignment
pango_attr_list_new
pango_attr_strikethrough_new
pango_attr_list_insert
pango_attr_underline_new
_st_create_texture_pipeline
_st_create_shadow_pipeline
cogl_texture_2d_new_from_data
cogl_error_free
cogl_pipeline_set_layer_combine
cogl_texture_new_with_size
cogl_offscreen_new_with_texture
cogl_framebuffer_allocate
cogl_color_init_from_4ub
cogl_push_framebuffer
cogl_framebuffer_clear
cogl_framebuffer_orthographic
clutter_actor_set_opacity_override
cogl_pop_framebuffer
clutter_texture_get_cogl_texture
_st_create_shadow_cairo_pattern
cairo_pattern_get_surface
cairo_surface_set_user_data
cairo_pattern_create_for_surface
cairo_pattern_get_matrix
cairo_matrix_invert
cairo_matrix_translate
cairo_matrix_scale
cairo_pattern_set_matrix
cairo_pattern_create_rgba
st_shadow_get_box
cogl_color_premultiply
cogl_pipeline_set_layer_combine_constant
clutter_actor_set_name
clutter_actor_get_reactive
clutter_actor_transform_stage_point
clutter_actor_get_x
clutter_actor_get_y
clutter_animation_completed
clutter_animation_get_type
st_slow_down_factor
clutter_animation_bind
clutter_animation_get_timeline
clutter_timeline_start
clutter_actor_get_height
clutter_actor_get_width
st_scroll_bar_get_type
clutter_event_is_pointer_emulated
clutter_event_get_scroll_delta
st_scroll_bar_new
st_scroll_bar_set_adjustment
st_scroll_bar_get_adjustment
clutter_shader_effect_get_type
g_param_spec_float
st_scroll_view_fade_glsl
st_scroll_view_fade_get_type
st_scroll_view_get_type
st_scroll_view_get_vscroll_bar
st_scroll_view_get_hscroll_bar
clutter_actor_get_paint_box
clutter_shader_effect_set_uniform
clutter_shader_float_get_type
g_value_get_float
g_value_set_float
st_scroll_view_fade_new
g_type_interface_peek_parent
gtk_policy_type_get_type
st_scrollable_set_adjustments
clutter_actor_remove_effect
g_object_run_dispose
st_scroll_view_update_fade_effect
clutter_actor_add_effect_with_name
st_scroll_view_new
st_scroll_view_get_column_size
st_scroll_view_set_column_size
st_scroll_view_get_row_size
st_scroll_view_set_row_size
st_scroll_view_set_mouse_scrolling
st_scroll_view_get_mouse_scrolling
st_scroll_view_set_overlay_scrollbars
st_scroll_view_get_overlay_scrollbars
st_scroll_view_set_policy
st_scrollable_get_adjustments
st_shadow_ref
st_shadow_helper_copy
cogl_object_ref
st_shadow_helper_free
st_shadow_get_type
st_shadow_helper_get_type
st_shadow_new
st_shadow_equal
clutter_color_equal
st_shadow_helper_new
st_shadow_helper_update
clutter_actor_get_size
st_shadow_helper_paint
gtk_icon_theme_get_default
g_file_hash
g_str_has_prefix
g_file_get_type
g_object_weak_unref
gdk_pixbuf_get_pixels
gdk_pixbuf_get_rowstride
gdk_pixbuf_get_has_alpha
gdk_pixbuf_get_height
gdk_pixbuf_get_width
g_slist_free_full
g_hash_table_lookup_extended
gtk_icon_info_get_type
gtk_icon_info_load_icon_finish
gtk_icon_info_load_symbolic_finish
g_file_load_contents
gdk_pixbuf_loader_new
gdk_pixbuf_loader_write
gdk_pixbuf_loader_close
gdk_pixbuf_loader_get_pixbuf
gdk_pixbuf_apply_embedded_orientation
g_task_return_error
gdk_pixbuf_loader_set_size
gdk_pixbuf_new_subpixbuf
g_file_has_uri_scheme
g_file_monitor_file
cairo_surface_get_type
g_task_set_task_data
gtk_icon_info_load_symbolic_async
gtk_icon_info_load_icon_async
g_task_had_error
gdk_pixbuf_get_type
st_texture_cache_get_type
g_object_weak_ref
st_texture_cache_load
st_theme_node_get_icon_style
clutter_get_default_text_direction
gtk_icon_theme_lookup_by_gicon_for_scale
g_icon_to_string
st_texture_cache_load_sliced_image
clutter_actor_new
st_texture_cache_load_file_async
st_texture_cache_load_file_to_cogl_texture
st_texture_cache_load_file_to_cairo_surface
gdk_cairo_set_source_pixbuf
cairo_get_source
pango_font_description_from_string
st_theme_node_equal
st_theme_node_hash
st_theme_context_get_type
pango_font_description_free
st_theme_context_new
st_theme_context_set_theme
st_theme_get_type
st_theme_context_get_theme
st_theme_context_set_font
pango_font_description_equal
pango_font_description_copy
st_theme_context_get_font
st_theme_context_get_root_node
st_theme_node_new
st_theme_context_intern_node
g_hash_table_add
cairo_scale
cairo_arc
cairo_set_operator
cairo_set_source_rgba
cairo_line_to
cogl_handle_unref
cairo_append_path
cairo_clip
cairo_mask
cairo_path_extents
floor
ceil
cairo_transform
st_theme_node_get_border_image
st_theme_node_get_background_image_shadow
st_theme_node_get_box_shadow
st_theme_node_get_background_paint_box
cairo_format_stride_for_width
st_theme_node_get_border_color
st_theme_node_get_border_width
cairo_pattern_create_radial
cairo_pattern_add_color_stop_rgba
cairo_close_path
cairo_copy_path
cairo_set_source
cairo_path_destroy
st_theme_node_get_background_image
cairo_surface_get_content
cairo_matrix_init_identity
cairo_move_to
cairo_fill_preserve
cairo_matrix_init_translate
cairo_pattern_create_linear
cairo_pattern_set_extend
cogl_framebuffer_draw_rectangles
cogl_framebuffer_draw_textured_rectangle
st_theme_node_invalidate_border_image
st_theme_node_invalidate_background_image
st_theme_node_paint_state_set_node
st_theme_node_paint_state_init
st_theme_node_paint_state_free
st_theme_node_paint_state_copy
cogl_handle_ref
st_theme_node_paint
_st_theme_node_ensure_background
_st_theme_node_ensure_geometry
cogl_framebuffer_draw_textured_rectangles
st_theme_node_get_outline_width
st_theme_node_get_outline_color
cogl_framebuffer_clear4f
cogl_pipeline_set_layer_wrap_mode
st_theme_node_paint_state_invalidate
st_theme_node_transition_get_type
st_theme_node_transition_new
st_theme_node_get_type
st_theme_node_get_transition_duration
clutter_timeline_new
clutter_timeline_set_progress_mode
st_theme_node_transition_get_new_paint_state
st_theme_node_transition_update
clutter_timeline_get_direction
clutter_timeline_get_elapsed_time
clutter_timeline_set_duration
clutter_timeline_set_direction
clutter_timeline_stop
st_theme_node_transition_get_paint_box
st_theme_node_transition_paint
clutter_actor_box_equal
clutter_timeline_get_progress
cogl_color_init_from_4f
cogl_framebuffer_draw_multitextured_rectangle
cr_declaration_destroy
__strtok_r
_st_theme_get_matched_properties
_st_theme_parse_declaration_list
cr_rgb_set_from_term
cr_rgb_compute_from_percentage
st_theme_node_get_parent
st_theme_node_get_theme
st_theme_node_get_element_type
st_theme_node_get_element_id
st_theme_node_get_element_classes
st_theme_node_get_pseudo_classes
st_theme_node_get_color
st_theme_node_lookup_double
st_theme_node_lookup_time
st_theme_node_get_double
st_theme_node_lookup_url
_st_theme_resolve_url
st_theme_node_get_url
pango_font_description_get_size
pango_font_description_get_size_is_absolute
pango_font_description_set_family
pango_font_description_get_weight
pango_font_description_set_weight
pango_font_description_set_absolute_size
pango_font_description_set_variant
pango_font_description_set_style
clutter_backend_get_resolution
st_theme_node_get_background_color
st_theme_node_get_background_gradient
st_theme_node_get_border_radius
st_theme_node_get_width
st_theme_node_get_height
st_theme_node_get_min_width
st_theme_node_get_min_height
st_theme_node_get_max_width
st_theme_node_get_max_height
st_theme_node_get_padding
st_theme_node_get_margin
st_theme_node_get_horizontal_padding
st_theme_node_get_vertical_padding
_st_theme_node_apply_margins
clutter_actor_set_margin_left
clutter_actor_set_margin_right
clutter_actor_set_margin_top
clutter_actor_set_margin_bottom
st_theme_node_lookup_shadow
st_theme_node_geometry_equal
st_theme_node_paint_equal
st_theme_node_to_string
cr_stylesheet_unref
cr_om_parser_simply_parse_buf
cr_stylesheet_ref
g_type_from_name
g_type_is_a
g_slist_foreach
cr_cascade_unref
cr_cascade_new
cr_declaration_parse_list_from_buf
st_theme_load_stylesheet
st_theme_unload_stylesheet
st_theme_get_custom_stylesheets
st_theme_new
g_uri_parse_scheme
g_file_new_for_uri
g_file_get_parent
g_file_resolve_relative_path
cr_simple_sel_compute_specificity
cr_cascade_get_sheet
g_ptr_array_sort
atk_state_set_new
atk_role_get_type
clutter_actor_get_children
clutter_actor_box_from_vertices
cally_actor_get_type
g_object_add_weak_pointer
st_widget_get_theme
st_widget_get_style_class_name
st_widget_get_style_pseudo_class
st_widget_has_style_pseudo_class
atk_object_notify_state_change
st_widget_get_style
st_widget_get_track_hover
st_widget_set_can_focus
atk_state_set_remove_state
atk_state_set_is_empty
atk_state_set_or_sets
atk_state_set_add_state
st_describe_actor
clutter_actor_get_name
g_list_concat
g_strchug
clutter_layout_manager_allocate
clutter_actor_iter_init
clutter_actor_iter_next
st_widget_set_theme
st_widget_set_style_class_name
st_widget_add_style_class_name
st_widget_remove_style_class_name
st_widget_set_style_pseudo_class
st_widget_set_hover
st_widget_sync_hover
clutter_input_device_get_pointer_actor
st_widget_set_style
st_widget_ensure_style
st_set_slow_down_factor
st_get_slow_down_factor
st_widget_get_label_actor
atk_object_remove_relationship
atk_object_add_relationship
st_widget_set_label_actor
st_widget_set_accessible_name
st_widget_get_accessible_name
st_widget_set_accessible_role
st_widget_get_accessible_role
atk_object_get_role
st_widget_add_accessible_state
st_widget_remove_accessible_state
st_widget_set_accessible
g_object_remove_weak_pointer
st_widget_get_focus_chain
g_list_sort_with_data
g_list_delete_link
g_string_append_unichar
gdk_window_get_parent
gdk_window_get_visual
gtk_widget_set_app_paintable
gtk_widget_set_double_buffered
na_tray_child_new
gdk_screen_get_display
XGetWindowAttributes
gdk_x11_screen_lookup_visual
gdk_visual_get_red_pixel_details
gdk_visual_get_green_pixel_details
gdk_visual_get_blue_pixel_details
gdk_visual_get_depth
cairo_get_group_target
gdk_cairo_get_clip_rectangle
cairo_surface_flush
XClearArea
cairo_surface_mark_dirty_rectangle
na_tray_child_force_redraw
gtk_widget_get_mapped
gtk_widget_get_allocation
gdk_window_invalidate_rect
XGetClassHint
gtk_orientation_get_type
gtk_invisible_get_type
gdk_window_get_type
gdk_selection_owner_get_for_display
gdk_x11_get_server_time
gdk_selection_owner_set_for_display
g_list_remove_link
g_list_free_1
gtk_widget_get_toplevel
gtk_socket_add_id
gtk_widget_show
na_tray_manager_get_type
gdk_x11_screen_get_xscreen
gtk_invisible_new_for_screen
gtk_widget_realize
gtk_widget_add_events
gdk_screen_get_number
gdk_atom_intern
gdk_screen_get_rgba_visual
gdk_x11_visual_get_xvisual
XVisualIDFromVisual
gdk_x11_atom_to_xatom_for_display
gdk_screen_get_system_visual
na_tray_manager_check_running
XGetSelectionOwner
na_tray_manager_set_orientation
na_tray_manager_get_orientation
g_cclosure_marshal_VOID__BOOLEAN
g_type_class_add_private
gvc_channel_map_get_type
g_type_instance_get_private
gvc_channel_map_get_num_channels
pa_channel_map_valid
gvc_channel_map_can_balance
gvc_channel_map_can_fade
gvc_channel_map_get_mapping
pa_channel_map_to_pretty_name
gvc_channel_map_has_position
pa_channel_map_has_position
gvc_channel_map_get_volume
pa_cvolume_max
pa_cvolume_get_fade
pa_cvolume_get_position
pa_cvolume_get_balance
gvc_channel_map_get_pa_channel_map
gvc_channel_map_get_cvolume
gvc_channel_map_volume_changed
pa_cvolume_compatible_with_channel_map
pa_cvolume_equal
gvc_channel_map_new
gvc_channel_map_new_from_pa_channel_map
pa_channel_map_can_balance
pa_channel_map_can_fade
pa_cvolume_set
gvc_mixer_card_profile_compare
g_param_spec_ulong
g_param_spec_pointer
gvc_mixer_card_get_type
g_value_set_ulong
g_value_set_pointer
gvc_mixer_card_get_pa_context
gvc_mixer_card_get_index
gvc_mixer_card_get_id
gvc_mixer_card_get_name
gvc_mixer_card_set_name
gvc_mixer_card_get_icon_name
gvc_mixer_card_set_icon_name
gvc_mixer_card_get_profile
gvc_mixer_card_set_profile
g_value_get_ulong
g_value_get_pointer
pa_operation_unref
gvc_mixer_card_change_profile
pa_operation_cancel
pa_context_set_card_profile_by_index
gvc_mixer_card_get_profiles
gvc_mixer_card_get_ports
gvc_mixer_card_set_profiles
g_list_sort
gvc_mixer_card_get_gicon
gvc_mixer_card_set_ports
gvc_mixer_card_new
g_cclosure_marshal_VOID__UINT
pa_proplist_new
pa_proplist_sets
pa_context_new_with_proplist
pa_proplist_free
gvc_mixer_stream_get_name
gvc_mixer_stream_get_id
pa_proplist_gets
gvc_mixer_stream_set_icon_name
gvc_mixer_stream_set_is_event_stream
pa_ext_stream_restore_write
pa_context_errno
pa_strerror
g_utf8_collate
gvc_mixer_event_role_new
gvc_mixer_stream_set_name
gvc_mixer_stream_set_volume
gvc_mixer_stream_set_is_muted
pa_context_get_server_info
pa_context_get_card_info_by_index
pa_context_get_card_info_list
pa_context_get_client_info
pa_context_get_client_info_list
pa_context_get_sink_info_by_index
pa_context_get_sink_info_list
gvc_mixer_source_get_type
gvc_mixer_stream_get_ports
gvc_mixer_stream_get_card_index
g_hash_table_get_values
gvc_mixer_ui_device_get_id
gvc_mixer_stream_get_description
gvc_mixer_ui_device_get_description
gvc_mixer_ui_device_get_type
pa_context_get_source_info_by_index
pa_context_get_source_info_list
pa_context_get_sink_input_info
pa_context_get_sink_input_info_list
pa_context_get_source_output_info
pa_context_get_source_output_info_list
gvc_mixer_stream_get_type
gvc_mixer_control_get_type
g_main_context_default
pa_glib_mainloop_new
pa_glib_mainloop_get_api
pa_context_unref
pa_glib_mainloop_free
pa_context_get_state
pa_context_set_subscribe_callback
pa_context_subscribe
pa_ext_stream_restore_read
pa_ext_stream_restore_set_subscribe_cb
pa_ext_stream_restore_subscribe
pa_proplist_iterate
gvc_mixer_ui_device_set_profiles
dcngettext
gvc_mixer_stream_is_running
gvc_mixer_stream_set_description
gvc_mixer_stream_set_application_id
gvc_mixer_stream_set_is_virtual
gvc_mixer_sink_input_new
gvc_mixer_source_output_new
gvc_mixer_control_get_pa_context
gvc_mixer_control_get_event_sink_input
gvc_mixer_control_lookup_device_from_stream
gvc_mixer_stream_get_port
gvc_mixer_ui_device_get_port
gvc_mixer_control_set_default_sink
pa_context_set_default_sink
gvc_mixer_control_set_default_source
pa_context_set_default_source
gvc_mixer_control_get_default_sink
gvc_mixer_control_get_default_source
gvc_mixer_ui_device_invalidate_stream
gvc_mixer_ui_device_has_ports
gvc_mixer_ui_device_is_output
g_hash_table_find
gvc_mixer_control_lookup_stream_id
gvc_mixer_control_lookup_card_id
gvc_mixer_control_lookup_output_id
pa_channel_map_snprint
gvc_mixer_stream_set_card_index
gvc_mixer_stream_set_form_factor
gvc_mixer_stream_set_sysfs_path
gvc_mixer_stream_set_can_decibel
gvc_mixer_stream_set_base_volume
gvc_mixer_stream_set_port
gvc_mixer_ui_device_get_stream_id
gvc_mixer_sink_new
gvc_mixer_stream_set_ports
gvc_mixer_stream_get_channel_map
gvc_mixer_control_lookup_input_id
gvc_mixer_source_new
gvc_mixer_control_get_stream_from_device
gvc_mixer_control_change_profile_on_selected_device
gvc_mixer_ui_device_get_best_profile
gvc_mixer_ui_device_set_user_preferred_profile
gvc_mixer_control_change_output
gvc_mixer_stream_change_port
gvc_mixer_control_change_input
gvc_mixer_control_get_cards
g_hash_table_foreach
gvc_mixer_control_get_streams
gvc_mixer_control_get_sinks
gvc_mixer_control_get_sources
gvc_mixer_control_get_sink_inputs
gvc_mixer_control_get_source_outputs
gvc_mixer_control_get_state
gvc_mixer_control_set_headset_port
gvc_mixer_control_open
pa_context_set_state_callback
pa_context_connect
gvc_mixer_control_close
pa_context_disconnect
gvc_mixer_control_new
gvc_mixer_control_get_vol_max_norm
gvc_mixer_control_get_vol_max_amplified
pa_sw_volume_from_dB
gvc_mixer_stream_get_pa_context
gvc_mixer_event_role_get_type
gvc_mixer_stream_get_is_muted
gvc_mixer_stream_get_index
pa_context_set_sink_input_mute
pa_context_set_sink_input_volume
gvc_mixer_sink_input_get_type
pa_context_set_sink_mute_by_index
pa_context_set_sink_port_by_index
pa_context_set_sink_volume_by_index
gvc_mixer_sink_get_type
pa_context_set_source_output_mute
pa_context_set_source_output_volume
gvc_mixer_source_output_get_type
pa_context_set_source_port_by_index
pa_context_set_source_mute_by_index
pa_context_set_source_volume_by_index
g_param_spec_long
pa_sw_volume_to_dB
g_value_set_long
gvc_mixer_stream_port_get_type
gvc_mixer_stream_get_volume
gvc_mixer_stream_get_decibel
pa_cvolume_scale
gvc_mixer_stream_set_decibel
gvc_mixer_stream_get_can_decibel
gvc_mixer_stream_is_event_stream
gvc_mixer_stream_is_virtual
gvc_mixer_stream_get_application_id
gvc_mixer_stream_get_icon_name
gvc_mixer_stream_get_form_factor
gvc_mixer_stream_get_sysfs_path
gvc_mixer_stream_get_gicon
gvc_mixer_stream_get_base_volume
g_value_get_long
gvc_mixer_stream_push_volume
gvc_mixer_stream_change_is_muted
pa_operation_get_state
g_hash_table_contains
gvc_mixer_ui_device_get_matching_profile
gvc_mixer_ui_device_get_active_profile
gvc_mixer_ui_device_should_profiles_be_hidden
gvc_mixer_ui_device_get_profiles
gvc_mixer_ui_device_get_supported_profiles
gvc_mixer_ui_device_get_icon_name
gvc_mixer_ui_device_get_gicon
gvc_mixer_ui_device_get_origin
gvc_mixer_ui_device_get_user_preferred_profile
gvc_mixer_ui_device_get_top_priority_profile
g_list_last
libmutter.so.0
libgnome-shell-menu.so
libatk-bridge-2.0.so.0
libgjs.so.0
libmozjs-24.so
libgstbase-1.0.so.0
libgstreamer-1.0.so.0
libsoup-2.4.so.1
libstartup-notification-1.so.0
libgirepository-1.0.so.1
libcanberra-gtk3.so.0
libcanberra.so.0
libtelepathy-glib.so.0
libpolkit-agent-1.so.0
libpolkit-gobject-1.so.0
libgcr-base-3.so.1
libgck-1.so.0
libp11-kit.so.0
libsystemd.so.0
libnm-gtk.so.0
libnm-glib.so.4
libnm-util.so.2
libdbus-glib-1.so.2
libdbus-1.so.3
libsecret-1.so.0
libcroco-0.6.so.3
libxml2.so.2
libmutter-clutter-1.0.so
libpangoft2-1.0.so.0
libfontconfig.so.1
libfreetype.so.6
libudev.so.1
libinput.so.10
libxkbcommon.so.0
libgthread-2.0.so.0
libmutter-cogl-pango.so
libmutter-cogl-path.so
libjson-glib-1.0.so.0
libwayland-egl.so.1
libwayland-client.so.0
libXi.so.6
libmutter-cogl.so
libm.so.6
libgmodule-2.0.so.0
libgbm.so.1
libdrm.so.2
libwayland-server.so.0
libEGL.so.1
libX11.so.6
libXext.so.6
libXdamage.so.1
libXfixes.so.3
libXcomposite.so.1
libXrandr.so.2
libgtk-3.so.0
libgdk-3.so.0
libpangocairo-1.0.so.0
libpango-1.0.so.0
libatk-1.0.so.0
libcairo-gobject.so.2
libcairo.so.2
libgdk_pixbuf-2.0.so.0
libgio-2.0.so.0
libpulse-mainloop-glib.so.0
libpulse.so.0
libgobject-2.0.so.0
libglib-2.0.so.0
libpthread.so.0
libc.so.6
_edata
__bss_start
libgnome-shell.so
/usr/lib64/gnome-shell:/usr/lib64/mutter
LIBSYSTEMD_209
GLIBC_2.2.5
PULSE_0
GLIBC_2.4
GLIBC_2.7
GLIBC_2.14
TELEPATHY_GLIB_0.7.29
TELEPATHY_GLIB_0.11.5
TELEPATHY_GLIB_0.11.6
=QAF
ATUI
[]A\H
ATUA
[]A\
ATUA
[]A\H
ATUA
[]A\H
ATUI
[]A\
AUATUSH
([]A\A]
tOUSH
t7SH
AWAVAUATI
umM9
[]A\A]A^A_
[]A\A]A^A_
H9:t@
ATUA
[]A\
AUATUSH
[]A\A]
[]A\A]
AUATUSH
]A\A]
[]A\A]
AWAVAUATA
D$81
D$8dH3
H[]A\A]A^A_
T$ H
D$ H
L9,$t{D
ATUH
[]A\
E(t'H
ATUSL
C8[]A\
AVAUI
ATUH
 []A\A]A^
]A\A]A^
AUATA
[]A\A]
[]A\A]
[]A\A]
[]A\A]
[]A\A]
ATUSH
[]A\1
[]A\
ATUS
[]A\
AUATUSH
[]A\A]
[]A\A]
ATUSH
 []A\
AUATUS
[]A\A]
[]A\A]
AVAUA
ATUH
[]A\A]A^
AUATA
|$ H
[]A\A]
AVAUATUI
|$(H
D$(L
|$0L
]A\A]A^
[]A\A]A^
AUATUSH
[]A\A]
[]A\A]1
T$(I
|$0PM
D$@L
D$0L
D$ H
AWAVI
AUATUSH
[]A\A]A^A_1
AUAT1
%yXF
-A?F
[]A\A]
5wcF
ATUH
[]A\
AVAUI
ATUI
[]A\A]A^
[]A\A]A^
AUATUSH
[]A\A]
t3SH
t re
5	`F
AUATUS1
D$81
L$8dH3
H[]A\A]
AUATUSH
[]A\A]
ATUI
5?^F
5d8F
[]A\
AWAVI
AUATUSH
D$(1
d$ H
t$ L
L$(dH3
8[]A\A]A^A_
D$ I
AVAU1
ATUH
]A\A]A^
]A\A]A^1
AWAVH
AUATI
([]A\A]A^A_
[]A\A]A^A_
([]A\A]A^A_
AWAV1
AUATUSH
[]A\A]A^A_
T$ H
=dWF
l$ H
|$(H
\$0L
D$0H
AVAUI
ATUSH
t.[]A\A]A^
[]A\A]A^
AVAUATUH
+]XH
[]A\A]A^
\$ H
AUATI
j`dH
([]A\A]
ATUSH
5P.F
[]A\
=9RF
D$81
D$8dH3
;HHt
HHv!H
|$ H
T$ H
AWAVAUATUSH
D$HH
[]A\A]A^A_
t$hH
D$PH
D$@H
D$8H
D$0H
D$(f
t$(H
D$0I9
l$0H
T$0H
T$8H
D$@H
AWAVI
AUATUSH
([]A\A]A^A_
ATUI
[]A\
AWAVAUATI
[]A\A]A^A_
5`GF
j@j@E1
ATUI
[]A\
ATUSH
[]A\
AVAUI
ATUH
[]A\A]A^
F(H9G
AUATUSH
C0fA
l$0L
[]A\A]
zHSH
ulATUSL
=x=F
AVAUI
ATUH
 []A\A]A^
D$X[]A\A]A^
[]A\A]A^
[]A\A]A^
AUATI
D$(1
D$(dH3
8[]A\A]
t$(H
T$0H
L$8L
D$@L
L$Ht7
)D$P
)L$`
)T$p
D$ H
AUATUSH
[]A\A]1
[]A\A]
D$X1
D$XdH3
AWAVAUATSH
[A\A]A^A_]
ATUSH
s E1
s E1
_AXH
[]A\
ATUI
[]A\
{Ht#
AWAVI
AUATH
D$81
D$ H
D$8dH3
H[]A\A]A^A_
l$(H
D$X1
D$0f
D$HH
D$XdH3
AUATI
[]A\A]
AUATI
[]A\A]
[]A\A]
AUATI
([]A\A]
AWAVI
AUATM
d$`dH
([]A\A]A^A_
AWAVI
AUATM
d$`dH
([]A\A]A^A_
AUATI
([]A\A]
AVAUATUH
C I9
t3H;E t-1
[]A\A]A^
D$0 
d$8H
AUATA
[]A\A]
ATUI
#tQL
[]A\H
AWAVI
AUATH
[]A\A]A^A_
[]A\A]A^A_
AWAVI
AUATI
D$(1
l$$H
\D$ 
\D$$
D$(dH3
8[]A\A]A^A_
AVAUI
ATUI
 []A\A]A^
AVAUI
ATUI
 []A\A]A^
AVAUI
ATUH
 []A\A]A^
]A\A]A^
AUATI
([]A\A]
[]A\A]
AVAUH
ATUE
T$(1
D$(dH3
0[]A\A]A^
AWAVAUATUSH
[]A\A]A^A_
AWAVAUATI
D$81
T$,H
t$(1
t$(L
D$8dH3
H[]A\A]A^A_
T$4H
t$0H
T$(I
+T$0
D$,+D$4H
AWAVI
AUATI
D$X1
*D$@
*\$L
*T$H
*L$D
D$XdH3
h[]A\A]A^A_
AWAVAUATUSH
t$ dH
D$H1
t$0H
D$HdH3
X[]A\A]A^A_
AWAVAUATUSH
[]A\A]A^A_
[]A\A]A^A_
AVAUI
ATUSH
[]A\A]A^H
AUATH
[]A\A]1
[]A\A]
\$8E
l$0I
[]A\A]
AWAVAUATUSH
T$PH
[]A\A]A^A_1
[]A\A]A^A_
[]A\A]A^A_
AWAVI
AUATA
[]A\A]A^A_
[]A\A]A^A_H
[]A\A]A^A_
AUATUSH
D$81
T$0E1
T$0RH
T$0RH
T$$RH
T$8Rj
|$0H
D$8dH3
H[]A\A]
|$0H
AUATI
([]A\A]
[]A\A]
[]A\A]
AWAVAUATUSH
[]A\A]A^A_
\$0L
t$8H
AUATI
[]A\A]H
ATUL
[]A\1
ATUSH
AUATI
([]A\A]
[]A\A]H
AVAUI
ATUH
[]A\A]A^
 []A\A]A^
AUATI
[]A\A]
ATUI
D$81
D$8dH3
@[]A\
ATUI
[]A\E1
D$0E
AUATUSH
D$(1
T$(dH3
[]A\A]
AWAVA
AUATE
([]A\A]A^A_
ATUH
[]A\
ATUStOH
[]A\
[]A\
AWAVAUATUSH
XZE1
[]A\A]A^A_
AUATI
([]A\A]
[]A\A]
ATUI
[]A\H
[]A\
AUATUS
[]A\A]
ATUH
AWAVAUATI
|$ H
|$ L
[]A\A]A^A_1
[]A\A]A^A_
|$ L
AUAT1
[]A\A]1
[]A\
AUATUSH
AUATE1
UPE1
UPE1
([]A\A]
AUATH
[]A\A]
AWAVAUATUSH
[]A\A]A^A_
l$ H
|$0D
+K8+S4f
~xSH
G@PH
G<PH
AVAUI
ATU1
[]A\A]A^
$9CX
9S\u
AUATA
[]A\A]
[]A\A]
[]A\A]
[]A\A]
([]A\A]
;kht+
AVAUA
ATUA
u#[]A\A]A^H
}vA9
S8~V9
K<~'
t1[]A\A]A^H
[]A\A]A^
AWAVAUATI
D$(1
L$ 1
L$(dH3
8[]A\A]A^A_
D$ H
G(H9
tMUSH
tHUS
t:USH
t:USH
AVAUA
ATUI
A;Fh
[]A\A]A^H
I;Fp
[]A\A]A^H
]A\A]A^
]A\A]A^
]A\A]A^
]A\A]A^
 []A\A]A^
AVAUL
ATUE1
tYH;
[]A\A]A^
V@dH
AVAUATUSH
3jTH
jTj@I
PAUI
jTAVI
j@AUE1
[]A\A]A^
ATUSt'L
Z[]A\
Hc=@
ATUSH
dH34%(
 []A\
dH34%(
[]A\
AWAVH
AUATUSH
[]A\A]A^A_
ATUS1
XZ[]A\A]A^
AUATI
[]A\A]
AUATI
t$0H
[]A\A]
ATUI
[]A\
AUATI
[]A\A]
AUATI
t$0H
[]A\A]
AUATI
[]A\A]
ATUH
t$8L
[]A\
AWAVI
AUATL
([]A\A]A^A_
AWAVI
AUATI
QAWVH
AVW1
AURH
X[]A\A]A^A_
AWAVI
AUATI
AWVE
AVWH
[]A\A]A^A_
[]A\A]A^A_
AWAVI
AUATA
QAWVH
AVW1
AURH
X[]A\A]A^A_
ATUI
AWAVI
AUATA
AWVE
AVWH
[]A\A]A^A_
[]A\A]A^A_
AVAUM
ATUL
\$XL
t$PdH
 []A\A]A^
AUATM
\$PdH
([]A\A]
AWAVAUATUSL
L$ L
D$(I
D$PH
[]A\A]A^A_
L$ L
D$(H
AWAVAUATUSH
[]A\A]A^A_
AUATUSH
ZYt.H
[]A\A]
{ []
AWAVA
AUATI
[]A\A]A^A_
5MJE
5>JE
L92u
L92t\H
ATUI
{ []A\H
5-NE
5=ME
5]KE
AUATUSH
D$0H
D$ H
[]A\A]
ATUH
AVAUI
ATUSH
]A\A]A^
]A\A]A^
]A\A]A^
AUATI
[]A\A]
8[]A\A]
[]A\A]
AVAUI
ATUH
 []A\A]A^
[]A\A]A^
[]A\A]A^
ATUH
[]A\H
ATUSH
[]A\
ATUI
Z[]A\
AUATUSH
[]A\A]
[]A\A]
AWAVA
AUATA
([]A\A]A^A_
AUATI
([]A\A]
AWAVI
AUAT
[]A\A]A^A_
AWAVI
AUAT
[]A\A]A^A_
={}E
ATUSH
AUATI
D$81
L$8dH3
H[]A\A]
\$ H
\D$ L
\D$$
ATUA
C(t.H
[]A\H
[]A\
ATUSH
T$0H
Pj8E1
Pj8E1
UPE1
[]A\
5rxE
=pwE
ATUI
D$(1
Hc-&wE
D$(dH3
0[]A\
=GvE
AUATUSH
[]A\A]1
AUATUSH
[]A\A]
[]A\A]1
ATUSH
C0[]A\
C0[]A\
ATUSH
E([]A\
=(sE
AUATUSH
[]A\A]
[]A\A]
ATUH
*S([]A\
ATUH
5\pE
[]A\
AUATI
[]A\A]
[]A\A]
[]A\A]
AUATI
[]A\A]
[]A\A]
[]A\A]
ATUI
[]A\H
5#hE
[]A\1
ATUI
[]A\H
5?gE
[]A\1
AUATA
[]A\A]
[]A\A]
[]A\A]
[]A\A]
([]A\A]
ATUH
[]A\H
[]A\H
ATUH
[]A\H
[]A\H
AVAUA
ATUI
 []A\A]A^
[]A\A]A^
]A\A]A^
]A\A]A^
F8tzH
ATUSH
[]A\
[]A\
[]A\
[]A\
AWAVM
AUATI
D$XL
D$`H
D$hSH
[]A\A]A^A_
AWAVI
AUATI
D$PH
[]A\A]A^A_
=aYE
=+YE
=OWE
AVAUI
ATUI
[]A\A]A^
5&VE
AVAUI
ATUI
[]A\A]A^
[]A\A]A^
[]A\A]A^
"t:H
[]A\
[]A\
ATUI
[]A\E1
AUATI
[]A\A]
[]A\A]
AWAVAUATUSH
[]A\A]A^A_
[]A\A]A^A_
CPE1
AUATI
[]A\A]
[]A\A]
AWAVI
AUATI
[]A\A]A^A_
[]A\A]A^A_
=3OE
ATUSH
CH[]A\
[]E1
AUATI
[]A\A]
[]A\A]
uMATUSH
[]A\
[]A\
AUATI
[]A\A]
AVAUATUI
D$81
D$89X
L$(L)
[]A\A]A^
AWAVAUATUSH
_HdH
D$H1
D$(twH
l$0I
D$(E1
E;4$s;A
E;4$I
D$(H
D$(u
D$HdH3
X[]A\A]A^A_
D$ A
D$ I
D$ A
D$ I
D$ E
AWAVI
AUAT1
[]A\A]A^A_H
AVAUI
ATUI
 []A\A]A^
j@j@E1
j@j@E1
AWAVAUATI
\$@H
D$`L
|$(H
D$0H
|$01
L$(1
55BE
<$P1
[]A\A]A^A_
AUATA
e L9
5b1E
[]A\A]
[]A\A]
H;x t
=P?E
AWAVI
AUATI
D$pH
L$ H
T$(H
T$(H
L$ H
5L(E
8[]A\A]A^A_
[]A\A]A^A_
AUATI
D$(H
[]A\A]
=M<E
AWAVAUATI
|$0H
A)\$8
[]A\A]A^A_
AWAVA
AUATA
V0L)
^(v,
[]A\A]A^A_
=`7E
ATUA
uo[1
]A\H
AUATI
D$(1
D$(dH3
8[]A\A]
AWAVI
AUATI
D$(1
d$$H
D$(dH3
8[]A\A]A^A_
AWAVI
AUATI
D$(1
d$$H
D$(dH3
8[]A\A]A^A_
ATUI
=z.E
[]A\
Uj@E1
Pj@E1
AVAUI
XZ[]A\A]A^
ATUH
 []A\
AVAUI
ATUH
[]A\A]A^H
5@(E
AWAVAUATUSH
[]A\A]A^A_
AWAVI
AUAT1
T$0H
D$x1
D$ H
D$0H
l$8M
D$ I
D$xdH3
[]A\A]A^A_
\$PL
d$HH
l$@L
$taH
|$@L
|$(H
T$(H
ATUH
[]A\
[]A\
AWAVI
AUAT1
D$(1
D$(dH3
8[]A\A]A^A_
l$ M
Y^tnA
l$ H
l$ L
AUATI
[]A\A]
[]A\A]
[]A\A]H
AVAUATUI
]A\A]A^
ATUH
[]A\
AWAVI
AUATI
D$pL
D$xH
D$(1
t$$H
D$(dH3
8[]A\A]A^A_
AWAVAUATUSH
D$X1
|$(H
D$ H
D$(L
D$XdH3
h[]A\A]A^A_
AUATI
[]A\A]
[]A\A]
AWAVAUATA
[]A\A]A^A_
[]A\A]A^A_
.@ z
.@(z
AUATA
[]A\A]
([]A\A]
zBu@H
\H0f
.C0z
AVAUA
ATUI
]A\A]A^
]A\A]A^
]A\A]A^
]A\A]A^
]A\A]A^
]A\A]A^
 []A\A]A^
ATUI
[]A\
AWAVAUATUSH
D$ H
D$(H
[]A\A]A^A_
[]A\A]A^A_
AWAVI
AUATI
[]A\A]A^A_H
[]A\A]A^A_
AUATUSH
[]A\A]
AWAVAUATA
[]A\A]A^A_
[]A\A]A^A_1
AUATI
D$(1
D$(dH3
8[]A\A]
AUATI
[]A\A]
AUATI
[]A\A]
AUATA
[]A\A]
[]A\A]
[]A\A]
([]A\A]
AUATUSH
[]A\A]
Lc%i
,$L9
[]A\A]
[]A\A]
AUATA
[]A\A]H
Hc-y
[]A\A]
ATUI
u%[]A\H
[]A\
AUATA
[]A\A]H
[]A\A]
AWAVA
AUATI
[]A\A]A^A_
[]A\A]A^A_
[]A\A]A^A_
([]A\A]A^A_
ATUI
u%[]A\H
[]A\
AWAVA
AUATA
[]A\A]A^A_
AVAUI
ATUI
u#[]A\A]A^H
[]A\A]A^
M H9K t
M(H9K(u
ATUH
@H]A\
AWAVA
AUATI
[]A\A]A^A_
([]A\A]A^A_
AVAUA
ATUI
[]A\A]A^
ATUI
[]A\H
[]A\
ATUI
[]A\
ATUSH
[]A\
ATUI
[]A\
[]A\
ATUI
[]A\
ATUH
 []A\
t$$H
AUATI
[]A\A]
AWAVI
AUATUSH
D$81
.4$z@u>f
z6u4H
D$8dH3
H[]A\A]A^A_
T$ L
ZD$ f
ZT$(
ZL$$
Z\$,
\$,I
AVAUATUH
D$H1
l$ H
T$0L
L$0H
\D$ 
\D$,
D$<H
\D$4
L$HdH3
P[]A\A]A^
AVAUATUSH
D$81
.4$z=u;f
z3u1H
D$8dH3
@[]A\A]A^
T$ L
ZD$ f
ZT$(
ZL$$
Z\$,
\$,I
ATUH
[]A\
AWAVI
AUATA
D$X1
l$@L
T$,H
t$(L
L$4H
T$0H
D$(L
_D$0H
L$<H
T$8L
D$,f
D$(f
D$XdH3
h[]A\A]A^A_
AUATUSH
[]A\A]H
[]A\A]
[]A\A]
u![]A\H
[]A\H
[]A\
AVAUI
ATUH
D$(H
[]A\A]A^
]A\A]A^
 []A\A]A^
]A\A]A^
ATUI
[]A\
AVAUA
ATUI
[]A\A]A^
AWAVAUATI
L; tIL
[]A\A]A^A_
AVAUI
ATUH
[]A\A]A^
]A\A]A^
AUATA
[]A\A]
[]A\A]
[]A\A]
([]A\A]
AUATI
[]A\A]H
Hc-Q
t	L;(
[]A\A]
ATUSHc
[]A\
tuL;C
]A\1
AVAUI
ATUH
[]A\A]A^
AUATI
[]A\A]
[]A\A]
[]A\A]
AUATI
[]A\A]
[]A\A]
[]A\A]
AWAVI
AUATI
[]A\A]A^A_
[]A\A]A^A_
AVAUI
ATUH
]A\A]A^
]A\A]A^
]A\A]A^
 []A\A]A^
]A\A]A^
ATUH
[]A\
AUATUSH
D$H1
L$HdH3
X[]A\A]
2H9s u
k8L;-
s(E1
D$(H
T$0H
t$ H
D$@H
s(E1
 []A\
 []A\
AVAUATUH
D$(1
L$(dH3
0[]A\A]A^
H9E u
D$ H
D$ PH
D$ PH
D$(Pj
t$ A
|$ H
AUATI
[]A\A]
[]A\A]
AUATA
[]A\A]
[]A\A]
AVAUA
ATUH
 []A\A]A^
ATUI
[]A\
ATUI
[]A\
ATUH
[]A\
t1USH
[]Hc
ATUI
[]A\
H93t	
AWAVI
AUATUSH
([]A\A]A^A_
ATUH
tiHc
[]A\
<$Hc
AWAVI
AUATA
D$X1
T$ L
D$,M
\D$$
D$ H
XL$$
XD$0
D$0M
D$(H
XL$$
\D$0H
t$0D
XL$$
D$XdH3
h[]A\A]A^A_
AUATI
(Lc%~
([]A\A]
AUATI
([]A\A]
t$$H
AUATI
[]A\A]
ATUI
[]A\
tFHc
ATUSH
[]A\
ATUSH
[]A\
ATUH
@(]A\
ATUI
u []A\H
Hc-A
[]A\H
ATUH
[]A\H
t	[]A\
[]A\H
u![]A\H
[]A\H
[]A\
u![]A\H
[]A\H
[]A\
AVAUI
ATUH
]A\A]A^
]A\A]A^
]A\A]A^
 []A\A]A^
]A\A]A^
AUATI
[]A\A]
ATUI
[]A\
[]A\
AUATI
[]A\A]
5=KD
5=ID
5}HD
5=FD
5=DD
AWAVAUATUSH
F$=Q
tpH9
]A\A]A^A_
tI=	
[]A\A]A^A_
ATUI
[]A\H
ATUI
[]A\
ATUI
[]A\
ATUI
[]A\
ATUI
[]A\
j<E1
j<E1
j<E1
j<E1
St*H
5IwD
=c~D
ATUH
[]A\
ATUI
o(dH
;](t 
[]A\
_(dH
ATUH
[]A\H
[]A\
AUATUSH
_(dH
[]A\A]
ATUSH
CHt2
D$(1
D$(dH3
=AuD
H;(t
ATUI
u![]A\H
[]A\
t)[L
[]A\
C([H
ATUH
[]A\H
[]A\
[]A\
C(9h t7
H;(t
AUATI
[]A\A]
[]A\A]
[]A\A]
([]A\A]
ATUI
u![]A\H
[]A\
t%[L
[]A\
AVAUI
ATUH
]A\A]A^
]A\A]A^
]A\A]A^
 []A\A]A^
]A\A]A^
ATUH
AUATI
x;Hc
[]A\A]
ATUI
 []A\
[]Hc
ATUI
=HhD
ATUH
D$(1
D$(dH3
0[]A\
={fD
=_fD
AWAVAUATUSH
([]A\A]A^A_
$tiA
ATUH
=`aD
AUATI
[]A\A]
([]A\A]
[]A\A]
AVAUI
ATUH
]A\A]A^
 []A\A]A^
]A\A]A^
ATUH
5$[D
[]A\
=hYD
57YD
=@XD
AUATI
[]A\A]
AUATI
[]A\A]
AVAUATUI
 []A\A]A^
ATUH
D$(1
D$(dH3
0[]A\
="TD
AVAUI
ATUH
]A\A]A^
 []A\A]A^
]A\A]A^
ATUSH
[]A\
[]A\
[]A\H
AUATUSH
[]A\A]
[]A\A]
[]A\A]
AVAUI
ATUH
 []A\A]A^
]A\A]A^
C([H
AWAVAUATUSH
|$0H
|$ L
L$(L
D$TA
Ic?H
l$@A
l$@L
L$PH
D$(D
D$DLcD$
D$0Lc\$@E
\$8G
L$ 9
D9T$
D9d$P
D$0Hct$DE1
d$8L
D$XM
t$ I
\$ I
L$DL
}:f.
;D$(
D$8H
h[]A\A]A^A_
D$0A
h[]A\A]A^A_
L$PH
ATUI
 []A\
ATUI
 []A\
AUATUSH
[]A\A]
=CHD
AWAVAUATI
D$(1
L$(L
D$$D
D$(L
D$0Y^H
=hFD
T$(dH3
8[]A\A]A^A_
AVAUATUI
D$H1
t	H;(
l$ H
t$0E1
D$ H
L$HdH3
P[]A\A]A^
AWAVAUATUSH
D$X1
L$ L
54BD
|$ I
D+l$
\$XdH3
h[]A\A]A^A_
AVAUI
ATUI
D$(1
D$(dH3
0[]A\A]A^
AUATUSH
[]A\A]H
ATUI
ATUSHc
[]A\
5!<D
[]A\1
ATUH
[]A\
5);D
Hc-y:D
AUATUSH
D$H1
t$ H
{ Y^
C0v3
XD$(
\D$(
D$ H
l$0H
D$ H
L$HdH3
X[]A\A]
~@SH
ATUSH
[]A\
AUATI
D$x1
T$@H
D$@H
D$PH
t$PD
L$ H
D$0E1
D$(Xf
L$0H
L$8H
D$ f
\D$(f
d$Df
L$Hf
l$0f
D$lH
t$`D
D$xdH3
[]A\A]
l$0f
D$81
L$8dH3
L$(H
D$8E1
\$0H
\D$0
=P/D
ATUH
=X.D
AUATI
D$(L
([]A\A]
AUATI
[]A\A]
AUATI
D$(1
L$$H
XD$ 
XD$$
D$(dH3
8[]A\A]
_D$ 
_D$$
AUATI
D$(1
L$$H
_D$ 
_D$$
D$(dH3
8[]A\A]
XD$ 
XD$$
ATUI
[]A\
AUATI
[]A\A]
([]A\A]
[]A\A]
ATUI
u []A\H
[]A\H
[]A\
AVAUI
ATUI
u\Hc
]A\A]A^
 []A\A]A^
]A\A]A^
]A\A]A^
AWAVAUATI
t$pH
T$`L
\D$p
XD$`
\D$t
XD$d
\D$x
XD$h
\D$|
XD$l
D$,H
T$(H
D$,E
D$0L
t$@L
l$8H
{8E1
|$PE1
\L$X
D$@Y^
.l$0
{@E1
\L$X
D$@XZ
.|$0A
[]A\A]A^A_
.t$0
.|$0A
AWAVAUATUSH
D$81
d$ H
t$8H
x8E1
\L$0
D$8dH3
H[]A\A]A^A_
AVE1
L$(1
\L$0
AVAUATUI
u([]A\A]A^H
C0[]A\A]A^
]A\A]A^
AVAUI
ATUI
[]A\A]A^
.CLz
[]A\A]A^
.CPz
AUATI
([]A\A]
[]A\A]
[]A\A]
AUATUSH
[]A\A]1
ATUI
[]A\
ATUH
 []A\
t;rI
ATUI
[]A\
AUATI
tSH;] t-H;]
[]A\A]
[]A\A]
AUATI
[]A\A]H
[]A\A]H
D$(1
L$(dH3
T$ H
AWAVAUATA
D$X1
T$0L
t$8H
t$,1
S(E1
D$4E
D$<u
D$LH
D$0E
D$8u
D$<D
L$DH
D$LH
D$XdH3
h[]A\A]A^A_
C(E1
XD$0
|$@H
|$@H
w6E1
AWAVI
AUATI
D$(1
t$$1
T$ H
D$(dH3
8[]A\A]A^A_
T$ H
L$ A
AVAUI
ATUH
tlrj
 []A\A]A^
ATUH
 u	[]A\
{ []A\
ATUH
@(]A\
ATUH
[]A\
AUATUSH
[]A\A]
C([H
C([H
AUATA
[]A\A]H
h(D9e(tfH
D;e(t
D;m,t
[]A\A]
D9m,u
[]A\A]
AWAVI
AUATI
[]A\A]A^A_
[]A\A]A^A_
[]A\A]A^A_
([]A\A]A^A_
ATUI
[]A\H
ATUI
[]A\H
z[uY
zMuK
z?u=
.E z1u/
E(9C(
AVAUATUSH
[]A\A]A^
AVAUI
ATUL
D$81
D$8dH3
@[]A\A]A^
AWAVAUATUSH
dH34%(
[]A\A]A^A_
AUATUSH
([]A\A]
ATUI
[]A\
[]A\
ATUI
[]A\
[]A\
AWAVA
AUATA
L$(H
T$ H
D$H1
t$ H
D$(H
T$0H
t$0D
|$4D
|$0D
t$4D
L$HdH3
X[]A\A]A^A_
~<D9
~7E9
AWAVAUATUSH
D$(1
L$ H
T$ H
uLE1
D$(dH3
8[]A\A]A^A_
D9l$
AUATUSH
[]A\A]
[]A\A]H
AWAVAUATI
([]A\A]A^A_
XZtVH
AWAVA
AUATI
[]A\A]A^A_
L$@H
L$ f
L$(f
L$@f
L$`f
L$xSPL
AUATH
[]A\A]
AWAVI
AUATUSH
[]A\A]A^A_
[]A\A]A^A_
ATUI
[]A\
[]A\
AVAUI
ATUI
]A\A]A^
AWAVM
AUATI
[]A\A]A^A_
AWAVI
AUATI
D$(1
L$ M
D$ H
T$ L
t$ H
\$(dH3
8[]A\A]A^A_
AWAVE
AUATM
[]A\A]A^A_
AWAVA
AUATE
([]A\A]A^A_
AWAVA
AUATI
([]A\A]A^A_
AWAVA
AUATI
D$(1
L$(dH3
8[]A\A]A^A_
t$ H
t$ L
{0Y^H
AUATI
([]A\A]
[]A\A]
AVAUI
ATUH
A;D$8tjA
D$8L
[]A\A]A^
 []A\A]A^
{(H9
ATUH
[]A\H
[]A\
[]A\
C ZY[
L$ H
AWAVI
AUATUSH
D$(1
D$(M
D$0ZYH
T$(dH3
8[]A\A]A^A_
\$$f
AUATUS
D$H1
D$$H
L$(AQD
L$,AQW
|$:W
|$AW
|$HWPH
D$VP
D$]PD
L$d1
L$HdH3
X[]A\A]
D$$H
AVAUI
ATUA
D$x1
D$xdH3
[]A\A]A^
L$(H
t$8L
L$ H
T$(H
D$0H
|$8H
|$8A
AUATUSH
[]A\A]
AWAVAUATUSH
D$@H
L$<H
D$(H
D$ H
ZD$ 
D$ E
|$PA
,T$ 
,D$Pf
|$0H
|$0M
L$8D
t$$H
[]A\A]A^A_
T$PH
Zd$ f
\$Xf
YD$P
YT$X
YD$X
|$ f
.D$`
t$pf
L$PL
|$0L
L$Pf
t$XL
t$pL
l$hf
T$pf
D$pf
T$x9
\D$p
\$h9
\L$x
L$XE
D$hf
\L$x
\D$p
l$`f
|$0L
ZT$ f
.D$h
AWAVE1
AUATI
d$ H
l$PH
CSp9
`tPH
D$\A9
CKx9
T$0H
D$3A
D$2A
D$1A
D$0A
T$Pf
D$`f
D$df
D$xf
D$hf
t$lf
D$`f
D$lf
T$`f
D$lf
l$pE1
D$Lf
D$pf
D$tf
l$@A9
|$DD
d$LL
l$HE9
[]A\A]A^A_
L$Lf
D$pf
T$df
D$Hf
T$hf
D$pf
D$tf
T$@f
t$Lf
t$Hf
D$lf
+t(H
AUATA
[]A\A]
ATUH
D$ H
[]A\
AWAVAUATUSf
H9>H
0<0u
D$$u
T$pD
t$pH
L$`H
T$XH
t$TL
*|$XD
*d$TD
*l$`
d$0f
*|$T
*D$`
l$xH
\l$p
\d$t
t$XH
YT$X
[]A\A]A^A_
|$`H
D$cH
D$xL
\D$p
\L$tH
l$pf
d$tD
t$LA
|$@Hi
\$Df
D$4A
P	Hc
vwHc
A	Hc
t$`H
\$|L
l$xH
\l$p
\d$tf
|$xH
5WmC
=`lC
AWAVAUATI
[]A\A]A^A_
AWAVAUATI
D$X1
D$XdH3
h[]A\A]A^A_
ATUH
D$(1
D$(dH3
0[]A\
AWAVAUATI
D$H1
D$<L
D$HdH3
X[]A\A]A^A_
t$`A
=A`C
5g_C
AUATUSH
[]A\A]
AUATI
[]A\A]
[]A\
L$81
L$8dH3
=9UC
=eTC
AWAVM
AUATI
l$(M
C(E1
|$PH
|$XH
[]A\A]A^A_
ATUH
E H9C t
[]A\
E(H9C(u
t6E1
ATUI
[]A\
AWAVI
AUATI
x}Hc
[]A\A]A^A_
[]A\A]A^A_
AWAVA
AUATI
[]A\A]A^A_
[]A\A]A^A_
$u!H
AWAVI
AUATI
[]A\A]A^A_
[]A\A]A^A_
AWAVI
AUATI
[]A\A]A^A_H
xhHc
[]A\A]A^A_
AWAVI
AUATUSH
[]A\A]A^A_
L;t$
[]A\A]A^A_
[]A\A]A^A_
AWAVL
AUATI
[]A\A]A^A_
AUATL
[]A\A]
[]A\A]
[]A\A]
[]A\A]
AWAVAUATUSH
[]A\A]A^A_
D$@H
D$HL
\$tL
T$pL
|$lL
L$dH
T$`H
DD$ 
t$XH
DD$$
t$xH
L$dI
D$`d
t$`H
t$0L
\$0H
t$HH
DD$(
YD$0
t$xH
AUATI
dH34%(
([]A\A]
AWAVAUATUSH
[]A\A]A^A_
AUATI
[]A\A]H
[]A\A]
AWAVI
AUATI
x}Hc
[]A\A]A^A_
[]A\A]A^A_
]A\A]A^A_
AWAVAUATUSH
D$H1
D$ I
l$(E1
D$@L
D$0H
t	E1
t$<E9
D$HdH3
X[]A\A]A^A_
D$0A
XD$@
T$0H
D$@L
T$0A
XD$@
D$0A
L$@1
T$0A
L$@1
XD$@
L$@1
XD$@
L$@1
XD$@
\$@1
XD$@
XD$@
XD$@
XD$@
T$8L
\$@1
XD$@
XD$@
XD$@
XD$@
T$<L
L$@1
XD$@
L$@1
XD$@
L$@1
\$@1
XD$@
XD$@
L$@1
XD$@
\$@1
XD$@
XD$@
L$@1
XD$@
L$@1
XD$@
\$@1
XD$@
XD$@
\$@1
XD$@
XD$@
\$@1
XD$@
XD$@
XD$@
XD$@
L$@1
XD$@
L$@1
XD$@
L$@1
XD$@
\$@1
XD$@
XD$@
\$@1
XD$@
XD$@
L$@1
L$@1
XD$@
L$@1
XD$@
L$@1
XD$@
ATUI
[]A\H
\[]A
AWAVI
AUATUSH
D$H1
T$,H
L$HdH3
X[]A\A]A^A_
t$0H
\$0t
L$,D
L$4H
L$8H
AWAVAUATI
D$h1
T$DH
H9l$
t$`H
d$PH
t$@H
\$HH
\$hdH3
x[]A\A]A^A_
tj~H
Yt$`
Y|$`
T$DH
AWAVI
AUATUSH
([]A\A]A^A_
ATUI
u%[]A\H
[]A\
ATUI
u%[]A\H
[]A\
ATUI
u%[]A\H
CpfE
[]A\
ATUH
 []A\
AVAUI
ATUH
 []A\A]A^
t>AVAUATUH
C<;E<t
[]A\A]A^
E$A9D$$u
AUATI
[]A\A]
ATUH
[]A\
ATUSH
dH34%(
 []A\
tKATUI
|$8H
|$@H
[]A\
tpAUATUSH
[]A\A]
[]A\A]
AVAUATUS
[]A\A]A^
]A\A]A^
]A\A]A^
]A\A]A^
]A\A]A^
AWAVI
AUATI
D$(H
([]A\A]A^A_
s0E1
AUATI
([]A\A]
[]A\A]
AVAUI
ATUI
 []A\A]A^
[]A\A]A^
E []A\A]A^
E([]A\A]A^
AUATUSH
CHt>H
[]A\A]
[]A\
ATUI
[]A\1
[]A\
ATUSH
[]A\
ATUI
ZY[]A\
ATUI
[]A\
|$@H
[]A\
[]A\
AWAVAUATI
D$$H
T$(1
$taI
D$(dH3
8[]A\A]A^A_
AUATI
[]A\A]
[]A\A]
CPE1
ATUH
[]A\
D$H1
D$HdH3
AUATI
[]A\A]
ATUI
[]A\
AUATUSH
[]A\A]
[]A\A]
[]A\A]
ATUI
H;(t8H
u@[]A\
ATUI
[]A\
ulHc
[]A\H
ATUH
@(]A\
t8Hc
CP;(t!
CP;h
[]A\
AUATUSH
@PHc-
[]A\A]
H#V H
AVAUA
ATUI
]A\A]A^
[]A\A]A^H
]A\A]A^
AWAVAUATUSH
t	H;
[]A\A]A^A_
AWAVAUATUSH
[]A\A]A^A_
QATL
[]A\A]A^A_1
AVAUI
ATUH
D$81
L$8dH3
@[]A\A]A^
\D$ L
\D$$
AVAUI
ATUA
 []A\A]A^
AUATI
[]A\A]
AUATI
[]A\A]
AVAUATUSH
 Hc-B
 []A\A]A^
AWAVAUATI
uKHc
[]A\A]A^A_
ATUH
D$81
D$8dH3
@[]A\
ATUI
u []A\H
Hc-a
[]A\H
[]A\
tSHc
tSHc
tSHc
tSHc
B0u*
ATUI
t$0H
[]A\
ATUI
[]A\
ATUH
[]A\
ATUSH
[]A\
[]A\
ATUA
u []A\H
[]A\
[]A\
[]A\
Hc-X
ATUI
u []A\H
[]A\
[]A\H
ATUI
[]A\
AUATUSH
[]A\A]
ATUI
u []A\H
Hc-q
}XL9
[]A\H
[]A\
ATUI
u []A\H
[]A\H
AVAUA
ATUI
]A\A]A^
]A\A]A^
]A\A]A^
]A\A]A^
]A\A]A^
]A\A]A^
]A\A]A^
]A\A]A^
]A\A]A^
]A\A]A^
 []A\A]A^
AVAUA
ATUI
p`[L
]A\A]A^
]A\A]A^
]A\A]A^
]A\A]A^
 []A\A]A^
t)Hc
t!Hc
ATUH
[]A\H
C@I9
[]A\
[]A\
AWAVI
AUATA
Lc5G
F0 t+1
[]A\A]A^A_
t	H;
\$@L
|$ H
D$pL
D$0H
ZD$(
ZL$0
\$@H
|$ H
D$(M
ZD$$
ZL$<
ZD$ 
ZL$8
ZD$,
ZL$4
AUATUSH
]A\A]
ATUI
D$(H
[]A\
AUATUSH
D$(1
T$ E1
T$ RH
T$ RH
T$(RATL
u|L;d$
|$ 1
L$(dH3
8[]A\A]
|$ 1
|$ H
|$ H
|$ 1
AWAVAUATI
D$(1
T$(dH3
8[]A\A]A^A_
ATUSH
[]A\
t$0L
AVAUA
ATUH
 []A\A]A^
AUATI
([]A\A]
j j E1
j@UE1
j UE1
AUATUSH
[]A\A]
[]A\A]
AUATUSH
[]A\A]
AUATUSH
D$h1
D$hdH3
x[]A\A]
AWAVAUATUSH
[]A\A]A^A_
G(H;B I
H;E(u
E I9D$(u
#I;D$(
#I9t$(u
|$ Mc
M)t$
t$(H
D$ H
#I9D$(u
M;4$u
|$ H
AUATI
([]A\A]
[]A\A]
AWAVAUATI
D$x1
L$xdH3
[]A\A]A^A_
D$8L
D$@ 
D$XL
ATUSH
9k@t3
AVAUI
ATUH
 []A\A]A^
]A\A]A^
AVAUM
ATUI
u#[]A\A]A^H
CP[]A\A]A^
[]A\A]A^
=)wB
t{SH
=2vB
AUATA
[]A\A]
[]A\A]
5jpB
]A\A]
AUATUSH
[]A\A]
=[lB
AUATA
[]A\A]
[]A\A]
[]A\A]
([]A\A]
ATUI
=7iB
ATUH
ATUH
ATUI
[]A\
[]A\
[]A\
ATUI
AVAUA
ATUI
]A\A]A^
[]A\A]A^
[]A\A]A^
[]A\A]A^
]A\A]A^
]A\A]A^
 []A\A]A^
ATUH
[]A\
|$@H
D$(H
5)FB
5 >B
ATUSH
t-[]A\
ATUH
[]A\1
AUATI
[]A\A]
ATUSH
XZtPL
[]A\
t%USH
t%USH
AUATUSH
[]A\A]
AWAVAUATUSH
D$x1
|$HH
|$8H
D$pH
D$TH
D$XH
D$hH
\$8H
D$(H
|$8H
D$HH
D$`H
\$0L
t$ AW
t$8L
t$(H
D$8H
T$@H
L$x1
\$LA
D$pH
D$(H
D$xdH3
[]A\A]A^A_
|$8L
D$HH
d$8H
|$8L
\$8H
T$8H
t	H;
|$8H
\$8H
ATUSH
D$PL
D$XL
D$`L
D$hL
D$pL
[]A\
AUATI
([]A\A]
[]A\A]
AVAUI
ATUH
 []A\A]A^
[]A\A]A^H
ATUI
=O@B
[]A\
AUATI
[]A\A]
AWAVI
AUATA
T$hdH
[]A\A]A^A_
A;o AZA[r
l$pI
D$XH
D$xH
t$hH
N@E1
D$8A
D$@H
L$DH
t$(H
t$XL
|$`L
L$HH
H;D$x
|$ L
t$(H
E;~@
D$0H
L$DD
D$8H
T$8H
L$lH
T$(H
AWQH
L$ I
D$ H
A;o H
D$(1
L$(H
l$ I
D$8I
L$8H
|$(H
D$ ;A@
t$(H
ATARL
T$ H
T$`I
AUATI
[]A\A]
[]A\A]
[]A\A]
[]A\A]
AVAUI
ATUH
[]A\A]A^H
[]A\A]A^1
]A\A]A^
[]A\A]A^
[]A\A]A^H
AWAVI
AUATA
[]A\A]A^A_
[]A\A]A^A_H
[]A\A]A^A_
[]A\A]A^A_
[]A\A]A^A_
AWAVAUATI
t	H;
AUSH
L$ M
([]A\A]A^A_
ATUH
[]A\
ATUH
[]A\
ATUH
[]A\
ATUH
-\#B
[]A\
ATUH
D;`,
]A\1
[]A\
ATUH
5U B
]A\1
[]A\
AUATUSH
;B,tw;B<tRH
[]A\A]
AUATI
D$81
D$8dH3
H[]A\A]
AWAVAUATI
([]A\A]A^A_
AUATUSH
D$0H
[]A\A]
[]A\A]
AWAVAUATL
f$USI
l$ dH
[]A\A]A^A_
AUATI
[]A\A]
[]A\A]
[]A\A]
[]A\A]
AWAVAUATI
[]A\A]A^A_
[]A\A]A^A_
[]A\A]A^A_
[]A\A]A^A_
AVAUI
ATUI
[]A\A]A^
AUATH
[]A\A]H
[]A\A]H
[]A\A]1
[]A\A]
[]A\A]
AUATI
[]A\A]
[]A\A]
[]A\A]H
[]A\A]1
[]A\A]
AUATUSH
D$81
L$8dH3
H[]A\A]
AVAUATUA
ZYtFH
[]A\A]A^
ATUI
AUATI
([]A\A]
[]A\A]
AVAUI
ATUI
 []A\A]A^
u$[]A\A]A^H
[]A\A]A^H
u"[H
ATUI
[]A\
ATUA
AUATI
[]A\A]
t{SH
ATUI
[]A\
ATUA
ATUI
AUATI
[]A\A]
t{SH
ATUI
[]A\
ATUA
AUATI
[]A\A]
t{SH
ATUI
[]A\
ATUI
ATUA
AUATI
[]A\A]
t{SH
ATUI
[]A\
AXAYH
AZA[H
AUATA
[]A\A]
[]A\A]
[]A\A]
[]A\A]
[]A\A]
[]A\A]
[]A\A]
([]A\A]
ATUI
[]A\
ATUSH
[]A\
[]A\
9hPt
[]A\
[]A\
9hTt
[]A\
ATUH
ATUH
ATUH
ATUH
ATUH
ATUH
ATUI
[]A\
ATUI
AWAVA
AUATI
[]A\A]A^A_
[]A\A]A^A_
t	H;
[]A\A]A^A_H
[]A\A]A^A_
[]A\A]A^A_
[]A\A]A^A_
[]A\A]A^A_
[]A\A]A^A_
[]A\A]A^A_
[]A\A]A^A_
[]A\A]A^A_
[]A\A]A^A_
[]A\A]A^A_
[]A\A]A^A_
[]A\A]A^A_
[]A\A]A^A_
ATUI
[]A\
ATUA
[]A\
AWAVI
AUATUSH
[]A\A]A^A_
[]A\A]A^A_
AWAVAUATUSH
[]A\A]A^A_
AWAVA
AUATI
t	H;
[]A\A]A^A_H
[]A\A]A^A_1
[]A\A]A^A_
[]A\A]A^A_
[]A\A]A^A_
[]A\A]A^A_
[]A\A]A^A_
ATUI
[]A\
AWAVAUATL
[]A\A]A^A_
AWAVI
AUATH
4$E1
[]A\A]A^A_
X8E1
AUATI
[]A\A]
[]A\A]
AUATA
[]A\A]
[]A\A]
[]A\A]
[]A\A]
([]A\A]
window-manager
GnomeShellPlugin
glXQueryExtensionsString
glXQueryExtension
GLX_INTEL_swap_event
glx.swapComplete
<main>
GNOME Shell
Various
GPLv2+
GL buffer swap complete event received (with timestamp of completion)
imports.ui.environment.init();imports.ui.main.start();
Execution of main.js threw exception: %s
Provides GNOME Shell core functionality
app->info == NULL
shell-app.c
app->running_state->windows
app->running_state != NULL
ShellApp
Application state
Busy state
Busy
Application id
Application Action Group
action-group
Application Menu
DesktopAppInfo
app-info
SHELL_IS_APP (app)
notify::busy
scale-factor
application-x-executable
program
Unknown
actions
app->running_state->muxer
app.new-window
X-GNOME-SingleWindow
property
state->refcount > 0
app->info != NULL
Failed to launch 
workspace-switched
unmanaged
notify::user-time
notify::skip-taskbar
window:%d
!(app->state == SHELL_APP_STATE_RUNNING && state == SHELL_APP_STATE_STARTING)
The desktop file id of this ShellApp
The action group exported by the remote application
The primary menu exported by the remote application
The DesktopAppInfo associated with this app
%s:%d: invalid %s id %u for "%s" of type '%s' in '%s'
app->state == SHELL_APP_STATE_STOPPED
app->running_state->session != NULL
shell_app_launch_context
unref_running_state
_shell_app_remove_window
shell_app_state_transition
shell_app_sync_running_state
busy_changed_cb
get_application_proxy
shell_app_on_ws_switch
create_running_state
shell_app_on_user_time_changed
shell_app_on_skip_taskbar_changed
shell_app_open_new_window
shell_app_activate_full
shell_app_update_window_actions
window_backed_app_get_window
shell_app_dispose
ShellAppSystem
app-state-changed
installed-changed
gnome-
.desktop
shell-app-system.c
fedora-
mozilla-
debian-
_shell_app_system_notify_app_state_changed
 %s="
application-state
open-window-count
score
last-seen
Unknown element <%s>
iter->in_context
shell-app-usage.c
notify::focus-app
org.gnome.SessionManager
g-signal
userdatadir
application_state
org.gnome.desktop.privacy
changed::remember-app-usage
ShellAppUsage
StatusChanged
  </context>
  <context
    <application
</application-state>
  </context>
Missing attribute id on <%s> element
Could not load applications usage data: %s
[gnome-shell] idle_save_application_usage
/org/gnome/SessionManager/Presence
Could not save applications usage data: %s
<?xml version="1.0"?>
<application-state>
usage_iterator_remove
?/usr/share/gnome-shell
GNOME_SHELL_DATADIR
GNOME_SHELL_JS
images/
org.gnome.shell
application.icon_name
org.gnome.Shell
application.id
application.name
application.language
start-here
resource
resource:///org/gnome/shell
search-path
xdnd-position-changed
xdnd-leave
xdnd-enter
notify-error
user
The session mode to use
Session Mode
session-mode
GdkScreen
gdk-screen
Screen width, in pixels
Screen Width
screen-width
Screen height, in pixels
Screen Height
screen-height
Display
display
Stage
stage
Actor holding window actors
Top Window Group
top-window-group
Window management interface
Window Manager
Settings
settings
Data directory
Image directory
imagedir
User data directory
The shell's StFocusManager
Focus manager
Frame Timestamps
frame-timestamps
Frame Finish Timestamps
frame-finish-timestamp
event.description
volatile
canberra.cache-control
event.mouse.x
event.mouse.y
event.mouse.button
glFinish
ShellGlobal
clutter.stagePaintDone
clutter.stagePaintStart
gdk-window-scaling-factor
font-dpi
the_object == NULL
SHELL_IS_GLOBAL (global)
notify::width
notify::height
after-paint
Start of stage page repaint
Paint completion on GPU
notify::key-focus
notify::focus-window
notify::gtk-xft-dpi
global->plugin == NULL
i == n_opts-1
MESSAGE=
CODE_LINE=1375
CODE_FILE=shell-global.c
XdndAware
XdndProxy
org.gnome.shell.overrides
classic
/proc/self/cmdline
/proc/self/fd
failed to reexec: %s
global->work_count > 0
event.id
media.filename
XdndPosition
XdndStatus
XdndLeave
XdndEnter
%s/gnome-shell/runtime-state-%s.%s
Metacity screen object for the shell
Gdk screen object for the shell
Metacity display object for the shell
Stage holding the desktop scene graph
Actor holding override-redirect windows
GSettings instance for gnome-shell configuration
Directory containing gnome-shell data files
Directory containing gnome-shell image files
Directory containing gnome-shell user data
Whether to log frame timestamps in the performance log
Whether at the end of a frame to call glFinish and log paintCompletedTimestamp
Failed to open runtime state: %s
[gnome-shell] run_leisure_functions
failed to resolve required GL symbol "%s"
clutter.paintCompletedTimestamp
End of frame, possibly including swap time
org.gnome.shell.extensions.classic-overrides
failed to get /proc/self/cmdline: %s
shell_global_get_session_mode
shell_global_end_work
shell_global_get_overrides_settings
shell_global_log_structured
_shell_global_set_plugin
shell_global_get_window_actors
shell_global_get_gdk_screen
shell_global_set_stage_input_region
_shell_global_init
ShellEmbeddedWindow to embed
window-created
destroy
ShellGtkEmbed
shell-gtk-embed.c
SHELL_IS_EMBEDDED_WINDOW (window)
shell_gtk_embed_new
org.gnome.desktop.a11y.applications
screen-magnifier-enabled
ShellScreenshot
%s.png
%s - %d.png
tEXt::Software
gnome-screenshot
screenshot != NULL
shell-screenshot.c
write_screenshot_thread
The PID of the icon's application
shell tray: plug window is gone
event_type == CLUTTER_BUTTON_RELEASE || event_type == CLUTTER_KEY_PRESS || event_type == CLUTTER_KEY_RELEASE
The icon's window title
Title
The icon's window WM_CLASS
WM Class
ShellTrayIcon
_NET_WM_PID
shell-tray-icon.c
shell_tray_icon_click
shell_tray_icon_new
shell_tray_icon_constructed
tray-icon-added
tray-icon-removed
realize
plug-added
BG Color
bg-color
child != NULL
ShellTrayManager
shell-tray-manager.c
style-changed
Background color (only if we don't have transparency)
na_tray_icon_removed
o@shell-stop-pick
CLUTTER_IS_ACTOR (actor)
LC_TIME
glGetString
NVIDIA Corporation
draw
Unknown value of _NL_TIME_WEEK_1STDAY.
File %s contains invalid UTF-8
shell_util_get_transformed_allocation
?ShellWindowTracker
window-added
window-removed
shell-window-tracker.c
ShellStartupSequence
Focused application
Focus App
startup-sequence-changed
tracked-windows-changed
notify::wm-class
notify::gtk-application-id
notify::n-workspaces
get_app_from_id
unminimize
size-change
kill-switch-workspace
kill-window-effects
show-tile-preview
hide-tile-preview
show-window-menu
filter-keybinding
confirm-display-change
ShellWM
/proc/meminfo
MemTotal: %u
Screen to record
Stage to record
Framerate
framerate
Pipeline
pipeline
File Template
file-template
Whether to record the cursor
Draw Cursor
draw-cursor
BGRx
format
video/x-raw
shell-recorder.c
SHELL_IS_RECORDER (recorder)
shellrecordersrc
videoconvert
Recording to %s
fdsink
Can't create fdsink element
notify::memory-used
recorder->stage != NULL
cursor-changed
Framerate used for resulting video in frames-per-second
GStreamer pipeline description to encode recordings
The filename template to use for output files
recorder->current_pipeline != NULL
[gnome-shell] recorder_redraw_timeout
[gnome-shell] recorder_update_memory_used_timeout
[gnome-shell] recorder_idle_redraw
vp9enc min_quantizer=13 max_quantizer=13 cpu-used=5 deadline=1000000 threads=%T ! queue ! webmmux
ShellRecorder: failed to parse pipeline: %s
ShellRecorder: pipeline has no unlinked sink pad
Can't create recorder source element
Can't create videoconvert element
ShellRecorder: can't get src pad to link into pipeline
ShellRecorder: can't link to sink pad
Unknown escape %%%c in filename
Cannot open output file '%s': %s
ShellRecorder: can't get sink pad to link pipeline output
[gnome-shell] recorder_update_pointer_timeout
recorder->state != RECORDER_STATE_RECORDING
recorder->state != RECORDER_STATE_CLOSED
Error in recording pipeline: %s
shell_recorder_is_recording
shell_recorder_close
shell_recorder_record
shell_recorder_set_area
shell_recorder_set_pipeline
shell_recorder_set_draw_cursor
shell_recorder_set_file_template
shell_recorder_set_framerate
recorder_record_frame
handle-activate
handle-open
handle-command-line
org-gtk-application.c
org.gtk.Application
(ssv)
ShellOrgGtkApplication
(@a{sv})
Activate
(^ass@a{sv})
Open
(o^aay@a{sv})
CommandLine
ShellOrgGtkApplicationProxy
a{sv}
{&sv}
g-flags
g-interface-name
g-object-path
g-connection
g-bus-type
No property with name %s
(sa{sv}as)
PropertiesChanged
org-gtk-application
exit_status
platform_data
arguments
hint
uris
prop_id != 0 && prop_id - 1 < 1
org.freedesktop.DBus.Properties.Set
Error setting property '%s' on interface org.gtk.Application: %s (%s, %d)
_g_value_equal() does not handle type %s
G_VALUE_TYPE (a) == G_VALUE_TYPE (b)
ShellOrgGtkApplicationSkeleton
Method %s is not implemented on interface %s
org.freedesktop.DBus.Properties
[generated] _shell_org_gtk_application_emit_changed
shell_org_gtk_application_skeleton_get_property
shell_org_gtk_application_skeleton_set_property
_g_value_equal
_shell_org_gtk_application_skeleton_handle_method_call
_shell_org_gtk_application_skeleton_handle_get_property
_shell_org_gtk_application_skeleton_handle_set_property
shell_org_gtk_application_proxy_get_property
shell_org_gtk_application_proxy_set_property
ShellAppState
ShellSnippetHook
ShellActionMode
ShellNetworkAgentResponse
SHELL_NETWORK_AGENT_CONFIRMED
confirmed
user-canceled
internal-error
SHELL_ACTION_MODE_NONE
none
SHELL_ACTION_MODE_NORMAL
normal
SHELL_ACTION_MODE_OVERVIEW
overview
SHELL_ACTION_MODE_LOCK_SCREEN
unlock-screen
login-screen
system-modal
looking-glass
SHELL_ACTION_MODE_POPUP
popup
SHELL_ACTION_MODE_ALL
SHELL_SNIPPET_HOOK_VERTEX
vertex
vertex-transform
SHELL_SNIPPET_HOOK_FRAGMENT
texture-coord-transform
layer-fragment
texture-lookup
SHELL_APP_STATE_STOPPED
stopped
SHELL_APP_STATE_STARTING
starting
SHELL_APP_STATE_RUNNING
running
SHELL_NETWORK_AGENT_USER_CANCELED
SHELL_NETWORK_AGENT_INTERNAL_ERROR
SHELL_ACTION_MODE_UNLOCK_SCREEN
SHELL_ACTION_MODE_LOGIN_SCREEN
SHELL_ACTION_MODE_SYSTEM_MODAL
SHELL_ACTION_MODE_LOOKING_GLASS
SHELL_SNIPPET_HOOK_VERTEX_TRANSFORM
SHELL_SNIPPET_HOOK_TEXTURE_COORD_TRANSFORM
SHELL_SNIPPET_HOOK_LAYER_FRAGMENT
SHELL_SNIPPET_HOOK_TEXTURE_LOOKUP
Fixed GstCaps for the source
Caps
Memory Used
Generic/Src
ShellRecorderSrc
shell-recorder-src.c
SHELL_IS_RECORDER_SRC (src)
src->caps != NULL
Plugin for ShellRecorder
shellrecorder
LGPL
Memory currently used by the queue (in kB)
Owen Taylor <otaylor@redhat.com>
Feed screen capture data to a pipeline
[gnome-shell] shell_recorder_src_memory_used_update_idle
http://live.gnome.org/GnomeShell
shell_recorder_src_add_buffer
resize-mode
app-paintable
ShellEmbeddedWindow
_shell_embedded_window_unmap
_shell_embedded_window_map
_shell_embedded_window_allocate
_shell_embedded_window_set_actor
ShellGenericContainer
get-preferred-width
get-preferred-height
allocate
ShellGenericContainerAllocation
ShellGLSLQuad
klass->base_pipeline != NULL
RGBA = ADD (SRC_COLOR * (SRC_COLOR[A]), DST_COLOR * (1-SRC_COLOR[A]))
shell_glsl_quad_add_glsl_snippet
cogl_texel = texture2D (cogl_sampler, cogl_tex_coord.st);
vec3 effect = vec3 (cogl_texel);
float maxColor = max (cogl_texel.r, max (cogl_texel.g, cogl_texel.b));
float minColor = min (cogl_texel.r, min (cogl_texel.g, cogl_texel.b));
float lightness = (maxColor + minColor) / 2.0;
float delta = (1.0 - lightness) - lightness;
effect.rgb = (effect.rgb + delta);
cogl_texel = vec4 (effect, cogl_texel.a);
Unable to use the ShellInvertLightnessEffect: the graphics hardware or the current GL driver does not implement support for the GLSL shading language.
ShellInvertLightnessEffect
message
password-new
password-strength
choice-label
choice-chosen
caller-window
continue-label
cancel-label
Password field is visible
Password visible
password-visible
Confirm field is visible
Confirm visible
confirm-visible
Warning is visible
Warning visible
warning-visible
Choice is visible
Choice visible
choice-visible
Text field for password
Password actor
password-actor
Confirm actor
confirm-actor
show-password
show-confirm
G_VALUE_HOLDS_STRING (value)
value != NULL
stripped_label != NULL
shell-keyring-prompt.c
ShellKeyringPrompt
text-changed
Passwords do not match.
GNOME_KEYRING_PARANOID
Password cannot be blank
self->mode != PROMPTING_NONE
self->task != NULL
self->task == NULL
Text field for confirming password
g_task_get_source_object (task) == prompt
g_async_result_is_tagged (result, shell_keyring_prompt_confirm_async)
g_task_get_source_object (G_TASK (result)) == prompt
g_async_result_is_tagged (result, shell_keyring_prompt_password_async)
this prompt is already prompting
this prompt can only show one prompt at a time
SHELL_IS_KEYRING_PROMPT (self)
password_actor == NULL || CLUTTER_IS_TEXT (password_actor)
confirm_actor == NULL || CLUTTER_IS_TEXT (confirm_actor)
shell_keyring_prompt_cancel
shell_keyring_prompt_complete
shell_keyring_prompt_set_confirm_actor
shell_keyring_prompt_set_password_actor
shell_keyring_prompt_get_confirm_actor
shell_keyring_prompt_get_password_actor
remove_mnemonics
shell_keyring_prompt_dispose
shell_keyring_prompt_password_finish
shell_keyring_prompt_confirm_finish
$@ShellMenuTracker
show-processes-2
ShellMountOperation
Only supported event signatures are '', 's', 'i', and 'x'
Maximum number of events defined
Duplicate event event for '%s'
Discarding unknown event '%s'
Event '%s'; defined with signature '%s', used with '%s'
Discarding oversize event '%s'
Statistic '%s'; defined with signature '%s', used with '%s'
[gnome-shell] statistics_timeout
perf_log->events->len == EVENT_SET_TIME + 1
Finished collecting statistics
perf_log->events->len == EVENT_STATISTICS_COLLECTED + 1
Only supported statistic signatures are 'i' and 'x'
Unsupported signature in event
{ "name": "%s",
    "description": "%s"
Event names can't include '"'
perf.setTime
Unknown statistic '%s'
[%li, "%s"]
[%li, "%s", %i]
[%li, "%s", %li]
[%li, "%s", "%s"]
shell-perf-log.c
ShellPerfLog
perf.statisticsCollected
    "statistic": true
replay_to_json
shell_perf_log_init
initiate
cancel
[gnome-shell] handle_cancelled_in_idle
Invalid UTF-8 in username for uid %d. Skipping
Error looking up user name for uid %d
Unsupporting identity of GType %s
Authentication dialog was dismissed by the user
ShellPolkitAuthenticationAgent
PolKit failed to properly get our session
SHELL_IS_POLKIT_AUTHENTICATION_AGENT (agent)
agent->current_request != NULL
shell_polkit_authentication_agent_complete
ShellSecureTextBuffer
ShellStack
org.freedesktop.Telepathy.Channel.TargetHandleType
org.freedesktop.Telepathy.Channel.Type.Text
org.freedesktop.Telepathy.Channel.ChannelType
self->priv->handle_channels_impl != NULL
self->priv->approve_channels_impl != NULL
self->priv->observe_impl != NULL
self->priv->observe_impl == NULL
self->priv->approve_channels_impl == NULL
self->priv->handle_channels_impl == NULL
shell-tp-client.c
ShellTpClient
shell_tp_client_set_handle_channels_func
shell_tp_client_set_approve_channels_func
shell_tp_client_set_observe_channels_func
observe_channels
add_dispatch_operation
handle_channels
new-request
cancel-request
s_con
shell-network-agent.c
connection-uuid
Canceled by NetworkManager
setting-key
Network secret for %s/%s/%s
setting-name
default
setting_name
s_con != NULL
connection_uuid != NULL
connection_id != NULL
setting_key != NULL
attrs
secrets
setting
service_name
VPN %s secret for %s/%s/vpn
ShellNetworkAgent
GHashTable
setting != NULL
SHELL_IS_NETWORK_AGENT (self)
request != NULL
The request could not be completed.  Keyring result: %s
Internal error while retrieving secrets from the keyring (%s)
The secret agent is going away
Network dialog was canceled by the user
An internal error occurred while processing the request.
org.freedesktop.NetworkManager.Connection
shell_network_agent_respond
shell_network_agent_set_password
is_connection_always_ask
create_keyring_add_attr_list
save_one_secret
vpn_secret_iter_cb
shell_network_agent_delete_secrets
Lower bound
Lower
lower
Upper bound
Upper
upper
Current value
Value
Step increment
Step Increment
step-increment
Page increment
Page Increment
page-increment
Page size
Page Size
page-size
StAdjustment
st/st-adjustment.c
ST_IS_ADJUSTMENT (adjustment)
page_size
page_size >= 0 && page_size <= G_MAXDOUBLE
step_increment >= 0 && step_increment <= G_MAXDOUBLE
page_increment >= 0 && page_increment <= G_MAXDOUBLE
st_adjustment_adjust_for_scroll_event
st_adjustment_get_values
st_adjustment_set_values
st_adjustment_clamp_page
st_adjustment_set_value
st_adjustment_get_value
UUUUUU
?The child of the Bin
The horizontal alignment
X Align
x-align
The vertical alignment
Y Align
y-align
X Fill
x-fill
Y Fill
y-fill
StBin
priv->child == NULL
st/st-bin.c
ST_IS_BIN (bin)
Whether the child should fill the horizontal allocation
Whether the child should fill the vertical allocation
child == NULL || CLUTTER_IS_ACTOR (child)
st_bin_get_fill
st_bin_set_fill
st_bin_get_alignment
st_bin_set_alignment
st_bin_get_child
st_bin_set_child
st_bin_dispose
StBorderImage
ST_IS_BORDER_IMAGE (image)
ST_IS_BORDER_IMAGE (other)
st_border_image_equal
st_border_image_get_borders
st_border_image_get_file
Allocate the child extra space
Whether the child should receive priority when the container is allocating spare space on the horizontal axis
Whether the child should receive priority when the container is allocating spare space on the vertical axis
X alignment of the widget within the cell
Y alignment of the widget within the cell
Expand
expand
X Alignment
Y Alignment
StBoxLayoutChild
st/st-box-layout-child.c
st_box_layout_child_get_property
st_box_layout_child_set_property
notify::layout-manager
layout-changed
notify
st/st-box-layout.c
Vertical
vertical
Pack Start
pack-start
hadjustment
vadjustment
StBoxLayout
notify::value
ST_IS_BOX_LAYOUT (box)
CLUTTER_IS_BOX_LAYOUT (layout)
Whether the layout should be vertical, ratherthan horizontal
Whether to pack items at the start of the box
st_box_layout_get_pack_start
st_box_layout_set_pack_start
st_box_layout_get_vertical
st_box_layout_set_vertical
on_layout_manager_notify
@Label of the button
Button mask
button-mask
Enable or disable toggling
Toggle Mode
Checked
checked
Pressed
pressed
StButtonAccessible
StButton
border-spacing
st/st-button.c
ST_IS_BUTTON (button)
ellipsize
line-alignment
use-markup
notify::label
notify::toggle-mode
Which buttons trigger the 'clicked' signal
Indicates if a toggle button is "on" or "off"
Indicates if the button is pressed in
st_button_fake_release
st_button_set_checked
st_button_get_checked
st_button_set_toggle_mode
st_button_get_toggle_mode
st_button_set_button_mask
st_button_get_button_mask
st_button_set_label
st_button_get_label
@UTF8_STRING
TARGETS
st/st-clipboard.c
StClipboard
ST_IS_CLIPBOARD (clipboard)
callback != NULL
text != NULL
Clipboard: prop retrival failed
st_clipboard_set_text
st_clipboard_get_text
StDrawingArea
ST_IS_DRAWING_AREA (area)
priv->in_repaint
st_drawing_area_get_surface_size
st_drawing_area_get_context
st_drawing_area_queue_repaint
editable
single-line-mode
key-focus-in
key-focus-out
notify::password-char
button-press-event
Internal ClutterText actor
Clutter Text
clutter-text
Hint Text
hint-text
Text of the entry
Purpose of the text field
Purpose
input-purpose
input-hints
primary-icon-clicked
secondary-icon-clicked
StEntryAccessible
caret-size
caret-color
selection-background-color
selected-color
st/st-entry.c
button-release-event
gtk-enable-primary-paste
StEntry
ST_IS_ENTRY_ACCESSIBLE (obj)
i == 0
ST_IS_ENTRY (entry)
indeterminate
ST_ENTRY (entry)
dialog-warning-symbolic
capslock-warning
style-class
Text to display when the entry is not focused and the text property is empty
Hints for the text field behaviour
st_entry_set_secondary_icon
st_entry_set_primary_icon
st_entry_get_input_hints
st_entry_set_input_hints
st_entry_get_input_purpose
st_entry_set_input_purpose
st_entry_get_hint_text
st_entry_set_hint_text
st_entry_get_clutter_text
st_entry_set_text
st_entry_get_text
st_entry_accessible_get_n_children
st_entry_accessible_ref_child
?StButtonMask
StClipboardType
StTextureCachePolicy
StSide
StCorner
StTextDecoration
StTextAlign
StGradientType
StIconStyle
StAlign
StBackgroundSize
ST_BACKGROUND_SIZE_AUTO
auto
ST_BACKGROUND_SIZE_CONTAIN
contain
ST_BACKGROUND_SIZE_COVER
cover
ST_BACKGROUND_SIZE_FIXED
fixed
ST_ALIGN_START
ST_ALIGN_MIDDLE
middle
ST_ALIGN_END
ST_ICON_STYLE_REQUESTED
requested
ST_ICON_STYLE_REGULAR
regular
ST_ICON_STYLE_SYMBOLIC
ST_GRADIENT_NONE
ST_GRADIENT_VERTICAL
ST_GRADIENT_HORIZONTAL
horizontal
ST_GRADIENT_RADIAL
radial
ST_TEXT_ALIGN_LEFT
ST_TEXT_ALIGN_CENTER
center
ST_TEXT_ALIGN_RIGHT
ST_TEXT_ALIGN_JUSTIFY
justify
ST_TEXT_DECORATION_UNDERLINE
underline
ST_TEXT_DECORATION_OVERLINE
overline
line-through
ST_TEXT_DECORATION_BLINK
blink
ST_CORNER_TOPLEFT
ST_CORNER_TOPRIGHT
ST_CORNER_BOTTOMRIGHT
ST_CORNER_BOTTOMLEFT
ST_SIDE_TOP
ST_SIDE_RIGHT
ST_SIDE_BOTTOM
ST_SIDE_LEFT
ST_TEXTURE_CACHE_POLICY_NONE
forever
ST_CLIPBOARD_TYPE_PRIMARY
primary
ST_CLIPBOARD_TYPE_CLIPBOARD
clipboard
ST_BUTTON_ONE
ST_BUTTON_TWO
ST_BUTTON_THREE
three
ST_TEXT_DECORATION_LINE_THROUGH
ST_TEXTURE_CACHE_POLICY_FOREVER
st-focus-manager
get-current-value
get-maximum-value
get-minimum-value
get-minimum-increment
set-current-value
StGenericAccessible
st_generic_accessible_new_for_actor
colors != NULL
colors->ref_count > 0
StIconColors
st_icon_colors_copy
st_icon_colors_unref
st_icon_colors_ref
The GIcon shown by this icon actor
The size if the icon, if positive. Otherwise the size will be derived from the current style
The icon-shadow property does not support inset shadows
gicon == NULL || G_IS_ICON (gicon)
GIcon
gicon
An icon name
Icon name
Icon size
icon-size
A fallback icon name
Fallback icon name
fallback-icon-name
pixbuf-change
notify::opacity
StIcon
icon-shadow
ST_IS_ICON (icon)
st/st-icon.c
st_icon_set_fallback_icon_name
st_icon_get_fallback_icon_name
st_icon_set_icon_size
st_icon_get_icon_size
st_icon_set_gicon
st_icon_get_gicon
st_icon_set_icon_name
st_icon_get_icon_name
commit
preedit-changed
retrieve-surrounding
delete-surrounding
StIMText
event_window != NULL
st/st-im-text.c
event_window == NULL
ST_IS_IM_TEXT (imtext)
st_im_text_has_preedit
st_im_text_get_input_hints
st_im_text_set_input_hints
st_im_text_get_input_purpose
st_im_text_set_input_purpose
st_im_text_set_event_window
st_im_text_realize
key_event_to_gdk
Text of the label
StLabelAccessible
notify::text
StLabel
st/st-label.c
ST_IS_LABEL (label)
ST_IS_LABEL_ACCESSIBLE (obj)
hidden
ST_LABEL (label)
st_label_get_clutter_text
st_label_set_text
st_label_get_text
st_label_accessible_get_name
sigma > 0
src_texture != NULL
shadow_spec != NULL
src_pattern != NULL
shadow_pipeline != NULL
Failed to allocate texture: %s
RGBA = MODULATE (CONSTANT, TEXTURE[A])
_st_paint_shadow_with_opacity
_st_create_shadow_cairo_pattern
calculate_gaussian_kernel
_st_create_shadow_pipeline
_st_create_texture_pipeline
trough
leave-event
hhandle
motion-event
notify::reactive
!priv->grabbed
st/st-scroll-bar.c
object
completed
The adjustment
Vertical Orientation
scroll-start
scroll-stop
min-size
max-size
self
StScrollBar
ST_IS_SCROLL_BAR (bar)
vhandle
[gnome-shell] trough_paging_cb
file %s: line %d (%s): should not be reached
st_scroll_bar_get_adjustment
st_scroll_bar_set_adjustment
st_scroll_bar_scroll_event
trough_button_press_event_cb
handle_button_press_event_cb
The height of the area which is faded at the edge
The width of the area which is faded at the edge
Whether the faded area should extend to the edges
actor == NULL || ST_IS_SCROLL_VIEW (actor)
Vertical Fade Offset
Horizontal Fade Offset
Fade Edges
fade-edges
StScrollViewFade
vscrollbar-visible
hscrollbar-visible
fade_edges_top
fade_edges_bottom
fade_edges_left
fade_edges_right
vfade_offset
hfade_offset
fade_area_topleft
fade_area_bottomright
st/st-scroll-view-fade.c
st_scroll_view_fade_set_actor
 * st-scroll-view-fade.glsl: Edge fade effect for StScrollView
 * Copyright 2010 Intel Corporation.
 * Copyright 2011 Adel Gadllah
 * This program is free software; you can redistribute it and/or modify it
 * under the terms and conditions of the GNU Lesser General Public License,
 * version 2.1, as published by the Free Software Foundation.
 * This program is distributed in the hope it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for
 * more details.
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
uniform sampler2D tex;
uniform float height;
uniform float width;
uniform float vfade_offset;
uniform float hfade_offset;
uniform bool  fade_edges_top;
uniform bool  fade_edges_right;
uniform bool  fade_edges_bottom;
uniform bool  fade_edges_left;
uniform vec2 fade_area_topleft;
uniform vec2 fade_area_bottomright;
void main ()
    cogl_color_out = cogl_color_in * texture2D (tex, vec2 (cogl_tex_coord_in[0].xy));
    float y = height * cogl_tex_coord_in[0].y;
    float x = width * cogl_tex_coord_in[0].x;
    /*
     * We cannot just return here due to a bug in llvmpipe see:
     * https://bugzilla.freedesktop.org/show_bug.cgi?id=62357
     */
    if (x > fade_area_topleft[0] && x < fade_area_bottomright[0] &&
        y > fade_area_topleft[1] && y < fade_area_bottomright[1]) {
        float ratio = 1.0;
        float fade_bottom_start = fade_area_bottomright[1] - vfade_offset;
        float fade_right_start = fade_area_bottomright[0] - hfade_offset;
        bool fade_top = y < vfade_offset && fade_edges_top;
        bool fade_bottom = y > fade_bottom_start && fade_edges_bottom;
        bool fade_left = x < hfade_offset && fade_edges_left;
        bool fade_right = x > fade_right_start && fade_edges_right;
        float vfade_scale = height / vfade_offset;
        if (fade_top) {
            ratio *= y / vfade_offset;
        }
        if (fade_bottom) {
            ratio *= (fade_area_bottomright[1] - y) / (fade_area_bottomright[1] - fade_bottom_start);
        }
        float hfade_scale = width / hfade_offset;
        if (fade_left) {
            ratio *= x / hfade_offset;
        }
        if (fade_right) {
            ratio *= (fade_area_bottomright[0] - x) / (fade_area_bottomright[0] - fade_right_start);
        }
        cogl_color_out *= ratio;
    }
?Horizontal scroll indicator
hscroll
Vertical scroll indicator
vscroll
Vertical Scrollbar Policy
vscrollbar-policy
Horizontal Scrollbar Policy
hscrollbar-policy
Vertical Scrollbar Visibility
Enable Mouse Scrolling
enable-mouse-scrolling
Use Overlay Scrollbars
overlay-scrollbars
st/st-scroll-view.c
StScrollView
fade
-st-vfade-offset
-st-hfade-offset
ST_IS_SCROLL_VIEW (scroll)
When the vertical scrollbar is displayed
When the horizontal scrollbar is displayed
Whether the horizontal scrollbar is visible
Horizontal Scrollbar Visibility
Whether the vertical scrollbar is visible
Enable automatic mouse wheel scrolling
Overlay scrollbars over the content
Attempting to add an actor of type %s to a StScrollView, but the actor does not implement StScrollable.
st_scroll_view_set_policy
st_scroll_view_get_overlay_scrollbars
st_scroll_view_set_overlay_scrollbars
st_scroll_view_get_mouse_scrolling
st_scroll_view_set_mouse_scrolling
st_scroll_view_set_row_size
st_scroll_view_get_row_size
st_scroll_view_set_column_size
st_scroll_view_get_column_size
st_scroll_view_get_vscroll_bar
st_scroll_view_get_hscroll_bar
st_scroll_view_get_preferred_width
st_scroll_view_get_preferred_height
adjust_with_direction
st_scroll_view_scroll_event
Horizontal adjustment
Vertical adjustment
StScrollable
shadow != NULL
shadow->ref_count > 0
StShadow
StShadowHelper
other != NULL
actor_box != NULL
shadow_box != NULL
st_shadow_get_box
st_shadow_equal
st_shadow_unref
st_shadow_ref
icon:
icon-theme-changed
texture-file-changed
keep-aspect-ratio
size-prepared
data != NULL
st/st-texture-cache.c
data->file != NULL
!cancellable
pixbuf != NULL
file:%u
file-for-cairo:%u
StTextureCache
notify::%s
Failed to load %s: %s
icon:%s,size=%d,scale=%d,style=%d,colors=%2x%2x%2x%2x,%2x%2x%2x%2x,%2x%2x%2x%2x,%2x%2x%2x%2x
icon:%s,size=%d,scale=%d,style=%d
load_sliced_image
load_pixbuf_thread
load_texture_async
sans-serif 10
resolution-changed
[gnome-shell] changed_idle
Scale factor
StThemeContext
st/st-theme-context.c
CLUTTER_IS_STAGE (stage)
st-theme-context
ST_IS_THEME_CONTEXT (context)
font != NULL
Integer scale factor used for high dpi scaling
theme == NULL || ST_IS_THEME (theme)
st_theme_context_get_font
st_theme_context_set_font
st_theme_context_get_theme
st_theme_context_set_theme
st_theme_context_get_for_stage
st/st-theme-node-drawing.c
shadow_outline != NULL
width > 0 && height > 0
border_image != NULL
st-theme-node-corner:%02x%02x%02x%02x,%02x%02x%02x%02x,%02x%02x%02x%02x,%u,%u,%u
!(fill_exterior && path == NULL)
cairo_surface_get_type (surface) == CAIRO_SURFACE_TYPE_IMAGE
st_theme_node_paint_sliced_border_image
st_theme_node_update_resources
paint_inset_box_shadow_to_cairo_context
paint_shadow_pattern_to_cairo_context
paint_background_image_shadow_to_cairo_context
get_background_scale
create_cairo_pattern_of_background_image
st_theme_node_get_corner_border_widths
st_theme_node_render_resources
@new-frame
StThemeNodeTransition
ST_IS_THEME_NODE (from_node)
ST_IS_THEME_NODE (to_node)
ST_IS_THEME_NODE (new_node)
width > 0
RGBA = REPLACE (TEXTURE)
ST_IS_THEME_NODE_TRANSITION (transition)
ST_IS_THEME_NODE (priv->old_theme_node)
ST_IS_THEME_NODE (priv->new_theme_node)
RGBA = INTERPOLATE (PREVIOUS, TEXTURE, CONSTANT[A])
RGBA = MODULATE (PREVIOUS, PRIMARY)
setup_framebuffers
st_theme_node_transition_paint
st_theme_node_transition_update
st_theme_node_transition_new
bold
bolder
lighter
oblique
italic
small-caps
transparent
rgba
StThemeNode
custom-stylesheets-changed
ST_IS_THEME_NODE (node)
ST_IS_THEME_NODE (node_a)
ST_IS_THEME_NODE (node_b)
transition-duration
-st-icon-style
Unknown -st-icon-style "%s"
text-decoration
inherit
text-align
font
font-family
font-weight
font-style
font-variant
font-size
background
-position
-repeat
-gradient-direction
-gradient-start
-gradient-end
xx-small
medium
xx-large
smaller
larger
border
-radius
-topleft
-topright
-bottomright
-bottomleft
-left
-right
-top
-bottom
solid
dotted
dashed
double
groove
ridge
inset
outset
outline
padding
margin
-st-natural-width
-st-natural-height
min-width
min-height
max-width
max-height
border-image
box-shadow
-st-background-image-shadow
text-shadow
warning-color
error-color
success-color
st/st-theme-node.c
for_height != NULL
for_width != NULL
paint_box != NULL
ST_IS_THEME_NODE (other)
[null]
[%p %s#%s
parent_node == NULL || ST_IS_THEME_NODE (parent_node)
Did not find color property '%s'
Did not find double property '%s'
Did not find string property '%s'
Size missing from font property
Couldn't parse size in font property
Couldn't parse family in font property
Ignoring length property that isn't a number at line %d, col %d
'auto' not supported for lengths
length values must specify a unit
percentage lengths not currently supported
Ignoring invalid type of number of length property
Unrecognized background-gradient-direction "%s"
Too many values for border-radius property
Too many values for padding property
Too many values for margin property
side >= ST_SIDE_TOP && side <= ST_SIDE_LEFT
corner >= ST_CORNER_TOPLEFT && corner <= ST_CORNER_BOTTOMLEFT
Percentages not supported for border-image
Negative blur values are not allowed
Negative spread values are not allowed
Ignoring excess values in shadow definition
The -st-background-image-shadow property does not support inset shadows
The text-shadow property does not support inset shadows
st_theme_node_geometry_equal
st_theme_node_get_paint_box
st_theme_node_get_background_paint_box
st_theme_node_get_content_box
st_theme_node_adjust_preferred_height
st_theme_node_adjust_for_width
st_theme_node_adjust_preferred_width
st_theme_node_adjust_for_height
st_theme_node_get_icon_colors
_st_theme_node_apply_margins
st_theme_node_get_transition_duration
st_theme_node_get_margin
st_theme_node_get_padding
st_theme_node_get_border_color
st_theme_node_get_background_gradient
st_theme_node_get_foreground_color
st_theme_node_get_background_image
st_theme_node_get_background_color
st_theme_node_get_max_height
st_theme_node_get_max_width
st_theme_node_get_min_height
st_theme_node_get_min_width
st_theme_node_get_height
st_theme_node_get_width
st_theme_node_get_outline_color
st_theme_node_get_outline_width
st_theme_node_get_border_radius
st_theme_node_get_border_width
st_theme_node_equal
st_theme_node_get_pseudo_classes
st_theme_node_get_element_classes
st_theme_node_get_element_id
st_theme_node_get_element_type
st_theme_node_get_theme
st_theme_node_get_parent
st_theme_node_new
@333333
?Stylesheet with application-specific styling
Stylesheet with theme-specific styling
Stylesheet with global default styling
Error parsing stylesheet '%s'; errcode:%d
Attribute selectors not supported
a_add_sel && a_add_sel->type == CLASS_ADD_SELECTOR && a_add_sel->content.class_name && a_add_sel->content.class_name->stryng && a_add_sel->content.class_name->stryng->str && a_node
a_add_sel && a_add_sel->type == ID_ADD_SELECTOR && a_add_sel->content.id_name && a_add_sel->content.id_name->stryng && a_add_sel->content.id_name->stryng->str && a_node
a_this && a_add_sel && a_add_sel->content.pseudo && a_add_sel->content.pseudo->name && a_add_sel->content.pseudo->name->stryng && a_add_sel->content.pseudo->name->stryng->str && a_node
+ combinators are not supported
Out of memory when creating cascade object
Application Stylesheet
application-stylesheet
Theme Stylesheet
theme-stylesheet
Default Stylesheet
default-stylesheet
Unhandled selector type %d
a_add_sel
StTheme
st/st-theme.c
base_file
ST_IS_THEME (theme)
_st_theme_resolve_url
pseudo_class_add_sel_matches_style
id_add_sel_matches_style
class_add_sel_matches_style
additional_selector_matches_style
_st_theme_get_matched_properties
notify::name
notify::first-child
notify::last-child
Pseudo class for styling
Pseudo Class
Style class for styling
Style Class
Inline style string
Theme override
theme
Track hover
track-hover
Hover
Can focus
Accessible Role
accessible-role
Accessible name
popup-menu
%s %s
%.*s%s
StWidgetAccessible
 ("%s")
StWidget
ST_IS_WIDGET_ACCESSIBLE (obj)
ST_IS_WIDGET (actor)
ST_IS_WIDGET (widget)
selected
[%p %s
st-theme-initialized
gtk-enable-animations
style_class != NULL
pseudo_class != NULL
insensitive
notify::pseudo-class
notify::can-focus
notify::label-actor
notify::accessible-name
st/st-widget.c
Determines whether the widget tracks hover state
Whether the pointer is hovering over the widget
Whether the widget can be focused via keyboard navigation
Label that identifies this widget
The accessible role of this object
Object instance's name for assistive technology access.
st_widget_get_theme_node called on the widget %s which is not in the stage.
accessible == NULL || ATK_IS_GOBJECT_ACCESSIBLE (accessible)
st_get_align_factors
st_widget_set_accessible
st_widget_accessible_get_role
st_widget_accessible_get_name
st_widget_remove_accessible_state
st_widget_add_accessible_state
st_widget_get_accessible_role
st_widget_set_accessible_role
st_widget_get_accessible_name
st_widget_set_accessible_name
st_widget_set_label_actor
st_widget_get_label_actor
st_widget_navigate_focus
st_widget_get_can_focus
st_widget_set_can_focus
st_widget_get_hover
st_widget_set_hover
st_widget_get_track_hover
st_widget_set_track_hover
st_widget_ensure_style
st_widget_get_style
st_widget_set_style
st_widget_remove_style_pseudo_class
st_widget_add_style_pseudo_class
st_widget_set_style_pseudo_class
st_widget_has_style_pseudo_class
st_widget_get_style_pseudo_class
st_widget_has_style_class_name
st_widget_get_style_class_name
st_widget_remove_style_class_name
st_widget_add_style_class_name
st_widget_set_style_class_name
st_widget_get_theme
st_widget_set_theme
st_widget_peek_theme_node
st_widget_get_accessible
filter_by_position
st_widget_real_navigate_focus
NaTrayChild
GDK_IS_SCREEN (screen)
notification_area
icon_window != None
NA_IS_TRAY_CHILD (child)
_NET_WM_NAME
na_tray_child_get_wm_class
na_tray_child_has_alpha
na_tray_child_get_title
na_tray_child_new
orientation
tray_icon_added
tray_icon_removed
message_sent
message_cancelled
lost_selection
GTK_IS_INVISIBLE (invisible)
tray/na-tray-manager.c
GDK_IS_WINDOW (window)
manager->invisible != NULL
_NET_SYSTEM_TRAY_ORIENTATION
_NET_SYSTEM_TRAY_COLORS
plug_removed
NaTrayManager
NA_IS_TRAY_MANAGER (manager)
MANAGER
_NET_SYSTEM_TRAY_OPCODE
_NET_SYSTEM_TRAY_MESSAGE_DATA
manager->screen == NULL
_NET_SYSTEM_TRAY_S%d
_NET_SYSTEM_TRAY_VISUAL
gtk_widget_get_realized (invisible)
na_tray_manager_get_orientation
na_tray_manager_set_colors
na_tray_manager_set_orientation
na_tray_manager_check_running
na_tray_manager_set_colors_property
na_tray_manager_set_visual_property
na_tray_manager_set_orientation_property
na_tray_manager_manage_screen_x11
na_tray_manager_manage_screen
na_tray_manager_unmanage
volume-changed
GvcChannelMap
GVC_IS_CHANNEL_MAP (object)
object != NULL
channel_map->priv != NULL
GVC_IS_CHANNEL_MAP (map)
cv != NULL
pa_channel_map_valid(pa_map)
gvc-channel-map.c
pa_cvolume_compatible_with_channel_map(cv, &map->priv->pa_map)
set_from_pa_map
gvc_channel_map_volume_changed
gvc_channel_map_get_cvolume
gvc_channel_map_get_pa_channel_map
gvc_channel_map_has_position
gvc_channel_map_get_mapping
gvc_channel_map_can_fade
gvc_channel_map_can_balance
gvc_channel_map_get_volume
gvc_channel_map_get_num_channels
gvc_channel_map_finalize
The index for this card
Index
The id for this card
PulseAudio context
pa-context
Name to display for this card
Icon Name
Profile
Profile (Human readable)
human-profile
GvcMixerCard
gvc-mixer-card.c
GVC_IS_MIXER_CARD (object)
mixer_card->priv != NULL
GVC_IS_MIXER_CARD (card)
card->priv->profiles != NULL
card->priv->target_profile
card->priv->profiles == NULL
card->priv->ports == NULL
The PulseAudio context for this card
Name of icon to display for this card
Name of current profile for this card
Name of current profile for this card in human readable form
Failed to switch profile on '%s' from '%s' to '%s'
pa_context_set_card_profile_by_index() failed
card->priv->human_profile == NULL
gvc_mixer_card_set_ports
gvc_mixer_card_get_gicon
gvc_mixer_card_set_profiles
gvc_mixer_card_get_ports
gvc_mixer_card_get_profiles
_pa_context_set_card_profile_by_index_cb
gvc_mixer_card_change_profile
gvc_mixer_card_set_profile
gvc_mixer_card_get_profile
gvc_mixer_card_set_icon_name
gvc_mixer_card_get_icon_name
gvc_mixer_card_set_name
gvc_mixer_card_get_name
gvc_mixer_card_get_id
gvc_mixer_card_get_index
gvc_mixer_card_get_pa_context
gvc_mixer_card_finalize
Name to display for this mixer control
pa_ext_stream_restore_write() failed: %s
Changed default device for %s to %s
a == NULL || GVC_IS_MIXER_CARD (a)
b == NULL || GVC_IS_MIXER_CARD (b)
pa_context_get_server_info() failed
pa_context_get_card_info_by_index() failed
pa_context_client_info_list() failed
pa_context_get_sink_info_list() failed
sync devices, device description - '%s', device card id - %i, stream description - %s, stream card id - %i
Couldn't match the portless stream (with card) - '%s' is it an input ? -> %i, streams card id -> %i
Sync_devices: Failed to match stream id: %u, description: '%s', origin: '%s'
Attempt to match_stream update_with_existing_outputs - Try description : '%s', origin : '%s', device port name : '%s', card : %p, AGAINST stream port: '%s', sink card id %i
Match device with stream: We have a match with description: '%s', origin: '%s', cached already with device id %u, so set stream id to %i
pa_context_get_source_info_list() failed
pa_context_get_sink_input_info_list() failed
pa_context_get_source_output_info_list() failed
a == NULL || GVC_IS_MIXER_STREAM (a)
b == NULL || GVC_IS_MIXER_STREAM (b)
Failed to initialized stream_restore extension: %s
pa_ext_stream_restore_read() failed
sink-input-by-media-role:event
Udpating card %s (index: %u driver: %s):
	Profile '%s': %d sources %d sinks%s
%i profiles supported on port %s
Portless card just registered - %s
Portless card just registered - %i
create_ui_device_from_port, direction %u, description '%s', origin '%s', port available %i
sync port availability on card %i, card port name '%s', new available value %i
Found the relevant device %s, update its port availability flag to %i, is_output %i
Updating client: index=%u name='%s'
Ignoring event, volume changes are outstanding
Source output callback failure
Updating source output: index=%u name='%s' client=%u source=%u
GVC_IS_MIXER_CONTROL (control)
lookup device from stream - %s - it is a network_stream 
lookup-device-from-stream found device: device description '%s', device port = '%s', device stream id %i AND stream port = '%s' stream id '%u' and stream description '%s'
gvc_mixer_control_lookup_device_from_stream - Could not find a device for stream '%s'
on_default_sink_port_notify - moved to port %s - which SHOULD correspond to output %s
on_default_source_port_notify - moved to port '%s' which SHOULD ?? correspond to output '%s'
about to set default sink on server
pa_context_set_default_sink() failed: %s
pa_ext_stream_restore_read() failed: %s
pa_context_set_default_source() failed
Removing source output: index=%u
Updating sink: index=%u name='%s' description='%s' map='%s'
update sink - apparently a port update
Looks like we profile swapped on a non server default sink
Updating source: index=%u name='%s' description='%s'
update source - apparently a port update
GVC_IS_MIXER_UI_DEVICE (device)
gvc_mixer_control_get_stream_from_device - device has a null stream
Selected '%s', moving to profile '%s' on card '%s' on stream id %i
default sink name = %s and default sink id %u
Did we try to move to a software/bluetooth sink ?
Failed to set default sink with stream from output %s
Attempting to swap over to stream %s 
Did we try to move to a software/bluetooth source ?
Failed to set default source with stream from input %s
change-input - attempting to swap over to stream %s
BUG: libgnome-volume-control compiled without ALSA support
control->priv->pa_context != NULL
pa_context_get_state (control->priv->pa_context) == PA_CONTEXT_UNCONNECTED
stream-added
stream-removed
stream-changed
audio-device-selection-needed
card-added
card-removed
default-sink-changed
default-source-changed
active-output-update
active-input-update
output-added
input-added
output-removed
input-removed
!self->priv->pa_context
org.gnome.VolumeControl
multimedia-volume-control
3.22.1
application.version
gvc-mixer-control.c
audio
applications-games
dialog-information
device.icon_name
media.icon_name
window.icon_name
media.role
video
music
game
sink-input-by
source-output-by
System Sounds
origin
stream-id
port-available
GvcMixerControl
control->priv->pa_mainloop
control->priv->pa_api
GVC_IS_MIXER_CONTROL (object)
mixer_control->priv != NULL
pa_context_subscribe() failed
Removing event role
 (Current)
Card callback failure
	Property: '%s' = '%s'
Disabled
%u Outputs
%u Output
%u Inputs
%u Input
%s / %s
device.description
Client callback failure
Sink input callback failure
applications-multimedia
audio-input-microphone
GVC_IS_MIXER_STREAM (stream)
notify::port
active_sink change
Removing sink: index=%u
Removing source: index=%u
Removing sink input: index=%u
Card removal remove device %s
Server info callback failure
get server info
update server
audio-card
device.form_factor
sysfs.path
update sink - is new
Sink callback failure
Source callback failure
update source
(any)
best_profile
control change output
Port change, switch to = %s
Could not change port !
Could not change port!
Failed to connect context: %s
gvc_mixer_control_close
idle_reconnect
gvc_mixer_control_open
gvc_mixer_control_get_state
gvc_mixer_control_get_source_outputs
gvc_mixer_control_get_sink_inputs
gvc_mixer_control_get_sources
gvc_mixer_control_get_sinks
gvc_stream_collate
gvc_mixer_control_get_streams
gvc_card_collate
gvc_mixer_control_get_cards
gvc_mixer_control_change_profile_on_selected_device
gvc_mixer_control_get_stream_from_device
gvc_mixer_control_lookup_input_id
gvc_mixer_control_lookup_output_id
gvc_mixer_control_lookup_card_id
gvc_mixer_control_lookup_stream_id
gvc_mixer_control_get_default_source
gvc_mixer_control_get_default_sink
gvc_mixer_control_set_default_source
gvc_mixer_control_set_default_sink
gvc_mixer_control_get_event_sink_input
gvc_mixer_control_get_pa_context
gvc_mixer_new_pa_context
gvc_mixer_control_finalize
gvc_mixer_control_init
&@device
GvcMixerEventRole
gvc-mixer-event-role.c
channel-map
pa_ext_stream_restore_write() failed
GVC_IS_MIXER_EVENT_ROLE (role)
GVC_IS_MIXER_EVENT_ROLE (object)
mixer_event_role->priv != NULL
gvc_mixer_event_role_finalize
gvc_mixer_event_role_set_device
pa_context_set_sink_input_mute_by_index() failed
pa_context_set_sink_input_volume() failed
GVC_IS_MIXER_SINK_INPUT (object)
mixer_sink_input->priv != NULL
GvcMixerSinkInput
gvc_mixer_sink_input_finalize
pa_context_set_sink_mute_by_index() failed: %s
pa_context_set_sink_port_by_index() failed: %s
pa_context_set_sink_volume_by_index() failed: %s
GvcMixerSink
GVC_IS_MIXER_SINK (object)
mixer_sink->priv != NULL
gvc_mixer_sink_finalize
pa_context_set_source_output_mute_by_index() failed
pa_context_set_source_output_volume() failed
GVC_IS_MIXER_SOURCE_OUTPUT (object)
mixer_source_output->priv != NULL
GvcMixerSourceOutput
gvc_mixer_source_output_finalize
pa_context_set_source_port_by_index() failed: %s
pa_context_set_source_mute_by_index() failed: %s
pa_context_set_source_volume_by_index() failed: %s
GvcMixerSource
GVC_IS_MIXER_SOURCE (object)
mixer_source->priv != NULL
gvc_mixer_source_finalize
The index for this stream
The id for this stream
channel map
The volume for this stream
Volume
volume
Decibel
Description
Application identifier
Form Factor
form-factor
Sysfs path
sysfs-path
Whether stream is muted
is-muted
can decibel
can-decibel
is event stream
is-event-stream
Whether the stream is virtual
is virtual stream
is-virtual
Card index
card-index
GvcMixerStream
gvc-mixer-stream.c
GVC_IS_MIXER_STREAM (object)
mixer_stream->priv != NULL
GvcMixerStreamPort
stream->priv->ports != NULL
stream->priv->ports == NULL
The channel map for this stream
The PulseAudio context for this stream
The decibel level for this stream
Name to display for this stream
Description to display for this stream
Application identifier for this stream
Name of icon to display for this stream
Device form factor for this stream, as reported by PulseAudio
Sysfs path for the device associated with this stream
Whether stream volume can be converted to decibel units
Whether stream's role is to play an event
The name of the current port for this stream
The index of the card for this stream
Pushing new volume to stream '%s' (%s)
gvc_mixer_stream_change_is_muted
gvc_mixer_stream_push_volume
gvc_mixer_stream_set_card_index
gvc_mixer_stream_get_card_index
gvc_mixer_stream_set_ports
gvc_mixer_stream_get_ports
gvc_mixer_stream_change_port
gvc_mixer_stream_set_port
gvc_mixer_stream_get_port
gvc_mixer_stream_set_base_volume
gvc_mixer_stream_get_base_volume
gvc_mixer_stream_set_sysfs_path
gvc_mixer_stream_set_form_factor
gvc_mixer_stream_set_icon_name
gvc_mixer_stream_get_gicon
gvc_mixer_stream_get_sysfs_path
gvc_mixer_stream_get_form_factor
gvc_mixer_stream_get_icon_name
gvc_mixer_stream_set_application_id
gvc_mixer_stream_get_application_id
gvc_mixer_stream_set_is_virtual
gvc_mixer_stream_is_virtual
gvc_mixer_stream_set_is_event_stream
gvc_mixer_stream_is_event_stream
gvc_mixer_stream_set_description
gvc_mixer_stream_set_name
gvc_mixer_stream_get_description
gvc_mixer_stream_get_name
gvc_mixer_stream_set_can_decibel
gvc_mixer_stream_set_is_muted
gvc_mixer_stream_get_can_decibel
gvc_mixer_stream_get_is_muted
gvc_mixer_stream_set_decibel
gvc_mixer_stream_set_volume
gvc_mixer_stream_get_decibel
gvc_mixer_stream_get_volume
gvc_mixer_stream_get_channel_map
gvc_mixer_stream_get_id
gvc_mixer_stream_get_index
gvc_mixer_stream_get_pa_context
gvc_mixer_stream_finalize
gvc_mixer_stream_set_channel_map
no-name-set
Set first line description
Description construct prop
origin construct prop
Set/Get card
Card from pulse
Set port-name
port-name construct prop
Set/Get stream id
ui-device type
%s+%s
GvcMixerUIDevice
gvc-mixer-ui-device.c
GVC_MIXER_UI_DEVICE (object)
output:
input:
(null)
GVC_IS_MIXER_UI_DEVICE (self)
Set profiles for '%s'
Set second line description name
stream id assigned by gvc-stream
determine whether its an input and output
determine whether this port is available
The canonical name for '%s' is '%s'
Adding profile to combobox: '%s' - '%s'
gvc-mixer-output-set-property - 1st line: %s
gvc-mixer-output-set-property - 2nd line: %s
gvc-mixer-output-set-property - card: %p
gvc-mixer-output-set-property - card port name: %s
gvc-mixer-output-set-property - sink/source id: %i
gvc-mixer-output-set-property - port available %i, value passed in %i 
Matching profile for '%s' is '%s'
Candidate for profile switching: '%s'
No suitable profile candidates for '%s'
Comparing '%s' (from '%s') with '%s', prio %d
Device did not have an appropriate card
gvc_mixer_ui_device_is_output
gvc_mixer_ui_device_has_ports
gvc_mixer_ui_device_get_port
gvc_mixer_ui_device_set_user_preferred_profile
gvc_mixer_ui_device_get_top_priority_profile
gvc_mixer_ui_device_get_user_preferred_profile
gvc_mixer_ui_device_get_origin
gvc_mixer_ui_device_get_icon_name
gvc_mixer_ui_device_get_description
gvc_mixer_ui_device_invalidate_stream
gvc_mixer_ui_device_get_stream_id
gvc_mixer_ui_device_get_id
gvc_mixer_ui_device_get_supported_profiles
gvc_mixer_ui_device_get_profiles
gvc_mixer_ui_device_should_profiles_be_hidden
gvc_mixer_ui_device_get_active_profile
gvc_mixer_ui_device_dispose
gvc_mixer_ui_device_set_icon_name
GVariant
,[L1
jXo|
XH(1
sp81
popupMenu.js
// -*- mode: js; js-indent-level: 4; indent-tabs-mode: nil -*-
const Clutter = imports.gi.Clutter;
const Gtk = imports.gi.Gtk;
const Lang = imports.lang;
const Shell = imports.gi.Shell;
const Signals = imports.signals;
const St = imports.gi.St;
const Atk = imports.gi.Atk;
const BoxPointer = imports.ui.boxpointer;
const GrabHelper = imports.ui.grabHelper;
const Main = imports.ui.main;
const Params = imports.misc.params;
const Tweener = imports.ui.tweener;
const Ornament = {
    NONE: 0,
    DOT: 1,
    CHECK: 2,
function isPopupMenuItemVisible(child) {
    if (child._delegate instanceof PopupMenuSection)
        if (child._delegate.isEmpty())
            return false;
    return child.visible;
 * @side Side to which the arrow points.
function arrowIcon(side) {
    let iconName;
    switch (side) {
        case St.Side.TOP:
            iconName = 'pan-up-symbolic';
            break;
        case St.Side.RIGHT:
            iconName = 'pan-end-symbolic';
            break;
        case St.Side.BOTTOM:
            iconName = 'pan-down-symbolic';
            break;
        case St.Side.LEFT:
            iconName = 'pan-start-symbolic';
            break;
    }
    let arrow = new St.Icon({ style_class: 'popup-menu-arrow',
                              icon_name: iconName,
                              accessible_role: Atk.Role.ARROW,
                              y_expand: true,
                              y_align: Clutter.ActorAlign.CENTER });
    return arrow;
const PopupBaseMenuItem = new Lang.Class({
    Name: 'PopupBaseMenuItem',
    _init: function (params) {
        params = Params.parse (params, { reactive: true,
                                         activate: true,
                                         hover: true,
                                         style_class: null,
                                         can_focus: true
                                       });
        this.actor = new St.BoxLayout({ style_class: 'popup-menu-item',
                                        reactive: params.reactive,
                                        track_hover: params.reactive,
                                        can_focus: params.can_focus,
                                        accessible_role: Atk.Role.MENU_ITEM });
        this.actor._delegate = this;
        this._ornament = Ornament.NONE;
        this._ornamentLabel = new St.Label({ style_class: 'popup-menu-ornament' });
        this.actor.add(this._ornamentLabel);
        this._parent = null;
        this.active = false;
        this._activatable = params.reactive && params.activate;
        this._sensitive = true;
        if (!this._activatable)
            this.actor.add_style_class_name('popup-inactive-menu-item');
        if (params.style_class)
            this.actor.add_style_class_name(params.style_class);
        if (this._activatable) {
            this.actor.connect('button-press-event', Lang.bind(this, this._onButtonPressEvent));
            this.actor.connect('button-release-event', Lang.bind(this, this._onButtonReleaseEvent));
            this.actor.connect('touch-event', Lang.bind(this, this._onTouchEvent));
            this.actor.connect('key-press-event', Lang.bind(this, this._onKeyPressEvent));
        }
        if (params.reactive && params.hover)
            this.actor.connect('notify::hover', Lang.bind(this, this._onHoverChanged));
        this.actor.connect('key-focus-in', Lang.bind(this, this._onKeyFocusIn));
        this.actor.connect('key-focus-out', Lang.bind(this, this._onKeyFocusOut));
        this.actor.connect('destroy', Lang.bind(this, this._onDestroy));
    },
    _getTopMenu: function() {
        if (this._parent)
            return this._parent._getTopMenu();
        else
            return this;
    },
    _setParent: function(parent) {
        this._parent = parent;
    },
    _onButtonPressEvent: function (actor, event) {
        // This is the CSS active state
        this.actor.add_style_pseudo_class ('active');
        return Clutter.EVENT_PROPAGATE;
    },
    _onButtonReleaseEvent: function (actor, event) {
        this.actor.remove_style_pseudo_class ('active');
        this.activate(event);
        return Clutter.EVENT_STOP;
    },
    _onTouchEvent: function (actor, event) {
        if (event.type() == Clutter.EventType.TOUCH_END) {
            this.actor.remove_style_pseudo_class ('active');
            this.activate(event);
            return Clutter.EVENT_STOP;
        } else if (event.type() == Clutter.EventType.TOUCH_BEGIN) {
            // This is the CSS active state
            this.actor.add_style_pseudo_class ('active');
        }
        return Clutter.EVENT_PROPAGATE;
    },
    _onKeyPressEvent: function (actor, event) {
        let symbol = event.get_key_symbol();
        if (symbol == Clutter.KEY_space || symbol == Clutter.KEY_Return) {
            this.activate(event);
            return Clutter.EVENT_STOP;
        }
        return Clutter.EVENT_PROPAGATE;
    },
    _onKeyFocusIn: function (actor) {
        this.setActive(true);
    },
    _onKeyFocusOut: function (actor) {
        this.setActive(false);
    },
    _onHoverChanged: function (actor) {
        this.setActive(actor.hover);
    },
    activate: function (event) {
        this.emit('activate', event);
    },
    setActive: function (active) {
        let activeChanged = active != this.active;
        if (activeChanged) {
            this.active = active;
            if (active) {
                this.actor.add_style_class_name('selected');
                this.actor.grab_key_focus();
            } else {
                this.actor.remove_style_class_name('selected');
                // Remove the CSS active state if the user press the button and
                // while holding moves to another menu item, so we don't paint all items.
                // The correct behaviour would be to set the new item with the CSS
                // active state as well, but button-press-event is not trigered,
                // so we should track it in our own, which would involve some work
                // in the container
                this.actor.remove_style_pseudo_class ('active');
            }
            this.emit('active-changed', active);
        }
    },
    syncSensitive: function() {
        let sensitive = this.getSensitive();
        this.actor.reactive = sensitive;
        this.actor.can_focus = sensitive;
        this.emit('sensitive-changed');
        return sensitive;
    },
    getSensitive: function() {
        let parentSensitive = this._parent ? this._parent.getSensitive() : true;
        return this._activatable && this._sensitive && parentSensitive;
    },
    setSensitive: function(sensitive) {
        if (this._sensitive == sensitive)
            return;
        this._sensitive = sensitive;
        this.syncSensitive();
    },
    destroy: function() {
        this.actor.destroy();
    },
    _onDestroy: function() {
        this.emit('destroy');
    },
    setOrnament: function(ornament) {
        if (ornament == this._ornament)
            return;
        this._ornament = ornament;
        if (ornament == Ornament.DOT) {
            this._ornamentLabel.text = '\u2022';
            this.actor.add_accessible_state(Atk.StateType.CHECKED);
        } else if (ornament == Ornament.CHECK) {
            this._ornamentLabel.text = '\u2713';
            this.actor.add_accessible_state(Atk.StateType.CHECKED);
        } else if (ornament == Ornament.NONE) {
            this._ornamentLabel.text = '';
            this.actor.remove_accessible_state(Atk.StateType.CHECKED);
        }
    }
Signals.addSignalMethods(PopupBaseMenuItem.prototype);
const PopupMenuItem = new Lang.Class({
    Name: 'PopupMenuItem',
    Extends: PopupBaseMenuItem,
    _init: function (text, params) {
        this.parent(params);
        this.label = new St.Label({ text: text });
        this.actor.add_child(this.label);
        this.actor.label_actor = this.label
    }
const PopupSeparatorMenuItem = new Lang.Class({
    Name: 'PopupSeparatorMenuItem',
    Extends: PopupBaseMenuItem,
    _init: function (text) {
        this.parent({ reactive: false,
                      can_focus: false});
        this.label = new St.Label({ text: text || '' });
        this.actor.add(this.label);
        this.actor.label_actor = this.label;
        this.label.connect('notify::text',
                           Lang.bind(this, this._syncVisibility));
        this._syncVisibility();
        this._separator = new St.Widget({ style_class: 'popup-separator-menu-item',
                                          y_expand: true,
                                          y_align: Clutter.ActorAlign.CENTER });
        this.actor.add(this._separator, { expand: true });
    },
    _syncVisibility: function() {
        this.label.visible = this.label.text != '';
    }
const Switch = new Lang.Class({
    Name: 'Switch',
    _init: function(state) {
        this.actor = new St.Bin({ style_class: 'toggle-switch',
                                  accessible_role: Atk.Role.CHECK_BOX,
                                  can_focus: true });
        // Translators: this MUST be either "toggle-switch-us"
        // (for toggle switches containing the English words
        // "ON" and "OFF") or "toggle-switch-intl" (for toggle
        // switches containing "
" and "|"). Other values will
        // simply result in invisible toggle switches.
        this.actor.add_style_class_name(_("toggle-switch-us"));
        this.setToggleState(state);
    },
    setToggleState: function(state) {
        if (state)
            this.actor.add_style_pseudo_class('checked');
        else
            this.actor.remove_style_pseudo_class('checked');
        this.state = state;
    },
    toggle: function() {
        this.setToggleState(!this.state);
    }
const PopupSwitchMenuItem = new Lang.Class({
    Name: 'PopupSwitchMenuItem',
    Extends: PopupBaseMenuItem,
    _init: function(text, active, params) {
        this.parent(params);
        this.label = new St.Label({ text: text });
        this._switch = new Switch(active);
        this.actor.accessible_role = Atk.Role.CHECK_MENU_ITEM;
        this.checkAccessibleState();
        this.actor.label_actor = this.label;
        this.actor.add_child(this.label);
        this._statusBin = new St.Bin({ x_align: St.Align.END });
        this.actor.add(this._statusBin, { expand: true, x_align: St.Align.END });
        this._statusLabel = new St.Label({ text: '',
                                           style_class: 'popup-status-menu-item'
                                         });
        this._statusBin.child = this._switch.actor;
    },
    setStatus: function(text) {
        if (text != null) {
            this._statusLabel.text = text;
            this._statusBin.child = this._statusLabel;
            this.actor.reactive = false;
            this.actor.accessible_role = Atk.Role.MENU_ITEM;
        } else {
            this._statusBin.child = this._switch.actor;
            this.actor.reactive = true;
            this.actor.accessible_role = Atk.Role.CHECK_MENU_ITEM;
        }
        this.checkAccessibleState();
    },
    activate: function(event) {
        if (this._switch.actor.mapped) {
            this.toggle();
        }
        // we allow pressing space to toggle the switch
        // without closing the menu
        if (event.type() == Clutter.EventType.KEY_PRESS &&
            event.get_key_symbol() == Clutter.KEY_space)
            return;
        this.parent(event);
    },
    toggle: function() {
        this._switch.toggle();
        this.emit('toggled', this._switch.state);
        this.checkAccessibleState();
    },
    get state() {
        return this._switch.state;
    },
    setToggleState: function(state) {
        this._switch.setToggleState(state);
        this.checkAccessibleState();
    },
    checkAccessibleState: function() {
        switch (this.actor.accessible_role) {
        case Atk.Role.CHECK_MENU_ITEM:
            if (this._switch.state)
                this.actor.add_accessible_state (Atk.StateType.CHECKED);
            else
                this.actor.remove_accessible_state (Atk.StateType.CHECKED);
            break;
        default:
            this.actor.remove_accessible_state (Atk.StateType.CHECKED);
        }
    }
const PopupImageMenuItem = new Lang.Class({
    Name: 'PopupImageMenuItem',
    Extends: PopupBaseMenuItem,
    _init: function (text, iconName, params) {
        this.parent(params);
        this.label = new St.Label({ text: text });
        this.actor.add_child(this.label);
        this._icon = new St.Icon({ style_class: 'popup-menu-icon' });
        this.actor.add_child(this._icon, { align: St.Align.END });
        this.actor.label_actor = this.label;
        this.setIcon(iconName);
    },
    setIcon: function(name) {
        this._icon.icon_name = name;
    }
const PopupMenuBase = new Lang.Class({
    Name: 'PopupMenuBase',
    Abstract: true,
    _init: function(sourceActor, styleClass) {
        this.sourceActor = sourceActor;
        this._parent = null;
        if (styleClass !== undefined) {
            this.box = new St.BoxLayout({ style_class: styleClass,
                                          vertical: true });
        } else {
            this.box = new St.BoxLayout({ vertical: true });
        }
        this.length = 0;
        this.isOpen = false;
        // If set, we don't send events (including crossing events) to the source actor
        // for the menu which causes its prelight state to freeze
        this.blockSourceEvents = false;
        this._activeMenuItem = null;
        this._settingsActions = { };
        this._sensitive = true;
        this._sessionUpdatedId = Main.sessionMode.connect('updated', Lang.bind(this, this._sessionUpdated));
    },
    _getTopMenu: function() {
        if (this._parent)
            return this._parent._getTopMenu();
        else
            return this;
    },
    _setParent: function(parent) {
        this._parent = parent;
    },
    getSensitive: function() {
        let parentSensitive = this._parent ? this._parent.getSensitive() : true;
        return this._sensitive && parentSensitive;
    },
    setSensitive: function(sensitive) {
        this._sensitive = sensitive;
        this.emit('sensitive-changed');
    },
    _sessionUpdated: function() {
        this._setSettingsVisibility(Main.sessionMode.allowSettings);
    },
    addAction: function(title, callback) {
        let menuItem = new PopupMenuItem(title);
        this.addMenuItem(menuItem);
        menuItem.connect('activate', Lang.bind(this, function (menuItem, event) {
            callback(event);
        }));
        return menuItem;
    },
    addSettingsAction: function(title, desktopFile) {
        let menuItem = this.addAction(title, function() {
                           let app = Shell.AppSystem.get_default().lookup_app(desktopFile);
                           if (!app) {
                               log('Settings panel for desktop file ' + desktopFile + ' could not be loaded!');
                               return;
                           }
                           Main.overview.hide();
                           app.activate();
                       });
        menuItem.actor.visible = Main.sessionMode.allowSettings;
        this._settingsActions[desktopFile] = menuItem;
        return menuItem;
    },
    _setSettingsVisibility: function(visible) {
        for (let id in this._settingsActions) {
            let item = this._settingsActions[id];
            item.actor.visible = visible;
        }
    },
    isEmpty: function() {
        let hasVisibleChildren = this.box.get_children().some(function(child) {
            if (child._delegate instanceof PopupSeparatorMenuItem)
                return false;
            return isPopupMenuItemVisible(child);
        });
        return !hasVisibleChildren;
    },
    itemActivated: function(animate) {
        if (animate == undefined)
            animate = BoxPointer.PopupAnimation.FULL;
        this._getTopMenu().close(animate);
    },
    _subMenuActiveChanged: function(submenu, submenuItem) {
        if (this._activeMenuItem && this._activeMenuItem != submenuItem)
            this._activeMenuItem.setActive(false);
        this._activeMenuItem = submenuItem;
        this.emit('active-changed', submenuItem);
    },
    _connectItemSignals: function(menuItem) {
        menuItem._activeChangeId = menuItem.connect('active-changed', Lang.bind(this, function (menuItem, active) {
            if (active && this._activeMenuItem != menuItem) {
                if (this._activeMenuItem)
                    this._activeMenuItem.setActive(false);
                this._activeMenuItem = menuItem;
                this.emit('active-changed', menuItem);
            } else if (!active && this._activeMenuItem == menuItem) {
                this._activeMenuItem = null;
                this.emit('active-changed', null);
            }
        }));
        menuItem._sensitiveChangeId = menuItem.connect('sensitive-changed', Lang.bind(this, function() {
            let sensitive = menuItem.getSensitive();
            if (!sensitive && this._activeMenuItem == menuItem) {
                if (!this.actor.navigate_focus(menuItem.actor,
                                               Gtk.DirectionType.TAB_FORWARD,
                                               true))
                    this.actor.grab_key_focus();
            } else if (sensitive && this._activeMenuItem == null) {
                if (global.stage.get_key_focus() == this.actor)
                    menuItem.actor.grab_key_focus();
            }
        }));
        menuItem._activateId = menuItem.connect('activate', Lang.bind(this, function (menuItem, event) {
            this.emit('activate', menuItem);
            this.itemActivated(BoxPointer.PopupAnimation.FULL);
        }));
        menuItem._parentSensitiveChangeId = this.connect('sensitive-changed', Lang.bind(this, function() {
            menuItem.syncSensitive();
        }));
        // the weird name is to avoid a conflict with some random property
        // the menuItem may have, called destroyId
        // (FIXME: in the future it may make sense to have container objects
        // like PopupMenuManager does)
        menuItem._popupMenuDestroyId = menuItem.connect('destroy', Lang.bind(this, function(menuItem) {
            menuItem.disconnect(menuItem._popupMenuDestroyId);
            menuItem.disconnect(menuItem._activateId);
            menuItem.disconnect(menuItem._activeChangeId);
            menuItem.disconnect(menuItem._sensitiveChangeId);
            this.disconnect(menuItem._parentSensitiveChangeId);
            if (menuItem == this._activeMenuItem)
                this._activeMenuItem = null;
        }));
    },
    _updateSeparatorVisibility: function(menuItem) {
        if (menuItem.label.text)
            return;
        let children = this.box.get_children();
        let index = children.indexOf(menuItem.actor);
        if (index < 0)
            return;
        let childBeforeIndex = index - 1;
        while (childBeforeIndex >= 0 && !isPopupMenuItemVisible(children[childBeforeIndex]))
            childBeforeIndex--;
        if (childBeforeIndex < 0
            || children[childBeforeIndex]._delegate instanceof PopupSeparatorMenuItem) {
            menuItem.actor.hide();
            return;
        }
        let childAfterIndex = index + 1;
        while (childAfterIndex < children.length && !isPopupMenuItemVisible(children[childAfterIndex]))
            childAfterIndex++;
        if (childAfterIndex >= children.length
            || children[childAfterIndex]._delegate instanceof PopupSeparatorMenuItem) {
            menuItem.actor.hide();
            return;
        }
        menuItem.actor.show();
    },
    addMenuItem: function(menuItem, position) {
        let before_item = null;
        if (position == undefined) {
            this.box.add(menuItem.actor);
        } else {
            let items = this._getMenuItems();
            if (position < items.length) {
                before_item = items[position].actor;
                this.box.insert_child_below(menuItem.actor, before_item);
            } else {
                this.box.add(menuItem.actor);
            }
        }
        if (menuItem instanceof PopupMenuSection) {
            let activeChangeId = menuItem.connect('active-changed', Lang.bind(this, this._subMenuActiveChanged));
            let parentOpenStateChangedId = this.connect('open-state-changed', function(self, open) {
                if (open)
                    menuItem.open();
                else
                    menuItem.close();
            });
            let parentClosingId = this.connect('menu-closed', function() {
                menuItem.emit('menu-closed');
            });
            let subMenuSensitiveChangedId = this.connect('sensitive-changed', Lang.bind(this, function() {
                menuItem.emit('sensitive-changed');
            }));
            menuItem.connect('destroy', Lang.bind(this, function() {
                menuItem.disconnect(activeChangeId);
                this.disconnect(subMenuSensitiveChangedId);
                this.disconnect(parentOpenStateChangedId);
                this.disconnect(parentClosingId);
                this.length--;
            }));
        } else if (menuItem instanceof PopupSubMenuMenuItem) {
            if (before_item == null)
                this.box.add(menuItem.menu.actor);
            else
                this.box.insert_child_below(menuItem.menu.actor, before_item);
            this._connectItemSignals(menuItem);
            let subMenuActiveChangeId = menuItem.menu.connect('active-changed', Lang.bind(this, this._subMenuActiveChanged));
            let closingId = this.connect('menu-closed', function() {
                menuItem.menu.close(BoxPointer.PopupAnimation.NONE);
            });
            menuItem.connect('destroy', Lang.bind(this, function() {
                menuItem.menu.disconnect(subMenuActiveChangeId);
                this.disconnect(closingId);
            }));
        } else if (menuItem instanceof PopupSeparatorMenuItem) {
            this._connectItemSignals(menuItem);
            // updateSeparatorVisibility needs to get called any time the
            // separator's adjacent siblings change visibility or position.
            // open-state-changed isn't exactly that, but doing it in more
            // precise ways would require a lot more bookkeeping.
            let openStateChangeId = this.connect('open-state-changed', Lang.bind(this, function() { this._updateSeparatorVisibility(menuItem); }));
            let destroyId = menuItem.connect('destroy', Lang.bind(this, function() {
                this.disconnect(openStateChangeId);
                menuItem.disconnect(destroyId);
            }));
        } else if (menuItem instanceof PopupBaseMenuItem)
            this._connectItemSignals(menuItem);
        else
            throw TypeError("Invalid argument to PopupMenuBase.addMenuItem()");
        menuItem._setParent(this);
        this.length++;
    },
    _getMenuItems: function() {
        return this.box.get_children().map(function (actor) {
            return actor._delegate;
        }).filter(function(item) {
            return item instanceof PopupBaseMenuItem || item instanceof PopupMenuSection;
        });
    },
    get firstMenuItem() {
        let items = this._getMenuItems();
        if (items.length)
            return items[0];
        else
            return null;
    },
    get numMenuItems() {
        return this._getMenuItems().length;
    },
    removeAll: function() {
        let children = this._getMenuItems();
        for (let i = 0; i < children.length; i++) {
            let item = children[i];
            item.destroy();
        }
    },
    toggle: function() {
        if (this.isOpen)
            this.close(BoxPointer.PopupAnimation.FULL);
        else
            this.open(BoxPointer.PopupAnimation.FULL);
    },
    destroy: function() {
        this.close();
        this.removeAll();
        this.actor.destroy();
        this.emit('destroy');
        Main.sessionMode.disconnect(this._sessionUpdatedId);
        this._sessionUpdatedId = 0;
    }
Signals.addSignalMethods(PopupMenuBase.prototype);
const PopupMenu = new Lang.Class({
    Name: 'PopupMenu',
    Extends: PopupMenuBase,
    _init: function(sourceActor, arrowAlignment, arrowSide) {
        this.parent(sourceActor, 'popup-menu-content');
        this._arrowAlignment = arrowAlignment;
        this._arrowSide = arrowSide;
        this._boxPointer = new BoxPointer.BoxPointer(arrowSide,
                                                     { x_fill: true,
                                                       y_fill: true,
                                                       x_align: St.Align.START });
        this.actor = this._boxPointer.actor;
        this.actor._delegate = this;
        this.actor.style_class = 'popup-menu-boxpointer';
        this._boxPointer.bin.set_child(this.box);
        this.actor.add_style_class_name('popup-menu');
        global.focus_manager.add_group(this.actor);
        this.actor.reactive = true;
        if (this.sourceActor)
            this._keyPressId = this.sourceActor.connect('key-press-event',
                                                        Lang.bind(this, this._onKeyPress));
        this._openedSubMenu = null;
    },
    _setOpenedSubMenu: function(submenu) {
        if (this._openedSubMenu)
            this._openedSubMenu.close(true);
        this._openedSubMenu = submenu;
    },
    _onKeyPress: function(actor, event) {
        let navKey;
        switch (this._boxPointer.arrowSide) {
            case St.Side.TOP:
                navKey = Clutter.KEY_Down;
                break;
            case St.Side.BOTTOM:
                navKey = Clutter.KEY_Up;
                break;
            case St.Side.LEFT:
                navKey = Clutter.KEY_Right;
                break;
            case St.Side.RIGHT:
                navKey = Clutter.KEY_Left;
                break;
        }
        let symbol = event.get_key_symbol();
        if (symbol == Clutter.KEY_space || symbol == Clutter.KEY_Return) {
            this.toggle();
            return Clutter.EVENT_STOP;
        } else if (symbol == Clutter.KEY_Escape && this.isOpen) {
            this.close();
            return Clutter.EVENT_STOP;
        } else if (symbol == navKey) {
            if (!this.isOpen)
                this.toggle();
            this.actor.navigate_focus(null, Gtk.DirectionType.TAB_FORWARD, false);
            return Clutter.EVENT_STOP;
        } else
            return Clutter.EVENT_PROPAGATE;
    },
    setArrowOrigin: function(origin) {
        this._boxPointer.setArrowOrigin(origin);
    },
    setSourceAlignment: function(alignment) {
        this._boxPointer.setSourceAlignment(alignment);
    },
    open: function(animate) {
        if (this.isOpen)
            return;
        if (this.isEmpty())
            return;
        this.isOpen = true;
        this._boxPointer.setPosition(this.sourceActor, this._arrowAlignment);
        this._boxPointer.show(animate);
        this.actor.raise_top();
        this.emit('open-state-changed', true);
    },
    close: function(animate) {
        if (this._activeMenuItem)
            this._activeMenuItem.setActive(false);
        if (this._boxPointer.actor.visible) {
            this._boxPointer.hide(animate, Lang.bind(this, function() {
                this.emit('menu-closed');
            }));
        }
        if (!this.isOpen)
            return;
        this.isOpen = false;
        this.emit('open-state-changed', false);
    },
    destroy: function() {
        if (this._keyPressId)
            this.sourceActor.disconnect(this._keyPressId);
        this.parent();
    }
const PopupDummyMenu = new Lang.Class({
    Name: 'PopupDummyMenu',
    _init: function(sourceActor) {
        this.sourceActor = sourceActor;
        this.actor = sourceActor;
        this.actor._delegate = this;
    },
    getSensitive: function() {
        return true;
    },
    open: function() { this.emit('open-state-changed', true); },
    close: function() { this.emit('open-state-changed', false); },
    toggle: function() {},
    destroy: function() {
        this.emit('destroy');
    },
Signals.addSignalMethods(PopupDummyMenu.prototype);
const PopupSubMenu = new Lang.Class({
    Name: 'PopupSubMenu',
    Extends: PopupMenuBase,
    _init: function(sourceActor, sourceArrow) {
        this.parent(sourceActor);
        this._arrow = sourceArrow;
        // Since a function of a submenu might be to provide a "More.." expander
        // with long content, we make it scrollable - the scrollbar will only take
        // effect if a CSS max-height is set on the top menu.
        this.actor = new St.ScrollView({ style_class: 'popup-sub-menu',
                                         hscrollbar_policy: Gtk.PolicyType.NEVER,
                                         vscrollbar_policy: Gtk.PolicyType.NEVER });
        this.actor.add_actor(this.box);
        this.actor._delegate = this;
        this.actor.clip_to_allocation = true;
        this.actor.connect('key-press-event', Lang.bind(this, this._onKeyPressEvent));
        this.actor.hide();
    },
    _needsScrollbar: function() {
        let topMenu = this._getTopMenu();
        let [topMinHeight, topNaturalHeight] = topMenu.actor.get_preferred_height(-1);
        let topThemeNode = topMenu.actor.get_theme_node();
        let topMaxHeight = topThemeNode.get_max_height();
        return topMaxHeight >= 0 && topNaturalHeight >= topMaxHeight;
    },
    getSensitive: function() {
        return this._sensitive && this.sourceActor._delegate.getSensitive();
    },
    open: function(animate) {
        if (this.isOpen)
            return;
        if (this.isEmpty())
            return;
        this.isOpen = true;
        this.emit('open-state-changed', true);
        this.actor.show();
        let needsScrollbar = this._needsScrollbar();
        // St.ScrollView always requests space horizontally for a possible vertical
        // scrollbar if in AUTOMATIC mode. Doing better would require implementation
        // of width-for-height in St.BoxLayout and St.ScrollView. This looks bad
        // when we *don't* need it, so turn off the scrollbar when that's true.
        // Dynamic changes in whether we need it aren't handled properly.
        this.actor.vscrollbar_policy =
            needsScrollbar ? Gtk.PolicyType.AUTOMATIC : Gtk.PolicyType.NEVER;
        if (needsScrollbar)
            this.actor.add_style_pseudo_class('scrolled');
        else
            this.actor.remove_style_pseudo_class('scrolled');
        // It looks funny if we animate with a scrollbar (at what point is
        // the scrollbar added?) so just skip that case
        if (animate && needsScrollbar)
            animate = false;
        let targetAngle = this.actor.text_direction == Clutter.TextDirection.RTL ? -90 : 90;
        if (animate) {
            let [minHeight, naturalHeight] = this.actor.get_preferred_height(-1);
            this.actor.height = 0;
            this.actor._arrowRotation = this._arrow.rotation_angle_z;
            Tweener.addTween(this.actor,
                             { _arrowRotation: targetAngle,
                               height: naturalHeight,
                               time: 0.25,
                               onUpdateScope: this,
                               onUpdate: function() {
                                   this._arrow.rotation_angle_z = this.actor._arrowRotation;
                               },
                               onCompleteScope: this,
                               onComplete: function() {
                                   this.actor.set_height(-1);
                               }
                             });
        } else {
            this._arrow.rotation_angle_z = targetAngle;
        }
    },
    close: function(animate) {
        if (!this.isOpen)
            return;
        this.isOpen = false;
        this.emit('open-state-changed', false);
        if (this._activeMenuItem)
            this._activeMenuItem.setActive(false);
        if (animate && this._needsScrollbar())
            animate = false;
        if (animate) {
            this.actor._arrowRotation = this._arrow.rotation_angle_z;
            Tweener.addTween(this.actor,
                             { _arrowRotation: 0,
                               height: 0,
                               time: 0.25,
                               onUpdateScope: this,
                               onUpdate: function() {
                                   this._arrow.rotation_angle_z = this.actor._arrowRotation;
                               },
                               onCompleteScope: this,
                               onComplete: function() {
                                   this.actor.hide();
                                   this.actor.set_height(-1);
                               },
                             });
        } else {
            this._arrow.rotation_angle_z = 0;
            this.actor.hide();
        }
    },
    _onKeyPressEvent: function(actor, event) {
        // Move focus back to parent menu if the user types Left.
        if (this.isOpen && event.get_key_symbol() == Clutter.KEY_Left) {
            this.close(BoxPointer.PopupAnimation.FULL);
            this.sourceActor._delegate.setActive(true);
            return Clutter.EVENT_STOP;
        }
        return Clutter.EVENT_PROPAGATE;
    }
 * PopupMenuSection:
 * A section of a PopupMenu which is handled like a submenu
 * (you can add and remove items, you can destroy it, you
 * can add it to another menu), but is completely transparent
 * to the user
const PopupMenuSection = new Lang.Class({
    Name: 'PopupMenuSection',
    Extends: PopupMenuBase,
    _init: function() {
        this.parent();
        this.actor = this.box;
        this.actor._delegate = this;
        this.isOpen = true;
    },
    // deliberately ignore any attempt to open() or close(), but emit the
    // corresponding signal so children can still pick it up
    open: function() { this.emit('open-state-changed', true); },
    close: function() { this.emit('open-state-changed', false); },
const PopupSubMenuMenuItem = new Lang.Class({
    Name: 'PopupSubMenuMenuItem',
    Extends: PopupBaseMenuItem,
    _init: function(text, wantIcon) {
        this.parent();
        this.actor.add_style_class_name('popup-submenu-menu-item');
        if (wantIcon) {
            this.icon = new St.Icon({ style_class: 'popup-menu-icon' });
            this.actor.add_child(this.icon);
        }
        this.label = new St.Label({ text: text,
                                    y_expand: true,
                                    y_align: Clutter.ActorAlign.CENTER });
        this.actor.add_child(this.label);
        this.actor.label_actor = this.label;
        let expander = new St.Bin({ style_class: 'popup-menu-item-expander' });
        this.actor.add(expander, { expand: true });
        this._triangle = arrowIcon(St.Side.RIGHT);
        this._triangle.pivot_point = new Clutter.Point({ x: 0.5, y: 0.6 });
        this._triangleBin = new St.Widget({ y_expand: true,
                                            y_align: Clutter.ActorAlign.CENTER });
        this._triangleBin.add_child(this._triangle);
        this.actor.add_child(this._triangleBin);
        this.actor.add_accessible_state (Atk.StateType.EXPANDABLE);
        this.menu = new PopupSubMenu(this.actor, this._triangle);
        this.menu.connect('open-state-changed', Lang.bind(this, this._subMenuOpenStateChanged));
    },
    _setParent: function(parent) {
        this.parent(parent);
        this.menu._setParent(parent);
    },
    syncSensitive: function() {
        let sensitive = this.parent();
        this._triangle.visible = sensitive;
        if (!sensitive)
            this.menu.close(false);
    },
    _subMenuOpenStateChanged: function(menu, open) {
        if (open) {
            this.actor.add_style_pseudo_class('open');
            this._getTopMenu()._setOpenedSubMenu(this.menu);
            this.actor.add_accessible_state (Atk.StateType.EXPANDED);
            this.actor.add_style_pseudo_class('checked');
        } else {
            this.actor.remove_style_pseudo_class('open');
            this._getTopMenu()._setOpenedSubMenu(null);
            this.actor.remove_accessible_state (Atk.StateType.EXPANDED);
            this.actor.remove_style_pseudo_class('checked');
        }
    },
    destroy: function() {
        this.menu.destroy();
        this.parent();
    },
    setSubmenuShown: function(open) {
        if (open)
            this.menu.open(BoxPointer.PopupAnimation.FULL);
        else
            this.menu.close(BoxPointer.PopupAnimation.FULL);
    },
    _setOpenState: function(open) {
        this.setSubmenuShown(open);
    },
    _getOpenState: function() {
        return this.menu.isOpen;
    },
    _onKeyPressEvent: function(actor, event) {
        let symbol = event.get_key_symbol();
        if (symbol == Clutter.KEY_Right) {
            this._setOpenState(true);
            this.menu.actor.navigate_focus(null, Gtk.DirectionType.DOWN, false);
            return Clutter.EVENT_STOP;
        } else if (symbol == Clutter.KEY_Left && this._getOpenState()) {
            this._setOpenState(false);
            return Clutter.EVENT_STOP;
        }
        return this.parent(actor, event);
    },
    activate: function(event) {
        this._setOpenState(true);
    },
    _onButtonReleaseEvent: function(actor) {
        // Since we override the parent, we need to manage what the parent does
        // with the active style class
        this.actor.remove_style_pseudo_class ('active');
        this._setOpenState(!this._getOpenState());
        return Clutter.EVENT_PROPAGATE;
    },
    _onTouchEvent: function(actor, event) {
        if (event.type() == Clutter.EventType.TOUCH_END) {
            // Since we override the parent, we need to manage what the parent does
            // with the active style class
            this.actor.remove_style_pseudo_class ('active');
            this._setOpenState(!this._getOpenState());
        }
        return Clutter.EVENT_PROPAGATE;
    }
/* Basic implementation of a menu manager.
 * Call addMenu to add menus
const PopupMenuManager = new Lang.Class({
    Name: 'PopupMenuManager',
    _init: function(owner, grabParams) {
        grabParams = Params.parse(grabParams,
                                  { actionMode: Shell.ActionMode.POPUP });
        this._owner = owner;
        this._grabHelper = new GrabHelper.GrabHelper(owner.actor, grabParams);
        this._menus = [];
    },
    addMenu: function(menu, position) {
        if (this._findMenu(menu) > -1)
            return;
        let menudata = {
            menu:              menu,
            openStateChangeId: menu.connect('open-state-changed', Lang.bind(this, this._onMenuOpenState)),
            destroyId:         menu.connect('destroy', Lang.bind(this, this._onMenuDestroy)),
            enterId:           0,
            focusInId:         0
        };
        let source = menu.sourceActor;
        if (source) {
            if (!menu.blockSourceEvents)
                this._grabHelper.addActor(source);
            menudata.enterId = source.connect('enter-event', Lang.bind(this, function() { return this._onMenuSourceEnter(menu); }));
            menudata.focusInId = source.connect('key-focus-in', Lang.bind(this, function() { this._onMenuSourceEnter(menu); }));
        }
        if (position == undefined)
            this._menus.push(menudata);
        else
            this._menus.splice(position, 0, menudata);
    },
    removeMenu: function(menu) {
        if (menu == this.activeMenu)
            this._closeMenu(false, menu);
        let position = this._findMenu(menu);
        if (position == -1) // not a menu we manage
            return;
        let menudata = this._menus[position];
        menu.disconnect(menudata.openStateChangeId);
        menu.disconnect(menudata.destroyId);
        if (menudata.enterId)
            menu.sourceActor.disconnect(menudata.enterId);
        if (menudata.focusInId)
            menu.sourceActor.disconnect(menudata.focusInId);
        if (menu.sourceActor)
            this._grabHelper.removeActor(menu.sourceActor);
        this._menus.splice(position, 1);
    },
    get activeMenu() {
        let firstGrab = this._grabHelper.grabStack[0];
        if (firstGrab)
            return firstGrab.actor._delegate;
        else
            return null;
    },
    ignoreRelease: function() {
        return this._grabHelper.ignoreRelease();
    },
    _onMenuOpenState: function(menu, open) {
        if (open) {
            if (this.activeMenu)
                this.activeMenu.close(BoxPointer.PopupAnimation.FADE);
            this._grabHelper.grab({ actor: menu.actor, focus: menu.sourceActor,
                                    onUngrab: Lang.bind(this, this._closeMenu, menu) });
        } else {
            this._grabHelper.ungrab({ actor: menu.actor });
        }
    },
    _changeMenu: function(newMenu) {
        newMenu.open(this.activeMenu ? BoxPointer.PopupAnimation.FADE
                                     : BoxPointer.PopupAnimation.FULL);
    },
    _onMenuSourceEnter: function(menu) {
        if (!this._grabHelper.grabbed)
            return Clutter.EVENT_PROPAGATE;
        if (this._grabHelper.isActorGrabbed(menu.actor))
            return Clutter.EVENT_PROPAGATE;
        this._changeMenu(menu);
        return Clutter.EVENT_PROPAGATE;
    },
    _onMenuDestroy: function(menu) {
        this.removeMenu(menu);
    },
    _findMenu: function(item) {
        for (let i = 0; i < this._menus.length; i++) {
            let menudata = this._menus[i];
            if (item == menudata.menu)
                return i;
        }
        return -1;
    },
    _closeMenu: function(isUser, menu) {
        // If this isn't a user action, we called close()
        // on the BoxPointer ourselves, so we shouldn't
        // reanimate.
        if (isUser)
            menu.close(BoxPointer.PopupAnimation.FULL);
    }
(uuay)panelMenu.js
// -*- mode: js; js-indent-level: 4; indent-tabs-mode: nil -*-
const Clutter = imports.gi.Clutter;
const Gio = imports.gi.Gio;
const Gtk = imports.gi.Gtk;
const Lang = imports.lang;
const Shell = imports.gi.Shell;
const Signals = imports.signals;
const St = imports.gi.St;
const Atk = imports.gi.Atk;
const Main = imports.ui.main;
const Params = imports.misc.params;
const PopupMenu = imports.ui.popupMenu;
const ButtonBox = new Lang.Class({
    Name: 'ButtonBox',
    _init: function(params) {
        params = Params.parse(params, { style_class: 'panel-button' }, true);
        this.actor = new Shell.GenericContainer(params);
        this.actor._delegate = this;
        this.container = new St.Bin({ y_fill: true,
                                      x_fill: true,
                                      child: this.actor });
        this.actor.connect('get-preferred-width', Lang.bind(this, this._getPreferredWidth));
        this.actor.connect('get-preferred-height', Lang.bind(this, this._getPreferredHeight));
        this.actor.connect('allocate', Lang.bind(this, this._allocate));
        this.actor.connect('style-changed', Lang.bind(this, this._onStyleChanged));
        this._minHPadding = this._natHPadding = 0.0;
    },
    _onStyleChanged: function(actor) {
        let themeNode = actor.get_theme_node();
        this._minHPadding = themeNode.get_length('-minimum-hpadding');
        this._natHPadding = themeNode.get_length('-natural-hpadding');
    },
    _getPreferredWidth: function(actor, forHeight, alloc) {
        let child = actor.get_first_child();
        if (child) {
            [alloc.min_size, alloc.natural_size] = child.get_preferred_width(-1);
        } else {
            alloc.min_size = alloc.natural_size = 0;
        }
        alloc.min_size += 2 * this._minHPadding;
        alloc.natural_size += 2 * this._natHPadding;
    },
    _getPreferredHeight: function(actor, forWidth, alloc) {
        let child = actor.get_first_child();
        if (child) {
            [alloc.min_size, alloc.natural_size] = child.get_preferred_height(-1);
        } else {
            alloc.min_size = alloc.natural_size = 0;
        }
    },
    _allocate: function(actor, box, flags) {
        let child = actor.get_first_child();
        if (!child)
            return;
        let [minWidth, natWidth] = child.get_preferred_width(-1);
        let availWidth = box.x2 - box.x1;
        let availHeight = box.y2 - box.y1;
        let childBox = new Clutter.ActorBox();
        if (natWidth + 2 * this._natHPadding <= availWidth) {
            childBox.x1 = this._natHPadding;
            childBox.x2 = availWidth - this._natHPadding;
        } else {
            childBox.x1 = this._minHPadding;
            childBox.x2 = availWidth - this._minHPadding;
        }
        childBox.y1 = 0;
        childBox.y2 = availHeight;
        child.allocate(childBox, flags);
    },
const Button = new Lang.Class({
    Name: 'PanelMenuButton',
    Extends: ButtonBox,
    _init: function(menuAlignment, nameText, dontCreateMenu) {
        this.parent({ reactive: true,
                      can_focus: true,
                      track_hover: true,
                      accessible_name: nameText ? nameText : "",
                      accessible_role: Atk.Role.MENU });
        this.actor.connect('event', Lang.bind(this, this._onEvent));
        this.actor.connect('notify::visible', Lang.bind(this, this._onVisibilityChanged));
        if (dontCreateMenu)
            this.menu = new PopupMenu.PopupDummyMenu(this.actor);
        else
            this.setMenu(new PopupMenu.PopupMenu(this.actor, menuAlignment, St.Side.TOP, 0));
    },
    setSensitive: function(sensitive) {
        this.actor.reactive = sensitive;
        this.actor.can_focus = sensitive;
        this.actor.track_hover = sensitive;
    },
    setMenu: function(menu) {
        if (this.menu)
            this.menu.destroy();
        this.menu = menu;
        if (this.menu) {
            this.menu.actor.add_style_class_name('panel-menu');
            this.menu.connect('open-state-changed', Lang.bind(this, this._onOpenStateChanged));
            this.menu.actor.connect('key-press-event', Lang.bind(this, this._onMenuKeyPress));
            Main.uiGroup.add_actor(this.menu.actor);
            this.menu.actor.hide();
        }
        this.emit('menu-set');
    },
    _onEvent: function(actor, event) {
        if (this.menu &&
            (event.type() == Clutter.EventType.TOUCH_BEGIN ||
             event.type() == Clutter.EventType.BUTTON_PRESS))
            this.menu.toggle();
        return Clutter.EVENT_PROPAGATE;
    },
    _onVisibilityChanged: function() {
        if (!this.menu)
            return;
        if (!this.actor.visible)
            this.menu.close();
    },
    _onMenuKeyPress: function(actor, event) {
        if (global.focus_manager.navigate_from_event(event))
            return Clutter.EVENT_STOP;
        let symbol = event.get_key_symbol();
        if (symbol == Clutter.KEY_Left || symbol == Clutter.KEY_Right) {
            let group = global.focus_manager.get_group(this.actor);
            if (group) {
                let direction = (symbol == Clutter.KEY_Left) ? Gtk.DirectionType.LEFT : Gtk.DirectionType.RIGHT;
                group.navigate_focus(this.actor, direction, false);
                return Clutter.EVENT_STOP;
            }
        }
        return Clutter.EVENT_PROPAGATE;
    },
    _onOpenStateChanged: function(menu, open) {
        if (open)
            this.actor.add_style_pseudo_class('active');
        else
            this.actor.remove_style_pseudo_class('active');
        // Setting the max-height won't do any good if the minimum height of the
        // menu is higher then the screen; it's useful if part of the menu is
        // scrollable so the minimum height is smaller than the natural height
        let workArea = Main.layoutManager.getWorkAreaForMonitor(Main.layoutManager.primaryIndex);
        let verticalMargins = this.menu.actor.margin_top + this.menu.actor.margin_bottom;
        this.menu.actor.style = ('max-height: ' + Math.round(workArea.height - verticalMargins) + 'px;');
    },
    destroy: function() {
        this.actor._delegate = null;
        if (this.menu)
            this.menu.destroy();
        this.actor.destroy();
        this.emit('destroy');
    }
Signals.addSignalMethods(Button.prototype);
/* SystemIndicator:
 * This class manages one system indicator, which are the icons
 * that you see at the top right. A system indicator is composed
 * of an icon and a menu section, which will be composed into the
 * aggregate menu.
const SystemIndicator = new Lang.Class({
    Name: 'SystemIndicator',
    _init: function() {
        this.indicators = new St.BoxLayout({ style_class: 'panel-status-indicators-box',
                                             reactive: true });
        this.indicators.hide();
        this.menu = new PopupMenu.PopupMenuSection();
    },
    _syncIndicatorsVisible: function() {
        this.indicators.visible = this.indicators.get_children().some(function(actor) {
            return actor.visible;
        });
    },
    _addIndicator: function() {
        let icon = new St.Icon({ style_class: 'system-status-icon' });
        this.indicators.add_actor(icon);
        icon.connect('notify::visible', Lang.bind(this, this._syncIndicatorsVisible));
        this._syncIndicatorsVisible();
        return icon;
    }
Signals.addSignalMethods(SystemIndicator.prototype);
(uuay)windowMenu.js
// -*- mode: js; js-indent-level: 4; indent-tabs-mode: nil -*
const Gtk = imports.gi.Gtk;
const Lang = imports.lang;
const Meta = imports.gi.Meta;
const St = imports.gi.St;
const Shell = imports.gi.Shell;
const BoxPointer = imports.ui.boxpointer;
const Main = imports.ui.main;
const PopupMenu = imports.ui.popupMenu;
const RemoteMenu = imports.ui.remoteMenu;
const WindowMenu = new Lang.Class({
    Name: 'WindowMenu',
    Extends: PopupMenu.PopupMenu,
    _init: function(window, sourceActor) {
        this.parent(sourceActor, 0, St.Side.TOP);
        this.actor.add_style_class_name('window-menu');
        Main.layoutManager.uiGroup.add_actor(this.actor);
        this.actor.hide();
        this._buildMenu(window);
    },
    _buildMenu: function(window) {
        let type = window.get_window_type();
        let item;
        item = this.addAction(_("Minimize"), Lang.bind(this, function(event) {
            window.minimize();
        }));
        if (!window.can_minimize())
            item.setSensitive(false);
        if (window.get_maximized()) {
            item = this.addAction(_("Unmaximize"), Lang.bind(this, function() {
                window.unmaximize(Meta.MaximizeFlags.BOTH);
            }));
        } else {
            item = this.addAction(_("Maximize"), Lang.bind(this, function() {
                window.maximize(Meta.MaximizeFlags.BOTH);
            }));
        }
        if (!window.can_maximize())
            item.setSensitive(false);
        item = this.addAction(_("Move"), Lang.bind(this, function(event) {
            window.begin_grab_op(Meta.GrabOp.KEYBOARD_MOVING, true, event.get_time());
        }));
        if (!window.allows_move())
            item.setSensitive(false);
        item = this.addAction(_("Resize"), Lang.bind(this, function(event) {
            window.begin_grab_op(Meta.GrabOp.KEYBOARD_RESIZING_UNKNOWN, true, event.get_time());
        }));
        if (!window.allows_resize())
            item.setSensitive(false);
        if (!window.titlebar_is_onscreen() && type != Meta.WindowType.DOCK && type != Meta.WindowType.DESKTOP) {
            this.addAction(_("Move Titlebar Onscreen"), Lang.bind(this, function(event) {
                window.shove_titlebar_onscreen();
            }));
        }
        item = this.addAction(_("Always on Top"), Lang.bind(this, function() {
            if (window.is_above())
                window.unmake_above();
            else
                window.make_above();
        }));
        if (window.is_above())
            item.setOrnament(PopupMenu.Ornament.CHECK);
        if (window.get_maximized() == Meta.MaximizeFlags.BOTH ||
            type == Meta.WindowType.DOCK ||
            type == Meta.WindowType.DESKTOP ||
            type == Meta.WindowType.SPLASHSCREEN)
            item.setSensitive(false);
        if (Main.sessionMode.hasWorkspaces &&
            (!Meta.prefs_get_workspaces_only_on_primary() ||
             window.is_on_primary_monitor())) {
            let isSticky = window.is_on_all_workspaces();
            item = this.addAction(_("Always on Visible Workspace"), Lang.bind(this, function() {
                if (isSticky)
                    window.unstick();
                else
                    window.stick();
            }));
            if (isSticky)
                item.setOrnament(PopupMenu.Ornament.CHECK);
            if (window.is_always_on_all_workspaces())
                item.setSensitive(false);
            let nWorkspaces = global.screen.n_workspaces;
            if (!isSticky) {
                let workspace = window.get_workspace();
                if (workspace != workspace.get_neighbor(Meta.MotionDirection.LEFT)) {
                     this.addAction(_("Move to Workspace Left"), Lang.bind(this, function(event) {
                        window.change_workspace(workspace.get_neighbor(Meta.MotionDirection.LEFT));
                    }));
                }
                if (workspace != workspace.get_neighbor(Meta.MotionDirection.RIGHT)) {
                     this.addAction(_("Move to Workspace Right"), Lang.bind(this, function(event) {
                        window.change_workspace(workspace.get_neighbor(Meta.MotionDirection.RIGHT));
                    }));
                }
                if (workspace != workspace.get_neighbor(Meta.MotionDirection.UP)) {
                    this.addAction(_("Move to Workspace Up"), Lang.bind(this, function(event) {
                        window.change_workspace(workspace.get_neighbor(Meta.MotionDirection.UP));
                    }));
                }
                if (workspace != workspace.get_neighbor(Meta.MotionDirection.DOWN)) {
                     this.addAction(_("Move to Workspace Down"), Lang.bind(this, function(event) {
                        window.change_workspace(workspace.get_neighbor(Meta.MotionDirection.DOWN));
                    }));
                }
            }
        }
        let screen = global.screen;
        let nMonitors = screen.get_n_monitors();
        if (nMonitors > 1) {
          this.addMenuItem(new PopupMenu.PopupSeparatorMenuItem());
          let monitorIndex = window.get_monitor();
          let upMonitorIndex = screen.get_monitor_neighbor_index(monitorIndex, Meta.ScreenDirection.UP);
          if (upMonitorIndex != -1) {
            this.addAction(_("Move to Monitor Up"), Lang.bind(this, function(event) {
              window.move_to_monitor(upMonitorIndex);
            }));
          }
          let downMonitorIndex = screen.get_monitor_neighbor_index(monitorIndex, Meta.ScreenDirection.DOWN);
          if (downMonitorIndex != -1) {
            this.addAction(_("Move to Monitor Down"), Lang.bind(this, function(event) {
              window.move_to_monitor(downMonitorIndex);
            }));
          }
          let leftMonitorIndex = screen.get_monitor_neighbor_index(monitorIndex, Meta.ScreenDirection.LEFT);
          if (leftMonitorIndex != -1) {
            this.addAction(_("Move to Monitor Left"), Lang.bind(this, function(event) {
              window.move_to_monitor(leftMonitorIndex);
            }));
          }
          let rightMonitorIndex = screen.get_monitor_neighbor_index(monitorIndex, Meta.ScreenDirection.RIGHT);
          if (rightMonitorIndex != -1) {
            this.addAction(_("Move to Monitor Right"), Lang.bind(this, function(event) {
              window.move_to_monitor(rightMonitorIndex);
            }));
          }
        }
        this.addMenuItem(new PopupMenu.PopupSeparatorMenuItem());
        item = this.addAction(_("Close"), Lang.bind(this, function(event) {
            window.delete(event.get_time());
        }));
        if (!window.can_close())
            item.setSensitive(false);
    }
const AppMenu = new Lang.Class({
    Name: 'AppMenu',
    Extends: RemoteMenu.RemoteMenu,
    _init: function(window, sourceActor) {
        let app = Shell.WindowTracker.get_default().get_window_app(window);
        this.parent(sourceActor, app.menu, app.action_group);
        this.actor.add_style_class_name('fallback-app-menu');
        let variant = window.get_gtk_theme_variant();
        if (variant)
            this.actor.add_style_class_name(variant);
        Main.layoutManager.uiGroup.add_actor(this.actor);
        this.actor.hide();
    }
const WindowMenuManager = new Lang.Class({
    Name: 'WindowMenuManager',
    _init: function() {
        this._manager = new PopupMenu.PopupMenuManager({ actor: Main.layoutManager.dummyCursor });
        this._sourceActor = new St.Widget({ reactive: true, visible: false });
        this._sourceActor.connect('button-press-event', Lang.bind(this,
            function() {
                this._manager.activeMenu.toggle();
            }));
        Main.uiGroup.add_actor(this._sourceActor);
    },
    showWindowMenuForWindow: function(window, type, rect) {
        let menuType = (type == Meta.WindowMenuType.WM) ? WindowMenu : AppMenu;
        let menu = new menuType(window, this._sourceActor);
        this._manager.addMenu(menu);
        menu.connect('activate', function() {
            window.check_alive(global.get_current_time());
        });
        let destroyId = window.connect('unmanaged',
            function() {
                menu.close();
            });
        this._sourceActor.set_size(Math.max(1, rect.width), Math.max(1, rect.height));
        this._sourceActor.set_position(rect.x, rect.y);
        this._sourceActor.show();
        menu.open(BoxPointer.PopupAnimation.NONE);
        menu.actor.navigate_focus(null, Gtk.DirectionType.TAB_FORWARD, false);
        menu.connect('open-state-changed', Lang.bind(this, function(menu_, isOpen) {
            if (isOpen)
                return;
            this._sourceActor.hide();
            menu.destroy();
            window.disconnect(destroyId);
        }));
    }
(uuay)telepathyClient.js
// -*- mode: js; js-indent-level: 4; indent-tabs-mode: nil -*-
const Clutter = imports.gi.Clutter;
const Gio = imports.gi.Gio;
const GLib = imports.gi.GLib;
const Gtk = imports.gi.Gtk;
const Lang = imports.lang;
const Mainloop = imports.mainloop;
const Shell = imports.gi.Shell;
const Signals = imports.signals;
const St = imports.gi.St;
const Tpl = imports.gi.TelepathyLogger;
const Tp = imports.gi.TelepathyGLib;
const History = imports.misc.history;
const Main = imports.ui.main;
const MessageList = imports.ui.messageList;
const MessageTray = imports.ui.messageTray;
const Params = imports.misc.params;
const PopupMenu = imports.ui.popupMenu;
const Util = imports.misc.util;
// See Notification.appendMessage
const SCROLLBACK_IMMEDIATE_TIME = 3 * 60; // 3 minutes
const SCROLLBACK_RECENT_TIME = 15 * 60; // 15 minutes
const SCROLLBACK_RECENT_LENGTH = 20;
const SCROLLBACK_IDLE_LENGTH = 5;
// See Source._displayPendingMessages
const SCROLLBACK_HISTORY_LINES = 10;
// See Notification._onEntryChanged
const COMPOSING_STOP_TIMEOUT = 5;
const CHAT_EXPAND_LINES = 12;
const NotificationDirection = {
    SENT: 'chat-sent',
    RECEIVED: 'chat-received'
const N_ = function(s) { return s; };
function makeMessageFromTpMessage(tpMessage, direction) {
    let [text, flags] = tpMessage.to_text();
    let timestamp = tpMessage.get_sent_timestamp();
    if (timestamp == 0)
        timestamp = tpMessage.get_received_timestamp();
    return {
        messageType: tpMessage.get_message_type(),
        text: text,
        sender: tpMessage.sender.alias,
        timestamp: timestamp,
        direction: direction
    };
function makeMessageFromTplEvent(event) {
    let sent = event.get_sender().get_entity_type() == Tpl.EntityType.SELF;
    let direction = sent ? NotificationDirection.SENT : NotificationDirection.RECEIVED;
    return {
        messageType: event.get_message_type(),
        text: event.get_message(),
        sender: event.get_sender().get_alias(),
        timestamp: event.get_timestamp(),
        direction: direction
    };
const TelepathyClient = new Lang.Class({
    Name: 'TelepathyClient',
    _init: function() {
        // channel path -> ChatSource
        this._chatSources = {};
        this._chatState = Tp.ChannelChatState.ACTIVE;
        // account path -> AccountNotification
        this._accountNotifications = {};
        // Define features we want
        this._accountManager = Tp.AccountManager.dup();
        let factory = this._accountManager.get_factory();
        factory.add_account_features([Tp.Account.get_feature_quark_connection()]);
        factory.add_connection_features([Tp.Connection.get_feature_quark_contact_list()]);
        factory.add_channel_features([Tp.Channel.get_feature_quark_contacts()]);
        factory.add_contact_features([Tp.ContactFeature.ALIAS,
                                      Tp.ContactFeature.AVATAR_DATA,
                                      Tp.ContactFeature.PRESENCE,
                                      Tp.ContactFeature.SUBSCRIPTION_STATES]);
        // Set up a SimpleObserver, which will call _observeChannels whenever a
        // channel matching its filters is detected.
        // The second argument, recover, means _observeChannels will be run
        // for any existing channel as well.
        this._tpClient = new Shell.TpClient({ name: 'GnomeShell',
                                              account_manager: this._accountManager,
                                              uniquify_name: true });
        this._tpClient.set_observe_channels_func(
            Lang.bind(this, this._observeChannels));
        this._tpClient.set_approve_channels_func(
            Lang.bind(this, this._approveChannels));
        this._tpClient.set_handle_channels_func(
            Lang.bind(this, this._handleChannels));
        // Allow other clients (such as Empathy) to pre-empt our channels if
        // needed
        this._tpClient.set_delegated_channels_callback(
            Lang.bind(this, this._delegatedChannelsCb));
    },
    enable: function() {
        try {
            this._tpClient.register();
        } catch (e) {
            throw new Error('Couldn\'t register Telepathy client. Error: \n' + e);
        }
        if (!this._accountManager.is_prepared(Tp.AccountManager.get_feature_quark_core()))
            this._accountManager.prepare_async(null, null);
    },
    disable: function() {
        this._tpClient.unregister();
    },
    _observeChannels: function(observer, account, conn, channels,
                               dispatchOp, requests, context) {
        let len = channels.length;
        for (let i = 0; i < len; i++) {
            let channel = channels[i];
            let [targetHandle, targetHandleType] = channel.get_handle();
            if (channel.get_invalidated())
              continue;
            /* Only observe contact text channels */
            if ((!(channel instanceof Tp.TextChannel)) ||
               targetHandleType != Tp.HandleType.CONTACT)
               continue;
            this._createChatSource(account, conn, channel, channel.get_target_contact());
        }
        context.accept();
    },
    _createChatSource: function(account, conn, channel, contact) {
        if (this._chatSources[channel.get_object_path()])
            return;
        let source = new ChatSource(account, conn, channel, contact, this._tpClient);
        this._chatSources[channel.get_object_path()] = source;
        source.connect('destroy', Lang.bind(this,
                       function() {
                           delete this._chatSources[channel.get_object_path()];
                       }));
    },
    _handleChannels: function(handler, account, conn, channels,
                              requests, user_action_time, context) {
        this._handlingChannels(account, conn, channels, true);
        context.accept();
    },
    _handlingChannels: function(account, conn, channels, notify) {
        let len = channels.length;
        for (let i = 0; i < len; i++) {
            let channel = channels[i];
            // We can only handle text channel, so close any other channel
            if (!(channel instanceof Tp.TextChannel)) {
                channel.close_async(null);
                continue;
            }
            if (channel.get_invalidated())
              continue;
            // 'notify' will be true when coming from an actual HandleChannels
            // call, and not when from a successful Claim call. The point is
            // we don't want to notify for a channel we just claimed which
            // has no new messages (for example, a new channel which only has
            // a delivery notification). We rely on _displayPendingMessages()
            // and _messageReceived() to notify for new messages.
            // But we should still notify from HandleChannels because the
            // Telepathy spec states that handlers must foreground channels
            // in HandleChannels calls which are already being handled.
            if (notify && this._tpClient.is_handling_channel(channel)) {
                // We are already handling the channel, display the source
                let source = this._chatSources[channel.get_object_path()];
                if (source)
                    source.notify();
            }
        }
    },
    _approveChannels: function(approver, account, conn, channels,
                               dispatchOp, context) {
        let channel = channels[0];
        let chanType = channel.get_channel_type();
        if (channel.get_invalidated()) {
            context.fail(new Tp.Error({ code: Tp.Error.INVALID_ARGUMENT,
                                        message: 'Channel is invalidated' }));
            return;
        }
        if (chanType == Tp.IFACE_CHANNEL_TYPE_TEXT)
            this._approveTextChannel(account, conn, channel, dispatchOp, context);
        else
            context.fail(new Tp.Error({ code: Tp.Error.INVALID_ARGUMENT,
                                        message: 'Unsupported channel type' }));
    },
    _approveTextChannel: function(account, conn, channel, dispatchOp, context) {
        let [targetHandle, targetHandleType] = channel.get_handle();
        if (targetHandleType != Tp.HandleType.CONTACT) {
            context.fail(new Tp.Error({ code: Tp.Error.INVALID_ARGUMENT,
                                        message: 'Unsupported handle type' }));
            return;
        }
        // Approve private text channels right away as we are going to handle it
        dispatchOp.claim_with_async(this._tpClient, Lang.bind(this, function(dispatchOp, result) {
            try {
                dispatchOp.claim_with_finish(result);
                this._handlingChannels(account, conn, [channel], false);
            } catch (err) {
                log('Failed to Claim channel: ' + err);
            }
        }));
        context.accept();
    },
    _delegatedChannelsCb: function(client, channels) {
        // Nothing to do as we don't make a distinction between observed and
        // handled channels.
    },
const ChatSource = new Lang.Class({
    Name: 'ChatSource',
    Extends: MessageTray.Source,
    _init: function(account, conn, channel, contact, client) {
        this._account = account;
        this._contact = contact;
        this._client = client;
        this.parent(contact.get_alias());
        this.isChat = true;
        this._pendingMessages = [];
        this._conn = conn;
        this._channel = channel;
        this._closedId = this._channel.connect('invalidated', Lang.bind(this, this._channelClosed));
        this._notifyTimeoutId = 0;
        this._presence = contact.get_presence_type();
        this._sentId = this._channel.connect('message-sent', Lang.bind(this, this._messageSent));
        this._receivedId = this._channel.connect('message-received', Lang.bind(this, this._messageReceived));
        this._pendingId = this._channel.connect('pending-message-removed', Lang.bind(this, this._pendingRemoved));
        this._notifyAliasId = this._contact.connect('notify::alias', Lang.bind(this, this._updateAlias));
        this._notifyAvatarId = this._contact.connect('notify::avatar-file', Lang.bind(this, this._updateAvatarIcon));
        this._presenceChangedId = this._contact.connect('presence-changed', Lang.bind(this, this._presenceChanged));
        // Add ourselves as a source.
        Main.messageTray.add(this);
        this._getLogMessages();
    },
    _ensureNotification: function() {
        if (this._notification)
            return;
        this._notification = new ChatNotification(this);
        this._notification.connect('activated', Lang.bind(this, this.open));
        this._notification.connect('updated', Lang.bind(this,
            function() {
                if (this._banner && this._banner.expanded)
                    this._ackMessages();
            }));
        this._notification.connect('destroy', Lang.bind(this,
            function() {
                this._notification = null;
            }));
        this.pushNotification(this._notification);
    },
    _createPolicy: function() {
        if (this._account.protocol_name == 'irc')
            return new MessageTray.NotificationApplicationPolicy('org.gnome.Polari');
        return new MessageTray.NotificationApplicationPolicy('empathy');
    },
    createBanner: function() {
        this._banner = new ChatNotificationBanner(this._notification);
        // We ack messages when the user expands the new notification
        let id = this._banner.connect('expanded', Lang.bind(this, this._ackMessages));
        this._banner.actor.connect('destroy', Lang.bind(this,
            function() {
                this._banner.disconnect(id);
                this._banner = null;
            }));
        return this._banner;
    },
    _updateAlias: function() {
        let oldAlias = this.title;
        let newAlias = this._contact.get_alias();
        if (oldAlias == newAlias)
            return;
        this.setTitle(newAlias);
        if (this._notification)
            this._notification.appendAliasChange(oldAlias, newAlias);
    },
    getIcon: function() {
        let file = this._contact.get_avatar_file();
        if (file) {
            return new Gio.FileIcon({ file: file });
        } else {
            return new Gio.ThemedIcon({ name: 'avatar-default' });
        }
    },
    getSecondaryIcon: function() {
        let iconName;
        let presenceType = this._contact.get_presence_type();
        switch (presenceType) {
            case Tp.ConnectionPresenceType.AVAILABLE:
                iconName = 'user-available';
                break;
            case Tp.ConnectionPresenceType.BUSY:
                iconName = 'user-busy';
                break;
            case Tp.ConnectionPresenceType.OFFLINE:
                iconName = 'user-offline';
                break;
            case Tp.ConnectionPresenceType.HIDDEN:
                iconName = 'user-invisible';
                break;
            case Tp.ConnectionPresenceType.AWAY:
                iconName = 'user-away';
                break;
            case Tp.ConnectionPresenceType.EXTENDED_AWAY:
                iconName = 'user-idle';
                break;
            default:
                iconName = 'user-offline';
       }
       return new Gio.ThemedIcon({ name: iconName });
    },
    _updateAvatarIcon: function() {
        this.iconUpdated();
        if (this._notifiction)
            this._notification.update(this._notification.title,
                                      this._notification.bannerBodyText,
                                      { gicon: this.getIcon() });
    },
    open: function() {
        Main.overview.hide();
        Main.panel.closeCalendar();
        if (this._client.is_handling_channel(this._channel)) {
            // We are handling the channel, try to pass it to Empathy or Polari
            // (depending on the channel type)
            // We don't check if either app is availble - mission control will
            // fallback to something else if activation fails
            let target;
            if (this._channel.connection.protocol_name == 'irc')
                target = 'org.freedesktop.Telepathy.Client.Polari';
            else
                target = 'org.freedesktop.Telepathy.Client.Empathy.Chat';
            this._client.delegate_channels_async([this._channel], global.get_current_time(), target, null);
        } else {
            // We are not the handler, just ask to present the channel
            let dbus = Tp.DBusDaemon.dup();
            let cd = Tp.ChannelDispatcher.new(dbus);
            cd.present_channel_async(this._channel, global.get_current_time(), null);
        }
    },
    _getLogMessages: function() {
        let logManager = Tpl.LogManager.dup_singleton();
        let entity = Tpl.Entity.new_from_tp_contact(this._contact, Tpl.EntityType.CONTACT);
        logManager.get_filtered_events_async(this._account, entity,
                                             Tpl.EventTypeMask.TEXT, SCROLLBACK_HISTORY_LINES,
                                             null, Lang.bind(this, this._displayPendingMessages));
    },
    _displayPendingMessages: function(logManager, result) {
        let [success, events] = logManager.get_filtered_events_finish(result);
        let logMessages = events.map(makeMessageFromTplEvent);
        this._ensureNotification();
        let pendingTpMessages = this._channel.get_pending_messages();
        let pendingMessages = [];
        for (let i = 0; i < pendingTpMessages.length; i++) {
            let message = pendingTpMessages[i];
            if (message.get_message_type() == Tp.ChannelTextMessageType.DELIVERY_REPORT)
                continue;
            pendingMessages.push(makeMessageFromTpMessage(message, NotificationDirection.RECEIVED));
            this._pendingMessages.push(message);
        }
        this.countUpdated();
        let showTimestamp = false;
        for (let i = 0; i < logMessages.length; i++) {
            let logMessage = logMessages[i];
            let isPending = false;
            // Skip any log messages that are also in pendingMessages
            for (let j = 0; j < pendingMessages.length; j++) {
                let pending = pendingMessages[j];
                if (logMessage.timestamp == pending.timestamp && logMessage.text == pending.text) {
                    isPending = true;
                    break;
                }
            }
            if (!isPending) {
                showTimestamp = true;
                this._notification.appendMessage(logMessage, true, ['chat-log-message']);
            }
        }
        if (showTimestamp)
            this._notification.appendTimestamp();
        for (let i = 0; i < pendingMessages.length; i++)
            this._notification.appendMessage(pendingMessages[i], true);
        if (pendingMessages.length > 0)
            this.notify();
    },
    destroy: function(reason) {
        if (this._client.is_handling_channel(this._channel)) {
            this._ackMessages();
            // The chat box has been destroyed so it can't
            // handle the channel any more.
            this._channel.close_async(function(channel, result) {
                channel.close_finish(result);
            });
        } else {
            // Don't indicate any unread messages when the notification
            // that represents them has been destroyed.
            this._pendingMessages = [];
            this.countUpdated();
        }
        // Keep source alive while the channel is open
        if (reason != MessageTray.NotificationDestroyedReason.SOURCE_CLOSED)
            return;
        if (this._destroyed)
            return;
        this._destroyed = true;
        this._channel.disconnect(this._closedId);
        this._channel.disconnect(this._receivedId);
        this._channel.disconnect(this._pendingId);
        this._channel.disconnect(this._sentId);
        this._contact.disconnect(this._notifyAliasId);
        this._contact.disconnect(this._notifyAvatarId);
        this._contact.disconnect(this._presenceChangedId);
        this.parent(reason);
    },
    _channelClosed: function() {
        this.destroy(MessageTray.NotificationDestroyedReason.SOURCE_CLOSED);
    },
    /* All messages are new messages for Telepathy sources */
    get count() {
        return this._pendingMessages.length;
    },
    get unseenCount() {
        return this.count;
    },
    get countVisible() {
        return this.count > 0;
    },
    _messageReceived: function(channel, message) {
        if (message.get_message_type() == Tp.ChannelTextMessageType.DELIVERY_REPORT)
            return;
        this._ensureNotification();
        this._pendingMessages.push(message);
        this.countUpdated();
        message = makeMessageFromTpMessage(message, NotificationDirection.RECEIVED);
        this._notification.appendMessage(message);
        // Wait a bit before notifying for the received message, a handler
        // could ack it in the meantime.
        if (this._notifyTimeoutId != 0)
            Mainloop.source_remove(this._notifyTimeoutId);
        this._notifyTimeoutId = Mainloop.timeout_add(500,
            Lang.bind(this, this._notifyTimeout));
        GLib.Source.set_name_by_id(this._notifyTimeoutId, '[gnome-shell] this._notifyTimeout');
    },
    _notifyTimeout: function() {
        if (this._pendingMessages.length != 0)
            this.notify();
        this._notifyTimeoutId = 0;
        return GLib.SOURCE_REMOVE;
    },
    // This is called for both messages we send from
    // our client and other clients as well.
    _messageSent: function(channel, message, flags, token) {
        this._ensureNotification();
        message = makeMessageFromTpMessage(message, NotificationDirection.SENT);
        this._notification.appendMessage(message);
    },
    notify: function() {
        this.parent(this._notification);
    },
    respond: function(text) {
        let type;
        if (text.slice(0, 4) == '/me ') {
            type = Tp.ChannelTextMessageType.ACTION;
            text = text.slice(4);
        } else {
            type = Tp.ChannelTextMessageType.NORMAL;
        }
        let msg = Tp.ClientMessage.new_text(type, text);
        this._channel.send_message_async(msg, 0, Lang.bind(this, function (src, result) {
            this._channel.send_message_finish(result); 
        }));
    },
    setChatState: function(state) {
        // We don't want to send COMPOSING every time a letter is typed into
        // the entry. We send the state only when it changes. Telepathy/Empathy
        // might change it behind our back if the user is using both
        // gnome-shell's entry and the Empathy conversation window. We could
        // keep track of it with the ChatStateChanged signal but it is good
        // enough right now.
        if (state != this._chatState) {
          this._chatState = state;
          this._channel.set_chat_state_async(state, null);
        }
    },
    _presenceChanged: function (contact, presence, status, message) {
        if (this._notification)
            this._notification.update(this._notification.title,
                                      this._notification.bannerBodyText,
                                      { secondaryGIcon: this.getSecondaryIcon() });
    },
    _pendingRemoved: function(channel, message) {
        let idx = this._pendingMessages.indexOf(message);
        if (idx >= 0) {
            this._pendingMessages.splice(idx, 1);
            this.countUpdated();
        }
        if (this._pendingMessages.length == 0 &&
            this._banner && !this._banner.expanded)
            this._banner.hide();
    },
    _ackMessages: function() {
        // Don't clear our messages here, tp-glib will send a
        // 'pending-message-removed' for each one.
        this._channel.ack_all_pending_messages_async(null);
    }
const ChatNotification = new Lang.Class({
    Name: 'ChatNotification',
    Extends: MessageTray.Notification,
    _init: function(source) {
        this.parent(source, source.title, null,
                    { secondaryGIcon: source.getSecondaryIcon() });
        this.setUrgency(MessageTray.Urgency.HIGH);
        this.setResident(true);
        this.messages = [];
        this._timestampTimeoutId = 0;
    },
    destroy: function(reason) {
        if (this._timestampTimeoutId)
            Mainloop.source_remove(this._timestampTimeoutId);
        this._timestampTimeoutId = 0;
        this.parent(reason);
    },
    /**
     * appendMessage:
     * @message: An object with the properties:
     *   text: the body of the message,
     *   messageType: a #Tp.ChannelTextMessageType,
     *   sender: the name of the sender,
     *   timestamp: the time the message was sent
     *   direction: a #NotificationDirection
     * 
     * @noTimestamp: Whether to add a timestamp. If %true, no timestamp
     *   will be added, regardless of the difference since the
     *   last timestamp
     */
    appendMessage: function(message, noTimestamp) {
        let messageBody = GLib.markup_escape_text(message.text, -1);
        let styles = [message.direction];
        if (message.messageType == Tp.ChannelTextMessageType.ACTION) {
            let senderAlias = GLib.markup_escape_text(message.sender, -1);
            messageBody = '<i>%s</i> %s'.format(senderAlias, messageBody);
            styles.push('chat-action');
        }
        if (message.direction == NotificationDirection.RECEIVED)
            this.update(this.source.title, messageBody, { bannerMarkup: true });
        let group = (message.direction == NotificationDirection.RECEIVED ?
                     'received' : 'sent');
        this._append({ body: messageBody,
                       group: group,
                       styles: styles,
                       timestamp: message.timestamp,
                       noTimestamp: noTimestamp });
    },
    _filterMessages: function() {
        if (this.messages.length < 1)
            return;
        let lastMessageTime = this.messages[0].timestamp;
        let currentTime = (Date.now() / 1000);
        // Keep the scrollback from growing too long. If the most
        // recent message (before the one we just added) is within
        // SCROLLBACK_RECENT_TIME, we will keep
        // SCROLLBACK_RECENT_LENGTH previous messages. Otherwise
        // we'll keep SCROLLBACK_IDLE_LENGTH messages.
        let maxLength = (lastMessageTime < currentTime - SCROLLBACK_RECENT_TIME) ?
            SCROLLBACK_IDLE_LENGTH : SCROLLBACK_RECENT_LENGTH;
        let filteredHistory = this.messages.filter(function(item) { return item.realMessage });
        if (filteredHistory.length > maxLength) {
            let lastMessageToKeep = filteredHistory[maxLength];
            let expired = this.messages.splice(this.messages.indexOf(lastMessageToKeep));
            for (let i = 0; i < expired.length; i++)
                this.emit('message-removed', expired[i]);
        }
    },
    /**
     * _append:
     * @props: An object with the properties:
     *  body: The text of the message.
     *  group: The group of the message, one of:
     *         'received', 'sent', 'meta'.
     *  styles: Style class names for the message to have.
     *  timestamp: The timestamp of the message.
     *  noTimestamp: suppress timestamp signal?
     */
    _append: function(props) {
        let currentTime = (Date.now() / 1000);
        props = Params.parse(props, { body: null,
                                      group: null,
                                      styles: [],
                                      timestamp: currentTime,
                                      noTimestamp: false });
        // Reset the old message timeout
        if (this._timestampTimeoutId)
            Mainloop.source_remove(this._timestampTimeoutId);
        this._timestampTimeoutId = 0;
        let message = { realMessage: props.group != 'meta',
                        showTimestamp: false };
        Lang.copyProperties(props, message);
        delete message.noTimestamp;
        this.messages.unshift(message);
        this.emit('message-added', message);
        if (!props.noTimestamp) {
            let timestamp = props.timestamp;
            if (timestamp < currentTime - SCROLLBACK_IMMEDIATE_TIME) {
                this.appendTimestamp();
            } else {
                // Schedule a new timestamp in SCROLLBACK_IMMEDIATE_TIME
                // from the timestamp of the message.
                this._timestampTimeoutId = Mainloop.timeout_add_seconds(
                    SCROLLBACK_IMMEDIATE_TIME - (currentTime - timestamp),
                    Lang.bind(this, this.appendTimestamp));
                GLib.Source.set_name_by_id(this._timestampTimeoutId, '[gnome-shell] this.appendTimestamp');
            }
        }
        this._filterMessages();
    },
    appendTimestamp: function() {
        this._timestampTimeoutId = 0;
        this.messages[0].showTimestamp = true;
        this.emit('timestamp-changed', this.messages[0]);
        this._filterMessages();
        return GLib.SOURCE_REMOVE;
    },
    appendAliasChange: function(oldAlias, newAlias) {
        oldAlias = GLib.markup_escape_text(oldAlias, -1);
        newAlias = GLib.markup_escape_text(newAlias, -1);
        /* Translators: this is the other person changing their old IM name to their new
           IM name. */
        let message = '<i>' + _("%s is now known as %s").format(oldAlias, newAlias) + '</i>';
        this._append({ body: message,
                       group: 'meta',
                       styles: ['chat-meta-message'] });
        this._filterMessages();
    }
const ChatLineBox = new Lang.Class({
    Name: 'ChatLineBox',
    Extends: St.BoxLayout,
    vfunc_get_preferred_height: function(forWidth) {
        let [, natHeight] = this.parent(forWidth);
        return [natHeight, natHeight];
    }
const ChatNotificationBanner = new Lang.Class({
    Name: 'ChatNotificationBanner',
    Extends: MessageTray.NotificationBanner,
    _init: function(notification) {
        this.parent(notification);
        this._responseEntry = new St.Entry({ style_class: 'chat-response',
                                             x_expand: true,
                                             can_focus: true });
        this._responseEntry.clutter_text.connect('activate', Lang.bind(this, this._onEntryActivated));
        this._responseEntry.clutter_text.connect('text-changed', Lang.bind(this, this._onEntryChanged));
        this.setActionArea(this._responseEntry);
        this._responseEntry.clutter_text.connect('key-focus-in', Lang.bind(this, function() {
            this.focused = true;
        }));
        this._responseEntry.clutter_text.connect('key-focus-out', Lang.bind(this, function() {
            this.focused = false;
            this.emit('unfocused');
        }));
        this._scrollArea = new St.ScrollView({ style_class: 'chat-scrollview vfade',
                                               vscrollbar_policy: Gtk.PolicyType.AUTOMATIC,
                                               hscrollbar_policy: Gtk.PolicyType.NEVER,
                                               visible: this.expanded });
        this._contentArea = new St.BoxLayout({ style_class: 'chat-body',
                                               vertical: true });
        this._scrollArea.add_actor(this._contentArea);
        this.setExpandedBody(this._scrollArea);
        this.setExpandedLines(CHAT_EXPAND_LINES);
        this._lastGroup = null;
        // Keep track of the bottom position for the current adjustment and
        // force a scroll to the bottom if things change while we were at the
        // bottom
        this._oldMaxScrollValue = this._scrollArea.vscroll.adjustment.value;
        this._scrollArea.vscroll.adjustment.connect('changed', Lang.bind(this, function(adjustment) {
            if (adjustment.value == this._oldMaxScrollValue)
                this.scrollTo(St.Side.BOTTOM);
            this._oldMaxScrollValue = Math.max(adjustment.lower, adjustment.upper - adjustment.page_size);
        }));
        this._inputHistory = new History.HistoryManager({ entry: this._responseEntry.clutter_text });
        this._composingTimeoutId = 0;
        this._messageActors = new Map();
        this._messageAddedId = this.notification.connect('message-added',
            Lang.bind(this, function(n, message) {
                this._addMessage(message);
            }));
        this._messageRemovedId = this.notification.connect('message-removed',
            Lang.bind(this, function(n, message) {
                let actor = this._messageActors.get(message);
                if (this._messageActors.delete(message))
                    actor.destroy();
            }));
        this._timestampChangedId = this.notification.connect('timestamp-changed',
            Lang.bind(this, function(n, message) {
                this._updateTimestamp(message);
            }));
        for (let i = this.notification.messages.length - 1; i >= 0; i--)
            this._addMessage(this.notification.messages[i]);
    },
    _onDestroy: function() {
        this.parent();
        this.notification.disconnect(this._messageAddedId);
        this.notification.disconnect(this._messageRemovedId);
        this.notification.disconnect(this._timestampChangedId);
    },
    scrollTo: function(side) {
        let adjustment = this._scrollArea.vscroll.adjustment;
        if (side == St.Side.TOP)
            adjustment.value = adjustment.lower;
        else if (side == St.Side.BOTTOM)
            adjustment.value = adjustment.upper;
    },
    hide: function() {
        this.emit('done-displaying');
    },
    _addMessage: function(message) {
        let highlighter = new MessageList.URLHighlighter(message.body, true, true);
        let body = highlighter.actor;
        let styles = message.styles;
        for (let i = 0; i < styles.length; i++)
            body.add_style_class_name(styles[i]);
        let group = message.group;
        if (group != this._lastGroup) {
            this._lastGroup = group;
            body.add_style_class_name('chat-new-group');
        }
        let lineBox = new ChatLineBox();
        lineBox.add(body);
        this._contentArea.add_actor(lineBox);
        this._messageActors.set(message, lineBox);
        this._updateTimestamp(message);
    },
    _updateTimestamp: function(message) {
        let actor = this._messageActors.get(message);
        if (!actor)
            return;
        while (actor.get_n_children() > 1)
            actor.get_child_at_index(1).destroy();
        if (message.showTimestamp) {
            let lastMessageTime = message.timestamp;
            let lastMessageDate = new Date(lastMessageTime * 1000);
            let timeLabel = Util.createTimeLabel(lastMessageDate);
            timeLabel.style_class = 'chat-meta-message';
            timeLabel.x_expand = timeLabel.y_expand = true;
            timeLabel.x_align = timeLabel.y_align = Clutter.ActorAlign.END;
            actor.add_actor(timeLabel);
        }
    },
    _onEntryActivated: function() {
        let text = this._responseEntry.get_text();
        if (text == '')
            return;
        this._inputHistory.addItem(text);
        // Telepathy sends out the Sent signal for us.
        // see Source._messageSent
        this._responseEntry.set_text('');
        this.notification.source.respond(text);
    },
    _composingStopTimeout: function() {
        this._composingTimeoutId = 0;
        this.notification.source.setChatState(Tp.ChannelChatState.PAUSED);
        return GLib.SOURCE_REMOVE;
    },
    _onEntryChanged: function() {
        let text = this._responseEntry.get_text();
        // If we're typing, we want to send COMPOSING.
        // If we empty the entry, we want to send ACTIVE.
        // If we've stopped typing for COMPOSING_STOP_TIMEOUT
        //    seconds, we want to send PAUSED.
        // Remove composing timeout.
        if (this._composingTimeoutId > 0) {
            Mainloop.source_remove(this._composingTimeoutId);
            this._composingTimeoutId = 0;
        }
        if (text != '') {
            this.notification.source.setChatState(Tp.ChannelChatState.COMPOSING);
            this._composingTimeoutId = Mainloop.timeout_add_seconds(
                COMPOSING_STOP_TIMEOUT,
                Lang.bind(this, this._composingStopTimeout));
            GLib.Source.set_name_by_id(this._composingTimeoutId, '[gnome-shell] this._composingStopTimeout');
        } else {
            this.notification.source.setChatState(Tp.ChannelChatState.ACTIVE);
        }
    }
const Component = TelepathyClient;
(uuay)audioDeviceSelection.js
const Clutter = imports.gi.Clutter;
const Gio = imports.gi.Gio;
const GLib = imports.gi.GLib;
const Lang = imports.lang;
const Meta = imports.gi.Meta;
const Shell = imports.gi.Shell;
const St = imports.gi.St;
const Main = imports.ui.main;
const ModalDialog = imports.ui.modalDialog;
const AudioDevice = {
    HEADPHONES: 1 << 0,
    HEADSET:    1 << 1,
    MICROPHONE: 1 << 2
const AudioDeviceSelectionIface = '<node> \
<interface name="org.gnome.Shell.AudioDeviceSelection"> \
<method name="Open"> \
    <arg name="devices" direction="in" type="as" /> \
</method> \
<method name="Close"> \
</method> \
<signal name="DeviceSelected"> \
    <arg name="device" type="s" /> \
</signal> \
</interface> \
</node>';
const AudioDeviceSelectionDialog = new Lang.Class({
    Name: 'AudioDeviceSelectionDialog',
    Extends: ModalDialog.ModalDialog,
    _init: function(devices) {
        this.parent({ styleClass: 'audio-device-selection-dialog' });
        this._deviceItems = {};
        this._buildLayout();
        if (devices & AudioDevice.HEADPHONES)
            this._addDevice(AudioDevice.HEADPHONES);
        if (devices & AudioDevice.HEADSET)
            this._addDevice(AudioDevice.HEADSET);
        if (devices & AudioDevice.MICROPHONE)
            this._addDevice(AudioDevice.MICROPHONE);
        if (this._selectionBox.get_n_children() < 2)
            throw new Error('Too few devices for a selection');
    },
    destroy: function() {
        this.parent();
    },
    _buildLayout: function(devices) {
        let title = new St.Label({ style_class: 'audio-selection-title',
                                   text: _("Select Audio Device"),
                                   x_align: Clutter.ActorAlign.CENTER });
        this.contentLayout.style_class = 'audio-selection-content';
        this.contentLayout.add(title);
        this._selectionBox = new St.BoxLayout({ style_class: 'audio-selection-box' });
        this.contentLayout.add(this._selectionBox, { expand: true });
        this.addButton({ action: Lang.bind(this, this._openSettings),
                         label: _("Sound Settings") });
        this.addButton({ action: Lang.bind(this, this.close),
                         label: _("Cancel"),
                         key: Clutter.Escape });
    },
    _getDeviceLabel: function(device) {
        switch(device) {
            case AudioDevice.HEADPHONES:
                return _("Headphones");
            case AudioDevice.HEADSET:
                return _("Headset");
            case AudioDevice.MICROPHONE:
                return _("Microphone");
            default:
                return null;
        }
    },
    _getDeviceIcon: function(device) {
        switch(device) {
            case AudioDevice.HEADPHONES:
                return 'audio-headphones-symbolic';
            case AudioDevice.HEADSET:
                return 'audio-headset-symbolic';
            case AudioDevice.MICROPHONE:
                return 'audio-input-microphone-symbolic';
            default:
                return null;
        }
    },
    _addDevice: function(device) {
        let box = new St.BoxLayout({ style_class: 'audio-selection-device-box',
                                     vertical: true });
        box.connect('notify::height',
            function() {
                Meta.later_add(Meta.LaterType.BEFORE_REDRAW,
                    function() {
                        box.width = box.height;
                    });
            });
        let icon = new St.Icon({ style_class: 'audio-selection-device-icon',
                                 icon_name: this._getDeviceIcon(device) });
        box.add(icon);
        let label = new St.Label({ style_class: 'audio-selection-device-label',
                                   text: this._getDeviceLabel(device),
                                   x_align: Clutter.ActorAlign.CENTER });
        box.add(label);
        let button = new St.Button({ style_class: 'audio-selection-device',
                                     can_focus: true,
                                     child: box });
        this._selectionBox.add(button);
        button.connect('clicked', Lang.bind(this,
            function() {
                this.emit('device-selected', device);
                this.close();
                Main.overview.hide();
            }));
    },
    _openSettings: function() {
        let desktopFile = 'gnome-sound-panel.desktop'
        let app = Shell.AppSystem.get_default().lookup_app(desktopFile);
        if (!app) {
            log('Settings panel for desktop file ' + desktopFile + ' could not be loaded!');
            return;
        }
        this.close();
        Main.overview.hide();
        app.activate();
    }
const AudioDeviceSelectionDBus = new Lang.Class({
    Name: 'AudioDeviceSelectionDBus',
    _init: function() {
        this._audioSelectionDialog = null;
        this._dbusImpl = Gio.DBusExportedObject.wrapJSObject(AudioDeviceSelectionIface, this);
        this._dbusImpl.export(Gio.DBus.session, '/org/gnome/Shell/AudioDeviceSelection');
        Gio.DBus.session.own_name('org.gnome.Shell.AudioDeviceSelection', Gio.BusNameOwnerFlags.REPLACE, null, null);
    },
    _onDialogClosed: function() {
        this._audioSelectionDialog = null;
    },
    _onDeviceSelected: function(dialog, device) {
        let connection = this._dbusImpl.get_connection();
        let info = this._dbusImpl.get_info();
        let deviceName = Object.keys(AudioDevice).filter(
            function(dev) {
                return AudioDevice[dev] == device;
            })[0].toLowerCase();
        connection.emit_signal(this._audioSelectionDialog._sender,
                               this._dbusImpl.get_object_path(),
                               info ? info.name : null,
                               'DeviceSelected',
                               GLib.Variant.new('(s)', [deviceName]));
    },
    OpenAsync: function(params, invocation) {
        if (this._audioSelectionDialog) {
            invocation.return_value(null);
            return;
        }
        let [deviceNames] = params;
        let devices = 0;
        deviceNames.forEach(function(n) {
            devices |= AudioDevice[n.toUpperCase()];
        });
        let dialog;
        try {
            dialog = new AudioDeviceSelectionDialog(devices);
        } catch(e) {
            invocation.return_value(null);
            return;
        }
        dialog._sender = invocation.get_sender();
        dialog.connect('closed', Lang.bind(this, this._onDialogClosed));
        dialog.connect('device-selected',
                       Lang.bind(this, this._onDeviceSelected));
        dialog.open();
        this._audioSelectionDialog = dialog;
        invocation.return_value(null);
    },
    CloseAsync: function(params, invocation) {
        if (this._audioSelectionDialog &&
            this._audioSelectionDialog._sender == invocation.get_sender())
            this._audioSelectionDialog.close();
        invocation.return_value(null);
    }
(uuay)keyboard.js
// -*- mode: js; js-indent-level: 4; indent-tabs-mode: nil -*-
const Clutter = imports.gi.Clutter;
const Gio = imports.gi.Gio;
const GLib = imports.gi.GLib;
const Lang = imports.lang;
const Meta = imports.gi.Meta;
const Shell = imports.gi.Shell;
const Signals = imports.signals;
const St = imports.gi.St;
const Gettext = imports.gettext;
const IBus = imports.misc.ibusManager.IBus;
const IBusManager = imports.misc.ibusManager;
const KeyboardManager = imports.misc.keyboardManager;
const Main = imports.ui.main;
const PopupMenu = imports.ui.popupMenu;
const PanelMenu = imports.ui.panelMenu;
const SwitcherPopup = imports.ui.switcherPopup;
const Util = imports.misc.util;
const INPUT_SOURCE_TYPE_XKB = 'xkb';
const INPUT_SOURCE_TYPE_IBUS = 'ibus';
const LayoutMenuItem = new Lang.Class({
    Name: 'LayoutMenuItem',
    Extends: PopupMenu.PopupBaseMenuItem,
    _init: function(displayName, shortName) {
        this.parent();
        this.label = new St.Label({ text: displayName });
        this.indicator = new St.Label({ text: shortName });
        this.actor.add(this.label, { expand: true });
        this.actor.add(this.indicator);
        this.actor.label_actor = this.label;
    }
const InputSource = new Lang.Class({
    Name: 'InputSource',
    _init: function(type, id, displayName, shortName, index) {
        this.type = type;
        this.id = id;
        this.displayName = displayName;
        this._shortName = shortName;
        this.index = index;
        this.properties = null;
        this.xkbId = this._getXkbId();
    },
    get shortName() {
        return this._shortName;
    },
    set shortName(v) {
        this._shortName = v;
        this.emit('changed');
    },
    activate: function(interactive) {
        this.emit('activate', !!interactive);
    },
    _getXkbId: function() {
        let engineDesc = IBusManager.getIBusManager().getEngineDesc(this.id);
        if (!engineDesc)
            return this.id;
        if (engineDesc.variant && engineDesc.variant.length > 0)
            return engineDesc.layout + '+' + engineDesc.variant;
        else
            return engineDesc.layout;
    }
Signals.addSignalMethods(InputSource.prototype);
const InputSourcePopup = new Lang.Class({
    Name: 'InputSourcePopup',
    Extends: SwitcherPopup.SwitcherPopup,
    _init: function(items, action, actionBackward) {
        this.parent(items);
        this._action = action;
        this._actionBackward = actionBackward;
        this._switcherList = new InputSourceSwitcher(this._items);
    },
    _keyPressHandler: function(keysym, action) {
        if (action == this._action)
            this._select(this._next());
        else if (action == this._actionBackward)
            this._select(this._previous());
        else if (keysym == Clutter.Left)
            this._select(this._previous());
        else if (keysym == Clutter.Right)
            this._select(this._next());
        else
            return Clutter.EVENT_PROPAGATE;
        return Clutter.EVENT_STOP;
    },
    _finish : function() {
        this.parent();
        this._items[this._selectedIndex].activate(true);
    },
const InputSourceSwitcher = new Lang.Class({
    Name: 'InputSourceSwitcher',
    Extends: SwitcherPopup.SwitcherList,
    _init: function(items) {
        this.parent(true);
        for (let i = 0; i < items.length; i++)
            this._addIcon(items[i]);
    },
    _addIcon: function(item) {
        let box = new St.BoxLayout({ vertical: true });
        let bin = new St.Bin({ style_class: 'input-source-switcher-symbol' });
        let symbol = new St.Label({ text: item.shortName });
        bin.set_child(symbol);
        box.add(bin, { x_fill: false, y_fill: false } );
        let text = new St.Label({ text: item.displayName });
        box.add(text, { x_fill: false });
        this.addItem(box, text);
    }
const InputSourceSettings = new Lang.Class({
    Name: 'InputSourceSettings',
    Abstract: true,
    _emitInputSourcesChanged: function() {
        this.emit('input-sources-changed');
    },
    _emitKeyboardOptionsChanged: function() {
        this.emit('keyboard-options-changed');
    },
    _emitPerWindowChanged: function() {
        this.emit('per-window-changed');
    },
    get inputSources() {
        return [];
    },
    get mruSources() {
        return [];
    },
    set mruSources(sourcesList) {
        // do nothing
    },
    get keyboardOptions() {
        return [];
    },
    get perWindow() {
        return false;
    }
Signals.addSignalMethods(InputSourceSettings.prototype);
const InputSourceSystemSettings = new Lang.Class({
    Name: 'InputSourceSystemSettings',
    Extends: InputSourceSettings,
    _BUS_NAME: 'org.freedesktop.locale1',
    _BUS_PATH: '/org/freedesktop/locale1',
    _BUS_IFACE: 'org.freedesktop.locale1',
    _BUS_PROPS_IFACE: 'org.freedesktop.DBus.Properties',
    _init: function() {
        this._layouts = '';
        this._variants = '';
        this._options = '';
        this._reload();
        Gio.DBus.system.signal_subscribe(this._BUS_NAME,
                                         this._BUS_PROPS_IFACE,
                                         'PropertiesChanged',
                                         this._BUS_PATH,
                                         null,
                                         Gio.DBusSignalFlags.NONE,
                                         Lang.bind(this, this._reload));
    },
    _reload: function() {
        Gio.DBus.system.call(this._BUS_NAME,
                             this._BUS_PATH,
                             this._BUS_PROPS_IFACE,
                             'GetAll',
                             new GLib.Variant('(s)', [this._BUS_IFACE]),
                             null, Gio.DBusCallFlags.NONE, -1, null,
                             Lang.bind(this, function(conn, result) {
                                 let props;
                                 try {
                                     props = conn.call_finish(result).deep_unpack()[0];
                                 } catch(e) {
                                     log('Could not get properties from ' + this._BUS_NAME);
                                     return;
                                 }
                                 let layouts = props['X11Layout'].unpack();
                                 let variants = props['X11Variant'].unpack();
                                 let options = props['X11Options'].unpack();
                                 if (layouts != this._layouts ||
                                     variants != this._variants) {
                                     this._layouts = layouts;
                                     this._variants = variants;
                                     this._emitInputSourcesChanged();
                                 }
                                 if (options != this._options) {
                                     this._options = options;
                                     this._emitKeyboardOptionsChanged();
                                 }
                             }));
    },
    get inputSources() {
        let sourcesList = [];
        let layouts = this._layouts.split(',');
        let variants = this._variants.split(',');
        for (let i = 0; i < layouts.length && !!layouts[i]; i++) {
            let id = layouts[i];
            if (!!variants[i])
                id += '+' + variants[i];
            sourcesList.push({ type: INPUT_SOURCE_TYPE_XKB, id: id });
        }
        return sourcesList;
    },
    get keyboardOptions() {
        return this._options.split(',');
    }
const InputSourceSessionSettings = new Lang.Class({
    Name: 'InputSourceSessionSettings',
    Extends: InputSourceSettings,
    _DESKTOP_INPUT_SOURCES_SCHEMA: 'org.gnome.desktop.input-sources',
    _KEY_INPUT_SOURCES: 'sources',
    _KEY_MRU_SOURCES: 'mru-sources',
    _KEY_KEYBOARD_OPTIONS: 'xkb-options',
    _KEY_PER_WINDOW: 'per-window',
    _init: function() {
        this._settings = new Gio.Settings({ schema_id: this._DESKTOP_INPUT_SOURCES_SCHEMA });
        this._settings.connect('changed::' + this._KEY_INPUT_SOURCES, Lang.bind(this, this._emitInputSourcesChanged));
        this._settings.connect('changed::' + this._KEY_KEYBOARD_OPTIONS, Lang.bind(this, this._emitKeyboardOptionsChanged));
        this._settings.connect('changed::' + this._KEY_PER_WINDOW, Lang.bind(this, this._emitPerWindowChanged));
    },
    _getSourcesList: function(key) {
        let sourcesList = [];
        let sources = this._settings.get_value(key);
        let nSources = sources.n_children();
        for (let i = 0; i < nSources; i++) {
            let [type, id] = sources.get_child_value(i).deep_unpack();
            sourcesList.push({ type: type, id: id });
        }
        return sourcesList;
    },
    get inputSources() {
        return this._getSourcesList(this._KEY_INPUT_SOURCES);
    },
    get mruSources() {
        return this._getSourcesList(this._KEY_MRU_SOURCES);
    },
    set mruSources(sourcesList) {
        let sources = GLib.Variant.new('a(ss)', sourcesList);
        this._settings.set_value(this._KEY_MRU_SOURCES, sources);
    },
    get keyboardOptions() {
        return this._settings.get_strv(this._KEY_KEYBOARD_OPTIONS);
    },
    get perWindow() {
        return this._settings.get_boolean(this._KEY_PER_WINDOW);
    }
const InputSourceManager = new Lang.Class({
    Name: 'InputSourceManager',
    _init: function() {
        // All valid input sources currently in the gsettings
        // KEY_INPUT_SOURCES list indexed by their index there
        this._inputSources = {};
        // All valid input sources currently in the gsettings
        // KEY_INPUT_SOURCES list of type INPUT_SOURCE_TYPE_IBUS
        // indexed by the IBus ID
        this._ibusSources = {};
        this._currentSource = null;
        // All valid input sources currently in the gsettings
        // KEY_INPUT_SOURCES list ordered by most recently used
        this._mruSources = [];
        this._mruSourcesBackup = null;
        this._keybindingAction =
            Main.wm.addKeybinding('switch-input-source',
                                  new Gio.Settings({ schema_id: "org.gnome.desktop.wm.keybindings" }),
                                  Meta.KeyBindingFlags.NONE,
                                  Shell.ActionMode.ALL,
                                  Lang.bind(this, this._switchInputSource));
        this._keybindingActionBackward =
            Main.wm.addKeybinding('switch-input-source-backward',
                                  new Gio.Settings({ schema_id: "org.gnome.desktop.wm.keybindings" }),
                                  Meta.KeyBindingFlags.IS_REVERSED,
                                  Shell.ActionMode.ALL,
                                  Lang.bind(this, this._switchInputSource));
        if (Main.sessionMode.isGreeter)
            this._settings = new InputSourceSystemSettings();
        else
            this._settings = new InputSourceSessionSettings();
        this._settings.connect('input-sources-changed', Lang.bind(this, this._inputSourcesChanged));
        this._settings.connect('keyboard-options-changed', Lang.bind(this, this._keyboardOptionsChanged));
        this._xkbInfo = KeyboardManager.getXkbInfo();
        this._keyboardManager = KeyboardManager.getKeyboardManager();
        this._ibusReady = false;
        this._ibusManager = IBusManager.getIBusManager();
        this._ibusManager.connect('ready', Lang.bind(this, this._ibusReadyCallback));
        this._ibusManager.connect('properties-registered', Lang.bind(this, this._ibusPropertiesRegistered));
        this._ibusManager.connect('property-updated', Lang.bind(this, this._ibusPropertyUpdated));
        this._ibusManager.connect('set-content-type', Lang.bind(this, this._ibusSetContentType));
        global.display.connect('modifiers-accelerator-activated', Lang.bind(this, this._modifiersSwitcher));
        this._sourcesPerWindow = false;
        this._focusWindowNotifyId = 0;
        this._overviewShowingId = 0;
        this._overviewHiddenId = 0;
        this._settings.connect('per-window-changed', Lang.bind(this, this._sourcesPerWindowChanged));
        this._sourcesPerWindowChanged();
        this._disableIBus = false;
    },
    reload: function() {
        this._keyboardManager.setKeyboardOptions(this._settings.keyboardOptions);
        this._inputSourcesChanged();
    },
    _ibusReadyCallback: function(im, ready) {
        if (this._ibusReady == ready)
            return;
        this._ibusReady = ready;
        this._mruSources = [];
        this._inputSourcesChanged();
    },
    _modifiersSwitcher: function() {
        let sourceIndexes = Object.keys(this._inputSources);
        if (sourceIndexes.length == 0) {
            KeyboardManager.releaseKeyboard();
            return true;
        }
        let is = this._currentSource;
        if (!is)
            is = this._inputSources[sourceIndexes[0]];
        let nextIndex = is.index + 1;
        if (nextIndex > sourceIndexes[sourceIndexes.length - 1])
            nextIndex = 0;
        while (!(is = this._inputSources[nextIndex]))
            nextIndex += 1;
        is.activate(true);
        return true;
    },
    _switchInputSource: function(display, screen, window, binding) {
        if (this._mruSources.length < 2)
            return;
        // HACK: Fall back on simple input source switching since we
        // can't show a popup switcher while a GrabHelper grab is in
        // effect without considerable work to consolidate the usage
        // of pushModal/popModal and grabHelper. See
        // https://bugzilla.gnome.org/show_bug.cgi?id=695143 .
        if (Main.actionMode == Shell.ActionMode.POPUP) {
            this._modifiersSwitcher();
            return;
        }
        let popup = new InputSourcePopup(this._mruSources, this._keybindingAction, this._keybindingActionBackward);
        if (!popup.show(binding.is_reversed(), binding.get_name(), binding.get_mask()))
            popup.destroy();
    },
    _keyboardOptionsChanged: function() {
        this._keyboardManager.setKeyboardOptions(this._settings.keyboardOptions);
        this._keyboardManager.reapply();
    },
    _updateMruSettings: function() {
        // If IBus is not ready we don't have a full picture of all
        // the available sources, so don't update the setting
        if (!this._ibusReady)
            return;
        // If IBus is temporarily disabled, don't update the setting
        if (this._disableIBus)
            return;
        let sourcesList = [];
        for (let i = 0; i < this._mruSources.length; ++i) {
            let source = this._mruSources[i];
            sourcesList.push([source.type, source.id]);
        }
        this._settings.mruSources = sourcesList;
    },
    _currentInputSourceChanged: function(newSource) {
        let oldSource;
        [oldSource, this._currentSource] = [this._currentSource, newSource];
        this.emit('current-source-changed', oldSource);
        for (let i = 1; i < this._mruSources.length; ++i)
            if (this._mruSources[i] == newSource) {
                let currentSource = this._mruSources.splice(i, 1);
                this._mruSources = currentSource.concat(this._mruSources);
                break;
            }
        this._changePerWindowSource();
    },
    _activateInputSource: function(is, interactive) {
        KeyboardManager.holdKeyboard();
        this._keyboardManager.apply(is.xkbId);
        // All the "xkb:..." IBus engines simply "echo" back symbols,
        // despite their naming implying differently, so we always set
        // one in order for XIM applications to work given that we set
        // XMODIFIERS=@im=ibus in the first place so that they can
        // work without restarting when/if the user adds an IBus input
        // source.
        let engine;
        if (is.type == INPUT_SOURCE_TYPE_IBUS)
            engine = is.id;
        else
            engine = 'xkb:us::eng';
        this._ibusManager.setEngine(engine, KeyboardManager.releaseKeyboard);
        this._currentInputSourceChanged(is);
        if (interactive)
            this._updateMruSettings();
    },
    _updateMruSources: function() {
        let sourcesList = [];
        for (let i in this._inputSources)
            sourcesList.push(this._inputSources[i]);
        this._keyboardManager.setUserLayouts(sourcesList.map(function(x) { return x.xkbId; }));
        if (!this._disableIBus && this._mruSourcesBackup) {
            this._mruSources = this._mruSourcesBackup;
            this._mruSourcesBackup = null;
        }
        // Initialize from settings when we have no MRU sources list
        if (this._mruSources.length == 0) {
            let mruSettings = this._settings.mruSources;
            for (let i = 0; i < mruSettings.length; i++) {
                let mruSettingSource = mruSettings[i];
                let mruSource = null;
                for (let j = 0; j < sourcesList.length; j++) {
                    let source = sourcesList[j];
                    if (source.type == mruSettingSource.type &&
                        source.id == mruSettingSource.id) {
                        mruSource = source;
                        break;
                    }
                }
                if (mruSource)
                    this._mruSources.push(mruSource);
            }
        }
        let mruSources = [];
        for (let i = 0; i < this._mruSources.length; i++) {
            for (let j = 0; j < sourcesList.length; j++)
                if (this._mruSources[i].type == sourcesList[j].type &&
                    this._mruSources[i].id == sourcesList[j].id) {
                    mruSources = mruSources.concat(sourcesList.splice(j, 1));
                    break;
                }
        }
        this._mruSources = mruSources.concat(sourcesList);
    },
    _inputSourcesChanged: function() {
        let sources = this._settings.inputSources;
        let nSources = sources.length;
        this._inputSources = {};
        this._ibusSources = {};
        let infosList = [];
        for (let i = 0; i < nSources; i++) {
            let displayName;
            let shortName;
            let type = sources[i].type;
            let id = sources[i].id;
            let exists = false;
            if (type == INPUT_SOURCE_TYPE_XKB) {
                [exists, displayName, shortName, , ] =
                    this._xkbInfo.get_layout_info(id);
            } else if (type == INPUT_SOURCE_TYPE_IBUS) {
                if (this._disableIBus)
                    continue;
                let engineDesc = this._ibusManager.getEngineDesc(id);
                if (engineDesc) {
                    let language = IBus.get_language_name(engineDesc.get_language());
                    let longName = engineDesc.get_longname();
                    let textdomain = engineDesc.get_textdomain();
                    if (textdomain != '')
                        longName = Gettext.dgettext(textdomain, longName);
                    exists = true;
                    displayName = '%s (%s)'.format(language, longName);
                    shortName = this._makeEngineShortName(engineDesc);
                }
            }
            if (exists)
                infosList.push({ type: type, id: id, displayName: displayName, shortName: shortName });
        }
        if (infosList.length == 0) {
            let type = INPUT_SOURCE_TYPE_XKB;
            let id = KeyboardManager.DEFAULT_LAYOUT;
            let [ , displayName, shortName, , ] = this._xkbInfo.get_layout_info(id);
            infosList.push({ type: type, id: id, displayName: displayName, shortName: shortName });
        }
        let inputSourcesByShortName = {};
        for (let i = 0; i < infosList.length; i++) {
            let is = new InputSource(infosList[i].type,
                                     infosList[i].id,
                                     infosList[i].displayName,
                                     infosList[i].shortName,
                                     i);
            is.connect('activate', Lang.bind(this, this._activateInputSource));
            if (!(is.shortName in inputSourcesByShortName))
                inputSourcesByShortName[is.shortName] = [];
            inputSourcesByShortName[is.shortName].push(is);
            this._inputSources[is.index] = is;
            if (is.type == INPUT_SOURCE_TYPE_IBUS)
                this._ibusSources[is.id] = is;
        }
        for (let i in this._inputSources) {
            let is = this._inputSources[i];
            if (inputSourcesByShortName[is.shortName].length > 1) {
                let sub = inputSourcesByShortName[is.shortName].indexOf(is) + 1;
                is.shortName += String.fromCharCode(0x2080 + sub);
            }
        }
        this.emit('sources-changed');
        this._updateMruSources();
        if (this._mruSources.length > 0)
            this._mruSources[0].activate(false);
        // All ibus engines are preloaded here to reduce the launching time
        // when users switch the input sources.
        this._ibusManager.preloadEngines(Object.keys(this._ibusSources));
    },
    _makeEngineShortName: function(engineDesc) {
        let symbol = engineDesc.get_symbol();
        if (symbol && symbol[0])
            return symbol;
        let langCode = engineDesc.get_language().split('_', 1)[0];
        if (langCode.length == 2 || langCode.length == 3)
            return langCode.toLowerCase();
        return String.fromCharCode(0x2328); // keyboard glyph
    },
    _ibusPropertiesRegistered: function(im, engineName, props) {
        let source = this._ibusSources[engineName];
        if (!source)
            return;
        source.properties = props;
        if (source == this._currentSource)
            this.emit('current-source-changed', null);
    },
    _ibusPropertyUpdated: function(im, engineName, prop) {
        let source = this._ibusSources[engineName];
        if (!source)
            return;
        if (this._updateSubProperty(source.properties, prop) &&
            source == this._currentSource)
            this.emit('current-source-changed', null);
    },
    _updateSubProperty: function(props, prop) {
        if (!props)
            return false;
        let p;
        for (let i = 0; (p = props.get(i)) != null; ++i) {
            if (p.get_key() == prop.get_key() && p.get_prop_type() == prop.get_prop_type()) {
                p.update(prop);
                return true;
            } else if (p.get_prop_type() == IBus.PropType.MENU) {
                if (this._updateSubProperty(p.get_sub_props(), prop))
                    return true;
            }
        }
        return false;
    },
    _ibusSetContentType: function(im, purpose, hints) {
        if (purpose == IBus.InputPurpose.PASSWORD) {
            if (Object.keys(this._inputSources).length == Object.keys(this._ibusSources).length)
                return;
            if (this._disableIBus)
                return;
            this._disableIBus = true;
            this._mruSourcesBackup = this._mruSources.slice();
        } else {
            if (!this._disableIBus)
                return;
            this._disableIBus = false;
        }
        this.reload();
    },
    _getNewInputSource: function(current) {
        let sourceIndexes = Object.keys(this._inputSources);
        if (sourceIndexes.length == 0)
            return null;
        if (current) {
            for (let i in this._inputSources) {
                let is = this._inputSources[i];
                if (is.type == current.type &&
                    is.id == current.id)
                    return is;
            }
        }
        return this._inputSources[sourceIndexes[0]];
    },
    _getCurrentWindow: function() {
        if (Main.overview.visible)
            return Main.overview;
        else
            return global.display.focus_window;
    },
    _setPerWindowInputSource: function() {
        let window = this._getCurrentWindow();
        if (!window)
            return;
        if (window._inputSources != this._inputSources) {
            window._inputSources = this._inputSources;
            window._currentSource = this._getNewInputSource(window._currentSource);
        }
        if (window._currentSource)
            window._currentSource.activate(false);
    },
    _sourcesPerWindowChanged: function() {
        this._sourcesPerWindow = this._settings.perWindow;
        if (this._sourcesPerWindow && this._focusWindowNotifyId == 0) {
            this._focusWindowNotifyId = global.display.connect('notify::focus-window',
                                                               Lang.bind(this, this._setPerWindowInputSource));
            this._overviewShowingId = Main.overview.connect('showing',
                                                            Lang.bind(this, this._setPerWindowInputSource));
            this._overviewHiddenId = Main.overview.connect('hidden',
                                                           Lang.bind(this, this._setPerWindowInputSource));
        } else if (!this._sourcesPerWindow && this._focusWindowNotifyId != 0) {
            global.display.disconnect(this._focusWindowNotifyId);
            this._focusWindowNotifyId = 0;
            Main.overview.disconnect(this._overviewShowingId);
            this._overviewShowingId = 0;
            Main.overview.disconnect(this._overviewHiddenId);
            this._overviewHiddenId = 0;
            let windows = global.get_window_actors().map(function(w) {
                return w.meta_window;
            });
            for (let i = 0; i < windows.length; ++i) {
                delete windows[i]._inputSources;
                delete windows[i]._currentSource;
            }
            delete Main.overview._inputSources;
            delete Main.overview._currentSource;
        }
    },
    _changePerWindowSource: function() {
        if (!this._sourcesPerWindow)
            return;
        let window = this._getCurrentWindow();
        if (!window)
            return;
        window._inputSources = this._inputSources;
        window._currentSource = this._currentSource;
    },
    get currentSource() {
        return this._currentSource;
    },
    get inputSources() {
        return this._inputSources;
    },
Signals.addSignalMethods(InputSourceManager.prototype);
let _inputSourceManager = null;
function getInputSourceManager() {
    if (_inputSourceManager == null)
        _inputSourceManager = new InputSourceManager();
    return _inputSourceManager;
const InputSourceIndicator = new Lang.Class({
    Name: 'InputSourceIndicator',
    Extends: PanelMenu.Button,
    _init: function() {
        this.parent(0.0, _("Keyboard"));
        this._menuItems = {};
        this._indicatorLabels = {};
        this._container = new Shell.GenericContainer();
        this._container.connect('get-preferred-width', Lang.bind(this, this._containerGetPreferredWidth));
        this._container.connect('get-preferred-height', Lang.bind(this, this._containerGetPreferredHeight));
        this._container.connect('allocate', Lang.bind(this, this._containerAllocate));
        this._hbox = new St.BoxLayout({ style_class: 'panel-status-menu-box' });
        this._hbox.add_child(this._container);
        this._hbox.add_child(PopupMenu.arrowIcon(St.Side.BOTTOM));
        this.actor.add_child(this._hbox);
        this._propSeparator = new PopupMenu.PopupSeparatorMenuItem();
        this.menu.addMenuItem(this._propSeparator);
        this._propSection = new PopupMenu.PopupMenuSection();
        this.menu.addMenuItem(this._propSection);
        this._propSection.actor.hide();
        this.menu.addMenuItem(new PopupMenu.PopupSeparatorMenuItem());
        this._showLayoutItem = this.menu.addAction(_("Show Keyboard Layout"), Lang.bind(this, this._showLayout));
        Main.sessionMode.connect('updated', Lang.bind(this, this._sessionUpdated));
        this._sessionUpdated();
        this._inputSourceManager = getInputSourceManager();
        this._inputSourceManager.connect('sources-changed', Lang.bind(this, this._sourcesChanged));
        this._inputSourceManager.connect('current-source-changed', Lang.bind(this, this._currentSourceChanged));
        this._inputSourceManager.reload();
    },
    _sessionUpdated: function() {
        // re-using "allowSettings" for the keyboard layout is a bit shady,
        // but at least for now it is used as "allow popping up windows
        // from shell menus"; we can always add a separate sessionMode
        // option if need arises.
        this._showLayoutItem.actor.visible = Main.sessionMode.allowSettings;
    },
    _sourcesChanged: function() {
        for (let i in this._menuItems)
            this._menuItems[i].destroy();
        for (let i in this._indicatorLabels)
            this._indicatorLabels[i].destroy();
        let menuIndex = 0;
        for (let i in this._inputSourceManager.inputSources) {
            let is = this._inputSourceManager.inputSources[i];
            let menuItem = new LayoutMenuItem(is.displayName, is.shortName);
            menuItem.connect('activate', function() {
                is.activate(true);
            });
            let indicatorLabel = new St.Label({ text: is.shortName,
                                                visible: false });
            this._menuItems[i] = menuItem;
            this._indicatorLabels[i] = indicatorLabel;
            is.connect('changed', function() {
                menuItem.indicator.set_text(is.shortName);
                indicatorLabel.set_text(is.shorName);
            });
            this.menu.addMenuItem(menuItem, menuIndex++);
            this._container.add_actor(indicatorLabel);
        }
    },
    _currentSourceChanged: function(manager, oldSource) {
        let nVisibleSources = Object.keys(this._inputSourceManager.inputSources).length;
        let newSource = this._inputSourceManager.currentSource;
        if (oldSource) {
            this._menuItems[oldSource.index].setOrnament(PopupMenu.Ornament.NONE);
            this._indicatorLabels[oldSource.index].hide();
        }
        if (!newSource || (nVisibleSources < 2 && !newSource.properties)) {
            // This source index might be invalid if we weren't able
            // to build a menu item for it, so we hide ourselves since
            // we can't fix it here. *shrug*
            // We also hide if we have only one visible source unless
            // it's an IBus source with properties.
            this.menu.close();
            this.actor.hide();
            return;
        }
        this.actor.show();
        this._buildPropSection(newSource.properties);
        this._menuItems[newSource.index].setOrnament(PopupMenu.Ornament.DOT);
        this._indicatorLabels[newSource.index].show();
    },
    _buildPropSection: function(properties) {
        this._propSeparator.actor.hide();
        this._propSection.actor.hide();
        this._propSection.removeAll();
        this._buildPropSubMenu(this._propSection, properties);
        if (!this._propSection.isEmpty()) {
            this._propSection.actor.show();
            this._propSeparator.actor.show();
        }
    },
    _buildPropSubMenu: function(menu, props) {
        if (!props)
            return;
        let ibusManager = IBusManager.getIBusManager();
        let radioGroup = [];
        let p;
        for (let i = 0; (p = props.get(i)) != null; ++i) {
            let prop = p;
            if (!prop.get_visible())
                continue;
            if (prop.get_key() == 'InputMode') {
                let text;
                if (prop.get_symbol)
                    text = prop.get_symbol().get_text();
                else
                    text = prop.get_label().get_text();
                let currentSource = this._inputSourceManager.currentSource;
                if (currentSource) {
                    let indicatorLabel = this._indicatorLabels[currentSource.index];
                    if (text && text.length > 0 && text.length < 3)
                        indicatorLabel.set_text(text);
                }
            }
            let item;
            switch (prop.get_prop_type()) {
            case IBus.PropType.MENU:
                item = new PopupMenu.PopupSubMenuMenuItem(prop.get_label().get_text());
                this._buildPropSubMenu(item.menu, prop.get_sub_props());
                break;
            case IBus.PropType.RADIO:
                item = new PopupMenu.PopupMenuItem(prop.get_label().get_text());
                item.prop = prop;
                radioGroup.push(item);
                item.radioGroup = radioGroup;
                item.setOrnament(prop.get_state() == IBus.PropState.CHECKED ?
                                 PopupMenu.Ornament.DOT : PopupMenu.Ornament.NONE);
                item.connect('activate', Lang.bind(this, function() {
                    if (item.prop.get_state() == IBus.PropState.CHECKED)
                        return;
                    let group = item.radioGroup;
                    for (let i = 0; i < group.length; ++i) {
                        if (group[i] == item) {
                            item.setOrnament(PopupMenu.Ornament.DOT);
                            item.prop.set_state(IBus.PropState.CHECKED);
                            ibusManager.activateProperty(item.prop.get_key(),
                                                         IBus.PropState.CHECKED);
                        } else {
                            group[i].setOrnament(PopupMenu.Ornament.NONE);
                            group[i].prop.set_state(IBus.PropState.UNCHECKED);
                            ibusManager.activateProperty(group[i].prop.get_key(),
                                                         IBus.PropState.UNCHECKED);
                        }
                    }
                }));
                break;
            case IBus.PropType.TOGGLE:
                item = new PopupMenu.PopupSwitchMenuItem(prop.get_label().get_text(), prop.get_state() == IBus.PropState.CHECKED);
                item.prop = prop;
                item.connect('toggled', Lang.bind(this, function() {
                    if (item.state) {
                        item.prop.set_state(IBus.PropState.CHECKED);
                        ibusManager.activateProperty(item.prop.get_key(),
                                                     IBus.PropState.CHECKED);
                    } else {
                        item.prop.set_state(IBus.PropState.UNCHECKED);
                        ibusManager.activateProperty(item.prop.get_key(),
                                                     IBus.PropState.UNCHECKED);
                    }
                }));
                break;
            case IBus.PropType.NORMAL:
                item = new PopupMenu.PopupMenuItem(prop.get_label().get_text());
                item.prop = prop;
                item.connect('activate', Lang.bind(this, function() {
                    ibusManager.activateProperty(item.prop.get_key(),
                                                 item.prop.get_state());
                }));
                break;
            case IBus.PropType.SEPARATOR:
                item = new PopupMenu.PopupSeparatorMenuItem();
                break;
            default:
                log ('IBus property %s has invalid type %d'.format(prop.get_key(), type));
                continue;
            }
            item.setSensitive(prop.get_sensitive());
            menu.addMenuItem(item);
        }
    },
    _showLayout: function() {
        Main.overview.hide();
        let source = this._inputSourceManager.currentSource;
        let xkbLayout = '';
        let xkbVariant = '';
        if (source.type == INPUT_SOURCE_TYPE_XKB) {
            [, , , xkbLayout, xkbVariant] = KeyboardManager.getXkbInfo().get_layout_info(source.id);
        } else if (source.type == INPUT_SOURCE_TYPE_IBUS) {
            let engineDesc = IBusManager.getIBusManager().getEngineDesc(source.id);
            if (engineDesc) {
                xkbLayout = engineDesc.get_layout();
                xkbVariant = engineDesc.get_layout_variant();
            }
        }
        if (!xkbLayout || xkbLayout.length == 0)
            return;
        let description = xkbLayout;
        if (xkbVariant.length > 0)
            description = description + '\t' + xkbVariant;
        Util.spawn(['gkbd-keyboard-display', '-l', description]);
    },
    _containerGetPreferredWidth: function(container, for_height, alloc) {
        // Here, and in _containerGetPreferredHeight, we need to query
        // for the height of all children, but we ignore the results
        // for those we don't actually display.
        let max_min_width = 0, max_natural_width = 0;
        for (let i in this._inputSourceManager.inputSources) {
            let label = this._indicatorLabels[i];
            let [min_width, natural_width] = label.get_preferred_width(for_height);
            max_min_width = Math.max(max_min_width, min_width);
            max_natural_width = Math.max(max_natural_width, natural_width);
        }
        alloc.min_size = max_min_width;
        alloc.natural_size = max_natural_width;
    },
    _containerGetPreferredHeight: function(container, for_width, alloc) {
        let max_min_height = 0, max_natural_height = 0;
        for (let i in this._inputSourceManager.inputSources) {
            let label = this._indicatorLabels[i];
            let [min_height, natural_height] = label.get_preferred_height(for_width);
            max_min_height = Math.max(max_min_height, min_height);
            max_natural_height = Math.max(max_natural_height, natural_height);
        }
        alloc.min_size = max_min_height;
        alloc.natural_size = max_natural_height;
    },
    _containerAllocate: function(container, box, flags) {
        // translate box to (0, 0)
        box.x2 -= box.x1;
        box.x1 = 0;
        box.y2 -= box.y1;
        box.y1 = 0;
        for (let i in this._inputSourceManager.inputSources) {
            let label = this._indicatorLabels[i];
            label.allocate_align_fill(box, 0.5, 0.5, false, false, flags);
        }
    }
(uuay)pointerWatcher.js
// -*- mode: js; js-indent-level: 4; indent-tabs-mode: nil -*-
const GLib = imports.gi.GLib;
const Lang = imports.lang;
const Mainloop = imports.mainloop;
const Meta = imports.gi.Meta;
const GnomeDesktop = imports.gi.GnomeDesktop;
const Shell = imports.gi.Shell;
// We stop polling if the user is idle for more than this amount of time
const IDLE_TIME = 1000;
// This file implements a reasonably efficient system for tracking the position
// of the mouse pointer. We simply query the pointer from the X server in a loop,
// but we turn off the polling when the user is idle.
let _pointerWatcher = null;
function getPointerWatcher() {
    if (_pointerWatcher == null)
        _pointerWatcher = new PointerWatcher();
    return _pointerWatcher;
const PointerWatch = new Lang.Class({
    Name: 'PointerWatch',
    _init: function(watcher, interval, callback) {
        this.watcher = watcher;
        this.interval = interval;
        this.callback = callback;
    },
    // remove:
    // remove this watch. This function may safely be called
    // while the callback is executing.
    remove: function() {
        this.watcher._removeWatch(this);
    }
const PointerWatcher = new Lang.Class({
    Name: 'PointerWatcher',
    _init: function() {
        this._idleMonitor = Meta.IdleMonitor.get_core();
        this._idleMonitor.add_idle_watch(IDLE_TIME, Lang.bind(this, this._onIdleMonitorBecameIdle));
        this._idle = this._idleMonitor.get_idletime() > IDLE_TIME;
        this._watches = [];
        this.pointerX = null;
        this.pointerY = null;
    },
    // addWatch:
    // @interval: hint as to the time resolution needed. When the user is
    //   not idle, the position of the pointer will be queried at least
    //   once every this many milliseconds.
    // @callback: function to call when the pointer position changes - takes
    //   two arguments, X and Y.
    //
    // Set up a watch on the position of the mouse pointer. Returns a
    // PointerWatch object which has a remove() method to remove the watch.
    addWatch: function(interval, callback) {
        // Avoid unreliably calling the watch for the current position
        this._updatePointer();
        let watch = new PointerWatch(this, interval, callback);
        this._watches.push(watch);
        this._updateTimeout();
        return watch;
    },
    _removeWatch: function(watch) {
        for (let i = 0; i < this._watches.length; i++) {
            if (this._watches[i] == watch) {
                this._watches.splice(i, 1);
                this._updateTimeout();
                return;
            }
        }
    },
    _onIdleMonitorBecameActive: function(monitor) {
        this._idle = false;
        this._updatePointer();
        this._updateTimeout();
    },
    _onIdleMonitorBecameIdle: function(monitor) {
        this._idle = true;
        this._idleMonitor.add_user_active_watch(Lang.bind(this, this._onIdleMonitorBecameActive));
        this._updateTimeout();
    },
    _updateTimeout: function() {
        if (this._timeoutId) {
            Mainloop.source_remove(this._timeoutId);
            this._timeoutId = 0;
        }
        if (this._idle || this._watches.length == 0)
            return;
        let minInterval = this._watches[0].interval;
        for (let i = 1; i < this._watches.length; i++)
            minInterval = Math.min(this._watches[i].interval, minInterval);
        this._timeoutId = Mainloop.timeout_add(minInterval,
                                               Lang.bind(this, this._onTimeout));
        GLib.Source.set_name_by_id(this._timeoutId, '[gnome-shell] this._onTimeout');
    },
    _onTimeout: function() {
        this._updatePointer();
        return GLib.SOURCE_CONTINUE;
    },
    _updatePointer: function() {
        let [x, y, mods] = global.get_pointer();
        if (this.pointerX == x && this.pointerY == y)
            return;
        this.pointerX = x;
        this.pointerY = y;
        for (let i = 0; i < this._watches.length;) {
            let watch = this._watches[i];
            watch.callback(x, y);
            if (watch == this._watches[i]) // guard against self-removal
                i++;
        }
    }
(uuay)focusCaretTracker.js
/** -*- mode: js2; js2-basic-offset: 4; indent-tabs-mode: nil -*- */
 * Copyright 2012 Inclusive Design Research Centre, OCAD University.
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library. If not, see <http://www.gnu.org/licenses/>.
 * Author:
 *   Joseph Scheuhammer <clown@alum.mit.edu>
 * Contributor:
 *   Magdalen Berns <m.berns@sms.ed.ac.uk>
const Atspi = imports.gi.Atspi;
const Lang = imports.lang;
const Signals = imports.signals;
const CARETMOVED        = 'object:text-caret-moved';
const STATECHANGED      = 'object:state-changed';
const FocusCaretTracker = new Lang.Class({
    Name: 'FocusCaretTracker',
    _init: function() {
        this._atspiListener = Atspi.EventListener.new(Lang.bind(this, this._onChanged));
        this._atspiInited = false;
        this._focusListenerRegistered = false;
        this._caretListenerRegistered = false;
    },
    _onChanged: function(event) {
        if (event.type.indexOf(STATECHANGED) == 0)
            this.emit('focus-changed', event);
        else if (event.type == CARETMOVED)
            this.emit('caret-moved', event);
    },
    _initAtspi: function() {
        if (!this._atspiInited) {
            Atspi.init();
            Atspi.set_timeout(250, 250);
            this._atspiInited = true;
        }
    },
    registerFocusListener: function() {
        if (this._focusListenerRegistered)
            return;
        this._initAtspi();
        this._atspiListener.register(STATECHANGED + ':focused');
        this._atspiListener.register(STATECHANGED + ':selected');
        this._focusListenerRegistered = true;
    },
    registerCaretListener: function() {
        if (this._caretListenerRegistered)
            return;
        this._initAtspi();
        this._atspiListener.register(CARETMOVED);
        this._caretListenerRegistered = true;
    },
    deregisterFocusListener: function() {
        if (!this._focusListenerRegistered)
            return;
        this._atspiListener.deregister(STATECHANGED + ':focused');
        this._atspiListener.deregister(STATECHANGED + ':selected');
        this._focusListenerRegistered = false;
    },
    deregisterCaretListener: function() {
        if (!this._caretListenerRegistered)
            return;
        this._atspiListener.deregister(CARETMOVED);
        this._caretListenerRegistered = false;
    }
Signals.addSignalMethods(FocusCaretTracker.prototype);
(uuay)mpris.js
const Gio = imports.gi.Gio;
const Lang = imports.lang;
const Signals = imports.signals;
const Shell = imports.gi.Shell;
const St = imports.gi.St;
const Calendar = imports.ui.calendar;
const Main = imports.ui.main;
const MessageList = imports.ui.messageList;
const DBusIface = '<node> \
<interface name="org.freedesktop.DBus"> \
  <method name="ListNames"> \
    <arg type="as" direction="out" name="names" /> \
  </method> \
  <signal name="NameOwnerChanged"> \
    <arg type="s" direction="out" name="name" /> \
    <arg type="s" direction="out" name="oldOwner" /> \
    <arg type="s" direction="out" name="newOwner" /> \
  </signal> \
</interface> \
</node>';
const DBusProxy = Gio.DBusProxy.makeProxyWrapper(DBusIface);
const MprisIface = '<node> \
<interface name="org.mpris.MediaPlayer2"> \
  <method name="Raise" /> \
  <property name="CanRaise" type="b" access="read" /> \
  <property name="DesktopEntry" type="s" access="read" /> \
</interface> \
</node>';
const MprisProxy = Gio.DBusProxy.makeProxyWrapper(MprisIface);
const MprisPlayerIface = '<node> \
<interface name="org.mpris.MediaPlayer2.Player"> \
  <method name="PlayPause" /> \
  <method name="Next" /> \
  <method name="Previous" /> \
  <property name="CanPlay" type="b" access="read" /> \
  <property name="Metadata" type="a{sv}" access="read" /> \
  <property name="PlaybackStatus" type="s" access="read" /> \
</interface> \
</node>';
const MprisPlayerProxy = Gio.DBusProxy.makeProxyWrapper(MprisPlayerIface);
const MPRIS_PLAYER_PREFIX = 'org.mpris.MediaPlayer2.';
const MediaMessage = new Lang.Class({
    Name: 'MediaMessage',
    Extends: MessageList.Message,
    _init: function(player) {
        this._player = player;
        this.parent('', '');
        this._icon = new St.Icon({ style_class: 'media-message-cover-icon' });
        this.setIcon(this._icon);
        this.addMediaControl('media-skip-backward-symbolic',
            Lang.bind(this, function() {
                this._player.previous();
            }));
        this._playPauseButton = this.addMediaControl(null,
            Lang.bind(this, function() {
                this._player.playPause();
            }));
        this.addMediaControl('media-skip-forward-symbolic',
            Lang.bind(this, function() {
                this._player.next();
            }));
        this._player.connect('changed', Lang.bind(this, this._update));
        this._player.connect('closed', Lang.bind(this, this.close));
        this._update();
    },
    _onClicked: function() {
        this._player.raise();
        Main.panel.closeCalendar();
    },
    _update: function() {
        this.setTitle(this._player.trackArtists.join(', '));
        this.setBody(this._player.trackTitle);
        if (this._player.trackCoverUrl) {
            let file = Gio.File.new_for_uri(this._player.trackCoverUrl);
            this._icon.gicon = new Gio.FileIcon({ file: file });
            this._icon.remove_style_class_name('fallback');
        } else {
            this._icon.icon_name = 'audio-x-generic-symbolic';
            this._icon.add_style_class_name('fallback');
        }
        let isPlaying = this._player.status == 'Playing';
        let iconName = isPlaying ? 'media-playback-pause-symbolic'
                                 : 'media-playback-start-symbolic';
        this._playPauseButton.child.icon_name = iconName;
    }
const MprisPlayer = new Lang.Class({
    Name: 'MprisPlayer',
    _init: function(busName) {
        this._mprisProxy = new MprisProxy(Gio.DBus.session, busName,
                                          '/org/mpris/MediaPlayer2',
                                          Lang.bind(this, this._onMprisProxyReady));
        this._playerProxy = new MprisPlayerProxy(Gio.DBus.session, busName,
                                                 '/org/mpris/MediaPlayer2',
                                                 Lang.bind(this, this._onPlayerProxyReady));
        this._visible = false;
        this._trackArtists = [];
        this._trackTitle = '';
        this._trackCoverUrl = '';
    },
    get status() {
        return this._playerProxy.PlaybackStatus;
    },
    get trackArtists() {
        return this._trackArtists;
    },
    get trackTitle() {
        return this._trackTitle;
    },
    get trackCoverUrl() {
        return this._trackCoverUrl;
    },
    playPause: function() {
        this._playerProxy.PlayPauseRemote();
    },
    next: function() {
        this._playerProxy.NextRemote();
    },
    previous: function() {
        this._playerProxy.PreviousRemote();
    },
    raise: function() {
        // The remote Raise() method may run into focus stealing prevention,
        // so prefer activating the app via .desktop file if possible
        let app = null;
        if (this._mprisProxy.DesktopEntry) {
            let desktopId = this._mprisProxy.DesktopEntry + '.desktop';
            app = Shell.AppSystem.get_default().lookup_app(desktopId);
        }
        if (app)
            app.activate();
        else if (this._mprisProxy.CanRaise)
            this._mprisProxy.RaiseRemote();
    },
    _close: function() {
        this._mprisProxy.disconnect(this._ownerNotifyId);
        this._mprisProxy = null;
        this._playerProxy.disconnect(this._propsChangedId);
        this._playerProxy = null;
        this.emit('closed');
    },
    _onMprisProxyReady: function() {
        this._ownerNotifyId = this._mprisProxy.connect('notify::g-name-owner',
            Lang.bind(this, function() {
                if (!this._mprisProxy.g_name_owner)
                    this._close();
            }));
    },
    _onPlayerProxyReady: function() {
        this._propsChangedId = this._playerProxy.connect('g-properties-changed',
                                                         Lang.bind(this, this._updateState));
        this._updateState();
    },
    _updateState: function() {
        let metadata = {};
        for (let prop in this._playerProxy.Metadata)
            metadata[prop] = this._playerProxy.Metadata[prop].deep_unpack();
        this._trackArtists = metadata['xesam:artist'] || [_("Unknown artist")];
        this._trackTitle = metadata['xesam:title'] || _("Unknown title");
        this._trackCoverUrl = metadata['mpris:artUrl'] || '';
        this.emit('changed');
        let visible = this._playerProxy.CanPlay;
        if (this._visible != visible) {
            this._visible = visible;
            if (visible)
                this.emit('show');
            else
                this._close();
        }
    }
Signals.addSignalMethods(MprisPlayer.prototype);
const MediaSection = new Lang.Class({
    Name: 'MediaSection',
    Extends: MessageList.MessageListSection,
    _init: function() {
        this.parent(_("Media"));
        this._players = new Map();
        this._proxy = new DBusProxy(Gio.DBus.session,
                                    'org.freedesktop.DBus',
                                    '/org/freedesktop/DBus',
                                    Lang.bind(this, this._onProxyReady));
    },
    _shouldShow: function() {
        return !this.empty && Calendar.isToday(this._date);
    },
    _addPlayer: function(busName) {
        if (this._players.get(busName))
            return;
        let player = new MprisPlayer(busName);
        player.connect('closed', Lang.bind(this,
            function() {
                this._players.delete(busName);
            }));
        player.connect('show', Lang.bind(this,
            function() {
                let message = new MediaMessage(player);
                this.addMessage(message, true);
            }));
        this._players.set(busName, player);
    },
    _onProxyReady: function() {
        this._proxy.ListNamesRemote(Lang.bind(this,
            function([names]) {
                names.forEach(Lang.bind(this,
                    function(name) {
                        if (!name.startsWith(MPRIS_PLAYER_PREFIX))
                            return;
                        this._addPlayer(name);
                    }));
            }));
        this._proxy.connectSignal('NameOwnerChanged',
                                  Lang.bind(this, this._onNameOwnerChanged));
    },
    _onNameOwnerChanged: function(proxy, sender, [name, oldOwner, newOwner]) {
        if (!name.startsWith(MPRIS_PLAYER_PREFIX))
            return;
        if (newOwner && !oldOwner)
            this._addPlayer(name);
    }
(uuay)dateMenu.js
// -*- mode: js; js-indent-level: 4; indent-tabs-mode: nil -*-
const GLib = imports.gi.GLib;
const Gio = imports.gi.Gio;
const GnomeDesktop = imports.gi.GnomeDesktop;
const GObject = imports.gi.GObject;
const Gtk = imports.gi.Gtk;
const GWeather = imports.gi.GWeather;
const Lang = imports.lang;
const Mainloop = imports.mainloop;
const Cairo = imports.cairo;
const Clutter = imports.gi.Clutter;
const Shell = imports.gi.Shell;
const St = imports.gi.St;
const Atk = imports.gi.Atk;
const Params = imports.misc.params;
const Util = imports.misc.util;
const Main = imports.ui.main;
const PanelMenu = imports.ui.panelMenu;
const PopupMenu = imports.ui.popupMenu;
const Calendar = imports.ui.calendar;
function _isToday(date) {
    let now = new Date();
    return now.getYear() == date.getYear() &&
           now.getMonth() == date.getMonth() &&
           now.getDate() == date.getDate();
const TodayButton = new Lang.Class({
    Name: 'TodayButton',
    _init: function(calendar) {
        // Having the ability to go to the current date if the user is already
        // on the current date can be confusing. So don't make the button reactive
        // until the selected date changes.
        this.actor = new St.Button({ style_class: 'datemenu-today-button',
                                     x_align: St.Align.START,
                                     can_focus: true,
                                     reactive: false
                                   });
        this.actor.connect('clicked', Lang.bind(this,
            function() {
                this._calendar.setDate(new Date(), false);
            }));
        let hbox = new St.BoxLayout({ vertical: true });
        this.actor.add_actor(hbox);
        this._dayLabel = new St.Label({ style_class: 'day-label',
                                        x_align: Clutter.ActorAlign.START });
        hbox.add_actor(this._dayLabel);
        this._dateLabel = new St.Label({ style_class: 'date-label' });
        hbox.add_actor(this._dateLabel);
        this._calendar = calendar;
        this._calendar.connect('selected-date-changed', Lang.bind(this,
            function(calendar, date) {
                // Make the button reactive only if the selected date is not the
                // current date.
                this.actor.reactive = !_isToday(date)
            }));
    },
    setDate: function(date) {
        this._dayLabel.set_text(date.toLocaleFormat('%A'));
        /* Translators: This is the date format to use when the calendar popup is
         * shown - it is shown just below the time in the shell (e.g. "Tue 9:29 AM").
         */
        let dateFormat = Shell.util_translate_time_string (N_("%B %e %Y"));
        this._dateLabel.set_text(date.toLocaleFormat(dateFormat));
        /* Translators: This is the accessible name of the date button shown
         * below the time in the shell; it should combine the weekday and the
         * date, e.g. "Tuesday February 17 2015".
         */
        let dateFormat = Shell.util_translate_time_string (N_("%A %B %e %Y"));
        this.actor.accessible_name = date.toLocaleFormat(dateFormat);
    }
const WorldClocksSection = new Lang.Class({
    Name: 'WorldClocksSection',
    _init: function() {
        this._clock = new GnomeDesktop.WallClock();
        this._settings = null;
        this._clockNotifyId = 0;
        this._changedId = 0;
        this._locations = [];
        this.actor = new St.Button({ style_class: 'world-clocks-button',
                                     x_fill: true,
                                     can_focus: true });
        this.actor.connect('clicked', Lang.bind(this,
            function() {
                let app = this._getClockApp();
                app.activate();
                Main.overview.hide();
                Main.panel.closeCalendar();
            }));
        let layout = new Clutter.GridLayout({ orientation: Clutter.Orientation.VERTICAL });
        this._grid = new St.Widget({ style_class: 'world-clocks-grid',
                                     layout_manager: layout });
        layout.hookup_style(this._grid);
        this.actor.child = this._grid;
        Shell.AppSystem.get_default().connect('installed-changed',
                                              Lang.bind(this, this._sync));
        this._sync();
    },
    _getClockApp: function() {
        return Shell.AppSystem.get_default().lookup_app('org.gnome.clocks.desktop');
    },
    _sync: function() {
        this.actor.visible = (this._getClockApp() != null);
        if (this.actor.visible) {
            if (!this._settings) {
                this._settings = new Gio.Settings({ schema_id: 'org.gnome.clocks' });
                this._changedId =
                    this._settings.connect('changed::world-clocks',
                                           Lang.bind(this, this._clocksChanged));
                this._clocksChanged();
            }
        } else {
            if (this._settings)
                this._settings.disconnect(this._changedId);
            this._settings = null;
            this._changedId = 0;
        }
    },
    _clocksChanged: function() {
        this._grid.destroy_all_children();
        this._locations = [];
        let world = GWeather.Location.get_world();
        let clocks = this._settings.get_value('world-clocks').deep_unpack();
        for (let i = 0; i < clocks.length; i++) {
            let l = world.deserialize(clocks[i].location);
            this._locations.push({ location: l });
        }
        this._locations.sort(function(a, b) {
            return a.location.get_timezone().get_offset() -
                   b.location.get_timezone().get_offset();
        });
        let layout = this._grid.layout_manager;
        let title = (this._locations.length == 0) ? _("Add world clocks
                                                  : _("World Clocks");
        let header = new St.Label({ style_class: 'world-clocks-header',
                                    x_align: Clutter.ActorAlign.START,
                                    text: title });
        layout.attach(header, 0, 0, 2, 1);
        this.actor.label_actor = header;
        for (let i = 0; i < this._locations.length; i++) {
            let l = this._locations[i].location;
            let label = new St.Label({ style_class: 'world-clocks-city',
                                       text: l.get_city_name(),
                                       x_align: Clutter.ActorAlign.START,
                                       x_expand: true });
            let time = new St.Label({ style_class: 'world-clocks-time',
                                      x_align: Clutter.ActorAlign.END,
                                      x_expand: true });
            if (this._grid.text_direction == Clutter.TextDirection.RTL) {
                layout.attach(time, 0, i + 1, 1, 1);
                layout.attach(label, 1, i + 1, 1, 1);
            } else {
                layout.attach(label, 0, i + 1, 1, 1);
                layout.attach(time, 1, i + 1, 1, 1);
            }
            this._locations[i].actor = time;
        }
        if (this._grid.get_n_children() > 1) {
            if (!this._clockNotifyId)
                this._clockNotifyId =
                    this._clock.connect('notify::clock', Lang.bind(this, this._updateLabels));
            this._updateLabels();
        } else {
            if (this._clockNotifyId)
                this._clock.disconnect(this._clockNotifyId);
            this._clockNotifyId = 0;
        }
    },
    _updateLabels: function() {
        for (let i = 0; i < this._locations.length; i++) {
            let l = this._locations[i];
            let tz = GLib.TimeZone.new(l.location.get_timezone().get_tzid());
            let now = GLib.DateTime.new_now(tz);
            l.actor.text = Util.formatTime(now, { timeOnly: true });
        }
    }
const MessagesIndicator = new Lang.Class({
    Name: 'MessagesIndicator',
    _init: function() {
        this.actor = new St.Label({ text: '
', visible: false, y_expand: true,
                                    y_align: Clutter.ActorAlign.CENTER });
        this._sources = [];
        Main.messageTray.connect('source-added', Lang.bind(this, this._onSourceAdded));
        Main.messageTray.connect('source-removed', Lang.bind(this, this._onSourceRemoved));
        Main.messageTray.connect('queue-changed', Lang.bind(this, this._updateCount));
        let sources = Main.messageTray.getSources();
        sources.forEach(Lang.bind(this, function(source) { this._onSourceAdded(null, source); }));
    },
    _onSourceAdded: function(tray, source) {
        source.connect('count-updated', Lang.bind(this, this._updateCount));
        this._sources.push(source);
        this._updateCount();
    },
    _onSourceRemoved: function(tray, source) {
        this._sources.splice(this._sources.indexOf(source), 1);
        this._updateCount();
    },
    _updateCount: function() {
        let count = 0;
        this._sources.forEach(Lang.bind(this,
            function(source) {
                count += source.unseenCount;
            }));
        count -= Main.messageTray.queueCount;
        this.actor.visible = (count > 0);
    }
const IndicatorPad = new Lang.Class({
    Name: 'IndicatorPad',
    Extends: St.Widget,
    _init: function(actor) {
        this._source = actor;
        this._source.connect('notify::visible',
                             Lang.bind(this, this.queue_relayout));
        this.parent();
    },
    vfunc_get_preferred_width: function(container, forHeight) {
        if (this._source.visible)
            return this._source.get_preferred_width(forHeight);
        return [0, 0];
    },
    vfunc_get_preferred_height: function(container, forWidth) {
        if (this._source.visible)
            return this._source.get_preferred_height(forWidth);
        return [0, 0];
    }
const FreezableBinLayout = new Lang.Class({
    Name: 'FreezableBinLayout',
    Extends: Clutter.BinLayout,
    _init: function() {
        this.parent();
        this._frozen = false;
        this._savedWidth = [NaN, NaN];
        this._savedHeight = [NaN, NaN];
    },
    set frozen(v) {
        if (this._frozen == v)
            return;
        this._frozen = v;
        if (!this._frozen)
            this.layout_changed();
    },
    vfunc_get_preferred_width: function(container, forHeight) {
        if (!this._frozen || this._savedWidth.some(isNaN))
            this._savedWidth = this.parent(container, forHeight);
        return this._savedWidth;
    },
    vfunc_get_preferred_height: function(container, forWidth) {
        if (!this._frozen || this._savedHeight.some(isNaN))
            this._savedHeight = this.parent(container, forWidth);
        return this._savedHeight;
    }
const DateMenuButton = new Lang.Class({
    Name: 'DateMenuButton',
    Extends: PanelMenu.Button,
    _init: function() {
        let item;
        let hbox;
        let vbox;
        let menuAlignment = 0.5;
        if (Clutter.get_default_text_direction() == Clutter.TextDirection.RTL)
            menuAlignment = 1.0 - menuAlignment;
        this.parent(menuAlignment);
        this._clockDisplay = new St.Label({ y_align: Clutter.ActorAlign.CENTER });
        this._indicator = new MessagesIndicator();
        let box = new St.BoxLayout();
        box.add_actor(new IndicatorPad(this._indicator.actor));
        box.add_actor(this._clockDisplay);
        box.add_actor(this._indicator.actor);
        this.actor.label_actor = this._clockDisplay;
        this.actor.add_actor(box);
        this.actor.add_style_class_name ('clock-display');
        let layout = new FreezableBinLayout();
        let bin = new St.Widget({ layout_manager: layout });
        this.menu.box.add_child(bin);
        hbox = new St.BoxLayout({ name: 'calendarArea' });
        bin.add_actor(hbox);
        this._calendar = new Calendar.Calendar();
        this._calendar.connect('selected-date-changed',
                               Lang.bind(this, function(calendar, date) {
                                   layout.frozen = !_isToday(date);
                                   this._messageList.setDate(date);
                               }));
        this.menu.connect('open-state-changed', Lang.bind(this, function(menu, isOpen) {
            // Whenever the menu is opened, select today
            if (isOpen) {
                let now = new Date();
                this._calendar.setDate(now);
                this._date.setDate(now);
                this._messageList.setDate(now);
            }
        }));
        // Fill up the first column
        this._messageList = new Calendar.CalendarMessageList();
        hbox.add(this._messageList.actor, { expand: true, y_fill: false, y_align: St.Align.START });
        // Fill up the second column
        vbox = new St.BoxLayout({ style_class: 'datemenu-calendar-column',
                                  vertical: true });
        hbox.add(vbox);
        this._date = new TodayButton(this._calendar);
        vbox.add_actor(this._date.actor);
        vbox.add(this._calendar.actor);
        this._displaysSection = new St.ScrollView({ style_class: 'datemenu-displays-section vfade',
                                                    x_expand: true, x_fill: true,
                                                    overlay_scrollbars: true });
        this._displaysSection.set_policy(Gtk.PolicyType.NEVER, Gtk.PolicyType.AUTOMATIC);
        vbox.add_actor(this._displaysSection);
        let displaysBox = new St.BoxLayout({ vertical: true,
                                             style_class: 'datemenu-displays-box' });
        this._displaysSection.add_actor(displaysBox);
        this._clocksItem = new WorldClocksSection();
        displaysBox.add(this._clocksItem.actor, { x_fill: true });
        // Done with hbox for calendar and event list
        this._clock = new GnomeDesktop.WallClock();
        this._clock.bind_property('clock', this._clockDisplay, 'text', GObject.BindingFlags.SYNC_CREATE);
        Main.sessionMode.connect('updated', Lang.bind(this, this._sessionUpdated));
        this._sessionUpdated();
    },
    _getEventSource: function() {
        return new Calendar.DBusEventSource();
    },
    _setEventSource: function(eventSource) {
        if (this._eventSource)
            this._eventSource.destroy();
        this._calendar.setEventSource(eventSource);
        this._messageList.setEventSource(eventSource);
        this._eventSource = eventSource;
    },
    _sessionUpdated: function() {
        let eventSource;
        let showEvents = Main.sessionMode.showCalendarEvents;
        if (showEvents) {
            eventSource = this._getEventSource();
        } else {
            eventSource = new Calendar.EmptyEventSource();
        }
        this._setEventSource(eventSource);
        // Displays are not actually expected to launch Settings when activated
        // but the corresponding app (clocks, weather); however we can consider
        // that display-specific settings, so re-use "allowSettings" here ...
        this._displaysSection.visible = Main.sessionMode.allowSettings;
    }
(uuay)overview.js]Y
// -*- mode: js; js-indent-level: 4; indent-tabs-mode: nil -*-
const Clutter = imports.gi.Clutter;
const GLib = imports.gi.GLib;
const Gtk = imports.gi.Gtk;
const Meta = imports.gi.Meta;
const Mainloop = imports.mainloop;
const Signals = imports.signals;
const Lang = imports.lang;
const St = imports.gi.St;
const Shell = imports.gi.Shell;
const Gdk = imports.gi.Gdk;
const Background = imports.ui.background;
const DND = imports.ui.dnd;
const LayoutManager = imports.ui.layout;
const Lightbox = imports.ui.lightbox;
const Main = imports.ui.main;
const MessageTray = imports.ui.messageTray;
const OverviewControls = imports.ui.overviewControls;
const Panel = imports.ui.panel;
const Params = imports.misc.params;
const Tweener = imports.ui.tweener;
const WorkspaceThumbnail = imports.ui.workspaceThumbnail;
// Time for initial animation going into Overview mode
const ANIMATION_TIME = 0.25;
// Must be less than ANIMATION_TIME, since we switch to
// or from the overview completely after ANIMATION_TIME,
// and don't want the shading animation to get cut off
const SHADE_ANIMATION_TIME = .20;
const DND_WINDOW_SWITCH_TIMEOUT = 750;
const OVERVIEW_ACTIVATION_TIMEOUT = 0.5;
const ShellInfo = new Lang.Class({
    Name: 'ShellInfo',
    _init: function() {
        this._source = null;
        this._undoCallback = null;
    },
    _onUndoClicked: function() {
        if (this._undoCallback)
            this._undoCallback();
        this._undoCallback = null;
        if (this._source)
            this._source.destroy();
    },
    setMessage: function(text, options) {
        options = Params.parse(options, { undoCallback: null,
                                          forFeedback: false
                                        });
        let undoCallback = options.undoCallback;
        let forFeedback = options.forFeedback;
        if (this._source == null) {
            this._source = new MessageTray.SystemNotificationSource();
            this._source.connect('destroy', Lang.bind(this,
                function() {
                    this._source = null;
                }));
            Main.messageTray.add(this._source);
        }
        let notification = null;
        if (this._source.notifications.length == 0) {
            notification = new MessageTray.Notification(this._source, text, null);
            notification.setTransient(true);
            notification.setForFeedback(forFeedback);
        } else {
            notification = this._source.notifications[0];
            notification.update(text, null, { clear: true });
        }
        this._undoCallback = undoCallback;
        if (undoCallback)
            notification.addAction(_("Undo"), Lang.bind(this, this._onUndoClicked));
        this._source.notify(notification);
    }
const Overview = new Lang.Class({
    Name: 'Overview',
    _init: function() {
        this._overviewCreated = false;
        this._initCalled = false;
        Main.sessionMode.connect('updated', Lang.bind(this, this._sessionUpdated));
        this._sessionUpdated();
    },
    _createOverview: function() {
        if (this._overviewCreated)
            return;
        if (this.isDummy)
            return;
        this._overviewCreated = true;
        /* Translators: This is the main view to select
           activities. See also note for "Activities" string. */
        this._overview = new St.BoxLayout({ name: 'overview',
                                            accessible_name: _("Overview"),
                                            vertical: true });
        this._overview.add_constraint(new LayoutManager.MonitorConstraint({ primary: true }));
        this._overview._delegate = this;
        // The main Background actors are inside global.window_group which are
        // hidden when displaying the overview, so we create a new
        // one. Instances of this class share a single CoglTexture behind the
        // scenes which allows us to show the background with different
        // rendering options without duplicating the texture data.
        this._backgroundGroup = new Meta.BackgroundGroup({ reactive: true });
        Main.layoutManager.overviewGroup.add_child(this._backgroundGroup);
        this._bgManagers = [];
        this._desktopFade = new St.Widget();
        Main.layoutManager.overviewGroup.add_child(this._desktopFade);
        this._activationTime = 0;
        this.visible = false;           // animating to overview, in overview, animating out
        this._shown = false;            // show() and not hide()
        this._modal = false;            // have a modal grab
        this.animationInProgress = false;
        this.visibleTarget = false;
        // During transitions, we raise this to the top to avoid having the overview
        // area be reactive; it causes too many issues such as double clicks on
        // Dash elements, or mouseover handlers in the workspaces.
        this._coverPane = new Clutter.Actor({ opacity: 0,
                                              reactive: true });
        Main.layoutManager.overviewGroup.add_child(this._coverPane);
        this._coverPane.connect('event', Lang.bind(this, function (actor, event) { return Clutter.EVENT_STOP; }));
        Main.layoutManager.overviewGroup.add_child(this._overview);
        this._coverPane.hide();
        // XDND
        this._dragMonitor = {
            dragMotion: Lang.bind(this, this._onDragMotion)
        };
        Main.layoutManager.overviewGroup.connect('scroll-event',
                                                 Lang.bind(this, this._onScrollEvent));
        Main.xdndHandler.connect('drag-begin', Lang.bind(this, this._onDragBegin));
        Main.xdndHandler.connect('drag-end', Lang.bind(this, this._onDragEnd));
        global.screen.connect('restacked', Lang.bind(this, this._onRestacked));
        this._windowSwitchTimeoutId = 0;
        this._windowSwitchTimestamp = 0;
        this._lastActiveWorkspaceIndex = -1;
        this._lastHoveredWindow = null;
        this._needsFakePointerEvent = false;
        if (this._initCalled)
            this.init();
    },
    _updateBackgrounds: function() {
        for (let i = 0; i < this._bgManagers.length; i++)
            this._bgManagers[i].destroy();
        this._bgManagers = [];
        for (let i = 0; i < Main.layoutManager.monitors.length; i++) {
            let bgManager = new Background.BackgroundManager({ container: this._backgroundGroup,
                                                               monitorIndex: i,
                                                               vignette: true });
            this._bgManagers.push(bgManager);
        }
    },
    _unshadeBackgrounds: function() {
        let backgrounds = this._backgroundGroup.get_children();
        for (let i = 0; i < backgrounds.length; i++) {
            Tweener.addTween(backgrounds[i],
                             { brightness: 1.0,
                               vignette_sharpness: 0.0,
                               time: SHADE_ANIMATION_TIME,
                               transition: 'easeOutQuad'
                             });
        }
    },
    _shadeBackgrounds: function() {
        let backgrounds = this._backgroundGroup.get_children();
        for (let i = 0; i < backgrounds.length; i++) {
            Tweener.addTween(backgrounds[i],
                             { brightness: Lightbox.VIGNETTE_BRIGHTNESS,
                               vignette_sharpness: Lightbox.VIGNETTE_SHARPNESS,
                               time: SHADE_ANIMATION_TIME,
                               transition: 'easeOutQuad'
                             });
        }
    },
    _sessionUpdated: function() {
        this.isDummy = !Main.sessionMode.hasOverview;
        this._createOverview();
    },
    // The members we construct that are implemented in JS might
    // want to access the overview as Main.overview to connect
    // signal handlers and so forth. So we create them after
    // construction in this init() method.
    init: function() {
        this._initCalled = true;
        if (this.isDummy)
            return;
        this._shellInfo = new ShellInfo();
        // Add a clone of the panel to the overview so spacing and such is
        // automatic
        this._panelGhost = new St.Bin({ child: new Clutter.Clone({ source: Main.panel.actor }),
                                        reactive: false,
                                        opacity: 0 });
        this._overview.add_actor(this._panelGhost);
        this._searchEntry = new St.Entry({ style_class: 'search-entry',
                                           /* Translators: this is the text displayed
                                              in the search entry when no search is
                                              active; it should not exceed ~30
                                              characters. */
                                           hint_text: _("Type to search
                                           track_hover: true,
                                           can_focus: true });
        this._searchEntryBin = new St.Bin({ child: this._searchEntry,
                                            x_align: St.Align.MIDDLE });
        this._overview.add_actor(this._searchEntryBin);
        // Create controls
        this._controls = new OverviewControls.ControlsManager(this._searchEntry);
        this._dash = this._controls.dash;
        this.viewSelector = this._controls.viewSelector;
        // Add our same-line elements after the search entry
        this._overview.add(this._controls.actor, { y_fill: true, expand: true });
        // TODO - recalculate everything when desktop size changes
        this.dashIconSize = this._dash.iconSize;
        this._dash.connect('icon-size-changed',
                           Lang.bind(this, function() {
                               this.dashIconSize = this._dash.iconSize;
                           }));
        Main.layoutManager.connect('monitors-changed', Lang.bind(this, this._relayout));
        this._relayout();
    },
    addSearchProvider: function(provider) {
        this.viewSelector.addSearchProvider(provider);
    },
    removeSearchProvider: function(provider) {
        this.viewSelector.removeSearchProvider(provider);
    },
    //
    // options:
    //  - undoCallback (function): the callback to be called if undo support is needed
    //  - forFeedback (boolean): whether the message is for direct feedback of a user action
    //
    setMessage: function(text, options) {
        if (this.isDummy)
            return;
        this._shellInfo.setMessage(text, options);
    },
    _onDragBegin: function() {
        this._inXdndDrag = true;
        DND.addDragMonitor(this._dragMonitor);
        // Remember the workspace we started from
        this._lastActiveWorkspaceIndex = global.screen.get_active_workspace_index();
    },
    _onDragEnd: function(time) {
        this._inXdndDrag = false;
        // In case the drag was canceled while in the overview
        // we have to go back to where we started and hide
        // the overview
        if (this._shown) {
            global.screen.get_workspace_by_index(this._lastActiveWorkspaceIndex).activate(time);
            this.hide();
        }
        this._resetWindowSwitchTimeout();
        this._lastHoveredWindow = null;
        DND.removeDragMonitor(this._dragMonitor);
        this.endItemDrag();
    },
    _resetWindowSwitchTimeout: function() {
        if (this._windowSwitchTimeoutId != 0) {
            Mainloop.source_remove(this._windowSwitchTimeoutId);
            this._windowSwitchTimeoutId = 0;
            this._needsFakePointerEvent = false;
        }
    },
    _fakePointerEvent: function() {
        let display = Gdk.Display.get_default();
        let deviceManager = display.get_device_manager();
        let pointer = deviceManager.get_client_pointer();
        let [screen, pointerX, pointerY] = pointer.get_position();
        pointer.warp(screen, pointerX, pointerY);
    },
    _onDragMotion: function(dragEvent) {
        let targetIsWindow = dragEvent.targetActor &&
                             dragEvent.targetActor._delegate &&
                             dragEvent.targetActor._delegate.metaWindow &&
                             !(dragEvent.targetActor._delegate instanceof WorkspaceThumbnail.WindowClone);
        this._windowSwitchTimestamp = global.get_current_time();
        if (targetIsWindow &&
            dragEvent.targetActor._delegate.metaWindow == this._lastHoveredWindow)
            return DND.DragMotionResult.CONTINUE;
        this._lastHoveredWindow = null;
        this._resetWindowSwitchTimeout();
        if (targetIsWindow) {
            this._lastHoveredWindow = dragEvent.targetActor._delegate.metaWindow;
            this._windowSwitchTimeoutId = Mainloop.timeout_add(DND_WINDOW_SWITCH_TIMEOUT,
                                            Lang.bind(this, function() {
                                                this._windowSwitchTimeoutId = 0;
                                                this._needsFakePointerEvent = true;
                                                Main.activateWindow(dragEvent.targetActor._delegate.metaWindow,
                                                                    this._windowSwitchTimestamp);
                                                this.hide();
                                                this._lastHoveredWindow = null;
                                                return GLib.SOURCE_REMOVE;
                                            }));
            GLib.Source.set_name_by_id(this._windowSwitchTimeoutId, '[gnome-shell] Main.activateWindow');
        }
        return DND.DragMotionResult.CONTINUE;
    },
    _onScrollEvent: function(actor, event) {
        this.emit('scroll-event', event);
        return Clutter.EVENT_PROPAGATE;
    },
    addAction: function(action) {
        if (this.isDummy)
            return;
        this._backgroundGroup.add_action(action);
    },
    _getDesktopClone: function() {
        let windows = global.get_window_actors().filter(function(w) {
            return w.meta_window.get_window_type() == Meta.WindowType.DESKTOP;
        });
        if (windows.length == 0)
            return null;
        let window = windows[0];
        let clone = new Clutter.Clone({ source: window.get_texture(),
                                        x: window.x, y: window.y });
        clone.source.connect('destroy', Lang.bind(this, function() {
            clone.destroy();
        }));
        return clone;
    },
    _relayout: function () {
        // To avoid updating the position and size of the workspaces
        // we just hide the overview. The positions will be updated
        // when it is next shown.
        this.hide();
        let workArea = Main.layoutManager.getWorkAreaForMonitor(Main.layoutManager.primaryIndex);
        this._coverPane.set_position(0, workArea.y);
        this._coverPane.set_size(workArea.width, workArea.height);
        this._updateBackgrounds();
    },
    _onRestacked: function() {
        let stack = global.get_window_actors();
        let stackIndices = {};
        for (let i = 0; i < stack.length; i++) {
            // Use the stable sequence for an integer to use as a hash key
            stackIndices[stack[i].get_meta_window().get_stable_sequence()] = i;
        }
        this.emit('windows-restacked', stackIndices);
    },
    beginItemDrag: function(source) {
        this.emit('item-drag-begin');
        this._inDrag = true;
    },
    cancelledItemDrag: function(source) {
        this.emit('item-drag-cancelled');
    },
    endItemDrag: function(source) {
        this.emit('item-drag-end');
        this._inDrag = false;
    },
    beginWindowDrag: function(window) {
        this.emit('window-drag-begin', window);
        this._inDrag = true;
    },
    cancelledWindowDrag: function(window) {
        this.emit('window-drag-cancelled', window);
    },
    endWindowDrag: function(window) {
        this.emit('window-drag-end', window);
        this._inDrag = false;
    },
    focusSearch: function() {
        this.show();
        this._searchEntry.grab_key_focus();
    },
    fadeInDesktop: function() {
            this._desktopFade.opacity = 0;
            this._desktopFade.show();
            Tweener.addTween(this._desktopFade,
                             { opacity: 255,
                               time: ANIMATION_TIME,
                               transition: 'easeOutQuad' });
    },
    fadeOutDesktop: function() {
        if (!this._desktopFade.get_n_children()) {
            let clone = this._getDesktopClone();
            if (!clone)
                return;
            this._desktopFade.add_child(clone);
        }
        this._desktopFade.opacity = 255;
        this._desktopFade.show();
        Tweener.addTween(this._desktopFade,
                         { opacity: 0,
                           time: ANIMATION_TIME,
                           transition: 'easeOutQuad'
                         });
    },
    // Checks if the Activities button is currently sensitive to
    // clicks. The first call to this function within the
    // OVERVIEW_ACTIVATION_TIMEOUT time of the hot corner being
    // triggered will return false. This avoids opening and closing
    // the overview if the user both triggered the hot corner and
    // clicked the Activities button.
    shouldToggleByCornerOrButton: function() {
        if (this.animationInProgress)
            return false;
        if (this._inDrag)
            return false;
        if (this._activationTime == 0 || Date.now() / 1000 - this._activationTime > OVERVIEW_ACTIVATION_TIMEOUT)
            return true;
        return false;
    },
    _syncGrab: function() {
        // We delay grab changes during animation so that when removing the
        // overview we don't have a problem with the release of a press/release
        // going to an application.
        if (this.animationInProgress)
            return true;
        if (this._shown) {
            let shouldBeModal = !this._inXdndDrag;
            if (shouldBeModal) {
                if (!this._modal) {
                    if (Main.pushModal(this._overview,
                                       { actionMode: Shell.ActionMode.OVERVIEW })) {
                        this._modal = true;
                    } else {
                        this.hide();
                        return false;
                    }
                }
            }
        } else {
            if (this._modal) {
                Main.popModal(this._overview);
                this._modal = false;
            }
        }
        return true;
    },
    // show:
    //
    // Animates the overview visible and grabs mouse and keyboard input
    show: function() {
        if (this.isDummy)
            return;
        if (this._shown)
            return;
        this._shown = true;
        if (!this._syncGrab())
            return;
        Main.layoutManager.showOverview();
        this._animateVisible();
    },
    _animateVisible: function() {
        if (this.visible || this.animationInProgress)
            return;
        this.visible = true;
        this.animationInProgress = true;
        this.visibleTarget = true;
        this._activationTime = Date.now() / 1000;
        Meta.disable_unredirect_for_screen(global.screen);
        this.viewSelector.show();
        this._overview.opacity = 0;
        Tweener.addTween(this._overview,
                         { opacity: 255,
                           transition: 'easeOutQuad',
                           time: ANIMATION_TIME,
                           onComplete: this._showDone,
                           onCompleteScope: this
                         });
        this._shadeBackgrounds();
        this._coverPane.raise_top();
        this._coverPane.show();
        this.emit('showing');
    },
    _showDone: function() {
        this.animationInProgress = false;
        this._desktopFade.hide();
        this._coverPane.hide();
        this.emit('shown');
        // Handle any calls to hide* while we were showing
        if (!this._shown)
            this._animateNotVisible();
        this._syncGrab();
        global.sync_pointer();
    },
    // hide:
    //
    // Reverses the effect of show()
    hide: function() {
        if (this.isDummy)
            return;
        if (!this._shown)
            return;
        let event = Clutter.get_current_event();
        if (event) {
            let type = event.type();
            let button = (type == Clutter.EventType.BUTTON_PRESS ||
                          type == Clutter.EventType.BUTTON_RELEASE);
            let ctrl = (event.get_state() & Clutter.ModifierType.CONTROL_MASK) != 0;
            if (button && ctrl)
                return;
        }
        this._shown = false;
        this._animateNotVisible();
        this._syncGrab();
    },
    _animateNotVisible: function() {
        if (!this.visible || this.animationInProgress)
            return;
        this.animationInProgress = true;
        this.visibleTarget = false;
        this.viewSelector.animateFromOverview();
        // Make other elements fade out.
        Tweener.addTween(this._overview,
                         { opacity: 0,
                           transition: 'easeOutQuad',
                           time: ANIMATION_TIME,
                           onComplete: this._hideDone,
                           onCompleteScope: this
                         });
        this._unshadeBackgrounds();
        this._coverPane.raise_top();
        this._coverPane.show();
        this.emit('hiding');
    },
    _hideDone: function() {
        // Re-enable unredirection
        Meta.enable_unredirect_for_screen(global.screen);
        this.viewSelector.hide();
        this._desktopFade.hide();
        this._coverPane.hide();
        this.visible = false;
        this.animationInProgress = false;
        this.emit('hidden');
        // Handle any calls to show* while we were hiding
        if (this._shown)
            this._animateVisible();
        else
            Main.layoutManager.hideOverview();
        this._syncGrab();
        // Fake a pointer event if requested
        if (this._needsFakePointerEvent) {
            this._fakePointerEvent();
            this._needsFakePointerEvent = false;
        }
    },
    toggle: function() {
        if (this.isDummy)
            return;
        if (this.visible)
            this.hide();
        else
            this.show();
    },
    getShowAppsButton: function() {
        return this._dash.showAppsButton;
    }
Signals.addSignalMethods(Overview.prototype);
(uuay)org/
unlockDialog.js
// -*- mode: js; js-indent-level: 4; indent-tabs-mode: nil -*-
const AccountsService = imports.gi.AccountsService;
const Atk = imports.gi.Atk;
const Clutter = imports.gi.Clutter;
const Gdm  = imports.gi.Gdm;
const Gio = imports.gi.Gio;
const GLib = imports.gi.GLib;
const GnomeDesktop = imports.gi.GnomeDesktop;
const Gtk = imports.gi.Gtk;
const Lang = imports.lang;
const Meta = imports.gi.Meta;
const Signals = imports.signals;
const Shell = imports.gi.Shell;
const St = imports.gi.St;
const Layout = imports.ui.layout;
const Main = imports.ui.main;
const Panel = imports.ui.panel;
const Tweener = imports.ui.tweener;
const UserWidget = imports.ui.userWidget;
const AuthPrompt = imports.gdm.authPrompt;
const Batch = imports.gdm.batch;
const GdmUtil = imports.gdm.util;
const LoginDialog = imports.gdm.loginDialog;
// The timeout before going back automatically to the lock screen (in seconds)
const IDLE_TIMEOUT = 2 * 60;
const UnlockDialog = new Lang.Class({
    Name: 'UnlockDialog',
    _init: function(parentActor) {
        this.actor = new St.Widget({ accessible_role: Atk.Role.WINDOW,
                                     style_class: 'login-dialog',
                                     layout_manager: new Clutter.BoxLayout(),
                                     visible: false });
        this.actor.add_constraint(new Layout.MonitorConstraint({ primary: true }));
        parentActor.add_child(this.actor);
        this._userManager = AccountsService.UserManager.get_default();
        this._userName = GLib.get_user_name();
        this._user = this._userManager.get_user(this._userName);
        this._promptBox = new St.BoxLayout({ vertical: true,
                                             x_align: Clutter.ActorAlign.CENTER,
                                             y_align: Clutter.ActorAlign.CENTER,
                                             x_expand: true,
                                             y_expand: true });
        this.actor.add_child(this._promptBox);
        this._authPrompt = new AuthPrompt.AuthPrompt(new Gdm.Client(), AuthPrompt.AuthPromptMode.UNLOCK_ONLY);
        this._authPrompt.connect('failed', Lang.bind(this, this._fail));
        this._authPrompt.connect('cancelled', Lang.bind(this, this._fail));
        this._authPrompt.connect('reset', Lang.bind(this, this._onReset));
        this._authPrompt.setPasswordChar('\u25cf');
        this._authPrompt.nextButton.label = _("Unlock");
        this._promptBox.add_child(this._authPrompt.actor);
        this.allowCancel = false;
        let screenSaverSettings = new Gio.Settings({ schema_id: 'org.gnome.desktop.screensaver' });
        if (screenSaverSettings.get_boolean('user-switch-enabled')) {
            let otherUserLabel = new St.Label({ text: _("Log in as another user"),
                                                style_class: 'login-dialog-not-listed-label' });
            this._otherUserButton = new St.Button({ style_class: 'login-dialog-not-listed-button',
                                                    can_focus: true,
                                                    child: otherUserLabel,
                                                    reactive: true,
                                                    x_align: St.Align.START,
                                                    x_fill: false });
            this._otherUserButton.connect('clicked', Lang.bind(this, this._otherUserClicked));
            this._promptBox.add_child(this._otherUserButton);
        } else {
            this._otherUserButton = null;
        }
        this._authPrompt.reset();
        this._updateSensitivity(true);
        Main.ctrlAltTabManager.addGroup(this.actor, _("Unlock Window"), 'dialog-password-symbolic');
        this._idleMonitor = Meta.IdleMonitor.get_core();
        this._idleWatchId = this._idleMonitor.add_idle_watch(IDLE_TIMEOUT * 1000, Lang.bind(this, this._escape));
    },
    _updateSensitivity: function(sensitive) {
        this._authPrompt.updateSensitivity(sensitive);
        if (this._otherUserButton) {
            this._otherUserButton.reactive = sensitive;
            this._otherUserButton.can_focus = sensitive;
        }
    },
    _fail: function() {
        this.emit('failed');
    },
    _onReset: function(authPrompt, beginRequest) {
        let userName;
        if (beginRequest == AuthPrompt.BeginRequestType.PROVIDE_USERNAME) {
            this._authPrompt.setUser(this._user);
            userName = this._userName;
        } else {
            userName = null;
        }
        this._authPrompt.begin({ userName: userName });
    },
    _escape: function() {
        if (this.allowCancel)
            this._authPrompt.cancel();
    },
    _otherUserClicked: function(button, event) {
        Gdm.goto_login_session_sync(null);
        this._authPrompt.cancel();
    },
    destroy: function() {
        this.popModal();
        this.actor.destroy();
        if (this._idleWatchId) {
            this._idleMonitor.remove_watch(this._idleWatchId);
            this._idleWatchId = 0;
        }
    },
    cancel: function() {
        this._authPrompt.cancel();
        this.destroy();
    },
    addCharacter: function(unichar) {
        this._authPrompt.addCharacter(unichar);
    },
    finish: function(onComplete) {
        this._authPrompt.finish(onComplete);
    },
    open: function(timestamp) {
        this.actor.show();
        if (this._isModal)
            return true;
        if (!Main.pushModal(this.actor, { timestamp: timestamp,
                                          actionMode: Shell.ActionMode.UNLOCK_SCREEN }))
            return false;
        this._isModal = true;
        return true;
    },
    popModal: function(timestamp) {
        if (this._isModal) {
            Main.popModal(this.actor, timestamp);
            this._isModal = false;
        }
    }
Signals.addSignalMethods(UnlockDialog.prototype);
(uuay)panel.js
// -*- mode: js; js-indent-level: 4; indent-tabs-mode: nil -*-
const Cairo = imports.cairo;
const Clutter = imports.gi.Clutter;
const Gio = imports.gi.Gio;
const GLib = imports.gi.GLib;
const Gtk = imports.gi.Gtk;
const Lang = imports.lang;
const Mainloop = imports.mainloop;
const Meta = imports.gi.Meta;
const Pango = imports.gi.Pango;
const Shell = imports.gi.Shell;
const St = imports.gi.St;
const Signals = imports.signals;
const Atk = imports.gi.Atk;
const Animation = imports.ui.animation;
const Config = imports.misc.config;
const CtrlAltTab = imports.ui.ctrlAltTab;
const DND = imports.ui.dnd;
const Overview = imports.ui.overview;
const PopupMenu = imports.ui.popupMenu;
const PanelMenu = imports.ui.panelMenu;
const RemoteMenu = imports.ui.remoteMenu;
const Main = imports.ui.main;
const Tweener = imports.ui.tweener;
const PANEL_ICON_SIZE = 16;
const APP_MENU_ICON_MARGIN = 0;
const BUTTON_DND_ACTIVATION_TIMEOUT = 250;
const SPINNER_ANIMATION_TIME = 1.0;
// To make sure the panel corners blend nicely with the panel,
// we draw background and borders the same way, e.g. drawing
// them as filled shapes from the outside inwards instead of
// using cairo stroke(). So in order to give the border the
// appearance of being drawn on top of the background, we need
// to blend border and background color together.
// For that purpose we use the following helper methods, taken
// from st-theme-node-drawing.c
function _norm(x) {
    return Math.round(x / 255);
function _over(srcColor, dstColor) {
    let src = _premultiply(srcColor);
    let dst = _premultiply(dstColor);
    let result = new Clutter.Color();
    result.alpha = src.alpha + _norm((255 - src.alpha) * dst.alpha);
    result.red = src.red + _norm((255 - src.alpha) * dst.red);
    result.green = src.green + _norm((255 - src.alpha) * dst.green);
    result.blue = src.blue + _norm((255 - src.alpha) * dst.blue);
    return _unpremultiply(result);
function _premultiply(color) {
    return new Clutter.Color({ red: _norm(color.red * color.alpha),
                               green: _norm(color.green * color.alpha),
                               blue: _norm(color.blue * color.alpha),
                               alpha: color.alpha });
function _unpremultiply(color) {
    if (color.alpha == 0)
        return new Clutter.Color();
    let red = Math.min((color.red * 255 + 127) / color.alpha, 255);
    let green = Math.min((color.green * 255 + 127) / color.alpha, 255);
    let blue = Math.min((color.blue * 255 + 127) / color.alpha, 255);
    return new Clutter.Color({ red: red, green: green,
                               blue: blue, alpha: color.alpha });
 * AppMenuButton:
 * This class manages the "application menu" component.  It tracks the
 * currently focused application.  However, when an app is launched,
 * this menu also handles startup notification for it.  So when we
 * have an active startup notification, we switch modes to display that.
const AppMenuButton = new Lang.Class({
    Name: 'AppMenuButton',
    Extends: PanelMenu.Button,
    _init: function(panel) {
        this.parent(0.0, null, true);
        this.actor.accessible_role = Atk.Role.MENU;
        this._startingApps = [];
        this._menuManager = panel.menuManager;
        this._gtkSettings = Gtk.Settings.get_default();
        this._targetApp = null;
        this._appMenuNotifyId = 0;
        this._actionGroupNotifyId = 0;
        this._busyNotifyId = 0;
        let bin = new St.Bin({ name: 'appMenu' });
        bin.connect('style-changed', Lang.bind(this, this._onStyleChanged));
        this.actor.add_actor(bin);
        this.actor.bind_property("reactive", this.actor, "can-focus", 0);
        this.actor.reactive = false;
        this._container = new St.BoxLayout({ style_class: 'panel-status-menu-box' });
        bin.set_child(this._container);
        let textureCache = St.TextureCache.get_default();
        textureCache.connect('icon-theme-changed',
                             Lang.bind(this, this._onIconThemeChanged));
        this._iconBox = new St.Bin({ style_class: 'app-menu-icon' });
        this._container.add_actor(this._iconBox);
        this._label = new St.Label({ y_expand: true,
                                     y_align: Clutter.ActorAlign.CENTER });
        this._container.add_actor(this._label);
        this._arrow = PopupMenu.arrowIcon(St.Side.BOTTOM);
        this._container.add_actor(this._arrow);
        this._visible = this._gtkSettings.gtk_shell_shows_app_menu &&
                        !Main.overview.visible;
        if (!this._visible)
            this.actor.hide();
        this._overviewHidingId = Main.overview.connect('hiding', Lang.bind(this, this._sync));
        this._overviewShowingId = Main.overview.connect('showing', Lang.bind(this, this._sync));
        this._showsAppMenuId = this._gtkSettings.connect('notify::gtk-shell-shows-app-menu',
                                                         Lang.bind(this, this._sync));
        this._stop = true;
        this._spinner = null;
        let tracker = Shell.WindowTracker.get_default();
        let appSys = Shell.AppSystem.get_default();
        this._focusAppNotifyId =
            tracker.connect('notify::focus-app', Lang.bind(this, this._focusAppChanged));
        this._appStateChangedSignalId =
            appSys.connect('app-state-changed', Lang.bind(this, this._onAppStateChanged));
        this._switchWorkspaceNotifyId =
            global.window_manager.connect('switch-workspace', Lang.bind(this, this._sync));
        this._sync();
    },
    show: function() {
        if (this._visible)
            return;
        this._visible = true;
        this.actor.reactive = true;
        this.actor.show();
        Tweener.removeTweens(this.actor);
        Tweener.addTween(this.actor,
                         { opacity: 255,
                           time: Overview.ANIMATION_TIME,
                           transition: 'easeOutQuad' });
    },
    hide: function() {
        if (!this._visible)
            return;
        this._visible = false;
        this.actor.reactive = false;
        Tweener.removeTweens(this.actor);
        Tweener.addTween(this.actor,
                         { opacity: 0,
                           time: Overview.ANIMATION_TIME,
                           transition: 'easeOutQuad',
                           onComplete: function() {
                               this.actor.hide();
                           },
                           onCompleteScope: this });
    },
    _onStyleChanged: function(actor) {
        let node = actor.get_theme_node();
        let [success, icon] = node.lookup_url('spinner-image', false);
        if (!success || (this._spinnerIcon && this._spinnerIcon.equal(icon)))
            return;
        this._spinnerIcon = icon;
        this._spinner = new Animation.AnimatedIcon(this._spinnerIcon, PANEL_ICON_SIZE);
        this._container.add_actor(this._spinner.actor);
        this._spinner.actor.hide();
    },
    _syncIcon: function() {
        if (!this._targetApp)
            return;
        let icon = this._targetApp.create_icon_texture(PANEL_ICON_SIZE - APP_MENU_ICON_MARGIN);
        this._iconBox.set_child(icon);
    },
    _onIconThemeChanged: function() {
        if (this._iconBox.child == null)
            return;
        this._syncIcon();
    },
    stopAnimation: function() {
        if (this._stop)
            return;
        this._stop = true;
        if (this._spinner == null)
            return;
        Tweener.addTween(this._spinner.actor,
                         { opacity: 0,
                           time: SPINNER_ANIMATION_TIME,
                           transition: "easeOutQuad",
                           onCompleteScope: this,
                           onComplete: function() {
                               this._spinner.stop();
                               this._spinner.actor.opacity = 255;
                               this._spinner.actor.hide();
                           }
                         });
    },
    startAnimation: function() {
        this._stop = false;
        if (this._spinner == null)
            return;
        this._spinner.play();
        this._spinner.actor.show();
    },
    _onAppStateChanged: function(appSys, app) {
        let state = app.state;
        if (state != Shell.AppState.STARTING) {
            this._startingApps = this._startingApps.filter(function(a) {
                return a != app;
            });
        } else if (state == Shell.AppState.STARTING) {
            this._startingApps.push(app);
        }
        // For now just resync on all running state changes; this is mainly to handle
        // cases where the focused window's application changes without the focus
        // changing.  An example case is how we map OpenOffice.org based on the window
        // title which is a dynamic property.
        this._sync();
    },
    _focusAppChanged: function() {
        let tracker = Shell.WindowTracker.get_default();
        let focusedApp = tracker.focus_app;
        if (!focusedApp) {
            // If the app has just lost focus to the panel, pretend
            // nothing happened; otherwise you can't keynav to the
            // app menu.
            if (global.stage.key_focus != null)
                return;
        }
        this._sync();
    },
    _findTargetApp: function() {
        let workspace = global.screen.get_active_workspace();
        let tracker = Shell.WindowTracker.get_default();
        let focusedApp = tracker.focus_app;
        if (focusedApp && focusedApp.is_on_workspace(workspace))
            return focusedApp;
        for (let i = 0; i < this._startingApps.length; i++)
            if (this._startingApps[i].is_on_workspace(workspace))
                return this._startingApps[i];
        return null;
    },
    _sync: function() {
        let targetApp = this._findTargetApp();
        if (this._targetApp != targetApp) {
            if (this._appMenuNotifyId) {
                this._targetApp.disconnect(this._appMenuNotifyId);
                this._appMenuNotifyId = 0;
            }
            if (this._actionGroupNotifyId) {
                this._targetApp.disconnect(this._actionGroupNotifyId);
                this._actionGroupNotifyId = 0;
            }
            if (this._busyNotifyId) {
                this._targetApp.disconnect(this._busyNotifyId);
                this._busyNotifyId = 0;
            }
            this._targetApp = targetApp;
            if (this._targetApp) {
                this._appMenuNotifyId = this._targetApp.connect('notify::menu', Lang.bind(this, this._sync));
                this._actionGroupNotifyId = this._targetApp.connect('notify::action-group', Lang.bind(this, this._sync));
                this._busyNotifyId = this._targetApp.connect('notify::busy', Lang.bind(this, this._sync));
                this._label.set_text(this._targetApp.get_name());
                this.actor.set_accessible_name(this._targetApp.get_name());
            }
        }
        let visible = (this._targetApp != null &&
                       this._gtkSettings.gtk_shell_shows_app_menu &&
                       !Main.overview.visibleTarget);
        if (visible)
            this.show();
        else
            this.hide();
        let isBusy = (this._targetApp != null &&
                      (this._targetApp.get_state() == Shell.AppState.STARTING ||
                       this._targetApp.get_busy()));
        if (isBusy)
            this.startAnimation();
        else
            this.stopAnimation();
        this.actor.reactive = (visible && !isBusy);
        this._syncIcon();
        this._maybeSetMenu();
        this.emit('changed');
    },
    _maybeSetMenu: function() {
        let menu;
        if (this._targetApp == null) {
            menu = null;
        } else if (this._targetApp.action_group && this._targetApp.menu) {
            if (this.menu instanceof RemoteMenu.RemoteMenu &&
                this.menu.actionGroup == this._targetApp.action_group)
                return;
            menu = new RemoteMenu.RemoteMenu(this.actor, this._targetApp.menu, this._targetApp.action_group);
            menu.connect('activate', Lang.bind(this, function() {
                let win = this._targetApp.get_windows()[0];
                win.check_alive(global.get_current_time());
            }));
        } else {
            if (this.menu && this.menu.isDummyQuitMenu)
                return;
            // fallback to older menu
            menu = new PopupMenu.PopupMenu(this.actor, 0.0, St.Side.TOP, 0);
            menu.isDummyQuitMenu = true;
            menu.addAction(_("Quit"), Lang.bind(this, function() {
                this._targetApp.request_quit();
            }));
        }
        this.setMenu(menu);
        if (menu)
            this._menuManager.addMenu(menu);
    },
    destroy: function() {
        if (this._appStateChangedSignalId > 0) {
            let appSys = Shell.AppSystem.get_default();
            appSys.disconnect(this._appStateChangedSignalId);
            this._appStateChangedSignalId = 0;
        }
        if (this._focusAppNotifyId > 0) {
            let tracker = Shell.WindowTracker.get_default();
            tracker.disconnect(this._focusAppNotifyId);
            this._focusAppNotifyId = 0;
        }
        if (this._overviewHidingId > 0) {
            Main.overview.disconnect(this._overviewHidingId);
            this._overviewHidingId = 0;
        }
        if (this._overviewShowingId > 0) {
            Main.overview.disconnect(this._overviewShowingId);
            this._overviewShowingId = 0;
        }
        if (this._showsAppMenuId > 0) {
            this._gtkSettings.disconnect(this._showsAppMenuId);
            this._showsAppMenuId = 0;
        }
        if (this._switchWorkspaceNotifyId > 0) {
            global.window_manager.disconnect(this._switchWorkspaceNotifyId);
            this._switchWorkspaceNotifyId = 0;
        }
        this.parent();
    }
Signals.addSignalMethods(AppMenuButton.prototype);
const ActivitiesButton = new Lang.Class({
    Name: 'ActivitiesButton',
    Extends: PanelMenu.Button,
    _init: function() {
        this.parent(0.0, null, true);
        this.actor.accessible_role = Atk.Role.TOGGLE_BUTTON;
        this.actor.name = 'panelActivities';
        /* Translators: If there is no suitable word for "Activities"
           in your language, you can use the word for "Overview". */
        this._label = new St.Label({ text: _("Activities"),
                                     y_align: Clutter.ActorAlign.CENTER });
        this.actor.add_actor(this._label);
        this.actor.label_actor = this._label;
        this.actor.connect('captured-event', Lang.bind(this, this._onCapturedEvent));
        this.actor.connect_after('key-release-event', Lang.bind(this, this._onKeyRelease));
        Main.overview.connect('showing', Lang.bind(this, function() {
            this.actor.add_style_pseudo_class('overview');
            this.actor.add_accessible_state (Atk.StateType.CHECKED);
        }));
        Main.overview.connect('hiding', Lang.bind(this, function() {
            this.actor.remove_style_pseudo_class('overview');
            this.actor.remove_accessible_state (Atk.StateType.CHECKED);
        }));
        this._xdndTimeOut = 0;
    },
    handleDragOver: function(source, actor, x, y, time) {
        if (source != Main.xdndHandler)
            return DND.DragMotionResult.CONTINUE;
        if (this._xdndTimeOut != 0)
            Mainloop.source_remove(this._xdndTimeOut);
        this._xdndTimeOut = Mainloop.timeout_add(BUTTON_DND_ACTIVATION_TIMEOUT,
                                                 Lang.bind(this, this._xdndToggleOverview, actor));
        GLib.Source.set_name_by_id(this._xdndTimeOut, '[gnome-shell] this._xdndToggleOverview');
        return DND.DragMotionResult.CONTINUE;
    },
    _onCapturedEvent: function(actor, event) {
        if (event.type() == Clutter.EventType.BUTTON_PRESS ||
            event.type() == Clutter.EventType.TOUCH_BEGIN) {
            if (!Main.overview.shouldToggleByCornerOrButton())
                return Clutter.EVENT_STOP;
        }
        return Clutter.EVENT_PROPAGATE;
    },
    _onEvent: function(actor, event) {
        this.parent(actor, event);
        if (event.type() == Clutter.EventType.TOUCH_END ||
            event.type() == Clutter.EventType.BUTTON_RELEASE)
            if (Main.overview.shouldToggleByCornerOrButton())
                Main.overview.toggle();
        return Clutter.EVENT_PROPAGATE;
    },
    _onKeyRelease: function(actor, event) {
        let symbol = event.get_key_symbol();
        if (symbol == Clutter.KEY_Return || symbol == Clutter.KEY_space) {
            if (Main.overview.shouldToggleByCornerOrButton())
                Main.overview.toggle();
        }
        return Clutter.EVENT_PROPAGATE;
    },
    _xdndToggleOverview: function(actor) {
        let [x, y, mask] = global.get_pointer();
        let pickedActor = global.stage.get_actor_at_pos(Clutter.PickMode.REACTIVE, x, y);
        if (pickedActor == this.actor && Main.overview.shouldToggleByCornerOrButton())
            Main.overview.toggle();
        Mainloop.source_remove(this._xdndTimeOut);
        this._xdndTimeOut = 0;
        return GLib.SOURCE_REMOVE;
    }
const PanelCorner = new Lang.Class({
    Name: 'PanelCorner',
    _init: function(side) {
        this._side = side;
        this.actor = new St.DrawingArea({ style_class: 'panel-corner' });
        this.actor.connect('style-changed', Lang.bind(this, this._styleChanged));
        this.actor.connect('repaint', Lang.bind(this, this._repaint));
    },
    _findRightmostButton: function(container) {
        if (!container.get_children)
            return null;
        let children = container.get_children();
        if (!children || children.length == 0)
            return null;
        // Start at the back and work backward
        let index;
        for (index = children.length - 1; index >= 0; index--) {
            if (children[index].visible)
                break;
        }
        if (index < 0)
            return null;
        if (!(children[index].has_style_class_name('panel-menu')) &&
            !(children[index].has_style_class_name('panel-button')))
            return this._findRightmostButton(children[index]);
        return children[index];
    },
    _findLeftmostButton: function(container) {
        if (!container.get_children)
            return null;
        let children = container.get_children();
        if (!children || children.length == 0)
            return null;
        // Start at the front and work forward
        let index;
        for (index = 0; index < children.length; index++) {
            if (children[index].visible)
                break;
        }
        if (index == children.length)
            return null;
        if (!(children[index].has_style_class_name('panel-menu')) &&
            !(children[index].has_style_class_name('panel-button')))
            return this._findLeftmostButton(children[index]);
        return children[index];
    },
    setStyleParent: function(box) {
        let side = this._side;
        let rtlAwareContainer = box instanceof St.BoxLayout;
        if (rtlAwareContainer &&
            box.get_text_direction() == Clutter.TextDirection.RTL) {
            if (this._side == St.Side.LEFT)
                side = St.Side.RIGHT;
            else if (this._side == St.Side.RIGHT)
                side = St.Side.LEFT;
        }
        let button;
        if (side == St.Side.LEFT)
            button = this._findLeftmostButton(box);
        else if (side == St.Side.RIGHT)
            button = this._findRightmostButton(box);
        if (button) {
            if (this._button && this._buttonStyleChangedSignalId) {
                this._button.disconnect(this._buttonStyleChangedSignalId);
                this._button.style = null;
            }
            this._button = button;
            button.connect('destroy', Lang.bind(this,
                function() {
                    if (this._button == button) {
                        this._button = null;
                        this._buttonStyleChangedSignalId = 0;
                    }
                }));
            // Synchronize the locate button's pseudo classes with this corner
            this._buttonStyleChangedSignalId = button.connect('style-changed', Lang.bind(this,
                function(actor) {
                    let pseudoClass = button.get_style_pseudo_class();
                    this.actor.set_style_pseudo_class(pseudoClass);
                }));
            // The corner doesn't support theme transitions, so override
            // the .panel-button default
            button.style = 'transition-duration: 0ms';
        }
    },
    _repaint: function() {
        let node = this.actor.get_theme_node();
        let cornerRadius = node.get_length("-panel-corner-radius");
        let borderWidth = node.get_length('-panel-corner-border-width');
        let backgroundColor = node.get_color('-panel-corner-background-color');
        let borderColor = node.get_color('-panel-corner-border-color');
        let overlap = borderColor.alpha != 0;
        let offsetY = overlap ? 0 : borderWidth;
        let cr = this.actor.get_context();
        cr.setOperator(Cairo.Operator.SOURCE);
        cr.moveTo(0, offsetY);
        if (this._side == St.Side.LEFT)
            cr.arc(cornerRadius,
                   borderWidth + cornerRadius,
                   cornerRadius, Math.PI, 3 * Math.PI / 2);
        else
            cr.arc(0,
                   borderWidth + cornerRadius,
                   cornerRadius, 3 * Math.PI / 2, 2 * Math.PI);
        cr.lineTo(cornerRadius, offsetY);
        cr.closePath();
        let savedPath = cr.copyPath();
        let xOffsetDirection = this._side == St.Side.LEFT ? -1 : 1;
        let over = _over(borderColor, backgroundColor);
        Clutter.cairo_set_source_color(cr, over);
        cr.fill();
        if (overlap) {
            let offset = borderWidth;
            Clutter.cairo_set_source_color(cr, backgroundColor);
            cr.save();
            cr.translate(xOffsetDirection * offset, - offset);
            cr.appendPath(savedPath);
            cr.fill();
            cr.restore();
        }
        cr.$dispose();
    },
    _styleChanged: function() {
        let node = this.actor.get_theme_node();
        let cornerRadius = node.get_length("-panel-corner-radius");
        let borderWidth = node.get_length('-panel-corner-border-width');
        this.actor.set_size(cornerRadius, borderWidth + cornerRadius);
        this.actor.set_anchor_point(0, borderWidth);
    }
const AggregateLayout = new Lang.Class({
    Name: 'AggregateLayout',
    Extends: Clutter.BoxLayout,
    _init: function(params) {
        if (!params)
            params = {};
        params['orientation'] = Clutter.Orientation.VERTICAL;
        this.parent(params);
        this._sizeChildren = [];
    },
    addSizeChild: function(actor) {
        this._sizeChildren.push(actor);
        this.layout_changed();
    },
    vfunc_get_preferred_width: function(container, forHeight) {
        let themeNode = container.get_theme_node();
        let minWidth = themeNode.get_min_width();
        let natWidth = minWidth;
        for (let i = 0; i < this._sizeChildren.length; i++) {
            let child = this._sizeChildren[i];
            let [childMin, childNat] = child.get_preferred_width(forHeight);
            minWidth = Math.max(minWidth, childMin);
            natWidth = Math.max(minWidth, childNat);
        }
        return [minWidth, natWidth];
    }
const AggregateMenu = new Lang.Class({
    Name: 'AggregateMenu',
    Extends: PanelMenu.Button,
    _init: function() {
        this.parent(0.0, C_("System menu in the top bar", "System"), false);
        this.menu.actor.add_style_class_name('aggregate-menu');
        let menuLayout = new AggregateLayout();
        this.menu.box.set_layout_manager(menuLayout);
        this._indicators = new St.BoxLayout({ style_class: 'panel-status-indicators-box' });
        this.actor.add_child(this._indicators);
        if (Config.HAVE_NETWORKMANAGER) {
            this._network = new imports.ui.status.network.NMApplet();
        } else {
            this._network = null;
        }
        if (Config.HAVE_BLUETOOTH) {
            this._bluetooth = new imports.ui.status.bluetooth.Indicator();
        } else {
            this._bluetooth = null;
        }
        this._power = new imports.ui.status.power.Indicator();
        this._rfkill = new imports.ui.status.rfkill.Indicator();
        this._volume = new imports.ui.status.volume.Indicator();
        this._brightness = new imports.ui.status.brightness.Indicator();
        this._system = new imports.ui.status.system.Indicator();
        this._screencast = new imports.ui.status.screencast.Indicator();
        this._location = new imports.ui.status.location.Indicator();
        this._indicators.add_child(this._screencast.indicators);
        this._indicators.add_child(this._location.indicators);
        if (this._network) {
            this._indicators.add_child(this._network.indicators);
        }
        if (this._bluetooth) {
            this._indicators.add_child(this._bluetooth.indicators);
        }
        this._indicators.add_child(this._rfkill.indicators);
        this._indicators.add_child(this._volume.indicators);
        this._indicators.add_child(this._power.indicators);
        this._indicators.add_child(PopupMenu.arrowIcon(St.Side.BOTTOM));
        this.menu.addMenuItem(this._volume.menu);
        this.menu.addMenuItem(this._brightness.menu);
        this.menu.addMenuItem(new PopupMenu.PopupSeparatorMenuItem());
        if (this._network) {
            this.menu.addMenuItem(this._network.menu);
        }
        if (this._bluetooth) {
            this.menu.addMenuItem(this._bluetooth.menu);
        }
        this.menu.addMenuItem(this._location.menu);
        this.menu.addMenuItem(this._rfkill.menu);
        this.menu.addMenuItem(this._power.menu);
        this.menu.addMenuItem(this._system.menu);
        menuLayout.addSizeChild(this._location.menu.actor);
        menuLayout.addSizeChild(this._rfkill.menu.actor);
        menuLayout.addSizeChild(this._power.menu.actor);
        menuLayout.addSizeChild(this._system.menu.actor);
    },
const PANEL_ITEM_IMPLEMENTATIONS = {
    'activities': ActivitiesButton,
    'aggregateMenu': AggregateMenu,
    'appMenu': AppMenuButton,
    'dateMenu': imports.ui.dateMenu.DateMenuButton,
    'a11y': imports.ui.status.accessibility.ATIndicator,
    'a11yGreeter': imports.ui.status.accessibility.ATGreeterIndicator,
    'keyboard': imports.ui.status.keyboard.InputSourceIndicator,
const Panel = new Lang.Class({
    Name: 'Panel',
    _init : function() {
        this.actor = new Shell.GenericContainer({ name: 'panel',
                                                  reactive: true });
        this.actor._delegate = this;
        this._sessionStyle = null;
        this.statusArea = {};
        this.menuManager = new PopupMenu.PopupMenuManager(this);
        this._leftBox = new St.BoxLayout({ name: 'panelLeft' });
        this.actor.add_actor(this._leftBox);
        this._centerBox = new St.BoxLayout({ name: 'panelCenter' });
        this.actor.add_actor(this._centerBox);
        this._rightBox = new St.BoxLayout({ name: 'panelRight' });
        this.actor.add_actor(this._rightBox);
        this._leftCorner = new PanelCorner(St.Side.LEFT);
        this.actor.add_actor(this._leftCorner.actor);
        this._rightCorner = new PanelCorner(St.Side.RIGHT);
        this.actor.add_actor(this._rightCorner.actor);
        this.actor.connect('get-preferred-width', Lang.bind(this, this._getPreferredWidth));
        this.actor.connect('get-preferred-height', Lang.bind(this, this._getPreferredHeight));
        this.actor.connect('allocate', Lang.bind(this, this._allocate));
        this.actor.connect('button-press-event', Lang.bind(this, this._onButtonPress));
        Main.overview.connect('showing', Lang.bind(this, function () {
            this.actor.add_style_pseudo_class('overview');
        }));
        Main.overview.connect('hiding', Lang.bind(this, function () {
            this.actor.remove_style_pseudo_class('overview');
        }));
        Main.layoutManager.panelBox.add(this.actor);
        Main.ctrlAltTabManager.addGroup(this.actor, _("Top Bar"), 'focus-top-bar-symbolic',
                                        { sortGroup: CtrlAltTab.SortGroup.TOP });
        Main.sessionMode.connect('updated', Lang.bind(this, this._updatePanel));
        this._updatePanel();
    },
    _getPreferredWidth: function(actor, forHeight, alloc) {
        alloc.min_size = -1;
        alloc.natural_size = Main.layoutManager.primaryMonitor.width;
    },
    _getPreferredHeight: function(actor, forWidth, alloc) {
        // We don't need to implement this; it's forced by the CSS
        alloc.min_size = -1;
        alloc.natural_size = -1;
    },
    _allocate: function(actor, box, flags) {
        let allocWidth = box.x2 - box.x1;
        let allocHeight = box.y2 - box.y1;
        let [leftMinWidth, leftNaturalWidth] = this._leftBox.get_preferred_width(-1);
        let [centerMinWidth, centerNaturalWidth] = this._centerBox.get_preferred_width(-1);
        let [rightMinWidth, rightNaturalWidth] = this._rightBox.get_preferred_width(-1);
        let sideWidth, centerWidth;
        centerWidth = centerNaturalWidth;
        sideWidth = (allocWidth - centerWidth) / 2;
        let childBox = new Clutter.ActorBox();
        childBox.y1 = 0;
        childBox.y2 = allocHeight;
        if (this.actor.get_text_direction() == Clutter.TextDirection.RTL) {
            childBox.x1 = allocWidth - Math.min(Math.floor(sideWidth),
                                                leftNaturalWidth);
            childBox.x2 = allocWidth;
        } else {
            childBox.x1 = 0;
            childBox.x2 = Math.min(Math.floor(sideWidth),
                                   leftNaturalWidth);
        }
        this._leftBox.allocate(childBox, flags);
        childBox.x1 = Math.ceil(sideWidth);
        childBox.y1 = 0;
        childBox.x2 = childBox.x1 + centerWidth;
        childBox.y2 = allocHeight;
        this._centerBox.allocate(childBox, flags);
        childBox.y1 = 0;
        childBox.y2 = allocHeight;
        if (this.actor.get_text_direction() == Clutter.TextDirection.RTL) {
            childBox.x1 = 0;
            childBox.x2 = Math.min(Math.floor(sideWidth),
                                   rightNaturalWidth);
        } else {
            childBox.x1 = allocWidth - Math.min(Math.floor(sideWidth),
                                                rightNaturalWidth);
            childBox.x2 = allocWidth;
        }
        this._rightBox.allocate(childBox, flags);
        let cornerMinWidth, cornerMinHeight;
        let cornerWidth, cornerHeight;
        [cornerMinWidth, cornerWidth] = this._leftCorner.actor.get_preferred_width(-1);
        [cornerMinHeight, cornerHeight] = this._leftCorner.actor.get_preferred_height(-1);
        childBox.x1 = 0;
        childBox.x2 = cornerWidth;
        childBox.y1 = allocHeight;
        childBox.y2 = allocHeight + cornerHeight;
        this._leftCorner.actor.allocate(childBox, flags);
        [cornerMinWidth, cornerWidth] = this._rightCorner.actor.get_preferred_width(-1);
        [cornerMinHeight, cornerHeight] = this._rightCorner.actor.get_preferred_height(-1);
        childBox.x1 = allocWidth - cornerWidth;
        childBox.x2 = allocWidth;
        childBox.y1 = allocHeight;
        childBox.y2 = allocHeight + cornerHeight;
        this._rightCorner.actor.allocate(childBox, flags);
    },
    _onButtonPress: function(actor, event) {
        if (Main.modalCount > 0)
            return Clutter.EVENT_PROPAGATE;
        if (event.get_source() != actor)
            return Clutter.EVENT_PROPAGATE;
        let button = event.get_button();
        if (button != 1)
            return Clutter.EVENT_PROPAGATE;
        let focusWindow = global.display.focus_window;
        if (!focusWindow)
            return Clutter.EVENT_PROPAGATE;
        let dragWindow = focusWindow.is_attached_dialog() ? focusWindow.get_transient_for()
                                                          : focusWindow;
        if (!dragWindow)
            return Clutter.EVENT_PROPAGATE;
        let rect = dragWindow.get_frame_rect();
        let [stageX, stageY] = event.get_coords();
        let allowDrag = dragWindow.maximized_vertically &&
                        stageX > rect.x && stageX < rect.x + rect.width;
        if (!allowDrag)
            return Clutter.EVENT_PROPAGATE;
        global.display.begin_grab_op(global.screen,
                                     dragWindow,
                                     Meta.GrabOp.MOVING,
                                     false, /* pointer grab */
                                     true, /* frame action */
                                     button,
                                     event.get_state(),
                                     event.get_time(),
                                     stageX, stageY);
        return Clutter.EVENT_STOP;
    },
    _toggleMenu: function(indicator) {
        if (!indicator) // menu not supported by current session mode
            return;
        let menu = indicator.menu;
        if (!indicator.actor.reactive)
            return;
        menu.toggle();
        if (menu.isOpen)
            menu.actor.navigate_focus(null, Gtk.DirectionType.TAB_FORWARD, false);
    },
    toggleAppMenu: function() {
        this._toggleMenu(this.statusArea.appMenu);
    },
    toggleCalendar: function() {
        this._toggleMenu(this.statusArea.dateMenu);
    },
    closeCalendar: function() {
        let indicator = this.statusArea.dateMenu;
        if (!indicator) // calendar not supported by current session mode
            return;
        let menu = indicator.menu;
        if (!indicator.actor.reactive)
            return;
        menu.close();
    },
    set boxOpacity(value) {
        let isReactive = value > 0;
        this._leftBox.opacity = value;
        this._leftBox.reactive = isReactive;
        this._centerBox.opacity = value;
        this._centerBox.reactive = isReactive;
        this._rightBox.opacity = value;
        this._rightBox.reactive = isReactive;
    },
    get boxOpacity() {
        return this._leftBox.opacity;
    },
    _updatePanel: function() {
        let panel = Main.sessionMode.panel;
        this._hideIndicators();
        this._updateBox(panel.left, this._leftBox);
        this._updateBox(panel.center, this._centerBox);
        this._updateBox(panel.right, this._rightBox);
        if (panel.left.indexOf('dateMenu') != -1)
            Main.messageTray.bannerAlignment = Clutter.ActorAlign.START;
        else if (panel.right.indexOf('dateMenu') != -1)
            Main.messageTray.bannerAlignment = Clutter.ActorAlign.END;
        // Default to center if there is no dateMenu
        else
            Main.messageTray.bannerAlignment = Clutter.ActorAlign.CENTER;
        if (this._sessionStyle)
            this._removeStyleClassName(this._sessionStyle);
        this._sessionStyle = Main.sessionMode.panelStyle;
        if (this._sessionStyle)
            this._addStyleClassName(this._sessionStyle);
        if (this.actor.get_text_direction() == Clutter.TextDirection.RTL) {
            this._leftCorner.setStyleParent(this._rightBox);
            this._rightCorner.setStyleParent(this._leftBox);
        } else {
            this._leftCorner.setStyleParent(this._leftBox);
            this._rightCorner.setStyleParent(this._rightBox);
        }
    },
    _hideIndicators: function() {
        for (let role in PANEL_ITEM_IMPLEMENTATIONS) {
            let indicator = this.statusArea[role];
            if (!indicator)
                continue;
            if (indicator.menu)
                indicator.menu.close();
            indicator.container.hide();
        }
    },
    _ensureIndicator: function(role) {
        let indicator = this.statusArea[role];
        if (!indicator) {
            let constructor = PANEL_ITEM_IMPLEMENTATIONS[role];
            if (!constructor) {
                // This icon is not implemented (this is a bug)
                return null;
            }
            indicator = new constructor(this);
            this.statusArea[role] = indicator;
        }
        return indicator;
    },
    _updateBox: function(elements, box) {
        let nChildren = box.get_n_children();
        for (let i = 0; i < elements.length; i++) {
            let role = elements[i];
            let indicator = this._ensureIndicator(role);
            if (indicator == null)
                continue;
            this._addToPanelBox(role, indicator, i + nChildren, box);
        }
    },
    _addToPanelBox: function(role, indicator, position, box) {
        let container = indicator.container;
        container.show();
        let parent = container.get_parent();
        if (parent)
            parent.remove_actor(container);
        box.insert_child_at_index(container, position);
        if (indicator.menu)
            this.menuManager.addMenu(indicator.menu);
        this.statusArea[role] = indicator;
        let destroyId = indicator.connect('destroy', Lang.bind(this, function(emitter) {
            delete this.statusArea[role];
            emitter.disconnect(destroyId);
            container.destroy();
        }));
        indicator.connect('menu-set', Lang.bind(this, this._onMenuSet));
        this._onMenuSet(indicator);
    },
    addToStatusArea: function(role, indicator, position, box) {
        if (this.statusArea[role])
            throw new Error('Extension point conflict: there is already a status indicator for role ' + role);
        if (!(indicator instanceof PanelMenu.Button))
            throw new TypeError('Status indicator must be an instance of PanelMenu.Button');
        position = position || 0;
        let boxes = {
            left: this._leftBox,
            center: this._centerBox,
            right: this._rightBox
        };
        let boxContainer = boxes[box] || this._rightBox;
        this.statusArea[role] = indicator;
        this._addToPanelBox(role, indicator, position, boxContainer);
        return indicator;
    },
    _addStyleClassName: function(className) {
        this.actor.add_style_class_name(className);
        this._rightCorner.actor.add_style_class_name(className);
        this._leftCorner.actor.add_style_class_name(className);
    },
    _removeStyleClassName: function(className) {
        this.actor.remove_style_class_name(className);
        this._rightCorner.actor.remove_style_class_name(className);
        this._leftCorner.actor.remove_style_class_name(className);
    },
    _onMenuSet: function(indicator) {
        if (!indicator.menu || indicator.menu._openChangedId > 0)
            return;
        indicator.menu._openChangedId = indicator.menu.connect('open-state-changed',
            Lang.bind(this, function(menu, isOpen) {
                let boxAlignment;
                if (this._leftBox.contains(indicator.container))
                    boxAlignment = Clutter.ActorAlign.START;
                else if (this._centerBox.contains(indicator.container))
                    boxAlignment = Clutter.ActorAlign.CENTER;
                else if (this._rightBox.contains(indicator.container))
                    boxAlignment = Clutter.ActorAlign.END;
                if (boxAlignment == Main.messageTray.bannerAlignment)
                    Main.messageTray.bannerBlocked = isOpen;
            }));
    }
(uuay)util.js
// -*- mode: js; js-indent-level: 4; indent-tabs-mode: nil -*-
const Clutter = imports.gi.Clutter;
const Gio = imports.gi.Gio;
const GLib = imports.gi.GLib;
const Lang = imports.lang;
const Shell = imports.gi.Shell;
const St = imports.gi.St;
const Main = imports.ui.main;
const Tweener = imports.ui.tweener;
const Params = imports.misc.params;
const SCROLL_TIME = 0.1;
// http://daringfireball.net/2010/07/improved_regex_for_matching_urls
const _balancedParens = '\\((?:[^\\s()<>]+|(?:\\(?:[^\\s()<>]+\\)))*\\)';
const _leadingJunk = '[\\s`(\\[{\'\\"<\u00AB\u201C\u2018]';
const _notTrailingJunk = '[^\\s`!()\\[\\]{};:\'\\".,<>?\u00AB\u00BB\u201C\u201D\u2018\u2019]';
const _urlRegexp = new RegExp(
    '(^|' + _leadingJunk + ')' +
    '(' +
        '(?:' +
            '(?:http|https|ftp)://' +             // scheme://
            '|' +
            'www\\d{0,3}[.]' +                    // www.
            '|' +
            '[a-z0-9.\\-]+[.][a-z]{2,4}/' +       // foo.xx/
        ')' +
        '(?:' +                                   // one or more:
            '[^\\s()<>]+' +                       // run of non-space non-()
            '|' +                                 // or
            _balancedParens +                     // balanced parens
        ')+' +
        '(?:' +                                   // end with:
            _balancedParens +                     // balanced parens
            '|' +                                 // or
            _notTrailingJunk +                    // last non-junk char
        ')' +
    ')', 'gi');
let _desktopSettings = null;
// findUrls:
// @str: string to find URLs in
// Searches @str for URLs and returns an array of objects with %url
// properties showing the matched URL string, and %pos properties indicating
// the position within @str where the URL was found.
// Return value: the list of match objects, as described above
function findUrls(str) {
    let res = [], match;
    while ((match = _urlRegexp.exec(str)))
        res.push({ url: match[2], pos: match.index + match[1].length });
    return res;
// spawn:
// @argv: an argv array
// Runs @argv in the background, handling any errors that occur
// when trying to start the program.
function spawn(argv) {
    try {
        trySpawn(argv);
    } catch (err) {
        _handleSpawnError(argv[0], err);
    }
// spawnCommandLine:
// @command_line: a command line
// Runs @command_line in the background, handling any errors that
// occur when trying to parse or start the program.
function spawnCommandLine(command_line) {
    try {
        let [success, argv] = GLib.shell_parse_argv(command_line);
        trySpawn(argv);
    } catch (err) {
        _handleSpawnError(command_line, err);
    }
// spawnApp:
// @argv: an argv array
// Runs @argv as if it was an application, handling startup notification
function spawnApp(argv) {
    try {
        let app = Gio.AppInfo.create_from_commandline(argv.join(' '), null,
                                                      Gio.AppInfoCreateFlags.SUPPORTS_STARTUP_NOTIFICATION);
        let context = global.create_app_launch_context(0, -1);
        app.launch([], context);
    } catch(err) {
        _handleSpawnError(argv[0], err);
    }
// trySpawn:
// @argv: an argv array
// Runs @argv in the background. If launching @argv fails,
// this will throw an error.
function trySpawn(argv)
    var success, pid;
    try {
        [success, pid] = GLib.spawn_async(null, argv, null,
                                          GLib.SpawnFlags.SEARCH_PATH | GLib.SpawnFlags.DO_NOT_REAP_CHILD,
                                          null);
    } catch (err) {
        /* Rewrite the error in case of ENOENT */
        if (err.matches(GLib.SpawnError, GLib.SpawnError.NOENT)) {
            throw new GLib.SpawnError({ code: GLib.SpawnError.NOENT,
                                        message: _("Command not found") });
        } else if (err instanceof GLib.Error) {
            // The exception from gjs contains an error string like:
            //   Error invoking GLib.spawn_command_line_async: Failed to
            //   execute child process "foo" (No such file or directory)
            // We are only interested in the part in the parentheses. (And
            // we can't pattern match the text, since it gets localized.)
            let message = err.message.replace(/.*\((.+)\)/, '$1');
            throw new (err.constructor)({ code: err.code,
                                          message: message });
        } else {
            throw err;
        }
    }
    // Dummy child watch; we don't want to double-fork internally
    // because then we lose the parent-child relationship, which
    // can break polkit.  See https://bugzilla.redhat.com//show_bug.cgi?id=819275
    GLib.child_watch_add(GLib.PRIORITY_DEFAULT, pid, function () {});
// trySpawnCommandLine:
// @command_line: a command line
// Runs @command_line in the background. If launching @command_line
// fails, this will throw an error.
function trySpawnCommandLine(command_line) {
    let success, argv;
    try {
        [success, argv] = GLib.shell_parse_argv(command_line);
    } catch (err) {
        // Replace "Error invoking GLib.shell_parse_argv: " with
        // something nicer
        err.message = err.message.replace(/[^:]*: /, _("Could not parse command:") + "\n");
        throw err;
    }
    trySpawn(argv);
function _handleSpawnError(command, err) {
    let title = _("Execution of 
 failed:").format(command);
    Main.notifyError(title, err.message);
function formatTime(time, params) {
    let date;
    // HACK: The built-in Date type sucks at timezones, which we need for the
    //       world clock; it's often more convenient though, so allow either
    //       Date or GLib.DateTime as parameter
    if (time instanceof Date)
        date = GLib.DateTime.new_from_unix_local(time.getTime() / 1000);
    else
        date = time;
    let now = GLib.DateTime.new_now_local();
    let daysAgo = now.difference(date) / (24 * 60 * 60 * 1000 * 1000);
    let format;
    if (_desktopSettings == null)
        _desktopSettings = new Gio.Settings({ schema_id: 'org.gnome.desktop.interface' });
    let clockFormat = _desktopSettings.get_string('clock-format');
    let hasAmPm = date.format('%p') != '';
    params = Params.parse(params, { timeOnly: false });
    if (clockFormat == '24h' || !hasAmPm) {
        // Show only the time if date is on today
        if (daysAgo < 1 || params.timeOnly)
            /* Translators: Time in 24h format */
            format = N_("%H\u2236%M");
        // Show the word "Yesterday" and time if date is on yesterday
        else if (daysAgo <2)
            /* Translators: this is the word "Yesterday" followed by a
             time string in 24h format. i.e. "Yesterday, 14:30" */
            // xgettext:no-c-format
            format = N_("Yesterday, %H\u2236%M");
        // Show a week day and time if date is in the last week
        else if (daysAgo < 7)
            /* Translators: this is the week day name followed by a time
             string in 24h format. i.e. "Monday, 14:30" */
            // xgettext:no-c-format
            format = N_("%A, %H\u2236%M");
        else if (date.get_year() == now.get_year())
            /* Translators: this is the month name and day number
             followed by a time string in 24h format.
             i.e. "May 25, 14:30" */
            // xgettext:no-c-format
            format = N_("%B %d, %H\u2236%M");
        else
            /* Translators: this is the month name, day number, year
             number followed by a time string in 24h format.
             i.e. "May 25 2012, 14:30" */
            // xgettext:no-c-format
            format = N_("%B %d %Y, %H\u2236%M");
    } else {
        // Show only the time if date is on today
        if (daysAgo < 1 || params.timeOnly)
            /* Translators: Time in 12h format */
            format = N_("%l\u2236%M %p");
        // Show the word "Yesterday" and time if date is on yesterday
        else if (daysAgo <2)
            /* Translators: this is the word "Yesterday" followed by a
             time string in 12h format. i.e. "Yesterday, 2:30 pm" */
            // xgettext:no-c-format
            format = N_("Yesterday, %l\u2236%M %p");
        // Show a week day and time if date is in the last week
        else if (daysAgo < 7)
            /* Translators: this is the week day name followed by a time
             string in 12h format. i.e. "Monday, 2:30 pm" */
            // xgettext:no-c-format
            format = N_("%A, %l\u2236%M %p");
        else if (date.get_year() == now.get_year())
            /* Translators: this is the month name and day number
             followed by a time string in 12h format.
             i.e. "May 25, 2:30 pm" */
            // xgettext:no-c-format
            format = N_("%B %d, %l\u2236%M %p");
        else
            /* Translators: this is the month name, day number, year
             number followed by a time string in 12h format.
             i.e. "May 25 2012, 2:30 pm"*/
            // xgettext:no-c-format
            format = N_("%B %d %Y, %l\u2236%M %p");
    }
    return date.format(Shell.util_translate_time_string(format));
function createTimeLabel(date, params) {
    if (_desktopSettings == null)
        _desktopSettings = new Gio.Settings({ schema_id: 'org.gnome.desktop.interface' });
    let label = new St.Label({ text: formatTime(date, params) });
    let id = _desktopSettings.connect('changed::clock-format', function() {
        label.text = formatTime(date, params);
    });
    label.connect('destroy', function() {
        _desktopSettings.disconnect(id);
    });
    return label;
// lowerBound:
// @array: an array or array-like object, already sorted
//         according to @cmp
// @val: the value to add
// @cmp: a comparator (or undefined to compare as numbers)
// Returns the position of the first element that is not
// lower than @val, according to @cmp.
// That is, returns the first position at which it
// is possible to insert @val without violating the
// order.
// This is quite like an ordinary binary search, except
// that it doesn't stop at first element comparing equal.
function lowerBound(array, val, cmp) {
    let min, max, mid, v;
    cmp = cmp || function(a, b) { return a - b; };
    if (array.length == 0)
        return 0;
    min = 0; max = array.length;
    while (min < (max - 1)) {
        mid = Math.floor((min + max) / 2);
        v = cmp(array[mid], val);
        if (v < 0)
            min = mid + 1;
        else
            max = mid;
    }
    return (min == max || cmp(array[min], val) < 0) ? max : min;
// insertSorted:
// @array: an array sorted according to @cmp
// @val: a value to insert
// @cmp: the sorting function
// Inserts @val into @array, preserving the
// sorting invariants.
// Returns the position at which it was inserted
function insertSorted(array, val, cmp) {
    let pos = lowerBound(array, val, cmp);
    array.splice(pos, 0, val);
    return pos;
const CloseButton = new Lang.Class({
    Name: 'CloseButton',
    Extends: St.Button,
    _init: function(boxpointer) {
        this.parent({ style_class: 'notification-close'});
        // This is a bit tricky. St.Bin has its own x-align/y-align properties
        // that compete with Clutter's properties. This should be fixed for
        // Clutter 2.0. Since St.Bin doesn't define its own setters, the
        // setters are a workaround to get Clutter's version.
        this.set_x_align(Clutter.ActorAlign.END);
        this.set_y_align(Clutter.ActorAlign.START);
        // XXX Clutter 2.0 workaround: ClutterBinLayout needs expand
        // to respect the alignments.
        this.set_x_expand(true);
        this.set_y_expand(true);
        this._boxPointer = boxpointer;
        if (boxpointer)
            this._boxPointer.connect('arrow-side-changed', Lang.bind(this, this._sync));
    },
    _computeBoxPointerOffset: function() {
        if (!this._boxPointer || !this._boxPointer.actor.get_stage())
            return 0;
        let side = this._boxPointer.arrowSide;
        if (side == St.Side.TOP)
            return this._boxPointer.getArrowHeight();
        else
            return 0;
    },
    _sync: function() {
        let themeNode = this.get_theme_node();
        let offY = this._computeBoxPointerOffset();
        this.translation_x = themeNode.get_length('-shell-close-overlap-x')
        this.translation_y = themeNode.get_length('-shell-close-overlap-y') + offY;
    },
    vfunc_style_changed: function() {
        this._sync();
        this.parent();
    },
function makeCloseButton(boxpointer) {
    return new CloseButton(boxpointer);
function ensureActorVisibleInScrollView(scrollView, actor) {
    let adjustment = scrollView.vscroll.adjustment;
    let [value, lower, upper, stepIncrement, pageIncrement, pageSize] = adjustment.get_values();
    let offset = 0;
    let vfade = scrollView.get_effect("fade");
    if (vfade)
        offset = vfade.vfade_offset;
    let box = actor.get_allocation_box();
    let y1 = box.y1, y2 = box.y2;
    let parent = actor.get_parent();
    while (parent != scrollView) {
        if (!parent)
            throw new Error("actor not in scroll view");
        let box = parent.get_allocation_box();
        y1 += box.y1;
        y2 += box.y1;
        parent = parent.get_parent();
    }
    if (y1 < value + offset)
        value = Math.max(0, y1 - offset);
    else if (y2 > value + pageSize - offset)
        value = Math.min(upper, y2 + offset - pageSize);
    else
        return;
    Tweener.addTween(adjustment,
                     { value: value,
                       time: SCROLL_TIME,
                       transition: 'easeOutQuad' });
(uuay)remoteMenu.js
// -*- mode: js; js-indent-level: 4; indent-tabs-mode: nil -*-
const Atk = imports.gi.Atk;
const GLib = imports.gi.GLib;
const GObject = imports.gi.GObject;
const Gio = imports.gi.Gio;
const Lang = imports.lang;
const Shell = imports.gi.Shell;
const ShellMenu = imports.gi.ShellMenu;
const St = imports.gi.St;
const PopupMenu = imports.ui.popupMenu;
function stripMnemonics(label) {
    if (!label)
        return '';
    // remove all underscores that are not followed by another underscore
    return label.replace(/_([^_])/, '$1');
function _insertItem(menu, trackerItem, position) {
    let mapper;
    if (trackerItem.get_is_separator())
        mapper = new RemoteMenuSeparatorItemMapper(trackerItem);
    else if (trackerItem.get_has_submenu())
        mapper = new RemoteMenuSubmenuItemMapper(trackerItem);
    else
        mapper = new RemoteMenuItemMapper(trackerItem);
    let item = mapper.menuItem;
    menu.addMenuItem(item, position);
function _removeItem(menu, position) {
    let items = menu._getMenuItems();
    items[position].destroy();
const RemoteMenuSeparatorItemMapper = new Lang.Class({
    Name: 'RemoteMenuSeparatorItemMapper',
    _init: function(trackerItem) {
        this._trackerItem = trackerItem;
        this.menuItem = new PopupMenu.PopupSeparatorMenuItem();
        this._trackerItem.connect('notify::label', Lang.bind(this, this._updateLabel));
        this._updateLabel();
        this.menuItem.connect('destroy', function() {
            trackerItem.run_dispose();
        });
    },
    _updateLabel: function() {
        this.menuItem.label.text = stripMnemonics(this._trackerItem.label);
    },
const RequestSubMenu = new Lang.Class({
    Name: 'RequestSubMenu',
    Extends: PopupMenu.PopupSubMenuMenuItem,
    _init: function() {
        this.parent('');
        this._requestOpen = false;
    },
    _setOpenState: function(open) {
        this.emit('request-open', open);
        this._requestOpen = open;
    },
    _getOpenState: function() {
        return this._requestOpen;
    },
const RemoteMenuSubmenuItemMapper = new Lang.Class({
    Name: 'RemoteMenuSubmenuItemMapper',
    _init: function(trackerItem) {
        this._trackerItem = trackerItem;
        this.menuItem = new RequestSubMenu();
        this._trackerItem.connect('notify::label', Lang.bind(this, this._updateLabel));
        this._updateLabel();
        this._tracker = Shell.MenuTracker.new_for_item_submenu(this._trackerItem,
                                                               _insertItem.bind(null, this.menuItem.menu),
                                                               _removeItem.bind(null, this.menuItem.menu));
        this.menuItem.connect('request-open', Lang.bind(this, function(menu, open) {
            this._trackerItem.request_submenu_shown(open);
        }));
        this._trackerItem.connect('notify::submenu-shown', Lang.bind(this, function() {
            this.menuItem.setSubmenuShown(this._trackerItem.get_submenu_shown());
        }));
        this.menuItem.connect('destroy', function() {
            trackerItem.run_dispose();
        });
    },
    destroy: function() {
        this._tracker.destroy();
        this.parent();
    },
    _updateLabel: function() {
        this.menuItem.label.text = stripMnemonics(this._trackerItem.label);
    },
const RemoteMenuItemMapper = new Lang.Class({
    Name: 'RemoteMenuItemMapper',
    _init: function(trackerItem) {
        this._trackerItem = trackerItem;
        this.menuItem = new PopupMenu.PopupBaseMenuItem();
        this._label = new St.Label();
        this.menuItem.actor.add_child(this._label);
        this.menuItem.actor.label_actor = this._label;
        this.menuItem.connect('activate', Lang.bind(this, function() {
            this._trackerItem.activated();
        }));
        this._trackerItem.bind_property('visible', this.menuItem.actor, 'visible', GObject.BindingFlags.SYNC_CREATE);
        this._trackerItem.connect('notify::label', Lang.bind(this, this._updateLabel));
        this._trackerItem.connect('notify::sensitive', Lang.bind(this, this._updateSensitivity));
        this._trackerItem.connect('notify::role', Lang.bind(this, this._updateRole));
        this._trackerItem.connect('notify::toggled', Lang.bind(this, this._updateDecoration));
        this._updateLabel();
        this._updateSensitivity();
        this._updateRole();
        this.menuItem.connect('destroy', function() {
            trackerItem.run_dispose();
        });
    },
    _updateLabel: function() {
        this._label.text = stripMnemonics(this._trackerItem.label);
    },
    _updateSensitivity: function() {
        this.menuItem.setSensitive(this._trackerItem.sensitive);
    },
    _updateDecoration: function() {
        let ornamentForRole = {};
        ornamentForRole[ShellMenu.MenuTrackerItemRole.RADIO] = PopupMenu.Ornament.DOT;
        ornamentForRole[ShellMenu.MenuTrackerItemRole.CHECK] = PopupMenu.Ornament.CHECK;
        let ornament = PopupMenu.Ornament.NONE;
        if (this._trackerItem.toggled)
            ornament = ornamentForRole[this._trackerItem.role];
        this.menuItem.setOrnament(ornament);
    },
    _updateRole: function() {
        let a11yRoles = {};
        a11yRoles[ShellMenu.MenuTrackerItemRole.NORMAL] = Atk.Role.MENU_ITEM;
        a11yRoles[ShellMenu.MenuTrackerItemRole.RADIO] = Atk.Role.RADIO_MENU_ITEM;
        a11yRoles[ShellMenu.MenuTrackerItemRole.CHECK] = Atk.Role.CHECK_MENU_ITEM;
        let a11yRole = a11yRoles[this._trackerItem.role];
        this.menuItem.actor.accessible_role = a11yRole;
        this._updateDecoration();
    },
const RemoteMenu = new Lang.Class({
    Name: 'RemoteMenu',
    Extends: PopupMenu.PopupMenu,
    _init: function(sourceActor, model, actionGroup) {
        this.parent(sourceActor, 0.0, St.Side.TOP);
        this._model = model;
        this._actionGroup = actionGroup;
        this._tracker = Shell.MenuTracker.new(this._actionGroup,
                                              this._model,
                                              null, /* action namespace */
                                              _insertItem.bind(null, this),
                                              _removeItem.bind(null, this));
    },
    destroy: function() {
        this._tracker.destroy();
        this.parent();
    },
(uuay)appDisplay.js
// -*- mode: js; js-indent-level: 4; indent-tabs-mode: nil -*-
const Clutter = imports.gi.Clutter;
const Gio = imports.gi.Gio;
const GLib = imports.gi.GLib;
const GObject = imports.gi.GObject;
const Gtk = imports.gi.Gtk;
const Shell = imports.gi.Shell;
const Lang = imports.lang;
const Signals = imports.signals;
const Meta = imports.gi.Meta;
const St = imports.gi.St;
const Mainloop = imports.mainloop;
const Atk = imports.gi.Atk;
const AppFavorites = imports.ui.appFavorites;
const BoxPointer = imports.ui.boxpointer;
const DND = imports.ui.dnd;
const GrabHelper = imports.ui.grabHelper;
const IconGrid = imports.ui.iconGrid;
const Main = imports.ui.main;
const Overview = imports.ui.overview;
const OverviewControls = imports.ui.overviewControls;
const PopupMenu = imports.ui.popupMenu;
const Tweener = imports.ui.tweener;
const Workspace = imports.ui.workspace;
const Params = imports.misc.params;
const Util = imports.misc.util;
const MAX_APPLICATION_WORK_MILLIS = 75;
const MENU_POPUP_TIMEOUT = 600;
const MAX_COLUMNS = 6;
const MIN_COLUMNS = 4;
const MIN_ROWS = 4;
const INACTIVE_GRID_OPACITY = 77;
// This time needs to be less than IconGrid.EXTRA_SPACE_ANIMATION_TIME
// to not clash with other animations
const INACTIVE_GRID_OPACITY_ANIMATION_TIME = 0.24;
const FOLDER_SUBICON_FRACTION = .4;
const MIN_FREQUENT_APPS_COUNT = 3;
const INDICATORS_BASE_TIME = 0.25;
const INDICATORS_ANIMATION_DELAY = 0.125;
const INDICATORS_ANIMATION_MAX_TIME = 0.75;
// Follow iconGrid animations approach and divide by 2 to animate out to
// not annoy the user when the user wants to quit appDisplay.
// Also, make sure we don't exceed iconGrid animation total time or
// views switch time.
const INDICATORS_BASE_TIME_OUT = 0.125;
const INDICATORS_ANIMATION_DELAY_OUT = 0.0625;
const INDICATORS_ANIMATION_MAX_TIME_OUT =
    Math.min (VIEWS_SWITCH_TIME,
              IconGrid.ANIMATION_TIME_OUT + IconGrid.ANIMATION_MAX_DELAY_OUT_FOR_ITEM);
const PAGE_SWITCH_TIME = 0.3;
const VIEWS_SWITCH_TIME = 0.4;
const VIEWS_SWITCH_ANIMATION_DELAY = 0.1;
const SWITCHEROO_BUS_NAME = 'net.hadess.SwitcherooControl';
const SWITCHEROO_OBJECT_PATH = '/net/hadess/SwitcherooControl';
const SwitcherooProxyInterface = '<node> \
<interface name="net.hadess.SwitcherooControl"> \
  <property name="HasDualGpu" type="b" access="read"/> \
</interface> \
</node>';
const SwitcherooProxy = Gio.DBusProxy.makeProxyWrapper(SwitcherooProxyInterface);
let discreteGpuAvailable = false;
function _getCategories(info) {
    let categoriesStr = info.get_categories();
    if (!categoriesStr)
        return [];
    return categoriesStr.split(';');
function _listsIntersect(a, b) {
    for (let itemA of a)
        if (b.indexOf(itemA) >= 0)
            return true;
    return false;
function _getFolderName(folder) {
    let name = folder.get_string('name');
    if (folder.get_boolean('translate')) {
        let keyfile = new GLib.KeyFile();
        let path = 'desktop-directories/' + name;
        try {
            keyfile.load_from_data_dirs(path, GLib.KeyFileFlags.NONE);
            name = keyfile.get_locale_string('Desktop Entry', 'Name', null);
        } catch(e) {
            return name;
        }
    }
    return name;
function clamp(value, min, max) {
    return Math.max(min, Math.min(max, value));
const BaseAppView = new Lang.Class({
    Name: 'BaseAppView',
    Abstract: true,
    _init: function(params, gridParams) {
        gridParams = Params.parse(gridParams, { xAlign: St.Align.MIDDLE,
                                                columnLimit: MAX_COLUMNS,
                                                minRows: MIN_ROWS,
                                                minColumns: MIN_COLUMNS,
                                                fillParent: false,
                                                padWithSpacing: true });
        params = Params.parse(params, { usePagination: false });
        if(params.usePagination)
            this._grid = new IconGrid.PaginatedIconGrid(gridParams);
        else
            this._grid = new IconGrid.IconGrid(gridParams);
        this._grid.connect('key-focus-in', Lang.bind(this, function(grid, actor) {
            this._keyFocusIn(actor);
        }));
        // Standard hack for ClutterBinLayout
        this._grid.actor.x_expand = true;
        this._items = {};
        this._allItems = [];
    },
    _keyFocusIn: function(actor) {
        // Nothing by default
    },
    removeAll: function() {
        this._grid.destroyAll();
        this._items = {};
        this._allItems = [];
    },
    _redisplay: function() {
        this.removeAll();
        this._loadApps();
    },
    getAllItems: function() {
        return this._allItems;
    },
    addItem: function(icon) {
        let id = icon.id;
        if (this._items[id] !== undefined)
            return;
        this._allItems.push(icon);
        this._items[id] = icon;
    },
    _compareItems: function(a, b) {
        return a.name.localeCompare(b.name);
    },
    loadGrid: function() {
        this._allItems.sort(this._compareItems);
        this._allItems.forEach(Lang.bind(this, function(item) {
            this._grid.addItem(item);
        }));
        this.emit('view-loaded');
    },
    _selectAppInternal: function(id) {
        if (this._items[id])
            this._items[id].actor.navigate_focus(null, Gtk.DirectionType.TAB_FORWARD, false);
        else
            log('No such application ' + id);
    },
    selectApp: function(id) {
        if (this._items[id] && this._items[id].actor.mapped) {
            this._selectAppInternal(id);
        } else if (this._items[id]) {
            // Need to wait until the view is mapped
            let signalId = this._items[id].actor.connect('notify::mapped', Lang.bind(this, function(actor) {
                if (actor.mapped) {
                    actor.disconnect(signalId);
                    this._selectAppInternal(id);
                }
            }));
        } else {
            // Need to wait until the view is built
            let signalId = this.connect('view-loaded', Lang.bind(this, function() {
                this.disconnect(signalId);
                this.selectApp(id);
            }));
        }
    },
    _doSpringAnimation: function(animationDirection) {
        this._grid.actor.opacity = 255;
        this._grid.animateSpring(animationDirection,
                                 Main.overview.getShowAppsButton());
    },
    animate: function(animationDirection, onComplete) {
        if (animationDirection == IconGrid.AnimationDirection.IN) {
            let toAnimate = this._grid.actor.connect('notify::allocation', Lang.bind(this,
                function() {
                    this._grid.actor.disconnect(toAnimate);
                    // We need to hide the grid temporary to not flash it
                    // for a frame
                    this._grid.actor.opacity = 0;
                    Meta.later_add(Meta.LaterType.BEFORE_REDRAW,
                                   Lang.bind(this, function() {
                                       this._doSpringAnimation(animationDirection)
                                  }));
                }));
        } else {
            this._doSpringAnimation(animationDirection);
        }
        if (onComplete) {
            let animationDoneId = this._grid.connect('animation-done', Lang.bind(this,
                function () {
                    this._grid.disconnect(animationDoneId);
                    onComplete();
            }));
        }
    },
    animateSwitch: function(animationDirection) {
        Tweener.removeTweens(this.actor);
        Tweener.removeTweens(this._grid.actor);
        let params = { time: VIEWS_SWITCH_TIME,
                       transition: 'easeOutQuad' };
        if (animationDirection == IconGrid.AnimationDirection.IN) {
            this.actor.show();
            params.opacity = 255;
            params.delay = VIEWS_SWITCH_ANIMATION_DELAY;
        } else {
            params.opacity = 0;
            params.delay = 0;
            params.onComplete = Lang.bind(this, function() { this.actor.hide() });
        }
        Tweener.addTween(this._grid.actor, params);
    }
Signals.addSignalMethods(BaseAppView.prototype);
const PageIndicatorsActor = new Lang.Class({
    Name:'PageIndicatorsActor',
    Extends: St.BoxLayout,
    _init: function() {
        this.parent({ style_class: 'page-indicators',
                      vertical: true,
                      x_expand: true, y_expand: true,
                      x_align: Clutter.ActorAlign.END,
                      y_align: Clutter.ActorAlign.CENTER,
                      reactive: true,
                      clip_to_allocation: true });
    },
    vfunc_get_preferred_height: function(forWidth) {
        // We want to request the natural height of all our children as our
        // natural height, so we chain up to St.BoxLayout, but we only request 0
        // as minimum height, since it's not that important if some indicators
        // are not shown
        let [, natHeight] = this.parent(forWidth);
        return [0, natHeight];
    }
const PageIndicators = new Lang.Class({
    Name:'PageIndicators',
    _init: function() {
        this.actor = new PageIndicatorsActor();
        this._nPages = 0;
        this._currentPage = undefined;
        this.actor.connect('notify::mapped',
                           Lang.bind(this, function() {
                               this.animateIndicators(IconGrid.AnimationDirection.IN);
                           })
                          );
    },
    setNPages: function(nPages) {
        if (this._nPages == nPages)
            return;
        let diff = nPages - this._nPages;
        if (diff > 0) {
            for (let i = 0; i < diff; i++) {
                let pageIndex = this._nPages + i;
                let indicator = new St.Button({ style_class: 'page-indicator',
                                                button_mask: St.ButtonMask.ONE |
                                                             St.ButtonMask.TWO |
                                                             St.ButtonMask.THREE,
                                                toggle_mode: true,
                                                checked: pageIndex == this._currentPage });
                indicator.child = new St.Widget({ style_class: 'page-indicator-icon' });
                indicator.connect('clicked', Lang.bind(this,
                    function() {
                        this.emit('page-activated', pageIndex);
                    }));
                this.actor.add_actor(indicator);
            }
        } else {
            let children = this.actor.get_children().splice(diff);
            for (let i = 0; i < children.length; i++)
                children[i].destroy();
        }
        this._nPages = nPages;
        this.actor.visible = (this._nPages > 1);
    },
    setCurrentPage: function(currentPage) {
        this._currentPage = currentPage;
        let children = this.actor.get_children();
        for (let i = 0; i < children.length; i++)
            children[i].set_checked(i == this._currentPage);
    },
    animateIndicators: function(animationDirection) {
        if (!this.actor.mapped)
            return;
        let children = this.actor.get_children();
        if (children.length == 0)
            return;
        for (let i = 0; i < this._nPages; i++)
            Tweener.removeTweens(children[i]);
        let offset;
        if (this.actor.get_text_direction() == Clutter.TextDirection.RTL)
            offset = -children[0].width;
        else
            offset = children[0].width;
        let isAnimationIn = animationDirection == IconGrid.AnimationDirection.IN;
        let delay = isAnimationIn ? INDICATORS_ANIMATION_DELAY :
                                    INDICATORS_ANIMATION_DELAY_OUT;
        let baseTime = isAnimationIn ? INDICATORS_BASE_TIME : INDICATORS_BASE_TIME_OUT;
        let totalAnimationTime = baseTime + delay * this._nPages;
        let maxTime = isAnimationIn ? INDICATORS_ANIMATION_MAX_TIME :
                                      INDICATORS_ANIMATION_MAX_TIME_OUT;
        if (totalAnimationTime > maxTime)
            delay -= (totalAnimationTime - maxTime) / this._nPages;
        for (let i = 0; i < this._nPages; i++) {
            children[i].translation_x = isAnimationIn ? offset : 0;
            Tweener.addTween(children[i],
                             { translation_x: isAnimationIn ? 0 : offset,
                               time: baseTime + delay * i,
                               transition: 'easeInOutQuad',
                               delay: isAnimationIn ? VIEWS_SWITCH_ANIMATION_DELAY : 0
                             });
        }
    }
Signals.addSignalMethods(PageIndicators.prototype);
const AllView = new Lang.Class({
    Name: 'AllView',
    Extends: BaseAppView,
    _init: function() {
        this.parent({ usePagination: true }, null);
        this._scrollView = new St.ScrollView({ style_class: 'all-apps',
                                               x_expand: true,
                                               y_expand: true,
                                               x_fill: true,
                                               y_fill: false,
                                               reactive: true,
                                               y_align: St.Align.START });
        this.actor = new St.Widget({ layout_manager: new Clutter.BinLayout(),
                                     x_expand:true, y_expand:true });
        this.actor.add_actor(this._scrollView);
        this._scrollView.set_policy(Gtk.PolicyType.NEVER,
                                    Gtk.PolicyType.EXTERNAL);
        this._adjustment = this._scrollView.vscroll.adjustment;
        this._pageIndicators = new PageIndicators();
        this._pageIndicators.connect('page-activated', Lang.bind(this,
            function(indicators, pageIndex) {
                this.goToPage(pageIndex);
            }));
        this._pageIndicators.actor.connect('scroll-event', Lang.bind(this, this._onScroll));
        this.actor.add_actor(this._pageIndicators.actor);
        this.folderIcons = [];
        this._stack = new St.Widget({ layout_manager: new Clutter.BinLayout() });
        let box = new St.BoxLayout({ vertical: true });
        this._grid.currentPage = 0;
        this._stack.add_actor(this._grid.actor);
        this._eventBlocker = new St.Widget({ x_expand: true, y_expand: true });
        this._stack.add_actor(this._eventBlocker);
        box.add_actor(this._stack);
        this._scrollView.add_actor(box);
        this._scrollView.connect('scroll-event', Lang.bind(this, this._onScroll));
        let panAction = new Clutter.PanAction({ interpolate: false });
        panAction.connect('pan', Lang.bind(this, this._onPan));
        panAction.connect('gesture-cancel', Lang.bind(this, this._onPanEnd));
        panAction.connect('gesture-end', Lang.bind(this, this._onPanEnd));
        this._panAction = panAction;
        this._scrollView.add_action(panAction);
        this._panning = false;
        this._clickAction = new Clutter.ClickAction();
        this._clickAction.connect('clicked', Lang.bind(this, function() {
            if (!this._currentPopup)
                return;
            let [x, y] = this._clickAction.get_coords();
            let actor = global.stage.get_actor_at_pos(Clutter.PickMode.ALL, x, y);
            if (!this._currentPopup.actor.contains(actor))
                this._currentPopup.popdown();
        }));
        this._eventBlocker.add_action(this._clickAction);
        this._displayingPopup = false;
        this._availWidth = 0;
        this._availHeight = 0;
        Main.overview.connect('hidden', Lang.bind(this,
            function() {
                this.goToPage(0);
            }));
        this._grid.connect('space-opened', Lang.bind(this,
            function() {
                this._scrollView.get_effect('fade').enabled = false;
                this.emit('space-ready');
            }));
        this._grid.connect('space-closed', Lang.bind(this,
            function() {
                this._displayingPopup = false;
            }));
        this.actor.connect('notify::mapped', Lang.bind(this,
            function() {
                if (this.actor.mapped) {
                    this._keyPressEventId =
                        global.stage.connect('key-press-event',
                                             Lang.bind(this, this._onKeyPressEvent));
                } else {
                    if (this._keyPressEventId)
                        global.stage.disconnect(this._keyPressEventId);
                    this._keyPressEventId = 0;
                }
            }));
        this._redisplayWorkId = Main.initializeDeferredWork(this.actor, Lang.bind(this, this._redisplay));
        Shell.AppSystem.get_default().connect('installed-changed', Lang.bind(this, function() {
            Main.queueDeferredWork(this._redisplayWorkId);
        }));
        this._folderSettings = new Gio.Settings({ schema_id: 'org.gnome.desktop.app-folders' });
        this._folderSettings.connect('changed::folder-children', Lang.bind(this, function() {
            Main.queueDeferredWork(this._redisplayWorkId);
        }));
    },
    removeAll: function() {
        this.folderIcons = [];
        this.parent();
    },
    _itemNameChanged: function(item) {
        // If an item's name changed, we can pluck it out of where it's
        // supposed to be and reinsert it where it's sorted.
        let oldIdx = this._allItems.indexOf(item);
        this._allItems.splice(oldIdx, 1);
        let newIdx = Util.insertSorted(this._allItems, item, this._compareItems);
        this._grid.removeItem(item);
        this._grid.addItem(item, newIdx);
    },
    _refilterApps: function() {
        this._allItems.forEach(function(icon) {
            if (icon instanceof AppIcon)
                icon.actor.visible = true;
        });
        this.folderIcons.forEach(Lang.bind(this, function(folder) {
            let folderApps = folder.getAppIds();
            folderApps.forEach(Lang.bind(this, function(appId) {
                let appIcon = this._items[appId];
                appIcon.actor.visible = false;
            }));
        }));
    },
    _loadApps: function() {
        let apps = Gio.AppInfo.get_all().filter(function(appInfo) {
            try {
                let id = appInfo.get_id(); // catch invalid file encodings
            } catch(e) {
                return false;
            }
            return appInfo.should_show();
        }).map(function(app) {
            return app.get_id();
        });
        let appSys = Shell.AppSystem.get_default();
        let folders = this._folderSettings.get_strv('folder-children');
        folders.forEach(Lang.bind(this, function(id) {
            let path = this._folderSettings.path + 'folders/' + id + '/';
            let icon = new FolderIcon(id, path, this);
            icon.connect('name-changed', Lang.bind(this, this._itemNameChanged));
            icon.connect('apps-changed', Lang.bind(this, this._refilterApps));
            this.addItem(icon);
            this.folderIcons.push(icon);
        }));
        // Allow dragging of the icon only if the Dash would accept a drop to
        // change favorite-apps. There are no other possible drop targets from
        // the app picker, so there's no other need for a drag to start,
        // at least on single-monitor setups.
        // This also disables drag-to-launch on multi-monitor setups,
        // but we hope that is not used much.
        let favoritesWritable = global.settings.is_writable('favorite-apps');
        apps.forEach(Lang.bind(this, function(appId) {
            let app = appSys.lookup_app(appId);
            let icon = new AppIcon(app,
                                   { isDraggable: favoritesWritable });
            this.addItem(icon);
        }));
        this.loadGrid();
        this._refilterApps();
    },
    // Overriden from BaseAppView
    animate: function (animationDirection, onComplete) {
        this._scrollView.reactive = false;
        let completionFunc = Lang.bind(this, function() {
            this._scrollView.reactive = true;
            if (onComplete)
                onComplete();
        });
        if (animationDirection == IconGrid.AnimationDirection.OUT &&
            this._displayingPopup && this._currentPopup) {
            this._currentPopup.popdown();
            let spaceClosedId = this._grid.connect('space-closed', Lang.bind(this,
                function() {
                    this._grid.disconnect(spaceClosedId);
                    // Given that we can't call this.parent() inside the
                    // signal handler, call again animate which will
                    // call the parent given that popup is already
                    // closed.
                    this.animate(animationDirection, completionFunc);
                }));
        } else {
            this.parent(animationDirection, completionFunc);
            if (animationDirection == IconGrid.AnimationDirection.OUT)
                this._pageIndicators.animateIndicators(animationDirection);
        }
    },
    animateSwitch: function(animationDirection) {
        this.parent(animationDirection);
        if (this._currentPopup && this._displayingPopup &&
            animationDirection == IconGrid.AnimationDirection.OUT)
            Tweener.addTween(this._currentPopup.actor,
                             { time: VIEWS_SWITCH_TIME,
                               transition: 'easeOutQuad',
                               opacity: 0,
                               onComplete: function() {
                                  this.opacity = 255;
                               } });
        if (animationDirection == IconGrid.AnimationDirection.OUT)
            this._pageIndicators.animateIndicators(animationDirection);
    },
    getCurrentPageY: function() {
        return this._grid.getPageY(this._grid.currentPage);
    },
    goToPage: function(pageNumber) {
        pageNumber = clamp(pageNumber, 0, this._grid.nPages() - 1);
        if (this._grid.currentPage == pageNumber && this._displayingPopup && this._currentPopup)
            return;
        if (this._displayingPopup && this._currentPopup)
            this._currentPopup.popdown();
        let velocity;
        if (!this._panning)
            velocity = 0;
        else
            velocity = Math.abs(this._panAction.get_velocity(0)[2]);
        // Tween the change between pages.
        // If velocity is not specified (i.e. scrolling with mouse wheel),
        // use the same speed regardless of original position
        // if velocity is specified, it's in pixels per milliseconds
        let diffToPage = this._diffToPage(pageNumber);
        let childBox = this._scrollView.get_allocation_box();
        let totalHeight = childBox.y2 - childBox.y1;
        let time;
        // Only take the velocity into account on page changes, otherwise
        // return smoothly to the current page using the default velocity
        if (this._grid.currentPage != pageNumber) {
            let minVelocity = totalHeight / (PAGE_SWITCH_TIME * 1000);
            velocity = Math.max(minVelocity, velocity);
            time = (diffToPage / velocity) / 1000;
        } else {
            time = PAGE_SWITCH_TIME * diffToPage / totalHeight;
        }
        // When changing more than one page, make sure to not take
        // longer than PAGE_SWITCH_TIME
        time = Math.min(time, PAGE_SWITCH_TIME);
        this._grid.currentPage = pageNumber;
        Tweener.addTween(this._adjustment,
                         { value: this._grid.getPageY(this._grid.currentPage),
                           time: time,
                           transition: 'easeOutQuad' });
        this._pageIndicators.setCurrentPage(pageNumber);
    },
    _diffToPage: function (pageNumber) {
        let currentScrollPosition = this._adjustment.value;
        return Math.abs(currentScrollPosition - this._grid.getPageY(pageNumber));
    },
    openSpaceForPopup: function(item, side, nRows) {
        this._updateIconOpacities(true);
        this._displayingPopup = true;
        this._grid.openExtraSpace(item, side, nRows);
    },
    _closeSpaceForPopup: function() {
        this._updateIconOpacities(false);
        this._scrollView.get_effect('fade').enabled = true;
        this._grid.closeExtraSpace();
    },
    _onScroll: function(actor, event) {
        if (this._displayingPopup || !this._scrollView.reactive)
            return Clutter.EVENT_STOP;
        let direction = event.get_scroll_direction();
        if (direction == Clutter.ScrollDirection.UP)
            this.goToPage(this._grid.currentPage - 1);
        else if (direction == Clutter.ScrollDirection.DOWN)
            this.goToPage(this._grid.currentPage + 1);
        return Clutter.EVENT_STOP;
    },
    _onPan: function(action) {
        if (this._displayingPopup)
            return false;
        this._panning = true;
        this._clickAction.release();
        let [dist, dx, dy] = action.get_motion_delta(0);
        let adjustment = this._adjustment;
        adjustment.value -= (dy / this._scrollView.height) * adjustment.page_size;
        return false;
    },
    _onPanEnd: function(action) {
         if (this._displayingPopup)
            return;
        let pageHeight = this._grid.getPageHeight();
        // Calculate the scroll value we'd be at, which is our current
        // scroll plus any velocity the user had when they released
        // their finger.
        let velocity = -action.get_velocity(0)[2];
        let endPanValue = this._adjustment.value + velocity;
        let closestPage = Math.round(endPanValue / pageHeight);
        this.goToPage(closestPage);
        this._panning = false;
    },
    _onKeyPressEvent: function(actor, event) {
        if (this._displayingPopup)
            return Clutter.EVENT_STOP;
        if (event.get_key_symbol() == Clutter.Page_Up) {
            this.goToPage(this._grid.currentPage - 1);
            return Clutter.EVENT_STOP;
        } else if (event.get_key_symbol() == Clutter.Page_Down) {
            this.goToPage(this._grid.currentPage + 1);
            return Clutter.EVENT_STOP;
        }
        return Clutter.EVENT_PROPAGATE;
    },
    addFolderPopup: function(popup) {
        this._stack.add_actor(popup.actor);
        popup.connect('open-state-changed', Lang.bind(this,
            function(popup, isOpen) {
                this._eventBlocker.reactive = isOpen;
                this._currentPopup = isOpen ? popup : null;
                this._updateIconOpacities(isOpen);
                if(!isOpen)
                    this._closeSpaceForPopup();
            }));
    },
    _keyFocusIn: function(icon) {
        let itemPage = this._grid.getItemPage(icon);
        this.goToPage(itemPage);
    },
    _updateIconOpacities: function(folderOpen) {
        for (let id in this._items) {
            let params, opacity;
            if (folderOpen && !this._items[id].actor.checked)
                opacity =  INACTIVE_GRID_OPACITY;
            else
                opacity = 255;
            params = { opacity: opacity,
                       time: INACTIVE_GRID_OPACITY_ANIMATION_TIME,
                       transition: 'easeOutQuad' };
            Tweener.addTween(this._items[id].actor, params);
        }
    },
    // Called before allocation to calculate dynamic spacing
    adaptToSize: function(width, height) {
        let box = new Clutter.ActorBox();
        box.x1 = 0;
        box.x2 = width;
        box.y1 = 0;
        box.y2 = height;
        box = this.actor.get_theme_node().get_content_box(box);
        box = this._scrollView.get_theme_node().get_content_box(box);
        box = this._grid.actor.get_theme_node().get_content_box(box);
        let availWidth = box.x2 - box.x1;
        let availHeight = box.y2 - box.y1;
        let oldNPages = this._grid.nPages();
        this._grid.adaptToSize(availWidth, availHeight);
        let fadeOffset = Math.min(this._grid.topPadding,
                                  this._grid.bottomPadding);
        this._scrollView.update_fade_effect(fadeOffset, 0);
        if (fadeOffset > 0)
            this._scrollView.get_effect('fade').fade_edges = true;
        if (this._availWidth != availWidth || this._availHeight != availHeight || oldNPages != this._grid.nPages()) {
            this._adjustment.value = 0;
            this._grid.currentPage = 0;
            Meta.later_add(Meta.LaterType.BEFORE_REDRAW, Lang.bind(this,
                function() {
                    this._pageIndicators.setNPages(this._grid.nPages());
                    this._pageIndicators.setCurrentPage(0);
                }));
        }
        this._availWidth = availWidth;
        this._availHeight = availHeight;
        // Update folder views
        for (let i = 0; i < this.folderIcons.length; i++)
            this.folderIcons[i].adaptToSize(availWidth, availHeight);
    }
Signals.addSignalMethods(AllView.prototype);
const FrequentView = new Lang.Class({
    Name: 'FrequentView',
    Extends: BaseAppView,
    _init: function() {
        this.parent(null, { fillParent: true });
        this.actor = new St.Widget({ style_class: 'frequent-apps',
                                     layout_manager: new Clutter.BinLayout(),
                                     x_expand: true, y_expand: true });
        this._noFrequentAppsLabel = new St.Label({ text: _("Frequently used applications will appear here"),
                                                   style_class: 'no-frequent-applications-label',
                                                   x_align: Clutter.ActorAlign.CENTER,
                                                   x_expand: true,
                                                   y_align: Clutter.ActorAlign.CENTER,
                                                   y_expand: true });
        this._grid.actor.y_expand = true;
        this.actor.add_actor(this._grid.actor);
        this.actor.add_actor(this._noFrequentAppsLabel);
        this._noFrequentAppsLabel.hide();
        this._usage = Shell.AppUsage.get_default();
        this.actor.connect('notify::mapped', Lang.bind(this, function() {
            if (this.actor.mapped)
                this._redisplay();
        }));
    },
    hasUsefulData: function() {
        return this._usage.get_most_used("").length >= MIN_FREQUENT_APPS_COUNT;
    },
    _loadApps: function() {
        let mostUsed = this._usage.get_most_used ("");
        let hasUsefulData = this.hasUsefulData();
        this._noFrequentAppsLabel.visible = !hasUsefulData;
        if(!hasUsefulData)
            return;
        // Allow dragging of the icon only if the Dash would accept a drop to
        // change favorite-apps. There are no other possible drop targets from
        // the app picker, so there's no other need for a drag to start,
        // at least on single-monitor setups.
        // This also disables drag-to-launch on multi-monitor setups,
        // but we hope that is not used much.
        let favoritesWritable = global.settings.is_writable('favorite-apps');
        for (let i = 0; i < mostUsed.length; i++) {
            if (!mostUsed[i].get_app_info().should_show())
                continue;
            let appIcon = new AppIcon(mostUsed[i],
                                      { isDraggable: favoritesWritable });
            this._grid.addItem(appIcon, -1);
        }
    },
    // Called before allocation to calculate dynamic spacing
    adaptToSize: function(width, height) {
        let box = new Clutter.ActorBox();
        box.x1 = box.y1 = 0;
        box.x2 = width;
        box.y2 = height;
        box = this.actor.get_theme_node().get_content_box(box);
        box = this._grid.actor.get_theme_node().get_content_box(box);
        let availWidth = box.x2 - box.x1;
        let availHeight = box.y2 - box.y1;
        this._grid.adaptToSize(availWidth, availHeight);
    }
const Views = {
    FREQUENT: 0,
    ALL: 1
const ControlsBoxLayout = Lang.Class({
    Name: 'ControlsBoxLayout',
    Extends: Clutter.BoxLayout,
    /**
     * Override the BoxLayout behavior to use the maximum preferred width of all
     * buttons for each child
     */
    vfunc_get_preferred_width: function(container, forHeight) {
        let maxMinWidth = 0;
        let maxNaturalWidth = 0;
        for (let child = container.get_first_child();
             child;
             child = child.get_next_sibling()) {
             let [minWidth, natWidth] = child.get_preferred_width(forHeight);
             maxMinWidth = Math.max(maxMinWidth, minWidth);
             maxNaturalWidth = Math.max(maxNaturalWidth, natWidth);
        }
        let childrenCount = container.get_n_children();
        let totalSpacing = this.spacing * (childrenCount - 1);
        return [maxMinWidth * childrenCount + totalSpacing,
                maxNaturalWidth * childrenCount + totalSpacing];
    }
const ViewStackLayout = new Lang.Class({
    Name: 'ViewStackLayout',
    Extends: Clutter.BinLayout,
    vfunc_allocate: function (actor, box, flags) {
        let availWidth = box.x2 - box.x1;
        let availHeight = box.y2 - box.y1;
        // Prepare children of all views for the upcoming allocation, calculate all
        // the needed values to adapt available size
        this.emit('allocated-size-changed', availWidth, availHeight);
        this.parent(actor, box, flags);
    }
Signals.addSignalMethods(ViewStackLayout.prototype);
const AppDisplay = new Lang.Class({
    Name: 'AppDisplay',
    _init: function() {
        this._privacySettings = new Gio.Settings({ schema_id: 'org.gnome.desktop.privacy' });
        this._privacySettings.connect('changed::remember-app-usage',
                                      Lang.bind(this, this._updateFrequentVisibility));
        this._views = [];
        let view, button;
        view = new FrequentView();
        button = new St.Button({ label: _("Frequent"),
                                 style_class: 'app-view-control button',
                                 can_focus: true,
                                 x_expand: true });
        this._views[Views.FREQUENT] = { 'view': view, 'control': button };
        view = new AllView();
        button = new St.Button({ label: _("All"),
                                 style_class: 'app-view-control button',
                                 can_focus: true,
                                 x_expand: true });
        this._views[Views.ALL] = { 'view': view, 'control': button };
        this.actor = new St.BoxLayout ({ style_class: 'app-display',
                                         x_expand: true, y_expand: true,
                                         vertical: true });
        this._viewStackLayout = new ViewStackLayout();
        this._viewStack = new St.Widget({ x_expand: true, y_expand: true,
                                          layout_manager: this._viewStackLayout });
        this._viewStackLayout.connect('allocated-size-changed', Lang.bind(this, this._onAllocatedSizeChanged));
        this.actor.add_actor(this._viewStack);
        let layout = new ControlsBoxLayout({ homogeneous: true });
        this._controls = new St.Widget({ style_class: 'app-view-controls',
                                         layout_manager: layout });
        this._controls.connect('notify::mapped', Lang.bind(this,
            function() {
                // controls are faded either with their parent or
                // explicitly in animate(); we can't know how they'll be
                // shown next, so make sure to restore their opacity
                // when they are hidden
                if (this._controls.mapped)
                  return;
                Tweener.removeTweens(this._controls);
                this._controls.opacity = 255;
            }));
        layout.hookup_style(this._controls);
        this.actor.add_actor(new St.Bin({ child: this._controls }));
        for (let i = 0; i < this._views.length; i++) {
            this._viewStack.add_actor(this._views[i].view.actor);
            this._controls.add_actor(this._views[i].control);
            let viewIndex = i;
            this._views[i].control.connect('clicked', Lang.bind(this,
                function(actor) {
                    this._showView(viewIndex);
                    global.settings.set_uint('app-picker-view', viewIndex);
                }));
        }
        let initialView = Math.min(global.settings.get_uint('app-picker-view'),
                                   this._views.length - 1);
        let frequentUseful = this._views[Views.FREQUENT].view.hasUsefulData();
        if (initialView == Views.FREQUENT && !frequentUseful)
            initialView = Views.ALL;
        this._showView(initialView);
        this._updateFrequentVisibility();
        Gio.DBus.system.watch_name(SWITCHEROO_BUS_NAME,
                                   Gio.BusNameWatcherFlags.NONE,
                                   Lang.bind(this, this._switcherooProxyAppeared),
                                   Lang.bind(this, function() {
                                       this._switcherooProxy = null;
                                       this._updateDiscreteGpuAvailable();
                                   }));
    },
    _updateDiscreteGpuAvailable: function() {
        if (!this._switcherooProxy)
            discreteGpuAvailable = false;
        else
            discreteGpuAvailable = this._switcherooProxy.HasDualGpu;
    },
    _switcherooProxyAppeared: function() {
        this._switcherooProxy = new SwitcherooProxy(Gio.DBus.system, SWITCHEROO_BUS_NAME, SWITCHEROO_OBJECT_PATH,
            Lang.bind(this, function(proxy, error) {
                if (error) {
                    log(error.message);
                    return;
                }
                this._updateDiscreteGpuAvailable();
            }));
    },
    animate: function(animationDirection, onComplete) {
        let currentView = this._views[global.settings.get_uint('app-picker-view')].view;
        // Animate controls opacity using iconGrid animation time, since
        // it will be the time the AllView or FrequentView takes to show
        // it entirely.
        let finalOpacity;
        if (animationDirection == IconGrid.AnimationDirection.IN) {
            this._controls.opacity = 0;
            finalOpacity = 255;
        } else {
            finalOpacity = 0
        }
        Tweener.addTween(this._controls,
                         { time: IconGrid.ANIMATION_TIME_IN,
                           transition: 'easeInOutQuad',
                           opacity: finalOpacity,
                          });
        currentView.animate(animationDirection, onComplete);
    },
    _showView: function(activeIndex) {
        for (let i = 0; i < this._views.length; i++) {
            if (i == activeIndex)
                this._views[i].control.add_style_pseudo_class('checked');
            else
                this._views[i].control.remove_style_pseudo_class('checked');
            let animationDirection = i == activeIndex ? IconGrid.AnimationDirection.IN :
                                                        IconGrid.AnimationDirection.OUT;
            this._views[i].view.animateSwitch(animationDirection);
        }
    },
    _updateFrequentVisibility: function() {
        let enabled = this._privacySettings.get_boolean('remember-app-usage');
        this._views[Views.FREQUENT].control.visible = enabled;
        let visibleViews = this._views.filter(function(v) {
            return v.control.visible;
        });
        this._controls.visible = visibleViews.length > 1;
        if (!enabled && this._views[Views.FREQUENT].view.actor.visible)
            this._showView(Views.ALL);
    },
    selectApp: function(id) {
        this._showView(Views.ALL);
        this._views[Views.ALL].view.selectApp(id);
    },
    _onAllocatedSizeChanged: function(actor, width, height) {
        let box = new Clutter.ActorBox();
        box.x1 = box.y1 =0;
        box.x2 = width;
        box.y2 = height;
        box = this._viewStack.get_theme_node().get_content_box(box);
        let availWidth = box.x2 - box.x1;
        let availHeight = box.y2 - box.y1;
        for (let i = 0; i < this._views.length; i++)
            this._views[i].view.adaptToSize(availWidth, availHeight);
    }
const AppSearchProvider = new Lang.Class({
    Name: 'AppSearchProvider',
    _init: function() {
        this._appSys = Shell.AppSystem.get_default();
        this.id = 'applications';
    },
    getResultMetas: function(apps, callback) {
        let metas = [];
        for (let i = 0; i < apps.length; i++) {
            let app = this._appSys.lookup_app(apps[i]);
            metas.push({ 'id': app.get_id(),
                         'name': app.get_name(),
                         'createIcon': function(size) {
                             return app.create_icon_texture(size);
                         }
                       });
        }
        callback(metas);
    },
    filterResults: function(results, maxNumber) {
        return results.slice(0, maxNumber);
    },
    getInitialResultSet: function(terms, callback, cancellable) {
        let query = terms.join(' ');
        let groups = Shell.AppSystem.search(query);
        let usage = Shell.AppUsage.get_default();
        let results = [];
        groups.forEach(function(group) {
            group = group.filter(function(appID) {
                let app = Gio.DesktopAppInfo.new(appID);
                return app && app.should_show();
            });
            results = results.concat(group.sort(function(a, b) {
                return usage.compare('', a, b);
            }));
        });
        callback(results);
    },
    getSubsearchResultSet: function(previousResults, terms, callback, cancellable) {
        this.getInitialResultSet(terms, callback, cancellable);
    },
    createResultObject: function (resultMeta) {
        let app = this._appSys.lookup_app(resultMeta['id']);
        return new AppIcon(app);
    }
const FolderView = new Lang.Class({
    Name: 'FolderView',
    Extends: BaseAppView,
    _init: function() {
        this.parent(null, null);
        // If it not expand, the parent doesn't take into account its preferred_width when allocating
        // the second time it allocates, so we apply the "Standard hack for ClutterBinLayout"
        this._grid.actor.x_expand = true;
        this.actor = new St.ScrollView({ overlay_scrollbars: true });
        this.actor.set_policy(Gtk.PolicyType.NEVER, Gtk.PolicyType.AUTOMATIC);
        let scrollableContainer = new St.BoxLayout({ vertical: true, reactive: true });
        scrollableContainer.add_actor(this._grid.actor);
        this.actor.add_actor(scrollableContainer);
        let action = new Clutter.PanAction({ interpolate: true });
        action.connect('pan', Lang.bind(this, this._onPan));
        this.actor.add_action(action);
    },
    _keyFocusIn: function(actor) {
        Util.ensureActorVisibleInScrollView(this.actor, actor);
    },
    // Overriden from BaseAppView
    animate: function(animationDirection) {
        this._grid.animatePulse(animationDirection);
    },
    createFolderIcon: function(size) {
        let layout = new Clutter.GridLayout();
        let icon = new St.Widget({ layout_manager: layout,
                                   style_class: 'app-folder-icon' });
        layout.hookup_style(icon);
        let subSize = Math.floor(FOLDER_SUBICON_FRACTION * size);
        let numItems = this._allItems.length;
        let rtl = icon.get_text_direction() == Clutter.TextDirection.RTL;
        for (let i = 0; i < 4; i++) {
            let bin;
            if (i < numItems) {
                let texture = this._allItems[i].app.create_icon_texture(subSize);
                bin = new St.Bin({ child: texture });
            } else {
                bin = new St.Bin({ width: subSize, height: subSize });
            }
            layout.attach(bin, rtl ? (i + 1) % 2 : i % 2, Math.floor(i / 2), 1, 1);
        }
        return icon;
    },
    _onPan: function(action) {
        let [dist, dx, dy] = action.get_motion_delta(0);
        let adjustment = this.actor.vscroll.adjustment;
        adjustment.value -= (dy / this.actor.height) * adjustment.page_size;
        return false;
    },
    adaptToSize: function(width, height) {
        this._parentAvailableWidth = width;
        this._parentAvailableHeight = height;
        this._grid.adaptToSize(width, height);
        // To avoid the fade effect being applied to the unscrolled grid,
        // the offset would need to be applied after adjusting the padding;
        // however the final padding is expected to be too small for the
        // effect to look good, so use the unadjusted padding
        let fadeOffset = Math.min(this._grid.topPadding,
                                  this._grid.bottomPadding);
        this.actor.update_fade_effect(fadeOffset, 0);
        // Set extra padding to avoid popup or close button being cut off
        this._grid.topPadding = Math.max(this._grid.topPadding - this._offsetForEachSide, 0);
        this._grid.bottomPadding = Math.max(this._grid.bottomPadding - this._offsetForEachSide, 0);
        this._grid.leftPadding = Math.max(this._grid.leftPadding - this._offsetForEachSide, 0);
        this._grid.rightPadding = Math.max(this._grid.rightPadding - this._offsetForEachSide, 0);
        this.actor.set_width(this.usedWidth());
        this.actor.set_height(this.usedHeight());
    },
    _getPageAvailableSize: function() {
        let pageBox = new Clutter.ActorBox();
        pageBox.x1 = pageBox.y1 = 0;
        pageBox.x2 = this._parentAvailableWidth;
        pageBox.y2 = this._parentAvailableHeight;
        let contentBox = this.actor.get_theme_node().get_content_box(pageBox);
        // We only can show icons inside the collection view boxPointer
        // so we have to substract the required padding etc of the boxpointer
        return [(contentBox.x2 - contentBox.x1) - 2 * this._offsetForEachSide, (contentBox.y2 - contentBox.y1) - 2 * this._offsetForEachSide];
    },
    usedWidth: function() {
        let [availWidthPerPage, availHeightPerPage] = this._getPageAvailableSize();
        return this._grid.usedWidth(availWidthPerPage);
    },
    usedHeight: function() {
        return this._grid.usedHeightForNRows(this.nRowsDisplayedAtOnce());
    },
    nRowsDisplayedAtOnce: function() {
        let [availWidthPerPage, availHeightPerPage] = this._getPageAvailableSize();
        let maxRows = this._grid.rowsForHeight(availHeightPerPage) - 1;
        return Math.min(this._grid.nRows(availWidthPerPage), maxRows);
    },
    setPaddingOffsets: function(offset) {
        this._offsetForEachSide = offset;
    }
const FolderIcon = new Lang.Class({
    Name: 'FolderIcon',
    _init: function(id, path, parentView) {
        this.id = id;
        this._parentView = parentView;
        this._folder = new Gio.Settings({ schema_id: 'org.gnome.desktop.app-folders.folder',
                                          path: path });
        this.actor = new St.Button({ style_class: 'app-well-app app-folder',
                                     button_mask: St.ButtonMask.ONE,
                                     toggle_mode: true,
                                     can_focus: true,
                                     x_fill: true,
                                     y_fill: true });
        this.actor._delegate = this;
        // whether we need to update arrow side, position etc.
        this._popupInvalidated = false;
        this.icon = new IconGrid.BaseIcon('', { createIcon: Lang.bind(this, this._createIcon), setSizeManually: true });
        this.actor.set_child(this.icon.actor);
        this.actor.label_actor = this.icon.label;
        this.view = new FolderView();
        this.actor.connect('clicked', Lang.bind(this,
            function() {
                this._ensurePopup();
                this.view.actor.vscroll.adjustment.value = 0;
                this._openSpaceForPopup();
            }));
        this.actor.connect('notify::mapped', Lang.bind(this,
            function() {
                if (!this.actor.mapped && this._popup)
                    this._popup.popdown();
            }));
        this._folder.connect('changed', Lang.bind(this, this._redisplay));
        this._redisplay();
    },
    getAppIds: function() {
        return this.view.getAllItems().map(function(item) {
            return item.id;
        });
    },
    _updateName: function() {
        let name = _getFolderName(this._folder);
        if (this.name == name)
            return;
        this.name = name;
        this.icon.label.text = this.name;
        this.emit('name-changed');
    },
    _redisplay: function() {
        this._updateName();
        this.view.removeAll();
        let excludedApps = this._folder.get_strv('excluded-apps');
        let appSys = Shell.AppSystem.get_default();
        let addAppId = (function addAppId(appId) {
            if (excludedApps.indexOf(appId) >= 0)
                return;
            let app = appSys.lookup_app(appId);
            if (!app)
                return;
            if (!app.get_app_info().should_show())
                return;
            let icon = new AppIcon(app);
            this.view.addItem(icon);
        }).bind(this);
        let folderApps = this._folder.get_strv('apps');
        folderApps.forEach(addAppId);
        let folderCategories = this._folder.get_strv('categories');
        Gio.AppInfo.get_all().forEach(function(appInfo) {
            let appCategories = _getCategories(appInfo);
            if (!_listsIntersect(folderCategories, appCategories))
                return;
            try {
                addAppId(appInfo.get_id()); // catch invalid file encodings
            } catch(e) {
            }
        });
        this.actor.visible = this.view.getAllItems().length > 0;
        this.view.loadGrid();
        this.emit('apps-changed');
    },
    _createIcon: function(iconSize) {
        return this.view.createFolderIcon(iconSize, this);
    },
    _popupHeight: function() {
        let usedHeight = this.view.usedHeight() + this._popup.getOffset(St.Side.TOP) + this._popup.getOffset(St.Side.BOTTOM);
        return usedHeight;
    },
    _openSpaceForPopup: function() {
        let id = this._parentView.connect('space-ready', Lang.bind(this,
            function() {
                this._parentView.disconnect(id);
                this._popup.popup();
                this._updatePopupPosition();
            }));
        this._parentView.openSpaceForPopup(this, this._boxPointerArrowside, this.view.nRowsDisplayedAtOnce());
    },
    _calculateBoxPointerArrowSide: function() {
        let spaceTop = this.actor.y - this._parentView.getCurrentPageY();
        let spaceBottom = this._parentView.actor.height - (spaceTop + this.actor.height);
        return spaceTop > spaceBottom ? St.Side.BOTTOM : St.Side.TOP;
    },
    _updatePopupSize: function() {
        // StWidget delays style calculation until needed, make sure we use the correct values
        this.view._grid.actor.ensure_style();
        let offsetForEachSide = Math.ceil((this._popup.getOffset(St.Side.TOP) +
                                           this._popup.getOffset(St.Side.BOTTOM) -
                                           this._popup.getCloseButtonOverlap()) / 2);
        // Add extra padding to prevent boxpointer decorations and close button being cut off
        this.view.setPaddingOffsets(offsetForEachSide);
        this.view.adaptToSize(this._parentAvailableWidth, this._parentAvailableHeight);
    },
    _updatePopupPosition: function() {
        if (!this._popup)
            return;
        if (this._boxPointerArrowside == St.Side.BOTTOM)
            this._popup.actor.y = this.actor.allocation.y1 + this.actor.translation_y - this._popupHeight();
        else
            this._popup.actor.y = this.actor.allocation.y1 + this.actor.translation_y + this.actor.height;
    },
    _ensurePopup: function() {
        if (this._popup && !this._popupInvalidated)
            return;
        this._boxPointerArrowside = this._calculateBoxPointerArrowSide();
        if (!this._popup) {
            this._popup = new AppFolderPopup(this, this._boxPointerArrowside);
            this._parentView.addFolderPopup(this._popup);
            this._popup.connect('open-state-changed', Lang.bind(this,
                function(popup, isOpen) {
                    if (!isOpen)
                        this.actor.checked = false;
                }));
        } else {
            this._popup.updateArrowSide(this._boxPointerArrowside);
        }
        this._updatePopupSize();
        this._updatePopupPosition();
        this._popupInvalidated = false;
    },
    adaptToSize: function(width, height) {
        this._parentAvailableWidth = width;
        this._parentAvailableHeight = height;
        if(this._popup)
            this.view.adaptToSize(width, height);
        this._popupInvalidated = true;
    },
Signals.addSignalMethods(FolderIcon.prototype);
const AppFolderPopup = new Lang.Class({
    Name: 'AppFolderPopup',
    _init: function(source, side) {
        this._source = source;
        this._view = source.view;
        this._arrowSide = side;
        this._isOpen = false;
        this.parentOffset = 0;
        this.actor = new St.Widget({ layout_manager: new Clutter.BinLayout(),
                                     visible: false,
                                     // We don't want to expand really, but look
                                     // at the layout manager of our parent...
                                     //
                                     // DOUBLE HACK: if you set one, you automatically
                                     // get the effect for the other direction too, so
                                     // we need to set the y_align
                                     x_expand: true,
                                     y_expand: true,
                                     x_align: Clutter.ActorAlign.CENTER,
                                     y_align: Clutter.ActorAlign.START });
        this._boxPointer = new BoxPointer.BoxPointer(this._arrowSide,
                                                     { style_class: 'app-folder-popup-bin',
                                                       x_fill: true,
                                                       y_fill: true,
                                                       x_expand: true,
                                                       x_align: St.Align.START });
        this._boxPointer.actor.style_class = 'app-folder-popup';
        this.actor.add_actor(this._boxPointer.actor);
        this._boxPointer.bin.set_child(this._view.actor);
        this.closeButton = Util.makeCloseButton(this._boxPointer);
        this.closeButton.connect('clicked', Lang.bind(this, this.popdown));
        this.actor.add_actor(this.closeButton);
        this._boxPointer.actor.bind_property('opacity', this.closeButton, 'opacity',
                                             GObject.BindingFlags.SYNC_CREATE);
        global.focus_manager.add_group(this.actor);
        source.actor.connect('destroy', Lang.bind(this,
            function() {
                this.actor.destroy();
            }));
        this._grabHelper = new GrabHelper.GrabHelper(this.actor);
        this._grabHelper.addActor(Main.layoutManager.overviewGroup);
        this.actor.connect('key-press-event', Lang.bind(this, this._onKeyPress));
    },
    _onKeyPress: function(actor, event) {
        if (global.stage.get_key_focus() != actor)
            return Clutter.EVENT_PROPAGATE;
        // Since we need to only grab focus on one item child when the user
        // actually press a key we don't use navigate_focus when opening
        // the popup.
        // Instead of that, grab the focus on the AppFolderPopup actor
        // and actually moves the focus to a child only when the user
        // actually press a key.
        // It should work with just grab_key_focus on the AppFolderPopup
        // actor, but since the arrow keys are not wrapping_around the focus
        // is not grabbed by a child when the widget that has the current focus
        // is the same that is requesting focus, so to make it works with arrow
        // keys we need to connect to the key-press-event and navigate_focus
        // when that happens using TAB_FORWARD or TAB_BACKWARD instead of arrow
        // keys
        // Use TAB_FORWARD for down key and right key
        // and TAB_BACKWARD for up key and left key on ltr
        // languages
        let direction;
        let isLtr = Clutter.get_default_text_direction() == Clutter.TextDirection.LTR;
        switch (event.get_key_symbol()) {
            case Clutter.Down:
                direction = Gtk.DirectionType.TAB_FORWARD;
                break;
            case Clutter.Right:
                direction = isLtr ? Gtk.DirectionType.TAB_FORWARD :
                                    Gtk.DirectionType.TAB_BACKWARD;
                break;
            case Clutter.Up:
                direction = Gtk.DirectionType.TAB_BACKWARD;
                break;
            case Clutter.Left:
                direction = isLtr ? Gtk.DirectionType.TAB_BACKWARD :
                                    Gtk.DirectionType.TAB_FORWARD;
                break;
            default:
                return Clutter.EVENT_PROPAGATE;
        }
        return actor.navigate_focus(null, direction, false);
    },
    toggle: function() {
        if (this._isOpen)
            this.popdown();
        else
            this.popup();
    },
    popup: function() {
        if (this._isOpen)
            return;
        this._isOpen = this._grabHelper.grab({ actor: this.actor,
                                               onUngrab: Lang.bind(this, this.popdown) });
        if (!this._isOpen)
            return;
        this.actor.show();
        this._boxPointer.setArrowActor(this._source.actor);
        // We need to hide the icons of the view until the boxpointer animation
        // is completed so we can animate the icons after as we like without
        // showing them while boxpointer is animating.
        this._view.actor.opacity = 0;
        this._boxPointer.show(BoxPointer.PopupAnimation.FADE |
                              BoxPointer.PopupAnimation.SLIDE,
                              Lang.bind(this,
            function() {
                this._view.actor.opacity = 255;
                this._view.animate(IconGrid.AnimationDirection.IN);
            }));
        this.emit('open-state-changed', true);
    },
    popdown: function() {
        if (!this._isOpen)
            return;
        this._grabHelper.ungrab({ actor: this.actor });
        this._boxPointer.hide(BoxPointer.PopupAnimation.FADE |
                              BoxPointer.PopupAnimation.SLIDE);
        this._isOpen = false;
        this.emit('open-state-changed', false);
    },
    getCloseButtonOverlap: function() {
        return this.closeButton.get_theme_node().get_length('-shell-close-overlap-y');
    },
    getOffset: function (side) {
        let offset = this._boxPointer.getPadding(side);
        if (this._arrowSide == side)
            offset += this._boxPointer.getArrowHeight();
        return offset;
    },
    updateArrowSide: function (side) {
        this._arrowSide = side;
        this._boxPointer.updateArrowSide(side);
    }
Signals.addSignalMethods(AppFolderPopup.prototype);
const AppIcon = new Lang.Class({
    Name: 'AppIcon',
    _init : function(app, iconParams) {
        this.app = app;
        this.id = app.get_id();
        this.name = app.get_name();
        this.actor = new St.Button({ style_class: 'app-well-app',
                                     reactive: true,
                                     button_mask: St.ButtonMask.ONE | St.ButtonMask.TWO,
                                     can_focus: true,
                                     x_fill: true,
                                     y_fill: true });
        this._dot = new St.Widget({ style_class: 'app-well-app-running-dot',
                                    layout_manager: new Clutter.BinLayout(),
                                    x_expand: true, y_expand: true,
                                    x_align: Clutter.ActorAlign.CENTER,
                                    y_align: Clutter.ActorAlign.END });
        this._iconContainer = new St.Widget({ layout_manager: new Clutter.BinLayout(),
                                              x_expand: true, y_expand: true });
        this.actor.set_child(this._iconContainer);
        this._iconContainer.add_child(this._dot);
        this.actor._delegate = this;
        if (!iconParams)
            iconParams = {};
        // Get the isDraggable property without passing it on to the BaseIcon:
        let appIconParams = Params.parse(iconParams, { isDraggable: true }, true);
        let isDraggable = appIconParams['isDraggable'];
        delete iconParams['isDraggable'];
        iconParams['createIcon'] = Lang.bind(this, this._createIcon);
        iconParams['setSizeManually'] = true;
        this.icon = new IconGrid.BaseIcon(app.get_name(), iconParams);
        this._iconContainer.add_child(this.icon.actor);
        this.actor.label_actor = this.icon.label;
        this.actor.connect('leave-event', Lang.bind(this, this._onLeaveEvent));
        this.actor.connect('button-press-event', Lang.bind(this, this._onButtonPress));
        this.actor.connect('touch-event', Lang.bind(this, this._onTouchEvent));
        this.actor.connect('clicked', Lang.bind(this, this._onClicked));
        this.actor.connect('popup-menu', Lang.bind(this, this._onKeyboardPopupMenu));
        this._menu = null;
        this._menuManager = new PopupMenu.PopupMenuManager(this);
        if (isDraggable) {
            this._draggable = DND.makeDraggable(this.actor);
            this._draggable.connect('drag-begin', Lang.bind(this,
                function () {
                    this._removeMenuTimeout();
                    Main.overview.beginItemDrag(this);
                }));
            this._draggable.connect('drag-cancelled', Lang.bind(this,
                function () {
                    Main.overview.cancelledItemDrag(this);
                }));
            this._draggable.connect('drag-end', Lang.bind(this,
                function () {
                   Main.overview.endItemDrag(this);
                }));
        }
        this.actor.connect('destroy', Lang.bind(this, this._onDestroy));
        this._menuTimeoutId = 0;
        this._stateChangedId = this.app.connect('notify::state', Lang.bind(this,
            function () {
                this._updateRunningStyle();
            }));
        this._updateRunningStyle();
    },
    _onDestroy: function() {
        if (this._stateChangedId > 0)
            this.app.disconnect(this._stateChangedId);
        this._stateChangedId = 0;
        this._removeMenuTimeout();
    },
    _createIcon: function(iconSize) {
        return this.app.create_icon_texture(iconSize);
    },
    _removeMenuTimeout: function() {
        if (this._menuTimeoutId > 0) {
            Mainloop.source_remove(this._menuTimeoutId);
            this._menuTimeoutId = 0;
        }
    },
    _updateRunningStyle: function() {
        if (this.app.state != Shell.AppState.STOPPED)
            this._dot.show();
        else
            this._dot.hide();
    },
    _setPopupTimeout: function() {
        this._removeMenuTimeout();
        this._menuTimeoutId = Mainloop.timeout_add(MENU_POPUP_TIMEOUT,
            Lang.bind(this, function() {
                this._menuTimeoutId = 0;
                this.popupMenu();
                return GLib.SOURCE_REMOVE;
            }));
        GLib.Source.set_name_by_id(this._menuTimeoutId, '[gnome-shell] this.popupMenu');
    },
    _onLeaveEvent: function(actor, event) {
        this.actor.fake_release();
        this._removeMenuTimeout();
    },
    _onButtonPress: function(actor, event) {
        let button = event.get_button();
        if (button == 1) {
            this._setPopupTimeout();
        } else if (button == 3) {
            this.popupMenu();
            return Clutter.EVENT_STOP;
        }
        return Clutter.EVENT_PROPAGATE;
    },
    _onTouchEvent: function (actor, event) {
        if (event.type() == Clutter.EventType.TOUCH_BEGIN)
            this._setPopupTimeout();
        return Clutter.EVENT_PROPAGATE;
    },
    _onClicked: function(actor, button) {
        this._removeMenuTimeout();
        this.activate(button);
    },
    _onKeyboardPopupMenu: function() {
        this.popupMenu();
        this._menu.actor.navigate_focus(null, Gtk.DirectionType.TAB_FORWARD, false);
    },
    getId: function() {
        return this.app.get_id();
    },
    popupMenu: function() {
        this._removeMenuTimeout();
        this.actor.fake_release();
        if (this._draggable)
            this._draggable.fakeRelease();
        if (!this._menu) {
            this._menu = new AppIconMenu(this);
            this._menu.connect('activate-window', Lang.bind(this, function (menu, window) {
                this.activateWindow(window);
            }));
            this._menu.connect('open-state-changed', Lang.bind(this, function (menu, isPoppedUp) {
                if (!isPoppedUp)
                    this._onMenuPoppedDown();
            }));
            let id = Main.overview.connect('hiding', Lang.bind(this, function () { this._menu.close(); }));
            this.actor.connect('destroy', function() {
                Main.overview.disconnect(id);
            });
            this._menuManager.addMenu(this._menu);
        }
        this.emit('menu-state-changed', true);
        this.actor.set_hover(true);
        this._menu.popup();
        this._menuManager.ignoreRelease();
        this.emit('sync-tooltip');
        return false;
    },
    activateWindow: function(metaWindow) {
        if (metaWindow) {
            Main.activateWindow(metaWindow);
        } else {
            Main.overview.hide();
        }
    },
    _onMenuPoppedDown: function() {
        this.actor.sync_hover();
        this.emit('menu-state-changed', false);
    },
    activate: function (button) {
        let event = Clutter.get_current_event();
        let modifiers = event ? event.get_state() : 0;
        let openNewWindow = this.app.can_open_new_window () &&
                            modifiers & Clutter.ModifierType.CONTROL_MASK &&
                            this.app.state == Shell.AppState.RUNNING ||
                            button && button == 2;
        if (this.app.state == Shell.AppState.STOPPED || openNewWindow)
            this.animateLaunch();
        if (openNewWindow)
            this.app.open_new_window(-1);
        else
            this.app.activate();
        Main.overview.hide();
    },
    animateLaunch: function() {
        this.icon.animateZoomOut();
    },
    shellWorkspaceLaunch : function(params) {
        params = Params.parse(params, { workspace: -1,
                                        timestamp: 0 });
        this.app.open_new_window(params.workspace);
    },
    getDragActor: function() {
        return this.app.create_icon_texture(Main.overview.dashIconSize);
    },
    // Returns the original actor that should align with the actor
    // we show as the item is being dragged.
    getDragActorSource: function() {
        return this.icon.icon;
    },
    shouldShowTooltip: function() {
        return this.actor.hover && (!this._menu || !this._menu.isOpen);
    },
Signals.addSignalMethods(AppIcon.prototype);
const AppIconMenu = new Lang.Class({
    Name: 'AppIconMenu',
    Extends: PopupMenu.PopupMenu,
    _init: function(source) {
        let side = St.Side.LEFT;
        if (Clutter.get_default_text_direction() == Clutter.TextDirection.RTL)
            side = St.Side.RIGHT;
        this.parent(source.actor, 0.5, side);
        // We want to keep the item hovered while the menu is up
        this.blockSourceEvents = true;
        this._source = source;
        this.actor.add_style_class_name('app-well-menu');
        // Chain our visibility and lifecycle to that of the source
        source.actor.connect('notify::mapped', Lang.bind(this, function () {
            if (!source.actor.mapped)
                this.close();
        }));
        source.actor.connect('destroy', Lang.bind(this, this.destroy));
        Main.uiGroup.add_actor(this.actor);
    },
    _redisplay: function() {
        this.removeAll();
        let windows = this._source.app.get_windows().filter(function(w) {
            return !w.skip_taskbar;
        });
        // Display the app windows menu items and the separator between windows
        // of the current desktop and other windows.
        let activeWorkspace = global.screen.get_active_workspace();
        let separatorShown = windows.length > 0 && windows[0].get_workspace() != activeWorkspace;
        for (let i = 0; i < windows.length; i++) {
            let window = windows[i];
            if (!separatorShown && window.get_workspace() != activeWorkspace) {
                this._appendSeparator();
                separatorShown = true;
            }
            let item = this._appendMenuItem(window.title);
            item.connect('activate', Lang.bind(this, function() {
                this.emit('activate-window', window);
            }));
        }
        if (!this._source.app.is_window_backed()) {
            this._appendSeparator();
            let appInfo = this._source.app.get_app_info();
            let actions = appInfo.list_actions();
            if (this._source.app.can_open_new_window() &&
                actions.indexOf('new-window') == -1) {
                this._newWindowMenuItem = this._appendMenuItem(_("New Window"));
                this._newWindowMenuItem.connect('activate', Lang.bind(this, function() {
                    if (this._source.app.state == Shell.AppState.STOPPED)
                        this._source.animateLaunch();
                    this._source.app.open_new_window(-1);
                    this.emit('activate-window', null);
                }));
                this._appendSeparator();
            }
            if (discreteGpuAvailable &&
                this._source.app.state == Shell.AppState.STOPPED &&
                !this._source.app.app_info.get_boolean('DBusActivatable')) {
                this._onDiscreteGpuMenuItem = this._appendMenuItem(_("Launch using Dedicated Graphics Card"));
                this._onDiscreteGpuMenuItem.connect('activate', Lang.bind(this, function() {
                    if (this._source.app.state != Shell.AppState.STOPPED)
                        return;
                    let context = global.create_app_launch_context(0, -1);
                    context.setenv('DRI_PRIME', '1');
                    this._source.app.launch_context(context);
                    this.emit('activate-window', null);
                }));
            }
            for (let i = 0; i < actions.length; i++) {
                let action = actions[i];
                let item = this._appendMenuItem(appInfo.get_action_name(action));
                item.connect('activate', Lang.bind(this, function(emitter, event) {
                    this._source.app.launch_action(action, event.get_time(), -1);
                    this.emit('activate-window', null);
                }));
            }
            let canFavorite = global.settings.is_writable('favorite-apps');
            if (canFavorite) {
                this._appendSeparator();
                let isFavorite = AppFavorites.getAppFavorites().isFavorite(this._source.app.get_id());
                if (isFavorite) {
                    let item = this._appendMenuItem(_("Remove from Favorites"));
                    item.connect('activate', Lang.bind(this, function() {
                        let favs = AppFavorites.getAppFavorites();
                        favs.removeFavorite(this._source.app.get_id());
                    }));
                } else {
                    let item = this._appendMenuItem(_("Add to Favorites"));
                    item.connect('activate', Lang.bind(this, function() {
                        let favs = AppFavorites.getAppFavorites();
                        favs.addFavorite(this._source.app.get_id());
                    }));
                }
            }
            if (Shell.AppSystem.get_default().lookup_app('org.gnome.Software.desktop')) {
                this._appendSeparator();
                let item = this._appendMenuItem(_("Show Details"));
                item.connect('activate', Lang.bind(this, function() {
                    let id = this._source.app.get_id();
                    let args = GLib.Variant.new('(ss)', [id, '']);
                    Gio.DBus.get(Gio.BusType.SESSION, null,
                        function(o, res) {
                            let bus = Gio.DBus.get_finish(res);
                            bus.call('org.gnome.Software',
                                     '/org/gnome/Software',
                                     'org.gtk.Actions', 'Activate',
                                     GLib.Variant.new('(sava{sv})',
                                                      ['details', [args], null]),
                                     null, 0, -1, null, null);
                            Main.overview.hide();
                        });
                }));
            }
        }
    },
    _appendSeparator: function () {
        let separator = new PopupMenu.PopupSeparatorMenuItem();
        this.addMenuItem(separator);
    },
    _appendMenuItem: function(labelText) {
        // FIXME: app-well-menu-item style
        let item = new PopupMenu.PopupMenuItem(labelText);
        this.addMenuItem(item);
        return item;
    },
    popup: function(activatingButton) {
        this._redisplay();
        this.open();
    }
Signals.addSignalMethods(AppIconMenu.prototype);
(uuay)portalHelper/
search.js
// -*- mode: js; js-indent-level: 4; indent-tabs-mode: nil -*-
const Clutter = imports.gi.Clutter;
const Lang = imports.lang;
const GLib = imports.gi.GLib;
const Gio = imports.gi.Gio;
const Gtk = imports.gi.Gtk;
const Meta = imports.gi.Meta;
const Signals = imports.signals;
const Shell = imports.gi.Shell;
const St = imports.gi.St;
const Atk = imports.gi.Atk;
const AppDisplay = imports.ui.appDisplay;
const DND = imports.ui.dnd;
const IconGrid = imports.ui.iconGrid;
const Main = imports.ui.main;
const Overview = imports.ui.overview;
const RemoteSearch = imports.ui.remoteSearch;
const Separator = imports.ui.separator;
const Util = imports.misc.util;
const SEARCH_PROVIDERS_SCHEMA = 'org.gnome.desktop.search-providers';
const MAX_LIST_SEARCH_RESULTS_ROWS = 3;
const MAX_GRID_SEARCH_RESULTS_ROWS = 1;
const MaxWidthBin = new Lang.Class({
    Name: 'MaxWidthBin',
    Extends: St.Bin,
    vfunc_allocate: function(box, flags) {
        let themeNode = this.get_theme_node();
        let maxWidth = themeNode.get_max_width();
        let availWidth = box.x2 - box.x1;
        let adjustedBox = box;
        if (availWidth > maxWidth) {
            let excessWidth = availWidth - maxWidth;
            adjustedBox.x1 += Math.floor(excessWidth / 2);
            adjustedBox.x2 -= Math.floor(excessWidth / 2);
        }
        this.parent(adjustedBox, flags);
    }
const SearchResult = new Lang.Class({
    Name: 'SearchResult',
    _init: function(provider, metaInfo) {
        this.provider = provider;
        this.metaInfo = metaInfo;
        this.actor = new St.Button({ reactive: true,
                                     can_focus: true,
                                     track_hover: true,
                                     x_align: St.Align.START,
                                     y_fill: true });
        this.actor._delegate = this;
        this.actor.connect('clicked', Lang.bind(this, this.activate));
    },
    activate: function() {
        this.emit('activate', this.metaInfo.id);
    }
Signals.addSignalMethods(SearchResult.prototype);
const ListSearchResult = new Lang.Class({
    Name: 'ListSearchResult',
    Extends: SearchResult,
    ICON_SIZE: 64,
    _init: function(provider, metaInfo) {
        this.parent(provider, metaInfo);
        this.actor.style_class = 'list-search-result';
        this.actor.x_fill = true;
        let content = new St.BoxLayout({ style_class: 'list-search-result-content',
                                         vertical: false });
        this.actor.set_child(content);
        // An icon for, or thumbnail of, content
        let icon = this.metaInfo['createIcon'](this.ICON_SIZE);
        if (icon) {
            content.add(icon);
        }
        let details = new St.BoxLayout({ vertical: true });
        content.add(details, { x_fill: true,
                               y_fill: false,
                               x_align: St.Align.START,
                               y_align: St.Align.MIDDLE });
        let title = new St.Label({ style_class: 'list-search-result-title',
                                   text: this.metaInfo['name'] })
        details.add(title, { x_fill: false,
                             y_fill: false,
                             x_align: St.Align.START,
                             y_align: St.Align.START });
        this.actor.label_actor = title;
        if (this.metaInfo['description']) {
            let description = new St.Label({ style_class: 'list-search-result-description' });
            description.clutter_text.set_markup(this.metaInfo['description']);
            details.add(description, { x_fill: false,
                                       y_fill: false,
                                       x_align: St.Align.START,
                                       y_align: St.Align.END });
        }
    }
const GridSearchResult = new Lang.Class({
    Name: 'GridSearchResult',
    Extends: SearchResult,
    _init: function(provider, metaInfo) {
        this.parent(provider, metaInfo);
        this.actor.style_class = 'grid-search-result';
        this.icon = new IconGrid.BaseIcon(this.metaInfo['name'],
                                          { createIcon: this.metaInfo['createIcon'] });
        let content = new St.Bin({ child: this.icon.actor });
        this.actor.set_child(content);
        this.actor.label_actor = this.icon.label;
    }
const SearchResultsBase = new Lang.Class({
    Name: 'SearchResultsBase',
    _init: function(provider) {
        this.provider = provider;
        this._terms = [];
        this.actor = new St.BoxLayout({ style_class: 'search-section',
                                        vertical: true });
        this._resultDisplayBin = new St.Bin({ x_fill: true,
                                              y_fill: true });
        this.actor.add(this._resultDisplayBin, { expand: true });
        let separator = new Separator.HorizontalSeparator({ style_class: 'search-section-separator' });
        this.actor.add(separator.actor);
        this._resultDisplays = {};
        this._cancellable = new Gio.Cancellable();
    },
    destroy: function() {
        this.actor.destroy();
        this._terms = [];
    },
    _createResultDisplay: function(meta) {
        if (this.provider.createResultObject)
            return this.provider.createResultObject(meta);
        return null;
    },
    clear: function() {
        for (let resultId in this._resultDisplays)
            this._resultDisplays[resultId].actor.destroy();
        this._resultDisplays = {};
        this._clearResultDisplay();
        this.actor.hide();
    },
    _keyFocusIn: function(actor) {
        this.emit('key-focus-in', actor);
    },
    _activateResult: function(result, id) {
        this.provider.activateResult(id, this._terms);
        Main.overview.toggle();
    },
    _setMoreIconVisible: function(visible) {
    },
    _ensureResultActors: function(results, callback) {
        let metasNeeded = results.filter(Lang.bind(this, function(resultId) {
            return this._resultDisplays[resultId] === undefined;
        }));
        if (metasNeeded.length === 0) {
            callback(true);
        } else {
            this._cancellable.cancel();
            this._cancellable.reset();
            this.provider.getResultMetas(metasNeeded, Lang.bind(this, function(metas) {
                if (metas.length != metasNeeded.length) {
                    log('Wrong number of result metas returned by search provider ' + this.provider.id +
                        ': expected ' + metasNeeded.length + ' but got ' + metas.length);
                    callback(false);
                    return;
                }
                if (metas.some(function(meta) {
                    return !meta.name || !meta.id;
                })) {
                    log('Invalid result meta returned from search provider ' + this.provider.id);
                    callback(false);
                    return;
                }
                metasNeeded.forEach(Lang.bind(this, function(resultId, i) {
                    let meta = metas[i];
                    let display = this._createResultDisplay(meta);
                    display.connect('activate', Lang.bind(this, this._activateResult));
                    display.actor.connect('key-focus-in', Lang.bind(this, this._keyFocusIn));
                    this._resultDisplays[resultId] = display;
                }));
                callback(true);
            }), this._cancellable);
        }
    },
    updateSearch: function(providerResults, terms, callback) {
        this._terms = terms;
        if (providerResults.length == 0) {
            this._clearResultDisplay();
            this.actor.hide();
            callback();
        } else {
            let maxResults = this._getMaxDisplayedResults();
            let results = this.provider.filterResults(providerResults, maxResults);
            let hasMoreResults = results.length < providerResults.length;
            this._ensureResultActors(results, Lang.bind(this, function(successful) {
                if (!successful) {
                    this._clearResultDisplay();
                    callback();
                    return;
                }
                // To avoid CSS transitions causing flickering when
                // the first search result stays the same, we hide the
                // content while filling in the results.
                this.actor.hide();
                this._clearResultDisplay();
                results.forEach(Lang.bind(this, function(resultId) {
                    this._addItem(this._resultDisplays[resultId]);
                }));
                this._setMoreIconVisible(hasMoreResults && this.provider.canLaunchSearch);
                this.actor.show();
                callback();
            }));
        }
    }
const ListSearchResults = new Lang.Class({
    Name: 'ListSearchResults',
    Extends: SearchResultsBase,
    _init: function(provider) {
        this.parent(provider);
        this._container = new St.BoxLayout({ style_class: 'search-section-content' });
        this.providerIcon = new ProviderIcon(provider);
        this.providerIcon.connect('key-focus-in', Lang.bind(this, this._keyFocusIn));
        this.providerIcon.connect('clicked', Lang.bind(this,
            function() {
                this.providerIcon.animateLaunch();
                provider.launchSearch(this._terms);
                Main.overview.toggle();
            }));
        this._container.add(this.providerIcon, { x_fill: false,
                                                 y_fill: false,
                                                 x_align: St.Align.START,
                                                 y_align: St.Align.START });
        this._content = new St.BoxLayout({ style_class: 'list-search-results',
                                           vertical: true });
        this._container.add(this._content, { expand: true });
        this._resultDisplayBin.set_child(this._container);
    },
    _setMoreIconVisible: function(visible) {
        this.providerIcon.moreIcon.visible = visible;
    },
    _getMaxDisplayedResults: function() {
        return MAX_LIST_SEARCH_RESULTS_ROWS;
    },
    _clearResultDisplay: function () {
        this._content.remove_all_children();
    },
    _createResultDisplay: function(meta) {
        return this.parent(meta) || new ListSearchResult(this.provider, meta);
    },
    _addItem: function(display) {
        this._content.add_actor(display.actor);
    },
    getFirstResult: function() {
        if (this._content.get_n_children() > 0)
            return this._content.get_child_at_index(0)._delegate;
        else
            return null;
    }
Signals.addSignalMethods(ListSearchResults.prototype);
const GridSearchResults = new Lang.Class({
    Name: 'GridSearchResults',
    Extends: SearchResultsBase,
    _init: function(provider, parentContainer) {
        this.parent(provider);
        // We need to use the parent container to know how much results we can show.
        // None of the actors in this class can be used for that, since the main actor
        // goes hidden when no results are displayed, and then it lost its allocation.
        // Then on the next use of _getMaxDisplayedResults allocation is 0, en therefore
        // it doesn't show any result although we have some.
        this._parentContainer = parentContainer;
        this._grid = new IconGrid.IconGrid({ rowLimit: MAX_GRID_SEARCH_RESULTS_ROWS,
                                             xAlign: St.Align.START });
        this._bin = new St.Bin({ x_align: St.Align.MIDDLE });
        this._bin.set_child(this._grid.actor);
        this._resultDisplayBin.set_child(this._bin);
    },
    _getMaxDisplayedResults: function() {
        let parentThemeNode = this._parentContainer.get_theme_node();
        let availableWidth = parentThemeNode.adjust_for_width(this._parentContainer.width);
        return this._grid.columnsForWidth(availableWidth) * this._grid.getRowLimit();
    },
    _clearResultDisplay: function () {
        this._grid.removeAll();
    },
    _createResultDisplay: function(meta) {
        return this.parent(meta) || new GridSearchResult(this.provider, meta);
    },
    _addItem: function(display) {
        this._grid.addItem(display);
    },
    getFirstResult: function() {
        if (this._grid.visibleItemsCount() > 0)
            return this._grid.getItemAtIndex(0)._delegate;
        else
            return null;
    }
Signals.addSignalMethods(GridSearchResults.prototype);
const SearchResults = new Lang.Class({
    Name: 'SearchResults',
    _init: function() {
        this.actor = new St.BoxLayout({ name: 'searchResults',
                                        vertical: true });
        this._content = new St.BoxLayout({ name: 'searchResultsContent',
                                           vertical: true });
        this._contentBin = new MaxWidthBin({ name: 'searchResultsBin',
                                             x_fill: true,
                                             y_fill: true,
                                             child: this._content });
        let scrollChild = new St.BoxLayout();
        scrollChild.add(this._contentBin, { expand: true });
        this._scrollView = new St.ScrollView({ x_fill: true,
                                               y_fill: false,
                                               overlay_scrollbars: true,
                                               style_class: 'search-display vfade' });
        this._scrollView.set_policy(Gtk.PolicyType.NEVER, Gtk.PolicyType.AUTOMATIC);
        this._scrollView.add_actor(scrollChild);
        let action = new Clutter.PanAction({ interpolate: true });
        action.connect('pan', Lang.bind(this, this._onPan));
        this._scrollView.add_action(action);
        this.actor.add(this._scrollView, { x_fill: true,
                                           y_fill: true,
                                           expand: true,
                                           x_align: St.Align.START,
                                           y_align: St.Align.START });
        this._statusText = new St.Label({ style_class: 'search-statustext' });
        this._statusBin = new St.Bin({ x_align: St.Align.MIDDLE,
                                       y_align: St.Align.MIDDLE });
        this.actor.add(this._statusBin, { expand: true });
        this._statusBin.add_actor(this._statusText);
        this._highlightDefault = false;
        this._defaultResult = null;
        this._startingSearch = false;
        this._terms = [];
        this._results = {};
        this._providers = [];
        this._searchSettings = new Gio.Settings({ schema_id: SEARCH_PROVIDERS_SCHEMA });
        this._searchSettings.connect('changed::disabled', Lang.bind(this, this._reloadRemoteProviders));
        this._searchSettings.connect('changed::enabled', Lang.bind(this, this._reloadRemoteProviders));
        this._searchSettings.connect('changed::disable-external', Lang.bind(this, this._reloadRemoteProviders));
        this._searchSettings.connect('changed::sort-order', Lang.bind(this, this._reloadRemoteProviders));
        this._searchTimeoutId = 0;
        this._cancellable = new Gio.Cancellable();
        this._registerProvider(new AppDisplay.AppSearchProvider());
        this._reloadRemoteProviders();
    },
    _reloadRemoteProviders: function() {
        let remoteProviders = this._providers.filter(function(provider) {
            return provider.isRemoteProvider;
        });
        remoteProviders.forEach(Lang.bind(this, function(provider) {
            this._unregisterProvider(provider);
        }));
        RemoteSearch.loadRemoteSearchProviders(this._searchSettings, Lang.bind(this, function(providers) {
            providers.forEach(Lang.bind(this, this._registerProvider));
        }));
    },
    _registerProvider: function (provider) {
        this._providers.push(provider);
        this._ensureProviderDisplay(provider);
    },
    _unregisterProvider: function (provider) {
        let index = this._providers.indexOf(provider);
        this._providers.splice(index, 1);
        if (provider.display)
            provider.display.destroy();
    },
    _gotResults: function(results, provider) {
        this._results[provider.id] = results;
        this._updateResults(provider, results);
    },
    _clearSearchTimeout: function() {
        if (this._searchTimeoutId > 0) {
            GLib.source_remove(this._searchTimeoutId);
            this._searchTimeoutId = 0;
        }
    },
    _reset: function() {
        this._terms = [];
        this._results = {};
        this._clearDisplay();
        this._clearSearchTimeout();
        this._defaultResult = null;
        this._startingSearch = false;
        this._updateSearchProgress();
    },
    _doSearch: function() {
        this._startingSearch = false;
        let previousResults = this._results;
        this._results = {};
        this._providers.forEach(Lang.bind(this, function(provider) {
            provider.searchInProgress = true;
            let previousProviderResults = previousResults[provider.id];
            if (this._isSubSearch && previousProviderResults)
                provider.getSubsearchResultSet(previousProviderResults, this._terms, Lang.bind(this, this._gotResults, provider), this._cancellable);
            else
                provider.getInitialResultSet(this._terms, Lang.bind(this, this._gotResults, provider), this._cancellable);
        }));
        this._updateSearchProgress();
        this._clearSearchTimeout();
    },
    _onSearchTimeout: function() {
        this._searchTimeoutId = 0;
        this._doSearch();
        return GLib.SOURCE_REMOVE;
    },
    setTerms: function(terms) {
        // Check for the case of making a duplicate previous search before
        // setting state of the current search or cancelling the search.
        // This will prevent incorrect state being as a result of a duplicate
        // search while the previous search is still active.
        let searchString = terms.join(' ');
        let previousSearchString = this._terms.join(' ');
        if (searchString == previousSearchString)
            return;
        this._startingSearch = true;
        this._cancellable.cancel();
        this._cancellable.reset();
        if (terms.length == 0) {
            this._reset();
            return;
        }
        let isSubSearch = false;
        if (this._terms.length > 0)
            isSubSearch = searchString.indexOf(previousSearchString) == 0;
        this._terms = terms;
        this._isSubSearch = isSubSearch;
        this._updateSearchProgress();
        if (this._searchTimeoutId == 0)
            this._searchTimeoutId = GLib.timeout_add(GLib.PRIORITY_DEFAULT, 150, Lang.bind(this, this._onSearchTimeout));
    },
    _onPan: function(action) {
        let [dist, dx, dy] = action.get_motion_delta(0);
        let adjustment = this._scrollView.vscroll.adjustment;
        adjustment.value -= (dy / this.actor.height) * adjustment.page_size;
        return false;
    },
    _keyFocusIn: function(provider, actor) {
        Util.ensureActorVisibleInScrollView(this._scrollView, actor);
    },
    _ensureProviderDisplay: function(provider) {
        if (provider.display)
            return;
        let providerDisplay;
        if (provider.appInfo)
            providerDisplay = new ListSearchResults(provider);
        else
            providerDisplay = new GridSearchResults(provider, this.actor);
        providerDisplay.connect('key-focus-in', Lang.bind(this, this._keyFocusIn));
        providerDisplay.actor.hide();
        this._content.add(providerDisplay.actor);
        provider.display = providerDisplay;
    },
    _clearDisplay: function() {
        this._providers.forEach(function(provider) {
            provider.display.clear();
        });
    },
    _maybeSetInitialSelection: function() {
        let newDefaultResult = null;
        let providers = this._providers;
        for (let i = 0; i < providers.length; i++) {
            let provider = providers[i];
            let display = provider.display;
            if (!display.actor.visible)
                continue;
            let firstResult = display.getFirstResult();
            if (firstResult) {
                newDefaultResult = firstResult;
                break; // select this one!
            }
        }
        if (newDefaultResult != this._defaultResult) {
            this._setSelected(this._defaultResult, false);
            this._setSelected(newDefaultResult, this._highlightDefault);
            this._defaultResult = newDefaultResult;
        }
    },
    get searchInProgress() {
        if (this._startingSearch)
            return true;
        return this._providers.some(function(provider) {
            return provider.searchInProgress;
        });
    },
    _updateSearchProgress: function () {
        let haveResults = this._providers.some(function(provider) {
            let display = provider.display;
            return (display.getFirstResult() != null);
        });
        this._scrollView.visible = haveResults;
        this._statusBin.visible = !haveResults;
        if (!haveResults) {
            if (this.searchInProgress) {
                this._statusText.set_text(_("Searching
"));
            } else {
                this._statusText.set_text(_("No results."));
            }
        }
    },
    _updateResults: function(provider, results) {
        let terms = this._terms;
        let display = provider.display;
        display.updateSearch(results, terms, Lang.bind(this, function() {
            provider.searchInProgress = false;
            this._maybeSetInitialSelection();
            this._updateSearchProgress();
        }));
    },
    activateDefault: function() {
        // If we have a search queued up, force the search now.
        if (this._searchTimeoutId > 0)
            this._doSearch();
        if (this._defaultResult)
            this._defaultResult.activate();
    },
    highlightDefault: function(highlight) {
        this._highlightDefault = highlight;
        this._setSelected(this._defaultResult, highlight);
    },
    navigateFocus: function(direction) {
        let rtl = this.actor.get_text_direction() == Clutter.TextDirection.RTL;
        if (direction == Gtk.DirectionType.TAB_BACKWARD ||
            direction == (rtl ? Gtk.DirectionType.RIGHT
                              : Gtk.DirectionType.LEFT) ||
            direction == Gtk.DirectionType.UP) {
            this.actor.navigate_focus(null, direction, false);
            return;
        }
        let from = this._defaultResult ? this._defaultResult.actor : null;
        this.actor.navigate_focus(from, direction, false);
    },
    _setSelected: function(result, selected) {
        if (!result)
            return;
        if (selected) {
            result.actor.add_style_pseudo_class('selected');
            Util.ensureActorVisibleInScrollView(this._scrollView, result.actor);
        } else {
            result.actor.remove_style_pseudo_class('selected');
        }
    }
const ProviderIcon = new Lang.Class({
    Name: 'ProviderIcon',
    Extends: St.Button,
    PROVIDER_ICON_SIZE: 48,
    _init: function(provider) {
        this.provider = provider;
        this.parent({ style_class: 'search-provider-icon',
                      reactive: true,
                      can_focus: true,
                      accessible_name: provider.appInfo.get_name(),
                      track_hover: true });
        this._content = new St.Widget({ layout_manager: new Clutter.BinLayout() });
        this.set_child(this._content);
        let rtl = (this.get_text_direction() == Clutter.TextDirection.RTL);
        this.moreIcon = new St.Widget({ style_class: 'search-provider-icon-more',
                                        visible: false,
                                        x_align: rtl ? Clutter.ActorAlign.START : Clutter.ActorAlign.END,
                                        y_align: Clutter.ActorAlign.END,
                                        x_expand: true,
                                        y_expand: true });
        let icon = new St.Icon({ icon_size: this.PROVIDER_ICON_SIZE,
                                 gicon: provider.appInfo.get_icon() });
        this._content.add_actor(icon);
        this._content.add_actor(this.moreIcon);
    },
    animateLaunch: function() {
        let appSys = Shell.AppSystem.get_default();
        let app = appSys.lookup_app(this.provider.appInfo.get_id());
        if (app.state == Shell.AppState.STOPPED)
            IconGrid.zoomOutActor(this._content);
    }
(uuay)windowAttentionHandler.js
// -*- mode: js; js-indent-level: 4; indent-tabs-mode: nil -*-
const Lang = imports.lang;
const Shell = imports.gi.Shell;
const Main = imports.ui.main;
const MessageTray = imports.ui.messageTray;
const WindowAttentionHandler = new Lang.Class({
    Name: 'WindowAttentionHandler',
    _init : function() {
        this._tracker = Shell.WindowTracker.get_default();
        this._windowDemandsAttentionId = global.display.connect('window-demands-attention',
                                                                Lang.bind(this, this._onWindowDemandsAttention));
    },
    _getTitleAndBanner: function(app, window) {
        let title = app.get_name();
        let banner = _("
 is ready").format(window.get_title());
        return [title, banner]
    },
    _onWindowDemandsAttention : function(display, window) {
        // We don't want to show the notification when the window is already focused,
        // because this is rather pointless.
        // Some apps (like GIMP) do things like setting the urgency hint on the
        // toolbar windows which would result into a notification even though GIMP itself is
        // focused.
        // We are just ignoring the hint on skip_taskbar windows for now.
        // (Which is the same behaviour as with metacity + panel)
        if (!window || window.has_focus() || window.is_skip_taskbar())
            return;
        let app = this._tracker.get_window_app(window);
        let source = new Source(app, window);
        Main.messageTray.add(source);
        let [title, banner] = this._getTitleAndBanner(app, window);
        let notification = new MessageTray.Notification(source, title, banner);
        notification.connect('activated', function() {
            source.open();
        });
        notification.setForFeedback(true);
        source.notify(notification);
        source.signalIDs.push(window.connect('notify::title', Lang.bind(this, function() {
            let [title, banner] = this._getTitleAndBanner(app, window);
            notification.update(title, banner);
        })));
    }
const Source = new Lang.Class({
    Name: 'WindowAttentionSource',
    Extends: MessageTray.Source,
    _init: function(app, window) {
        this._window = window;
        this._app = app;
        this.parent(app.get_name());
        this.signalIDs = [];
        this.signalIDs.push(this._window.connect('notify::demands-attention', Lang.bind(this, function() { this.destroy(); })));
        this.signalIDs.push(this._window.connect('focus', Lang.bind(this, function() { this.destroy(); })));
        this.signalIDs.push(this._window.connect('unmanaged', Lang.bind(this, function() { this.destroy(); })));
        this.connect('destroy', Lang.bind(this, this._onDestroy));
    },
    _onDestroy : function() {
        for(let i = 0; i < this.signalIDs.length; i++) {
           this._window.disconnect(this.signalIDs[i]);
        }
        this.signalIDs = [];
    },
    createIcon : function(size) {
        return this._app.create_icon_texture(size);
    },
    open: function() {
        Main.activateWindow(this._window);
        this.destroy();
    }
(uuay)extensionUtils.js
// -*- mode: js; js-indent-level: 4; indent-tabs-mode: nil -*-
// Common utils for the extension system and the extension
// preferences tool
const Lang = imports.lang;
const Signals = imports.signals;
const GLib = imports.gi.GLib;
const Gio = imports.gi.Gio;
const ShellJS = imports.gi.ShellJS;
const Config = imports.misc.config;
const FileUtils = imports.misc.fileUtils;
const ExtensionType = {
    SYSTEM: 1,
    PER_USER: 2
// Maps uuid -> metadata object
const extensions = {};
function getCurrentExtension() {
    let stack = (new Error()).stack;
    // Assuming we're importing this directly from an extension (and we shouldn't
    // ever not be), its UUID should be directly in the path here.
    let extensionStackLine = stack.split('\n')[1];
    if (!extensionStackLine)
        throw new Error('Could not find current extension');
    // The stack line is like:
    //   init([object Object])@/home/user/data/gnome-shell/extensions/u@u.id/prefs.js:8
    //
    // In the case that we're importing from
    // module scope, the first field is blank:
    //   @/home/user/data/gnome-shell/extensions/u@u.id/prefs.js:8
    let match = new RegExp('@(.+):\\d+').exec(extensionStackLine);
    if (!match)
        throw new Error('Could not find current extension');
    let path = match[1];
    let file = Gio.File.new_for_path(path);
    // Walk up the directory tree, looking for an extension with
    // the same UUID as a directory name.
    while (file != null) {
        let extension = extensions[file.get_basename()];
        if (extension !== undefined)
            return extension;
        file = file.get_parent();
    }
    throw new Error('Could not find current extension');
 * versionCheck:
 * @required: an array of versions we're compatible with
 * @current: the version we have
 * Check if a component is compatible for an extension.
 * @required is an array, and at least one version must match.
 * @current must be in the format <major>.<minor>.<point>.<micro>
 * <micro> is always ignored
 * <point> is ignored if <minor> is even (so you can target the
 * whole stable release)
 * <minor> and <major> must match
 * Each target version must be at least <major> and <minor>
function versionCheck(required, current) {
    let currentArray = current.split('.');
    let major = currentArray[0];
    let minor = currentArray[1];
    let point = currentArray[2];
    for (let i = 0; i < required.length; i++) {
        let requiredArray = required[i].split('.');
        if (requiredArray[0] == major &&
            requiredArray[1] == minor &&
            (requiredArray[2] == point ||
             (requiredArray[2] == undefined && parseInt(minor) % 2 == 0)))
            return true;
    }
    return false;
function isOutOfDate(extension) {
    if (!versionCheck(extension.metadata['shell-version'], Config.PACKAGE_VERSION))
        return true;
    return false;
function createExtensionObject(uuid, dir, type) {
    let info;
    let metadataFile = dir.get_child('metadata.json');
    if (!metadataFile.query_exists(null)) {
        throw new Error('Missing metadata.json');
    }
    let metadataContents, success, tag;
    try {
        [success, metadataContents, tag] = metadataFile.load_contents(null);
    } catch (e) {
        throw new Error('Failed to load metadata.json: ' + e);
    }
    let meta;
    try {
        meta = JSON.parse(metadataContents);
    } catch (e) {
        throw new Error('Failed to parse metadata.json: ' + e);
    }
    let requiredProperties = ['uuid', 'name', 'description', 'shell-version'];
    for (let i = 0; i < requiredProperties.length; i++) {
        let prop = requiredProperties[i];
        if (!meta[prop]) {
            throw new Error('missing "' + prop + '" property in metadata.json');
        }
    }
    if (uuid != meta.uuid) {
        throw new Error('uuid "' + meta.uuid + '" from metadata.json does not match directory name "' + uuid + '"');
    }
    let extension = {};
    extension.metadata = meta;
    extension.uuid = meta.uuid;
    extension.type = type;
    extension.dir = dir;
    extension.path = dir.get_path();
    extension.error = '';
    extension.hasPrefs = dir.get_child('prefs.js').query_exists(null);
    extensions[uuid] = extension;
    return extension;
var _extension = null;
function installImporter(extension) {
    _extension = extension;
    ShellJS.add_extension_importer('imports.misc.extensionUtils._extension', 'imports', extension.path);
    _extension = null;
const ExtensionFinder = new Lang.Class({
    Name: 'ExtensionFinder',
    _loadExtension: function(extensionDir, info, perUserDir) {
        let fileType = info.get_file_type();
        if (fileType != Gio.FileType.DIRECTORY)
            return;
        let uuid = info.get_name();
        let existing = extensions[uuid];
        if (existing) {
            log('Extension %s already installed in %s. %s will not be loaded'.format(uuid, existing.path, extensionDir.get_path()));
            return;
        }
        let extension;
        let type = extensionDir.has_prefix(perUserDir) ? ExtensionType.PER_USER
                                                       : ExtensionType.SYSTEM;
        try {
            extension = createExtensionObject(uuid, extensionDir, type);
        } catch(e) {
            logError(e, 'Could not load extension %s'.format(uuid));
            return;
        }
        this.emit('extension-found', extension);
    },
    scanExtensions: function() {
        let perUserDir = Gio.File.new_for_path(global.userdatadir);
        FileUtils.collectFromDatadirs('extensions', true, Lang.bind(this, this._loadExtension, perUserDir));
    }
Signals.addSignalMethods(ExtensionFinder.prototype);
(uuay)keyboard.js
// -*- mode: js; js-indent-level: 4; indent-tabs-mode: nil -*-
const Caribou = imports.gi.Caribou;
const Clutter = imports.gi.Clutter;
const Gdk = imports.gi.Gdk;
const Gio = imports.gi.Gio;
const GLib = imports.gi.GLib;
const Lang = imports.lang;
const Meta = imports.gi.Meta;
const Shell = imports.gi.Shell;
const Signals = imports.signals;
const St = imports.gi.St;
const InputSourceManager = imports.ui.status.keyboard;
const BoxPointer = imports.ui.boxpointer;
const Layout = imports.ui.layout;
const Main = imports.ui.main;
const MessageTray = imports.ui.messageTray;
const KEYBOARD_REST_TIME = Layout.KEYBOARD_ANIMATION_TIME * 2 * 1000;
const KEYBOARD_SCHEMA = 'org.gnome.shell.keyboard';
const KEYBOARD_TYPE = 'keyboard-type';
const A11Y_APPLICATIONS_SCHEMA = 'org.gnome.desktop.a11y.applications';
const SHOW_KEYBOARD = 'screen-keyboard-enabled';
const CARIBOU_BUS_NAME = 'org.gnome.Caribou.Daemon';
const CARIBOU_OBJECT_PATH = '/org/gnome/Caribou/Daemon';
const CaribouKeyboardIface = '<node> \
<interface name="org.gnome.Caribou.Keyboard"> \
<method name="Show"> \
    <arg type="u" direction="in" /> \
</method> \
<method name="Hide"> \
    <arg type="u" direction="in" /> \
</method> \
<method name="SetCursorLocation"> \
    <arg type="i" direction="in" /> \
    <arg type="i" direction="in" /> \
    <arg type="i" direction="in" /> \
    <arg type="i" direction="in" /> \
</method> \
<method name="SetEntryLocation"> \
    <arg type="i" direction="in" /> \
    <arg type="i" direction="in" /> \
    <arg type="i" direction="in" /> \
    <arg type="i" direction="in" /> \
</method> \
<property name="Name" access="read" type="s" /> \
</interface> \
</node>';
const CaribouDaemonIface = '<node> \
<interface name="org.gnome.Caribou.Daemon"> \
<method name="Run" /> \
<method name="Quit" /> \
</interface> \
</node>';
const CaribouDaemonProxy = Gio.DBusProxy.makeProxyWrapper(CaribouDaemonIface);
const Key = new Lang.Class({
    Name: 'Key',
    _init : function(key) {
        this._key = key;
        this.actor = this._makeKey(key, GLib.markup_escape_text(key.label, -1));
        this.actor.connect('destroy', Lang.bind(this, this._onDestroy));
        this._extended_keys = this._key.get_extended_keys();
        this._extended_keyboard = null;
        if (this._key.name == 'Control_L' || this._key.name == 'Alt_L')
            this._key.latch = true;
        if (this._extended_keys.length > 0) {
            this._key.connect('notify::show-subkeys', Lang.bind(this, this._onShowSubkeysChanged));
            this._boxPointer = new BoxPointer.BoxPointer(St.Side.BOTTOM,
                                                         { x_fill: true,
                                                           y_fill: true,
                                                           x_align: St.Align.START });
            // Adds style to existing keyboard style to avoid repetition
            this._boxPointer.actor.add_style_class_name('keyboard-subkeys');
            this._getExtendedKeys();
            this.actor._extended_keys = this._extended_keyboard;
            this._boxPointer.actor.hide();
            Main.layoutManager.addChrome(this._boxPointer.actor);
        }
    },
    _onDestroy: function() {
        if (this._boxPointer) {
            this._boxPointer.actor.destroy();
            this._boxPointer = null;
        }
    },
    _makeKey: function (key, label) {
        let button = new St.Button ({ label: label,
                                      style_class: 'keyboard-key' });
        button.key_width = this._key.width;
        button.connect('button-press-event', Lang.bind(this,
            function () {
                key.press();
                return Clutter.EVENT_PROPAGATE;
            }));
        button.connect('button-release-event', Lang.bind(this,
            function () {
                key.release();
                return Clutter.EVENT_PROPAGATE;
            }));
        button.connect('touch-event', Lang.bind(this,
            function (actor, event) {
                let device = event.get_device();
                let sequence = event.get_event_sequence();
                // We only handle touch events here on wayland. On X11
                // we do get emulated pointer events, which already works
                // for single-touch cases. Besides, the X11 passive touch grab
                // set up by Mutter will make us see first the touch events
                // and later the pointer events, so it will look like two
                // unrelated series of events, we want to avoid double handling
                // in these cases.
                if (!Meta.is_wayland_compositor())
                    return Clutter.EVENT_PROPAGATE;
                if (!this._touchPressed &&
                    event.type() == Clutter.EventType.TOUCH_BEGIN) {
                    device.sequence_grab(sequence, actor);
                    this._touchPressed = true;
                    key.press();
                } else if (this._touchPressed &&
                           event.type() == Clutter.EventType.TOUCH_END &&
                           device.sequence_get_grabbed_actor(sequence) == actor) {
                    device.sequence_ungrab(sequence);
                    this._touchPressed = false;
                    key.release();
                }
                return Clutter.EVENT_PROPAGATE;
            }));
        return button;
    },
    _getUnichar: function(key) {
        let keyval = key.keyval;
        let unichar = Gdk.keyval_to_unicode(keyval);
        if (unichar) {
            return String.fromCharCode(unichar);
        } else {
            return key.name;
        }
    },
    _getExtendedKeys: function () {
        this._extended_keyboard = new St.BoxLayout({ style_class: 'keyboard-layout',
                                                     vertical: false });
        for (let i = 0; i < this._extended_keys.length; ++i) {
            let extended_key = this._extended_keys[i];
            let label = this._getUnichar(extended_key);
            let key = this._makeKey(extended_key, label);
            key.extended_key = extended_key;
            this._extended_keyboard.add(key);
        }
        this._boxPointer.bin.add_actor(this._extended_keyboard);
    },
    get subkeys() {
        return this._boxPointer;
    },
    _onShowSubkeysChanged: function () {
        if (this._key.show_subkeys) {
            this._boxPointer.actor.raise_top();
            this._boxPointer.setPosition(this.actor, 0.5);
            this.emit('show-subkeys');
            this.actor.fake_release();
            this.actor.set_hover(false);
        } else {
            this.emit('hide-subkeys');
        }
    }
Signals.addSignalMethods(Key.prototype);
const Keyboard = new Lang.Class({
    // HACK: we can't set Name, because it collides with Name dbus property
    // Name: 'Keyboard',
    _init: function () {
        this._impl = Gio.DBusExportedObject.wrapJSObject(CaribouKeyboardIface, this);
        this._impl.export(Gio.DBus.session, '/org/gnome/Caribou/Keyboard');
        this.actor = null;
        this._focusInTray = false;
        this._focusInExtendedKeys = false;
        this._timestamp = global.display.get_current_time_roundtrip();
        this._keyboardSettings = new Gio.Settings({ schema_id: KEYBOARD_SCHEMA });
        this._keyboardSettings.connect('changed', Lang.bind(this, this._sync));
        this._a11yApplicationsSettings = new Gio.Settings({ schema_id: A11Y_APPLICATIONS_SCHEMA });
        this._a11yApplicationsSettings.connect('changed', Lang.bind(this, this._sync));
        this._daemonProxy = null;
        this._lastDeviceId = null;
        if (Meta.is_wayland_compositor() &&
            Caribou.DisplayAdapter.set_default)
            Caribou.DisplayAdapter.set_default(new ShellWaylandAdapter());
        Meta.get_backend().connect('last-device-changed', Lang.bind(this,
            function (backend, deviceId) {
                let manager = Clutter.DeviceManager.get_default();
                let device = manager.get_device(deviceId);
                if (device.get_device_name().indexOf('XTEST') < 0) {
                    this._lastDeviceId = deviceId;
                    this._sync();
                }
            }));
        this._sync();
        this._showIdleId = 0;
        this._subkeysBoxPointer = null;
        this._capturedEventId = 0;
        this._capturedPress = false;
        this._keyboardVisible = false;
        Main.layoutManager.connect('keyboard-visible-changed', Lang.bind(this, function(o, visible) {
            this._keyboardVisible = visible;
        }));
        this._keyboardRequested = false;
        this._keyboardRestingId = 0;
        Main.layoutManager.connect('monitors-changed', Lang.bind(this, this._redraw));
        this._redraw();
    },
    _lastDeviceIsTouchscreen: function () {
        if (!this._lastDeviceId)
            return false;
        let manager = Clutter.DeviceManager.get_default();
        let device = manager.get_device(this._lastDeviceId);
        if (!device)
            return false;
        return device.get_device_type() == Clutter.InputDeviceType.TOUCHSCREEN_DEVICE;
    },
    _sync: function () {
        this._enableKeyboard = this._a11yApplicationsSettings.get_boolean(SHOW_KEYBOARD) ||
                               this._lastDeviceIsTouchscreen();
        if (!this._enableKeyboard && !this._keyboard)
            return;
        if (this._enableKeyboard && this._keyboard &&
            this._keyboard.keyboard_type == this._keyboardSettings.get_string(KEYBOARD_TYPE))
            return;
        if (this._keyboard)
            this._destroyKeyboard();
        if (this._enableKeyboard)
            this._setupKeyboard();
        else
            Main.layoutManager.hideKeyboard(true);
    },
    _destroyKeyboard: function() {
        if (this._keyboardNotifyId)
            this._keyboard.disconnect(this._keyboardNotifyId);
        if (this._keyboardGroupAddedId)
            this._keyboard.disconnect(this._keyboardGroupAddedId);
        if (this._keyboardGroupRemovedId)
            this._keyboard.disconnect(this._keyboardGroupRemovedId);
        if (this._focusNotifyId)
            global.stage.disconnect(this._focusNotifyId);
        this._keyboard = null;
        this.actor.destroy();
        this.actor = null;
        this._destroySource();
        if (this._daemonProxy) {
            this._daemonProxy.QuitRemote(function (result, error) {
                if (error) {
                    log(error.message);
                    return;
                }
            });
            this._daemonProxy = null;
        }
    },
    _setupKeyboard: function() {
        if (!this._daemonProxy) {
            this._daemonProxy = new CaribouDaemonProxy(Gio.DBus.session, CARIBOU_BUS_NAME,
                                                       CARIBOU_OBJECT_PATH,
                                                       Lang.bind(this, function(proxy, error) {
                                                           if (error) {
                                                               log(error.message);
                                                               return;
                                                           }
                                                       }));
        }
        this._daemonProxy.RunRemote(function (result, error) {
            if (error) {
                log(error.message);
                return;
            }
        });
        this.actor = new St.BoxLayout({ name: 'keyboard', vertical: true, reactive: true });
        Main.layoutManager.keyboardBox.add_actor(this.actor);
        Main.layoutManager.trackChrome(this.actor);
        this._keyboard = new Caribou.KeyboardModel({ keyboard_type: this._keyboardSettings.get_string(KEYBOARD_TYPE) });
        this._groups = {};
        this._current_page = null;
        // Initialize keyboard key measurements
        this._numOfHorizKeys = 0;
        this._numOfVertKeys = 0;
        this._addKeys();
        // Keys should be layout according to the group, not the
        // locale; as Caribou already provides the expected layout,
        // this means enforcing LTR for all locales.
        this.actor.text_direction = Clutter.TextDirection.LTR;
        this._keyboardNotifyId = this._keyboard.connect('notify::active-group', Lang.bind(this, this._onGroupChanged));
        this._keyboardGroupAddedId = this._keyboard.connect('group-added', Lang.bind(this, this._onGroupAdded));
        this._keyboardGroupRemovedId = this._keyboard.connect('group-removed', Lang.bind(this, this._onGroupRemoved));
        this._focusNotifyId = global.stage.connect('notify::key-focus', Lang.bind(this, this._onKeyFocusChanged));
        this._createSource();
    },
    _onKeyFocusChanged: function () {
        let focus = global.stage.key_focus;
        // Showing an extended key popup and clicking a key from the extended keys
        // will grab focus, but ignore that
        let extendedKeysWereFocused = this._focusInExtendedKeys;
        this._focusInExtendedKeys = focus && (focus._extended_keys || focus.extended_key);
        if (this._focusInExtendedKeys || extendedKeysWereFocused)
            return;
        // Ignore focus changes caused by message tray showing/hiding
        let trayWasFocused = this._focusInTray;
        this._focusInTray = (focus && Main.messageTray.actor.contains(focus));
        if (this._focusInTray || trayWasFocused)
            return;
        let time = global.get_current_time();
        if (!(focus instanceof Clutter.Text)) {
            this.Hide(time);
            return;
        }
        if (!this._showIdleId) {
          this._showIdleId = GLib.idle_add(GLib.PRIORITY_DEFAULT_IDLE,
                                           Lang.bind(this, function() {
                                               this.Show(time);
                                               return GLib.SOURCE_REMOVE;
                                           }));
          GLib.Source.set_name_by_id(this._showIdleId, '[gnome-shell] this.Show');
        }
    },
    _createLayersForGroup: function (gname) {
        let group = this._keyboard.get_group(gname);
        group.connect('notify::active-level', Lang.bind(this, this._onLevelChanged));
        let layers = {};
        let levels = group.get_levels();
        for (let j = 0; j < levels.length; ++j) {
            let lname = levels[j];
            let level = group.get_level(lname);
            let layout = new St.BoxLayout({ style_class: 'keyboard-layout',
                                                 vertical: true });
            this._loadRows(level, layout);
            layers[lname] = layout;
            this.actor.add(layout, { x_fill: false });
            layout.hide();
        }
        return layers;
    },
    _addKeys: function () {
        let groups = this._keyboard.get_groups();
        for (let i = 0; i < groups.length; ++i) {
             let gname = groups[i];
             this._groups[gname] = this._createLayersForGroup(gname);
        }
        this._setActiveLayer();
    },
    _onCapturedEvent: function(actor, event) {
        let type = event.type();
        let press = type == Clutter.EventType.BUTTON_PRESS;
        let release = type == Clutter.EventType.BUTTON_RELEASE;
        if (press)
            this._capturedPress = true;
        else if (release && this._capturedPress)
            this._hideSubkeys();
        return Clutter.EVENT_STOP;
    },
    _addRows : function (keys, layout) {
        let keyboard_row = new St.BoxLayout();
        for (let i = 0; i < keys.length; ++i) {
            let children = keys[i].get_children();
            let left_box = new St.BoxLayout({ style_class: 'keyboard-row' });
            let center_box = new St.BoxLayout({ style_class: 'keyboard-row' });
            let right_box = new St.BoxLayout({ style_class: 'keyboard-row' });
            for (let j = 0; j < children.length; ++j) {
                if (this._numOfHorizKeys == 0)
                    this._numOfHorizKeys = children.length;
                let key = children[j];
                let button = new Key(key);
                switch (key.align) {
                case 'right':
                    right_box.add(button.actor);
                    break;
                case 'center':
                    center_box.add(button.actor);
                    break;
                case 'left':
                default:
                    left_box.add(button.actor);
                    break;
                }
                if (key.name == 'Caribou_Prefs') {
                    key.connect('key-released', Lang.bind(this, this.hide));
                }
                button.connect('show-subkeys', Lang.bind(this, function() {
                    if (this._subkeysBoxPointer)
                        this._subkeysBoxPointer.hide(BoxPointer.PopupAnimation.FULL);
                    this._subkeysBoxPointer = button.subkeys;
                    this._subkeysBoxPointer.show(BoxPointer.PopupAnimation.FULL);
                    if (!this._capturedEventId)
                        this._capturedEventId = this.actor.connect('captured-event',
                                                                   Lang.bind(this, this._onCapturedEvent));
                }));
                button.connect('hide-subkeys', Lang.bind(this, function() {
                    this._hideSubkeys();
                }));
            }
            keyboard_row.add(left_box, { expand: true, x_fill: false, x_align: St.Align.START });
            keyboard_row.add(center_box, { expand: true, x_fill: false, x_align: St.Align.MIDDLE });
            keyboard_row.add(right_box, { expand: true, x_fill: false, x_align: St.Align.END });
        }
        layout.add(keyboard_row);
    },
    _loadRows : function (level, layout) {
        let rows = level.get_rows();
        for (let i = 0; i < rows.length; ++i) {
            let row = rows[i];
            if (this._numOfVertKeys == 0)
                this._numOfVertKeys = rows.length;
            this._addRows(row.get_columns(), layout);
        }
    },
    _redraw: function () {
        if (!this._enableKeyboard)
            return;
        let monitor = Main.layoutManager.keyboardMonitor;
        let maxHeight = monitor.height / 3;
        this.actor.width = monitor.width;
        let layout = this._current_page;
        let verticalSpacing = layout.get_theme_node().get_length('spacing');
        let padding = layout.get_theme_node().get_length('padding');
        let box = layout.get_children()[0].get_children()[0];
        let horizontalSpacing = box.get_theme_node().get_length('spacing');
        let allHorizontalSpacing = (this._numOfHorizKeys - 1) * horizontalSpacing;
        let keyWidth = Math.floor((this.actor.width - allHorizontalSpacing - 2 * padding) / this._numOfHorizKeys);
        let allVerticalSpacing = (this._numOfVertKeys - 1) * verticalSpacing;
        let keyHeight = Math.floor((maxHeight - allVerticalSpacing - 2 * padding) / this._numOfVertKeys);
        let keySize = Math.min(keyWidth, keyHeight);
        this.actor.height = keySize * this._numOfVertKeys + allVerticalSpacing + 2 * padding;
        let rows = this._current_page.get_children();
        for (let i = 0; i < rows.length; ++i) {
            let keyboard_row = rows[i];
            let boxes = keyboard_row.get_children();
            for (let j = 0; j < boxes.length; ++j) {
                let keys = boxes[j].get_children();
                for (let k = 0; k < keys.length; ++k) {
                    let child = keys[k];
                    child.width = keySize * child.key_width;
                    child.height = keySize;
                    if (child._extended_keys) {
                        let extended_keys = child._extended_keys.get_children();
                        for (let n = 0; n < extended_keys.length; ++n) {
                            let extended_key = extended_keys[n];
                            extended_key.width = keySize;
                            extended_key.height = keySize;
                        }
                    }
                }
            }
        }
    },
    _onLevelChanged: function () {
        this._setActiveLayer();
        this._redraw();
    },
    _onGroupChanged: function () {
        this._setActiveLayer();
        this._redraw();
    },
    _onGroupAdded: function (keyboard, gname) {
        this._groups[gname] = this._createLayersForGroup(gname);
    },
    _onGroupRemoved: function (keyboard, gname) {
        delete this._groups[gname];
    },
    _setActiveLayer: function () {
        let active_group_name = this._keyboard.active_group;
        let active_group = this._keyboard.get_group(active_group_name);
        let active_level = active_group.active_level;
        let layers = this._groups[active_group_name];
        if (this._current_page != null) {
            this._current_page.hide();
        }
        this._current_page = layers[active_level];
        this._current_page.show();
    },
    _createSource: function () {
        if (this._source == null) {
            this._source = new KeyboardSource(this);
            Main.messageTray.add(this._source);
        }
    },
    _destroySource: function () {
        if (this._source) {
            this._source.destroy();
            this._source = null;
        }
    },
    shouldTakeEvent: function(event) {
        let actor = event.get_source();
        return Main.layoutManager.keyboardBox.contains(actor) ||
               actor._extended_keys || actor.extended_key;
    },
    _clearKeyboardRestTimer: function() {
        if (!this._keyboardRestingId)
            return;
        GLib.source_remove(this._keyboardRestingId);
        this._keyboardRestingId = 0;
    },
    show: function (monitor) {
        this._keyboardRequested = true;
        if (this._keyboardVisible) {
            if (monitor != Main.layoutManager.keyboardIndex) {
                Main.layoutManager.keyboardIndex = monitor;
                this._redraw();
            }
            return;
        }
        this._clearKeyboardRestTimer();
        this._keyboardRestingId = GLib.timeout_add(GLib.PRIORITY_DEFAULT,
                                                   KEYBOARD_REST_TIME,
                                                   Lang.bind(this, function() {
                                                       this._clearKeyboardRestTimer();
                                                       this._show(monitor);
                                                       return GLib.SOURCE_REMOVE;
                                                   }));
        GLib.Source.set_name_by_id(this._keyboardRestingId, '[gnome-shell] this._clearKeyboardRestTimer');
    },
    _show: function(monitor) {
        if (!this._keyboardRequested)
            return;
        Main.layoutManager.keyboardIndex = monitor;
        this._redraw();
        Main.layoutManager.showKeyboard();
        this._destroySource();
    },
    hide: function () {
        this._keyboardRequested = false;
        if (!this._keyboardVisible)
            return;
        this._clearKeyboardRestTimer();
        this._keyboardRestingId = GLib.timeout_add(GLib.PRIORITY_DEFAULT,
                                                   KEYBOARD_REST_TIME,
                                                   Lang.bind(this, function() {
                                                       this._clearKeyboardRestTimer();
                                                       this._hide();
                                                       return GLib.SOURCE_REMOVE;
                                                   }));
        GLib.Source.set_name_by_id(this._keyboardRestingId, '[gnome-shell] this._clearKeyboardRestTimer');
    },
    _hide: function() {
        if (this._keyboardRequested)
            return;
        this._hideSubkeys();
        Main.layoutManager.hideKeyboard();
        this._createSource();
    },
    _hideSubkeys: function() {
        if (this._subkeysBoxPointer) {
            this._subkeysBoxPointer.hide(BoxPointer.PopupAnimation.FULL);
            this._subkeysBoxPointer = null;
        }
        if (this._capturedEventId) {
            this.actor.disconnect(this._capturedEventId);
            this._capturedEventId = 0;
        }
        this._capturedPress = false;
    },
    _moveTemporarily: function () {
        let currentWindow = global.screen.get_display().focus_window;
        let rect = currentWindow.get_frame_rect();
        let newX = rect.x;
        let newY = 3 * this.actor.height / 2;
        currentWindow.move_frame(true, newX, newY);
    },
    _setLocation: function (x, y) {
        if (y >= 2 * this.actor.height)
            this._moveTemporarily();
    },
    // _compareTimestamp:
    //
    // Compare two timestamps taking into account
    // CURRENT_TIME (0)
    _compareTimestamp: function(one, two) {
        if (one == two)
            return 0;
        if (one == Clutter.CURRENT_TIME)
            return 1;
        if (two == Clutter.CURRENT_TIME)
            return -1;
        return one - two;
    },
    _clearShowIdle: function() {
        if (!this._showIdleId)
            return;
        GLib.source_remove(this._showIdleId);
        this._showIdleId = 0;
    },
    // D-Bus methods
    Show: function(timestamp) {
        if (!this._enableKeyboard)
            return;
        if (this._compareTimestamp(timestamp, this._timestamp) < 0)
            return;
        this._clearShowIdle();
        if (timestamp != Clutter.CURRENT_TIME)
            this._timestamp = timestamp;
        this.show(Main.layoutManager.focusIndex);
    },
    Hide: function(timestamp) {
        if (!this._enableKeyboard)
            return;
        if (this._compareTimestamp(timestamp, this._timestamp) < 0)
            return;
        this._clearShowIdle();
        if (timestamp != Clutter.CURRENT_TIME)
            this._timestamp = timestamp;
        this.hide();
    },
    SetCursorLocation: function(x, y, w, h) {
        if (!this._enableKeyboard)
            return;
//        this._setLocation(x, y);
    },
    SetEntryLocation: function(x, y, w, h) {
        if (!this._enableKeyboard)
            return;
//        this._setLocation(x, y);
    },
    get Name() {
        return 'gnome-shell';
    }
const KeyboardSource = new Lang.Class({
    Name: 'KeyboardSource',
    Extends: MessageTray.Source,
    _init: function(keyboard) {
        this._keyboard = keyboard;
        this.parent(_("Keyboard"), 'input-keyboard-symbolic');
        this.keepTrayOnSummaryClick = true;
    },
    handleSummaryClick: function(button) {
        this.open();
        return true;
    },
    open: function() {
        // Show the OSK below the message tray
        this._keyboard.show(Main.layoutManager.bottomIndex);
    }
const ShellWaylandAdapter = new Lang.Class({
    Name: 'ShellWaylandAdapter',
    Extends: Caribou.XAdapter,
    _init: function () {
        this.parent();
        let deviceManager = Clutter.DeviceManager.get_default();
        this._virtualDevice = deviceManager.create_virtual_device(Clutter.InputDeviceType.KEYBOARD_DEVICE);
        this._inputSourceManager = InputSourceManager.getInputSourceManager();
        this._sourceChangedId = this._inputSourceManager.connect('current-source-changed',
                                                                 Lang.bind(this, this._onSourceChanged));
        this._sourcesModifiedId = this._inputSourceManager.connect ('sources-changed',
                                                                    Lang.bind(this, this._onSourcesModified));
    },
    _onSourcesModified: function () {
        this.emit('config-changed');
    },
    _onSourceChanged: function (inputSourceManager, oldSource) {
        let source = inputSourceManager.currentSource;
        this.emit('group-changed', source.index, source.id, '');
    },
    vfunc_get_groups: function () {
        let inputSources = this._inputSourceManager.inputSources;
        let groups = []
        let variants = [];
        for (let i in inputSources) {
            let is = inputSources[i];
            groups[is.index] = is.id;
            variants[is.index] = '';
        }
        return [groups, groups.length, variants, variants.length];
    },
    vfunc_keyval_press: function(keyval) {
        this._virtualDevice.notify_keyval(Clutter.get_current_event_time(),
                                          keyval, Clutter.KeyState.PRESSED);
    },
    vfunc_keyval_release: function(keyval) {
        this._virtualDevice.notify_keyval(Clutter.get_current_event_time(),
                                          keyval, Clutter.KeyState.RELEASED);
    },
(uuay)jsParse.js
/* -*- mode: js2; js2-basic-offset: 4; indent-tabs-mode: nil -*- */
// Returns a list of potential completions for text. Completions either
// follow a dot (e.g. foo.ba -> bar) or they are picked from globalCompletionList (e.g. fo -> foo)
// commandHeader is prefixed on any expression before it is eval'ed.  It will most likely
// consist of global constants that might not carry over from the calling environment.
// This function is likely the one you want to call from external modules
function getCompletions(text, commandHeader, globalCompletionList) {
    let methods = [];
    let expr, base;
    let attrHead = '';
    if (globalCompletionList == null) {
        globalCompletionList = [];
    }
    let offset = getExpressionOffset(text, text.length - 1);
    if (offset >= 0) {
        text = text.slice(offset);
        // Look for expressions like "Main.panel.foo" and match Main.panel and foo
        let matches = text.match(/(.*)\.(.*)/);
        if (matches) {
            [expr, base, attrHead] = matches;
            methods = getPropertyNamesFromExpression(base, commandHeader).filter(function(attr) {
                return attr.slice(0, attrHead.length) == attrHead;
            });
        }
        // Look for the empty expression or partially entered words
        // not proceeded by a dot and match them against global constants
        matches = text.match(/^(\w*)$/);
        if (text == '' || matches) {
            [expr, attrHead] = matches;
            methods = globalCompletionList.filter(function(attr) {
                return attr.slice(0, attrHead.length) == attrHead;
            });
        }
    }
    return [methods, attrHead];
// A few functions for parsing strings of javascript code.
// Identify characters that delimit an expression.  That is,
// if we encounter anything that isn't a letter, '.', ')', or ']',
// we should stop parsing.
function isStopChar(c) {
    return !c.match(/[\w\.\)\]]/);
// Given the ending position of a quoted string, find where it starts
function findMatchingQuote(expr, offset) {
    let quoteChar = expr.charAt(offset);
    for (let i = offset - 1; i >= 0; --i) {
        if (expr.charAt(i) == quoteChar && expr.charAt(i-1) != '\\'){
            return i;
        }
    }
    return -1;
// Given the ending position of a regex, find where it starts
function findMatchingSlash(expr, offset) {
    for (let i = offset - 1; i >= 0; --i) {
        if (expr.charAt(i) == '/' && expr.charAt(i-1) != '\\'){
            return i;
        }
    }
    return -1;
// If expr.charAt(offset) is ')' or ']',
// return the position of the corresponding '(' or '[' bracket.
// This function does not check for syntactic correctness.  e.g.,
// findMatchingBrace("[(])", 3) returns 1.
function findMatchingBrace(expr, offset) {
    let closeBrace = expr.charAt(offset);
    let openBrace = ({')': '(', ']': '['})[closeBrace];
    function findTheBrace(expr, offset) {
        if (offset < 0) {
            return -1;
        }
        if (expr.charAt(offset) == openBrace) {
            return offset;
        }
        if (expr.charAt(offset).match(/['"]/)) {
            return findTheBrace(expr, findMatchingQuote(expr, offset) - 1);
        }
        if (expr.charAt(offset) == '/') {
            return findTheBrace(expr, findMatchingSlash(expr, offset) - 1);
        }
        if (expr.charAt(offset) == closeBrace) {
            return findTheBrace(expr, findTheBrace(expr, offset - 1) - 1);
        }
        return findTheBrace(expr, offset - 1);
    }
    return findTheBrace(expr, offset - 1);
// Walk expr backwards from offset looking for the beginning of an
// expression suitable for passing to eval.
// There is no guarantee of correct javascript syntax between the return
// value and offset.  This function is meant to take a string like
// "foo(Obj.We.Are.Completing" and allow you to extract "Obj.We.Are.Completing"
function getExpressionOffset(expr, offset) {
    while (offset >= 0) {
        let currChar = expr.charAt(offset);
        if (isStopChar(currChar)){
            return offset + 1;
        }
        if (currChar.match(/[\)\]]/)) {
            offset = findMatchingBrace(expr, offset);
        }
        --offset;
    }
    return offset + 1;
// Things with non-word characters or that start with a number
// are not accessible via .foo notation and so aren't returned
function isValidPropertyName(w) {
    return !(w.match(/\W/) || w.match(/^\d/));
// To get all properties (enumerable and not), we need to walk
// the prototype chain ourselves
function getAllProps(obj) {
    if (obj === null || obj === undefined) {
        return [];
    }
    return Object.getOwnPropertyNames(obj).concat( getAllProps(Object.getPrototypeOf(obj)) );
// Given a string _expr_, returns all methods
// that can be accessed via '.' notation.
// e.g., expr="({ foo: null, bar: null, 4: null })" will
// return ["foo", "bar", ...] but the list will not include "4",
// since methods accessed with '.' notation must star with a letter or _.
function getPropertyNamesFromExpression(expr, commandHeader) {
    if (commandHeader == null) {
        commandHeader = '';
    }
    let obj = {};
    if (!isUnsafeExpression(expr)) {
        try {
                obj = eval(commandHeader + expr);
        } catch (e) {
            return [];
        }
    } else {
        return [];
    }
    let propsUnique = {};
    if (typeof obj === 'object'){
        let allProps = getAllProps(obj);
        // Get only things we are allowed to complete following a '.'
        allProps = allProps.filter( isValidPropertyName );
        // Make sure propsUnique contains one key for every
        // property so we end up with a unique list of properties
        allProps.map(function(p){ propsUnique[p] = null; });
    }
    return Object.keys(propsUnique).sort();
// Given a list of words, returns the longest prefix they all have in common
function getCommonPrefix(words) {
    let word = words[0];
    for (let i = 0; i < word.length; i++) {
        for (let w = 1; w < words.length; w++) {
            if (words[w].charAt(i) != word.charAt(i))
                return word.slice(0, i);
        }
    }
    return word;
// Returns true if there is reason to think that eval(str)
// will modify the global scope
function isUnsafeExpression(str) {
    // Remove any blocks that are quoted or are in a regex
    function removeLiterals(str) {
        if (str.length == 0) {
            return '';
        }
        let currChar = str.charAt(str.length - 1);
        if (currChar == '"' || currChar == '\'') {
            return removeLiterals(str.slice(0, findMatchingQuote(str, str.length - 1)));
        } else if (currChar == '/') {
            return removeLiterals(str.slice(0, findMatchingSlash(str, str.length - 1)));
        }
        return removeLiterals(str.slice(0, str.length - 1)) + currChar;
    }
    // Check for any sort of assignment
    // The strategy used is dumb: remove any quotes
    // or regexs and comparison operators and see if there is an '=' character.
    // If there is, it might be an unsafe assignment.
    let prunedStr = removeLiterals(str);
    prunedStr = prunedStr.replace(/[=!]==/g, '');    //replace === and !== with nothing
    prunedStr = prunedStr.replace(/[=<>!]=/g, '');    //replace ==, <=, >=, != with nothing
    if (prunedStr.match(/=/)) {
        return true;
    } else if (prunedStr.match(/;/)) {
        // If we contain a semicolon not inside of a quote/regex, assume we're unsafe as well
        return true;
    }
    return false;
// Returns a list of global keywords derived from str
function getDeclaredConstants(str) {
    let ret = [];
    str.split(';').forEach(function(s) {
        let base, keyword;
        let match = s.match(/const\s+(\w+)\s*=/);
        if (match) {
            [base, keyword] = match;
            ret.push(keyword);
        }
    });
    return ret;
(uuay)power.js
// -*- mode: js; js-indent-level: 4; indent-tabs-mode: nil -*-
const Gio = imports.gi.Gio;
const Clutter = imports.gi.Clutter;
const St = imports.gi.St;
const Lang = imports.lang;
const UPower = imports.gi.UPowerGlib;
const Main = imports.ui.main;
const PanelMenu = imports.ui.panelMenu;
const PopupMenu = imports.ui.popupMenu;
const BUS_NAME = 'org.freedesktop.UPower';
const OBJECT_PATH = '/org/freedesktop/UPower/devices/DisplayDevice';
const DisplayDeviceInterface = '<node> \
<interface name="org.freedesktop.UPower.Device"> \
  <property name="Type" type="u" access="read"/> \
  <property name="State" type="u" access="read"/> \
  <property name="Percentage" type="d" access="read"/> \
  <property name="TimeToEmpty" type="x" access="read"/> \
  <property name="TimeToFull" type="x" access="read"/> \
  <property name="IsPresent" type="b" access="read"/> \
  <property name="IconName" type="s" access="read"/> \
</interface> \
</node>';
const PowerManagerProxy = Gio.DBusProxy.makeProxyWrapper(DisplayDeviceInterface);
const SHOW_BATTERY_PERCENTAGE       = 'show-battery-percentage';
const Indicator = new Lang.Class({
    Name: 'PowerIndicator',
    Extends: PanelMenu.SystemIndicator,
    _init: function() {
        this.parent();
        this._desktopSettings = new Gio.Settings({ schema_id: 'org.gnome.desktop.interface' });
        this._desktopSettings.connect('changed::' + SHOW_BATTERY_PERCENTAGE,
                                      Lang.bind(this, this._sync));
        this._indicator = this._addIndicator();
        this._percentageLabel = new St.Label({ y_expand: true,
                                               y_align: Clutter.ActorAlign.CENTER });
        this.indicators.add(this._percentageLabel, { expand: true, y_fill: true });
        this.indicators.add_style_class_name('power-status');
        this._proxy = new PowerManagerProxy(Gio.DBus.system, BUS_NAME, OBJECT_PATH,
                                            Lang.bind(this, function(proxy, error) {
                                                if (error) {
                                                    log(error.message);
                                                    return;
                                                }
                                                this._proxy.connect('g-properties-changed',
                                                                    Lang.bind(this, this._sync));
                                                this._sync();
                                            }));
        this._item = new PopupMenu.PopupSubMenuMenuItem("", true);
        this._item.menu.addSettingsAction(_("Power Settings"), 'gnome-power-panel.desktop');
        this.menu.addMenuItem(this._item);
        Main.sessionMode.connect('updated', Lang.bind(this, this._sessionUpdated));
        this._sessionUpdated();
    },
    _sessionUpdated: function() {
        let sensitive = !Main.sessionMode.isLocked && !Main.sessionMode.isGreeter;
        this.menu.setSensitive(sensitive);
    },
    _getStatus: function() {
        let seconds = 0;
        if (this._proxy.State == UPower.DeviceState.FULLY_CHARGED)
            return _("Fully Charged");
        else if (this._proxy.State == UPower.DeviceState.CHARGING)
            seconds = this._proxy.TimeToFull;
        else if (this._proxy.State == UPower.DeviceState.DISCHARGING)
            seconds = this._proxy.TimeToEmpty;
        // state is one of PENDING_CHARGING, PENDING_DISCHARGING
        else
            return _("Estimating
        let time = Math.round(seconds / 60);
        if (time == 0) {
            // 0 is reported when UPower does not have enough data
            // to estimate battery life
            return _("Estimating
        }
        let minutes = time % 60;
        let hours = Math.floor(time / 60);
        if (this._proxy.State == UPower.DeviceState.DISCHARGING) {
            // Translators: this is <hours>:<minutes> Remaining (<percentage>)
            return _("%d\u2236%02d Remaining (%d\u2009%%)").format(hours, minutes, this._proxy.Percentage);
        }
        if (this._proxy.State == UPower.DeviceState.CHARGING) {
            // Translators: this is <hours>:<minutes> Until Full (<percentage>)
            return _("%d\u2236%02d Until Full (%d\u2009%%)").format(hours, minutes, this._proxy.Percentage);
        }
        return null;
    },
    _sync: function() {
        // Do we have batteries or a UPS?
        let visible = this._proxy.IsPresent;
        if (visible) {
            this._item.actor.show();
            this._percentageLabel.visible = this._desktopSettings.get_boolean(SHOW_BATTERY_PERCENTAGE);
        } else {
            // If there's no battery, then we use the power icon.
            this._item.actor.hide();
            this._indicator.icon_name = 'system-shutdown-symbolic';
            this._percentageLabel.hide();
            return;
        }
        // The icons
        let icon = this._proxy.IconName;
        this._indicator.icon_name = icon;
        this._item.icon.icon_name = icon;
        // The icon label
        let label
        if (this._proxy.State == UPower.DeviceState.FULLY_CHARGED)
          label = _("%d\u2009%%").format(100);
        else
          label = _("%d\u2009%%").format(this._proxy.Percentage);
        this._percentageLabel.clutter_text.set_markup('<span size="smaller">' + label + '</span>');
        // The status label
        this._item.label.text = this._getStatus();
    },
(uuay)lightbox.js
// -*- mode: js; js-indent-level: 4; indent-tabs-mode: nil -*-
const Clutter = imports.gi.Clutter;
const Lang = imports.lang;
const Meta = imports.gi.Meta;
const Signals = imports.signals;
const St = imports.gi.St;
const Shell = imports.gi.Shell;
const Params = imports.misc.params;
const Tweener = imports.ui.tweener;
const DEFAULT_FADE_FACTOR = 0.4;
const VIGNETTE_BRIGHTNESS = 0.8;
const VIGNETTE_SHARPNESS = 0.7;
const VIGNETTE_DECLARATIONS = '\
uniform float brightness;\n\
uniform float vignette_sharpness;\n';
const VIGNETTE_CODE = '\
cogl_color_out.a = cogl_color_in.a;\n\
cogl_color_out.rgb = vec3(0.0, 0.0, 0.0);\n\
vec2 position = cogl_tex_coord_in[0].xy - 0.5;\n\
float t = length(2.0 * position);\n\
t = clamp(t, 0.0, 1.0);\n\
float pixel_brightness = mix(1.0, 1.0 - vignette_sharpness, t);\n\
cogl_color_out.a = cogl_color_out.a * (1 - pixel_brightness * brightness);';
const RadialShaderQuad = new Lang.Class({
    Name: 'RadialShaderQuad',
    Extends: Shell.GLSLQuad,
    _init: function(params) {
        this.parent(params);
        this._brightnessLocation = this.get_uniform_location('brightness');
        this._sharpnessLocation = this.get_uniform_location('vignette_sharpness');
        this.brightness = 1.0;
        this.vignetteSharpness = 0.0;
    },
    vfunc_build_pipeline: function() {
        this.add_glsl_snippet(Shell.SnippetHook.FRAGMENT,
                              VIGNETTE_DECLARATIONS, VIGNETTE_CODE, true);
    },
    get brightness() {
        return this._brightness;
    },
    set brightness(v) {
        this._brightness = v;
        this.set_uniform_float(this._brightnessLocation,
                               1, [this._brightness]);
    },
    get vignetteSharpness() {
        return this._sharpness;
    },
    set vignetteSharpness(v) {
        this._sharpness = v;
        this.set_uniform_float(this._sharpnessLocation,
                               1, [this._sharpness]);
    }
 * Lightbox:
 * @container: parent Clutter.Container
 * @params: (optional) additional parameters:
 *           - inhibitEvents: whether to inhibit events for @container
 *           - width: shade actor width
 *           - height: shade actor height
 *           - fadeInTime: seconds used to fade in
 *           - fadeOutTime: seconds used to fade out
 * Lightbox creates a dark translucent "shade" actor to hide the
 * contents of @container, and allows you to specify particular actors
 * in @container to highlight by bringing them above the shade. It
 * tracks added and removed actors in @container while the lightboxing
 * is active, and ensures that all actors are returned to their
 * original stacking order when the lightboxing is removed. (However,
 * if actors are restacked by outside code while the lightboxing is
 * active, the lightbox may later revert them back to their original
 * order.)
 * By default, the shade window will have the height and width of
 * @container and will track any changes in its size. You can override
 * this by passing an explicit width and height in @params.
const Lightbox = new Lang.Class({
    Name: 'Lightbox',
    _init : function(container, params) {
        params = Params.parse(params, { inhibitEvents: false,
                                        width: null,
                                        height: null,
                                        fadeFactor: DEFAULT_FADE_FACTOR,
                                        radialEffect: false,
                                      });
        this._container = container;
        this._children = container.get_children();
        this._fadeFactor = params.fadeFactor;
        this._radialEffect = Clutter.feature_available(Clutter.FeatureFlags.SHADERS_GLSL) && params.radialEffect;
        if (this._radialEffect)
            this.actor = new RadialShaderQuad({ x: 0,
                                                y: 0,
                                                reactive: params.inhibitEvents });
        else
            this.actor = new St.Bin({ x: 0,
                                      y: 0,
                                      opacity: 0,
                                      style_class: 'lightbox',
                                      reactive: params.inhibitEvents });
        container.add_actor(this.actor);
        this.actor.raise_top();
        this.actor.hide();
        this.shown = false;
        this.actor.connect('destroy', Lang.bind(this, this._onDestroy));
        if (params.width && params.height) {
            this.actor.width = params.width;
            this.actor.height = params.height;
        } else {
            let constraint = new Clutter.BindConstraint({ source: container,
                                                          coordinate: Clutter.BindCoordinate.ALL });
            this.actor.add_constraint(constraint);
        }
        this._actorAddedSignalId = container.connect('actor-added', Lang.bind(this, this._actorAdded));
        this._actorRemovedSignalId = container.connect('actor-removed', Lang.bind(this, this._actorRemoved));
        this._highlighted = null;
    },
    _actorAdded : function(container, newChild) {
        let children = this._container.get_children();
        let myIndex = children.indexOf(this.actor);
        let newChildIndex = children.indexOf(newChild);
        if (newChildIndex > myIndex) {
            // The child was added above the shade (presumably it was
            // made the new top-most child). Move it below the shade,
            // and add it to this._children as the new topmost actor.
            newChild.lower(this.actor);
            this._children.push(newChild);
        } else if (newChildIndex == 0) {
            // Bottom of stack
            this._children.unshift(newChild);
        } else {
            // Somewhere else; insert it into the correct spot
            let prevChild = this._children.indexOf(children[newChildIndex - 1]);
            if (prevChild != -1) // paranoia
                this._children.splice(prevChild + 1, 0, newChild);
        }
    },
    show: function(fadeInTime) {
        fadeInTime = fadeInTime || 0;
        Tweener.removeTweens(this.actor);
        if (this._radialEffect) {
            Tweener.addTween(this.actor,
                             { brightness: VIGNETTE_BRIGHTNESS,
                               vignetteSharpness: VIGNETTE_SHARPNESS,
                               time: fadeInTime,
                               transition: 'easeOutQuad',
                               onComplete: Lang.bind(this, function() {
                                   this.shown = true;
                                   this.emit('shown');
                               })
                             });
        } else {
            Tweener.addTween(this.actor,
                             { opacity: 255 * this._fadeFactor,
                               time: fadeInTime,
                               transition: 'easeOutQuad',
                               onComplete: Lang.bind(this, function() {
                                   this.shown = true;
                                   this.emit('shown');
                               })
                             });
        }
        this.actor.show();
    },
    hide: function(fadeOutTime) {
        fadeOutTime = fadeOutTime || 0;
        this.shown = false;
        Tweener.removeTweens(this.actor);
        if (this._radialEffect) {
            Tweener.addTween(this.actor,
                             { brightness: 1.0,
                               vignetteSharpness: 0.0,
                               opacity: 0,
                               time: fadeOutTime,
                               transition: 'easeOutQuad',
                               onComplete: Lang.bind(this, function() {
                                   this.actor.hide();
                               })
                             });
        } else {
            Tweener.addTween(this.actor,
                             { opacity: 0,
                               time: fadeOutTime,
                               transition: 'easeOutQuad',
                               onComplete: Lang.bind(this, function() {
                                   this.actor.hide();
                               })
                             });
        }
    },
    _actorRemoved : function(container, child) {
        let index = this._children.indexOf(child);
        if (index != -1) // paranoia
            this._children.splice(index, 1);
        if (child == this._highlighted)
            this._highlighted = null;
    },
    /**
     * highlight:
     * @window: actor to highlight
     *
     * Highlights the indicated actor and unhighlights any other
     * currently-highlighted actor. With no arguments or a false/null
     * argument, all actors will be unhighlighted.
     */
    highlight : function(window) {
        if (this._highlighted == window)
            return;
        // Walk this._children raising and lowering actors as needed.
        // Things get a little tricky if the to-be-raised and
        // to-be-lowered actors were originally adjacent, in which
        // case we may need to indicate some *other* actor as the new
        // sibling of the to-be-lowered one.
        let below = this.actor;
        for (let i = this._children.length - 1; i >= 0; i--) {
            if (this._children[i] == window)
                this._children[i].raise_top();
            else if (this._children[i] == this._highlighted)
                this._children[i].lower(below);
            else
                below = this._children[i];
        }
        this._highlighted = window;
    },
    /**
     * destroy:
     *
     * Destroys the lightbox.
     */
    destroy : function() {
        this.actor.destroy();
    },
    /**
     * _onDestroy:
     *
     * This is called when the lightbox' actor is destroyed, either
     * by destroying its container or by explicitly calling this.destroy().
     */
    _onDestroy: function() {
        this._container.disconnect(this._actorAddedSignalId);
        this._container.disconnect(this._actorRemovedSignalId);
        this.highlight(null);
    }
Signals.addSignalMethods(Lightbox.prototype);
(uuay)extensionSystem.js
// -*- mode: js; js-indent-level: 4; indent-tabs-mode: nil -*-
const Lang = imports.lang;
const Signals = imports.signals;
const GLib = imports.gi.GLib;
const Gio = imports.gi.Gio;
const St = imports.gi.St;
const ExtensionUtils = imports.misc.extensionUtils;
const Main = imports.ui.main;
const ExtensionState = {
    ENABLED: 1,
    DISABLED: 2,
    ERROR: 3,
    OUT_OF_DATE: 4,
    DOWNLOADING: 5,
    INITIALIZED: 6,
    // Used as an error state for operations on unknown extensions,
    // should never be in a real extensionMeta object.
    UNINSTALLED: 99
// Arrays of uuids
var enabledExtensions;
// Contains the order that extensions were enabled in.
const extensionOrder = [];
// We don't really have a class to add signals on. So, create
// a simple dummy object, add the signal methods, and export those
// publically.
var _signals = {};
Signals.addSignalMethods(_signals);
const connect = Lang.bind(_signals, _signals.connect);
const disconnect = Lang.bind(_signals, _signals.disconnect);
const ENABLED_EXTENSIONS_KEY = 'enabled-extensions';
const EXTENSION_DISABLE_VERSION_CHECK_KEY = 'disable-extension-version-validation';
var initted = false;
var enabled;
function disableExtension(uuid) {
    let extension = ExtensionUtils.extensions[uuid];
    if (!extension)
        return;
    if (extension.state != ExtensionState.ENABLED)
        return;
    // "Rebase" the extension order by disabling and then enabling extensions
    // in order to help prevent conflicts.
    // Example:
    //   order = [A, B, C, D, E]
    //   user disables C
    //   this should: disable E, disable D, disable C, enable D, enable E
    let orderIdx = extensionOrder.indexOf(uuid);
    let order = extensionOrder.slice(orderIdx + 1);
    let orderReversed = order.slice().reverse();
    for (let i = 0; i < orderReversed.length; i++) {
        let uuid = orderReversed[i];
        try {
            ExtensionUtils.extensions[uuid].stateObj.disable();
        } catch(e) {
            logExtensionError(uuid, e);
        }
    }
    if (extension.stylesheet) {
        let theme = St.ThemeContext.get_for_stage(global.stage).get_theme();
        theme.unload_stylesheet(extension.stylesheet);
    }
    try {
        extension.stateObj.disable();
    } catch(e) {
        logExtensionError(uuid, e);
    }
    for (let i = 0; i < order.length; i++) {
        let uuid = order[i];
        try {
            ExtensionUtils.extensions[uuid].stateObj.enable();
        } catch(e) {
            logExtensionError(uuid, e);
        }
    }
    extensionOrder.splice(orderIdx, 1);
    if ( extension.state != ExtensionState.ERROR ) {
        extension.state = ExtensionState.DISABLED;
        _signals.emit('extension-state-changed', extension);
    }
function enableExtension(uuid) {
    let extension = ExtensionUtils.extensions[uuid];
    if (!extension)
        return;
    if (extension.state == ExtensionState.INITIALIZED)
        initExtension(uuid);
    if (extension.state != ExtensionState.DISABLED)
        return;
    extensionOrder.push(uuid);
    let stylesheetNames = [global.session_mode + '.css', 'stylesheet.css'];
    for (let i = 0; i < stylesheetNames.length; i++) {
        let stylesheetFile = extension.dir.get_child(stylesheetNames[i]);
        if (stylesheetFile.query_exists(null)) {
            let theme = St.ThemeContext.get_for_stage(global.stage).get_theme();
            theme.load_stylesheet(stylesheetFile);
            extension.stylesheet = stylesheetFile;
            break;
        }
    }
    try {
        extension.stateObj.enable();
        extension.state = ExtensionState.ENABLED;
        _signals.emit('extension-state-changed', extension);
        return;
    } catch(e) {
        logExtensionError(uuid, e);
        return;
    }
function logExtensionError(uuid, error) {
    let extension = ExtensionUtils.extensions[uuid];
    if (!extension)
        return;
    let message = '' + error;
    extension.state = ExtensionState.ERROR;
    if (!extension.errors)
        extension.errors = [];
    extension.errors.push(message);
    log('Extension "%s" had error: %s'.format(uuid, message));
    _signals.emit('extension-state-changed', { uuid: uuid,
                                               error: message,
                                               state: extension.state });
function loadExtension(extension) {
    // Default to error, we set success as the last step
    extension.state = ExtensionState.ERROR;
    let checkVersion = !global.settings.get_boolean(EXTENSION_DISABLE_VERSION_CHECK_KEY);
    if (checkVersion && ExtensionUtils.isOutOfDate(extension)) {
        extension.state = ExtensionState.OUT_OF_DATE;
    } else {
        let enabled = enabledExtensions.indexOf(extension.uuid) != -1;
        if (enabled) {
            if (!initExtension(extension.uuid))
                return;
            if (extension.state == ExtensionState.DISABLED)
                enableExtension(extension.uuid);
        } else {
            extension.state = ExtensionState.INITIALIZED;
        }
    }
    _signals.emit('extension-state-changed', extension);
function unloadExtension(extension) {
    // Try to disable it -- if it's ERROR'd, we can't guarantee that,
    // but it will be removed on next reboot, and hopefully nothing
    // broke too much.
    disableExtension(extension.uuid);
    extension.state = ExtensionState.UNINSTALLED;
    _signals.emit('extension-state-changed', extension);
    delete ExtensionUtils.extensions[extension.uuid];
    return true;
function reloadExtension(oldExtension) {
    // Grab the things we'll need to pass to createExtensionObject
    // to reload it.
    let { uuid: uuid, dir: dir, type: type } = oldExtension;
    // Then unload the old extension.
    unloadExtension(oldExtension);
    // Now, recreate the extension and load it.
    let newExtension = ExtensionUtils.createExtensionObject(uuid, dir, type);
    loadExtension(newExtension);
function initExtension(uuid) {
    let extension = ExtensionUtils.extensions[uuid];
    let dir = extension.dir;
    if (!extension)
        throw new Error("Extension was not properly created. Call loadExtension first");
    let extensionJs = dir.get_child('extension.js');
    if (!extensionJs.query_exists(null))
        throw new Error('Missing extension.js');
    let extensionModule;
    let extensionState = null;
    ExtensionUtils.installImporter(extension);
    extensionModule = extension.imports.extension;
    if (extensionModule.init) {
        try {
            extensionState = extensionModule.init(extension);
        } catch(e) {
            logExtensionError(uuid, e);
            return false;
        }
    }
    if (!extensionState)
        extensionState = extensionModule;
    extension.stateObj = extensionState;
    extension.state = ExtensionState.DISABLED;
    _signals.emit('extension-loaded', uuid);
    return true;
function getEnabledExtensions() {
    let extensions = global.settings.get_strv(ENABLED_EXTENSIONS_KEY);
    if (!Array.isArray(Main.sessionMode.enabledExtensions))
        return extensions;
    return Main.sessionMode.enabledExtensions.concat(extensions);
function onEnabledExtensionsChanged() {
    let newEnabledExtensions = getEnabledExtensions();
    if (!enabled)
        return;
    // Find and enable all the newly enabled extensions: UUIDs found in the
    // new setting, but not in the old one.
    newEnabledExtensions.filter(function(uuid) {
        return enabledExtensions.indexOf(uuid) == -1;
    }).forEach(function(uuid) {
        enableExtension(uuid);
    });
    // Find and disable all the newly disabled extensions: UUIDs found in the
    // old setting, but not in the new one.
    enabledExtensions.filter(function(item) {
        return newEnabledExtensions.indexOf(item) == -1;
    }).forEach(function(uuid) {
        disableExtension(uuid);
    });
    enabledExtensions = newEnabledExtensions;
function _onVersionValidationChanged() {
    // we want to reload all extensions, but only enable
    // extensions when allowed by the sessionMode, so
    // temporarily disable them all
    enabledExtensions = [];
    for (let uuid in ExtensionUtils.extensions)
        reloadExtension(ExtensionUtils.extensions[uuid]);
    enabledExtensions = getEnabledExtensions();
    if (Main.sessionMode.allowExtensions) {
        enabledExtensions.forEach(function(uuid) {
            enableExtension(uuid);
        });
    }
function _loadExtensions() {
    global.settings.connect('changed::' + ENABLED_EXTENSIONS_KEY, onEnabledExtensionsChanged);
    global.settings.connect('changed::' + EXTENSION_DISABLE_VERSION_CHECK_KEY, _onVersionValidationChanged);
    enabledExtensions = getEnabledExtensions();
    let finder = new ExtensionUtils.ExtensionFinder();
    finder.connect('extension-found', function(finder, extension) {
        loadExtension(extension);
    });
    finder.scanExtensions();
function enableAllExtensions() {
    if (enabled)
        return;
    if (!initted) {
        _loadExtensions();
        initted = true;
    } else {
        enabledExtensions.forEach(function(uuid) {
            enableExtension(uuid);
        });
    }
    enabled = true;
function disableAllExtensions() {
    if (!enabled)
        return;
    if (initted) {
        extensionOrder.slice().reverse().forEach(function(uuid) {
            disableExtension(uuid);
        });
    }
    enabled = false;
function _sessionUpdated() {
    // For now sessionMode.allowExtensions controls extensions from both the
    // 'enabled-extensions' preference and the sessionMode.enabledExtensions
    // property; it might make sense to make enabledExtensions independent
    // from allowExtensions in the future
    if (Main.sessionMode.allowExtensions) {
        if (initted)
            enabledExtensions = getEnabledExtensions();
        enableAllExtensions();
    } else {
        disableAllExtensions();
    }
function init() {
    Main.sessionMode.connect('updated', _sessionUpdated);
    _sessionUpdated();
(uuay)tweener.js
// -*- mode: js; js-indent-level: 4; indent-tabs-mode: nil -*-
const Clutter = imports.gi.Clutter;
const GLib = imports.gi.GLib;
const Gtk = imports.gi.Gtk;
const Lang = imports.lang;
const Mainloop = imports.mainloop;
const Shell = imports.gi.Shell;
const St = imports.gi.St;
const Signals = imports.signals;
const Tweener = imports.tweener.tweener;
// This is a wrapper around imports.tweener.tweener that adds a bit of
// Clutter integration. If the tweening target is a Clutter.Actor, then
// the tweenings will automatically be removed if the actor is destroyed.
// ActionScript Tweener methods that imports.tweener.tweener doesn't
// currently implement: getTweens, getVersion, registerTransition,
// setTimeScale, updateTime.
// imports.tweener.tweener methods that we don't re-export:
// pauseAllTweens, removeAllTweens, resumeAllTweens. (It would be hard
// to clean up properly after removeAllTweens, and also, any code that
// calls any of these is almost certainly wrong anyway, because they
// affect the entire application.)
// Called from Main.start
function init() {
    Tweener.setFrameTicker(new ClutterFrameTicker());
function addCaller(target, tweeningParameters) {
    _wrapTweening(target, tweeningParameters);
    Tweener.addCaller(target, tweeningParameters);
function addTween(target, tweeningParameters) {
    _wrapTweening(target, tweeningParameters);
    Tweener.addTween(target, tweeningParameters);
function _wrapTweening(target, tweeningParameters) {
    let state = _getTweenState(target);
    if (!state.destroyedId) {
        if (target instanceof Clutter.Actor) {
            state.actor = target;
            state.destroyedId = target.connect('destroy', _actorDestroyed);
        } else if (target.actor && target.actor instanceof Clutter.Actor) {
            state.actor = target.actor;
            state.destroyedId = target.actor.connect('destroy', function() { _actorDestroyed(target); });
        }
    }
    if (!Gtk.Settings.get_default().gtk_enable_animations) {
        tweeningParameters['time'] = 0.000001;
        tweeningParameters['delay'] = 0.000001;
    }
    _addHandler(target, tweeningParameters, 'onComplete', _tweenCompleted);
function _getTweenState(target) {
    // If we were paranoid, we could keep a plist mapping targets to
    // states... but we're not that paranoid.
    if (!target.__ShellTweenerState)
        target.__ShellTweenerState = {};
    return target.__ShellTweenerState;
function _resetTweenState(target) {
    let state = target.__ShellTweenerState;
    if (state) {
        if (state.destroyedId)
            state.actor.disconnect(state.destroyedId);
    }
    target.__ShellTweenerState = {};
function _addHandler(target, params, name, handler) {
    if (params[name]) {
        let oldHandler = params[name];
        let oldScope = params[name + 'Scope'];
        let oldParams = params[name + 'Params'];
        let eventScope = oldScope ? oldScope : target;
        params[name] = function () {
            oldHandler.apply(eventScope, oldParams);
            handler(target);
        };
    } else
        params[name] = function () { handler(target); };
function _actorDestroyed(target) {
    _resetTweenState(target);
    Tweener.removeTweens(target);
function _tweenCompleted(target) {
    if (!isTweening(target))
        _resetTweenState(target);
function getTweenCount(scope) {
    return Tweener.getTweenCount(scope);
// imports.tweener.tweener doesn't provide this method (which exists
// in the ActionScript version) but it's easy to implement.
function isTweening(scope) {
    return Tweener.getTweenCount(scope) != 0;
function removeTweens(scope) {
    if (Tweener.removeTweens.apply(null, arguments)) {
        // If we just removed the last active tween, clean up
        if (Tweener.getTweenCount(scope) == 0)
            _tweenCompleted(scope);
        return true;
    } else
        return false;
function pauseTweens() {
    return Tweener.pauseTweens.apply(null, arguments);
function resumeTweens() {
    return Tweener.resumeTweens.apply(null, arguments);
function registerSpecialProperty(name, getFunction, setFunction,
                                 parameters, preProcessFunction) {
    Tweener.registerSpecialProperty(name, getFunction, setFunction,
                                    parameters, preProcessFunction);
function registerSpecialPropertyModifier(name, modifyFunction, getFunction) {
    Tweener.registerSpecialPropertyModifier(name, modifyFunction, getFunction);
function registerSpecialPropertySplitter(name, splitFunction, parameters) {
    Tweener.registerSpecialPropertySplitter(name, splitFunction, parameters);
// The 'FrameTicker' object is an object used to feed new frames to
// Tweener so it can update values and redraw. The default frame
// ticker for Tweener just uses a simple timeout at a fixed frame rate
// and has no idea of "catching up" by dropping frames.
// We substitute it with custom frame ticker here that connects
// Tweener to a Clutter.TimeLine. Now, Clutter.Timeline itself isn't a
// whole lot more sophisticated than a simple timeout at a fixed frame
// rate, but at least it knows how to drop frames. (See
// HippoAnimationManager for a more sophisticated view of continous
// time updates; even better is to pay attention to the vertical
// vblank and sync to that when possible.)
const ClutterFrameTicker = new Lang.Class({
    Name: 'ClutterFrameTicker',
    FRAME_RATE : 60,
    _init : function() {
        // We don't have a finite duration; tweener will tell us to stop
        // when we need to stop, so use 1000 seconds as "infinity", and
        // set the timeline to loop. Doing this means we have to track
        // time ourselves, since clutter timeline's time will cycle
        // instead of strictly increase.
        this._timeline = new Clutter.Timeline({ duration: 1000*1000 });
        this._timeline.set_loop(true);
        this._startTime = -1;
        this._currentTime = -1;
        this._timeline.connect('new-frame', Lang.bind(this,
            function(timeline, frame) {
                this._onNewFrame(frame);
            }));
        let perf_log = Shell.PerfLog.get_default();
        perf_log.define_event("tweener.framePrepareStart",
                              "Start of a new animation frame",
                              "");
        perf_log.define_event("tweener.framePrepareDone",
                              "Finished preparing frame",
                              "");
    },
    _onNewFrame : function(frame) {
        // If there is a lot of setup to start the animation, then
        // first frame number we get from clutter might be a long ways
        // into the animation (or the animation might even be done).
        // That looks bad, so we always start at the first frame of the
        // animation then only do frame dropping from there.
        if (this._startTime < 0)
            this._startTime = GLib.get_monotonic_time() / 1000.0;
        // currentTime is in milliseconds
        let perf_log = Shell.PerfLog.get_default();
        this._currentTime = GLib.get_monotonic_time() / 1000.0 - this._startTime;
        perf_log.event("tweener.framePrepareStart");
        this.emit('prepare-frame');
        perf_log.event("tweener.framePrepareDone");
    },
    getTime : function() {
        return this._currentTime;
    },
    start : function() {
        if (St.get_slow_down_factor() > 0)
            Tweener.setTimeScale(1 / St.get_slow_down_factor());
        this._timeline.start();
        global.begin_work();
    },
    stop : function() {
        this._timeline.stop();
        this._startTime = -1;
        this._currentTime = -1;
        global.end_work();
    }
Signals.addSignalMethods(ClutterFrameTicker.prototype);
(uuay)batch.js
// -*- mode: js; js-indent-level: 4; indent-tabs-mode: nil -*-
 * Copyright 2011 Red Hat, Inc
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2, or (at your option)
 * any later version.
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, see <http://www.gnu.org/licenses/>.
 * In order for transformation animations to look good, they need to be
 * incremental and have some order to them (e.g., fade out hidden items,
 * then shrink to close the void left over). Chaining animations in this way can
 * be error-prone and wordy using just Tweener callbacks.
 * The classes in this file help with this:
 * - Task.  encapsulates schedulable work to be run in a specific scope.
 * - ConsecutiveBatch.  runs a series of tasks in order and completes
 *                      when the last in the series finishes.
 * - ConcurrentBatch.  runs a set of tasks at the same time and completes
 *                     when the last to finish completes.
 * - Hold.  prevents a batch from completing the pending task until
 *          the hold is released.
 * The tasks associated with a batch are specified in a list at batch
 * construction time as either task objects or plain functions.
 * Batches are task objects, themselves, so they can be nested.
 * These classes aren't specific to GDM, but were found to be unintuitive and so
 * are not used elsewhere. These APIs may ultimately get dropped entirely and
 * replaced by something else.
const Lang = imports.lang;
const Signals = imports.signals;
const Task = new Lang.Class({
    Name: 'Task',
    _init: function(scope, handler) {
        if (scope)
            this.scope = scope;
        else
            this.scope = this;
        this.handler = handler;
    },
    run: function() {
        if (this.handler)
            return this.handler.call(this.scope);
        return null;
    },
Signals.addSignalMethods(Task.prototype);
const Hold = new Lang.Class({
    Name: 'Hold',
    Extends: Task,
    _init: function() {
        this.parent(this, function () {
            return this;
        });
        this._acquisitions = 1;
    },
    acquire: function() {
        if (this._acquisitions <= 0)
            throw new Error("Cannot acquire hold after it's been released");
        this._acquisitions++;
    },
    acquireUntilAfter: function(hold) {
        if (!hold.isAcquired())
            return;
        this.acquire();
        let signalId = hold.connect('release', Lang.bind(this, function() {
                                        hold.disconnect(signalId);
                                        this.release();
                                    }));
    },
    release: function() {
        this._acquisitions--;
        if (this._acquisitions == 0)
            this.emit('release');
    },
    isAcquired: function() {
        return this._acquisitions > 0;
    }
Signals.addSignalMethods(Hold.prototype);
const Batch = new Lang.Class({
    Name: 'Batch',
    Extends: Task,
    _init: function(scope, tasks) {
        this.parent();
        this.tasks = [];
        for (let i = 0; i < tasks.length; i++) {
            let task;
            if (tasks[i] instanceof Task) {
                task = tasks[i];
            } else if (typeof tasks[i] == 'function') {
                task = new Task(scope, tasks[i]);
            } else {
                throw new Error('Batch tasks must be functions or Task, Hold or Batch objects');
            }
            this.tasks.push(task);
        }
    },
    process: function() {
        throw new Error('Not implemented');
    },
    runTask: function() {
        if (!(this._currentTaskIndex in this.tasks)) {
            return null;
        }
        return this.tasks[this._currentTaskIndex].run();
    },
    _finish: function() {
        this.hold.release();
    },
    nextTask: function() {
        this._currentTaskIndex++;
        // if the entire batch of tasks is finished, release
        // the hold and notify anyone waiting on the batch
        if (this._currentTaskIndex >= this.tasks.length) {
            this._finish();
            return;
        }
        this.process();
    },
    _start: function() {
        // acquire a hold to get released when the entire
        // batch of tasks is finished
        this.hold = new Hold();
        this._currentTaskIndex = 0;
        this.process();
    },
    run: function() {
        this._start();
        // hold may be destroyed at this point
        // if we're already done running
        return this.hold;
    },
    cancel: function() {
        this.tasks = this.tasks.splice(0, this._currentTaskIndex + 1);
    }
Signals.addSignalMethods(Batch.prototype);
const ConcurrentBatch = new Lang.Class({
    Name: 'ConcurrentBatch',
    Extends: Batch,
    process: function() {
       let hold = this.runTask();
       if (hold) {
           this.hold.acquireUntilAfter(hold);
       }
       // Regardless of the state of the just run task,
       // fire off the next one, so all the tasks can run
       // concurrently.
       this.nextTask();
    }
Signals.addSignalMethods(ConcurrentBatch.prototype);
const ConsecutiveBatch = new Lang.Class({
    Name: 'ConsecutiveBatch',
    Extends: Batch,
    process: function() {
       let hold = this.runTask();
       if (hold && hold.isAcquired()) {
           // This task is inhibiting the batch. Wait on it
           // before processing the next one.
           let signalId = hold.connect('release',
                                       Lang.bind(this, function() {
                                           hold.disconnect(signalId);
                                           this.nextTask();
                                       }));
           return;
       } else {
           // This task finished, process the next one
           this.nextTask();
       }
    }
Signals.addSignalMethods(ConsecutiveBatch.prototype);
(uuay)overviewControls.js
// -*- mode: js; js-indent-level: 4; indent-tabs-mode: nil -*-
const GObject = imports.gi.GObject;
const Clutter = imports.gi.Clutter;
const Lang = imports.lang;
const Meta = imports.gi.Meta;
const St = imports.gi.St;
const Shell = imports.gi.Shell;
const Dash = imports.ui.dash;
const Main = imports.ui.main;
const Params = imports.misc.params;
const Tweener = imports.ui.tweener;
const ViewSelector = imports.ui.viewSelector;
const WorkspaceThumbnail = imports.ui.workspaceThumbnail;
const SIDE_CONTROLS_ANIMATION_TIME = 0.16;
function getRtlSlideDirection(direction, actor) {
    let rtl = (actor.text_direction == Clutter.TextDirection.RTL);
    if (rtl)
        direction = (direction == SlideDirection.LEFT) ?
            SlideDirection.RIGHT : SlideDirection.LEFT;
    return direction;
const SlideDirection = {
    LEFT: 0,
    RIGHT: 1
const SlideLayout = new Lang.Class({
    Name: 'SlideLayout',
    Extends: Clutter.FixedLayout,
    _init: function(params) {
        this._slideX = 1;
        this._translationX = undefined;
        this._direction = SlideDirection.LEFT;
        this.parent(params);
    },
    vfunc_get_preferred_width: function(container, forHeight) {
        let child = container.get_first_child();
        let [minWidth, natWidth] = child.get_preferred_width(forHeight);
        minWidth *= this._slideX;
        natWidth *= this._slideX;
        return [minWidth, natWidth];
    },
    vfunc_allocate: function(container, box, flags) {
        let child = container.get_first_child();
        let availWidth = Math.round(box.x2 - box.x1);
        let availHeight = Math.round(box.y2 - box.y1);
        let [, natWidth] = child.get_preferred_width(availHeight);
        // Align the actor inside the clipped box, as the actor's alignment
        // flags only determine what to do if the allocated box is bigger
        // than the actor's box.
        let realDirection = getRtlSlideDirection(this._direction, child);
        let alignX = (realDirection == SlideDirection.LEFT) ? (availWidth - natWidth)
                                                            : (availWidth - natWidth * this._slideX);
        let actorBox = new Clutter.ActorBox();
        actorBox.x1 = box.x1 + alignX + this._translationX;
        actorBox.x2 = actorBox.x1 + (child.x_expand ? availWidth : natWidth);
        actorBox.y1 = box.y1;
        actorBox.y2 = actorBox.y1 + availHeight;
        child.allocate(actorBox, flags);
    },
    set slideX(value) {
        this._slideX = value;
        this.layout_changed();
    },
    get slideX() {
        return this._slideX;
    },
    set slideDirection(direction) {
        this._direction = direction;
        this.layout_changed();
    },
    get slideDirection() {
        return this._direction;
    },
    set translationX(value) {
        this._translationX = value;
        this.layout_changed();
    },
    get translationX() {
        return this._translationX;
    },
const SlidingControl = new Lang.Class({
    Name: 'SlidingControl',
    _init: function(params) {
        params = Params.parse(params, { slideDirection: SlideDirection.LEFT });
        this._visible = true;
        this._inDrag = false;
        this.layout = new SlideLayout();
        this.layout.slideDirection = params.slideDirection;
        this.actor = new St.Widget({ layout_manager: this.layout,
                                     style_class: 'overview-controls',
                                     clip_to_allocation: true });
        Main.overview.connect('hiding', Lang.bind(this, this._onOverviewHiding));
        Main.overview.connect('item-drag-begin', Lang.bind(this, this._onDragBegin));
        Main.overview.connect('item-drag-end', Lang.bind(this, this._onDragEnd));
        Main.overview.connect('item-drag-cancelled', Lang.bind(this, this._onDragEnd));
        Main.overview.connect('window-drag-begin', Lang.bind(this, this._onWindowDragBegin));
        Main.overview.connect('window-drag-cancelled', Lang.bind(this, this._onWindowDragEnd));
        Main.overview.connect('window-drag-end', Lang.bind(this, this._onWindowDragEnd));
    },
    _getSlide: function() {
        throw new Error('getSlide() must be overridden');
    },
    _updateSlide: function() {
        Tweener.addTween(this.layout, { slideX: this._getSlide(),
                                        time: SIDE_CONTROLS_ANIMATION_TIME,
                                        transition: 'easeOutQuad' });
    },
    getVisibleWidth: function() {
        let child = this.actor.get_first_child();
        let [, , natWidth, ] = child.get_preferred_size();
        return natWidth;
    },
    _getTranslation: function() {
        let child = this.actor.get_first_child();
        let direction = getRtlSlideDirection(this.layout.slideDirection, child);
        let visibleWidth = this.getVisibleWidth();
        if (direction == SlideDirection.LEFT)
            return - visibleWidth;
        else
            return visibleWidth;
    },
    _updateTranslation: function() {
        let translationStart = 0;
        let translationEnd = 0;
        let translation = this._getTranslation();
        let shouldShow = (this._getSlide() > 0);
        if (shouldShow) {
            translationStart = translation;
        } else {
            translationEnd = translation;
        }
        if (this.layout.translationX == translationEnd)
            return;
        this.layout.translationX = translationStart;
        Tweener.addTween(this.layout, { translationX: translationEnd,
                                        time: SIDE_CONTROLS_ANIMATION_TIME,
                                        transition: 'easeOutQuad' });
    },
    _onOverviewHiding: function() {
        // We need to explicitly slideOut since showing pages
        // doesn't imply sliding out, instead, hiding the overview does.
        this.slideOut();
    },
    _onWindowDragBegin: function() {
        this._onDragBegin();
    },
    _onWindowDragEnd: function() {
        this._onDragEnd();
    },
    _onDragBegin: function() {
        this._inDrag = true;
        this._updateTranslation();
        this._updateSlide();
    },
    _onDragEnd: function() {
        this._inDrag = false;
        this._updateSlide();
    },
    fadeIn: function() {
        Tweener.addTween(this.actor, { opacity: 255,
                                       time: SIDE_CONTROLS_ANIMATION_TIME / 2,
                                       transition: 'easeInQuad'
                                     });
    },
    fadeHalf: function() {
        Tweener.addTween(this.actor, { opacity: 128,
                                       time: SIDE_CONTROLS_ANIMATION_TIME / 2,
                                       transition: 'easeOutQuad'
                                     });
    },
    slideIn: function() {
        this._visible = true;
        // we will update slideX and the translation from pageEmpty
    },
    slideOut: function() {
        this._visible = false;
        this._updateTranslation();
        // we will update slideX from pageEmpty
    },
    pageEmpty: function() {
        // When pageEmpty is received, there's no visible view in the
        // selector; this means we can now safely set the full slide for
        // the next page, since slideIn or slideOut might have been called,
        // changing the visiblity
        this.layout.slideX = this._getSlide();
        this._updateTranslation();
    }
const ThumbnailsSlider = new Lang.Class({
    Name: 'ThumbnailsSlider',
    Extends: SlidingControl,
    _init: function(thumbnailsBox) {
        this.parent({ slideDirection: SlideDirection.RIGHT });
        this._thumbnailsBox = thumbnailsBox;
        this.actor.request_mode = Clutter.RequestMode.WIDTH_FOR_HEIGHT;
        this.actor.reactive = true;
        this.actor.track_hover = true;
        this.actor.add_actor(this._thumbnailsBox.actor);
        Main.layoutManager.connect('monitors-changed', Lang.bind(this, this._updateSlide));
        this.actor.connect('notify::hover', Lang.bind(this, this._updateSlide));
        global.window_manager.connect('switch-workspace', Lang.bind(this, this._updateSlide));
        this._thumbnailsBox.actor.bind_property('visible', this.actor, 'visible', GObject.BindingFlags.SYNC_CREATE);
    },
    _getAlwaysZoomOut: function() {
        // Always show the pager when hover, during a drag, or if workspaces are
        // actually used, e.g. there are windows on any non-active workspace
        let alwaysZoomOut = this.actor.hover ||
                            this._inDrag ||
                            !Meta.prefs_get_dynamic_workspaces() ||
                            global.screen.n_workspaces > 2 ||
                            global.screen.get_active_workspace_index() != 0;
        if (!alwaysZoomOut) {
            let monitors = Main.layoutManager.monitors;
            let primary = Main.layoutManager.primaryMonitor;
            /* Look for any monitor to the right of the primary, if there is
             * one, we always keep zoom out, otherwise its hard to reach
             * the thumbnail area without passing into the next monitor. */
            for (let i = 0; i < monitors.length; i++) {
                if (monitors[i].x >= primary.x + primary.width) {
                    alwaysZoomOut = true;
                    break;
                }
            }
        }
        return alwaysZoomOut;
    },
    getNonExpandedWidth: function() {
        let child = this.actor.get_first_child();
        return child.get_theme_node().get_length('visible-width');
    },
    _getSlide: function() {
        if (!this._visible)
            return 0;
        let alwaysZoomOut = this._getAlwaysZoomOut();
        if (alwaysZoomOut)
            return 1;
        let child = this.actor.get_first_child();
        let preferredHeight = child.get_preferred_height(-1)[1];
        let expandedWidth = child.get_preferred_width(preferredHeight)[1];
        return this.getNonExpandedWidth() / expandedWidth;
    },
    getVisibleWidth: function() {
        let alwaysZoomOut = this._getAlwaysZoomOut();
        if (alwaysZoomOut)
            return this.parent();
        else
            return this.getNonExpandedWidth();
    }
const DashSlider = new Lang.Class({
    Name: 'DashSlider',
    Extends: SlidingControl,
    _init: function(dash) {
        this.parent({ slideDirection: SlideDirection.LEFT });
        this._dash = dash;
        // SlideLayout reads the actor's expand flags to decide
        // whether to allocate the natural size to its child, or the whole
        // available allocation
        this._dash.actor.x_expand = true;
        this.actor.x_expand = true;
        this.actor.x_align = Clutter.ActorAlign.START;
        this.actor.y_expand = true;
        this.actor.add_actor(this._dash.actor);
        this._dash.connect('icon-size-changed', Lang.bind(this, this._updateSlide));
    },
    _getSlide: function() {
        if (this._visible || this._inDrag)
            return 1;
        else
            return 0;
    },
    _onWindowDragBegin: function() {
        this.fadeHalf();
    },
    _onWindowDragEnd: function() {
        this.fadeIn();
    }
const DashSpacer = new Lang.Class({
    Name: 'DashSpacer',
    Extends: St.Widget,
    _init: function(params) {
        this.parent(params);
        this._bindConstraint = null;
    },
    setDashActor: function(dashActor) {
        if (this._bindConstraint) {
            this.remove_constraint(this._bindConstraint);
            this._bindConstraint = null;
        }
        if (dashActor) {
            this._bindConstraint = new Clutter.BindConstraint({ source: dashActor,
                                                                coordinate: Clutter.BindCoordinate.SIZE });
            this.add_constraint(this._bindConstraint);
        }
    },
    vfunc_get_preferred_width: function(forHeight) {
        let box = this.get_allocation_box();
        let minWidth = this.parent(forHeight)[0];
        let natWidth = box.x2 - box.x1;
        return [minWidth, natWidth];
    },
    vfunc_get_preferred_height: function(forWidth) {
        let box = this.get_allocation_box();
        let minHeight = this.parent(forWidth)[0];
        let natHeight = box.y2 - box.y1;
        return [minHeight, natHeight];
    }
const ControlsLayout = new Lang.Class({
    Name: 'ControlsLayout',
    Extends: Clutter.BinLayout,
    Signals: { 'allocation-changed': { flags: GObject.SignalFlags.RUN_LAST } },
    vfunc_allocate: function(container, box, flags) {
        this.parent(container, box, flags);
        this.emit('allocation-changed');
    }
const ControlsManager = new Lang.Class({
    Name: 'ControlsManager',
    _init: function(searchEntry) {
        this.dash = new Dash.Dash();
        this._dashSlider = new DashSlider(this.dash);
        this._dashSpacer = new DashSpacer();
        this._dashSpacer.setDashActor(this._dashSlider.actor);
        this._thumbnailsBox = new WorkspaceThumbnail.ThumbnailsBox();
        this._thumbnailsSlider = new ThumbnailsSlider(this._thumbnailsBox);
        this.viewSelector = new ViewSelector.ViewSelector(searchEntry,
                                                          this.dash.showAppsButton);
        this.viewSelector.connect('page-changed', Lang.bind(this, this._setVisibility));
        this.viewSelector.connect('page-empty', Lang.bind(this, this._onPageEmpty));
        let layout = new ControlsLayout();
        this.actor = new St.Widget({ layout_manager: layout,
                                     x_expand: true, y_expand: true,
                                     clip_to_allocation: true });
        this._group = new St.BoxLayout({ name: 'overview-group',
                                        x_expand: true, y_expand: true });
        this.actor.add_actor(this._group);
        this.actor.add_actor(this._dashSlider.actor);
        this._group.add_actor(this._dashSpacer);
        this._group.add(this.viewSelector.actor, { x_fill: true,
                                                   expand: true });
        this._group.add_actor(this._thumbnailsSlider.actor);
        layout.connect('allocation-changed', Lang.bind(this, this._updateWorkspacesGeometry));
        Main.overview.connect('showing', Lang.bind(this, this._updateSpacerVisibility));
        Main.overview.connect('item-drag-begin', Lang.bind(this,
            function() {
                let activePage = this.viewSelector.getActivePage();
                if (activePage != ViewSelector.ViewPage.WINDOWS)
                    this.viewSelector.fadeHalf();
            }));
        Main.overview.connect('item-drag-end', Lang.bind(this,
            function() {
                this.viewSelector.fadeIn();
            }));
        Main.overview.connect('item-drag-cancelled', Lang.bind(this,
            function() {
                this.viewSelector.fadeIn();
            }));
    },
    _updateWorkspacesGeometry: function() {
        let [x, y] = this.actor.get_transformed_position();
        let [width, height] = this.actor.get_transformed_size();
        let geometry = { x: x, y: y, width: width, height: height };
        let spacing = this.actor.get_theme_node().get_length('spacing');
        let dashWidth = this._dashSlider.getVisibleWidth() + spacing;
        let thumbnailsWidth = this._thumbnailsSlider.getNonExpandedWidth() + spacing;
        geometry.width -= dashWidth;
        geometry.width -= thumbnailsWidth;
        if (this.actor.get_text_direction() == Clutter.TextDirection.LTR)
            geometry.x += dashWidth;
        else
            geometry.x += thumbnailsWidth;
        this.viewSelector.setWorkspacesFullGeometry(geometry);
    },
    _setVisibility: function() {
        // Ignore the case when we're leaving the overview, since
        // actors will be made visible again when entering the overview
        // next time, and animating them while doing so is just
        // unnecessary noise
        if (!Main.overview.visible ||
            (Main.overview.animationInProgress && !Main.overview.visibleTarget))
            return;
        let activePage = this.viewSelector.getActivePage();
        let dashVisible = (activePage == ViewSelector.ViewPage.WINDOWS ||
                           activePage == ViewSelector.ViewPage.APPS);
        let thumbnailsVisible = (activePage == ViewSelector.ViewPage.WINDOWS);
        if (dashVisible)
            this._dashSlider.slideIn();
        else
            this._dashSlider.slideOut();
        if (thumbnailsVisible)
            this._thumbnailsSlider.slideIn();
        else
            this._thumbnailsSlider.slideOut();
    },
    _updateSpacerVisibility: function() {
        if (Main.overview.animationInProgress && !Main.overview.visibleTarget)
            return;
        let activePage = this.viewSelector.getActivePage();
        this._dashSpacer.visible = (activePage == ViewSelector.ViewPage.WINDOWS);
    },
    _onPageEmpty: function() {
        this._dashSlider.pageEmpty();
        this._thumbnailsSlider.pageEmpty();
        this._updateSpacerVisibility();
    }
(uuay)loginManager.js
// -*- mode: js; js-indent-level: 4; indent-tabs-mode: nil -*-
const GLib = imports.gi.GLib;
const Gio = imports.gi.Gio;
const Lang = imports.lang;
const Mainloop = imports.mainloop;
const Shell = imports.gi.Shell;
const Signals = imports.signals;
const SystemdLoginManagerIface = '<node> \
<interface name="org.freedesktop.login1.Manager"> \
<method name="Suspend"> \
    <arg type="b" direction="in"/> \
</method> \
<method name="CanSuspend"> \
    <arg type="s" direction="out"/> \
</method> \
<method name="Inhibit"> \
    <arg type="s" direction="in"/> \
    <arg type="s" direction="in"/> \
    <arg type="s" direction="in"/> \
    <arg type="s" direction="in"/> \
    <arg type="h" direction="out"/> \
</method> \
<method name="GetSession"> \
    <arg type="s" direction="in"/> \
    <arg type="o" direction="out"/> \
</method> \
<method name="ListSessions"> \
    <arg name="sessions" type="a(susso)" direction="out"/> \
</method> \
<signal name="PrepareForSleep"> \
    <arg type="b" direction="out"/> \
</signal> \
</interface> \
</node>';
const SystemdLoginSessionIface = '<node> \
<interface name="org.freedesktop.login1.Session"> \
<signal name="Lock" /> \
<signal name="Unlock" /> \
<property name="Active" type="b" access="read" /> \
<method name="SetLockedHint"> \
    <arg type="b" direction="in"/> \
</method> \
</interface> \
</node>';
const SystemdLoginManager = Gio.DBusProxy.makeProxyWrapper(SystemdLoginManagerIface);
const SystemdLoginSession = Gio.DBusProxy.makeProxyWrapper(SystemdLoginSessionIface);
function haveSystemd() {
    return GLib.access("/run/systemd/seats", 0) >= 0;
function versionCompare(required, reference) {
    required = required.split('.');
    reference = reference.split('.');
    for (let i = 0; i < required.length; i++) {
        let requiredInt = parseInt(required[i]);
        let referenceInt = parseInt(reference[i]);
        if (requiredInt != referenceInt)
            return requiredInt < referenceInt;
    }
    return true;
function canLock() {
    try {
        let params = GLib.Variant.new('(ss)', ['org.gnome.DisplayManager.Manager', 'Version']);
        let result = Gio.DBus.system.call_sync('org.gnome.DisplayManager',
                                               '/org/gnome/DisplayManager/Manager',
                                               'org.freedesktop.DBus.Properties',
                                               'Get', params, null,
                                               Gio.DBusCallFlags.NONE,
                                               -1, null);
        let version = result.deep_unpack()[0].deep_unpack();
        return haveSystemd() && versionCompare('3.5.91', version);
    } catch(e) {
        return false;
    }
let _loginManager = null;
 * LoginManager:
 * An abstraction over systemd/logind and ConsoleKit.
function getLoginManager() {
    if (_loginManager == null) {
        if (haveSystemd())
            _loginManager = new LoginManagerSystemd();
        else
            _loginManager = new LoginManagerDummy();
    }
    return _loginManager;
const LoginManagerSystemd = new Lang.Class({
    Name: 'LoginManagerSystemd',
    _init: function() {
        this._proxy = new SystemdLoginManager(Gio.DBus.system,
                                              'org.freedesktop.login1',
                                              '/org/freedesktop/login1');
        this._proxy.connectSignal('PrepareForSleep',
                                  Lang.bind(this, this._prepareForSleep));
    },
    getCurrentSessionProxy: function(callback) {
        if (this._currentSession) {
            callback (this._currentSession);
            return;
        }
        this._proxy.GetSessionRemote(GLib.getenv('XDG_SESSION_ID'), Lang.bind(this,
            function(result, error) {
                if (error) {
                    logError(error, 'Could not get a proxy for the current session');
                } else {
                    this._currentSession = new SystemdLoginSession(Gio.DBus.system,
                                                                   'org.freedesktop.login1',
                                                                   result[0]);
                    callback(this._currentSession);
                }
            }));
    },
    canSuspend: function(asyncCallback) {
        this._proxy.CanSuspendRemote(function(result, error) {
            if (error) {
                asyncCallback(false, false);
            } else {
                let needsAuth = result[0] == 'challenge';
                let canSuspend = needsAuth || result[0] == 'yes';
                asyncCallback(canSuspend, needsAuth);
            }
        });
    },
    listSessions: function(asyncCallback) {
        this._proxy.ListSessionsRemote(function(result, error) {
            if (error)
                asyncCallback([]);
            else
                asyncCallback(result[0]);
        });
    },
    suspend: function() {
        this._proxy.SuspendRemote(true);
    },
    inhibit: function(reason, callback) {
        let inVariant = GLib.Variant.new('(ssss)',
                                         ['sleep',
                                          'GNOME Shell',
                                          reason,
                                          'delay']);
        this._proxy.call_with_unix_fd_list('Inhibit', inVariant, 0, -1, null, null,
            Lang.bind(this, function(proxy, result) {
                let fd = -1;
                try {
                    let [outVariant, fdList] = proxy.call_with_unix_fd_list_finish(result);
                    fd = fdList.steal_fds()[0];
                    callback(new Gio.UnixInputStream({ fd: fd }));
                } catch(e) {
                    logError(e, "Error getting systemd inhibitor");
                    callback(null);
                }
            }));
    },
    _prepareForSleep: function(proxy, sender, [aboutToSuspend]) {
        this.emit('prepare-for-sleep', aboutToSuspend);
    }
Signals.addSignalMethods(LoginManagerSystemd.prototype);
const LoginManagerDummy = new Lang.Class({
    Name: 'LoginManagerDummy',
    getCurrentSessionProxy: function(callback) {
        // we could return a DummySession object that fakes whatever callers
        // expect (at the time of writing: connect() and connectSignal()
        // methods), but just never calling the callback should be safer
    },
    canSuspend: function(asyncCallback) {
        asyncCallback(false, false);
    },
    listSessions: function(asyncCallback) {
        asyncCallback([]);
    },
    suspend: function() {
        this.emit('prepare-for-sleep', true);
        this.emit('prepare-for-sleep', false);
    },
    inhibit: function(reason, callback) {
        callback(null);
    }
Signals.addSignalMethods(LoginManagerDummy.prototype);
(uuay)edgeDragAction.js
// -*- mode: js; js-indent-level: 4; indent-tabs-mode: nil -*-
const Lang = imports.lang;
const Signals = imports.signals;
const Meta = imports.gi.Meta;
const Clutter = imports.gi.Clutter;
const St = imports.gi.St;
const Main = imports.ui.main;
const EDGE_THRESHOLD = 20;
const DRAG_DISTANCE = 80;
const EdgeDragAction = new Lang.Class({
    Name: 'EdgeDragAction',
    Extends: Clutter.GestureAction,
    _init : function(side, allowedModes) {
        this.parent();
        this._side = side;
        this._allowedModes = allowedModes;
        this.set_n_touch_points(1);
        global.display.connect('grab-op-begin', Lang.bind(this, function() {
            this.cancel();
        }));
    },
    _getMonitorRect : function (x, y) {
        let rect = new Meta.Rectangle({ x: x - 1, y: y - 1, width: 1, height: 1 });
        let monitorIndex = global.screen.get_monitor_index_for_rect(rect);
        return global.screen.get_monitor_geometry(monitorIndex);
    },
    vfunc_gesture_prepare : function(action, actor) {
        if (this.get_n_current_points() == 0)
            return false;
        if (!(this._allowedModes & Main.actionMode))
            return false;
        let [x, y] = this.get_press_coords(0);
        let monitorRect = this._getMonitorRect(x, y);
        return ((this._side == St.Side.LEFT && x < monitorRect.x + EDGE_THRESHOLD) ||
                (this._side == St.Side.RIGHT && x > monitorRect.x + monitorRect.width - EDGE_THRESHOLD) ||
                (this._side == St.Side.TOP && y < monitorRect.y + EDGE_THRESHOLD) ||
                (this._side == St.Side.BOTTOM && y > monitorRect.y + monitorRect.height - EDGE_THRESHOLD));
    },
    vfunc_gesture_progress : function (action, actor) {
        let [startX, startY] = this.get_press_coords(0);
        let [x, y] = this.get_motion_coords(0);
        let offsetX = Math.abs (x - startX);
        let offsetY = Math.abs (y - startY);
        if (offsetX < EDGE_THRESHOLD && offsetY < EDGE_THRESHOLD)
            return true;
        if ((offsetX > offsetY &&
             (this._side == St.Side.TOP || this._side == St.Side.BOTTOM)) ||
            (offsetY > offsetX &&
             (this._side == St.Side.LEFT || this._side == St.Side.RIGHT))) {
            this.cancel();
            return false;
        }
        return true;
    },
    vfunc_gesture_end : function (action, actor) {
        let [startX, startY] = this.get_press_coords(0);
        let [x, y] = this.get_motion_coords(0);
        let monitorRect = this._getMonitorRect(startX, startY);
        if ((this._side == St.Side.TOP && y > monitorRect.y + DRAG_DISTANCE) ||
            (this._side == St.Side.BOTTOM && y < monitorRect.y + monitorRect.height - DRAG_DISTANCE) ||
            (this._side == St.Side.LEFT && x > monitorRect.x + DRAG_DISTANCE) ||
            (this._side == St.Side.RIGHT && x < monitorRect.x + monitorRect.width - DRAG_DISTANCE))
            this.emit('activated');
    }
Signals.addSignalMethods(EdgeDragAction.prototype);
(uuay)messageList.js
const Atk = imports.gi.Atk;
const Clutter = imports.gi.Clutter;
const Gio = imports.gi.Gio;
const GLib = imports.gi.GLib;
const GObject = imports.gi.GObject;
const Lang = imports.lang;
const Main = imports.ui.main;
const MessageTray = imports.ui.messageTray;
const Meta = imports.gi.Meta;
const Pango = imports.gi.Pango;
const Signals = imports.signals;
const St = imports.gi.St;
const Calendar = imports.ui.calendar;
const Tweener = imports.ui.tweener;
const Util = imports.misc.util;
const MESSAGE_ANIMATION_TIME = 0.1;
const DEFAULT_EXPAND_LINES = 6;
function _fixMarkup(text, allowMarkup) {
    if (allowMarkup) {
        // Support &amp;, &quot;, &apos;, &lt; and &gt;, escape all other
        // occurrences of '&'.
        let _text = text.replace(/&(?!amp;|quot;|apos;|lt;|gt;)/g, '&amp;');
        // Support <b>, <i>, and <u>, escape anything else
        // so it displays as raw markup.
        _text = _text.replace(/<(?!\/?[biu]>)/g, '&lt;');
        try {
            Pango.parse_markup(_text, -1, '');
            return _text;
        } catch (e) {}
    }
    // !allowMarkup, or invalid markup
    return GLib.markup_escape_text(text, -1);
const URLHighlighter = new Lang.Class({
    Name: 'URLHighlighter',
    _init: function(text, lineWrap, allowMarkup) {
        if (!text)
            text = '';
        this.actor = new St.Label({ reactive: true, style_class: 'url-highlighter',
                                    x_expand: true, x_align: Clutter.ActorAlign.START });
        this._linkColor = '#ccccff';
        this.actor.connect('style-changed', Lang.bind(this, function() {
            let [hasColor, color] = this.actor.get_theme_node().lookup_color('link-color', false);
            if (hasColor) {
                let linkColor = color.to_string().substr(0, 7);
                if (linkColor != this._linkColor) {
                    this._linkColor = linkColor;
                    this._highlightUrls();
                }
            }
        }));
        this.actor.clutter_text.line_wrap = lineWrap;
        this.actor.clutter_text.line_wrap_mode = Pango.WrapMode.WORD_CHAR;
        this.setMarkup(text, allowMarkup);
        this.actor.connect('button-press-event', Lang.bind(this, function(actor, event) {
            // Don't try to URL highlight when invisible.
            // The MessageTray doesn't actually hide us, so
            // we need to check for paint opacities as well.
            if (!actor.visible || actor.get_paint_opacity() == 0)
                return Clutter.EVENT_PROPAGATE;
            // Keep Notification.actor from seeing this and taking
            // a pointer grab, which would block our button-release-event
            // handler, if an URL is clicked
            return this._findUrlAtPos(event) != -1;
        }));
        this.actor.connect('button-release-event', Lang.bind(this, function (actor, event) {
            if (!actor.visible || actor.get_paint_opacity() == 0)
                return Clutter.EVENT_PROPAGATE;
            let urlId = this._findUrlAtPos(event);
            if (urlId != -1) {
                let url = this._urls[urlId].url;
                if (url.indexOf(':') == -1)
                    url = 'http://' + url;
                Gio.app_info_launch_default_for_uri(url, global.create_app_launch_context(0, -1));
                return Clutter.EVENT_STOP;
            }
            return Clutter.EVENT_PROPAGATE;
        }));
        this.actor.connect('motion-event', Lang.bind(this, function(actor, event) {
            if (!actor.visible || actor.get_paint_opacity() == 0)
                return Clutter.EVENT_PROPAGATE;
            let urlId = this._findUrlAtPos(event);
            if (urlId != -1 && !this._cursorChanged) {
                global.screen.set_cursor(Meta.Cursor.POINTING_HAND);
                this._cursorChanged = true;
            } else if (urlId == -1) {
                global.screen.set_cursor(Meta.Cursor.DEFAULT);
                this._cursorChanged = false;
            }
            return Clutter.EVENT_PROPAGATE;
        }));
        this.actor.connect('leave-event', Lang.bind(this, function() {
            if (!this.actor.visible || this.actor.get_paint_opacity() == 0)
                return Clutter.EVENT_PROPAGATE;
            if (this._cursorChanged) {
                this._cursorChanged = false;
                global.screen.set_cursor(Meta.Cursor.DEFAULT);
            }
            return Clutter.EVENT_PROPAGATE;
        }));
    },
    setMarkup: function(text, allowMarkup) {
        text = text ? _fixMarkup(text, allowMarkup) : '';
        this._text = text;
        this.actor.clutter_text.set_markup(text);
        /* clutter_text.text contain text without markup */
        this._urls = Util.findUrls(this.actor.clutter_text.text);
        this._highlightUrls();
    },
    _highlightUrls: function() {
        // text here contain markup
        let urls = Util.findUrls(this._text);
        let markup = '';
        let pos = 0;
        for (let i = 0; i < urls.length; i++) {
            let url = urls[i];
            let str = this._text.substr(pos, url.pos - pos);
            markup += str + '<span foreground="' + this._linkColor + '"><u>' + url.url + '</u></span>';
            pos = url.pos + url.url.length;
        }
        markup += this._text.substr(pos);
        this.actor.clutter_text.set_markup(markup);
    },
    _findUrlAtPos: function(event) {
        let success;
        let [x, y] = event.get_coords();
        [success, x, y] = this.actor.transform_stage_point(x, y);
        let find_pos = -1;
        for (let i = 0; i < this.actor.clutter_text.text.length; i++) {
            let [success, px, py, line_height] = this.actor.clutter_text.position_to_coords(i);
            if (py > y || py + line_height < y || x < px)
                continue;
            find_pos = i;
        }
        if (find_pos != -1) {
            for (let i = 0; i < this._urls.length; i++)
            if (find_pos >= this._urls[i].pos &&
                this._urls[i].pos + this._urls[i].url.length > find_pos)
                return i;
        }
        return -1;
    }
const ScaleLayout = new Lang.Class({
    Name: 'ScaleLayout',
    Extends: Clutter.BinLayout,
    _connectContainer: function(container) {
        if (this._container == container)
            return;
        if (this._container)
            for (let id of this._signals)
                this._container.disconnect(id);
        this._container = container;
        this._signals = [];
        if (this._container)
            for (let signal of ['notify::scale-x', 'notify::scale-y']) {
                let id = this._container.connect(signal, Lang.bind(this,
                    function() {
                        this.layout_changed();
                    }));
                this._signals.push(id);
            }
    },
    vfunc_get_preferred_width: function(container, forHeight) {
        this._connectContainer(container);
        let [min, nat] = this.parent(container, forHeight);
        return [Math.floor(min * container.scale_x),
                Math.floor(nat * container.scale_x)];
    },
    vfunc_get_preferred_height: function(container, forWidth) {
        this._connectContainer(container);
        let [min, nat] = this.parent(container, forWidth);
        return [Math.floor(min * container.scale_y),
                Math.floor(nat * container.scale_y)];
    }
const LabelExpanderLayout = new Lang.Class({
    Name: 'LabelExpanderLayout',
    Extends: Clutter.LayoutManager,
    Properties: { 'expansion': GObject.ParamSpec.double('expansion',
                                                        'Expansion',
                                                        'Expansion of the layout, between 0 (collapsed) ' +
                                                        'and 1 (fully expanded',
                                                         GObject.ParamFlags.READABLE | GObject.ParamFlags.WRITABLE,
                                                         0, 1, 0)},
    _init: function(params) {
        this._expansion = 0;
        this._expandLines = DEFAULT_EXPAND_LINES;
        this.parent(params);
    },
    get expansion() {
        return this._expansion;
    },
    set expansion(v) {
        if (v == this._expansion)
            return;
        this._expansion = v;
        this.notify('expansion');
        let visibleIndex = this._expansion > 0 ? 1 : 0;
        for (let i = 0; this._container && i < this._container.get_n_children(); i++)
            this._container.get_child_at_index(i).visible = (i == visibleIndex);
        this.layout_changed();
    },
    set expandLines(v) {
        if (v == this._expandLines)
            return;
        this._expandLines = v;
        if (this._expansion > 0)
            this.layout_changed();
    },
    vfunc_set_container: function(container) {
        this._container = container;
    },
    vfunc_get_preferred_width: function(container, forHeight) {
        let [min, nat] = [0, 0];
        for (let i = 0; i < container.get_n_children(); i++) {
            if (i > 1)
                break; // we support one unexpanded + one expanded child
            let child = container.get_child_at_index(i);
            let [childMin, childNat] = child.get_preferred_width(forHeight);
            [min, nat] = [Math.max(min, childMin), Math.max(nat, childNat)];
        }
        return [min, nat];
    },
    vfunc_get_preferred_height: function(container, forWidth) {
        let [min, nat] = [0, 0];
        let children = container.get_children();
        if (children[0])
            [min, nat] = children[0].get_preferred_height(forWidth);
        if (children[1]) {
            let [min2, nat2] = children[1].get_preferred_height(forWidth);
            let [expMin, expNat] = [Math.min(min2, min * this._expandLines),
                                    Math.min(nat2, nat * this._expandLines)];
            [min, nat] = [min + this._expansion * (expMin - min),
                          nat + this._expansion * (expNat - nat)];
        }
        return [min, nat];
    },
    vfunc_allocate: function(container, box, flags) {
        for (let i = 0; i < container.get_n_children(); i++) {
            let child = container.get_child_at_index(i);
            if (child.visible)
                child.allocate(box, flags);
        }
    }
const Message = new Lang.Class({
    Name: 'Message',
    _init: function(title, body) {
        this.expanded = false;
        this.actor = new St.Button({ style_class: 'message',
                                     accessible_role: Atk.Role.NOTIFICATION,
                                     can_focus: true,
                                     x_expand: true, x_fill: true });
        this.actor.connect('key-press-event',
                           Lang.bind(this, this._onKeyPressed));
        let vbox = new St.BoxLayout({ vertical: true });
        this.actor.set_child(vbox);
        let hbox = new St.BoxLayout();
        vbox.add_actor(hbox);
        this._actionBin = new St.Widget({ layout_manager: new ScaleLayout(),
                                          visible: false });
        vbox.add_actor(this._actionBin);
        this._iconBin = new St.Bin({ style_class: 'message-icon-bin',
                                     y_expand: true,
                                     visible: false });
        hbox.add_actor(this._iconBin);
        let contentBox = new St.BoxLayout({ style_class: 'message-content',
                                            vertical: true, x_expand: true });
        hbox.add_actor(contentBox);
        this._mediaControls = new St.BoxLayout();
        hbox.add_actor(this._mediaControls);
        let titleBox = new St.BoxLayout();
        contentBox.add_actor(titleBox);
        this.titleLabel = new St.Label({ style_class: 'message-title',
                                         x_expand: true,
                                         x_align: Clutter.ActorAlign.START });
        this.setTitle(title);
        titleBox.add_actor(this.titleLabel);
        this._secondaryBin = new St.Bin({ style_class: 'message-secondary-bin' });
        titleBox.add_actor(this._secondaryBin);
        let closeIcon = new St.Icon({ icon_name: 'window-close-symbolic',
                                      icon_size: 16 });
        this._closeButton = new St.Button({ child: closeIcon, visible: false });
        titleBox.add_actor(this._closeButton);
        this._bodyStack = new St.Widget({ x_expand: true });
        this._bodyStack.layout_manager = new LabelExpanderLayout();
        contentBox.add_actor(this._bodyStack);
        this.bodyLabel = new URLHighlighter('', false, this._useBodyMarkup);
        this.bodyLabel.actor.add_style_class_name('message-body');
        this._bodyStack.add_actor(this.bodyLabel.actor);
        this.setBody(body);
        this._closeButton.connect('clicked', Lang.bind(this, this.close));
        this.actor.connect('notify::hover', Lang.bind(this, this._sync));
        this.actor.connect('clicked', Lang.bind(this, this._onClicked));
        this.actor.connect('destroy', Lang.bind(this, this._onDestroy));
        this._sync();
    },
    close: function() {
        this.emit('close');
    },
    setIcon: function(actor) {
        this._iconBin.child = actor;
        this._iconBin.visible = (actor != null);
    },
    setSecondaryActor: function(actor) {
        this._secondaryBin.child = actor;
    },
    setTitle: function(text) {
        let title = text ? _fixMarkup(text.replace(/\n/g, ' '), false) : '';
        this.titleLabel.clutter_text.set_markup(title);
    },
    setBody: function(text) {
        this._bodyText = text;
        this.bodyLabel.setMarkup(text ? text.replace(/\n/g, ' ') : '',
                                 this._useBodyMarkup);
        if (this._expandedLabel)
            this._expandedLabel.setMarkup(text, this._useBodyMarkup);
    },
    setUseBodyMarkup: function(enable) {
        if (this._useBodyMarkup === enable)
            return;
        this._useBodyMarkup = enable;
        if (this.bodyLabel)
            this.setBody(this._bodyText);
    },
    setActionArea: function(actor) {
        if (actor == null) {
            if (this._actionBin.get_n_children() > 0)
                this._actionBin.get_child_at_index(0).destroy();
            return;
        }
        if (this._actionBin.get_n_children() > 0)
            throw new Error('Message already has an action area');
        this._actionBin.add_actor(actor);
        this._actionBin.visible = this.expanded;
    },
    addMediaControl: function(iconName, callback) {
        let icon = new St.Icon({ icon_name: iconName, icon_size: 16 });
        let button = new St.Button({ style_class: 'message-media-control',
                                     child: icon });
        button.connect('clicked', callback);
        this._mediaControls.add_actor(button);
        return button;
    },
    setExpandedBody: function(actor) {
        if (actor == null) {
            if (this._bodyStack.get_n_children() > 1)
                this._bodyStack.get_child_at_index(1).destroy();
            return;
        }
        if (this._bodyStack.get_n_children() > 1)
            throw new Error('Message already has an expanded body actor');
        this._bodyStack.insert_child_at_index(actor, 1);
    },
    setExpandedLines: function(nLines) {
        this._bodyStack.layout_manager.expandLines = nLines;
    },
    expand: function(animate) {
        this.expanded = true;
        this._actionBin.visible = (this._actionBin.get_n_children() > 0);
        if (this._bodyStack.get_n_children() < 2) {
            this._expandedLabel = new URLHighlighter(this._bodyText,
                                                     true, this._useBodyMarkup);
            this.setExpandedBody(this._expandedLabel.actor);
        }
        if (animate) {
            Tweener.addTween(this._bodyStack.layout_manager,
                             { expansion: 1,
                               time: MessageTray.ANIMATION_TIME,
                               transition: 'easeOutQuad' });
            this._actionBin.scale_y = 0;
            Tweener.addTween(this._actionBin,
                             { scale_y: 1,
                               time: MessageTray.ANIMATION_TIME,
                               transition: 'easeOutQuad' });
        } else {
            this._bodyStack.layout_manager.expansion = 1;
            this._actionBin.scale_y = 1;
        }
        this.emit('expanded');
    },
    unexpand: function(animate) {
        if (animate) {
            Tweener.addTween(this._bodyStack.layout_manager,
                             { expansion: 0,
                               time: MessageTray.ANIMATION_TIME,
                               transition: 'easeOutQuad' });
            Tweener.addTween(this._actionBin,
                             { scale_y: 0,
                               time: MessageTray.ANIMATION_TIME,
                               transition: 'easeOutQuad',
                               onCompleteScope: this,
                               onComplete: function() {
                                   this._actionBin.hide();
                                   this.expanded = false;
                               }});
        } else {
            this._bodyStack.layout_manager.expansion = 0;
            this._actionBin.scale_y = 0;
            this.expanded = false;
        }
        this.emit('unexpanded');
    },
    canClose: function() {
        return this._mediaControls.get_n_children() == 0;
    },
    _sync: function() {
        let hovered = this.actor.hover;
        this._closeButton.visible = hovered && this.canClose();
        this._secondaryBin.visible = !hovered;
    },
    _onClicked: function() {
    },
    _onDestroy: function() {
    },
    _onKeyPressed: function(a, event) {
        let keysym = event.get_key_symbol();
        if (keysym == Clutter.KEY_Delete ||
            keysym == Clutter.KEY_KP_Delete) {
            this.close();
            return Clutter.EVENT_STOP;
        }
        return Clutter.EVENT_PROPAGATE;
    }
Signals.addSignalMethods(Message.prototype);
const MessageListSection = new Lang.Class({
    Name: 'MessageListSection',
    _init: function(title) {
        this.actor = new St.BoxLayout({ style_class: 'message-list-section',
                                        clip_to_allocation: true,
                                        x_expand: true, vertical: true });
        let titleBox = new St.BoxLayout({ style_class: 'message-list-section-title-box' });
        this.actor.add_actor(titleBox);
        this._title = new St.Button({ style_class: 'message-list-section-title',
                                      label: title,
                                      can_focus: true,
                                      x_expand: true,
                                      x_align: St.Align.START });
        titleBox.add_actor(this._title);
        this._title.connect('clicked', Lang.bind(this, this._onTitleClicked));
        this._title.connect('key-focus-in', Lang.bind(this, this._onKeyFocusIn));
        let closeIcon = new St.Icon({ icon_name: 'window-close-symbolic' });
        this._closeButton = new St.Button({ style_class: 'message-list-section-close',
                                            child: closeIcon,
                                            accessible_name: _("Clear section"),
                                            can_focus: true });
        this._closeButton.set_x_align(Clutter.ActorAlign.END);
        titleBox.add_actor(this._closeButton);
        this._closeButton.connect('clicked', Lang.bind(this, this.clear));
        this._list = new St.BoxLayout({ style_class: 'message-list-section-list',
                                        vertical: true });
        this.actor.add_actor(this._list);
        this._list.connect('actor-added', Lang.bind(this, this._sync));
        this._list.connect('actor-removed', Lang.bind(this, this._sync));
        let id = Main.sessionMode.connect('updated',
                                          Lang.bind(this, this._sync));
        this.actor.connect('destroy', function() {
            Main.sessionMode.disconnect(id);
        });
        this._messages = new Map();
        this._date = new Date();
        this.empty = true;
        this._sync();
    },
    _onTitleClicked: function() {
        Main.overview.hide();
        Main.panel.closeCalendar();
    },
    _onKeyFocusIn: function(actor) {
        this.emit('key-focus-in', actor);
    },
    get allowed() {
        return true;
    },
    setDate: function(date) {
        if (Calendar.sameDay(date, this._date))
            return;
        this._date = date;
        this._sync();
    },
    addMessage: function(message, animate) {
        this.addMessageAtIndex(message, -1, animate);
    },
    addMessageAtIndex: function(message, index, animate) {
        let obj = {
            container: null,
            destroyId: 0,
            keyFocusId: 0,
            closeId: 0
        };
        let pivot = new Clutter.Point({ x: .5, y: .5 });
        let scale = animate ? 0 : 1;
        obj.container = new St.Widget({ layout_manager: new ScaleLayout(),
                                        pivot_point: pivot,
                                        scale_x: scale, scale_y: scale });
        obj.keyFocusId = message.actor.connect('key-focus-in',
            Lang.bind(this, this._onKeyFocusIn));
        obj.destroyId = message.actor.connect('destroy',
            Lang.bind(this, function() {
                this.removeMessage(message, false);
            }));
        obj.closeId = message.connect('close',
            Lang.bind(this, function() {
                this.removeMessage(message, true);
            }));
        this._messages.set(message, obj);
        obj.container.add_actor(message.actor);
        this._list.insert_child_at_index(obj.container, index);
        if (animate)
            Tweener.addTween(obj.container, { scale_x: 1,
                                              scale_y: 1,
                                              time: MESSAGE_ANIMATION_TIME,
                                              transition: 'easeOutQuad' });
    },
    moveMessage: function(message, index, animate) {
        let obj = this._messages.get(message);
        if (!animate) {
            this._list.set_child_at_index(obj.container, index);
            return;
        }
        let onComplete = Lang.bind(this, function() {
            this._list.set_child_at_index(obj.container, index);
            Tweener.addTween(obj.container, { scale_x: 1,
                                              scale_y: 1,
                                              time: MESSAGE_ANIMATION_TIME,
                                              transition: 'easeOutQuad' });
        });
        Tweener.addTween(obj.container, { scale_x: 0,
                                          scale_y: 0,
                                          time: MESSAGE_ANIMATION_TIME,
                                          transition: 'easeOutQuad',
                                          onComplete: onComplete });
    },
    removeMessage: function(message, animate) {
        let obj = this._messages.get(message);
        message.actor.disconnect(obj.destroyId);
        message.actor.disconnect(obj.keyFocusId);
        message.disconnect(obj.closeId);
        this._messages.delete(message);
        if (animate) {
            Tweener.addTween(obj.container, { scale_x: 0, scale_y: 0,
                                              time: MESSAGE_ANIMATION_TIME,
                                              transition: 'easeOutQuad',
                                              onComplete: function() {
                                                  obj.container.destroy();
                                                  global.sync_pointer();
                                              }});
        } else {
            obj.container.destroy();
            global.sync_pointer();
        }
    },
    clear: function() {
        let messages = [...this._messages.keys()].filter(function(message) {
            return message.canClose();
        });
        // If there are few messages, letting them all zoom out looks OK
        if (messages.length < 2) {
            messages.forEach(function(message) {
                message.close();
            });
        } else {
            // Otherwise we slide them out one by one, and then zoom them
            // out "off-screen" in the end to smoothly shrink the parent
            let delay = MESSAGE_ANIMATION_TIME / Math.max(messages.length, 5);
            for (let i = 0; i < messages.length; i++) {
                let message = messages[i];
                let obj = this._messages.get(message);
                Tweener.addTween(obj.container,
                                 { anchor_x: this._list.width,
                                   opacity: 0,
                                   time: MESSAGE_ANIMATION_TIME,
                                   delay: i * delay,
                                   transition: 'easeOutQuad',
                                   onComplete: function() {
                                       message.close();
                                   }});
            }
        }
    },
    _canClear: function() {
        for (let message of this._messages.keys())
            if (message.canClose())
                return true;
        return false;
    },
    _shouldShow: function() {
        return !this.empty;
    },
    _sync: function() {
        let empty = this._list.get_n_children() == 0;
        let changed = this.empty !== empty;
        this.empty = empty;
        if (changed)
            this.emit('empty-changed');
        this._closeButton.visible = this._canClear();
        this.actor.visible = this.allowed && this._shouldShow();
    }
Signals.addSignalMethods(MessageListSection.prototype);
(uuay)network.js
// -*- mode: js; js-indent-level: 4; indent-tabs-mode: nil -*-
const Clutter = imports.gi.Clutter;
const GLib = imports.gi.GLib;
const GObject = imports.gi.GObject;
const Gio = imports.gi.Gio;
const Gtk = imports.gi.Gtk;
const Lang = imports.lang;
const NetworkManager = imports.gi.NetworkManager;
const NMClient = imports.gi.NMClient;
const NMGtk = imports.gi.NMGtk;
const Signals = imports.signals;
const Shell = imports.gi.Shell;
const St = imports.gi.St;
const Animation = imports.ui.animation;
const Main = imports.ui.main;
const PanelMenu = imports.ui.panelMenu;
const PopupMenu = imports.ui.popupMenu;
const MessageTray = imports.ui.messageTray;
const ModalDialog = imports.ui.modalDialog;
const ModemManager = imports.misc.modemManager;
const Rfkill = imports.ui.status.rfkill;
const Util = imports.misc.util;
const NMConnectionCategory = {
    INVALID: 'invalid',
    WIRED: 'wired',
    WIRELESS: 'wireless',
    WWAN: 'wwan',
    VPN: 'vpn'
const NMAccessPointSecurity = {
    NONE: 1,
    WEP: 2,
    WPA_PSK: 3,
    WPA2_PSK: 4,
    WPA_ENT: 5,
    WPA2_ENT: 6
// small optimization, to avoid using [] all the time
const NM80211Mode = NetworkManager['80211Mode'];
const NM80211ApFlags = NetworkManager['80211ApFlags'];
const NM80211ApSecurityFlags = NetworkManager['80211ApSecurityFlags'];
const PortalHelperResult = {
    CANCELLED: 0,
    COMPLETED: 1,
    RECHECK: 2
const PortalHelperIface = '<node> \
<interface name="org.gnome.Shell.PortalHelper"> \
<method name="Authenticate"> \
    <arg type="o" direction="in" name="connection" /> \
    <arg type="s" direction="in" name="url" /> \
    <arg type="u" direction="in" name="timestamp" /> \
</method> \
<method name="Close"> \
    <arg type="o" direction="in" name="connection" /> \
</method> \
<method name="Refresh"> \
    <arg type="o" direction="in" name="connection" /> \
</method> \
<signal name="Done"> \
    <arg type="o" name="connection" /> \
    <arg type="u" name="result" /> \
</signal> \
</interface> \
</node>';
const PortalHelperProxy = Gio.DBusProxy.makeProxyWrapper(PortalHelperIface);
function ssidCompare(one, two) {
    if (!one || !two)
        return false;
    if (one.length != two.length)
        return false;
    for (let i = 0; i < one.length; i++) {
        if (one[i] != two[i])
            return false;
    }
    return true;
function signalToIcon(value) {
    if (value > 80)
        return 'excellent';
    if (value > 55)
        return 'good';
    if (value > 30)
        return 'ok';
    if (value > 5)
        return 'weak';
    return 'none';
function ssidToLabel(ssid) {
    let label = NetworkManager.utils_ssid_to_utf8(ssid);
    if (!label)
        label = _("<unknown>");
    return label;
function ensureActiveConnectionProps(active, settings) {
    if (!active._connection) {
        active._connection = settings.get_connection_by_path(active.connection);
        // This list is guaranteed to have only one device in it.
        let device = active.get_devices()[0]._delegate;
        active._primaryDevice = device;
    }
function createSettingsAction(label, device) {
    let item = new PopupMenu.PopupMenuItem(label);
    item.connect('activate', function() {
        Util.spawnApp(['gnome-control-center', 'network', 'show-device',
                       device.get_path()]);
    });
    return item;
const NMConnectionItem = new Lang.Class({
    Name: 'NMConnectionItem',
    _init: function(section, connection) {
        this._section = section;
        this._connection = connection;
        this._activeConnection = null;
        this._activeConnectionChangedId = 0;
        this._buildUI();
        this._sync();
    },
    _buildUI: function() {
        this.labelItem = new PopupMenu.PopupMenuItem('');
        this.labelItem.connect('activate', Lang.bind(this, this._toggle));
        this.radioItem = new PopupMenu.PopupMenuItem(this._connection.get_id(), false);
        this.radioItem.connect('activate', Lang.bind(this, this._activate));
    },
    destroy: function() {
        this.labelItem.destroy();
        this.radioItem.destroy();
    },
    updateForConnection: function(connection) {
        // connection should always be the same object
        // (and object path) as this._connection, but
        // this can be false if NetworkManager was restarted
        // and picked up connections in a different order
        // Just to be safe, we set it here again
        this._connection = connection;
        this.radioItem.label.text = connection.get_id();
        this._sync();
        this.emit('name-changed');
    },
    getName: function() {
        return this._connection.get_id();
    },
    isActive: function() {
        if (this._activeConnection == null)
            return false;
        return this._activeConnection.state <= NetworkManager.ActiveConnectionState.ACTIVATED;
    },
    _sync: function() {
        let isActive = this.isActive();
        this.labelItem.label.text = isActive ? _("Turn Off") : this._section.getConnectLabel();
        this.radioItem.setOrnament(isActive ? PopupMenu.Ornament.DOT : PopupMenu.Ornament.NONE);
        this.emit('icon-changed');
    },
    _toggle: function() {
        if (this._activeConnection == null)
            this._section.activateConnection(this._connection);
        else
            this._section.deactivateConnection(this._activeConnection);
        this._sync();
    },
    _activate: function() {
        if (this._activeConnection == null)
            this._section.activateConnection(this._connection);
        this._sync();
    },
    _connectionStateChanged: function(ac, newstate, reason) {
        this._sync();
    },
    setActiveConnection: function(activeConnection) {
        if (this._activeConnectionChangedId > 0) {
            this._activeConnection.disconnect(this._activeConnectionChangedId);
            this._activeConnectionChangedId = 0;
        }
        this._activeConnection = activeConnection;
        if (this._activeConnection)
            this._activeConnectionChangedId = this._activeConnection.connect('notify::state',
                                                                             Lang.bind(this, this._connectionStateChanged));
        this._sync();
    },
Signals.addSignalMethods(NMConnectionItem.prototype);
const NMConnectionSection = new Lang.Class({
    Name: 'NMConnectionSection',
    Abstract: true,
    _init: function(client) {
        this._client = client;
        this._connectionItems = new Map();
        this._connections = [];
        this._labelSection = new PopupMenu.PopupMenuSection();
        this._radioSection = new PopupMenu.PopupMenuSection();
        this.item = new PopupMenu.PopupSubMenuMenuItem('', true);
        this.item.menu.addMenuItem(this._labelSection);
        this.item.menu.addMenuItem(this._radioSection);
        this._notifyConnectivityId = this._client.connect('notify::connectivity', Lang.bind(this, this._iconChanged));
    },
    destroy: function() {
        if (this._notifyConnectivityId != 0) {
            this._client.disconnect(this._notifyConnectivityId);
            this._notifyConnectivityId = 0;
        }
        this.item.destroy();
    },
    _iconChanged: function() {
        this._sync();
        this.emit('icon-changed');
    },
    _sync: function() {
        let nItems = this._connectionItems.size;
        this._radioSection.actor.visible = (nItems > 1);
        this._labelSection.actor.visible = (nItems == 1);
        this.item.label.text = this._getStatus();
        this.item.icon.icon_name = this._getMenuIcon();
    },
    _getMenuIcon: function() {
        return this.getIndicatorIcon();
    },
    getConnectLabel: function() {
        return _("Connect");
    },
    _connectionValid: function(connection) {
        return true;
    },
    _connectionSortFunction: function(one, two) {
        return GLib.utf8_collate(one.get_id(), two.get_id());
    },
    _makeConnectionItem: function(connection) {
        return new NMConnectionItem(this, connection);
    },
    checkConnection: function(connection) {
        if (!this._connectionValid(connection))
            return;
        // This function is called everytime connection is added or updated
        // In the usual case, we already added this connection and UUID
        // didn't change. So we need to check if we already have an item,
        // and update it for properties in the connection that changed
        // (the only one we care about is the name)
        // But it's also possible we didn't know about this connection
        // (eg, during coldplug, or because it was updated and suddenly
        // it's valid for this device), in which case we add a new item
        let item = this._connectionItems.get(connection.get_uuid());
        if (item)
            item.updateForConnection(connection);
        else
            this._addConnection(connection);
    },
    _addConnection: function(connection) {
        let item = this._makeConnectionItem(connection);
        if (!item)
            return;
        item.connect('icon-changed', Lang.bind(this, function() {
            this._iconChanged();
        }));
        item.connect('activation-failed', Lang.bind(this, function(item, reason) {
            this.emit('activation-failed', reason);
        }));
        item.connect('name-changed', Lang.bind(this, this._sync));
        let pos = Util.insertSorted(this._connections, connection, Lang.bind(this, this._connectionSortFunction));
        this._labelSection.addMenuItem(item.labelItem, pos);
        this._radioSection.addMenuItem(item.radioItem, pos);
        this._connectionItems.set(connection.get_uuid(), item);
        this._sync();
    },
    removeConnection: function(connection) {
        let uuid = connection.get_uuid();
        let item = this._connectionItems.get(uuid);
        if (item == undefined)
            return;
        item.destroy();
        this._connectionItems.delete(uuid);
        let pos = this._connections.indexOf(connection);
        this._connections.splice(pos, 1);
        this._sync();
    },
Signals.addSignalMethods(NMConnectionSection.prototype);
const NMConnectionDevice = new Lang.Class({
    Name: 'NMConnectionDevice',
    Extends: NMConnectionSection,
    Abstract: true,
    _init: function(client, device, settings) {
        this.parent(client);
        this._device = device;
        this._settings = settings;
        this._description = '';
        this._autoConnectItem = this.item.menu.addAction(_("Connect"), Lang.bind(this, this._autoConnect));
        this._deactivateItem = this._radioSection.addAction(_("Turn Off"), Lang.bind(this, this.deactivateConnection));
        this._stateChangedId = this._device.connect('state-changed', Lang.bind(this, this._deviceStateChanged));
        this._activeConnectionChangedId = this._device.connect('notify::active-connection', Lang.bind(this, this._activeConnectionChanged));
    },
    _canReachInternet: function() {
        if (this._client.primary_connection != this._device.active_connection)
            return true;
        return this._client.connectivity == NetworkManager.ConnectivityState.FULL;
    },
    _autoConnect: function() {
        let connection = new NetworkManager.Connection();
        this._client.add_and_activate_connection(connection, this._device, null, null);
    },
    destroy: function() {
        if (this._stateChangedId) {
            GObject.Object.prototype.disconnect.call(this._device, this._stateChangedId);
            this._stateChangedId = 0;
        }
        if (this._activeConnectionChangedId) {
            GObject.Object.prototype.disconnect.call(this._device, this._activeConnectionChangedId);
            this._activeConnectionChangedId = 0;
        }
        this.parent();
    },
    _activeConnectionChanged: function() {
        if (this._activeConnection) {
            let item = this._connectionItems.get(this._activeConnection._connection.get_uuid());
            item.setActiveConnection(null);
        }
        this._activeConnection = this._device.active_connection;
        if (this._activeConnection) {
            ensureActiveConnectionProps(this._activeConnection, this._settings);
            let item = this._connectionItems.get(this._activeConnection._connection.get_uuid());
            item.setActiveConnection(this._activeConnection);
        }
    },
    _deviceStateChanged: function(device, newstate, oldstate, reason) {
        if (newstate == oldstate) {
            log('device emitted state-changed without actually changing state');
            return;
        }
        /* Emit a notification if activation fails, but don't do it
           if the reason is no secrets, as that indicates the user
           cancelled the agent dialog */
        if (newstate == NetworkManager.DeviceState.FAILED &&
            reason != NetworkManager.DeviceStateReason.NO_SECRETS) {
            this.emit('activation-failed', reason);
        }
        this._sync();
    },
    _connectionValid: function(connection) {
        return this._device.connection_valid(connection);
    },
    activateConnection: function(connection) {
        this._client.activate_connection(connection, this._device, null, null);
    },
    deactivateConnection: function(activeConnection) {
        this._device.disconnect(null);
    },
    setDeviceDescription: function(desc) {
        this._description = desc;
        this._sync();
    },
    _getDescription: function() {
        return this._description;
    },
    _sync: function() {
        let nItems = this._connectionItems.size;
        this._autoConnectItem.actor.visible = (nItems == 0);
        this._deactivateItem.actor.visible = this._device.state > NetworkManager.DeviceState.DISCONNECTED;
        this.parent();
    },
    _getStatus: function() {
        if (!this._device)
            return '';
        switch(this._device.state) {
        case NetworkManager.DeviceState.DISCONNECTED:
            /* Translators: %s is a network identifier */
            return _("%s Off").format(this._getDescription());
        case NetworkManager.DeviceState.ACTIVATED:
            /* Translators: %s is a network identifier */
            return _("%s Connected").format(this._getDescription());
        case NetworkManager.DeviceState.UNMANAGED:
            /* Translators: this is for network devices that are physically present but are not
               under NetworkManager's control (and thus cannot be used in the menu);
               %s is a network identifier */
            return _("%s Unmanaged").format(this._getDescription());
        case NetworkManager.DeviceState.DEACTIVATING:
            /* Translators: %s is a network identifier */
            return _("%s Disconnecting").format(this._getDescription());
        case NetworkManager.DeviceState.PREPARE:
        case NetworkManager.DeviceState.CONFIG:
        case NetworkManager.DeviceState.IP_CONFIG:
        case NetworkManager.DeviceState.IP_CHECK:
        case NetworkManager.DeviceState.SECONDARIES:
            /* Translators: %s is a network identifier */
            return _("%s Connecting").format(this._getDescription());
        case NetworkManager.DeviceState.NEED_AUTH:
            /* Translators: this is for network connections that require some kind of key or password; %s is a network identifier */
            return _("%s Requires Authentication").format(this._getDescription());
        case NetworkManager.DeviceState.UNAVAILABLE:
            // This state is actually a compound of various states (generically unavailable,
            // firmware missing), that are exposed by different properties (whose state may
            // or may not updated when we receive state-changed).
            if (this._device.firmware_missing) {
                /* Translators: this is for devices that require some kind of firmware or kernel
                   module, which is missing; %s is a network identifier */
                return _("Firmware Missing For %s").format(this._getDescription());
            }
            /* Translators: this is for a network device that cannot be activated (for example it
               is disabled by rfkill, or it has no coverage; %s is a network identifier */
            return _("%s Unavailable").format(this._getDescription());
        case NetworkManager.DeviceState.FAILED:
            /* Translators: %s is a network identifier */
            return _("%s Connection Failed").format(this._getDescription());
        default:
            log('Device state invalid, is %d'.format(this._device.state));
            return 'invalid';
        }
    },
const NMDeviceWired = new Lang.Class({
    Name: 'NMDeviceWired',
    Extends: NMConnectionDevice,
    category: NMConnectionCategory.WIRED,
    _init: function(client, device, settings) {
        this.parent(client, device, settings);
        this.item.menu.addMenuItem(createSettingsAction(_("Wired Settings"), device));
    },
    _hasCarrier: function() {
        if (this._device instanceof NMClient.DeviceEthernet)
            return this._device.carrier;
        else
            return true;
    },
    _sync: function() {
        this.item.actor.visible = this._hasCarrier();
        this.parent();
    },
    getIndicatorIcon: function() {
        if (this._device.active_connection) {
            let state = this._device.active_connection.state;
            if (state == NetworkManager.ActiveConnectionState.ACTIVATING) {
                return 'network-wired-acquiring-symbolic';
            } else if (state == NetworkManager.ActiveConnectionState.ACTIVATED) {
                if (this._canReachInternet())
                    return 'network-wired-symbolic';
                else
                    return 'network-wired-no-route-symbolic';
            } else {
                return 'network-wired-disconnected-symbolic';
            }
        } else
            return 'network-wired-disconnected-symbolic';
    }
const NMDeviceModem = new Lang.Class({
    Name: 'NMDeviceModem',
    Extends: NMConnectionDevice,
    category: NMConnectionCategory.WWAN,
    _init: function(client, device, settings) {
        this.parent(client, device, settings);
        this.item.menu.addMenuItem(createSettingsAction(_("Mobile Broadband Settings"), device));
        this._mobileDevice = null;
        let capabilities = device.current_capabilities;
        if (device.udi.indexOf('/org/freedesktop/ModemManager1/Modem') == 0)
            this._mobileDevice = new ModemManager.BroadbandModem(device.udi, capabilities);
        else if (capabilities & NetworkManager.DeviceModemCapabilities.GSM_UMTS)
            this._mobileDevice = new ModemManager.ModemGsm(device.udi);
        else if (capabilities & NetworkManager.DeviceModemCapabilities.CDMA_EVDO)
            this._mobileDevice = new ModemManager.ModemCdma(device.udi);
        else if (capabilities & NetworkManager.DeviceModemCapabilities.LTE)
            this._mobileDevice = new ModemManager.ModemGsm(device.udi);
        if (this._mobileDevice) {
            this._operatorNameId = this._mobileDevice.connect('notify::operator-name', Lang.bind(this, this._sync));
            this._signalQualityId = this._mobileDevice.connect('notify::signal-quality', Lang.bind(this, function() {
                this._iconChanged();
            }));
        }
    },
    _autoConnect: function() {
        Util.spawn(['gnome-control-center', 'network',
                    'connect-3g', this._device.get_path()]);
    },
    destroy: function() {
        if (this._operatorNameId) {
            this._mobileDevice.disconnect(this._operatorNameId);
            this._operatorNameId = 0;
        }
        if (this._signalQualityId) {
            this._mobileDevice.disconnect(this._signalQualityId);
            this._signalQualityId = 0;
        }
        this.parent();
    },
    _getStatus: function() {
        if (!this._client.wwan_hardware_enabled)
            /* Translators: %s is a network identifier */
            return _("%s Hardware Disabled").format(this._getDescription());
        else if (!this._client.wwan_enabled)
            /* Translators: this is for a network device that cannot be activated
               because it's disabled by rfkill (airplane mode); %s is a network identifier */
            return _("%s Disabled").format(this._getDescription());
        else if (this._device.state == NetworkManager.DeviceState.ACTIVATED &&
                 this._mobileDevice && this._mobileDevice.operator_name)
            return this._mobileDevice.operator_name;
        else
            return this.parent();
    },
    getIndicatorIcon: function() {
        if (this._device.active_connection) {
            if (this._device.active_connection.state == NetworkManager.ActiveConnectionState.ACTIVATING)
                return 'network-cellular-acquiring-symbolic';
            return this._getSignalIcon();
        } else {
            return 'network-cellular-signal-none-symbolic';
        }
    },
    _getSignalIcon: function() {
        return 'network-cellular-signal-' + signalToIcon(this._mobileDevice.signal_quality) + '-symbolic';
    },
const NMDeviceBluetooth = new Lang.Class({
    Name: 'NMDeviceBluetooth',
    Extends: NMConnectionDevice,
    category: NMConnectionCategory.WWAN,
    _init: function(client, device, settings) {
        this.parent(client, device, settings);
        this.item.menu.addMenuItem(createSettingsAction(_("Bluetooth Settings"), device));
    },
    _getDescription: function() {
        return this._device.name;
    },
    getConnectLabel: function() {
        return _("Connect to Internet");
    },
    getIndicatorIcon: function() {
        if (this._device.active_connection) {
            let state = this._device.active_connection.state;
            if (state == NetworkManager.ActiveConnectionState.ACTIVATING)
                return 'network-cellular-acquiring-symbolic';
            else if (state == NetworkManager.ActiveConnectionState.ACTIVATED)
                return 'network-cellular-connected-symbolic';
            else
                return 'network-cellular-signal-none-symbolic';
        } else {
            return 'network-cellular-signal-none-symbolic';
        }
    }
const NMWirelessDialogItem = new Lang.Class({
    Name: 'NMWirelessDialogItem',
    _init: function(network) {
        this._network = network;
        this._ap = network.accessPoints[0];
        this.actor = new St.BoxLayout({ style_class: 'nm-dialog-item',
                                        can_focus: true,
                                        reactive: true });
        this.actor.connect('key-focus-in', Lang.bind(this, function() {
            this.emit('selected');
        }));
        let action = new Clutter.ClickAction();
        action.connect('clicked', Lang.bind(this, function() {
            this.actor.grab_key_focus();
        }));
        this.actor.add_action(action);
        let title = ssidToLabel(this._ap.get_ssid());
        this._label = new St.Label({ text: title });
        this.actor.label_actor = this._label;
        this.actor.add(this._label, { x_align: St.Align.START });
        this._selectedIcon = new St.Icon({ style_class: 'nm-dialog-icon',
                                           icon_name: 'object-select-symbolic' });
        this.actor.add(this._selectedIcon);
        this._icons = new St.BoxLayout({ style_class: 'nm-dialog-icons' });
        this.actor.add(this._icons, { expand: true, x_fill: false, x_align: St.Align.END });
        this._secureIcon = new St.Icon({ style_class: 'nm-dialog-icon' });
        if (this._ap._secType != NMAccessPointSecurity.NONE)
            this._secureIcon.icon_name = 'network-wireless-encrypted-symbolic';
        this._icons.add_actor(this._secureIcon);
        this._signalIcon = new St.Icon({ style_class: 'nm-dialog-icon' });
        this._icons.add_actor(this._signalIcon);
        this._sync();
    },
    _sync: function() {
        this._signalIcon.icon_name = this._getSignalIcon();
    },
    updateBestAP: function(ap) {
        this._ap = ap;
        this._sync();
    },
    setActive: function(isActive) {
        this._selectedIcon.opacity = isActive ? 255 : 0;
    },
    _getSignalIcon: function() {
        if (this._ap.mode == NM80211Mode.ADHOC)
            return 'network-workgroup-symbolic';
        else
            return 'network-wireless-signal-' + signalToIcon(this._ap.strength) + '-symbolic';
    }
Signals.addSignalMethods(NMWirelessDialogItem.prototype);
const NMWirelessDialog = new Lang.Class({
    Name: 'NMWirelessDialog',
    Extends: ModalDialog.ModalDialog,
    _init: function(client, device, settings) {
        this.parent({ styleClass: 'nm-dialog' });
        this._client = client;
        this._device = device;
        this._wirelessEnabledChangedId = this._client.connect('notify::wireless-enabled',
                                                              Lang.bind(this, this._syncView));
        this._rfkill = Rfkill.getRfkillManager();
        this._airplaneModeChangedId = this._rfkill.connect('airplane-mode-changed',
                                                           Lang.bind(this, this._syncView));
        this._networks = [];
        this._buildLayout();
        let connections = settings.list_connections();
        this._connections = connections.filter(Lang.bind(this, function(connection) {
            return device.connection_valid(connection);
        }));
        this._apAddedId = device.connect('access-point-added', Lang.bind(this, this._accessPointAdded));
        this._apRemovedId = device.connect('access-point-removed', Lang.bind(this, this._accessPointRemoved));
        this._activeApChangedId = device.connect('notify::active-access-point', Lang.bind(this, this._activeApChanged));
        // accessPointAdded will also create dialog items
        let accessPoints = device.get_access_points() || [ ];
        accessPoints.forEach(Lang.bind(this, function(ap) {
            this._accessPointAdded(this._device, ap);
        }));
        this._selectedNetwork = null;
        this._activeApChanged();
        this._updateSensitivity();
        this._syncView();
        if (accessPoints.length == 0) {
            /* If there are no visible access points, request a scan */
            this._device.request_scan_simple(null);
        }
    },
    destroy: function() {
        if (this._apAddedId) {
            GObject.Object.prototype.disconnect.call(this._device, this._apAddedId);
            this._apAddedId = 0;
        }
        if (this._apRemovedId) {
            GObject.Object.prototype.disconnect.call(this._device, this._apRemovedId);
            this._apRemovedId = 0;
        }
        if (this._activeApChangedId) {
            GObject.Object.prototype.disconnect.call(this._device, this._activeApChangedId);
            this._activeApChangedId = 0;
        }
        if (this._wirelessEnabledChangedId) {
            this._client.disconnect(this._wirelessEnabledChangedId);
            this._wirelessEnabledChangedId = 0;
        }
        if (this._airplaneModeChangedId) {
            this._rfkill.disconnect(this._airplaneModeChangedId);
            this._airplaneModeChangedId = 0;
        }
        this.parent();
    },
    _activeApChanged: function() {
        if (this._activeNetwork)
            this._activeNetwork.item.setActive(false);
        this._activeNetwork = null;
        if (this._device.active_access_point) {
            let idx = this._findNetwork(this._device.active_access_point);
            if (idx >= 0)
                this._activeNetwork = this._networks[idx];
        }
        if (this._activeNetwork)
            this._activeNetwork.item.setActive(true);
        this._updateSensitivity();
    },
    _updateSensitivity: function() {
        let connectSensitive = this._client.wireless_enabled && this._selectedNetwork && (this._selectedNetwork != this._activeNetwork);
        this._connectButton.reactive = connectSensitive;
        this._connectButton.can_focus = connectSensitive;
    },
    _syncView: function() {
        if (this._rfkill.airplaneMode) {
            this._airplaneBox.show();
            this._airplaneIcon.icon_name = 'airplane-mode-symbolic';
            this._airplaneHeadline.text = _("Airplane Mode is On");
            this._airplaneText.text = _("Wi-Fi is disabled when airplane mode is on.");
            this._airplaneButton.label = _("Turn Off Airplane Mode");
            this._airplaneButton.visible = !this._rfkill.hwAirplaneMode;
            this._airplaneInactive.visible = this._rfkill.hwAirplaneMode;
            this._noNetworksBox.hide();
        } else if (!this._client.wireless_enabled) {
            this._airplaneBox.show();
            this._airplaneIcon.icon_name = 'dialog-information-symbolic';
            this._airplaneHeadline.text = _("Wi-Fi is Off");
            this._airplaneText.text = _("Wi-Fi needs to be turned on in order to connect to a network.");
            this._airplaneButton.label = _("Turn On Wi-Fi");
            this._airplaneButton.show();
            this._airplaneInactive.hide();
            this._noNetworksBox.hide();
        } else {
            this._airplaneBox.hide();
            this._noNetworksBox.visible = (this._networks.length == 0);
        }
        if (this._noNetworksBox.visible)
            this._noNetworksSpinner.play();
        else
            this._noNetworksSpinner.stop();
    },
    _buildLayout: function() {
        let headline = new St.BoxLayout({ style_class: 'nm-dialog-header-hbox' });
        let icon = new St.Icon({ style_class: 'nm-dialog-header-icon',
                                 icon_name: 'network-wireless-signal-excellent-symbolic' });
        let titleBox = new St.BoxLayout({ vertical: true });
        let title = new St.Label({ style_class: 'nm-dialog-header',
                                   text: _("Wi-Fi Networks") });
        let subtitle = new St.Label({ style_class: 'nm-dialog-subheader',
                                      text: _("Select a network") });
        titleBox.add(title);
        titleBox.add(subtitle);
        headline.add(icon);
        headline.add(titleBox);
        this.contentLayout.style_class = 'nm-dialog-content';
        this.contentLayout.add(headline);
        this._stack = new St.Widget({ layout_manager: new Clutter.BinLayout() });
        this._itemBox = new St.BoxLayout({ vertical: true });
        this._scrollView = new St.ScrollView({ style_class: 'nm-dialog-scroll-view' });
        this._scrollView.set_x_expand(true);
        this._scrollView.set_y_expand(true);
        this._scrollView.set_policy(Gtk.PolicyType.NEVER,
                                    Gtk.PolicyType.AUTOMATIC);
        this._scrollView.add_actor(this._itemBox);
        this._stack.add_child(this._scrollView);
        this._noNetworksBox = new St.BoxLayout({ vertical: true,
                                                 style_class: 'no-networks-box',
                                                 x_align: Clutter.ActorAlign.CENTER,
                                                 y_align: Clutter.ActorAlign.CENTER });
        let file = Gio.File.new_for_uri('resource:///org/gnome/shell/theme/process-working.svg');
        this._noNetworksSpinner = new Animation.AnimatedIcon(file, 16, 16);
        this._noNetworksBox.add_actor(this._noNetworksSpinner.actor);
        this._noNetworksBox.add_actor(new St.Label({ style_class: 'no-networks-label',
                                                     text: _("No Networks") }));
        this._stack.add_child(this._noNetworksBox);
        this._airplaneBox = new St.BoxLayout({ vertical: true,
                                               style_class: 'nm-dialog-airplane-box',
                                               x_align: Clutter.ActorAlign.CENTER,
                                               y_align: Clutter.ActorAlign.CENTER });
        this._airplaneIcon = new St.Icon({ icon_size: 48 });
        this._airplaneHeadline = new St.Label({ style_class: 'nm-dialog-airplane-headline headline' });
        this._airplaneText = new St.Label({ style_class: 'nm-dialog-airplane-text' });
        let airplaneSubStack = new St.Widget({ layout_manager: new Clutter.BinLayout });
        this._airplaneButton = new St.Button({ style_class: 'modal-dialog-button button' });
        this._airplaneButton.connect('clicked', Lang.bind(this, function() {
            if (this._rfkill.airplaneMode)
                this._rfkill.airplaneMode = false;
            else
                this._client.wireless_enabled = true;
        }));
        airplaneSubStack.add_actor(this._airplaneButton);
        this._airplaneInactive = new St.Label({ style_class: 'nm-dialog-airplane-text',
                                                text: _("Use hardware switch to turn off") });
        airplaneSubStack.add_actor(this._airplaneInactive);
        this._airplaneBox.add(this._airplaneIcon, { x_align: St.Align.MIDDLE });
        this._airplaneBox.add(this._airplaneHeadline, { x_align: St.Align.MIDDLE });
        this._airplaneBox.add(this._airplaneText, { x_align: St.Align.MIDDLE });
        this._airplaneBox.add(airplaneSubStack, { x_align: St.Align.MIDDLE });
        this._stack.add_child(this._airplaneBox);
        this.contentLayout.add(this._stack, { expand: true });
        this._disconnectButton = this.addButton({ action: Lang.bind(this, this.close),
                                                  label: _("Cancel"),
                                                  key: Clutter.Escape });
        this._connectButton = this.addButton({ action: Lang.bind(this, this._connect),
                                               label: _("Connect"),
                                               key: Clutter.Return });
    },
    _connect: function() {
        let network = this._selectedNetwork;
        if (network.connections.length > 0) {
            let connection = network.connections[0];
            this._client.activate_connection(connection, this._device, null, null);
        } else {
            let accessPoints = network.accessPoints;
            if ((accessPoints[0]._secType == NMAccessPointSecurity.WPA2_ENT)
                || (accessPoints[0]._secType == NMAccessPointSecurity.WPA_ENT)) {
                // 802.1x-enabled APs require further configuration, so they're
                // handled in gnome-control-center
                Util.spawn(['gnome-control-center', 'network', 'connect-8021x-wifi',
                            this._device.get_path(), accessPoints[0].dbus_path]);
            } else {
                let connection = new NetworkManager.Connection();
                this._client.add_and_activate_connection(connection, this._device, accessPoints[0].dbus_path, null)
            }
        }
        this.close();
    },
    _notifySsidCb: function(accessPoint) {
        if (accessPoint.get_ssid() != null) {
            accessPoint.disconnect(accessPoint._notifySsidId);
            accessPoint._notifySsidId = 0;
            this._accessPointAdded(this._device, accessPoint);
        }
    },
    _getApSecurityType: function(accessPoint) {
        if (accessPoint._secType)
            return accessPoint._secType;
        let flags = accessPoint.flags;
        let wpa_flags = accessPoint.wpa_flags;
        let rsn_flags = accessPoint.rsn_flags;
        let type;
        if (rsn_flags != NM80211ApSecurityFlags.NONE) {
            /* RSN check first so that WPA+WPA2 APs are treated as RSN/WPA2 */
            if (rsn_flags & NM80211ApSecurityFlags.KEY_MGMT_802_1X)
	        type = NMAccessPointSecurity.WPA2_ENT;
	    else if (rsn_flags & NM80211ApSecurityFlags.KEY_MGMT_PSK)
	        type = NMAccessPointSecurity.WPA2_PSK;
        } else if (wpa_flags != NM80211ApSecurityFlags.NONE) {
            if (wpa_flags & NM80211ApSecurityFlags.KEY_MGMT_802_1X)
                type = NMAccessPointSecurity.WPA_ENT;
            else if (wpa_flags & NM80211ApSecurityFlags.KEY_MGMT_PSK)
	        type = NMAccessPointSecurity.WPA_PSK;
        } else {
            if (flags & NM80211ApFlags.PRIVACY)
                type = NMAccessPointSecurity.WEP;
            else
                type = NMAccessPointSecurity.NONE;
        }
        // cache the found value to avoid checking flags all the time
        accessPoint._secType = type;
        return type;
    },
    _networkSortFunction: function(one, two) {
        let oneHasConnection = one.connections.length != 0;
        let twoHasConnection = two.connections.length != 0;
        // place known connections first
        // (-1 = good order, 1 = wrong order)
        if (oneHasConnection && !twoHasConnection)
            return -1;
        else if (!oneHasConnection && twoHasConnection)
            return 1;
        let oneStrength = one.accessPoints[0].strength;
        let twoStrength = two.accessPoints[0].strength;
        // place stronger connections first
        if (oneStrength != twoStrength)
            return oneStrength < twoStrength ? 1 : -1;
        let oneHasSecurity = one.security != NMAccessPointSecurity.NONE;
        let twoHasSecurity = two.security != NMAccessPointSecurity.NONE;
        // place secure connections first
        // (we treat WEP/WPA/WPA2 the same as there is no way to
        // take them apart from the UI)
        if (oneHasSecurity && !twoHasSecurity)
            return -1;
        else if (!oneHasSecurity && twoHasSecurity)
            return 1;
        // sort alphabetically
        return GLib.utf8_collate(one.ssidText, two.ssidText);
    },
    _networkCompare: function(network, accessPoint) {
        if (!ssidCompare(network.ssid, accessPoint.get_ssid()))
            return false;
        if (network.mode != accessPoint.mode)
            return false;
        if (network.security != this._getApSecurityType(accessPoint))
            return false;
        return true;
    },
    _findExistingNetwork: function(accessPoint) {
        for (let i = 0; i < this._networks.length; i++) {
            let network = this._networks[i];
            for (let j = 0; j < network.accessPoints.length; j++) {
                if (network.accessPoints[j] == accessPoint)
                    return { network: i, ap: j };
            }
        }
        return null;
    },
    _findNetwork: function(accessPoint) {
        if (accessPoint.get_ssid() == null)
            return -1;
        for (let i = 0; i < this._networks.length; i++) {
            if (this._networkCompare(this._networks[i], accessPoint))
                return i;
        }
        return -1;
    },
    _checkConnections: function(network, accessPoint) {
        this._connections.forEach(function(connection) {
            if (accessPoint.connection_valid(connection) &&
                network.connections.indexOf(connection) == -1) {
                network.connections.push(connection);
            }
        });
    },
    _accessPointAdded: function(device, accessPoint) {
        if (accessPoint.get_ssid() == null) {
            // This access point is not visible yet
            // Wait for it to get a ssid
            accessPoint._notifySsidId = accessPoint.connect('notify::ssid', Lang.bind(this, this._notifySsidCb));
            return;
        }
        let pos = this._findNetwork(accessPoint);
        let network;
        if (pos != -1) {
            network = this._networks[pos];
            if (network.accessPoints.indexOf(accessPoint) != -1) {
                log('Access point was already seen, not adding again');
                return;
            }
            Util.insertSorted(network.accessPoints, accessPoint, function(one, two) {
                return two.strength - one.strength;
            });
            network.item.updateBestAP(network.accessPoints[0]);
            this._checkConnections(network, accessPoint);
            this._resortItems();
        } else {
            network = { ssid: accessPoint.get_ssid(),
                        mode: accessPoint.mode,
                        security: this._getApSecurityType(accessPoint),
                        connections: [ ],
                        item: null,
                        accessPoints: [ accessPoint ]
                      };
            network.ssidText = ssidToLabel(network.ssid);
            this._checkConnections(network, accessPoint);
            let newPos = Util.insertSorted(this._networks, network, this._networkSortFunction);
            this._createNetworkItem(network);
            this._itemBox.insert_child_at_index(network.item.actor, newPos);
        }
        this._syncView();
    },
    _accessPointRemoved: function(device, accessPoint) {
        let res = this._findExistingNetwork(accessPoint);
        if (res == null) {
            log('Removing an access point that was never added');
            return;
        }
        let network = this._networks[res.network];
        network.accessPoints.splice(res.ap, 1);
        if (network.accessPoints.length == 0) {
            network.item.actor.destroy();
            this._networks.splice(res.network, 1);
        } else {
            network.item.updateBestAP(network.accessPoints[0]);
            this._resortItems();
        }
        this._syncView();
    },
    _resortItems: function() {
        let adjustment = this._scrollView.vscroll.adjustment;
        let scrollValue = adjustment.value;
        this._itemBox.remove_all_children();
        this._networks.forEach(Lang.bind(this, function(network) {
            this._itemBox.add_child(network.item.actor);
        }));
        adjustment.value = scrollValue;
    },
    _selectNetwork: function(network) {
        if (this._selectedNetwork)
            this._selectedNetwork.item.actor.remove_style_pseudo_class('selected');
        this._selectedNetwork = network;
        this._updateSensitivity();
        if (this._selectedNetwork)
            this._selectedNetwork.item.actor.add_style_pseudo_class('selected');
    },
    _createNetworkItem: function(network) {
        network.item = new NMWirelessDialogItem(network);
        network.item.setActive(network == this._selectedNetwork);
        network.item.connect('selected', Lang.bind(this, function() {
            Util.ensureActorVisibleInScrollView(this._scrollView, network.item.actor);
            this._selectNetwork(network);
        }));
    },
const NMDeviceWireless = new Lang.Class({
    Name: 'NMDeviceWireless',
    category: NMConnectionCategory.WIRELESS,
    _init: function(client, device, settings) {
        this._client = client;
        this._device = device;
        this._settings = settings;
        this._description = '';
        this.item = new PopupMenu.PopupSubMenuMenuItem('', true);
        this.item.menu.addAction(_("Select Network"), Lang.bind(this, this._showDialog));
        this._toggleItem = new PopupMenu.PopupMenuItem('');
        this._toggleItem.connect('activate', Lang.bind(this, this._toggleWifi));
        this.item.menu.addMenuItem(this._toggleItem);
        this.item.menu.addMenuItem(createSettingsAction(_("Wi-Fi Settings"), device));
        this._wirelessEnabledChangedId = this._client.connect('notify::wireless-enabled', Lang.bind(this, this._sync));
        this._wirelessHwEnabledChangedId = this._client.connect('notify::wireless-hardware-enabled', Lang.bind(this, this._sync));
        this._activeApChangedId = this._device.connect('notify::active-access-point', Lang.bind(this, this._activeApChanged));
        this._stateChangedId = this._device.connect('state-changed', Lang.bind(this, this._deviceStateChanged));
        this._notifyConnectivityId = this._client.connect('notify::connectivity', Lang.bind(this, this._iconChanged));
        this._sync();
    },
    _iconChanged: function() {
        this._sync();
        this.emit('icon-changed');
    },
    destroy: function() {
        if (this._activeApChangedId) {
            GObject.Object.prototype.disconnect.call(this._device, this._activeApChangedId);
            this._activeApChangedId = 0;
        }
        if (this._stateChangedId) {
            GObject.Object.prototype.disconnect.call(this._device, this._stateChangedId);
            this._stateChangedId = 0;
        }
        if (this._strengthChangedId > 0) {
            this._activeAccessPoint.disconnect(this._strengthChangedId);
            this._strengthChangedId = 0;
        }
        if (this._wirelessEnabledChangedId) {
            this._client.disconnect(this._wirelessEnabledChangedId);
            this._wirelessEnabledChangedId = 0;
        }
        if (this._wirelessHwEnabledChangedId) {
            this._client.disconnect(this._wirelessHwEnabledChangedId);
            this._wirelessHwEnabledChangedId = 0;
        }
        if (this._dialog) {
            this._dialog.destroy();
            this._dialog = null;
        }
        if (this._notifyConnectivityId) {
            this._client.disconnect(this._notifyConnectivityId);
            this._notifyConnectivityId = 0;
        }
        this.item.destroy();
    },
    _deviceStateChanged: function(device, newstate, oldstate, reason) {
        if (newstate == oldstate) {
            log('device emitted state-changed without actually changing state');
            return;
        }
        /* Emit a notification if activation fails, but don't do it
           if the reason is no secrets, as that indicates the user
           cancelled the agent dialog */
        if (newstate == NetworkManager.DeviceState.FAILED &&
            reason != NetworkManager.DeviceStateReason.NO_SECRETS) {
            this.emit('activation-failed', reason);
        }
        this._sync();
    },
    _toggleWifi: function() {
        this._client.wireless_enabled = !this._client.wireless_enabled;
    },
    _showDialog: function() {
        this._dialog = new NMWirelessDialog(this._client, this._device, this._settings);
        this._dialog.connect('closed', Lang.bind(this, this._dialogClosed));
        this._dialog.open();
    },
    _dialogClosed: function() {
        this._dialog.destroy();
        this._dialog = null;
    },
    _strengthChanged: function() {
        this._iconChanged();
    },
    _activeApChanged: function() {
        if (this._activeAccessPoint) {
            this._activeAccessPoint.disconnect(this._strengthChangedId);
            this._strengthChangedId = 0;
        }
        this._activeAccessPoint = this._device.active_access_point;
        if (this._activeAccessPoint) {
            this._strengthChangedId = this._activeAccessPoint.connect('notify::strength',
                                                                      Lang.bind(this, this._strengthChanged));
        }
        this._sync();
    },
    _sync: function() {
        this._toggleItem.label.text = this._client.wireless_enabled ? _("Turn Off") : _("Turn On");
        this._toggleItem.actor.visible = this._client.wireless_hardware_enabled;
        this.item.icon.icon_name = this._getMenuIcon();
        this.item.label.text = this._getStatus();
    },
    setDeviceDescription: function(desc) {
        this._description = desc;
        this._sync();
    },
    _getStatus: function() {
        let ap = this._device.active_access_point;
        if (this._isHotSpotMaster())
            /* Translators: %s is a network identifier */
            return _("%s Hotspot Active").format(this._description);
        else if (this._device.state >= NetworkManager.DeviceState.PREPARE &&
                 this._device.state < NetworkManager.DeviceState.ACTIVATED)
            /* Translators: %s is a network identifier */
            return _("%s Connecting").format(this._description);
        else if (ap)
            return ssidToLabel(ap.get_ssid());
        else if (!this._client.wireless_hardware_enabled)
            /* Translators: %s is a network identifier */
            return _("%s Hardware Disabled").format(this._description);
        else if (!this._client.wireless_enabled)
            /* Translators: %s is a network identifier */
            return _("%s Off").format(this._description);
        else if (this._device.state == NetworkManager.DeviceState.DISCONNECTED)
            /* Translators: %s is a network identifier */
            return _("%s Not Connected").format(this._description);
        else
            return '';
    },
    _getMenuIcon: function() {
        if (this._device.active_connection)
            return this.getIndicatorIcon();
        else
            return 'network-wireless-signal-none-symbolic';
    },
    _canReachInternet: function() {
        if (this._client.primary_connection != this._device.active_connection)
            return true;
        return this._client.connectivity == NetworkManager.ConnectivityState.FULL;
    },
    _isHotSpotMaster: function() {
        if (!this._device.active_connection)
            return false;
        let connection = this._settings.get_connection_by_path(this._device.active_connection.connection);
        if (!connection)
            return false;
        let ip4config = connection.get_setting_ip4_config();
        if (!ip4config)
            return false;
        return ip4config.get_method() == NetworkManager.SETTING_IP4_CONFIG_METHOD_SHARED;
    },
    getIndicatorIcon: function() {
        if (this._device.state < NetworkManager.DeviceState.PREPARE)
            return 'network-wireless-disconnected-symbolic';
        if (this._device.state < NetworkManager.DeviceState.ACTIVATED)
            return 'network-wireless-acquiring-symbolic';
        if (this._isHotSpotMaster())
            return 'network-wireless-hotspot-symbolic';
        let ap = this._device.active_access_point;
        if (!ap) {
            if (this._device.mode != NM80211Mode.ADHOC)
                log('An active wireless connection, in infrastructure mode, involves no access point?');
            if (this._canReachInternet())
                return 'network-wireless-connected-symbolic';
            else
                return 'network-wireless-no-route-symbolic';
        }
        if (this._canReachInternet())
            return 'network-wireless-signal-' + signalToIcon(ap.strength) + '-symbolic';
        else
            return 'network-wireless-no-route-symbolic';
    },
Signals.addSignalMethods(NMDeviceWireless.prototype);
const NMVPNConnectionItem = new Lang.Class({
    Name: 'NMVPNConnectionItem',
    Extends: NMConnectionItem,
    isActive: function() {
        if (this._activeConnection == null)
            return false;
        return this._activeConnection.vpn_state != NetworkManager.VPNConnectionState.DISCONNECTED;
    },
    _buildUI: function() {
        this.labelItem = new PopupMenu.PopupMenuItem('');
        this.labelItem.connect('activate', Lang.bind(this, this._toggle));
        this.radioItem = new PopupMenu.PopupSwitchMenuItem(this._connection.get_id(), false);
        this.radioItem.connect('toggled', Lang.bind(this, this._toggle));
    },
    _sync: function() {
        let isActive = this.isActive();
        this.labelItem.label.text = isActive ? _("Turn Off") : this._section.getConnectLabel();
        this.radioItem.setToggleState(isActive);
        this.radioItem.setStatus(this._getStatus());
        this.emit('icon-changed');
    },
    _getStatus: function() {
        if (this._activeConnection == null)
            return null;
        switch(this._activeConnection.vpn_state) {
        case NetworkManager.VPNConnectionState.DISCONNECTED:
        case NetworkManager.VPNConnectionState.ACTIVATED:
            return null;
        case NetworkManager.VPNConnectionState.PREPARE:
        case NetworkManager.VPNConnectionState.CONNECT:
        case NetworkManager.VPNConnectionState.IP_CONFIG_GET:
            return _("connecting...");
        case NetworkManager.VPNConnectionState.NEED_AUTH:
            /* Translators: this is for network connections that require some kind of key or password */
            return _("authentication required");
        case NetworkManager.VPNConnectionState.FAILED:
            return _("connection failed");
        default:
            return 'invalid';
        }
    },
    _connectionStateChanged: function(ac, newstate, reason) {
        if (newstate == NetworkManager.VPNConnectionState.FAILED &&
            reason != NetworkManager.VPNConnectionStateReason.NO_SECRETS) {
            // FIXME: if we ever want to show something based on reason,
            // we need to convert from NetworkManager.VPNConnectionStateReason
            // to NetworkManager.DeviceStateReason
            this.emit('activation-failed', reason);
        }
        this.emit('icon-changed');
        this.parent();
    },
    setActiveConnection: function(activeConnection) {
        if (this._activeConnectionChangedId > 0) {
            this._activeConnection.disconnect(this._activeConnectionChangedId);
            this._activeConnectionChangedId = 0;
        }
        this._activeConnection = activeConnection;
        if (this._activeConnection)
            this._activeConnectionChangedId = this._activeConnection.connect('vpn-state-changed',
                                                                             Lang.bind(this, this._connectionStateChanged));
        this._sync();
    },
    getIndicatorIcon: function() {
        if (this._activeConnection) {
            if (this._activeConnection.vpn_state < NetworkManager.VPNConnectionState.ACTIVATED)
                return 'network-vpn-acquiring-symbolic';
            else
                return 'network-vpn-symbolic';
        } else {
            return '';
        }
    },
const NMVPNSection = new Lang.Class({
    Name: 'NMVPNSection',
    Extends: NMConnectionSection,
    category: NMConnectionCategory.VPN,
    _init: function(client) {
        this.parent(client);
        this._vpnSettings = new PopupMenu.PopupMenuItem('');
        this.item.menu.addMenuItem(this._vpnSettings);
        this._vpnSettings.connect('activate', Lang.bind(this, this._onSettingsActivate));
        this._sync();
    },
    _sync: function() {
        let nItems = this._connectionItems.size;
        this.item.actor.visible = (nItems > 0);
        if (nItems > 1)
            this._vpnSettings.label.text = _("Network Settings");
        else
            this._vpnSettings.label.text = _("VPN Settings");
        this.parent();
    },
    _onSettingsActivate: function() {
        let nItems = this._connectionItems.size;
        if (nItems > 1) {
            let appSys = Shell.AppSystem.get_default();
            let app = appSys.lookup_app('gnome-network-panel.desktop');
            app.launch(0, -1);
        } else {
            let connection = this._connections[0];
            Util.spawnApp(['gnome-control-center', 'network', 'show-device',
                           connection.get_path()]);
        }
    },
    _getDescription: function() {
        return _("VPN");
    },
    _getStatus: function() {
        let values = this._connectionItems.values();
        for (let item of values) {
            if (item.isActive())
                return item.getName();
        }
        return _("VPN Off");
    },
    _getMenuIcon: function() {
        return this.getIndicatorIcon() || 'network-vpn-symbolic';
    },
    activateConnection: function(connection) {
        this._client.activate_connection(connection, null, null, null);
    },
    deactivateConnection: function(activeConnection) {
        this._client.deactivate_connection(activeConnection);
    },
    setActiveConnections: function(vpnConnections) {
        let connections = this._connectionItems.values();
        for (let item of connections) {
            item.setActiveConnection(null);
        }
        vpnConnections.forEach(Lang.bind(this, function(a) {
            let item = this._connectionItems.get(a._connection.get_uuid());
            item.setActiveConnection(a);
        }));
    },
    _makeConnectionItem: function(connection) {
        return new NMVPNConnectionItem(this, connection);
    },
    getIndicatorIcon: function() {
        let items = this._connectionItems.values();
        for (let item of items) {
            let icon = item.getIndicatorIcon();
            if (icon)
                return icon;
        }
        return '';
    },
Signals.addSignalMethods(NMVPNSection.prototype);
const NMApplet = new Lang.Class({
    Name: 'NMApplet',
    Extends: PanelMenu.SystemIndicator,
    _init: function() {
        this.parent();
        this._primaryIndicator = this._addIndicator();
        this._vpnIndicator = this._addIndicator();
        // Device types
        this._dtypes = { };
        this._dtypes[NetworkManager.DeviceType.ETHERNET] = NMDeviceWired;
        this._dtypes[NetworkManager.DeviceType.WIFI] = NMDeviceWireless;
        this._dtypes[NetworkManager.DeviceType.MODEM] = NMDeviceModem;
        this._dtypes[NetworkManager.DeviceType.BT] = NMDeviceBluetooth;
        // TODO: WiMax support
        // Connection types
        this._ctypes = { };
        this._ctypes[NetworkManager.SETTING_WIRED_SETTING_NAME] = NMConnectionCategory.WIRED;
        this._ctypes[NetworkManager.SETTING_WIRELESS_SETTING_NAME] = NMConnectionCategory.WIRELESS;
        this._ctypes[NetworkManager.SETTING_BLUETOOTH_SETTING_NAME] = NMConnectionCategory.WWAN;
        this._ctypes[NetworkManager.SETTING_CDMA_SETTING_NAME] = NMConnectionCategory.WWAN;
        this._ctypes[NetworkManager.SETTING_GSM_SETTING_NAME] = NMConnectionCategory.WWAN;
        this._ctypes[NetworkManager.SETTING_VPN_SETTING_NAME] = NMConnectionCategory.VPN;
        NMClient.Client.new_async(null, Lang.bind(this, this._clientGot));
        NMClient.RemoteSettings.new_async(null, null, Lang.bind(this, this._remoteSettingsGot));
    },
    _clientGot: function(obj, result) {
        this._client = NMClient.Client.new_finish(result);
        this._tryLateInit();
    },
    _remoteSettingsGot: function(obj, result) {
        this._settings = NMClient.RemoteSettings.new_finish(result);
        this._tryLateInit();
    },
    _createDeviceCategory: function() {
        let category = {
            section: new PopupMenu.PopupMenuSection(),
            devices: [ ],
        };
        this.menu.addMenuItem(category.section);
        return category;
    },
    _tryLateInit: function() {
        if (!this._client || !this._settings)
            return;
        this._activeConnections = [ ];
        this._connections = [ ];
        this._connectivityQueue = [ ];
        this._mainConnection = null;
        this._mainConnectionIconChangedId = 0;
        this._notification = null;
        this._nmDevices = [];
        this._devices = { };
        this._devices.wired = this._createDeviceCategory();
        this._devices.wireless = this._createDeviceCategory();
        this._devices.wwan = this._createDeviceCategory();
        this._vpnSection = new NMVPNSection(this._client);
        this._vpnSection.connect('activation-failed', Lang.bind(this, this._onActivationFailed));
        this._vpnSection.connect('icon-changed', Lang.bind(this, this._updateIcon));
        this.menu.addMenuItem(this._vpnSection.item);
        this._readConnections();
        this._readDevices();
        this._syncNMState();
        this._syncMainConnection();
        this._syncVPNConnections();
        this._client.connect('notify::manager-running', Lang.bind(this, this._syncNMState));
        this._client.connect('notify::networking-enabled', Lang.bind(this, this._syncNMState));
        this._client.connect('notify::state', Lang.bind(this, this._syncNMState));
        this._client.connect('notify::primary-connection', Lang.bind(this, this._syncMainConnection));
        this._client.connect('notify::activating-connection', Lang.bind(this, this._syncMainConnection));
        this._client.connect('notify::active-connections', Lang.bind(this, this._syncVPNConnections));
        this._client.connect('notify::connectivity', Lang.bind(this, this._syncConnectivity));
        this._client.connect('device-added', Lang.bind(this, this._deviceAdded));
        this._client.connect('device-removed', Lang.bind(this, this._deviceRemoved));
        this._settings.connect('new-connection', Lang.bind(this, this._newConnection));
        Main.sessionMode.connect('updated', Lang.bind(this, this._sessionUpdated));
        this._sessionUpdated();
    },
    _sessionUpdated: function() {
        let sensitive = !Main.sessionMode.isLocked && !Main.sessionMode.isGreeter;
        this.menu.setSensitive(sensitive);
    },
    _ensureSource: function() {
        if (!this._source) {
            this._source = new MessageTray.Source(_("Network Manager"),
                                                  'network-transmit-receive');
            this._source.policy = new MessageTray.NotificationApplicationPolicy('gnome-network-panel');
            this._source.connect('destroy', Lang.bind(this, function() {
                this._source = null;
            }));
            Main.messageTray.add(this._source);
        }
    },
    _readDevices: function() {
        let devices = this._client.get_devices() || [ ];
        for (let i = 0; i < devices.length; ++i) {
            this._deviceAdded(this._client, devices[i], true);
        }
        this._syncDeviceNames();
    },
    _notify: function(iconName, title, text, urgency) {
        if (this._notification)
            this._notification.destroy();
        this._ensureSource();
        let gicon = new Gio.ThemedIcon({ name: iconName });
        this._notification = new MessageTray.Notification(this._source, title, text, { gicon: gicon });
        this._notification.setUrgency(urgency);
        this._notification.setTransient(true);
        this._notification.connect('destroy', function() {
            this._notification = null;
        });
        this._source.notify(this._notification);
    },
    _onActivationFailed: function(device, reason) {
        // XXX: nm-applet has no special text depending on reason
        // but I'm not sure of this generic message
        this._notify('network-error-symbolic',
                     _("Connection failed"),
                     _("Activation of network connection failed"),
                     MessageTray.Urgency.HIGH);
    },
    _syncDeviceNames: function() {
        let names = NMGtk.utils_disambiguate_device_names(this._nmDevices);
        for (let i = 0; i < this._nmDevices.length; i++) {
            let device = this._nmDevices[i];
            let description = names[i];
            if (device._delegate)
                device._delegate.setDeviceDescription(description);
        }
    },
    _deviceAdded: function(client, device, skipSyncDeviceNames) {
        if (device._delegate) {
            // already seen, not adding again
            return;
        }
        let wrapperClass = this._dtypes[device.get_device_type()];
        if (wrapperClass) {
            let wrapper = new wrapperClass(this._client, device, this._settings);
            device._delegate = wrapper;
            this._addDeviceWrapper(wrapper);
            this._nmDevices.push(device);
            if (!skipSyncDeviceNames)
                this._syncDeviceNames();
            if (wrapper instanceof NMConnectionSection) {
                this._connections.forEach(function(connection) {
                    wrapper.checkConnection(connection);
                });
            }
        }
    },
    _addDeviceWrapper: function(wrapper) {
        wrapper._activationFailedId = wrapper.connect('activation-failed',
                                                      Lang.bind(this, this._onActivationFailed));
        let section = this._devices[wrapper.category].section;
        section.addMenuItem(wrapper.item);
        let devices = this._devices[wrapper.category].devices;
        devices.push(wrapper);
    },
    _deviceRemoved: function(client, device) {
        let pos = this._nmDevices.indexOf(device);
        if (pos != -1) {
            this._nmDevices.splice(pos, 1);
            this._syncDeviceNames();
        }
        let wrapper = device._delegate;
        if (!wrapper) {
            log('Removing a network device that was not added');
            return;
        }
        this._removeDeviceWrapper(wrapper);
    },
    _removeDeviceWrapper: function(wrapper) {
        wrapper.disconnect(wrapper._activationFailedId);
        wrapper.destroy();
        let devices = this._devices[wrapper.category].devices;
        let pos = devices.indexOf(wrapper);
        devices.splice(pos, 1);
    },
    _getMainConnection: function() {
        let connection;
        connection = this._client.get_primary_connection();
        if (connection) {
            ensureActiveConnectionProps(connection, this._settings);
            return connection;
        }
        connection = this._client.get_activating_connection();
        if (connection) {
            ensureActiveConnectionProps(connection, this._settings);
            return connection;
        }
        return null;
    },
    _syncMainConnection: function() {
        if (this._mainConnectionIconChangedId > 0) {
            this._mainConnection._primaryDevice.disconnect(this._mainConnectionIconChangedId);
            this._mainConnectionIconChangedId = 0;
        }
        if (this._mainConnectionStateChangedId > 0) {
            this._mainConnection.disconnect(this._mainConnectionStateChangedId);
            this._mainConnectionStateChangedId = 0;
        }
        this._mainConnection = this._getMainConnection();
        if (this._mainConnection) {
            if (this._mainConnection._primaryDevice)
                this._mainConnectionIconChangedId = this._mainConnection._primaryDevice.connect('icon-changed', Lang.bind(this, this._updateIcon));
            this._mainConnectionStateChangedId = this._mainConnection.connect('notify::state', Lang.bind(this, this._mainConnectionStateChanged));
            this._mainConnectionStateChanged();
        }
        this._updateIcon();
        this._syncConnectivity();
    },
    _syncVPNConnections: function() {
        let activeConnections = this._client.get_active_connections() || [];
        let vpnConnections = activeConnections.filter(function(a) {
            return (a instanceof NMClient.VPNConnection);
        });
        vpnConnections.forEach(Lang.bind(this, function(a) {
            ensureActiveConnectionProps(a, this._settings);
        }));
        this._vpnSection.setActiveConnections(vpnConnections);
        this._updateIcon();
    },
    _mainConnectionStateChanged: function() {
        if (this._mainConnection.state == NetworkManager.ActiveConnectionState.ACTIVATED && this._notification)
            this._notification.destroy();
    },
    _ignoreConnection: function(connection) {
        let setting = connection.get_setting_connection();
        if (!setting)
            return true;
        // Ignore slave connections
        if (setting.get_master())
            return true;
        return false;
    },
    _addConnection: function(connection) {
        if (this._ignoreConnection(connection))
            return;
        if (connection._updatedId) {
            // connection was already seen
            return;
        }
        connection._removedId = connection.connect('removed', Lang.bind(this, this._connectionRemoved));
        connection._updatedId = connection.connect('updated', Lang.bind(this, this._updateConnection));
        this._updateConnection(connection);
        this._connections.push(connection);
    },
    _readConnections: function() {
        let connections = this._settings.list_connections();
        connections.forEach(Lang.bind(this, this._addConnection));
    },
    _newConnection: function(settings, connection) {
        this._addConnection(connection);
    },
    _connectionRemoved: function(connection) {
        let pos = this._connections.indexOf(connection);
        if (pos != -1)
            this._connections.splice(pos, 1);
        let section = connection._section;
        if (section == NMConnectionCategory.INVALID)
            return;
        if (section == NMConnectionCategory.VPN) {
            this._vpnSection.removeConnection(connection);
        } else {
            let devices = this._devices[section].devices;
            for (let i = 0; i < devices.length; i++) {
                if (devices[i] instanceof NMConnectionSection)
                    devices[i].removeConnection(connection);
            }
        }
        connection.disconnect(connection._removedId);
        connection.disconnect(connection._updatedId);
        connection._removedId = connection._updatedId = 0;
    },
    _updateConnection: function(connection) {
        let connectionSettings = connection.get_setting_by_name(NetworkManager.SETTING_CONNECTION_SETTING_NAME);
        connection._type = connectionSettings.type;
        connection._section = this._ctypes[connection._type] || NMConnectionCategory.INVALID;
        let section = connection._section;
        if (section == NMConnectionCategory.INVALID)
            return;
        if (section == NMConnectionCategory.VPN) {
            this._vpnSection.checkConnection(connection);
        } else {
            let devices = this._devices[section].devices;
            devices.forEach(function(wrapper) {
                if (wrapper instanceof NMConnectionSection)
                    wrapper.checkConnection(connection);
            });
        }
    },
    _syncNMState: function() {
        this.indicators.visible = this._client.manager_running;
        this.menu.actor.visible = this._client.networking_enabled;
        this._syncConnectivity();
    },
    _flushConnectivityQueue: function() {
        if (this._portalHelperProxy) {
            for (let item of this._connectivityQueue)
                this._portalHelperProxy.CloseRemote(item);
        }
        this._connectivityQueue = [];
    },
    _closeConnectivityCheck: function(path) {
        let index = this._connectivityQueue.indexOf(path);
        if (index >= 0) {
            if (this._portalHelperProxy)
                this._portalHelperProxy.CloseRemote(path);
            this._connectivityQueue.splice(index, 1);
        }
    },
    _portalHelperDone: function(proxy, emitter, parameters) {
        let [path, result] = parameters;
        if (result == PortalHelperResult.CANCELLED) {
            // Keep the connection in the queue, so the user is not
            // spammed with more logins until we next flush the queue,
            // which will happen once he chooses a better connection
            // or we get to full connectivity through other means
        } else if (result == PortalHelperResult.COMPLETED) {
            this._closeConnectivityCheck(path);
            return;
        } else if (result == PortalHelperResult.RECHECK) {
            this._client.check_connectivity_async(null, Lang.bind(this, function(client, result) {
                try {
                    let state = client.check_connectivity_finish(result);
                    if (state >= NetworkManager.ConnectivityState.FULL)
                        this._closeConnectivityCheck(path);
                } catch(e) { }
            }));
        } else {
            log('Invalid result from portal helper: ' + result);
        }
    },
    _syncConnectivity: function() {
        if (this._mainConnection == null ||
            this._mainConnection.state != NetworkManager.ActiveConnectionState.ACTIVATED) {
            this._flushConnectivityQueue();
            return;
        }
        let isPortal = this._client.connectivity == NetworkManager.ConnectivityState.PORTAL;
        // For testing, allow interpreting any value != FULL as PORTAL, because
        // LIMITED (no upstream route after the default gateway) is easy to obtain
        // with a tethered phone
        // NONE is also possible, with a connection configured to force no default route
        // (but in general we should only prompt a portal if we know there is a portal)
        if (GLib.getenv('GNOME_SHELL_CONNECTIVITY_TEST') != null)
            isPortal = isPortal || this._client.connectivity < NetworkManager.ConnectivityState.FULL;
        if (!isPortal)
            return;
        let path = this._mainConnection.get_path();
        for (let item of this._connectivityQueue) {
            if (item == path)
                return;
        }
        let timestamp = global.get_current_time();
        if (this._portalHelperProxy) {
            this._portalHelperProxy.AuthenticateRemote(path, '', timestamp);
        } else {
            new PortalHelperProxy(Gio.DBus.session, 'org.gnome.Shell.PortalHelper',
                                  '/org/gnome/Shell/PortalHelper', Lang.bind(this, function (proxy, error) {
                                      if (error) {
                                          log('Error launching the portal helper: ' + error);
                                          return;
                                      }
                                      this._portalHelperProxy = proxy;
                                      proxy.connectSignal('Done', Lang.bind(this, this._portalHelperDone));
                                      proxy.AuthenticateRemote(path, '', timestamp);
                                  }));
        }
        this._connectivityQueue.push(path);
    },
    _updateIcon: function() {
        if (!this._client.networking_enabled || !this._mainConnection) {
            this._primaryIndicator.visible = false;
        } else {
            let dev = this._mainConnection._primaryDevice;
            this._primaryIndicator.visible = (dev != null);
            if (dev)
                this._primaryIndicator.icon_name = dev.getIndicatorIcon();
        }
        this._vpnIndicator.icon_name = this._vpnSection.getIndicatorIcon();
        this._vpnIndicator.visible = (this._vpnIndicator.icon_name != '');
    }
(uuay)switcherPopup.js
// -*- mode: js; js-indent-level: 4; indent-tabs-mode: nil -*-
const Clutter = imports.gi.Clutter;
const GLib = imports.gi.GLib;
const Gtk = imports.gi.Gtk;
const Lang = imports.lang;
const Mainloop = imports.mainloop;
const Meta = imports.gi.Meta;
const Shell = imports.gi.Shell;
const Signals = imports.signals;
const St = imports.gi.St;
const Main = imports.ui.main;
const Tweener = imports.ui.tweener;
const POPUP_DELAY_TIMEOUT = 150; // milliseconds
const POPUP_SCROLL_TIME = 0.10; // seconds
const POPUP_FADE_OUT_TIME = 0.1; // seconds
const DISABLE_HOVER_TIMEOUT = 500; // milliseconds
function mod(a, b) {
    return (a + b) % b;
function primaryModifier(mask) {
    if (mask == 0)
        return 0;
    let primary = 1;
    while (mask > 1) {
        mask >>= 1;
        primary <<= 1;
    }
    return primary;
const SwitcherPopup = new Lang.Class({
    Name: 'SwitcherPopup',
    Abstract: true,
    _init: function(items) {
        this._switcherList = null;
        this._items = items || [];
        this._selectedIndex = 0;
        this.actor = new Shell.GenericContainer({ style_class: 'switcher-popup',
                                                  reactive: true,
                                                  visible: false });
        this.actor.connect('get-preferred-width', Lang.bind(this, this._getPreferredWidth));
        this.actor.connect('get-preferred-height', Lang.bind(this, this._getPreferredHeight));
        this.actor.connect('allocate', Lang.bind(this, this._allocate));
        this.actor.connect('destroy', Lang.bind(this, this._onDestroy));
        Main.uiGroup.add_actor(this.actor);
        this._haveModal = false;
        this._modifierMask = 0;
        this._motionTimeoutId = 0;
        this._initialDelayTimeoutId = 0;
        // Initially disable hover so we ignore the enter-event if
        // the switcher appears underneath the current pointer location
        this._disableHover();
    },
    _getPreferredWidth: function(actor, forHeight, alloc) {
        let primary = Main.layoutManager.primaryMonitor;
        alloc.min_size = primary.width;
        alloc.natural_size = primary.width;
    },
    _getPreferredHeight: function(actor, forWidth, alloc) {
        let primary = Main.layoutManager.primaryMonitor;
        alloc.min_size = primary.height;
        alloc.natural_size = primary.height;
    },
    _allocate: function(actor, box, flags) {
        let childBox = new Clutter.ActorBox();
        let primary = Main.layoutManager.primaryMonitor;
        let leftPadding = this.actor.get_theme_node().get_padding(St.Side.LEFT);
        let rightPadding = this.actor.get_theme_node().get_padding(St.Side.RIGHT);
        let hPadding = leftPadding + rightPadding;
        // Allocate the switcherList
        // We select a size based on an icon size that does not overflow the screen
        let [childMinHeight, childNaturalHeight] = this._switcherList.actor.get_preferred_height(primary.width - hPadding);
        let [childMinWidth, childNaturalWidth] = this._switcherList.actor.get_preferred_width(childNaturalHeight);
        childBox.x1 = Math.max(primary.x + leftPadding, primary.x + Math.floor((primary.width - childNaturalWidth) / 2));
        childBox.x2 = Math.min(primary.x + primary.width - rightPadding, childBox.x1 + childNaturalWidth);
        childBox.y1 = primary.y + Math.floor((primary.height - childNaturalHeight) / 2);
        childBox.y2 = childBox.y1 + childNaturalHeight;
        this._switcherList.actor.allocate(childBox, flags);
    },
    _initialSelection: function(backward, binding) {
        if (backward)
            this._select(this._items.length - 1);
        else if (this._items.length == 1)
            this._select(0);
        else
            this._select(1);
    },
    show: function(backward, binding, mask) {
        if (this._items.length == 0)
            return false;
        if (!Main.pushModal(this.actor)) {
            // Probably someone else has a pointer grab, try again with keyboard only
            if (!Main.pushModal(this.actor, { options: Meta.ModalOptions.POINTER_ALREADY_GRABBED })) {
                return false;
            }
        }
        this._haveModal = true;
        this._modifierMask = primaryModifier(mask);
        this.actor.connect('key-press-event', Lang.bind(this, this._keyPressEvent));
        this.actor.connect('key-release-event', Lang.bind(this, this._keyReleaseEvent));
        this.actor.connect('button-press-event', Lang.bind(this, this._clickedOutside));
        this.actor.connect('scroll-event', Lang.bind(this, this._scrollEvent));
        this.actor.add_actor(this._switcherList.actor);
        this._switcherList.connect('item-activated', Lang.bind(this, this._itemActivated));
        this._switcherList.connect('item-entered', Lang.bind(this, this._itemEntered));
        // Need to force an allocation so we can figure out whether we
        // need to scroll when selecting
        this.actor.opacity = 0;
        this.actor.show();
        this.actor.get_allocation_box();
        this._initialSelection(backward, binding);
        // There's a race condition; if the user released Alt before
        // we got the grab, then we won't be notified. (See
        // https://bugzilla.gnome.org/show_bug.cgi?id=596695 for
        // details.) So we check now. (Have to do this after updating
        // selection.)
        let [x, y, mods] = global.get_pointer();
        if (!(mods & this._modifierMask)) {
            this._finish(global.get_current_time());
            return false;
        }
        // We delay showing the popup so that fast Alt+Tab users aren't
        // disturbed by the popup briefly flashing.
        this._initialDelayTimeoutId = Mainloop.timeout_add(POPUP_DELAY_TIMEOUT,
                                                           Lang.bind(this, function () {
                                                               Main.osdWindowManager.hideAll();
                                                               this.actor.opacity = 255;
                                                               this._initialDelayTimeoutId = 0;
                                                               return GLib.SOURCE_REMOVE;
                                                           }));
        GLib.Source.set_name_by_id(this._initialDelayTimeoutId, '[gnome-shell] Main.osdWindow.cancel');
        return true;
    },
    _next: function() {
        return mod(this._selectedIndex + 1, this._items.length);
    },
    _previous: function() {
        return mod(this._selectedIndex - 1, this._items.length);
    },
    _keyPressHandler: function(keysym, action) {
        throw new Error('Not implemented');
    },
    _keyPressEvent: function(actor, event) {
        let keysym = event.get_key_symbol();
        let action = global.display.get_keybinding_action(event.get_key_code(), event.get_state());
        this._disableHover();
        if (this._keyPressHandler(keysym, action) != Clutter.EVENT_PROPAGATE)
            return Clutter.EVENT_STOP;
        if (keysym == Clutter.Escape)
            this.destroy();
        return Clutter.EVENT_STOP;
    },
    _keyReleaseEvent: function(actor, event) {
        let [x, y, mods] = global.get_pointer();
        let state = mods & this._modifierMask;
        if (state == 0)
            this._finish(event.get_time());
        return Clutter.EVENT_STOP;
    },
    _clickedOutside: function(actor, event) {
        this.destroy();
        return Clutter.EVENT_PROPAGATE;
    },
    _scrollHandler: function(direction) {
        if (direction == Clutter.ScrollDirection.UP)
            this._select(this._previous());
        else if (direction == Clutter.ScrollDirection.DOWN)
            this._select(this._next());
    },
    _scrollEvent: function(actor, event) {
        this._scrollHandler(event.get_scroll_direction());
        return Clutter.EVENT_PROPAGATE;
    },
    _itemActivatedHandler: function(n) {
        this._select(n);
    },
    _itemActivated: function(switcher, n) {
        this._itemActivatedHandler(n);
        this._finish(global.get_current_time());
    },
    _itemEnteredHandler: function(n) {
        this._select(n);
    },
    _itemEntered: function(switcher, n) {
        if (!this.mouseActive)
            return;
        this._itemEnteredHandler(n);
    },
    _disableHover: function() {
        this.mouseActive = false;
        if (this._motionTimeoutId != 0)
            Mainloop.source_remove(this._motionTimeoutId);
        this._motionTimeoutId = Mainloop.timeout_add(DISABLE_HOVER_TIMEOUT, Lang.bind(this, this._mouseTimedOut));
        GLib.Source.set_name_by_id(this._motionTimeoutId, '[gnome-shell] this._mouseTimedOut');
    },
    _mouseTimedOut: function() {
        this._motionTimeoutId = 0;
        this.mouseActive = true;
        return GLib.SOURCE_REMOVE;
    },
    _popModal: function() {
        if (this._haveModal) {
            Main.popModal(this.actor);
            this._haveModal = false;
        }
    },
    destroy: function() {
        this._popModal();
        if (this.actor.visible) {
            Tweener.addTween(this.actor,
                             { opacity: 0,
                               time: POPUP_FADE_OUT_TIME,
                               transition: 'easeOutQuad',
                               onComplete: Lang.bind(this,
                                   function() {
                                       this.actor.destroy();
                                   })
                             });
        } else
            this.actor.destroy();
    },
    _finish: function(timestamp) {
        this.destroy();
    },
    _onDestroy: function() {
        this._popModal();
        if (this._motionTimeoutId != 0)
            Mainloop.source_remove(this._motionTimeoutId);
        if (this._initialDelayTimeoutId != 0)
            Mainloop.source_remove(this._initialDelayTimeoutId);
    },
    _select: function(num) {
        this._selectedIndex = num;
        this._switcherList.highlight(num);
    }
const SwitcherList = new Lang.Class({
    Name: 'SwitcherList',
    _init : function(squareItems) {
        this.actor = new Shell.GenericContainer({ style_class: 'switcher-list' });
        this.actor.connect('get-preferred-width', Lang.bind(this, this._getPreferredWidth));
        this.actor.connect('get-preferred-height', Lang.bind(this, this._getPreferredHeight));
        this.actor.connect('allocate', Lang.bind(this, this._allocateTop));
        // Here we use a GenericContainer so that we can force all the
        // children to have the same width.
        this._list = new Shell.GenericContainer({ style_class: 'switcher-list-item-container' });
        this._list.spacing = 0;
        this._list.connect('style-changed', Lang.bind(this, function() {
                                                        this._list.spacing = this._list.get_theme_node().get_length('spacing');
                                                     }));
        this._list.connect('get-preferred-width', Lang.bind(this, this._getPreferredWidth));
        this._list.connect('get-preferred-height', Lang.bind(this, this._getPreferredHeight));
        this._list.connect('allocate', Lang.bind(this, this._allocate));
        this._scrollView = new St.ScrollView({ style_class: 'hfade',
                                               enable_mouse_scrolling: false });
        this._scrollView.set_policy(Gtk.PolicyType.NEVER, Gtk.PolicyType.NEVER);
        let scrollBox = new St.BoxLayout();
        scrollBox.add_actor(this._list);
        this._scrollView.add_actor(scrollBox);
        this.actor.add_actor(this._scrollView);
        // Those arrows indicate whether scrolling in one direction is possible
        this._leftArrow = new St.DrawingArea({ style_class: 'switcher-arrow',
                                               pseudo_class: 'highlighted' });
        this._leftArrow.connect('repaint', Lang.bind(this,
            function() { drawArrow(this._leftArrow, St.Side.LEFT); }));
        this._rightArrow = new St.DrawingArea({ style_class: 'switcher-arrow',
                                                pseudo_class: 'highlighted' });
        this._rightArrow.connect('repaint', Lang.bind(this,
            function() { drawArrow(this._rightArrow, St.Side.RIGHT); }));
        this.actor.add_actor(this._leftArrow);
        this.actor.add_actor(this._rightArrow);
        this._items = [];
        this._highlighted = -1;
        this._squareItems = squareItems;
        this._minSize = 0;
        this._scrollableRight = true;
        this._scrollableLeft = false;
    },
    _allocateTop: function(actor, box, flags) {
        let leftPadding = this.actor.get_theme_node().get_padding(St.Side.LEFT);
        let rightPadding = this.actor.get_theme_node().get_padding(St.Side.RIGHT);
        let childBox = new Clutter.ActorBox();
        let scrollable = this._minSize > box.x2 - box.x1;
        box.y1 -= this.actor.get_theme_node().get_padding(St.Side.TOP);
        box.y2 += this.actor.get_theme_node().get_padding(St.Side.BOTTOM);
        this._scrollView.allocate(box, flags);
        let arrowWidth = Math.floor(leftPadding / 3);
        let arrowHeight = arrowWidth * 2;
        childBox.x1 = leftPadding / 2;
        childBox.y1 = this.actor.height / 2 - arrowWidth;
        childBox.x2 = childBox.x1 + arrowWidth;
        childBox.y2 = childBox.y1 + arrowHeight;
        this._leftArrow.allocate(childBox, flags);
        this._leftArrow.opacity = (this._scrollableLeft && scrollable) ? 255 : 0;
        arrowWidth = Math.floor(rightPadding / 3);
        arrowHeight = arrowWidth * 2;
        childBox.x1 = this.actor.width - arrowWidth - rightPadding / 2;
        childBox.y1 = this.actor.height / 2 - arrowWidth;
        childBox.x2 = childBox.x1 + arrowWidth;
        childBox.y2 = childBox.y1 + arrowHeight;
        this._rightArrow.allocate(childBox, flags);
        this._rightArrow.opacity = (this._scrollableRight && scrollable) ? 255 : 0;
    },
    addItem : function(item, label) {
        let bbox = new St.Button({ style_class: 'item-box',
                                   reactive: true });
        bbox.set_child(item);
        this._list.add_actor(bbox);
        let n = this._items.length;
        bbox.connect('clicked', Lang.bind(this, function() { this._onItemClicked(n); }));
        bbox.connect('enter-event', Lang.bind(this, function() { this._onItemEnter(n); }));
        bbox.label_actor = label;
        this._items.push(bbox);
        return bbox;
    },
    _onItemClicked: function (index) {
        this._itemActivated(index);
    },
    _onItemEnter: function (index) {
        this._itemEntered(index);
        return Clutter.EVENT_PROPAGATE;
    },
    highlight: function(index, justOutline) {
        if (this._highlighted != -1) {
            this._items[this._highlighted].remove_style_pseudo_class('outlined');
            this._items[this._highlighted].remove_style_pseudo_class('selected');
        }
        this._highlighted = index;
        if (this._highlighted != -1) {
            if (justOutline)
                this._items[this._highlighted].add_style_pseudo_class('outlined');
            else
                this._items[this._highlighted].add_style_pseudo_class('selected');
        }
        let adjustment = this._scrollView.hscroll.adjustment;
        let [value, lower, upper, stepIncrement, pageIncrement, pageSize] = adjustment.get_values();
        let [absItemX, absItemY] = this._items[index].get_transformed_position();
        let [result, posX, posY] = this.actor.transform_stage_point(absItemX, 0);
        let [containerWidth, containerHeight] = this.actor.get_transformed_size();
        if (posX + this._items[index].get_width() > containerWidth)
            this._scrollToRight();
        else if (this._items[index].allocation.x1 - value < 0)
            this._scrollToLeft();
    },
    _scrollToLeft : function() {
        let adjustment = this._scrollView.hscroll.adjustment;
        let [value, lower, upper, stepIncrement, pageIncrement, pageSize] = adjustment.get_values();
        let item = this._items[this._highlighted];
        if (item.allocation.x1 < value)
            value = Math.min(0, item.allocation.x1);
        else if (item.allocation.x2 > value + pageSize)
            value = Math.max(upper, item.allocation.x2 - pageSize);
        this._scrollableRight = true;
        Tweener.addTween(adjustment,
                         { value: value,
                           time: POPUP_SCROLL_TIME,
                           transition: 'easeOutQuad',
                           onComplete: Lang.bind(this, function () {
                                if (this._highlighted == 0)
                                    this._scrollableLeft = false;
                                this.actor.queue_relayout();
                           })
                          });
    },
    _scrollToRight : function() {
        let adjustment = this._scrollView.hscroll.adjustment;
        let [value, lower, upper, stepIncrement, pageIncrement, pageSize] = adjustment.get_values();
        let item = this._items[this._highlighted];
        if (item.allocation.x1 < value)
            value = Math.max(0, item.allocation.x1);
        else if (item.allocation.x2 > value + pageSize)
            value = Math.min(upper, item.allocation.x2 - pageSize);
        this._scrollableLeft = true;
        Tweener.addTween(adjustment,
                         { value: value,
                           time: POPUP_SCROLL_TIME,
                           transition: 'easeOutQuad',
                           onComplete: Lang.bind(this, function () {
                                if (this._highlighted == this._items.length - 1)
                                    this._scrollableRight = false;
                                this.actor.queue_relayout();
                            })
                          });
    },
    _itemActivated: function(n) {
        this.emit('item-activated', n);
    },
    _itemEntered: function(n) {
        this.emit('item-entered', n);
    },
    _maxChildWidth: function (forHeight) {
        let maxChildMin = 0;
        let maxChildNat = 0;
        for (let i = 0; i < this._items.length; i++) {
            let [childMin, childNat] = this._items[i].get_preferred_width(forHeight);
            maxChildMin = Math.max(childMin, maxChildMin);
            maxChildNat = Math.max(childNat, maxChildNat);
            if (this._squareItems) {
                let [childMin, childNat] = this._items[i].get_preferred_height(-1);
                maxChildMin = Math.max(childMin, maxChildMin);
                maxChildNat = Math.max(childNat, maxChildNat);
            }
        }
        return [maxChildMin, maxChildNat];
    },
    _getPreferredWidth: function (actor, forHeight, alloc) {
        let [maxChildMin, maxChildNat] = this._maxChildWidth(forHeight);
        let totalSpacing = Math.max(this._list.spacing * (this._items.length - 1), 0);
        alloc.min_size = this._items.length * maxChildMin + totalSpacing;
        alloc.natural_size = alloc.min_size;
        this._minSize = alloc.min_size;
    },
    _getPreferredHeight: function (actor, forWidth, alloc) {
        let maxChildMin = 0;
        let maxChildNat = 0;
        for (let i = 0; i < this._items.length; i++) {
            let [childMin, childNat] = this._items[i].get_preferred_height(-1);
            maxChildMin = Math.max(childMin, maxChildMin);
            maxChildNat = Math.max(childNat, maxChildNat);
        }
        if (this._squareItems) {
            let [childMin, childNat] = this._maxChildWidth(-1);
            maxChildMin = Math.max(childMin, maxChildMin);
            maxChildNat = maxChildMin;
        }
        alloc.min_size = maxChildMin;
        alloc.natural_size = maxChildNat;
    },
    _allocate: function (actor, box, flags) {
        let childHeight = box.y2 - box.y1;
        let [maxChildMin, maxChildNat] = this._maxChildWidth(childHeight);
        let totalSpacing = Math.max(this._list.spacing * (this._items.length - 1), 0);
        let childWidth = Math.floor(Math.max(0, box.x2 - box.x1 - totalSpacing) / this._items.length);
        let x = 0;
        let children = this._list.get_children();
        let childBox = new Clutter.ActorBox();
        let primary = Main.layoutManager.primaryMonitor;
        let parentRightPadding = this.actor.get_parent().get_theme_node().get_padding(St.Side.RIGHT);
        for (let i = 0; i < children.length; i++) {
            if (this._items.indexOf(children[i]) != -1) {
                let [childMin, childNat] = children[i].get_preferred_height(childWidth);
                let vSpacing = (childHeight - childNat) / 2;
                childBox.x1 = x;
                childBox.y1 = vSpacing;
                childBox.x2 = x + childWidth;
                childBox.y2 = childBox.y1 + childNat;
                children[i].allocate(childBox, flags);
                x += this._list.spacing + childWidth;
            } else {
                // Something else, eg, AppSwitcher's arrows;
                // we don't allocate it.
            }
        }
    }
Signals.addSignalMethods(SwitcherList.prototype);
function drawArrow(area, side) {
    let themeNode = area.get_theme_node();
    let borderColor = themeNode.get_border_color(side);
    let bodyColor = themeNode.get_foreground_color();
    let [width, height] = area.get_surface_size ();
    let cr = area.get_context();
    cr.setLineWidth(1.0);
    Clutter.cairo_set_source_color(cr, borderColor);
    switch (side) {
    case St.Side.TOP:
        cr.moveTo(0, height);
        cr.lineTo(Math.floor(width * 0.5), 0);
        cr.lineTo(width, height);
        break;
    case St.Side.BOTTOM:
        cr.moveTo(width, 0);
        cr.lineTo(Math.floor(width * 0.5), height);
        cr.lineTo(0, 0);
        break;
    case St.Side.LEFT:
        cr.moveTo(width, height);
        cr.lineTo(0, Math.floor(height * 0.5));
        cr.lineTo(width, 0);
        break;
    case St.Side.RIGHT:
        cr.moveTo(0, 0);
        cr.lineTo(width, Math.floor(height * 0.5));
        cr.lineTo(0, height);
        break;
    }
    cr.strokePreserve();
    Clutter.cairo_set_source_color(cr, bodyColor);
    cr.fill();
    cr.$dispose();
(uuay)separator.js=
// -*- mode: js; js-indent-level: 4; indent-tabs-mode: nil -*-
const Cairo = imports.cairo;
const Lang = imports.lang;
const St = imports.gi.St;
const HorizontalSeparator = new Lang.Class({
    Name: 'HorizontalSeparator',
    _init: function (params) {
        this.actor = new St.DrawingArea(params);
        this.actor.connect('repaint', Lang.bind(this, this._onRepaint));
    },
    _onRepaint: function(area) {
        let cr = area.get_context();
        let themeNode = area.get_theme_node();
        let [width, height] = area.get_surface_size();
        let margin = themeNode.get_length('-margin-horizontal');
        let gradientHeight = themeNode.get_length('-gradient-height');
        let startColor = themeNode.get_color('-gradient-start');
        let endColor = themeNode.get_color('-gradient-end');
        let gradientWidth = (width - margin * 2);
        let gradientOffset = (height - gradientHeight) / 2;
        let pattern = new Cairo.LinearGradient(margin, gradientOffset, width - margin, gradientOffset + gradientHeight);
        pattern.addColorStopRGBA(0, startColor.red / 255, startColor.green / 255, startColor.blue / 255, startColor.alpha / 255);
        pattern.addColorStopRGBA(0.5, endColor.red / 255, endColor.green / 255, endColor.blue / 255, endColor.alpha / 255);
        pattern.addColorStopRGBA(1, startColor.red / 255, startColor.green / 255, startColor.blue / 255, startColor.alpha / 255);
        cr.setSource(pattern);
        cr.rectangle(margin, gradientOffset, gradientWidth, gradientHeight);
        cr.fill();
        cr.$dispose();
    }
(uuay)screencast.js
// -*- mode: js; js-indent-level: 4; indent-tabs-mode: nil -*-
const Gio = imports.gi.Gio;
const GLib = imports.gi.GLib;
const Lang = imports.lang;
const Shell = imports.gi.Shell;
const Signals = imports.signals;
const Main = imports.ui.main;
const ScreencastIface = '<node> \
<interface name="org.gnome.Shell.Screencast"> \
<method name="Screencast"> \
    <arg type="s" direction="in" name="file_template"/> \
    <arg type="a{sv}" direction="in" name="options"/> \
    <arg type="b" direction="out" name="success"/> \
    <arg type="s" direction="out" name="filename_used"/> \
</method> \
<method name="ScreencastArea"> \
    <arg type="i" direction="in" name="x"/> \
    <arg type="i" direction="in" name="y"/> \
    <arg type="i" direction="in" name="width"/> \
    <arg type="i" direction="in" name="height"/> \
    <arg type="s" direction="in" name="file_template"/> \
    <arg type="a{sv}" direction="in" name="options"/> \
    <arg type="b" direction="out" name="success"/> \
    <arg type="s" direction="out" name="filename_used"/> \
</method> \
<method name="StopScreencast"> \
    <arg type="b" direction="out" name="success"/> \
</method> \
</interface> \
</node>';
const ScreencastService = new Lang.Class({
    Name: 'ScreencastService',
    _init: function() {
        this._dbusImpl = Gio.DBusExportedObject.wrapJSObject(ScreencastIface, this);
        this._dbusImpl.export(Gio.DBus.session, '/org/gnome/Shell/Screencast');
        Gio.DBus.session.own_name('org.gnome.Shell.Screencast', Gio.BusNameOwnerFlags.REPLACE, null, null);
        this._recorders = new Map();
        this._lockdownSettings = new Gio.Settings({ schema_id: 'org.gnome.desktop.lockdown' });
        Main.sessionMode.connect('updated', Lang.bind(this, this._sessionUpdated));
    },
    get isRecording() {
        return this._recorders.size > 0;
    },
    _ensureRecorderForSender: function(sender) {
        let recorder = this._recorders.get(sender);
        if (!recorder) {
            recorder = new Shell.Recorder({ stage: global.stage,
                                            screen: global.screen });
            recorder._watchNameId =
                Gio.bus_watch_name(Gio.BusType.SESSION, sender, 0, null,
                                   Lang.bind(this, this._onNameVanished));
            this._recorders.set(sender, recorder);
            this.emit('updated');
        }
        return recorder;
    },
    _sessionUpdated: function() {
        if (Main.sessionMode.allowScreencast)
            return;
        for (let sender of this._recorders.keys())
            this._stopRecordingForSender(sender);
    },
    _onNameVanished: function(connection, name) {
        this._stopRecordingForSender(name);
    },
    _stopRecordingForSender: function(sender) {
        let recorder = this._recorders.get(sender);
        if (!recorder)
            return false;
        Gio.bus_unwatch_name(recorder._watchNameId);
        recorder.close();
        this._recorders.delete(sender);
        this.emit('updated');
        return true;
    },
    _applyOptionalParameters: function(recorder, options) {
        for (let option in options)
            options[option] = options[option].deep_unpack();
        if (options['pipeline'])
            recorder.set_pipeline(options['pipeline']);
        if (options['framerate'])
            recorder.set_framerate(options['framerate']);
        if ('draw-cursor' in options)
            recorder.set_draw_cursor(options['draw-cursor']);
    },
    ScreencastAsync: function(params, invocation) {
        let returnValue = [false, ''];
        if (!Main.sessionMode.allowScreencast ||
            this._lockdownSettings.get_boolean('disable-save-to-disk')) {
            invocation.return_value(GLib.Variant.new('(bs)', returnValue));
            return;
        }
        let sender = invocation.get_sender();
        let recorder = this._ensureRecorderForSender(sender);
        if (!recorder.is_recording()) {
            let [fileTemplate, options] = params;
            recorder.set_file_template(fileTemplate);
            this._applyOptionalParameters(recorder, options);
            let [success, fileName] = recorder.record();
            returnValue = [success, fileName ? fileName : ''];
            if (!success)
                this._stopRecordingForSender(sender);
        }
        invocation.return_value(GLib.Variant.new('(bs)', returnValue));
    },
    ScreencastAreaAsync: function(params, invocation) {
        let returnValue = [false, ''];
        if (!Main.sessionMode.allowScreencast ||
            this._lockdownSettings.get_boolean('disable-save-to-disk')) {
            invocation.return_value(GLib.Variant.new('(bs)', returnValue));
            return;
        }
        let sender = invocation.get_sender();
        let recorder = this._ensureRecorderForSender(sender);
        if (!recorder.is_recording()) {
            let [x, y, width, height, fileTemplate, options] = params;
            if (x < 0 || y < 0 ||
                width <= 0 || height <= 0 ||
                x + width > global.screen_width ||
                y + height > global.screen_height) {
                invocation.return_error_literal(Gio.IOErrorEnum,
                                                Gio.IOErrorEnum.CANCELLED,
                                                "Invalid params");
                return;
            }
            recorder.set_file_template(fileTemplate);
            recorder.set_area(x, y, width, height);
            this._applyOptionalParameters(recorder, options);
            let [success, fileName] = recorder.record();
            returnValue = [success, fileName ? fileName : ''];
            if (!success)
                this._stopRecordingForSender(sender);
        }
        invocation.return_value(GLib.Variant.new('(bs)', returnValue));
    },
    StopScreencastAsync: function(params, invocation) {
        let success = this._stopRecordingForSender(invocation.get_sender());
        invocation.return_value(GLib.Variant.new('(b)', [success]));
    }
Signals.addSignalMethods(ScreencastService.prototype);
(uuay)networkAgent.js
// -*- mode: js; js-indent-level: 4; indent-tabs-mode: nil -*-
const Clutter = imports.gi.Clutter;
const Gio = imports.gi.Gio;
const GLib = imports.gi.GLib;
const GObject = imports.gi.GObject;
const Lang = imports.lang;
const NetworkManager = imports.gi.NetworkManager;
const NMClient = imports.gi.NMClient;
const Pango = imports.gi.Pango;
const Shell = imports.gi.Shell;
const St = imports.gi.St;
const Config = imports.misc.config;
const Main = imports.ui.main;
const MessageTray = imports.ui.messageTray;
const ModalDialog = imports.ui.modalDialog;
const PopupMenu = imports.ui.popupMenu;
const ShellEntry = imports.ui.shellEntry;
const VPN_UI_GROUP = 'VPN Plugin UI';
const NetworkSecretDialog = new Lang.Class({
    Name: 'NetworkSecretDialog',
    Extends: ModalDialog.ModalDialog,
    _init: function(agent, requestId, connection, settingName, hints, contentOverride) {
        this.parent({ styleClass: 'prompt-dialog' });
        this._agent = agent;
        this._requestId = requestId;
        this._connection = connection;
        this._settingName = settingName;
        this._hints = hints;
        if (contentOverride)
            this._content = contentOverride;
        else
            this._content = this._getContent();
        let mainContentBox = new St.BoxLayout({ style_class: 'prompt-dialog-main-layout',
                                                vertical: false });
        this.contentLayout.add(mainContentBox,
                               { x_fill: true,
                                 y_fill: true });
        let icon = new St.Icon({ icon_name: 'dialog-password-symbolic' });
        mainContentBox.add(icon,
                           { x_fill:  true,
                             y_fill:  false,
                             x_align: St.Align.END,
                             y_align: St.Align.START });
        let messageBox = new St.BoxLayout({ style_class: 'prompt-dialog-message-layout',
                                            vertical: true });
        mainContentBox.add(messageBox,
                           { y_align: St.Align.START });
        let subjectLabel = new St.Label({ style_class: 'prompt-dialog-headline headline',
                                            text: this._content.title });
        messageBox.add(subjectLabel,
                       { y_fill:  false,
                         y_align: St.Align.START });
        if (this._content.message != null) {
            let descriptionLabel = new St.Label({ style_class: 'prompt-dialog-description',
                                                  text: this._content.message });
            descriptionLabel.clutter_text.line_wrap = true;
            descriptionLabel.clutter_text.ellipsize = Pango.EllipsizeMode.NONE;
            messageBox.add(descriptionLabel,
                           { y_fill:  true,
                             y_align: St.Align.START,
                             expand: true });
        }
        let layout = new Clutter.GridLayout({ orientation: Clutter.Orientation.VERTICAL });
        let secretTable = new St.Widget({ style_class: 'network-dialog-secret-table',
                                          layout_manager: layout });
        layout.hookup_style(secretTable);
        let rtl = secretTable.get_text_direction() == Clutter.TextDirection.RTL;
        let initialFocusSet = false;
        let pos = 0;
        for (let i = 0; i < this._content.secrets.length; i++) {
            let secret = this._content.secrets[i];
            let label = new St.Label({ style_class: 'prompt-dialog-password-label',
                                       text: secret.label,
                                       x_align: Clutter.ActorAlign.START,
                                       y_align: Clutter.ActorAlign.CENTER });
            label.clutter_text.ellipsize = Pango.EllipsizeMode.NONE;
            let reactive = secret.key != null;
            secret.entry = new St.Entry({ style_class: 'prompt-dialog-password-entry',
                                          text: secret.value, can_focus: reactive,
                                          reactive: reactive,
                                          x_expand: true });
            ShellEntry.addContextMenu(secret.entry,
                                      { isPassword: secret.password });
            if (secret.validate)
                secret.valid = secret.validate(secret);
            else // no special validation, just ensure it's not empty
                secret.valid = secret.value.length > 0;
            if (reactive) {
                if (!initialFocusSet) {
                    this.setInitialKeyFocus(secret.entry);
                    initialFocusSet = true;
                }
                secret.entry.clutter_text.connect('activate', Lang.bind(this, this._onOk));
                secret.entry.clutter_text.connect('text-changed', Lang.bind(this, function() {
                    secret.value = secret.entry.get_text();
                    if (secret.validate)
                        secret.valid = secret.validate(secret);
                    else
                        secret.valid = secret.value.length > 0;
                    this._updateOkButton();
                }));
            } else
                secret.valid = true;
            if (rtl) {
                layout.attach(secret.entry, 0, pos, 1, 1);
                layout.attach(label, 1, pos, 1, 1);
            } else {
                layout.attach(label, 0, pos, 1, 1);
                layout.attach(secret.entry, 1, pos, 1, 1);
            }
            pos++;
            if (secret.password)
                secret.entry.clutter_text.set_password_char('\u25cf');
        }
        messageBox.add(secretTable);
        this._okButton = { label:  _("Connect"),
                           action: Lang.bind(this, this._onOk),
                           default: true
                         };
        this.setButtons([{ label: _("Cancel"),
                           action: Lang.bind(this, this.cancel),
                           key:    Clutter.KEY_Escape,
                         },
                         this._okButton]);
        this._updateOkButton();
    },
    _updateOkButton: function() {
        let valid = true;
        for (let i = 0; i < this._content.secrets.length; i++) {
            let secret = this._content.secrets[i];
            valid = valid && secret.valid;
        }
        this._okButton.button.reactive = valid;
        this._okButton.button.can_focus = valid;
    },
    _onOk: function() {
        let valid = true;
        for (let i = 0; i < this._content.secrets.length; i++) {
            let secret = this._content.secrets[i];
            valid = valid && secret.valid;
            if (secret.key != null)
                this._agent.set_password(this._requestId, secret.key, secret.value);
        }
        if (valid) {
            this._agent.respond(this._requestId, Shell.NetworkAgentResponse.CONFIRMED);
            this.close(global.get_current_time());
        }
        // do nothing if not valid
    },
    cancel: function() {
        this._agent.respond(this._requestId, Shell.NetworkAgentResponse.USER_CANCELED);
        this.close(global.get_current_time());
    },
    _validateWpaPsk: function(secret) {
        let value = secret.value;
        if (value.length == 64) {
            // must be composed of hexadecimal digits only
            for (let i = 0; i < 64; i++) {
                if (!((value[i] >= 'a' && value[i] <= 'f')
                      || (value[i] >= 'A' && value[i] <= 'F')
                      || (value[i] >= '0' && value[i] <= '9')))
                    return false;
            }
            return true;
        }
        return (value.length >= 8 && value.length <= 63);
    },
    _validateStaticWep: function(secret) {
        let value = secret.value;
        if (secret.wep_key_type == NetworkManager.WepKeyType.KEY) {
            if (value.length == 10 || value.length == 26) {
		for (let i = 0; i < value.length; i++) {
                    if (!((value[i] >= 'a' && value[i] <= 'f')
                          || (value[i] >= 'A' && value[i] <= 'F')
                          || (value[i] >= '0' && value[i] <= '9')))
                        return false;
	    } else if (value.length == 5 || value.length == 13) {
		for (let i = 0; i < value.length; i++) {
                    if (!((value[i] >= 'a' && value[i] <= 'z')
                          || (value[i] >= 'A' && value[i] <= 'Z')))
                        return false;
                }
            } else
                return false;
	} else if (secret.wep_key_type == NetworkManager.WepKeyType.PASSPHRASE) {
	    if (value.length < 0 || value.length > 64)
	        return false;
        return true;
    },
    _getWirelessSecrets: function(secrets, wirelessSetting) {
        let wirelessSecuritySetting = this._connection.get_setting_wireless_security();
        switch (wirelessSecuritySetting.key_mgmt) {
        // First the easy ones
        case 'wpa-none':
        case 'wpa-psk':
            secrets.push({ label: _("Password: "), key: 'psk',
                           value: wirelessSecuritySetting.psk || '',
                           validate: this._validateWpaPsk, password: true });
            break;
        case 'none': // static WEP
            secrets.push({ label: _("Key: "), key: 'wep-key' + wirelessSecuritySetting.wep_tx_keyidx,
                           value: wirelessSecuritySetting.get_wep_key(wirelessSecuritySetting.wep_tx_keyidx) || '',
                           wep_key_type: wirelessSecuritySetting.wep_key_type,
                           validate: this._validateStaticWep, password: true });
            break;
        case 'ieee8021x':
            if (wirelessSecuritySetting.auth_alg == 'leap') // Cisco LEAP
                secrets.push({ label: _("Password: "), key: 'leap-password',
                               value: wirelessSecuritySetting.leap_password || '', password: true });
            else // Dynamic (IEEE 802.1x) WEP
                this._get8021xSecrets(secrets);
            break;
        case 'wpa-eap':
            this._get8021xSecrets(secrets);
            break;
        default:
            log('Invalid wireless key management: ' + wirelessSecuritySetting.key_mgmt);
        }
    },
    _get8021xSecrets: function(secrets) {
        let ieee8021xSetting = this._connection.get_setting_802_1x();
        let phase2method;
        switch (ieee8021xSetting.get_eap_method(0)) {
        case 'md5':
        case 'leap':
        case 'ttls':
        case 'peap':
        case 'fast':
            // TTLS and PEAP are actually much more complicated, but this complication
            // is not visible here since we only care about phase2 authentication
            // (and don't even care of which one)
            secrets.push({ label: _("Username: "), key: null,
                           value: ieee8021xSetting.identity || '', password: false });
            secrets.push({ label: _("Password: "), key: 'password',
                           value: ieee8021xSetting.password || '', password: true });
            break;
        case 'tls':
            secrets.push({ label: _("Identity: "), key: null,
                           value: ieee8021xSetting.identity || '', password: false });
            secrets.push({ label: _("Private key password: "), key: 'private-key-password',
                           value: ieee8021xSetting.private_key_password || '', password: true });
            break;
        default:
            log('Invalid EAP/IEEE802.1x method: ' + ieee8021xSetting.get_eap_method(0));
        }
    },
    _getPPPoESecrets: function(secrets) {
        let pppoeSetting = this._connection.get_setting_pppoe();
        secrets.push({ label: _("Username: "), key: 'username',
                       value: pppoeSetting.username || '', password: false });
        secrets.push({ label: _("Service: "), key: 'service',
                       value: pppoeSetting.service || '', password: false });
        secrets.push({ label: _("Password: "), key: 'password',
                       value: pppoeSetting.password || '', password: true });
    },
    _getMobileSecrets: function(secrets, connectionType) {
        let setting;
        if (connectionType == 'bluetooth')
            setting = this._connection.get_setting_cdma() || this._connection.get_setting_gsm();
        else
            setting = this._connection.get_setting_by_name(connectionType);
        secrets.push({ label: _("Password: "), key: 'password',
                       value: setting.value || '', password: true });
    },
    _getContent: function() {
        let connectionSetting = this._connection.get_setting_connection();
        let connectionType = connectionSetting.get_connection_type();
        let wirelessSetting;
        let ssid;
        let content = { };
        content.secrets = [ ];
        switch (connectionType) {
        case '802-11-wireless':
            wirelessSetting = this._connection.get_setting_wireless();
            ssid = NetworkManager.utils_ssid_to_utf8(wirelessSetting.get_ssid());
            content.title = _("Authentication required by wireless network");
            content.message = _("Passwords or encryption keys are required to access the wireless network 
.").format(ssid);
            this._getWirelessSecrets(content.secrets, wirelessSetting);
            break;
        case '802-3-ethernet':
            content.title = _("Wired 802.1X authentication");
            content.message = null;
            content.secrets.push({ label: _("Network name: "), key: null,
                                   value: connectionSetting.get_id(), password: false });
            this._get8021xSecrets(content.secrets);
            break;
        case 'pppoe':
            content.title = _("DSL authentication");
            content.message = null;
            this._getPPPoESecrets(content.secrets);
            break;
        case 'gsm':
            if (this._hints.indexOf('pin') != -1) {
                let gsmSetting = this._connection.get_setting_gsm();
                content.title = _("PIN code required");
                content.message = _("PIN code is needed for the mobile broadband device");
                content.secrets.push({ label: _("PIN: "), key: 'pin',
                                       value: gsmSetting.pin || '', password: true });
                break;
            }
            // fall through
        case 'cdma':
        case 'bluetooth':
            content.title = _("Mobile broadband network password");
            content.message = _("A password is required to connect to 
.").format(connectionSetting.get_id());
            this._getMobileSecrets(content.secrets, connectionType);
            break;
        default:
            log('Invalid connection type: ' + connectionType);
        };
        return content;
    }
const VPNRequestHandler = new Lang.Class({
    Name: 'VPNRequestHandler',
    _init: function(agent, requestId, authHelper, serviceType, connection, hints, flags) {
        this._agent = agent;
        this._requestId = requestId;
        this._connection = connection;
        this._pluginOutBuffer = [];
        this._title = null;
        this._description = null;
        this._content = [ ];
        this._shellDialog = null;
        let connectionSetting = connection.get_setting_connection();
        let argv = [ authHelper.fileName,
                     '-u', connectionSetting.uuid,
                     '-n', connectionSetting.id,
                     '-s', serviceType
                   ];
        if (authHelper.externalUIMode)
            argv.push('--external-ui-mode');
        if (flags & NMClient.SecretAgentGetSecretsFlags.ALLOW_INTERACTION)
            argv.push('-i');
        if (flags & NMClient.SecretAgentGetSecretsFlags.REQUEST_NEW)
            argv.push('-r');
        if (authHelper.supportsHints) {
            for (let i = 0; i < hints.length; i++) {
                argv.push('-t');
                argv.push(hints[i]);
            }
        }
        this._newStylePlugin = authHelper.externalUIMode;
        try {
            let [success, pid, stdin, stdout, stderr] =
                GLib.spawn_async_with_pipes(null, /* pwd */
                                            argv,
                                            null, /* envp */
                                            GLib.SpawnFlags.DO_NOT_REAP_CHILD,
                                            null /* child_setup */);
            this._childPid = pid;
            this._stdin = new Gio.UnixOutputStream({ fd: stdin, close_fd: true });
            this._stdout = new Gio.UnixInputStream({ fd: stdout, close_fd: true });
            GLib.close(stderr);
            this._dataStdout = new Gio.DataInputStream({ base_stream: this._stdout });
            if (this._newStylePlugin)
                this._readStdoutNewStyle();
            else
                this._readStdoutOldStyle();
            this._childWatch = GLib.child_watch_add(GLib.PRIORITY_DEFAULT, pid,
                                                    Lang.bind(this, this._vpnChildFinished));
            this._writeConnection();
        } catch(e) {
            logError(e, 'error while spawning VPN auth helper');
            this._agent.respond(requestId, Shell.NetworkAgentResponse.INTERNAL_ERROR);
        }
    },
    cancel: function(respond) {
        if (respond)
            this._agent.respond(this._requestId, Shell.NetworkAgentResponse.USER_CANCELED);
        if (this._newStylePlugin && this._shellDialog) {
            this._shellDialog.close(global.get_current_time());
            this._shellDialog.destroy();
        } else {
            try {
                this._stdin.write('QUIT\n\n', null);
            } catch(e) { /* ignore broken pipe errors */ }
        }
        this.destroy();
    },
    destroy: function() {
        if (this._destroyed)
            return;
        GLib.source_remove(this._childWatch);
        this._stdin.close(null);
        // Stdout is closed when we finish reading from it
        this._destroyed = true;
    },
    _vpnChildFinished: function(pid, status, requestObj) {
        this._childWatch = 0;
        if (this._newStylePlugin) {
            // For new style plugin, all work is done in the async reading functions
            // Just reap the process here
            return;
        }
        let [exited, exitStatus] = Shell.util_wifexited(status);
        if (exited) {
            if (exitStatus != 0)
                this._agent.respond(this._requestId, Shell.NetworkAgentResponse.USER_CANCELED);
            else
                this._agent.respond(this._requestId, Shell.NetworkAgentResponse.CONFIRMED);
        } else
            this._agent.respond(this._requestId, Shell.NetworkAgentResponse.INTERNAL_ERROR);
        this.destroy();
    },
    _vpnChildProcessLineOldStyle: function(line) {
        if (this._previousLine != undefined) {
            // Two consecutive newlines mean that the child should be closed
            // (the actual newlines are eaten by Gio.DataInputStream)
            // Send a termination message
            if (line == '' && this._previousLine == '') {
                try {
                    this._stdin.write('QUIT\n\n', null);
                } catch(e) { /* ignore broken pipe errors */ }
            } else {
                this._agent.set_password(this._requestId, this._previousLine, line);
                this._previousLine = undefined;
            }
        } else {
            this._previousLine = line;
        }
    },
    _readStdoutOldStyle: function() {
        this._dataStdout.read_line_async(GLib.PRIORITY_DEFAULT, null, Lang.bind(this, function(stream, result) {
            let [line, len] = this._dataStdout.read_line_finish_utf8(result);
            if (line == null) {
                // end of file
                this._stdout.close(null);
                return;
            }
            this._vpnChildProcessLineOldStyle(line);
            // try to read more!
            this._readStdoutOldStyle();
        }));
    },
    _readStdoutNewStyle: function() {
        this._dataStdout.fill_async(-1, GLib.PRIORITY_DEFAULT, null, Lang.bind(this, function(stream, result) {
            let cnt = this._dataStdout.fill_finish(result);
            if (cnt == 0) {
                // end of file
                this._showNewStyleDialog();
                this._stdout.close(null);
                return;
            }
            // Try to read more
            this._dataStdout.set_buffer_size(2 * this._dataStdout.get_buffer_size());
            this._readStdoutNewStyle();
        }));
    },
    _showNewStyleDialog: function() {
        let keyfile = new GLib.KeyFile();
        let data;
        let contentOverride;
        try {
            data = this._dataStdout.peek_buffer();
            keyfile.load_from_data(data.toString(), data.length,
                                   GLib.KeyFileFlags.NONE);
            if (keyfile.get_integer(VPN_UI_GROUP, 'Version') != 2)
                throw new Error('Invalid plugin keyfile version, is %d');
            contentOverride = { title: keyfile.get_string(VPN_UI_GROUP, 'Title'),
                                message: keyfile.get_string(VPN_UI_GROUP, 'Description'),
                                secrets: [] };
            let [groups, len] = keyfile.get_groups();
            for (let i = 0; i < groups.length; i++) {
                if (groups[i] == VPN_UI_GROUP)
                    continue;
                let value = keyfile.get_string(groups[i], 'Value');
                let shouldAsk = keyfile.get_boolean(groups[i], 'ShouldAsk');
                if (shouldAsk) {
                    contentOverride.secrets.push({ label: keyfile.get_string(groups[i], 'Label'),
                                                   key: groups[i],
                                                   value: value,
                                                   password: keyfile.get_boolean(groups[i], 'IsSecret')
                                                 });
                } else {
                    if (!value.length) // Ignore empty secrets
                        continue;
                    this._agent.set_password(this._requestId, groups[i], value);
                }
            }
        } catch(e) {
            // No output is a valid case it means "both secrets are stored"
            if (data.length > 0) {
                logError(e, 'error while reading VPN plugin output keyfile');
                this._agent.respond(this._requestId, Shell.NetworkAgentResponse.INTERNAL_ERROR);
                return;
            }
        }
        if (contentOverride && contentOverride.secrets.length) {
            // Only show the dialog if we actually have something to ask
            this._shellDialog = new NetworkSecretDialog(this._agent, this._requestId, this._connection, 'vpn', [], contentOverride);
            this._shellDialog.open(global.get_current_time());
        } else {
            this._agent.respond(this._requestId, Shell.NetworkAgentResponse.CONFIRMED);
        }
    },
    _writeConnection: function() {
        let vpnSetting = this._connection.get_setting_vpn();
        try {
            vpnSetting.foreach_data_item(Lang.bind(this, function(key, value) {
                this._stdin.write('DATA_KEY=' + key + '\n', null);
                this._stdin.write('DATA_VAL=' + (value || '') + '\n\n', null);
            }));
            vpnSetting.foreach_secret(Lang.bind(this, function(key, value) {
                this._stdin.write('SECRET_KEY=' + key + '\n', null);
                this._stdin.write('SECRET_VAL=' + (value || '') + '\n\n', null);
            }));
            this._stdin.write('DONE\n\n', null);
        } catch(e) {
            logError(e, 'internal error while writing connection to helper');
            this._agent.respond(this._requestId, Shell.NetworkAgentResponse.INTERNAL_ERROR);
        }
    },
const NetworkAgent = new Lang.Class({
    Name: 'NetworkAgent',
    _init: function() {
        this._native = new Shell.NetworkAgent({ identifier: 'org.gnome.Shell.NetworkAgent',
                                                capabilities: NMClient.SecretAgentCapabilities.VPN_HINTS
                                              });
        this._dialogs = { };
        this._vpnRequests = { };
        this._notifications = { };
        this._native.connect('new-request', Lang.bind(this, this._newRequest));
        this._native.connect('cancel-request', Lang.bind(this, this._cancelRequest));
        this._enabled = false;
    },
    enable: function() {
        this._enabled = true;
    },
    disable: function() {
        let requestId;
        for (requestId in this._dialogs)
            this._dialogs[requestId].cancel();
        this._dialogs = { };
        for (requestId in this._vpnRequests)
            this._vpnRequests[requestId].cancel(true);
        this._vpnRequests = { };
        for (requestId in this._notifications)
            this._notifications[requestId].destroy();
        this._notifications = { };
        this._enabled = false;
    },
    _showNotification: function(requestId, connection, settingName, hints, flags) {
        let source = new MessageTray.Source(_("Network Manager"), 'network-transmit-receive');
        source.policy = new MessageTray.NotificationApplicationPolicy('gnome-network-panel');
        let title, body;
        let connectionSetting = connection.get_setting_connection();
        let connectionType = connectionSetting.get_connection_type();
        switch (connectionType) {
        case '802-11-wireless':
            let wirelessSetting = connection.get_setting_wireless();
            let ssid = NetworkManager.utils_ssid_to_utf8(wirelessSetting.get_ssid());
            title = _("Authentication required by wireless network");
            body = _("Passwords or encryption keys are required to access the wireless network 
.").format(ssid);
            break;
        case '802-3-ethernet':
            title = _("Wired 802.1X authentication");
            body = _("A password is required to connect to 
.".format(connection.get_id()));
            break;
        case 'pppoe':
            title = _("DSL authentication");
            body = _("A password is required to connect to 
.".format(connection.get_id()));
            break;
        case 'gsm':
            if (hints.indexOf('pin') != -1) {
                let gsmSetting = connection.get_setting_gsm();
                title = _("PIN code required");
                message = _("PIN code is needed for the mobile broadband device");
                break;
            }
            // fall through
        case 'cdma':
        case 'bluetooth':
            title = _("Mobile broadband network password");
            message = _("A password is required to connect to 
.").format(connectionSetting.get_id());
            break;
        default:
            log('Invalid connection type: ' + connectionType);
            this._native.respond(requestId, Shell.NetworkAgentResponse.INTERNAL_ERROR);
            return;
        }
        let notification = new MessageTray.Notification(source, title, body);
        notification.connect('activated', Lang.bind(this, function() {
            notification.answered = true;
            this._handleRequest(requestId, connection, settingName, hints, flags);
        }));
        this._notifications[requestId] = notification;
        notification.connect('destroy', Lang.bind(this, function() {
            if (!notification.answered)
                this._native.respond(requestId, Shell.NetworkAgentResponse.USER_CANCELED);
            delete this._notifications[requestId];
        }));
        Main.messageTray.add(source);
        source.notify(notification);
    },
    _newRequest:  function(agent, requestId, connection, settingName, hints, flags) {
        if (!this._enabled) {
            agent.respond(requestId, Shell.NetworkAgentResponse.USER_CANCELED);
            return;
        }
        if (!(flags & NMClient.SecretAgentGetSecretsFlags.USER_REQUESTED))
            this._showNotification(requestId, connection, settingName, hints, flags);
        else
            this._handleRequest(requestId, connection, settingName, hints, flags);
    },
    _handleRequest: function(requestId, connection, settingName, hints, flags) {
        if (settingName == 'vpn') {
            this._vpnRequest(requestId, connection, hints, flags);
            return;
        }
        let dialog = new NetworkSecretDialog(this._native, requestId, connection, settingName, hints);
        dialog.connect('destroy', Lang.bind(this, function() {
            delete this._dialogs[requestId];
        }));
        this._dialogs[requestId] = dialog;
        dialog.open(global.get_current_time());
    },
    _cancelRequest: function(agent, requestId) {
        if (this._dialogs[requestId]) {
            this._dialogs[requestId].close(global.get_current_time());
            this._dialogs[requestId].destroy();
            delete this._dialogs[requestId];
        } else if (this._vpnRequests[requestId]) {
            this._vpnRequests[requestId].cancel(false);
            delete this._vpnRequests[requestId];
        }
    },
    _vpnRequest: function(requestId, connection, hints, flags) {
        let vpnSetting = connection.get_setting_vpn();
        let serviceType = vpnSetting.service_type;
        this._buildVPNServiceCache();
        let binary = this._vpnBinaries[serviceType];
        if (!binary) {
            log('Invalid VPN service type (cannot find authentication binary)');
            /* cancel the auth process */
            this._native.respond(requestId, Shell.NetworkAgentResponse.INTERNAL_ERROR);
            return;
        }
        this._vpnRequests[requestId] = new VPNRequestHandler(this._native, requestId, binary, serviceType, connection, hints, flags);
    },
    _buildVPNServiceCache: function() {
        if (this._vpnCacheBuilt)
            return;
        this._vpnCacheBuilt = true;
        this._vpnBinaries = { };
        let dir = Gio.file_new_for_path(GLib.build_filenamev([Config.SYSCONFDIR, 'NetworkManager/VPN']));
        try {
            let fileEnum = dir.enumerate_children('standard::name', Gio.FileQueryInfoFlags.NONE, null);
            let info;
            while ((info = fileEnum.next_file(null))) {
                let name = info.get_name();
                if (name.substr(-5) != '.name')
                    continue;
                try {
                    let keyfile = new GLib.KeyFile();
                    keyfile.load_from_file(dir.get_child(name).get_path(), GLib.KeyFileFlags.NONE);
                    let service = keyfile.get_string('VPN Connection', 'service');
                    let binary = keyfile.get_string('GNOME', 'auth-dialog');
                    let externalUIMode = false;
                    let hints = false;
                    try {
                        externalUIMode = keyfile.get_boolean('GNOME', 'supports-external-ui-mode');
                    } catch(e) { } // ignore errors if key does not exist
                    try {
                        hints = keyfile.get_boolean('GNOME', 'supports-hints');
                    } catch(e) { } // ignore errors if key does not exist
                    let path = binary;
                    if (!GLib.path_is_absolute(path)) {
                        path = GLib.build_filenamev([Config.LIBEXECDIR, path]);
                    }
                    if (GLib.file_test(path, GLib.FileTest.IS_EXECUTABLE)) {
                        this._vpnBinaries[service] = { fileName: path, externalUIMode: externalUIMode, supportsHints: hints };
                        try {
                            let aliases = keyfile.get_string_list('VPN Connection', 'aliases');
                            for (let alias of aliases) {
                                this._vpnBinaries[alias] = { fileName: path, externalUIMode: externalUIMode, supportsHints: hints };
                            }
                        } catch(e) { } // ignore errors if key does not exist
                    } else {
                        throw new Error('VPN plugin at %s is not executable'.format(path));
                    }
                } catch(e) {
                    log('Error \'%s\' while processing VPN keyfile \'%s\''.
                        format(e.message, dir.get_child(name).get_path()));
                    continue;
                }
            }
        } catch(e) {
            logError(e, 'error while enumerating VPN auth helpers');
        }
    }
const Component = NetworkAgent;
(uuay)history.js
// -*- mode: js; js-indent-level: 4; indent-tabs-mode: nil -*-
const Lang = imports.lang;
const Signals = imports.signals;
const Clutter = imports.gi.Clutter;
const Params = imports.misc.params;
const DEFAULT_LIMIT = 512;
const HistoryManager = new Lang.Class({
    Name: 'HistoryManager',
    _init: function(params) {
        params = Params.parse(params, { gsettingsKey: null,
                                        limit: DEFAULT_LIMIT,
                                        entry: null });
        this._key = params.gsettingsKey;
        this._limit = params.limit;
        this._historyIndex = 0;
        if (this._key) {
            this._history = global.settings.get_strv(this._key);
            global.settings.connect('changed::' + this._key,
                                    Lang.bind(this, this._historyChanged));
        } else {
            this._history = [];
        }
        this._entry = params.entry;
        if (this._entry) {
            this._entry.connect('key-press-event', 
                                Lang.bind(this, this._onEntryKeyPress));
        }
    },
    _historyChanged: function() {
        this._history = global.settings.get_strv(this._key);
        this._historyIndex = this._history.length;
    },
    _setPrevItem: function(text) {
        if (this._historyIndex <= 0)
            return false;
        if (text)
            this._history[this._historyIndex] = text;
        this._historyIndex--;
        this._indexChanged();
        return true;
    },
    _setNextItem: function(text) {
        if (this._historyIndex >= this._history.length)
            return false;
        if (text)
            this._history[this._historyIndex] = text;
        this._historyIndex++;
        this._indexChanged();
        return true;
    },
    lastItem: function() {
        if (this._historyIndex != this._history.length) {
            this._historyIndex = this._history.length;
            this._indexChanged();
        }
        return this._historyIndex[this._history.length];
    },
    addItem: function(input) {
        if (this._history.length == 0 ||
            this._history[this._history.length - 1] != input) {
            this._history.push(input);
            this._save();
        }
        this._historyIndex = this._history.length;
    },
    _onEntryKeyPress: function(entry, event) {
        let symbol = event.get_key_symbol();
        if (symbol == Clutter.KEY_Up) {
            return this._setPrevItem(entry.get_text());
        } else if (symbol == Clutter.KEY_Down) {
            return this._setNextItem(entry.get_text());
        }
        return Clutter.EVENT_PROPAGATE;
    },
    _indexChanged: function() {
        let current = this._history[this._historyIndex] || '';
        this.emit('changed', current);
        if (this._entry)
            this._entry.set_text(current);
    },
    _save: function() {
        if (this._history.length > this._limit)
            this._history.splice(0, this._history.length - this._limit);
        if (this._key)
            global.settings.set_strv(this._key, this._history);
    }
Signals.addSignalMethods(HistoryManager.prototype);
(uuay)realmd.js
// -*- mode: js; js-indent-level: 4; indent-tabs-mode: nil -*-
const Gio = imports.gi.Gio;
const Lang = imports.lang;
const Shell = imports.gi.Shell;
const Signals = imports.signals;
const ProviderIface = '<node> \
<interface name="org.freedesktop.realmd.Provider"> \
    <property name="Name" type="s" access="read"/> \
    <property name="Version" type="s" access="read"/> \
    <property name="Realms" type="ao" access="read"/> \
    <method name="Discover"> \
        <arg name="string" type="s" direction="in"/> \
        <arg name="options" type="a{sv}" direction="in"/> \
        <arg name="relevance" type="i" direction="out"/> \
        <arg name="realm" type="ao" direction="out"/> \
    </method> \
</interface> \
</node>';
const Provider = Gio.DBusProxy.makeProxyWrapper(ProviderIface);
const ServiceIface = '<node> \
<interface name="org.freedesktop.realmd.Service"> \
    <method name="Cancel"> \
        <arg name="operation" type="s" direction="in"/> \
    </method> \
    <method name="Release" /> \
    <method name="SetLocale"> \
        <arg name="locale" type="s" direction="in"/> \
    </method> \
    <signal name="Diagnostics"> \
        <arg name="data" type="s"/> \
        <arg name="operation" type="s"/> \
    </signal> \
</interface> \
</node>';
const Service = Gio.DBusProxy.makeProxyWrapper(ServiceIface);
const RealmIface = '<node> \
<interface name="org.freedesktop.realmd.Realm"> \
    <property name="Name" type="s" access="read"/> \
    <property name="Configured" type="s" access="read"/> \
    <property name="Details" type="a(ss)" access="read"/> \
    <property name="LoginFormats" type="as" access="read"/> \
    <property name="LoginPolicy" type="s" access="read"/> \
    <property name="PermittedLogins" type="as" access="read"/> \
    <property name="SupportedInterfaces" type="as" access="read"/> \
    <method name="ChangeLoginPolicy"> \
        <arg name="login_policy" type="s" direction="in"/> \
        <arg name="permitted_add" type="as" direction="in"/> \
        <arg name="permitted_remove" type="as" direction="in"/> \
        <arg name="options" type="a{sv}" direction="in"/> \
    </method> \
    <method name="Deconfigure"> \
        <arg name="options" type="a{sv}" direction="in"/> \
    </method> \
</interface> \
</node>';
const Realm = Gio.DBusProxy.makeProxyWrapper(RealmIface);
const Manager = new Lang.Class({
    Name: 'Manager',
    _init: function(parentActor) {
        this._aggregateProvider = Provider(Gio.DBus.system,
                                           'org.freedesktop.realmd',
                                           '/org/freedesktop/realmd',
                                           Lang.bind(this, this._reloadRealms))
        this._realms = {};
        this._signalId = this._aggregateProvider.connect('g-properties-changed',
                                        Lang.bind(this, function(proxy, properties) {
                                            if ('Realms' in properties.deep_unpack())
                                                this._reloadRealms();
                                        }));
    },
    _reloadRealms: function() {
        let realmPaths = this._aggregateProvider.Realms;
        if (!realmPaths)
            return;
        for (let i = 0; i < realmPaths.length; i++) {
            let realm = Realm(Gio.DBus.system,
                              'org.freedesktop.realmd',
                              realmPaths[i],
                              Lang.bind(this, this._onRealmLoaded));
        }
    },
    _reloadRealm: function(realm) {
        if (!realm.Configured) {
            if (this._realms[realm.get_object_path()])
                delete this._realms[realm.get_object_path()];
            return;
        }
        this._realms[realm.get_object_path()] = realm;
        this._updateLoginFormat();
    },
    _onRealmLoaded: function(realm, error) {
        if (error)
            return;
        this._reloadRealm(realm);
        realm.connect('g-properties-changed',
                      Lang.bind(this, function(proxy, properties) {
                                if ('Configured' in properties.deep_unpack())
                                    this._reloadRealm(realm);
                                }));
    },
    _updateLoginFormat: function() {
        let newLoginFormat;
        for (let realmPath in this._realms) {
            let realm = this._realms[realmPath];
            if (realm.LoginFormats && realm.LoginFormats.length > 0) {
                newLoginFormat = realm.LoginFormats[0];
                break;
            }
        }
        if (this._loginFormat != newLoginFormat) {
            this._loginFormat = newLoginFormat;
            this.emit('login-format-changed', newLoginFormat);
        }
    },
    get loginFormat() {
        if (this._loginFormat !== undefined)
            return this._loginFormat;
        this._updateLoginFormat();
        return this._loginFormat;
    },
    release: function() {
        Service(Gio.DBus.system,
                'org.freedesktop.realmd',
                '/org/freedesktop/realmd',
                function(service) {
                    service.ReleaseRemote();
                });
        this._aggregateProvider.disconnect(this._signalId);
        this._realms = { };
        this._updateLoginFormat();
    }
Signals.addSignalMethods(Manager.prototype)
(uuay)params.js;
// -*- mode: js; js-indent-level: 4; indent-tabs-mode: nil -*-
// parse:
// @params: caller-provided parameter object, or %null
// @defaults: function-provided defaults object
// @allowExtras: whether or not to allow properties not in @default
// Examines @params and fills in default values from @defaults for
// any properties in @defaults that don't appear in @params. If
// @allowExtras is not %true, it will throw an error if @params
// contains any properties that aren't in @defaults.
// If @params is %null, this returns the values from @defaults.
// Return value: a new object, containing the merged parameters from
// @params and @defaults
function parse(params, defaults, allowExtras) {
    let ret = {}, prop;
    if (!params)
        params = {};
    for (prop in params) {
        if (!(prop in defaults) && !allowExtras)
            throw new Error('Unrecognized parameter "' + prop + '"');
        ret[prop] = params[prop];
    }
    for (prop in defaults) {
        if (!(prop in params))
            ret[prop] = defaults[prop];
    }
    return ret;
(uuay)volume.js
// -*- mode: js; js-indent-level: 4; indent-tabs-mode: nil -*-
const Clutter = imports.gi.Clutter;
const Lang = imports.lang;
const Gio = imports.gi.Gio;
const Gvc = imports.gi.Gvc;
const St = imports.gi.St;
const Signals = imports.signals;
const PanelMenu = imports.ui.panelMenu;
const PopupMenu = imports.ui.popupMenu;
const Slider = imports.ui.slider;
const VOLUME_NOTIFY_ID = 1;
// Each Gvc.MixerControl is a connection to PulseAudio,
// so it's better to make it a singleton
let _mixerControl;
function getMixerControl() {
    if (_mixerControl)
        return _mixerControl;
    _mixerControl = new Gvc.MixerControl({ name: 'GNOME Shell Volume Control' });
    _mixerControl.open();
    return _mixerControl;
const StreamSlider = new Lang.Class({
    Name: 'StreamSlider',
    _init: function(control) {
        this._control = control;
        this.item = new PopupMenu.PopupBaseMenuItem({ activate: false });
        this._slider = new Slider.Slider(0);
        this._slider.connect('value-changed', Lang.bind(this, this._sliderChanged));
        this._slider.connect('drag-end', Lang.bind(this, this._notifyVolumeChange));
        this._icon = new St.Icon({ style_class: 'popup-menu-icon' });
        this.item.actor.add(this._icon);
        this.item.actor.add(this._slider.actor, { expand: true });
        this.item.actor.connect('button-press-event', Lang.bind(this, function(actor, event) {
            return this._slider.startDragging(event);
        }));
        this.item.actor.connect('key-press-event', Lang.bind(this, function(actor, event) {
            return this._slider.onKeyPressEvent(actor, event);
        }));
        this._stream = null;
    },
    get stream() {
        return this._stream;
    },
    set stream(stream) {
        if (this._stream) {
            this._disconnectStream(this._stream);
        }
        this._stream = stream;
        if (this._stream) {
            this._connectStream(this._stream);
            this._updateVolume();
        } else {
            this.emit('stream-updated');
        }
        this._updateVisibility();
    },
    _disconnectStream: function(stream) {
        stream.disconnect(this._mutedChangedId);
        this._mutedChangedId = 0;
        stream.disconnect(this._volumeChangedId);
        this._volumeChangedId = 0;
    },
    _connectStream: function(stream) {
        this._mutedChangedId = stream.connect('notify::is-muted', Lang.bind(this, this._updateVolume));
        this._volumeChangedId = stream.connect('notify::volume', Lang.bind(this, this._updateVolume));
    },
    _shouldBeVisible: function() {
        return this._stream != null;
    },
    _updateVisibility: function() {
        let visible = this._shouldBeVisible();
        this.item.actor.visible = visible;
    },
    scroll: function(event) {
        return this._slider.scroll(event);
    },
    setValue: function(value) {
        // piggy-back off of sliderChanged
        this._slider.setValue(value);
    },
    _sliderChanged: function(slider, value, property) {
        if (!this._stream)
            return;
        let volume = value * this._control.get_vol_max_norm();
        let prevMuted = this._stream.is_muted;
        if (volume < 1) {
            this._stream.volume = 0;
            if (!prevMuted)
                this._stream.change_is_muted(true);
        } else {
            this._stream.volume = volume;
            if (prevMuted)
                this._stream.change_is_muted(false);
        }
        this._stream.push_volume();
    },
    _notifyVolumeChange: function() {
        global.cancel_theme_sound(VOLUME_NOTIFY_ID);
        global.play_theme_sound(VOLUME_NOTIFY_ID,
                                'audio-volume-change',
                                _("Volume changed"),
                                Clutter.get_current_event ());
    },
    _updateVolume: function() {
        let muted = this._stream.is_muted;
        this._slider.setValue(muted ? 0 : (this._stream.volume / this._control.get_vol_max_norm()));
        this.emit('stream-updated');
    },
    getIcon: function() {
        if (!this._stream)
            return null;
        let volume = this._stream.volume;
        if (this._stream.is_muted || volume <= 0) {
            return 'audio-volume-muted-symbolic';
        } else {
            let n = Math.floor(3 * volume / this._control.get_vol_max_norm()) + 1;
            if (n < 2)
                return 'audio-volume-low-symbolic';
            if (n >= 3)
                return 'audio-volume-high-symbolic';
            return 'audio-volume-medium-symbolic';
        }
    }
Signals.addSignalMethods(StreamSlider.prototype);
const OutputStreamSlider = new Lang.Class({
    Name: 'OutputStreamSlider',
    Extends: StreamSlider,
    _init: function(control) {
        this.parent(control);
        this._slider.actor.accessible_name = _("Volume");
    },
    _connectStream: function(stream) {
        this.parent(stream);
        this._portChangedId = stream.connect('notify::port', Lang.bind(this, this._portChanged));
        this._portChanged();
    },
    _findHeadphones: function(sink) {
        // This only works for external headphones (e.g. bluetooth)
        if (sink.get_form_factor() == 'headset' ||
            sink.get_form_factor() == 'headphone')
            return true;
        // a bit hackish, but ALSA/PulseAudio have a number
        // of different identifiers for headphones, and I could
        // not find the complete list
        if (sink.get_ports().length > 0)
            return sink.get_port().port.indexOf('headphone') >= 0;
        return false;
    },
    _disconnectStream: function(stream) {
        this.parent(stream);
        stream.disconnect(this._portChangedId);
        this._portChangedId = 0;
    },
    _updateSliderIcon: function() {
        this._icon.icon_name = (this._hasHeadphones ?
                                'audio-headphones-symbolic' :
                                'audio-speakers-symbolic');
    },
    _portChanged: function() {
        let hasHeadphones = this._findHeadphones(this._stream);
        if (hasHeadphones != this._hasHeadphones) {
            this._hasHeadphones = hasHeadphones;
            this._updateSliderIcon();
        }
    }
const InputStreamSlider = new Lang.Class({
    Name: 'InputStreamSlider',
    Extends: StreamSlider,
    _init: function(control) {
        this.parent(control);
        this._slider.actor.accessible_name = _("Microphone");
        this._control.connect('stream-added', Lang.bind(this, this._maybeShowInput));
        this._control.connect('stream-removed', Lang.bind(this, this._maybeShowInput));
        this._icon.icon_name = 'audio-input-microphone-symbolic';
    },
    _connectStream: function(stream) {
        this.parent(stream);
        this._maybeShowInput();
    },
    _maybeShowInput: function() {
        // only show input widgets if any application is recording audio
        let showInput = false;
        let recordingApps = this._control.get_source_outputs();
        if (this._stream && recordingApps) {
            for (let i = 0; i < recordingApps.length; i++) {
                let outputStream = recordingApps[i];
                let id = outputStream.get_application_id();
                // but skip gnome-volume-control and pavucontrol
                // (that appear as recording because they show the input level)
                if (!id || (id != 'org.gnome.VolumeControl' && id != 'org.PulseAudio.pavucontrol')) {
                    showInput = true;
                    break;
                }
            }
        }
        this._showInput = showInput;
        this._updateVisibility();
    },
    _shouldBeVisible: function() {
        return this.parent() && this._showInput;
    }
const VolumeMenu = new Lang.Class({
    Name: 'VolumeMenu',
    Extends: PopupMenu.PopupMenuSection,
    _init: function(control) {
        this.parent();
        this.hasHeadphones = false;
        this._control = control;
        this._control.connect('state-changed', Lang.bind(this, this._onControlStateChanged));
        this._control.connect('default-sink-changed', Lang.bind(this, this._readOutput));
        this._control.connect('default-source-changed', Lang.bind(this, this._readInput));
        this._output = new OutputStreamSlider(this._control);
        this._output.connect('stream-updated', Lang.bind(this, function() {
            this.emit('icon-changed');
        }));
        this.addMenuItem(this._output.item);
        this._input = new InputStreamSlider(this._control);
        this.addMenuItem(this._input.item);
        this.addMenuItem(new PopupMenu.PopupSeparatorMenuItem());
        this._onControlStateChanged();
    },
    scroll: function(event) {
        return this._output.scroll(event);
    },
    _onControlStateChanged: function() {
        if (this._control.get_state() == Gvc.MixerControlState.READY) {
            this._readInput();
            this._readOutput();
        } else {
            this.emit('icon-changed');
        }
    },
    _readOutput: function() {
        this._output.stream = this._control.get_default_sink();
    },
    _readInput: function() {
        this._input.stream = this._control.get_default_source();
    },
    getIcon: function() {
        return this._output.getIcon();
    }
const Indicator = new Lang.Class({
    Name: 'VolumeIndicator',
    Extends: PanelMenu.SystemIndicator,
    _init: function() {
        this.parent();
        this._primaryIndicator = this._addIndicator();
        this._control = getMixerControl();
        this._volumeMenu = new VolumeMenu(this._control);
        this._volumeMenu.connect('icon-changed', Lang.bind(this, function(menu) {
            let icon = this._volumeMenu.getIcon();
            if (icon != null) {
                this.indicators.show();
                this._primaryIndicator.icon_name = icon;
            } else {
                this.indicators.hide();
            }
        }));
        this.menu.addMenuItem(this._volumeMenu);
        this.indicators.connect('scroll-event', Lang.bind(this, this._onScrollEvent));
    },
    _onScrollEvent: function(actor, event) {
        return this._volumeMenu.scroll(event);
    }
(uuay)components/
oVirt.js
// -*- mode: js; js-indent-level: 4; indent-tabs-mode: nil -*-
const Gio = imports.gi.Gio;
const Lang = imports.lang;
const Signals = imports.signals;
const OVirtCredentialsIface = '<node> \
<interface name="org.ovirt.vdsm.Credentials"> \
<signal name="UserAuthenticated"> \
    <arg type="s" name="token"/> \
</signal> \
</interface> \
</node>';
const OVirtCredentialsInfo = Gio.DBusInterfaceInfo.new_for_xml(OVirtCredentialsIface);
let _oVirtCredentialsManager = null;
function OVirtCredentials() {
    var self = new Gio.DBusProxy({ g_connection: Gio.DBus.system,
                                   g_interface_name: OVirtCredentialsInfo.name,
                                   g_interface_info: OVirtCredentialsInfo,
                                   g_name: 'org.ovirt.vdsm.Credentials',
                                   g_object_path: '/org/ovirt/vdsm/Credentials',
                                   g_flags: (Gio.DBusProxyFlags.DO_NOT_LOAD_PROPERTIES) });
    self.init(null);
    return self;
const OVirtCredentialsManager = new Lang.Class({
    Name: 'OVirtCredentialsManager',
    _init: function() {
        this._token = null;
        this._credentials = new OVirtCredentials();
        this._credentials.connectSignal('UserAuthenticated',
                                        Lang.bind(this, this._onUserAuthenticated));
    },
    _onUserAuthenticated: function(proxy, sender, [token]) {
        this._token = token;
        this.emit('user-authenticated', token);
    },
    hasToken: function() {
        return this._token != null;
    },
    getToken: function() {
        return this._token;
    },
    resetToken: function() {
        this._token = null;
    }
Signals.addSignalMethods(OVirtCredentialsManager.prototype);
function getOVirtCredentialsManager() {
    if (!_oVirtCredentialsManager)
        _oVirtCredentialsManager = new OVirtCredentialsManager();
    return _oVirtCredentialsManager;
(uuay)xdndHandler.js
// -*- mode: js; js-indent-level: 4; indent-tabs-mode: nil -*-
const Clutter = imports.gi.Clutter;
const Lang = imports.lang;
const Main = imports.ui.main;
const Meta = imports.gi.Meta;
const Shell = imports.gi.Shell;
const Signals = imports.signals;
const DND = imports.ui.dnd;
const XdndHandler = new Lang.Class({
    Name: 'XdndHandler',
    _init: function() {
        // Used to display a clone of the cursor window when the
        // window group is hidden (like it happens in the overview)
        this._cursorWindowClone = null;
        // Used as a drag actor in case we don't have a cursor window clone
        this._dummy = new Clutter.Actor({ width: 1, height: 1, opacity: 0 });
        Main.uiGroup.add_actor(this._dummy);
        this._dummy.hide();
        if (!Meta.is_wayland_compositor())
            global.init_xdnd();
        global.connect('xdnd-enter', Lang.bind(this, this._onEnter));
        global.connect('xdnd-position-changed', Lang.bind(this, this._onPositionChanged));
        global.connect('xdnd-leave', Lang.bind(this, this._onLeave));
        this._windowGroupVisibilityHandlerId = 0;
    },
    // Called when the user cancels the drag (i.e release the button)
    _onLeave: function() {
        if (this._windowGroupVisibilityHandlerId != 0) {
            global.window_group.disconnect(this._windowGroupVisibilityHandlerId);
            this._windowGroupVisibilityHandlerId = 0;
        }
        if (this._cursorWindowClone) {
            this._cursorWindowClone.destroy();
            this._cursorWindowClone = null;
        }
        this.emit('drag-end');
    },
    _onEnter: function() {
        this._windowGroupVisibilityHandlerId  =
                global.window_group.connect('notify::visible',
                    Lang.bind(this, this._onWindowGroupVisibilityChanged));
        this.emit('drag-begin', global.get_current_time());
    },
    _onWindowGroupVisibilityChanged: function() {
        if (!global.window_group.visible) {
            if (this._cursorWindowClone)
                return;
            let windows = global.get_window_actors();
            let cursorWindow = windows[windows.length - 1];
            // FIXME: more reliable way?
            if (!cursorWindow.get_meta_window().is_override_redirect())
                return;
            let constraint_position = new Clutter.BindConstraint({ coordinate : Clutter.BindCoordinate.POSITION,
                                                                   source: cursorWindow});
            this._cursorWindowClone = new Clutter.Clone({ source: cursorWindow });
            Main.uiGroup.add_actor(this._cursorWindowClone);
            // Make sure that the clone has the same position as the source
            this._cursorWindowClone.add_constraint(constraint_position);
        } else {
            if (this._cursorWindowClone) {
                this._cursorWindowClone.destroy();
                this._cursorWindowClone = null;
            }
        }
    },
    _onPositionChanged: function(obj, x, y) {
        let pickedActor = global.stage.get_actor_at_pos(Clutter.PickMode.REACTIVE, x, y);
        // Make sure that the cursor window is on top
        if (this._cursorWindowClone)
             this._cursorWindowClone.raise_top();
        let dragEvent = {
            x: x,
            y: y,
            dragActor: this._cursorWindowClone ? this._cursorWindowClone : this._dummy,
            source: this,
            targetActor: pickedActor
        };
        for (let i = 0; i < DND.dragMonitors.length; i++) {
            let motionFunc = DND.dragMonitors[i].dragMotion;
            if (motionFunc) {
                let result = motionFunc(dragEvent);
                if (result != DND.DragMotionResult.CONTINUE)
                    return;
            }
        }
        while (pickedActor) {
                if (pickedActor._delegate && pickedActor._delegate.handleDragOver) {
                    let [r, targX, targY] = pickedActor.transform_stage_point(x, y);
                    let result = pickedActor._delegate.handleDragOver(this,
                                                                      dragEvent.dragActor,
                                                                      targX,
                                                                      targY,
                                                                      global.get_current_time());
                    if (result != DND.DragMotionResult.CONTINUE)
                        return;
                }
                pickedActor = pickedActor.get_parent();
        }
    }
Signals.addSignalMethods(XdndHandler.prototype);
(uuay)keyring.js
// -*- mode: js; js-indent-level: 4; indent-tabs-mode: nil -*-
const Lang = imports.lang;
const Shell = imports.gi.Shell;
const Clutter = imports.gi.Clutter;
const St = imports.gi.St;
const Pango = imports.gi.Pango;
const Gio = imports.gi.Gio;
const GObject = imports.gi.GObject;
const Gcr = imports.gi.Gcr;
const Animation = imports.ui.animation;
const ModalDialog = imports.ui.modalDialog;
const ShellEntry = imports.ui.shellEntry;
const CheckBox = imports.ui.checkBox;
const Tweener = imports.ui.tweener;
const WORK_SPINNER_ICON_SIZE = 16;
const WORK_SPINNER_ANIMATION_DELAY = 1.0;
const WORK_SPINNER_ANIMATION_TIME = 0.3;
const KeyringDialog = new Lang.Class({
    Name: 'KeyringDialog',
    Extends: ModalDialog.ModalDialog,
    _init: function() {
        this.parent({ styleClass: 'prompt-dialog' });
        this.prompt = new Shell.KeyringPrompt();
        this.prompt.connect('show-password', Lang.bind(this, this._onShowPassword));
        this.prompt.connect('show-confirm', Lang.bind(this, this._onShowConfirm));
        this.prompt.connect('prompt-close', Lang.bind(this, this._onHidePrompt));
        let mainContentBox = new St.BoxLayout({ style_class: 'prompt-dialog-main-layout',
                                                vertical: false });
        this.contentLayout.add(mainContentBox);
        let icon = new St.Icon({ icon_name: 'dialog-password-symbolic' });
        mainContentBox.add(icon,
                           { x_fill:  true,
                             y_fill:  false,
                             x_align: St.Align.END,
                             y_align: St.Align.START });
        this._messageBox = new St.BoxLayout({ style_class: 'prompt-dialog-message-layout',
                                              vertical: true });
        mainContentBox.add(this._messageBox,
                           { y_align: St.Align.START, expand: true, x_fill: true, y_fill: true });
        let subject = new St.Label({ style_class: 'prompt-dialog-headline headline' });
        this.prompt.bind_property('message', subject, 'text', GObject.BindingFlags.SYNC_CREATE);
        this._messageBox.add(subject,
                             { x_fill: false,
                               y_fill:  false,
                               x_align: St.Align.START,
                               y_align: St.Align.START });
        let description = new St.Label({ style_class: 'prompt-dialog-description' });
        description.clutter_text.ellipsize = Pango.EllipsizeMode.NONE;
        description.clutter_text.line_wrap = true;
        this.prompt.bind_property('description', description, 'text', GObject.BindingFlags.SYNC_CREATE);
        this._messageBox.add(description,
                            { y_fill:  true,
                              y_align: St.Align.START });
        this._workSpinner = null;
        this._controlTable = null;
        this._cancelButton = this.addButton({ label: '',
                                              action: Lang.bind(this, this._onCancelButton),
                                              key: Clutter.Escape });
        this._continueButton = this.addButton({ label: '',
                                                action: Lang.bind(this, this._onContinueButton),
                                                default: true });
        this.prompt.bind_property('cancel-label', this._cancelButton, 'label', GObject.BindingFlags.SYNC_CREATE);
        this.prompt.bind_property('continue-label', this._continueButton, 'label', GObject.BindingFlags.SYNC_CREATE);
    },
    _setWorking: function(working) {
        if (!this._workSpinner)
            return;
        Tweener.removeTweens(this._workSpinner.actor);
        if (working) {
            this._workSpinner.play();
            Tweener.addTween(this._workSpinner.actor,
                             { opacity: 255,
                               delay: WORK_SPINNER_ANIMATION_DELAY,
                               time: WORK_SPINNER_ANIMATION_TIME,
                               transition: 'linear'
                             });
        } else {
            Tweener.addTween(this._workSpinner.actor,
                             { opacity: 0,
                               time: WORK_SPINNER_ANIMATION_TIME,
                               transition: 'linear',
                               onCompleteScope: this,
                               onComplete: function() {
                                   if (this._workSpinner)
                                       this._workSpinner.stop();
                               }
                             });
        }
    },
    _buildControlTable: function() {
        let layout = new Clutter.GridLayout({ orientation: Clutter.Orientation.VERTICAL });
        let table = new St.Widget({ style_class: 'keyring-dialog-control-table',
                                    layout_manager: layout });
        layout.hookup_style(table);
        let rtl = table.get_text_direction() == Clutter.TextDirection.RTL;
        let row = 0;
        if (this.prompt.password_visible) {
            let label = new St.Label({ style_class: 'prompt-dialog-password-label',
                                       x_align: Clutter.ActorAlign.START,
                                       y_align: Clutter.ActorAlign.CENTER });
            label.set_text(_("Password:"));
            label.clutter_text.ellipsize = Pango.EllipsizeMode.NONE;
            this._passwordEntry = new St.Entry({ style_class: 'prompt-dialog-password-entry',
                                                 text: '',
                                                 can_focus: true,
                                                 x_expand: true });
            this._passwordEntry.clutter_text.set_password_char('\u25cf'); // 
 U+25CF BLACK CIRCLE
            ShellEntry.addContextMenu(this._passwordEntry, { isPassword: true });
            this._passwordEntry.clutter_text.connect('activate', Lang.bind(this, this._onPasswordActivate));
            let spinnerIcon = Gio.File.new_for_uri('resource:///org/gnome/shell/theme/process-working.svg');
            this._workSpinner = new Animation.AnimatedIcon(spinnerIcon, WORK_SPINNER_ICON_SIZE);
            this._workSpinner.actor.opacity = 0;
            if (rtl) {
                layout.attach(this._workSpinner.actor, 0, row, 1, 1);
                layout.attach(this._passwordEntry, 1, row, 1, 1);
                layout.attach(label, 2, row, 1, 1);
            } else {
                layout.attach(label, 0, row, 1, 1);
                layout.attach(this._passwordEntry, 1, row, 1, 1);
                layout.attach(this._workSpinner.actor, 2, row, 1, 1);
            }
            row++;
        } else {
            this._workSpinner = null;
            this._passwordEntry = null;
        }
        if (this.prompt.confirm_visible) {
            var label = new St.Label(({ style_class: 'prompt-dialog-password-label',
                                        x_align: Clutter.ActorAlign.START,
                                        y_align: Clutter.ActorAlign.CENTER }));
            label.set_text(_("Type again:"));
            this._confirmEntry = new St.Entry({ style_class: 'prompt-dialog-password-entry',
                                                text: '',
                                                can_focus: true,
                                                x_expand: true });
            this._confirmEntry.clutter_text.set_password_char('\u25cf'); // 
 U+25CF BLACK CIRCLE
            ShellEntry.addContextMenu(this._confirmEntry, { isPassword: true });
            this._confirmEntry.clutter_text.connect('activate', Lang.bind(this, this._onConfirmActivate));
            if (rtl) {
                layout.attach(this._confirmEntry, 0, row, 1, 1);
                layout.attach(label, 1, row, 1, 1);
            } else {
                layout.attach(label, 0, row, 1, 1);
                layout.attach(this._confirmEntry, 1, row, 1, 1);
            }
            row++;
        } else {
            this._confirmEntry = null;
        }
        this.prompt.set_password_actor(this._passwordEntry ? this._passwordEntry.clutter_text : null);
        this.prompt.set_confirm_actor(this._confirmEntry ? this._confirmEntry.clutter_text : null);
        if (this.prompt.choice_visible) {
            let choice = new CheckBox.CheckBox();
            this.prompt.bind_property('choice-label', choice.getLabelActor(), 'text', GObject.BindingFlags.SYNC_CREATE);
            this.prompt.bind_property('choice-chosen', choice.actor, 'checked', GObject.BindingFlags.SYNC_CREATE | GObject.BindingFlags.BIDIRECTIONAL);
            layout.attach(choice.actor, rtl ? 0 : 1, row, 1, 1);
            row++;
        }
        let warning = new St.Label({ style_class: 'prompt-dialog-error-label',
                                     x_align: Clutter.ActorAlign.START });
        warning.clutter_text.ellipsize = Pango.EllipsizeMode.NONE;
        warning.clutter_text.line_wrap = true;
        layout.attach(warning, rtl ? 0 : 1, row, 1, 1);
        this.prompt.bind_property('warning-visible', warning, 'visible', GObject.BindingFlags.SYNC_CREATE);
        this.prompt.bind_property('warning', warning, 'text', GObject.BindingFlags.SYNC_CREATE);
        if (this._controlTable) {
            this._controlTable.destroy_all_children();
            this._controlTable.destroy();
        }
        this._controlTable = table;
        this._messageBox.add(table, { x_fill: true, y_fill: true });
    },
    _updateSensitivity: function(sensitive) {
        if (this._passwordEntry) {
            this._passwordEntry.reactive = sensitive;
            this._passwordEntry.clutter_text.editable = sensitive;
        }
        if (this._confirmEntry) {
            this._confirmEntry.reactive = sensitive;
            this._confirmEntry.clutter_text.editable = sensitive;
        }
        this._continueButton.can_focus = sensitive;
        this._continueButton.reactive = sensitive;
        this._setWorking(!sensitive);
    },
    _ensureOpen: function() {
        // NOTE: ModalDialog.open() is safe to call if the dialog is
        // already open - it just returns true without side-effects
        if (this.open())
          return true;
        // The above fail if e.g. unable to get input grab
        //
        // In an ideal world this wouldn't happen (because the
        // Shell is in complete control of the session) but that's
        // just not how things work right now.
        log('keyringPrompt: Failed to show modal dialog.' +
            ' Dismissing prompt request');
        this.prompt.cancel()
        return false;
    },
    _onShowPassword: function(prompt) {
        this._buildControlTable();
        this._ensureOpen();
        this._updateSensitivity(true);
        this._passwordEntry.grab_key_focus();
    },
    _onShowConfirm: function(prompt) {
        this._buildControlTable();
        this._ensureOpen();
        this._updateSensitivity(true);
        this._continueButton.grab_key_focus();
    },
    _onHidePrompt: function(prompt) {
        this.close();
    },
    _onPasswordActivate: function() {
        if (this.prompt.confirm_visible)
            this._confirmEntry.grab_key_focus();
        else
            this._onContinueButton();
    },
    _onConfirmActivate: function() {
        this._onContinueButton();
    },
    _onContinueButton: function() {
        this._updateSensitivity(false);
        this.prompt.complete();
    },
    _onCancelButton: function() {
        this.prompt.cancel();
    },
const KeyringDummyDialog = new Lang.Class({
    Name: 'KeyringDummyDialog',
    _init: function() {
        this.prompt = new Shell.KeyringPrompt();
        this.prompt.connect('show-password',
                            Lang.bind(this, this._cancelPrompt));
        this.prompt.connect('show-confirm', Lang.bind(this,
                            this._cancelPrompt));
    },
    _cancelPrompt: function() {
        this.prompt.cancel();
    }
const KeyringPrompter = new Lang.Class({
    Name: 'KeyringPrompter',
    _init: function() {
        this._prompter = new Gcr.SystemPrompter();
        this._prompter.connect('new-prompt', Lang.bind(this,
            function() {
                let dialog = this._enabled ? new KeyringDialog()
                                           : new KeyringDummyDialog();
                this._currentPrompt = dialog.prompt;
                return this._currentPrompt;
            }));
        this._dbusId = null;
        this._registered = false;
        this._enabled = false;
        this._currentPrompt = null;
    },
    enable: function() {
        if (!this._registered) {
            this._prompter.register(Gio.DBus.session);
            this._dbusId = Gio.DBus.session.own_name('org.gnome.keyring.SystemPrompter',
                                                     Gio.BusNameOwnerFlags.ALLOW_REPLACEMENT, null, null);
            this._registered = true;
        }
        this._enabled = true;
    },
    disable: function() {
        this._enabled = false;
        if (this._prompter.prompting)
            this._currentPrompt.cancel();
        this._currentPrompt = null;
    }
const Component = KeyringPrompter;
(uuay)scripting.js
// -*- mode: js; js-indent-level: 4; indent-tabs-mode: nil -*-
const Gio = imports.gi.Gio;
const GLib = imports.gi.GLib;
const Mainloop = imports.mainloop;
const Meta = imports.gi.Meta;
const Shell = imports.gi.Shell;
const Main = imports.ui.main;
const Params = imports.misc.params;
// This module provides functionality for driving the shell user interface
// in an automated fashion. The primary current use case for this is
// automated performance testing (see runPerfScript()), but it could
// be applied to other forms of automation, such as testing for
// correctness as well.
// When scripting an automated test we want to make a series of calls
// in a linear fashion, but we also want to be able to let the main
// loop run so actions can finish. For this reason we write the script
// as a generator function that yields when it want to let the main
// loop run.
//    yield Scripting.sleep(1000);
//    main.overview.show();
//    yield Scripting.waitLeisure();
// While it isn't important to the person writing the script, the actual
// yielded result is a function that the caller uses to provide the
// callback for resuming the script.
 * sleep:
 * @milliseconds: number of milliseconds to wait
 * Used within an automation script to pause the the execution of the
 * current script for the specified amount of time. Use as
 * 'yield Scripting.sleep(500);'
function sleep(milliseconds) {
    let cb;
    let id = Mainloop.timeout_add(milliseconds, function() {
                             if (cb)
                                 cb();
                             return GLib.SOURCE_REMOVE;
                         });
    GLib.Source.set_name_by_id(id, '[gnome-shell] sleep');
    return function(callback) {
        cb = callback;
    };
 * waitLeisure:
 * Used within an automation script to pause the the execution of the
 * current script until the shell is completely idle. Use as
 * 'yield Scripting.waitLeisure();'
function waitLeisure() {
    let cb;
    global.run_at_leisure(function() {
                             if (cb)
                                 cb();
                          });
    return function(callback) {
        cb = callback;
    };
const PerfHelperIface = '<node> \
<interface name="org.gnome.Shell.PerfHelper"> \
<method name="CreateWindow"> \
    <arg type="i" direction="in" /> \
    <arg type="i" direction="in" /> \
    <arg type="b" direction="in" /> \
    <arg type="b" direction="in" /> \
    <arg type="b" direction="in" /> \
</method> \
<method name="WaitWindows" /> \
<method name="DestroyWindows" /> \
</interface> \
</node>';
var PerfHelperProxy = Gio.DBusProxy.makeProxyWrapper(PerfHelperIface);
function PerfHelper() {
    return new PerfHelperProxy(Gio.DBus.session, 'org.gnome.Shell.PerfHelper', '/org/gnome/Shell/PerfHelper');
let _perfHelper = null;
function _getPerfHelper() {
    if (_perfHelper == null)
        _perfHelper = new PerfHelper();
    return _perfHelper;
function _callRemote(obj, method, ...args) {
    let cb;
    let errcb;
    args.push(function(result, excp) {
                  if (excp) {
                      if (errcb)
                          errcb(excp);
                  } else {
                      if (cb)
                          cb();
                  }
             });
    method.apply(obj, args);
    return function(callback, error_callback) {
        cb = callback;
        errcb = error_callback;
    };
 * createTestWindow:
 * @params: options for window creation.
 *   width - width of window, in pixels (default 640)
 *   height - height of window, in pixels (default 480)
 *   alpha - whether the window should have an alpha channel (default false)
 *   maximized - whether the window should be created maximized (default false)
 *   redraws - whether the window should continually redraw itself (default false)
 * @maximized: whethe the window should be created maximized
 * Creates a window using gnome-shell-perf-helper for testing purposes.
 * While this function can be used with yield in an automation
 * script to pause until the D-Bus call to the helper process returns,
 * because of the normal X asynchronous mapping process, to actually wait
 * until the window has been mapped and exposed, use waitTestWindows().
function createTestWindow(width, height, params) {
    params = Params.parse(params, { width: 640,
                                    height: 480,
                                    alpha: false,
                                    maximized: false,
                                    redraws: false });
    let perfHelper = _getPerfHelper();
    return _callRemote(perfHelper, perfHelper.CreateWindowRemote,
                       params.width, params.height,
                       params.alpha, params.maximized, params.redraws);
 * waitTestWindows:
 * Used within an automation script to pause until all windows previously
 * created with createTestWindow have been mapped and exposed.
function waitTestWindows() {
    let perfHelper = _getPerfHelper();
    return _callRemote(perfHelper, perfHelper.WaitWindowsRemote);
 * destroyTestWindows:
 * Destroys all windows previously created with createTestWindow().
 * While this function can be used with yield in an automation
 * script to pause until the D-Bus call to the helper process returns,
 * this doesn't guarantee that Mutter has actually finished the destroy
 * process because of normal X asynchronicity.
function destroyTestWindows() {
    let perfHelper = _getPerfHelper();
    return _callRemote(perfHelper, perfHelper.DestroyWindowsRemote);
 * defineScriptEvent
 * @name: The event will be called script.<name>
 * @description: Short human-readable description of the event
 * Convenience function to define a zero-argument performance event
 * within the 'script' namespace that is reserved for events defined locally
 * within a performance automation script
function defineScriptEvent(name, description) {
    Shell.PerfLog.get_default().define_event("script." + name,
                                             description,
                                             "");
 * scriptEvent
 * @name: Name registered with defineScriptEvent()
 * Convenience function to record a script-local performance event
 * previously defined with defineScriptEvent
function scriptEvent(name) {
    Shell.PerfLog.get_default().event("script." + name);
 * collectStatistics
 * Convenience function to trigger statistics collection
function collectStatistics() {
    Shell.PerfLog.get_default().collect_statistics();
function _step(g, finish, onError) {
    try {
        let waitFunction = g.next();
        waitFunction(function() {
                         _step(g, finish, onError);
                     },
                     function(err) {
                         if (onError)
                             onError(err);
                     });
    } catch (err if err instanceof StopIteration) {
        if (finish)
            finish();
    } catch (err) {
        if (onError)
            onError(err);
    }
function _collect(scriptModule, outputFile) {
    let eventHandlers = {};
    for (let f in scriptModule) {
        let m = /([A-Za-z]+)_([A-Za-z]+)/.exec(f);
        if (m)
            eventHandlers[m[1] + "." + m[2]] = scriptModule[f];
    }
    Shell.PerfLog.get_default().replay(
        function(time, eventName, signature, arg) {
            if (eventName in eventHandlers)
                eventHandlers[eventName](time, arg);
        });
    if ('finish' in scriptModule)
        scriptModule.finish();
    if (outputFile) {
        let f = Gio.file_new_for_path(outputFile);
        let raw = f.replace(null, false,
                            Gio.FileCreateFlags.NONE,
                            null);
        let out = Gio.BufferedOutputStream.new_sized (raw, 4096);
        Shell.write_string_to_stream (out, "{\n");
        Shell.write_string_to_stream(out, '"events":\n');
        Shell.PerfLog.get_default().dump_events(out);
        let monitors = Main.layoutManager.monitors;
        let primary = Main.layoutManager.primaryIndex;
        Shell.write_string_to_stream(out, ',\n"monitors":\n[');
        for (let i = 0; i < monitors.length; i++) {
            let monitor = monitors[i];
            if (i != 0)
                Shell.write_string_to_stream(out, ', ');
            Shell.write_string_to_stream(out, '"%s%dx%d+%d+%d"'.format(i == primary ? "*" : "",
                                                                       monitor.width, monitor.height,
                                                                       monitor.x, monitor.y));
        }
        Shell.write_string_to_stream(out, ' ]');
        Shell.write_string_to_stream(out, ',\n"metrics":\n[ ');
        let first = true;
        for (let name in scriptModule.METRICS) {
            let metric = scriptModule.METRICS[name];
            // Extra checks here because JSON.stringify generates
            // invalid JSON for undefined values
            if (metric.description == null) {
                log("Error: No description found for metric " + name);
                continue;
            }
            if (metric.units == null) {
                log("Error: No units found for metric " + name);
                continue;
            }
            if (metric.value == null) {
                log("Error: No value found for metric " + name);
                continue;
            }
            if (!first)
                Shell.write_string_to_stream(out, ',\n  ');
            first = false;
            Shell.write_string_to_stream(out,
                                         '{ "name": ' + JSON.stringify(name) + ',\n' +
                                         '    "description": ' + JSON.stringify(metric.description) + ',\n' +
                                         '    "units": ' + JSON.stringify(metric.units) + ',\n' +
                                         '    "value": ' + JSON.stringify(metric.value) + ' }');
        }
        Shell.write_string_to_stream(out, ' ]');
        Shell.write_string_to_stream (out, ',\n"log":\n');
        Shell.PerfLog.get_default().dump_log(out);
        Shell.write_string_to_stream (out, '\n}\n');
        out.close(null);
    } else {
        let metrics = [];
        for (let metric in scriptModule.METRICS)
            metrics.push(metric);
        metrics.sort();
        print ('------------------------------------------------------------');
        for (let i = 0; i < metrics.length; i++) {
            let metric = metrics[i];
            print ('# ' + scriptModule.METRICS[metric].description);
            print (metric + ': ' +  scriptModule.METRICS[metric].value + scriptModule.METRICS[metric].units);
        }
        print ('------------------------------------------------------------');
    }
 * runPerfScript
 * @scriptModule: module object with run and finish functions
 *    and event handlers
 * Runs a script for automated collection of performance data. The
 * script is defined as a Javascript module with specified contents.
 * First the run() function within the module will be called as a
 * generator to automate a series of actions. These actions will
 * trigger performance events and the script can also record its
 * own performance events.
 * Then the recorded event log is replayed using handler functions
 * within the module. The handler for the event 'foo.bar' is called
 * foo_bar().
 * Finally if the module has a function called finish(), that will
 * be called.
 * The event handler and finish functions are expected to fill in
 * metrics to an object within the module called METRICS. Each
 * property of this object represents an individual metric. The
 * name of the property is the name of the metric, the value
 * of the property is an object with the following properties:
 *  description: human readable description of the metric
 *  units: a string representing the units of the metric. It has
 *   the form '<unit> <unit> ... / <unit> / <unit> ...'. Certain
 *   unit values are recognized: s, ms, us, B, KiB, MiB. Other
 *   values can appear but are uninterpreted. Examples 's',
 *   '/ s', 'frames', 'frames / s', 'MiB / s / frame'
 *  value: computed value of the metric
 * The resulting metrics will be written to @outputFile as JSON, or,
 * if @outputFile is not provided, logged.
 * After running the script and collecting statistics from the
 * event log, GNOME Shell will exit.
 **/
function runPerfScript(scriptModule, outputFile) {
    Shell.PerfLog.get_default().set_enabled(true);
    let g = scriptModule.run();
    _step(g,
          function() {
              try {
                  _collect(scriptModule, outputFile);
              } catch (err) {
                  log("Script failed: " + err + "\n" + err.stack);
                  Meta.exit(Meta.ExitCode.ERROR);
              }
              Meta.exit(Meta.ExitCode.SUCCESS);
          },
         function(err) {
             log("Script failed: " + err + "\n" + err.stack);
             Meta.exit(Meta.ExitCode.ERROR);
         });
(uuay)background.js
// -*- mode: js; js-indent-level: 4; indent-tabs-mode: nil -*-
// READ THIS FIRST
// Background handling is a maze of objects, both objects in this file, and
// also objects inside Mutter. They all have a role.
// BackgroundManager
//   The only object that other parts of GNOME Shell deal with; a
//   BackgroundManager creates background actors and adds them to
//   the specified container. When the background is changed by the
//   user it will fade out the old actor and fade in the new actor.
//   (This is separate from the fading for an animated background,
//   since using two actors is quite inefficient.)
// MetaBackgroundImage
//   An object represented an image file that will be used for drawing
//   the background. MetaBackgroundImage objects asynchronously load,
//   so they are first created in an unloaded state, then later emit
//   a ::loaded signal when the Cogl object becomes available.
// MetaBackgroundImageCache
//   A cache from filename to MetaBackgroundImage.
// BackgroundSource
//   An object that is created for each GSettings schema (separate
//   settings schemas are used for the lock screen and main background),
//   and holds a reference to shared Background objects.
// MetaBackground
//   Holds the specification of a background - a background color
//   or gradient and one or two images blended together.
// Background
//   JS delegate object that Connects a MetaBackground to the GSettings
//   schema for the background.
// Animation
//   A helper object that handles loading a XML-based animation; it is a
//   wrapper for GnomeDesktop.BGSlideShow
// MetaBackgroundActor
//   An actor that draws the background for a single monitor
// BackgroundCache
//   A cache of Settings schema => BackgroundSource and of a single Animation.
//   Also used to share file monitors.
// A static image, background color or gradient is relatively straightforward. The
// calling code creates a separate BackgroundManager for each monitor. Since they
// are created for the same GSettings schema, they will use the same BackgroundSource
// object, which provides a single Background and correspondingly a single
// MetaBackground object.
// BackgroundManager               BackgroundManager
//        |        \               /        |
//        |         BackgroundSource        |        looked up in BackgroundCache
//        |                |                |
//        |            Background           |
//        |                |                |
//   MetaBackgroundActor   |    MetaBackgroundActor
//         \               |               /
//          `------- MetaBackground ------'
//                         |
//                MetaBackgroundImage            looked up in MetaBackgroundImageCache
// The animated case is tricker because the animation XML file can specify different
// files for different monitor resolutions and aspect ratios. For this reason,
// the BackgroundSource provides different Background share a single Animation object,
// which tracks the animation, but use different MetaBackground objects. In the
// common case, the different MetaBackground objects will be created for the
// same filename and look up the *same* MetaBackgroundImage object, so there is
// little wasted memory:
// BackgroundManager               BackgroundManager
//        |        \               /        |
//        |         BackgroundSource        |        looked up in BackgroundCache
//        |             /      \            |
//        |     Background   Background     |
//        |       |     \      /   |        |
//        |       |    Animation   |        |        looked up in BackgroundCache
// MetaBackgroundA|tor           Me|aBackgroundActor
//         \      |                |       /
//      MetaBackground           MetaBackground
//                 \                 /
//                MetaBackgroundImage            looked up in MetaBackgroundImageCache
//                MetaBackgroundImage
// But the case of different filenames and different background images
// is possible as well:
//                        ....
//      MetaBackground              MetaBackground
//             |                          |
//     MetaBackgroundImage         MetaBackgroundImage
//     MetaBackgroundImage         MetaBackgroundImage
const Clutter = imports.gi.Clutter;
const GDesktopEnums = imports.gi.GDesktopEnums;
const Gio = imports.gi.Gio;
const GLib = imports.gi.GLib;
const GnomeDesktop = imports.gi.GnomeDesktop;
const Lang = imports.lang;
const Meta = imports.gi.Meta;
const Signals = imports.signals;
const Main = imports.ui.main;
const Params = imports.misc.params;
const Tweener = imports.ui.tweener;
const DEFAULT_BACKGROUND_COLOR = Clutter.Color.from_pixel(0x2e3436ff);
const BACKGROUND_SCHEMA = 'org.gnome.desktop.background';
const PRIMARY_COLOR_KEY = 'primary-color';
const SECONDARY_COLOR_KEY = 'secondary-color';
const COLOR_SHADING_TYPE_KEY = 'color-shading-type';
const BACKGROUND_STYLE_KEY = 'picture-options';
const PICTURE_OPACITY_KEY = 'picture-opacity';
const PICTURE_URI_KEY = 'picture-uri';
const FADE_ANIMATION_TIME = 1.0;
// These parameters affect how often we redraw.
// The first is how different (percent crossfaded) the slide show
// has to look before redrawing and the second is the minimum
// frequency (in seconds) we're willing to wake up
const ANIMATION_OPACITY_STEP_INCREMENT = 4.0;
const ANIMATION_MIN_WAKEUP_INTERVAL = 1.0;
let _backgroundCache = null;
function _fileEqual0(file1, file2) {
    if (file1 == file2)
        return true;
    if (!file1 || !file2)
        return false;
    return file1.equal(file2);
const BackgroundCache = new Lang.Class({
    Name: 'BackgroundCache',
    _init: function() {
        this._pendingFileLoads = [];
        this._fileMonitors = {};
        this._backgroundSources = {};
        this._animations = {};
    },
    monitorFile: function(file) {
        let key = file.hash();
        if (this._fileMonitors[key])
            return;
        let monitor = file.monitor(Gio.FileMonitorFlags.NONE, null);
        monitor.connect('changed',
                        Lang.bind(this, function() {
                            this.emit('file-changed', file);
                        }));
        this._fileMonitors[key] = monitor;
    },
    getAnimation: function(params) {
        params = Params.parse(params, { file: null,
                                        settingsSchema: null,
                                        onLoaded: null });
        if (this._animations[params.settingsSchema] && _fileEqual0(this._animationFile, params.file)) {
            if (params.onLoaded) {
                let id = GLib.idle_add(GLib.PRIORITY_DEFAULT, Lang.bind(this, function() {
                    params.onLoaded(this._animations[params.settingsSchema]);
                    return GLib.SOURCE_REMOVE;
                }));
                GLib.Source.set_name_by_id(id, '[gnome-shell] params.onLoaded');
            }
            return;
        }
        let animation = new Animation({ file: params.file });
        animation.load(Lang.bind(this, function() {
                           this._animations[params.settingsSchema] = animation;
                           if (params.onLoaded) {
                               let id = GLib.idle_add(GLib.PRIORITY_DEFAULT, Lang.bind(this, function() {
                                   params.onLoaded(this._animations[params.settingsSchema]);
                                   return GLib.SOURCE_REMOVE;
                               }));
                               GLib.Source.set_name_by_id(id, '[gnome-shell] params.onLoaded');
                           }
                       }));
    },
    getBackgroundSource: function(layoutManager, settingsSchema) {
        // The layoutManager is always the same one; we pass in it since
        // Main.layoutManager may not be set yet
        if (!(settingsSchema in this._backgroundSources)) {
            this._backgroundSources[settingsSchema] = new BackgroundSource(layoutManager, settingsSchema);
            this._backgroundSources[settingsSchema]._useCount = 1;
        } else {
            this._backgroundSources[settingsSchema]._useCount++;
        }
        return this._backgroundSources[settingsSchema];
    },
    releaseBackgroundSource: function(settingsSchema) {
        if (settingsSchema in this._backgroundSources) {
            let source = this._backgroundSources[settingsSchema];
            source._useCount--;
            if (source._useCount == 0) {
                delete this._backgroundSources[settingsSchema];
                source.destroy();
            }
        }
    }
Signals.addSignalMethods(BackgroundCache.prototype);
function getBackgroundCache() {
    if (!_backgroundCache)
        _backgroundCache = new BackgroundCache();
    return _backgroundCache;
const Background = new Lang.Class({
    Name: 'Background',
    _init: function(params) {
        params = Params.parse(params, { monitorIndex: 0,
                                        layoutManager: Main.layoutManager,
                                        settings: null,
                                        file: null,
                                        style: null });
        this.background = new Meta.Background({ meta_screen: global.screen });
        this.background._delegate = this;
        this._settings = params.settings;
        this._file = params.file;
        this._style = params.style;
        this._monitorIndex = params.monitorIndex;
        this._layoutManager = params.layoutManager;
        this._fileWatches = {};
        this._cancellable = new Gio.Cancellable();
        this.isLoaded = false;
        this._clock = new GnomeDesktop.WallClock();
        this._timezoneChangedId = this._clock.connect('notify::timezone',
            Lang.bind(this, function() {
                if (this._animation)
                    this._loadAnimation(this._animation.file);
            }));
        this._settingsChangedSignalId = this._settings.connect('changed', Lang.bind(this, function() {
                                            this.emit('changed');
                                        }));
        this._load();
    },
    destroy: function() {
        this._cancellable.cancel();
        this._removeAnimationTimeout();
        let i;
        let keys = Object.keys(this._fileWatches);
        for (i = 0; i < keys.length; i++) {
            this._cache.disconnect(this._fileWatches[keys[i]]);
        }
        this._fileWatches = null;
        if (this._timezoneChangedId != 0)
            this._clock.disconnect(this._timezoneChangedId);
        this._timezoneChangedId = 0;
        if (this._settingsChangedSignalId != 0)
            this._settings.disconnect(this._settingsChangedSignalId);
        this._settingsChangedSignalId = 0;
    },
    updateResolution: function() {
        if (this._animation) {
            this._removeAnimationTimeout();
            this._updateAnimation();
        }
    },
    _setLoaded: function() {
        if (this.isLoaded)
            return;
        this.isLoaded = true;
        let id = GLib.idle_add(GLib.PRIORITY_DEFAULT, Lang.bind(this, function() {
            this.emit('loaded');
            return GLib.SOURCE_REMOVE;
        }));
        GLib.Source.set_name_by_id(id, '[gnome-shell] this.emit');
    },
    _loadPattern: function() {
        let colorString, res, color, secondColor;
        colorString = this._settings.get_string(PRIMARY_COLOR_KEY);
        [res, color] = Clutter.Color.from_string(colorString);
        colorString = this._settings.get_string(SECONDARY_COLOR_KEY);
        [res, secondColor] = Clutter.Color.from_string(colorString);
        let shadingType = this._settings.get_enum(COLOR_SHADING_TYPE_KEY);
        if (shadingType == GDesktopEnums.BackgroundShading.SOLID)
            this.background.set_color(color);
        else
            this.background.set_gradient(shadingType, color, secondColor);
    },
    _watchFile: function(file) {
        let key = file.hash();
        if (this._fileWatches[key])
            return;
        this._cache.monitorFile(file);
        let signalId = this._cache.connect('file-changed',
                                           Lang.bind(this, function(cache, changedFile) {
                                               if (changedFile.equal(file)) {
                                                   let imageCache = Meta.BackgroundImageCache.get_default();
                                                   imageCache.purge(changedFile);
                                                   this.emit('changed');
                                               }
                                           }));
        this._fileWatches[key] = signalId;
    },
    _removeAnimationTimeout: function() {
        if (this._updateAnimationTimeoutId) {
            GLib.source_remove(this._updateAnimationTimeoutId);
            this._updateAnimationTimeoutId = 0;
        }
    },
    _updateAnimation: function() {
        this._updateAnimationTimeoutId = 0;
        this._animation.update(this._layoutManager.monitors[this._monitorIndex]);
        let files = this._animation.keyFrameFiles;
        let finish = Lang.bind(this, function() {
            this._setLoaded();
            if (files.length > 1) {
                this.background.set_blend(files[0], files[1],
                                          this._animation.transitionProgress,
                                          this._style);
            } else if (files.length > 0) {
                this.background.set_file(files[0], this._style);
            } else {
                this.background.set_file(null, this._style);
            }
            this._queueUpdateAnimation();
        });
        let cache = Meta.BackgroundImageCache.get_default();
        let numPendingImages = files.length;
        let images = [];
        for (let i = 0; i < files.length; i++) {
            this._watchFile(files[i]);
            let image = cache.load(files[i]);
            images.push(image);
            if (image.is_loaded()) {
                numPendingImages--;
                if (numPendingImages == 0)
                    finish();
            } else {
                let id = image.connect('loaded',
                                       Lang.bind(this, function() {
                                           image.disconnect(id);
                                           numPendingImages--;
                                           if (numPendingImages == 0)
                                               finish();
                                       }));
            }
        }
    },
    _queueUpdateAnimation: function() {
        if (this._updateAnimationTimeoutId != 0)
            return;
        if (!this._cancellable || this._cancellable.is_cancelled())
            return;
        if (!this._animation.transitionDuration)
            return;
        let nSteps = 255 / ANIMATION_OPACITY_STEP_INCREMENT;
        let timePerStep = (this._animation.transitionDuration * 1000) / nSteps;
        let interval = Math.max(ANIMATION_MIN_WAKEUP_INTERVAL * 1000,
                                timePerStep);
        if (interval > GLib.MAXUINT32)
            return;
        this._updateAnimationTimeoutId = GLib.timeout_add(GLib.PRIORITY_DEFAULT,
                                                      interval,
                                                      Lang.bind(this, function() {
                                                                    this._updateAnimationTimeoutId = 0;
                                                                    this._updateAnimation();
                                                                    return GLib.SOURCE_REMOVE;
                                                                }));
        GLib.Source.set_name_by_id(this._updateAnimationTimeoutId, '[gnome-shell] this._updateAnimation');
    },
    _loadAnimation: function(file) {
        this._cache.getAnimation({ file: file,
                                   settingsSchema: this._settings.schema_id,
                                   onLoaded: Lang.bind(this, function(animation) {
                                       this._animation = animation;
                                       if (!this._animation || this._cancellable.is_cancelled()) {
                                           this._setLoaded();
                                           return;
                                       }
                                       this._updateAnimation();
                                       this._watchFile(file);
                                   })
                                 });
    },
    _loadImage: function(file) {
        this.background.set_file(file, this._style);
        this._watchFile(file);
        let cache = Meta.BackgroundImageCache.get_default();
        let image = cache.load(file);
        if (image.is_loaded())
            this._setLoaded();
        else {
            let id = image.connect('loaded',
                                   Lang.bind(this, function() {
                                       this._setLoaded();
                                       image.disconnect(id);
                                   }));
        }
    },
    _loadFile: function(file) {
        if (file.get_basename().endsWith('.xml'))
            this._loadAnimation(file);
        else
            this._loadImage(file);
    },
    _load: function () {
        this._cache = getBackgroundCache();
        this._loadPattern();
        if (!this._file) {
            this._setLoaded();
            return;
        }
        this._loadFile(this._file);
    },
Signals.addSignalMethods(Background.prototype);
let _systemBackground;
const SystemBackground = new Lang.Class({
    Name: 'SystemBackground',
    _init: function() {
        let file = Gio.File.new_for_uri('resource:///org/gnome/shell/theme/noise-texture.png');
        if (_systemBackground == null) {
            _systemBackground = new Meta.Background({ meta_screen: global.screen });
            _systemBackground.set_color(DEFAULT_BACKGROUND_COLOR);
            _systemBackground.set_file(file, GDesktopEnums.BackgroundStyle.WALLPAPER);
        }
        this.actor = new Meta.BackgroundActor({ meta_screen: global.screen,
                                                monitor: 0,
                                                background: _systemBackground });
        let cache = Meta.BackgroundImageCache.get_default();
        let image = cache.load(file);
        if (image.is_loaded()) {
            image = null;
            let id = GLib.idle_add(GLib.PRIORITY_DEFAULT, Lang.bind(this, function() {
                this.emit('loaded');
                return GLib.SOURCE_REMOVE;
            }));
            GLib.Source.set_name_by_id(id, '[gnome-shell] SystemBackground.loaded');
        } else {
            let id = image.connect('loaded',
                                   Lang.bind(this, function() {
                                       this.emit('loaded');
                                       image.disconnect(id);
                                       image = null;
                                   }));
        }
    },
Signals.addSignalMethods(SystemBackground.prototype);
const BackgroundSource = new Lang.Class({
    Name: 'BackgroundSource',
    _init: function(layoutManager, settingsSchema) {
        // Allow override the background image setting for performance testing
        this._layoutManager = layoutManager;
        this._overrideImage = GLib.getenv('SHELL_BACKGROUND_IMAGE');
        this._settings = new Gio.Settings({ schema_id: settingsSchema });
        this._backgrounds = [];
        this._monitorsChangedId = global.screen.connect('monitors-changed',
                                                        Lang.bind(this, this._onMonitorsChanged));
    },
    _onMonitorsChanged: function() {
        for (let monitorIndex in this._backgrounds) {
            let background = this._backgrounds[monitorIndex];
            if (monitorIndex < this._layoutManager.monitors.length) {
                background.updateResolution();
            } else {
                background.disconnect(background._changedId);
                background.destroy();
                delete this._backgrounds[monitorIndex];
            }
        }
    },
    getBackground: function(monitorIndex) {
        let file = null;
        let style;
        // We don't watch changes to settings here,
        // instead we rely on Background to watch those
        // and emit 'changed' at the right time
        if (this._overrideImage != null) {
            file = Gio.File.new_for_path(this._overrideImage);
            style = GDesktopEnums.BackgroundStyle.ZOOM; // Hardcode
        } else {
            style = this._settings.get_enum(BACKGROUND_STYLE_KEY);
            if (style != GDesktopEnums.BackgroundStyle.NONE) {
                let uri = this._settings.get_string(PICTURE_URI_KEY);
                file = Gio.File.new_for_commandline_arg(uri);
            }
        }
        // Animated backgrounds are (potentially) per-monitor, since
        // they can have variants that depend on the aspect ratio and
        // size of the monitor; for other backgrounds we can use the
        // same background object for all monitors.
        if (file == null || !file.get_basename().endsWith('.xml'))
            monitorIndex = 0;
        if (!(monitorIndex in this._backgrounds)) {
            let background = new Background({
                monitorIndex: monitorIndex,
                layoutManager: this._layoutManager,
                settings: this._settings,
                file: file,
                style: style
            });
            background._changedId = background.connect('changed', Lang.bind(this, function() {
                background.disconnect(background._changedId);
                background.destroy();
                delete this._backgrounds[monitorIndex];
            }));
            this._backgrounds[monitorIndex] = background;
        }
        return this._backgrounds[monitorIndex];
    },
    destroy: function() {
        global.screen.disconnect(this._monitorsChangedId);
        for (let monitorIndex in this._backgrounds) {
            let background = this._backgrounds[monitorIndex];
            background.disconnect(background._changedId);
            background.destroy();
        }
        this._backgrounds = null;
    }
const Animation = new Lang.Class({
    Name: 'Animation',
    _init: function(params) {
        params = Params.parse(params, { file: null });
        this.file = params.file;
        this.keyFrameFiles = [];
        this.transitionProgress = 0.0;
        this.transitionDuration = 0.0;
        this.loaded = false;
    },
    load: function(callback) {
        this._show = new GnomeDesktop.BGSlideShow({ filename: this.file.get_path() });
        this._show.load_async(null,
                              Lang.bind(this,
                                        function(object, result) {
                                            this.loaded = true;
                                            if (callback)
                                                callback();
                                        }));
    },
    update: function(monitor) {
        this.keyFrameFiles = [];
        if (!this._show)
            return;
        if (this._show.get_num_slides() < 1)
            return;
        let [progress, duration, isFixed, filename1, filename2] = this._show.get_current_slide(monitor.width, monitor.height);
        this.transitionDuration = duration;
        this.transitionProgress = progress;
        if (filename1)
            this.keyFrameFiles.push(Gio.File.new_for_path(filename1));
        if (filename2)
            this.keyFrameFiles.push(Gio.File.new_for_path(filename2));
    },
Signals.addSignalMethods(Animation.prototype);
const BackgroundManager = new Lang.Class({
    Name: 'BackgroundManager',
    _init: function(params) {
        params = Params.parse(params, { container: null,
                                        layoutManager: Main.layoutManager,
                                        monitorIndex: null,
                                        vignette: false,
                                        controlPosition: true,
                                        settingsSchema: BACKGROUND_SCHEMA });
        let cache = getBackgroundCache();
        this._settingsSchema = params.settingsSchema;
        this._backgroundSource = cache.getBackgroundSource(params.layoutManager, params.settingsSchema);
        this._container = params.container;
        this._layoutManager = params.layoutManager;
        this._vignette = params.vignette;
        this._monitorIndex = params.monitorIndex;
        this._controlPosition = params.controlPosition;
        this.backgroundActor = this._createBackgroundActor();
        this._newBackgroundActor = null;
    },
    destroy: function() {
        let cache = getBackgroundCache();
        cache.releaseBackgroundSource(this._settingsSchema);
        this._backgroundSource = null;
        if (this._newBackgroundActor) {
            this._newBackgroundActor.destroy();
            this._newBackgroundActor = null;
        }
        if (this.backgroundActor) {
            this.backgroundActor.destroy();
            this.backgroundActor = null;
        }
    },
    _swapBackgroundActor: function() {
        let oldBackgroundActor = this.backgroundActor;
        this.backgroundActor = this._newBackgroundActor;
        this._newBackgroundActor = null;
        this.emit('changed');
        Tweener.addTween(oldBackgroundActor,
                         { opacity: 0,
                           time: FADE_ANIMATION_TIME,
                           transition: 'easeOutQuad',
                           onComplete: function() {
                               oldBackgroundActor.background.run_dispose();
                               oldBackgroundActor.destroy();
                           }
                         });
    },
    _updateBackgroundActor: function() {
        if (this._newBackgroundActor) {
            /* Skip displaying existing background queued for load */
            this._newBackgroundActor.destroy();
            this._newBackgroundActor = null;
        }
        let newBackgroundActor = this._createBackgroundActor();
        newBackgroundActor.vignette_sharpness = this.backgroundActor.vignette_sharpness;
        newBackgroundActor.brightness = this.backgroundActor.brightness;
        newBackgroundActor.visible = this.backgroundActor.visible;
        this._newBackgroundActor = newBackgroundActor;
        let background = newBackgroundActor.background._delegate;
        if (background.isLoaded) {
            this._swapBackgroundActor();
        } else {
            newBackgroundActor.loadedSignalId = background.connect('loaded',
                Lang.bind(this, function() {
                    background.disconnect(newBackgroundActor.loadedSignalId);
                    newBackgroundActor.loadedSignalId = 0;
                    this._swapBackgroundActor();
                }));
        }
    },
    _createBackgroundActor: function() {
        let background = this._backgroundSource.getBackground(this._monitorIndex);
        let backgroundActor = new Meta.BackgroundActor({ meta_screen: global.screen,
                                                         monitor: this._monitorIndex,
                                                         background: background.background,
                                                         vignette: this._vignette,
                                                         vignette_sharpness: 0.5,
                                                         brightness: 0.5,
                                                       });
        this._container.add_child(backgroundActor);
        let monitor = this._layoutManager.monitors[this._monitorIndex];
        backgroundActor.set_size(monitor.width, monitor.height);
        if (this._controlPosition) {
            backgroundActor.set_position(monitor.x, monitor.y);
            backgroundActor.lower_bottom();
        }
        let changeSignalId = background.connect('changed', Lang.bind(this, function() {
            background.disconnect(changeSignalId);
            changeSignalId = null;
            this._updateBackgroundActor();
        }));
        backgroundActor.connect('destroy', Lang.bind(this, function() {
            if (changeSignalId)
                background.disconnect(changeSignalId);
            if (backgroundActor.loadedSignalId)
                background.disconnect(backgroundActor.loadedSignalId);
        }));
        return backgroundActor;
    },
Signals.addSignalMethods(BackgroundManager.prototype);
(uuay)sessionMode.js
// -*- mode: js; js-indent-level: 4; indent-tabs-mode: nil -*-
const Gio = imports.gi.Gio;
const GLib = imports.gi.GLib;
const Lang = imports.lang;
const Mainloop = imports.mainloop;
const Signals = imports.signals;
const FileUtils = imports.misc.fileUtils;
const Main = imports.ui.main;
const Params = imports.misc.params;
const Config = imports.misc.config;
const DEFAULT_MODE = 'restrictive';
const _modes = {
    'restrictive': {
        parentMode: null,
        stylesheetName: 'gnome-shell.css',
        hasOverview: false,
        showCalendarEvents: false,
        allowSettings: false,
        allowExtensions: false,
        allowScreencast: false,
        enabledExtensions: [],
        hasRunDialog: false,
        hasWorkspaces: false,
        hasWindows: false,
        hasNotifications: false,
        isLocked: false,
        isGreeter: false,
        isPrimary: false,
        unlockDialog: null,
        components: [],
        panel: {
            left: [],
            center: [],
            right: []
        },
        panelStyle: null
    },
    'gdm': {
        hasNotifications: true,
        isGreeter: true,
        isPrimary: true,
        unlockDialog: imports.gdm.loginDialog.LoginDialog,
        components: ['polkitAgent'],
        panel: {
            left: [],
            center: ['dateMenu'],
            right: ['a11yGreeter', 'keyboard', 'aggregateMenu'],
        },
        panelStyle: 'login-screen'
    },
    'lock-screen': {
        isLocked: true,
        isGreeter: undefined,
        unlockDialog: undefined,
        components: ['polkitAgent', 'telepathyClient'],
        panel: {
            left: [],
            center: [],
            right: ['aggregateMenu']
        },
        panelStyle: 'lock-screen'
    },
    'unlock-dialog': {
        isLocked: true,
        unlockDialog: undefined,
        components: ['polkitAgent', 'telepathyClient'],
        panel: {
            left: [],
            center: [],
            right: ['a11y', 'keyboard', 'aggregateMenu']
        },
        panelStyle: 'unlock-screen'
    },
    'user': {
        hasOverview: true,
        showCalendarEvents: true,
        allowSettings: true,
        allowExtensions: true,
        allowScreencast: true,
        hasRunDialog: true,
        hasWorkspaces: true,
        hasWindows: true,
        hasNotifications: true,
        isLocked: false,
        isPrimary: true,
        unlockDialog: imports.ui.unlockDialog.UnlockDialog,
        components: Config.HAVE_NETWORKMANAGER ?
                    ['networkAgent', 'polkitAgent', 'telepathyClient',
                     'keyring', 'autorunManager', 'automountManager'] :
                    ['polkitAgent', 'telepathyClient',
                     'keyring', 'autorunManager', 'automountManager'],
        panel: {
            left: ['activities', 'appMenu'],
            center: ['dateMenu'],
            right: ['a11y', 'keyboard', 'aggregateMenu']
        }
    }
function _loadMode(file, info) {
    let name = info.get_name();
    let suffix = name.indexOf('.json');
    let modeName = suffix == -1 ? name : name.slice(name, suffix);
    if (_modes.hasOwnProperty(modeName))
        return;
    let fileContent, success, tag, newMode;
    try {
        [success, fileContent, tag] = file.load_contents(null);
        newMode = JSON.parse(fileContent);
    } catch(e) {
        return;
    }
    _modes[modeName] = {};
    let propBlacklist = ['unlockDialog'];
    for (let prop in _modes[DEFAULT_MODE]) {
        if (newMode[prop] !== undefined &&
            propBlacklist.indexOf(prop) == -1)
            _modes[modeName][prop] = newMode[prop];
    }
    _modes[modeName]['isPrimary'] = true;
function _loadModes() {
    FileUtils.collectFromDatadirs('modes', false, _loadMode);
function listModes() {
    _loadModes();
    let id = Mainloop.idle_add(function() {
        let names = Object.getOwnPropertyNames(_modes);
        for (let i = 0; i < names.length; i++)
            if (_modes[names[i]].isPrimary)
                print(names[i]);
        Mainloop.quit('listModes');
    });
    GLib.Source.set_name_by_id(id, '[gnome-shell] listModes');
    Mainloop.run('listModes');
const SessionMode = new Lang.Class({
    Name: 'SessionMode',
    _init: function() {
        _loadModes();
        let isPrimary = (_modes[global.session_mode] &&
                         _modes[global.session_mode].isPrimary);
        let mode = isPrimary ? global.session_mode : 'user';
        this._modeStack = [mode];
        this._sync();
    },
    pushMode: function(mode) {
        this._modeStack.push(mode);
        this._sync();
    },
    popMode: function(mode) {
        if (this.currentMode != mode || this._modeStack.length === 1)
            throw new Error("Invalid SessionMode.popMode");
        this._modeStack.pop();
        this._sync();
    },
    switchMode: function(to) {
        if (this.currentMode == to)
            return;
        this._modeStack[this._modeStack.length - 1] = to;
        this._sync();
    },
    get currentMode() {
        return this._modeStack[this._modeStack.length - 1];
    },
    _sync: function() {
        let params = _modes[this.currentMode];
        let defaults;
        if (params.parentMode)
            defaults = Params.parse(_modes[params.parentMode],
                                    _modes[DEFAULT_MODE]);
        else
            defaults = _modes[DEFAULT_MODE];
        params = Params.parse(params, defaults);
        // A simplified version of Lang.copyProperties, handles
        // undefined as a special case for "no change / inherit from previous mode"
        for (let prop in params) {
            if (params[prop] !== undefined)
                this[prop] = params[prop];
        }
        this.emit('updated');
    }
Signals.addSignalMethods(SessionMode.prototype);
(uuay)notificationDaemon.js
// -*- mode: js; js-indent-level: 4; indent-tabs-mode: nil -*-
const Clutter = imports.gi.Clutter;
const GdkPixbuf = imports.gi.GdkPixbuf;
const Gio = imports.gi.Gio;
const GLib = imports.gi.GLib;
const Gtk = imports.gi.Gtk;
const Lang = imports.lang;
const Shell = imports.gi.Shell;
const Mainloop = imports.mainloop;
const St = imports.gi.St;
const Config = imports.misc.config;
const Main = imports.ui.main;
const MessageTray = imports.ui.messageTray;
const Params = imports.misc.params;
const Util = imports.misc.util;
// Should really be defined in Gio.js
const BusIface = '<node> \
<interface name="org.freedesktop.DBus"> \
<method name="GetConnectionUnixProcessID"> \
    <arg type="s" direction="in" /> \
    <arg type="u" direction="out" /> \
</method> \
</interface> \
</node>';
var BusProxy = Gio.DBusProxy.makeProxyWrapper(BusIface);
function Bus() {
    return new BusProxy(Gio.DBus.session, 'org.freedesktop.DBus', '/org/freedesktop/DBus');
const FdoNotificationsIface = '<node> \
<interface name="org.freedesktop.Notifications"> \
<method name="Notify"> \
    <arg type="s" direction="in"/> \
    <arg type="u" direction="in"/> \
    <arg type="s" direction="in"/> \
    <arg type="s" direction="in"/> \
    <arg type="s" direction="in"/> \
    <arg type="as" direction="in"/> \
    <arg type="a{sv}" direction="in"/> \
    <arg type="i" direction="in"/> \
    <arg type="u" direction="out"/> \
</method> \
<method name="CloseNotification"> \
    <arg type="u" direction="in"/> \
</method> \
<method name="GetCapabilities"> \
    <arg type="as" direction="out"/> \
</method> \
<method name="GetServerInformation"> \
    <arg type="s" direction="out"/> \
    <arg type="s" direction="out"/> \
    <arg type="s" direction="out"/> \
    <arg type="s" direction="out"/> \
</method> \
<signal name="NotificationClosed"> \
    <arg type="u"/> \
    <arg type="u"/> \
</signal> \
<signal name="ActionInvoked"> \
    <arg type="u"/> \
    <arg type="s"/> \
</signal> \
</interface> \
</node>';
const NotificationClosedReason = {
    EXPIRED: 1,
    DISMISSED: 2,
    APP_CLOSED: 3,
    UNDEFINED: 4
const Urgency = {
    LOW: 0,
    NORMAL: 1,
    CRITICAL: 2
const rewriteRules = {
    'XChat': [
        { pattern:     /^XChat: Private message from: (\S*) \(.*\)$/,
          replacement: '<$1>' },
        { pattern:     /^XChat: New public message from: (\S*) \((.*)\)$/,
          replacement: '$2 <$1>' },
        { pattern:     /^XChat: Highlighted message from: (\S*) \((.*)\)$/,
          replacement: '$2 <$1>' }
    ]
const FdoNotificationDaemon = new Lang.Class({
    Name: 'FdoNotificationDaemon',
    _init: function() {
        this._dbusImpl = Gio.DBusExportedObject.wrapJSObject(FdoNotificationsIface, this);
        this._dbusImpl.export(Gio.DBus.session, '/org/freedesktop/Notifications');
        this._sources = [];
        this._senderToPid = {};
        this._notifications = {};
        this._busProxy = new Bus();
        this._nextNotificationId = 1;
        Shell.WindowTracker.get_default().connect('notify::focus-app',
            Lang.bind(this, this._onFocusAppChanged));
        Main.overview.connect('hidden',
            Lang.bind(this, this._onFocusAppChanged));
    },
    _imageForNotificationData: function(hints) {
        if (hints['image-data']) {
            let [width, height, rowStride, hasAlpha,
                 bitsPerSample, nChannels, data] = hints['image-data'];
            return Shell.util_create_pixbuf_from_data(data, GdkPixbuf.Colorspace.RGB, hasAlpha,
                                                      bitsPerSample, width, height, rowStride);
        } else if (hints['image-path']) {
            return new Gio.FileIcon({ file: Gio.File.new_for_path(hints['image-path']) });
        }
        return null;
    },
    _fallbackIconForNotificationData: function(hints) {
        let stockIcon;
        switch (hints.urgency) {
            case Urgency.LOW:
            case Urgency.NORMAL:
                stockIcon = 'gtk-dialog-info';
                break;
            case Urgency.CRITICAL:
                stockIcon = 'gtk-dialog-error';
                break;
        }
        return new Gio.ThemedIcon({ name: stockIcon });
    },
    _iconForNotificationData: function(icon) {
        if (icon) {
            if (icon.substr(0, 7) == 'file://')
                return new Gio.FileIcon({ file: Gio.File.new_for_uri(icon) });
            else if (icon[0] == '/')
                return new Gio.FileIcon({ file: Gio.File.new_for_path(icon) });
            else
                return new Gio.ThemedIcon({ name: icon });
        }
        return null;
    },
    _lookupSource: function(title, pid) {
        for (let i = 0; i < this._sources.length; i++) {
            let source = this._sources[i];
            if (source.pid == pid && source.initialTitle == title)
                return source;
        }
        return null;
    },
    // Returns the source associated with ndata.notification if it is set.
    // If the existing or requested source is associated with a tray icon
    // and passed in pid matches a pid of an existing source, the title
    // match is ignored to enable representing a tray icon and notifications
    // from the same application with a single source.
    //
    // If no existing source is found, a new source is created as long as
    // pid is provided.
    //
    // Either a pid or ndata.notification is needed to retrieve or
    // create a source.
    _getSource: function(title, pid, ndata, sender) {
        if (!pid && !(ndata && ndata.notification))
            return null;
        // We use notification's source for the notifications we still have
        // around that are getting replaced because we don't keep sources
        // for transient notifications in this._sources, but we still want
        // the notification associated with them to get replaced correctly.
        if (ndata && ndata.notification)
            return ndata.notification.source;
        let source = this._lookupSource(title, pid);
        if (source) {
            source.setTitle(title);
            return source;
        }
        let source = new FdoNotificationDaemonSource(title, pid, sender, ndata ? ndata.hints['desktop-entry'] : null);
        this._sources.push(source);
        source.connect('destroy', Lang.bind(this, function() {
            let index = this._sources.indexOf(source);
            if (index >= 0)
                this._sources.splice(index, 1);
        }));
        Main.messageTray.add(source);
        return source;
    },
    NotifyAsync: function(params, invocation) {
        let [appName, replacesId, icon, summary, body, actions, hints, timeout] = params;
        let id;
        for (let hint in hints) {
            // unpack the variants
            hints[hint] = hints[hint].deep_unpack();
        }
        hints = Params.parse(hints, { urgency: Urgency.NORMAL }, true);
        // Filter out chat, presence, calls and invitation notifications from
        // Empathy, since we handle that information from telepathyClient.js
        //
        // Note that empathy uses im.received for one to one chats and
        // x-empathy.im.mentioned for multi-user, so we're good here
        if (appName == 'Empathy' && hints['category'] == 'im.received') {
            // Ignore replacesId since we already sent back a
            // NotificationClosed for that id.
            id = this._nextNotificationId++;
            let idle_id = Mainloop.idle_add(Lang.bind(this,
                                            function () {
                                                this._emitNotificationClosed(id, NotificationClosedReason.DISMISSED);
                                                return GLib.SOURCE_REMOVE;
                                            }));
            GLib.Source.set_name_by_id(idle_id, '[gnome-shell] this._emitNotificationClosed');
            return invocation.return_value(GLib.Variant.new('(u)', [id]));
        }
        let rewrites = rewriteRules[appName];
        if (rewrites) {
            for (let i = 0; i < rewrites.length; i++) {
                let rule = rewrites[i];
                if (summary.search(rule.pattern) != -1)
                    summary = summary.replace(rule.pattern, rule.replacement);
            }
        }
        // Be compatible with the various hints for image data and image path
        // 'image-data' and 'image-path' are the latest name of these hints, introduced in 1.2
        if (!hints['image-path'] && hints['image_path'])
            hints['image-path'] = hints['image_path']; // version 1.1 of the spec
        if (!hints['image-data']) {
            if (hints['image_data'])
                hints['image-data'] = hints['image_data']; // version 1.1 of the spec
            else if (hints['icon_data'] && !hints['image-path'])
                // early versions of the spec; 'icon_data' should only be used if 'image-path' is not available
                hints['image-data'] = hints['icon_data'];
        }
        let ndata = { appName: appName,
                      icon: icon,
                      summary: summary,
                      body: body,
                      actions: actions,
                      hints: hints,
                      timeout: timeout };
        if (replacesId != 0 && this._notifications[replacesId]) {
            ndata.id = id = replacesId;
            ndata.notification = this._notifications[replacesId].notification;
        } else {
            replacesId = 0;
            ndata.id = id = this._nextNotificationId++;
        }
        this._notifications[id] = ndata;
        let sender = invocation.get_sender();
        let pid = this._senderToPid[sender];
        let source = this._getSource(appName, pid, ndata, sender, null);
        if (source) {
            this._notifyForSource(source, ndata);
            return invocation.return_value(GLib.Variant.new('(u)', [id]));
        }
        if (replacesId) {
            // There's already a pending call to GetConnectionUnixProcessID,
            // which will see the new notification data when it finishes,
            // so we don't have to do anything.
            return invocation.return_value(GLib.Variant.new('(u)', [id]));;
        }
        this._busProxy.GetConnectionUnixProcessIDRemote(sender, Lang.bind(this, function (result, excp) {
            // The app may have updated or removed the notification
            ndata = this._notifications[id];
            if (!ndata)
                return;
            if (excp) {
                logError(excp, 'Call to GetConnectionUnixProcessID failed');
                return;
            }
            let [pid] = result;
            source = this._getSource(appName, pid, ndata, sender, null);
            this._senderToPid[sender] = pid;
            source.connect('destroy', Lang.bind(this, function() {
                delete this._senderToPid[sender];
            }));
            this._notifyForSource(source, ndata);
        }));
        return invocation.return_value(GLib.Variant.new('(u)', [id]));
    },
    _notifyForSource: function(source, ndata) {
        let [id, icon, summary, body, actions, hints, notification] =
            [ndata.id, ndata.icon, ndata.summary, ndata.body,
             ndata.actions, ndata.hints, ndata.notification];
        if (notification == null) {
            notification = new MessageTray.Notification(source);
            ndata.notification = notification;
            notification.connect('destroy', Lang.bind(this,
                function(n, reason) {
                    delete this._notifications[ndata.id];
                    let notificationClosedReason;
                    switch (reason) {
                        case MessageTray.NotificationDestroyedReason.EXPIRED:
                            notificationClosedReason = NotificationClosedReason.EXPIRED;
                            break;
                        case MessageTray.NotificationDestroyedReason.DISMISSED:
                            notificationClosedReason = NotificationClosedReason.DISMISSED;
                            break;
                        case MessageTray.NotificationDestroyedReason.SOURCE_CLOSED:
                            notificationClosedReason = NotificationClosedReason.APP_CLOSED;
                            break;
                    }
                    this._emitNotificationClosed(ndata.id, notificationClosedReason);
                }));
        }
        let gicon = this._iconForNotificationData(icon, hints);
        let gimage = this._imageForNotificationData(hints);
        // If an icon is not specified, we use 'image-data' or 'image-path' hint for an icon
        // and don't show a large image. There are currently many applications that use
        // notify_notification_set_icon_from_pixbuf() from libnotify, which in turn sets
        // the 'image-data' hint. These applications don't typically pass in 'app_icon'
        // argument to Notify() and actually expect the pixbuf to be shown as an icon.
        // So the logic here does the right thing for this case. If both an icon and either
        // one of 'image-data' or 'image-path' are specified, the icon and takes precedence.
        if (!gicon && gimage)
            gicon = gimage;
        else if (!gicon)
            gicon = this._fallbackIconForNotificationData(hints);
        notification.update(summary, body, { gicon: gicon,
                                             bannerMarkup: true,
                                             clear: true,
                                             soundFile: hints['sound-file'],
                                             soundName: hints['sound-name'] });
        let hasDefaultAction = false;
        if (actions.length) {
            for (let i = 0; i < actions.length - 1; i += 2) {
                let [actionId, label] = [actions[i], actions[i+1]];
                if (actionId == 'default')
                    hasDefaultAction = true;
                else
                    notification.addAction(label, Lang.bind(this, function() {
                        this._emitActionInvoked(ndata.id, actionId);
                    }));
            }
        }
        if (hasDefaultAction) {
            notification.connect('activated', Lang.bind(this, function() {
                this._emitActionInvoked(ndata.id, 'default');
            }));
        } else {
            notification.connect('activated', Lang.bind(this, function() {
                source.open();
            }));
        }
        switch (hints.urgency) {
            case Urgency.LOW:
                notification.setUrgency(MessageTray.Urgency.LOW);
                break;
            case Urgency.NORMAL:
                notification.setUrgency(MessageTray.Urgency.NORMAL);
                break;
            case Urgency.CRITICAL:
                notification.setUrgency(MessageTray.Urgency.CRITICAL);
                break;
        }
        notification.setResident(hints.resident == true);
        // 'transient' is a reserved keyword in JS, so we have to retrieve the value
        // of the 'transient' hint with hints['transient'] rather than hints.transient
        notification.setTransient(hints['transient'] == true);
        let sourceGIcon = source.useNotificationIcon ? gicon : null;
        source.processNotification(notification, sourceGIcon);
    },
    CloseNotification: function(id) {
        let ndata = this._notifications[id];
        if (ndata) {
            if (ndata.notification)
                ndata.notification.destroy(MessageTray.NotificationDestroyedReason.SOURCE_CLOSED);
            delete this._notifications[id];
        }
    },
    GetCapabilities: function() {
        return [
            'actions',
            // 'action-icons',
            'body',
            // 'body-hyperlinks',
            // 'body-images',
            'body-markup',
            // 'icon-multi',
            'icon-static',
            'persistence',
            'sound',
        ];
    },
    GetServerInformation: function() {
        return [
            Config.PACKAGE_NAME,
            'GNOME',
            Config.PACKAGE_VERSION,
            '1.2'
        ];
    },
    _onFocusAppChanged: function() {
        let tracker = Shell.WindowTracker.get_default();
        if (!tracker.focus_app)
            return;
        for (let i = 0; i < this._sources.length; i++) {
            let source = this._sources[i];
            if (source.app == tracker.focus_app) {
                source.destroyNonResidentNotifications();
                return;
            }
        }
    },
    _emitNotificationClosed: function(id, reason) {
        this._dbusImpl.emit_signal('NotificationClosed',
                                   GLib.Variant.new('(uu)', [id, reason]));
    },
    _emitActionInvoked: function(id, action) {
        this._dbusImpl.emit_signal('ActionInvoked',
                                   GLib.Variant.new('(us)', [id, action]));
    }
const FdoNotificationDaemonSource = new Lang.Class({
    Name: 'FdoNotificationDaemonSource',
    Extends: MessageTray.Source,
    _init: function(title, pid, sender, appId) {
        // Need to set the app before chaining up, so
        // methods called from the parent constructor can find it
        this.pid = pid;
        this.app = this._getApp(appId);
        this.parent(title);
        this.initialTitle = title;
        if (this.app)
            this.title = this.app.get_name();
        else
            this.useNotificationIcon = true;
        if (sender)
            this._nameWatcherId = Gio.DBus.session.watch_name(sender,
                                                              Gio.BusNameWatcherFlags.NONE,
                                                              null,
                                                              Lang.bind(this, this._onNameVanished));
        else
            this._nameWatcherId = 0;
    },
    _createPolicy: function() {
        if (this.app && this.app.get_app_info()) {
            let id = this.app.get_id().replace(/\.desktop$/,'');
            return new MessageTray.NotificationApplicationPolicy(id);
        } else {
            return new MessageTray.NotificationGenericPolicy();
        }
    },
    _onNameVanished: function() {
        // Destroy the notification source when its sender is removed from DBus.
        // Only do so if this.app is set to avoid removing "notify-send" sources, senders
        // of which 
re removed from DBus immediately.
        // Sender being removed from DBus would normally result in a tray icon being removed,
        // so allow the code path that handles the tray icon being removed to handle that case.
        if (this.app)
            this.destroy();
    },
    processNotification: function(notification, gicon) {
        if (gicon)
            this._gicon = gicon;
        this.iconUpdated();
        let tracker = Shell.WindowTracker.get_default();
        if (notification.resident && this.app && tracker.focus_app == this.app)
            this.pushNotification(notification);
        else
            this.notify(notification);
    },
    _getApp: function(appId) {
        let app;
        app = Shell.WindowTracker.get_default().get_app_from_pid(this.pid);
        if (app != null)
            return app;
        if (appId) {
            app = Shell.AppSystem.get_default().lookup_app(appId + '.desktop');
            if (app != null)
                return app;
        }
        return null;
    },
    setTitle: function(title) {
        // Do nothing if .app is set, we don't want to override the
        // app name with whatever is provided through libnotify (usually
        // garbage)
        if (this.app)
            return;
        this.parent(title);
    },
    open: function() {
        this.openApp();
        this.destroyNonResidentNotifications();
    },
    openApp: function() {
        if (this.app == null)
            return;
        this.app.activate();
        Main.overview.hide();
        Main.panel.closeCalendar();
    },
    destroy: function() {
        if (this._nameWatcherId) {
            Gio.DBus.session.unwatch_name(this._nameWatcherId);
            this._nameWatcherId = 0;
        }
        this.parent();
    },
    createIcon: function(size) {
        if (this.app) {
            return this.app.create_icon_texture(size);
        } else if (this._gicon) {
            return new St.Icon({ gicon: this._gicon,
                                 icon_size: size });
        } else {
            return null;
        }
    }
const PRIORITY_URGENCY_MAP = {
    low: MessageTray.Urgency.LOW,
    normal: MessageTray.Urgency.NORMAL,
    high: MessageTray.Urgency.HIGH,
    urgent: MessageTray.Urgency.CRITICAL
const GtkNotificationDaemonNotification = new Lang.Class({
    Name: 'GtkNotificationDaemonNotification',
    Extends: MessageTray.Notification,
    _init: function(source, notification) {
        this.parent(source);
        this._serialized = GLib.Variant.new('a{sv}', notification);
        let { "title": title,
              "body": body,
              "icon": gicon,
              "urgent": urgent,
              "priority": priority,
              "buttons": buttons,
              "default-action": defaultAction,
              "default-action-target": defaultActionTarget } = notification;
        if (priority) {
            let urgency = PRIORITY_URGENCY_MAP[priority.unpack()];
            this.setUrgency(urgency != undefined ? urgency : MessageTray.Urgency.NORMAL);
        } else if (urgent) {
            this.setUrgency(urgent.unpack() ? MessageTray.Urgency.CRITICAL
                            : MessageTray.Urgency.NORMAL);
        } else {
            this.setUrgency(MessageTray.Urgency.NORMAL);
        }
        if (buttons) {
            buttons.deep_unpack().forEach(Lang.bind(this, function(button) {
                this.addAction(button.label.unpack(),
                               Lang.bind(this, this._onButtonClicked, button));
            }));
        }
        this._defaultAction = defaultAction ? defaultAction.unpack() : null;
        this._defaultActionTarget = defaultActionTarget;
        this.update(title.unpack(), body ? body.unpack() : null,
                    { gicon: gicon ? Gio.icon_deserialize(gicon) : null });
    },
    _activateAction: function(namespacedActionId, target) {
        if (namespacedActionId) {
            if (namespacedActionId.startsWith('app.')) {
                let actionId = namespacedActionId.slice('app.'.length);
                this.source.activateAction(actionId, target);
            }
        } else {
            this.source.open();
        }
    },
    _onButtonClicked: function(button) {
        let { 'action': action, 'target': actionTarget } = button;
        this._activateAction(action.unpack(), actionTarget);
    },
    activate: function() {
        this._activateAction(this._defaultAction, this._defaultActionTarget);
        this.parent();
    },
    serialize: function() {
        return this._serialized;
    },
const FdoApplicationIface = '<node> \
<interface name="org.freedesktop.Application"> \
<method name="ActivateAction"> \
    <arg type="s" direction="in" /> \
    <arg type="av" direction="in" /> \
    <arg type="a{sv}" direction="in" /> \
</method> \
<method name="Activate"> \
    <arg type="a{sv}" direction="in" /> \
</method> \
</interface> \
</node>';
const FdoApplicationProxy = Gio.DBusProxy.makeProxyWrapper(FdoApplicationIface);
function objectPathFromAppId(appId) {
    return '/' + appId.replace(/\./g, '/');
function getPlatformData() {
    let startupId = GLib.Variant.new('s', '_TIME' + global.get_current_time());
    return { "desktop-startup-id": startupId };
function InvalidAppError() {}
const GtkNotificationDaemonAppSource = new Lang.Class({
    Name: 'GtkNotificationDaemonAppSource',
    Extends: MessageTray.Source,
    _init: function(appId) {
        this._appId = appId;
        this._objectPath = objectPathFromAppId(appId);
        this._app = Shell.AppSystem.get_default().lookup_app(appId + '.desktop');
        if (!this._app)
            throw new InvalidAppError();
        this._notifications = {};
        this.parent(this._app.get_name());
    },
    createIcon: function(size) {
        return this._app.create_icon_texture(size);
    },
    _createPolicy: function() {
        return new MessageTray.NotificationApplicationPolicy(this._appId);
    },
    _createApp: function() {
        return new FdoApplicationProxy(Gio.DBus.session, this._appId, this._objectPath);
    },
    activateAction: function(actionId, target) {
        let app = this._createApp();
        app.ActivateActionRemote(actionId, target ? [target] : [], getPlatformData());
        Main.overview.hide();
        Main.panel.closeCalendar();
    },
    open: function() {
        let app = this._createApp();
        app.ActivateRemote(getPlatformData());
        Main.overview.hide();
        Main.panel.closeCalendar();
    },
    addNotification: function(notificationId, notificationParams, showBanner) {
        if (this._notifications[notificationId])
            this._notifications[notificationId].destroy();
        let notification = new GtkNotificationDaemonNotification(this, notificationParams);
        notification.connect('destroy', Lang.bind(this, function() {
            delete this._notifications[notificationId];
        }));
        this._notifications[notificationId] = notification;
        if (showBanner)
            this.notify(notification);
        else
            this.pushNotification(notification);
    },
    removeNotification: function(notificationId) {
        if (this._notifications[notificationId])
            this._notifications[notificationId].destroy(MessageTray.NotificationDestroyedReason.SOURCE_CLOSED);
    },
    serialize: function() {
        let notifications = [];
        for (let notificationId in this._notifications) {
            let notification = this._notifications[notificationId];
            notifications.push([notificationId, notification.serialize()]);
        }
        return [this._appId, notifications];
    },
const GtkNotificationsIface = '<node> \
<interface name="org.gtk.Notifications"> \
<method name="AddNotification"> \
    <arg type="s" direction="in" /> \
    <arg type="s" direction="in" /> \
    <arg type="a{sv}" direction="in" /> \
</method> \
<method name="RemoveNotification"> \
    <arg type="s" direction="in" /> \
    <arg type="s" direction="in" /> \
</method> \
</interface> \
</node>';
const GtkNotificationDaemon = new Lang.Class({
    Name: 'GtkNotificationDaemon',
    _init: function() {
        this._sources = {};
        this._loadNotifications();
        this._dbusImpl = Gio.DBusExportedObject.wrapJSObject(GtkNotificationsIface, this);
        this._dbusImpl.export(Gio.DBus.session, '/org/gtk/Notifications');
        Gio.DBus.session.own_name('org.gtk.Notifications', Gio.BusNameOwnerFlags.REPLACE, null, null);
    },
    _ensureAppSource: function(appId) {
        if (this._sources[appId])
            return this._sources[appId];
        let source = new GtkNotificationDaemonAppSource(appId);
        source.connect('destroy', Lang.bind(this, function() {
            delete this._sources[appId];
            this._saveNotifications();
        }));
        source.connect('count-updated', Lang.bind(this, this._saveNotifications));
        Main.messageTray.add(source);
        this._sources[appId] = source;
        return source;
    },
    _loadNotifications: function() {
        this._isLoading = true;
        let value = global.get_persistent_state('a(sa(sv))', 'notifications');
        if (value) {
            let sources = value.deep_unpack();
            sources.forEach(Lang.bind(this, function([appId, notifications]) {
                if (notifications.length == 0)
                    return;
                let source;
                try {
                    source = this._ensureAppSource(appId);
                } catch(e if e instanceof InvalidAppError) {
                    return;
                }
                notifications.forEach(function([notificationId, notification]) {
                    source.addNotification(notificationId, notification.deep_unpack(), false);
                });
            }));
        }
        this._isLoading = false;
    },
    _saveNotifications: function() {
        if (this._isLoading)
            return;
        let sources = [];
        for (let appId in this._sources) {
            let source = this._sources[appId];
            sources.push(source.serialize());
        }
        global.set_persistent_state('notifications', new GLib.Variant('a(sa(sv))', sources));
    },
    AddNotificationAsync: function(params, invocation) {
        let [appId, notificationId, notification] = params;
        let source;
        try {
            source = this._ensureAppSource(appId);
        } catch(e if e instanceof InvalidAppError) {
            invocation.return_dbus_error('org.gtk.Notifications.InvalidApp', 'The app by ID "%s" could not be found'.format(appId));
            return;
        }
        source.addNotification(notificationId, notification, true);
        invocation.return_value(null);
    },
    RemoveNotificationAsync: function(params, invocation) {
        let [appId, notificationId] = params;
        let source = this._sources[appId];
        if (source)
            source.removeNotification(notificationId);
        invocation.return_value(null);
    },
const NotificationDaemon = new Lang.Class({
    Name: 'NotificationDaemon',
    _init: function() {
        this._fdoNotificationDaemon = new FdoNotificationDaemon();
        this._gtkNotificationDaemon = new GtkNotificationDaemon();
    },
(uuay)ui/
backgroundMenu.js
// -*- mode: js; js-indent-level: 4; indent-tabs-mode: nil -*-
const Clutter = imports.gi.Clutter;
const Lang = imports.lang;
const St = imports.gi.St;
const Shell = imports.gi.Shell;
const BoxPointer = imports.ui.boxpointer;
const Main = imports.ui.main;
const PopupMenu = imports.ui.popupMenu;
const BackgroundMenu = new Lang.Class({
    Name: 'BackgroundMenu',
    Extends: PopupMenu.PopupMenu,
    _init: function(layoutManager) {
        this.parent(layoutManager.dummyCursor, 0, St.Side.TOP);
        this.addSettingsAction(_("Change Background
"), 'gnome-background-panel.desktop');
        this.addMenuItem(new PopupMenu.PopupSeparatorMenuItem());
        this.addSettingsAction(_("Display Settings"), 'gnome-display-panel.desktop');
        this.addSettingsAction(_("Settings"), 'gnome-control-center.desktop');
        this.actor.add_style_class_name('background-menu');
        layoutManager.uiGroup.add_actor(this.actor);
        this.actor.hide();
    }
function addBackgroundMenu(actor, layoutManager) {
    actor.reactive = true;
    actor._backgroundMenu = new BackgroundMenu(layoutManager);
    actor._backgroundManager = new PopupMenu.PopupMenuManager({ actor: actor });
    actor._backgroundManager.addMenu(actor._backgroundMenu);
    function openMenu(x, y) {
        Main.layoutManager.setDummyCursorGeometry(x, y, 0, 0);
        actor._backgroundMenu.open(BoxPointer.PopupAnimation.NONE);
    }
    let clickAction = new Clutter.ClickAction();
    clickAction.connect('long-press', function(action, actor, state) {
        if (state == Clutter.LongPressState.QUERY)
            return ((action.get_button() == 0 ||
                     action.get_button() == 1) &&
                    !actor._backgroundMenu.isOpen);
        if (state == Clutter.LongPressState.ACTIVATE) {
            let [x, y] = action.get_coords();
            openMenu(x, y);
            actor._backgroundManager.ignoreRelease();
        }
        return true;
    });
    clickAction.connect('clicked', function(action) {
        if (action.get_button() == 3) {
            let [x, y] = action.get_coords();
            openMenu(x, y);
        }
    });
    actor.add_action(clickAction);
    let grabOpBeginId = global.display.connect('grab-op-begin', function () {
        clickAction.release();
    });
    actor.connect('destroy', function() {
        actor._backgroundMenu.destroy();
        actor._backgroundMenu = null;
        actor._backgroundManager = null;
        global.display.disconnect(grabOpBeginId);
    });
(uuay)endSessionDialog.js
// -*- mode: js; js-indent-level: 4; indent-tabs-mode: nil -*-
 * Copyright 2010-2016 Red Hat, Inc
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2, or (at your option)
 * any later version.
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, see <http://www.gnu.org/licenses/>.
const Lang = imports.lang;
const Mainloop = imports.mainloop;
const AccountsService = imports.gi.AccountsService;
const Clutter = imports.gi.Clutter;
const Gio = imports.gi.Gio;
const GLib = imports.gi.GLib;
const Gtk = imports.gi.Gtk;
const Pango = imports.gi.Pango;
const Polkit = imports.gi.Polkit;
const St = imports.gi.St;
const Shell = imports.gi.Shell;
const CheckBox = imports.ui.checkBox;
const GnomeSession = imports.misc.gnomeSession;
const LoginManager = imports.misc.loginManager;
const ModalDialog = imports.ui.modalDialog;
const Tweener = imports.ui.tweener;
const UserWidget = imports.ui.userWidget;
let _endSessionDialog = null;
const _ITEM_ICON_SIZE = 48;
const _DIALOG_ICON_SIZE = 48;
const GSM_SESSION_MANAGER_LOGOUT_FORCE = 2;
const EndSessionDialogIface = '<node> \
<interface name="org.gnome.SessionManager.EndSessionDialog"> \
<method name="Open"> \
    <arg type="u" direction="in" /> \
    <arg type="u" direction="in" /> \
    <arg type="u" direction="in" /> \
    <arg type="ao" direction="in" /> \
</method> \
<method name="Close" /> \
<signal name="ConfirmedLogout" /> \
<signal name="ConfirmedReboot" /> \
<signal name="ConfirmedShutdown" /> \
<signal name="Canceled" /> \
<signal name="Closed" /> \
</interface> \
</node>';
const logoutDialogContent = {
    subjectWithUser: C_("title", "Log Out %s"),
    subject: C_("title", "Log Out"),
    descriptionWithUser: function(user, seconds) {
        return ngettext("%s will be logged out automatically in %d second.",
                        "%s will be logged out automatically in %d seconds.",
                        seconds).format(user, seconds);
    },
    description: function(seconds) {
        return ngettext("You will be logged out automatically in %d second.",
                        "You will be logged out automatically in %d seconds.",
                        seconds).format(seconds);
    },
    showBatteryWarning: false,
    confirmButtons: [{ signal: 'ConfirmedLogout',
                       label:  C_("button", "Log Out") }],
    iconStyleClass: 'end-session-dialog-logout-icon',
    showOtherSessions: false,
const shutdownDialogContent = {
    subject: C_("title", "Power Off"),
    subjectWithUpdates: C_("title", "Install Updates & Power Off"),
    description: function(seconds) {
        return ngettext("The system will power off automatically in %d second.",
                        "The system will power off automatically in %d seconds.",
                        seconds).format(seconds);
    },
    checkBoxText: C_("checkbox", "Install pending software updates"),
    showBatteryWarning: true,
    confirmButtons: [{ signal: 'ConfirmedReboot',
                       label:  C_("button", "Restart") },
                     { signal: 'ConfirmedShutdown',
                       label:  C_("button", "Power Off") }],
    iconName: 'system-shutdown-symbolic',
    iconStyleClass: 'end-session-dialog-shutdown-icon',
    showOtherSessions: true,
const restartDialogContent = {
    subject: C_("title", "Restart"),
    description: function(seconds) {
        return ngettext("The system will restart automatically in %d second.",
                        "The system will restart automatically in %d seconds.",
                        seconds).format(seconds);
    },
    showBatteryWarning: false,
    confirmButtons: [{ signal: 'ConfirmedReboot',
                       label:  C_("button", "Restart") }],
    iconName: 'view-refresh-symbolic',
    iconStyleClass: 'end-session-dialog-shutdown-icon',
    showOtherSessions: true,
const restartUpdateDialogContent = {
    subject: C_("title", "Restart & Install Updates"),
    description: function(seconds) {
        return ngettext("The system will automatically restart and install updates in %d second.",
                        "The system will automatically restart and install updates in %d seconds.",
                        seconds).format(seconds);
    },
    showBatteryWarning: true,
    confirmButtons: [{ signal: 'ConfirmedReboot',
                       label:  C_("button", "Restart &amp; Install") }],
    unusedFutureButtonForTranslation: C_("button", "Install &amp; Power Off"),
    unusedFutureCheckBoxForTranslation: C_("checkbox", "Power off after updates are installed"),
    iconName: 'view-refresh-symbolic',
    iconStyleClass: 'end-session-dialog-shutdown-icon',
    showOtherSessions: true,
const restartUpgradeDialogContent = {
    subject: C_("title", "Restart & Install Upgrade"),
    upgradeDescription: function(distroName, distroVersion) {
        /* Translators: This is the text displayed for system upgrades in the
           shut down dialog. First %s gets replaced with the distro name and
           second %s with the distro version to upgrade to */
        return _("%s %s will be installed after restart. Upgrade installation can take a long time: ensure that you have backed up and that the computer is plugged in.").format(distroName, distroVersion);
    },
    disableTimer: true,
    showBatteryWarning: false,
    confirmButtons: [{ signal: 'ConfirmedReboot',
                       label:  C_("button", "Restart &amp; Install") }],
    iconName: 'view-refresh-symbolic',
    iconStyleClass: 'end-session-dialog-shutdown-icon',
    showOtherSessions: true,
const DialogType = {
  LOGOUT: 0 /* GSM_SHELL_END_SESSION_DIALOG_TYPE_LOGOUT */,
  SHUTDOWN: 1 /* GSM_SHELL_END_SESSION_DIALOG_TYPE_SHUTDOWN */,
  RESTART: 2 /* GSM_SHELL_END_SESSION_DIALOG_TYPE_RESTART */,
  UPDATE_RESTART: 3,
  UPGRADE_RESTART: 4
const DialogContent = {
    0 /* DialogType.LOGOUT */: logoutDialogContent,
    1 /* DialogType.SHUTDOWN */: shutdownDialogContent,
    2 /* DialogType.RESTART */: restartDialogContent,
    3 /* DialogType.UPDATE_RESTART */: restartUpdateDialogContent,
    4 /* DialogType.UPGRADE_RESTART */: restartUpgradeDialogContent
const MAX_USERS_IN_SESSION_DIALOG = 5;
const LogindSessionIface = '<node> \
<interface name="org.freedesktop.login1.Session"> \
    <property name="Id" type="s" access="read"/> \
    <property name="Remote" type="b" access="read"/> \
    <property name="Class" type="s" access="read"/> \
    <property name="Type" type="s" access="read"/> \
    <property name="State" type="s" access="read"/> \
</interface> \
</node>';
const LogindSession = Gio.DBusProxy.makeProxyWrapper(LogindSessionIface);
const PkOfflineIface = '<node> \
<interface name="org.freedesktop.PackageKit.Offline"> \
    <property name="UpdatePrepared" type="b" access="read"/> \
    <property name="UpdateTriggered" type="b" access="read"/> \
    <property name="UpgradePrepared" type="b" access="read"/> \
    <property name="UpgradeTriggered" type="b" access="read"/> \
    <property name="PreparedUpgrade" type="a{sv}" access="read"/> \
    <method name="Trigger"> \
        <arg type="s" name="action" direction="in"/> \
    </method> \
    <method name="Cancel"/> \
</interface> \
</node>';
const PkOfflineProxy = Gio.DBusProxy.makeProxyWrapper(PkOfflineIface);
const UPowerIface = '<node> \
<interface name="org.freedesktop.UPower"> \
    <property name="OnBattery" type="b" access="read"/> \
</interface> \
</node>';
const UPowerProxy = Gio.DBusProxy.makeProxyWrapper(UPowerIface);
function findAppFromInhibitor(inhibitor) {
    let desktopFile;
    try {
        [desktopFile] = inhibitor.GetAppIdSync();
    } catch(e) {
        // XXX -- sometimes JIT inhibitors generated by gnome-session
        // get removed too soon. Don't fail in this case.
        log('gnome-session gave us a dead inhibitor: %s'.format(inhibitor.get_object_path()));
        return null;
    }
    if (!GLib.str_has_suffix(desktopFile, '.desktop'))
        desktopFile += '.desktop';
    return Shell.AppSystem.get_default().lookup_heuristic_basename(desktopFile);
// The logout timer only shows updates every 10 seconds
// until the last 10 seconds, then it shows updates every
// second.  This function takes a given time and returns
// what we should show to the user for that time.
function _roundSecondsToInterval(totalSeconds, secondsLeft, interval) {
    let time;
    time = Math.ceil(secondsLeft);
    // Final count down is in decrements of 1
    if (time <= interval)
        return time;
    // Round up higher than last displayable time interval
    time += interval - 1;
    // Then round down to that time interval
    if (time > totalSeconds)
        time = Math.ceil(totalSeconds);
    else
        time -= time % interval;
    return time;
function _setLabelText(label, text) {
    if (text) {
        label.set_text(text);
        label.show();
    } else {
        label.set_text('');
        label.hide();
    }
function _setCheckBoxLabel(checkBox, text) {
    let label = checkBox.getLabelActor();
    if (text) {
        label.set_text(text);
        checkBox.actor.show();
    } else {
        label.set_text('');
        checkBox.actor.hide();
    }
function init() {
    // This always returns the same singleton object
    // By instantiating it initially, we register the
    // bus object, etc.
    _endSessionDialog = new EndSessionDialog();
const EndSessionDialog = new Lang.Class({
    Name: 'EndSessionDialog',
    Extends: ModalDialog.ModalDialog,
    _init: function() {
        this.parent({ styleClass: 'end-session-dialog',
                      destroyOnClose: false });
        this._loginManager = LoginManager.getLoginManager();
        this._userManager = AccountsService.UserManager.get_default();
        this._user = this._userManager.get_user(GLib.get_user_name());
        this._pkOfflineProxy = new PkOfflineProxy(Gio.DBus.system,
                                                  'org.freedesktop.PackageKit',
                                                  '/org/freedesktop/PackageKit',
                                                  Lang.bind(this, function(proxy, error) {
                                                      if (error)
                                                          log(error.message);
                                                  }));
        this._powerProxy = new UPowerProxy(Gio.DBus.system,
                                           'org.freedesktop.UPower',
                                           '/org/freedesktop/UPower',
                                           Lang.bind(this, function(proxy, error) {
                                               if (error) {
                                                   log(error.message);
                                                   return;
                                               }
                                               this._powerProxy.connect('g-properties-changed',
                                                                        Lang.bind(this, this._sync));
                                               this._sync();
                                           }));
        this._secondsLeft = 0;
        this._totalSecondsToStayOpen = 0;
        this._applications = [];
        this._sessions = [];
        this.connect('destroy',
                     Lang.bind(this, this._onDestroy));
        this.connect('opened',
                     Lang.bind(this, this._onOpened));
        this._userLoadedId = this._user.connect('notify::is_loaded', Lang.bind(this, this._sync));
        this._userChangedId = this._user.connect('changed', Lang.bind(this, this._sync));
        let mainContentLayout = new St.BoxLayout({ vertical: false });
        this.contentLayout.add(mainContentLayout,
                               { x_fill: true,
                                 y_fill: false });
        this._iconBin = new St.Bin();
        mainContentLayout.add(this._iconBin,
                              { x_fill:  true,
                                y_fill:  false,
                                x_align: St.Align.END,
                                y_align: St.Align.START });
        let messageLayout = new St.BoxLayout({ vertical: true,
                                               style_class: 'end-session-dialog-layout' });
        mainContentLayout.add(messageLayout,
                              { y_align: St.Align.START });
        this._subjectLabel = new St.Label({ style_class: 'end-session-dialog-subject' });
        messageLayout.add(this._subjectLabel,
                          { x_fill: false,
                            y_fill:  false,
                            x_align: St.Align.START,
                            y_align: St.Align.START });
        this._descriptionLabel = new St.Label({ style_class: 'end-session-dialog-description' });
        this._descriptionLabel.clutter_text.ellipsize = Pango.EllipsizeMode.NONE;
        this._descriptionLabel.clutter_text.line_wrap = true;
        messageLayout.add(this._descriptionLabel,
                          { y_fill:  true,
                            y_align: St.Align.START });
        this._checkBox = new CheckBox.CheckBox();
        this._checkBox.actor.connect('clicked', Lang.bind(this, this._sync));
        messageLayout.add(this._checkBox.actor);
        this._batteryWarning = new St.Label({ style_class: 'end-session-dialog-warning',
                                              text: _("Running on battery power: please plug in before installing updates.") });
        this._batteryWarning.clutter_text.ellipsize = Pango.EllipsizeMode.NONE;
        this._batteryWarning.clutter_text.line_wrap = true;
        messageLayout.add(this._batteryWarning);
        this._scrollView = new St.ScrollView({ style_class: 'end-session-dialog-list' });
        this._scrollView.set_policy(Gtk.PolicyType.NEVER, Gtk.PolicyType.AUTOMATIC);
        this.contentLayout.add(this._scrollView,
                               { x_fill: true,
                                 y_fill: true });
        this._scrollView.hide();
        this._inhibitorSection = new St.BoxLayout({ vertical: true,
                                                    style_class: 'end-session-dialog-inhibitor-layout' });
        this._scrollView.add_actor(this._inhibitorSection);
        this._applicationHeader = new St.Label({ style_class: 'end-session-dialog-list-header',
                                                 text: _("Some applications are busy or have unsaved work.") });
        this._applicationList = new St.BoxLayout({ style_class: 'end-session-dialog-app-list',
                                                   vertical: true });
        this._inhibitorSection.add_actor(this._applicationHeader);
        this._inhibitorSection.add_actor(this._applicationList);
        this._sessionHeader = new St.Label({ style_class: 'end-session-dialog-list-header',
                                             text: _("Other users are logged in.") });
        this._sessionList = new St.BoxLayout({ style_class: 'end-session-dialog-session-list',
                                               vertical: true });
        this._inhibitorSection.add_actor(this._sessionHeader);
        this._inhibitorSection.add_actor(this._sessionList);
        try {
            this._updatesPermission = Polkit.Permission.new_sync("org.freedesktop.packagekit.trigger-offline-update", null, null);
        } catch(e) {
            log('No permission to trigger offline updates: %s'.format(e.toString()));
        }
        this._dbusImpl = Gio.DBusExportedObject.wrapJSObject(EndSessionDialogIface, this);
        this._dbusImpl.export(Gio.DBus.session, '/org/gnome/SessionManager/EndSessionDialog');
    },
    _onDestroy: function() {
        this._user.disconnect(this._userLoadedId);
        this._user.disconnect(this._userChangedId);
    },
    _sync: function() {
        let open = (this.state == ModalDialog.State.OPENING || this.state == ModalDialog.State.OPENED);
        if (!open)
            return;
        let dialogContent = DialogContent[this._type];
        let subject = dialogContent.subject;
        // Use different title when we are installing updates
        if (dialogContent.subjectWithUpdates && this._checkBox.actor.checked)
            subject = dialogContent.subjectWithUpdates;
        if (dialogContent.showBatteryWarning) {
            // Warn when running on battery power
            if (this._powerProxy.OnBattery && this._checkBox.actor.checked)
                this._batteryWarning.opacity = 255;
            else
                this._batteryWarning.opacity = 0;
        }
        let description;
        let displayTime = _roundSecondsToInterval(this._totalSecondsToStayOpen,
                                                  this._secondsLeft,
                                                  10);
        if (this._user.is_loaded) {
            let realName = this._user.get_real_name();
            if (realName != null) {
                if (dialogContent.subjectWithUser)
                    subject = dialogContent.subjectWithUser.format(realName);
                if (dialogContent.descriptionWithUser)
                    description = dialogContent.descriptionWithUser(realName, displayTime);
            }
        }
        // Use a different description when we are installing a system upgrade
        if (dialogContent.upgradeDescription) {
            let name = this._pkOfflineProxy.PreparedUpgrade['name'].deep_unpack();
            let version = this._pkOfflineProxy.PreparedUpgrade['version'].deep_unpack();
            if (name != null && version != null)
                description = dialogContent.upgradeDescription(name, version);
        }
        // Fall back to regular description
        if (!description)
            description = dialogContent.description(displayTime);
        _setLabelText(this._descriptionLabel, description);
        _setLabelText(this._subjectLabel, subject);
        let dialogContent = DialogContent[this._type];
        if (dialogContent.iconName) {
            this._iconBin.child = new St.Icon({ icon_name: dialogContent.iconName,
                                                icon_size: _DIALOG_ICON_SIZE,
                                                style_class: dialogContent.iconStyleClass });
        } else {
            let avatarWidget = new UserWidget.Avatar(this._user,
                                                     { iconSize: _DIALOG_ICON_SIZE,
                                                       styleClass: dialogContent.iconStyleClass });
            this._iconBin.child = avatarWidget.actor;
            avatarWidget.update();
        }
        let hasApplications = this._applications.length > 0;
        let hasSessions = this._sessions.length > 0;
        this._scrollView.visible = hasApplications || hasSessions;
        this._applicationHeader.visible = hasApplications;
        this._sessionHeader.visible = hasSessions;
    },
    _updateButtons: function() {
        let dialogContent = DialogContent[this._type];
        let buttons = [{ action: Lang.bind(this, this.cancel),
                         label:  _("Cancel"),
                         key:    Clutter.Escape }];
        for (let i = 0; i < dialogContent.confirmButtons.length; i++) {
            let signal = dialogContent.confirmButtons[i].signal;
            let label = dialogContent.confirmButtons[i].label;
            buttons.push({ action: Lang.bind(this, function() {
                                       this.close(true);
                                       let signalId = this.connect('closed',
                                                                   Lang.bind(this, function() {
                                                                       this.disconnect(signalId);
                                                                       this._confirm(signal);
                                                                   }));
                                   }),
                           label: label });
        }
        this.setButtons(buttons);
    },
    close: function(skipSignal) {
        this.parent();
        if (!skipSignal)
            this._dbusImpl.emit_signal('Closed', null);
    },
    cancel: function() {
        this._stopTimer();
        this._dbusImpl.emit_signal('Canceled', null);
        this.close();
    },
    _confirm: function(signal) {
        let callback = Lang.bind(this, function() {
            this._fadeOutDialog();
            this._stopTimer();
            this._dbusImpl.emit_signal(signal, null);
        });
        // Offline update not available; just emit the signal
        if (!this._checkBox.actor.visible) {
            callback();
            return;
        }
        // Trigger the offline update as requested
        if (this._checkBox.actor.checked) {
            switch (signal) {
                case "ConfirmedReboot":
                    this._triggerOfflineUpdateReboot(callback);
                    break;
                case "ConfirmedShutdown":
                    // To actually trigger the offline update, we need to
                    // reboot to do the upgrade. When the upgrade is complete,
                    // the computer will shut down automatically.
                    signal = "ConfirmedReboot";
                    this._triggerOfflineUpdateShutdown(callback);
                    break;
                default:
                    callback();
                    break;
            }
        } else {
            this._triggerOfflineUpdateCancel(callback);
        }
    },
    _onOpened: function() {
        this._sync();
    },
    _triggerOfflineUpdateReboot: function(callback) {
        this._pkOfflineProxy.TriggerRemote('reboot',
                                           function (result, error) {
            if (error)
                log(error.message);
            callback();
        });
    },
    _triggerOfflineUpdateShutdown: function(callback) {
        this._pkOfflineProxy.TriggerRemote('power-off',
                                           function (result, error) {
            if (error)
                log(error.message);
            callback();
        });
    },
    _triggerOfflineUpdateCancel: function(callback) {
        this._pkOfflineProxy.CancelRemote(function (result, error) {
            if (error)
                log(error.message);
            callback();
        });
    },
    _startTimer: function() {
        let startTime = GLib.get_monotonic_time();
        this._secondsLeft = this._totalSecondsToStayOpen;
        this._timerId = Mainloop.timeout_add_seconds(1, Lang.bind(this,
            function() {
                let currentTime = GLib.get_monotonic_time();
                let secondsElapsed = ((currentTime - startTime) / 1000000);
                this._secondsLeft = this._totalSecondsToStayOpen - secondsElapsed;
                if (this._secondsLeft > 0) {
                    this._sync();
                    return GLib.SOURCE_CONTINUE;
                }
                let dialogContent = DialogContent[this._type];
                let button = dialogContent.confirmButtons[dialogContent.confirmButtons.length - 1];
                this._confirm(button.signal);
                this._timerId = 0;
                return GLib.SOURCE_REMOVE;
            }));
        GLib.Source.set_name_by_id(this._timerId, '[gnome-shell] this._confirm');
    },
    _stopTimer: function() {
        if (this._timerId > 0) {
            Mainloop.source_remove(this._timerId);
            this._timerId = 0;
        }
        this._secondsLeft = 0;
    },
    _constructListItemForApp: function(inhibitor, app) {
        let actor = new St.BoxLayout({ style_class: 'end-session-dialog-app-list-item',
                                       can_focus: true });
        actor.add(app.create_icon_texture(_ITEM_ICON_SIZE));
        let textLayout = new St.BoxLayout({ vertical: true,
                                            y_expand: true,
                                            y_align: Clutter.ActorAlign.CENTER });
        actor.add(textLayout);
        let nameLabel = new St.Label({ text: app.get_name(),
                                       style_class: 'end-session-dialog-app-list-item-name' });
        textLayout.add(nameLabel);
        actor.label_actor = nameLabel;
        let [reason] = inhibitor.GetReasonSync();
        if (reason) {
            let reasonLabel = new St.Label({ text: reason,
                                             style_class: 'end-session-dialog-app-list-item-description' });
            textLayout.add(reasonLabel);
        }
        return actor;
    },
    _onInhibitorLoaded: function(inhibitor) {
        if (this._applications.indexOf(inhibitor) < 0) {
            // Stale inhibitor
            return;
        }
        let app = findAppFromInhibitor(inhibitor);
        if (app) {
            let actor = this._constructListItemForApp(inhibitor, app);
            this._applicationList.add(actor);
        } else {
            // inhibiting app is a service, not an application
            this._applications.splice(this._applications.indexOf(inhibitor), 1);
        }
        this._sync();
    },
    _constructListItemForSession: function(session) {
        let avatar = new UserWidget.Avatar(session.user, { iconSize: _ITEM_ICON_SIZE });
        avatar.update();
        let userName = session.user.get_real_name() ? session.user.get_real_name() : session.username;
        let userLabelText;
        if (session.remote)
            /* Translators: Remote here refers to a remote session, like a ssh login */
            userLabelText = _("%s (remote)").format(userName);
        else if (session.type == "tty")
            /* Translators: Console here refers to a tty like a VT console */
            userLabelText = _("%s (console)").format(userName);
        else
            userLabelText = userName;
        let actor = new St.BoxLayout({ style_class: 'end-session-dialog-session-list-item',
                                       can_focus: true });
        actor.add(avatar.actor);
        let nameLabel = new St.Label({ text: userLabelText,
                                       style_class: 'end-session-dialog-session-list-item-name',
                                       y_expand: true,
                                       y_align: Clutter.ActorAlign.CENTER });
        actor.add(nameLabel);
        actor.label_actor = nameLabel;
        return actor;
    },
    _loadSessions: function() {
        this._loginManager.listSessions(Lang.bind(this, function(result) {
            let n = 0;
            for (let i = 0; i < result.length; i++) {
                let[id, uid, userName, seat, sessionPath] = result[i];
                let proxy = new LogindSession(Gio.DBus.system, 'org.freedesktop.login1', sessionPath);
                if (proxy.Class != 'user')
                    continue;
                if (proxy.State == 'closing')
                    continue;
                if (proxy.Id == GLib.getenv('XDG_SESSION_ID'))
                    continue;
                let session = { user: this._userManager.get_user(userName),
                                username: userName,
                                type: proxy.Type,
                                remote: proxy.Remote };
                this._sessions.push(session);
                let actor = this._constructListItemForSession(session);
                this._sessionList.add(actor);
                // limit the number of entries
                n++;
                if (n == MAX_USERS_IN_SESSION_DIALOG)
                    break;
            }
            this._sync();
        }));
    },
    OpenAsync: function(parameters, invocation) {
        let [type, timestamp, totalSecondsToStayOpen, inhibitorObjectPaths] = parameters;
        this._totalSecondsToStayOpen = totalSecondsToStayOpen;
        this._type = type;
        if (this._type == DialogType.RESTART) {
            if (this._pkOfflineProxy.UpdateTriggered)
                this._type = DialogType.UPDATE_RESTART;
            else if (this._pkOfflineProxy.UpgradeTriggered)
                this._type = DialogType.UPGRADE_RESTART;
        }
        this._applications = [];
        this._applicationList.destroy_all_children();
        this._sessions = [];
        this._sessionList.destroy_all_children();
        if (!(this._type in DialogContent)) {
            invocation.return_dbus_error('org.gnome.Shell.ModalDialog.TypeError',
                                         "Unknown dialog type requested");
            return;
        }
        let dialogContent = DialogContent[this._type];
        for (let i = 0; i < inhibitorObjectPaths.length; i++) {
            let inhibitor = new GnomeSession.Inhibitor(inhibitorObjectPaths[i], Lang.bind(this, function(proxy, error) {
                this._onInhibitorLoaded(proxy);
            }));
            this._applications.push(inhibitor);
        }
        if (dialogContent.showOtherSessions)
            this._loadSessions();
        let updateTriggered = this._pkOfflineProxy.UpdateTriggered;
        let updatePrepared = this._pkOfflineProxy.UpdatePrepared;
        let updatesAllowed = this._updatesPermission && this._updatesPermission.allowed;
        _setCheckBoxLabel(this._checkBox, dialogContent.checkBoxText);
        this._checkBox.actor.visible = (dialogContent.checkBoxText && updatePrepared && updatesAllowed);
        this._checkBox.actor.checked = (updatePrepared && updateTriggered);
        // We show the warning either together with the checkbox, or when
        // updates have already been triggered, but the user doesn't have
        // enough permissions to cancel them.
        this._batteryWarning.visible = (dialogContent.showBatteryWarning &&
                                        (this._checkBox.actor.visible || updatePrepared && updateTriggered && !updatesAllowed));
        this._updateButtons();
        if (!this.open(timestamp)) {
            invocation.return_dbus_error('org.gnome.Shell.ModalDialog.GrabError',
                                         "Cannot grab pointer and keyboard");
            return;
        }
        if (!dialogContent.disableTimer)
            this._startTimer();
        this._sync();
        let signalId = this.connect('opened',
                                    Lang.bind(this, function() {
                                        invocation.return_value(null);
                                        this.disconnect(signalId);
                                    }));
    },
    Close: function(parameters, invocation) {
        this.close();
    }
(uuay)checkBox.js
const Clutter = imports.gi.Clutter;
const Pango = imports.gi.Pango;
const St = imports.gi.St;
const Lang = imports.lang;
const CheckBox = new Lang.Class({
    Name: 'CheckBox',
    _init: function(label) {
        let container = new St.BoxLayout();
        this.actor = new St.Button({ style_class: 'check-box',
                                     child: container,
                                     button_mask: St.ButtonMask.ONE,
                                     toggle_mode: true,
                                     can_focus: true,
                                     x_fill: true,
                                     y_fill: true });
        this._box = new St.Bin();
        this._box.set_y_align(Clutter.ActorAlign.START);
        container.add_actor(this._box);
        this._label = new St.Label();
        this._label.clutter_text.set_line_wrap(true);
        this._label.clutter_text.set_ellipsize(Pango.EllipsizeMode.NONE);
        container.add_actor(this._label);
        if (label)
            this.setLabel(label);
    },
    setLabel: function(label) {
        this._label.set_text(label);
    },
    getLabelActor: function() {
        return this._label;
    }
(uuay)brightness.js
// -*- mode: js; js-indent-level: 4; indent-tabs-mode: nil -*-
const Lang = imports.lang;
const Gio = imports.gi.Gio;
const St = imports.gi.St;
const PanelMenu = imports.ui.panelMenu;
const PopupMenu = imports.ui.popupMenu;
const Slider = imports.ui.slider;
const BUS_NAME = 'org.gnome.SettingsDaemon.Power';
const OBJECT_PATH = '/org/gnome/SettingsDaemon/Power';
const BrightnessInterface = '<node> \
<interface name="org.gnome.SettingsDaemon.Power.Screen"> \
<property name="Brightness" type="i" access="readwrite"/> \
</interface> \
</node>';
const BrightnessProxy = Gio.DBusProxy.makeProxyWrapper(BrightnessInterface);
const Indicator = new Lang.Class({
    Name: 'BrightnessIndicator',
    Extends: PanelMenu.SystemIndicator,
    _init: function() {
        this.parent('display-brightness-symbolic');
        this._proxy = new BrightnessProxy(Gio.DBus.session, BUS_NAME, OBJECT_PATH,
                                          Lang.bind(this, function(proxy, error) {
                                              if (error) {
                                                  log(error.message);
                                                  return;
                                              }
                                              this._proxy.connect('g-properties-changed', Lang.bind(this, this._sync));
                                              this._sync();
                                          }));
        this._item = new PopupMenu.PopupBaseMenuItem({ activate: false });
        this.menu.addMenuItem(this._item);
        this._slider = new Slider.Slider(0);
        this._slider.connect('value-changed', Lang.bind(this, this._sliderChanged));
        this._slider.actor.accessible_name = _("Brightness");
        let icon = new St.Icon({ icon_name: 'display-brightness-symbolic',
                                 style_class: 'popup-menu-icon' });
        this._item.actor.add(icon);
        this._item.actor.add(this._slider.actor, { expand: true });
        this._item.actor.connect('button-press-event', Lang.bind(this, function(actor, event) {
            return this._slider.startDragging(event);
        }));
        this._item.actor.connect('key-press-event', Lang.bind(this, function(actor, event) {
            return this._slider.onKeyPressEvent(actor, event);
        }));
    },
    _sliderChanged: function(slider, value) {
        let percent = value * 100;
        this._proxy.Brightness = percent;
    },
    _sync: function() {
        let visible = this._proxy.Brightness >= 0;
        this._item.actor.visible = visible;
        if (visible)
            this._slider.setValue(this._proxy.Brightness / 100.0);
    },
(uuay)config.js
// -*- mode: js; js-indent-level: 4; indent-tabs-mode: nil -*-
/* The name of this package (not localized) */
const PACKAGE_NAME = 'gnome-shell';
/* The version of this package */
const PACKAGE_VERSION = '3.22.1';
/* 1 if gnome-bluetooth is available, 0 otherwise */
const HAVE_BLUETOOTH = 1;
/* 1 if networkmanager is available, 0 otherwise */
const HAVE_NETWORKMANAGER = 1;
/* gettext package */
const GETTEXT_PACKAGE = 'gnome-shell';
/* locale dir */
const LOCALEDIR = '/usr/share/locale';
/* other standard directories */
const LIBEXECDIR = '/usr/libexec';
const SYSCONFDIR = '/etc';
(uuay)fingerprint.js
// -*- mode: js; js-indent-level: 4; indent-tabs-mode: nil -*-
const Gio = imports.gi.Gio;
const Lang = imports.lang;
const Shell = imports.gi.Shell;
const Signals = imports.signals;
const FprintManagerIface = '<node> \
<interface name="net.reactivated.Fprint.Manager"> \
<method name="GetDefaultDevice"> \
    <arg type="o" direction="out" /> \
</method> \
</interface> \
</node>';
const FprintManagerInfo = Gio.DBusInterfaceInfo.new_for_xml(FprintManagerIface);
function FprintManager() {
    var self = new Gio.DBusProxy({ g_connection: Gio.DBus.system,
                                   g_interface_name: FprintManagerInfo.name,
                                   g_interface_info: FprintManagerInfo,
                                   g_name: 'net.reactivated.Fprint',
                                   g_object_path: '/net/reactivated/Fprint/Manager',
                                   g_flags: (Gio.DBusProxyFlags.DO_NOT_LOAD_PROPERTIES) });
    self.init(null);
    return self;
(uuay)altTab.js
// -*- mode: js; js-indent-level: 4; indent-tabs-mode: nil -*-
const Clutter = imports.gi.Clutter;
const Gio = imports.gi.Gio;
const GLib = imports.gi.GLib;
const Lang = imports.lang;
const Mainloop = imports.mainloop;
const Meta = imports.gi.Meta;
const Shell = imports.gi.Shell;
const St = imports.gi.St;
const Atk = imports.gi.Atk;
const Main = imports.ui.main;
const SwitcherPopup = imports.ui.switcherPopup;
const Tweener = imports.ui.tweener;
const APP_ICON_HOVER_TIMEOUT = 200; // milliseconds
const THUMBNAIL_DEFAULT_SIZE = 256;
const THUMBNAIL_POPUP_TIME = 500; // milliseconds
const THUMBNAIL_FADE_TIME = 0.1; // seconds
const WINDOW_PREVIEW_SIZE = 128;
const APP_ICON_SIZE = 96;
const APP_ICON_SIZE_SMALL = 48;
const baseIconSizes = [96, 64, 48, 32, 22];
const AppIconMode = {
    THUMBNAIL_ONLY: 1,
    APP_ICON_ONLY: 2,
    BOTH: 3,
function _createWindowClone(window, size) {
    let windowTexture = window.get_texture();
    let [width, height] = windowTexture.get_size();
    let scale = Math.min(1.0, size / width, size / height);
    return new Clutter.Clone({ source: windowTexture,
                               width: width * scale,
                               height: height * scale,
                               x_align: Clutter.ActorAlign.CENTER,
                               y_align: Clutter.ActorAlign.CENTER,
                               // usual hack for the usual bug in ClutterBinLayout...
                               x_expand: true,
                               y_expand: true });
function getWindows(workspace) {
    // We ignore skip-taskbar windows in switchers, but if they are attached
    // to their parent, their position in the MRU list may be more appropriate
    // than the parent; so start with the complete list ...
    let windows = global.display.get_tab_list(Meta.TabList.NORMAL_ALL,
                                              workspace);
    // ... map windows to their parent where appropriate ...
    return windows.map(w => {
        return w.is_attached_dialog() ? w.get_transient_for() : w;
    // ... and filter out skip-taskbar windows and duplicates
    }).filter((w, i, a) => !w.skip_taskbar && a.indexOf(w) == i);
const AppSwitcherPopup = new Lang.Class({
    Name: 'AppSwitcherPopup',
    Extends: SwitcherPopup.SwitcherPopup,
    _init : function() {
        this.parent();
        this._thumbnails = null;
        this._thumbnailTimeoutId = 0;
        this._currentWindow = -1;
        this.thumbnailsVisible = false;
        let apps = Shell.AppSystem.get_default().get_running ();
        if (apps.length == 0)
            return;
        this._switcherList = new AppSwitcher(apps, this);
        this._items = this._switcherList.icons;
    },
    _allocate: function (actor, box, flags) {
        this.parent(actor, box, flags);
        // Allocate the thumbnails
        // We try to avoid overflowing the screen so we base the resulting size on
        // those calculations
        if (this._thumbnails) {
            let childBox = this._switcherList.actor.get_allocation_box();
            let primary = Main.layoutManager.primaryMonitor;
            let leftPadding = this.actor.get_theme_node().get_padding(St.Side.LEFT);
            let rightPadding = this.actor.get_theme_node().get_padding(St.Side.RIGHT);
            let bottomPadding = this.actor.get_theme_node().get_padding(St.Side.BOTTOM);
            let hPadding = leftPadding + rightPadding;
            let icon = this._items[this._selectedIndex].actor;
            let [posX, posY] = icon.get_transformed_position();
            let thumbnailCenter = posX + icon.width / 2;
            let [childMinWidth, childNaturalWidth] = this._thumbnails.actor.get_preferred_width(-1);
            childBox.x1 = Math.max(primary.x + leftPadding, Math.floor(thumbnailCenter - childNaturalWidth / 2));
            if (childBox.x1 + childNaturalWidth > primary.x + primary.width - hPadding) {
                let offset = childBox.x1 + childNaturalWidth - primary.width + hPadding;
                childBox.x1 = Math.max(primary.x + leftPadding, childBox.x1 - offset - hPadding);
            }
            let spacing = this.actor.get_theme_node().get_length('spacing');
            childBox.x2 = childBox.x1 +  childNaturalWidth;
            if (childBox.x2 > primary.x + primary.width - rightPadding)
                childBox.x2 = primary.x + primary.width - rightPadding;
            childBox.y1 = this._switcherList.actor.allocation.y2 + spacing;
            this._thumbnails.addClones(primary.y + primary.height - bottomPadding - childBox.y1);
            let [childMinHeight, childNaturalHeight] = this._thumbnails.actor.get_preferred_height(-1);
            childBox.y2 = childBox.y1 + childNaturalHeight;
            this._thumbnails.actor.allocate(childBox, flags);
        }
    },
    _initialSelection: function(backward, binding) {
        if (binding == 'switch-group') {
            if (backward) {
                this._select(0, this._items[0].cachedWindows.length - 1);
            } else {
                if (this._items[0].cachedWindows.length > 1)
                    this._select(0, 1);
                else
                    this._select(0, 0);
            }
        } else if (binding == 'switch-group-backward') {
            this._select(0, this._items[0].cachedWindows.length - 1);
        } else if (binding == 'switch-applications-backward') {
            this._select(this._items.length - 1);
        } else if (this._items.length == 1) {
            this._select(0);
        } else if (backward) {
            this._select(this._items.length - 1);
        } else {
            this._select(1);
        }
    },
    _nextWindow : function() {
        // We actually want the second window if we're in the unset state
        if (this._currentWindow == -1)
            this._currentWindow = 0;
        return SwitcherPopup.mod(this._currentWindow + 1,
                                 this._items[this._selectedIndex].cachedWindows.length);
    },
    _previousWindow : function() {
        // Also assume second window here
        if (this._currentWindow == -1)
            this._currentWindow = 1;
        return SwitcherPopup.mod(this._currentWindow - 1,
                                 this._items[this._selectedIndex].cachedWindows.length);
    },
    _keyPressHandler: function(keysym, action) {
        if (action == Meta.KeyBindingAction.SWITCH_GROUP) {
            this._select(this._selectedIndex, this._nextWindow());
        } else if (action == Meta.KeyBindingAction.SWITCH_GROUP_BACKWARD) {
            this._select(this._selectedIndex, this._previousWindow());
        } else if (action == Meta.KeyBindingAction.SWITCH_APPLICATIONS) {
            this._select(this._next());
        } else if (action == Meta.KeyBindingAction.SWITCH_APPLICATIONS_BACKWARD) {
            this._select(this._previous());
        } else if (this._thumbnailsFocused) {
            if (keysym == Clutter.Left)
                this._select(this._selectedIndex, this._previousWindow());
            else if (keysym == Clutter.Right)
                this._select(this._selectedIndex, this._nextWindow());
            else if (keysym == Clutter.Up)
                this._select(this._selectedIndex, null, true);
            else
                return Clutter.EVENT_PROPAGATE;
        } else {
            if (keysym == Clutter.Left)
                this._select(this._previous());
            else if (keysym == Clutter.Right)
                this._select(this._next());
            else if (keysym == Clutter.Down)
                this._select(this._selectedIndex, 0);
            else
                return Clutter.EVENT_PROPAGATE;
        }
        return Clutter.EVENT_STOP;
    },
    _scrollHandler: function(direction) {
        if (direction == Clutter.ScrollDirection.UP) {
            if (this._thumbnailsFocused) {
                if (this._currentWindow == 0 || this._currentWindow == -1)
                    this._select(this._previous());
                else
                    this._select(this._selectedIndex, this._previousWindow());
            } else {
                let nwindows = this._items[this._selectedIndex].cachedWindows.length;
                if (nwindows > 1)
                    this._select(this._selectedIndex, nwindows - 1);
                else
                    this._select(this._previous());
            }
        } else if (direction == Clutter.ScrollDirection.DOWN) {
            if (this._thumbnailsFocused) {
                if (this._currentWindow == this._items[this._selectedIndex].cachedWindows.length - 1)
                    this._select(this._next());
                else
                    this._select(this._selectedIndex, this._nextWindow());
            } else {
                let nwindows = this._items[this._selectedIndex].cachedWindows.length;
                if (nwindows > 1)
                    this._select(this._selectedIndex, 0);
                else
                    this._select(this._next());
            }
        }
    },
    _itemActivatedHandler: function(n) {
        // If the user clicks on the selected app, activate the
        // selected window; otherwise (eg, they click on an app while
        // !mouseActive) activate the clicked-on app.
        if (n == this._selectedIndex && this._currentWindow >= 0)
            this._select(n, this._currentWindow);
        else
            this._select(n);
    },
    _itemEnteredHandler: function(n) {
        this._select(n);
    },
    _windowActivated : function(thumbnailList, n) {
        let appIcon = this._items[this._selectedIndex];
        Main.activateWindow(appIcon.cachedWindows[n]);
        this.destroy();
    },
    _windowEntered : function(thumbnailList, n) {
        if (!this.mouseActive)
            return;
        this._select(this._selectedIndex, n);
    },
    _finish : function(timestamp) {
        let appIcon = this._items[this._selectedIndex];
        if (this._currentWindow < 0)
            appIcon.app.activate_window(appIcon.cachedWindows[0], timestamp);
        else
            Main.activateWindow(appIcon.cachedWindows[this._currentWindow], timestamp);
        this.parent();
    },
    _onDestroy : function() {
        this.parent();
        if (this._thumbnails)
            this._destroyThumbnails();
        if (this._thumbnailTimeoutId != 0)
            Mainloop.source_remove(this._thumbnailTimeoutId);
    },
    /**
     * _select:
     * @app: index of the app to select
     * @window: (optional) index of which of @app's windows to select
     * @forceAppFocus: optional flag, see below
     *
     * Selects the indicated @app, and optional @window, and sets
     * this._thumbnailsFocused appropriately to indicate whether the
     * arrow keys should act on the app list or the thumbnail list.
     *
     * If @app is specified and @window is unspecified or %null, then
     * the app is highlighted (ie, given a light background), and the
     * current thumbnail list, if any, is destroyed. If @app has
     * multiple windows, and @forceAppFocus is not %true, then a
     * timeout is started to open a thumbnail list.
     *
     * If @app and @window are specified (and @forceAppFocus is not),
     * then @app will be outlined, a thumbnail list will be created
     * and focused (if it hasn't been already), and the @window'th
     * window in it will be highlighted.
     *
     * If @app and @window are specified and @forceAppFocus is %true,
     * then @app will be highlighted, and @window outlined, and the
     * app list will have the keyboard focus.
     */
    _select : function(app, window, forceAppFocus) {
        if (app != this._selectedIndex || window == null) {
            if (this._thumbnails)
                this._destroyThumbnails();
        }
        if (this._thumbnailTimeoutId != 0) {
            Mainloop.source_remove(this._thumbnailTimeoutId);
            this._thumbnailTimeoutId = 0;
        }
        this._thumbnailsFocused = (window != null) && !forceAppFocus;
        this._selectedIndex = app;
        this._currentWindow = window ? window : -1;
        this._switcherList.highlight(app, this._thumbnailsFocused);
        if (window != null) {
            if (!this._thumbnails)
                this._createThumbnails();
            this._currentWindow = window;
            this._thumbnails.highlight(window, forceAppFocus);
        } else if (this._items[this._selectedIndex].cachedWindows.length > 1 &&
                   !forceAppFocus) {
            this._thumbnailTimeoutId = Mainloop.timeout_add (
                THUMBNAIL_POPUP_TIME,
                Lang.bind(this, this._timeoutPopupThumbnails));
            GLib.Source.set_name_by_id(this._thumbnailTimeoutId, '[gnome-shell] this._timeoutPopupThumbnails');
        }
    },
    _timeoutPopupThumbnails: function() {
        if (!this._thumbnails)
            this._createThumbnails();
        this._thumbnailTimeoutId = 0;
        this._thumbnailsFocused = false;
        return GLib.SOURCE_REMOVE;
    },
    _destroyThumbnails : function() {
        let thumbnailsActor = this._thumbnails.actor;
        Tweener.addTween(thumbnailsActor,
                         { opacity: 0,
                           time: THUMBNAIL_FADE_TIME,
                           transition: 'easeOutQuad',
                           onComplete: Lang.bind(this, function() {
                                                            thumbnailsActor.destroy();
                                                            this.thumbnailsVisible = false;
                                                        })
                         });
        this._thumbnails = null;
        this._switcherList._items[this._selectedIndex].remove_accessible_state (Atk.StateType.EXPANDED);
    },
    _createThumbnails : function() {
        this._thumbnails = new ThumbnailList (this._items[this._selectedIndex].cachedWindows);
        this._thumbnails.connect('item-activated', Lang.bind(this, this._windowActivated));
        this._thumbnails.connect('item-entered', Lang.bind(this, this._windowEntered));
        this.actor.add_actor(this._thumbnails.actor);
        // Need to force an allocation so we can figure out whether we
        // need to scroll when selecting
        this._thumbnails.actor.get_allocation_box();
        this._thumbnails.actor.opacity = 0;
        Tweener.addTween(this._thumbnails.actor,
                         { opacity: 255,
                           time: THUMBNAIL_FADE_TIME,
                           transition: 'easeOutQuad',
                           onComplete: Lang.bind(this, function () { this.thumbnailsVisible = true; })
                         });
        this._switcherList._items[this._selectedIndex].add_accessible_state (Atk.StateType.EXPANDED);
    }
const CyclerHighlight = new Lang.Class({
    Name: 'CyclerHighlight',
    _init: function() {
        this._window = null;
        this.actor = new St.Widget({ layout_manager: new Clutter.BinLayout() });
        this._clone = new Clutter.Clone();
        this.actor.add_actor(this._clone);
        this._highlight = new St.Widget({ style_class: 'cycler-highlight' });
        this.actor.add_actor(this._highlight);
        let coordinate = Clutter.BindCoordinate.ALL;
        let constraint = new Clutter.BindConstraint({ coordinate: coordinate });
        this._clone.bind_property('source', constraint, 'source', 0);
        this.actor.add_constraint(constraint);
        this.actor.connect('notify::allocation',
                           Lang.bind(this, this._onAllocationChanged));
        this.actor.connect('destroy', Lang.bind(this, this._onDestroy));
    },
    set window(w) {
        if (this._window == w)
            return;
        this._window = w;
        if (this._clone.source)
            this._clone.source.sync_visibility();
        let windowActor = this._window ? this._window.get_compositor_private()
                                       : null;
        if (windowActor)
            windowActor.hide();
        this._clone.source = windowActor;
    },
    _onAllocationChanged: function() {
        if (!this._window) {
            this._highlight.set_size(0, 0);
            this._highlight.hide();
        } else {
            let [x, y] = this.actor.allocation.get_origin();
            let rect = this._window.get_frame_rect();
            this._highlight.set_size(rect.width, rect.height);
            this._highlight.set_position(rect.x - x, rect.y - y);
            this._highlight.show();
        }
    },
    _onDestroy: function() {
        this.window = null;
    }
const CyclerPopup = new Lang.Class({
    Name: 'CyclerPopup',
    Extends: SwitcherPopup.SwitcherPopup,
    Abstract: true,
    _init : function() {
        this.parent();
        this._items = this._getWindows();
        if (this._items.length == 0)
            return;
        this._highlight = new CyclerHighlight();
        global.window_group.add_actor(this._highlight.actor);
        // We don't show an actual popup, so just provide what SwitcherPopup
        // expects instead of inheriting from SwitcherList
        this._switcherList = { actor: new St.Widget(),
                               highlight: Lang.bind(this, this._highlightItem),
                               connect: function() {} };
    },
    _highlightItem: function(index, justOutline) {
        this._highlight.window = this._items[index];
        global.window_group.set_child_above_sibling(this._highlight.actor, null);
    },
    _finish: function() {
        let window = this._items[this._selectedIndex];
        let ws = window.get_workspace();
        let activeWs = global.screen.get_active_workspace();
        if (window.minimized) {
            Main.wm.skipNextEffect(window.get_compositor_private());
            window.unminimize();
        }
        if (activeWs == ws) {
            Main.activateWindow(window);
        } else {
            // If the selected window is on a different workspace, we don't
            // want it to disappear, then slide in with the workspace; instead,
            // always activate it on the active workspace ...
            activeWs.activate_with_focus(window, global.get_current_time());
            // ... then slide it over to the original workspace if necessary
            Main.wm.actionMoveWindow(window, ws);
        }
        this.parent();
    },
    _onDestroy: function() {
        this._highlight.actor.destroy();
        this.parent();
    }
const GroupCyclerPopup = new Lang.Class({
    Name: 'GroupCyclerPopup',
    Extends: CyclerPopup,
    _getWindows: function() {
        let app = Shell.WindowTracker.get_default().focus_app;
        return app ? app.get_windows() : [];
    },
    _keyPressHandler: function(keysym, action) {
        if (action == Meta.KeyBindingAction.CYCLE_GROUP)
            this._select(this._next());
        else if (action == Meta.KeyBindingAction.CYCLE_GROUP_BACKWARD)
            this._select(this._previous());
        else
            return Clutter.EVENT_PROPAGATE;
        return Clutter.EVENT_STOP;
    }
const WindowSwitcherPopup = new Lang.Class({
    Name: 'WindowSwitcherPopup',
    Extends: SwitcherPopup.SwitcherPopup,
    _init: function() {
        this.parent();
        this._settings = new Gio.Settings({ schema_id: 'org.gnome.shell.window-switcher' });
        let windows = this._getWindowList();
        if (windows.length == 0)
            return;
        let mode = this._settings.get_enum('app-icon-mode');
        this._switcherList = new WindowList(windows, mode);
        this._items = this._switcherList.icons;
    },
    _getWindowList: function() {
        let workspace = this._settings.get_boolean('current-workspace-only') ? global.screen.get_active_workspace() : null;
        return getWindows(workspace);
    },
    _keyPressHandler: function(keysym, action) {
        if (action == Meta.KeyBindingAction.SWITCH_WINDOWS) {
            this._select(this._next());
        } else if (action == Meta.KeyBindingAction.SWITCH_WINDOWS_BACKWARD) {
            this._select(this._previous());
        } else {
            if (keysym == Clutter.Left)
                this._select(this._previous());
            else if (keysym == Clutter.Right)
                this._select(this._next());
            else
                return Clutter.EVENT_PROPAGATE;
        }
        return Clutter.EVENT_STOP;
    },
    _finish: function() {
        Main.activateWindow(this._items[this._selectedIndex].window);
        this.parent();
    }
const WindowCyclerPopup = new Lang.Class({
    Name: 'WindowCyclerPopup',
    Extends: CyclerPopup,
    _init: function() {
        this._settings = new Gio.Settings({ schema_id: 'org.gnome.shell.window-switcher' });
        this.parent();
    },
    _getWindows: function() {
        let workspace = this._settings.get_boolean('current-workspace-only') ? global.screen.get_active_workspace() : null;
        return getWindows(workspace);
    },
    _keyPressHandler: function(keysym, action) {
        if (action == Meta.KeyBindingAction.CYCLE_WINDOWS)
            this._select(this._next());
        else if (action == Meta.KeyBindingAction.CYCLE_WINDOWS_BACKWARD)
            this._select(this._previous());
        else
            return Clutter.EVENT_PROPAGATE;
        return Clutter.EVENT_STOP;
    }
const AppIcon = new Lang.Class({
    Name: 'AppIcon',
    _init: function(app) {
        this.app = app;
        this.actor = new St.BoxLayout({ style_class: 'alt-tab-app',
                                         vertical: true });
        this.icon = null;
        this._iconBin = new St.Bin({ x_fill: true, y_fill: true });
        this.actor.add(this._iconBin, { x_fill: false, y_fill: false } );
        this.label = new St.Label({ text: this.app.get_name() });
        this.actor.add(this.label, { x_fill: false });
    },
    set_size: function(size) {
        this.icon = this.app.create_icon_texture(size);
        this._iconBin.child = this.icon;
    }
const AppSwitcher = new Lang.Class({
    Name: 'AppSwitcher',
    Extends: SwitcherPopup.SwitcherList,
    _init : function(apps, altTabPopup) {
        this.parent(true);
        this.icons = [];
        this._arrows = [];
        let windowTracker = Shell.WindowTracker.get_default();
        let settings = new Gio.Settings({ schema_id: 'org.gnome.shell.app-switcher' });
        let workspace = settings.get_boolean('current-workspace-only') ? global.screen.get_active_workspace()
                                                                       : null;
        let allWindows = global.display.get_tab_list(Meta.TabList.NORMAL, workspace);
        // Construct the AppIcons, add to the popup
        for (let i = 0; i < apps.length; i++) {
            let appIcon = new AppIcon(apps[i]);
            // Cache the window list now; we don't handle dynamic changes here,
            // and we don't want to be continually retrieving it
            appIcon.cachedWindows = allWindows.filter(function(w) {
                return windowTracker.get_window_app (w) == appIcon.app;
            });
            if (appIcon.cachedWindows.length > 0)
                this._addIcon(appIcon);
        }
        this._curApp = -1;
        this._iconSize = 0;
        this._altTabPopup = altTabPopup;
        this._mouseTimeOutId = 0;
        this.actor.connect('destroy', Lang.bind(this, this._onDestroy));
    },
    _onDestroy: function() {
        if (this._mouseTimeOutId != 0)
            Mainloop.source_remove(this._mouseTimeOutId);
    },
    _setIconSize: function() {
        let j = 0;
        while(this._items.length > 1 && this._items[j].style_class != 'item-box') {
                j++;
        }
        let themeNode = this._items[j].get_theme_node();
        let iconPadding = themeNode.get_horizontal_padding();
        let iconBorder = themeNode.get_border_width(St.Side.LEFT) + themeNode.get_border_width(St.Side.RIGHT);
        let [iconMinHeight, iconNaturalHeight] = this.icons[j].label.get_preferred_height(-1);
        let iconSpacing = iconNaturalHeight + iconPadding + iconBorder;
        let totalSpacing = this._list.spacing * (this._items.length - 1);
        // We just assume the whole screen here due to weirdness happing with the passed width
        let primary = Main.layoutManager.primaryMonitor;
        let parentPadding = this.actor.get_parent().get_theme_node().get_horizontal_padding();
        let availWidth = primary.width - parentPadding - this.actor.get_theme_node().get_horizontal_padding();
        let scaleFactor = St.ThemeContext.get_for_stage(global.stage).scale_factor;
        let iconSizes = baseIconSizes.map(function(s) {
            return s * scaleFactor;
        });
        if (this._items.length == 1) {
            this._iconSize = baseIconSizes[0];
        } else {
            for(let i =  0; i < baseIconSizes.length; i++) {
                this._iconSize = baseIconSizes[i];
                let height = iconSizes[i] + iconSpacing;
                let w = height * this._items.length + totalSpacing;
                if (w <= availWidth)
                    break;
            }
        }
        for(let i = 0; i < this.icons.length; i++) {
            if (this.icons[i].icon != null)
                break;
            this.icons[i].set_size(this._iconSize);
        }
    },
    _getPreferredHeight: function (actor, forWidth, alloc) {
        this._setIconSize();
        this.parent(actor, forWidth, alloc);
    },
    _allocate: function (actor, box, flags) {
        // Allocate the main list items
        this.parent(actor, box, flags);
        let arrowHeight = Math.floor(this.actor.get_theme_node().get_padding(St.Side.BOTTOM) / 3);
        let arrowWidth = arrowHeight * 2;
        // Now allocate each arrow underneath its item
        let childBox = new Clutter.ActorBox();
        for (let i = 0; i < this._items.length; i++) {
            let itemBox = this._items[i].allocation;
            childBox.x1 = Math.floor(itemBox.x1 + (itemBox.x2 - itemBox.x1 - arrowWidth) / 2);
            childBox.x2 = childBox.x1 + arrowWidth;
            childBox.y1 = itemBox.y2 + arrowHeight;
            childBox.y2 = childBox.y1 + arrowHeight;
            this._arrows[i].allocate(childBox, flags);
        }
    },
    // We override SwitcherList's _onItemEnter method to delay
    // activation when the thumbnail list is open
    _onItemEnter: function (index) {
        if (this._mouseTimeOutId != 0)
            Mainloop.source_remove(this._mouseTimeOutId);
        if (this._altTabPopup.thumbnailsVisible) {
            this._mouseTimeOutId = Mainloop.timeout_add(APP_ICON_HOVER_TIMEOUT,
                                                        Lang.bind(this, function () {
                                                                            this._enterItem(index);
                                                                            this._mouseTimeOutId = 0;
                                                                            return GLib.SOURCE_REMOVE;
                                                        }));
            GLib.Source.set_name_by_id(this._mouseTimeOutId, '[gnome-shell] this._enterItem');
        } else
           this._itemEntered(index);
    },
    _enterItem: function(index) {
        let [x, y, mask] = global.get_pointer();
        let pickedActor = global.stage.get_actor_at_pos(Clutter.PickMode.ALL, x, y);
        if (this._items[index].contains(pickedActor))
            this._itemEntered(index);
    },
    // We override SwitcherList's highlight() method to also deal with
    // the AppSwitcher->ThumbnailList arrows. Apps with only 1 window
    // will hide their arrows by default, but show them when their
    // thumbnails are visible (ie, when the app icon is supposed to be
    // in justOutline mode). Apps with multiple windows will normally
    // show a dim arrow, but show a bright arrow when they are
    // highlighted.
    highlight : function(n, justOutline) {
        if (this._curApp != -1) {
            if (this.icons[this._curApp].cachedWindows.length == 1)
                this._arrows[this._curApp].hide();
            else
                this._arrows[this._curApp].remove_style_pseudo_class('highlighted');
        }
        this.parent(n, justOutline);
        this._curApp = n;
        if (this._curApp != -1) {
            if (justOutline && this.icons[this._curApp].cachedWindows.length == 1)
                this._arrows[this._curApp].show();
            else
                this._arrows[this._curApp].add_style_pseudo_class('highlighted');
        }
    },
    _addIcon : function(appIcon) {
        this.icons.push(appIcon);
        let item = this.addItem(appIcon.actor, appIcon.label);
        let n = this._arrows.length;
        let arrow = new St.DrawingArea({ style_class: 'switcher-arrow' });
        arrow.connect('repaint', function() { SwitcherPopup.drawArrow(arrow, St.Side.BOTTOM); });
        this._list.add_actor(arrow);
        this._arrows.push(arrow);
        if (appIcon.cachedWindows.length == 1)
            arrow.hide();
        else
            item.add_accessible_state (Atk.StateType.EXPANDABLE);
    }
const ThumbnailList = new Lang.Class({
    Name: 'ThumbnailList',
    Extends: SwitcherPopup.SwitcherList,
    _init : function(windows) {
        this.parent(false);
        this._labels = new Array();
        this._thumbnailBins = new Array();
        this._clones = new Array();
        this._windows = windows;
        for (let i = 0; i < windows.length; i++) {
            let box = new St.BoxLayout({ style_class: 'thumbnail-box',
                                         vertical: true });
            let bin = new St.Bin({ style_class: 'thumbnail' });
            box.add_actor(bin);
            this._thumbnailBins.push(bin);
            let title = windows[i].get_title();
            if (title) {
                let name = new St.Label({ text: title });
                // St.Label doesn't support text-align so use a Bin
                let bin = new St.Bin({ x_align: St.Align.MIDDLE });
                this._labels.push(bin);
                bin.add_actor(name);
                box.add_actor(bin);
                this.addItem(box, name);
            } else {
                this.addItem(box, null);
            }
        }
    },
    addClones : function (availHeight) {
        if (!this._thumbnailBins.length)
            return;
        let totalPadding = this._items[0].get_theme_node().get_horizontal_padding() + this._items[0].get_theme_node().get_vertical_padding();
        totalPadding += this.actor.get_theme_node().get_horizontal_padding() + this.actor.get_theme_node().get_vertical_padding();
        let [labelMinHeight, labelNaturalHeight] = this._labels[0].get_preferred_height(-1);
        let spacing = this._items[0].child.get_theme_node().get_length('spacing');
        let scaleFactor = St.ThemeContext.get_for_stage(global.stage).scale_factor;
        let thumbnailSize = THUMBNAIL_DEFAULT_SIZE * scaleFactor;
        availHeight = Math.min(availHeight - labelNaturalHeight - totalPadding - spacing, thumbnailSize);
        let binHeight = availHeight + this._items[0].get_theme_node().get_vertical_padding() + this.actor.get_theme_node().get_vertical_padding() - spacing;
        binHeight = Math.min(thumbnailSize, binHeight);
        for (let i = 0; i < this._thumbnailBins.length; i++) {
            let mutterWindow = this._windows[i].get_compositor_private();
            if (!mutterWindow)
                continue;
            let clone = _createWindowClone(mutterWindow, thumbnailSize);
            this._thumbnailBins[i].set_height(binHeight);
            this._thumbnailBins[i].add_actor(clone);
            this._clones.push(clone);
        }
        // Make sure we only do this once
        this._thumbnailBins = new Array();
    }
const WindowIcon = new Lang.Class({
    Name: 'WindowIcon',
    _init: function(window, mode) {
        this.window = window;
        this.actor = new St.BoxLayout({ style_class: 'alt-tab-app',
                                        vertical: true });
        this._icon = new St.Widget({ layout_manager: new Clutter.BinLayout() });
        this.actor.add(this._icon, { x_fill: false, y_fill: false } );
        this.label = new St.Label({ text: window.get_title() });
        let tracker = Shell.WindowTracker.get_default();
        this.app = tracker.get_window_app(window);
        let mutterWindow = this.window.get_compositor_private();
        let size;
        this._icon.destroy_all_children();
        let scaleFactor = St.ThemeContext.get_for_stage(global.stage).scale_factor;
        switch (mode) {
            case AppIconMode.THUMBNAIL_ONLY:
                size = WINDOW_PREVIEW_SIZE;
                this._icon.add_actor(_createWindowClone(mutterWindow, size * scaleFactor));
                break;
            case AppIconMode.BOTH:
                size = WINDOW_PREVIEW_SIZE;
                this._icon.add_actor(_createWindowClone(mutterWindow, size * scaleFactor));
                if (this.app)
                    this._icon.add_actor(this._createAppIcon(this.app,
                                                             APP_ICON_SIZE_SMALL));
                break;
            case AppIconMode.APP_ICON_ONLY:
                size = APP_ICON_SIZE;
                this._icon.add_actor(this._createAppIcon(this.app, size));
        }
        this._icon.set_size(size * scaleFactor, size * scaleFactor);
    },
    _createAppIcon: function(app, size) {
        let appIcon = app ? app.create_icon_texture(size)
                          : new St.Icon({ icon_name: 'icon-missing',
                                          icon_size: size });
        appIcon.x_expand = appIcon.y_expand = true;
        appIcon.x_align = appIcon.y_align = Clutter.ActorAlign.END;
        return appIcon;
    }
const WindowList = new Lang.Class({
    Name: 'WindowList',
    Extends: SwitcherPopup.SwitcherList,
    _init : function(windows, mode) {
        this.parent(true);
        this._label = new St.Label({ x_align: Clutter.ActorAlign.CENTER,
                                     y_align: Clutter.ActorAlign.CENTER });
        this.actor.add_actor(this._label);
        this.windows = windows;
        this.icons = [];
        for (let i = 0; i < windows.length; i++) {
            let win = windows[i];
            let icon = new WindowIcon(win, mode);
            this.addItem(icon.actor, icon.label);
            this.icons.push(icon);
        }
    },
    _getPreferredHeight: function(actor, forWidth, alloc) {
        this.parent(actor, forWidth, alloc);
        let spacing = this.actor.get_theme_node().get_padding(St.Side.BOTTOM);
        let [labelMin, labelNat] = this._label.get_preferred_height(-1);
        alloc.min_size += labelMin + spacing;
        alloc.natural_size += labelNat + spacing;
    },
    _allocateTop: function(actor, box, flags) {
        let childBox = new Clutter.ActorBox();
        childBox.x1 = box.x1;
        childBox.x2 = box.x2;
        childBox.y2 = box.y2;
        childBox.y1 = childBox.y2 - this._label.height;
        this._label.allocate(childBox, flags);
        let spacing = this.actor.get_theme_node().get_padding(St.Side.BOTTOM);
        box.y2 -= this._label.height + spacing;
        this.parent(actor, box, flags);
    },
    highlight: function(index, justOutline) {
        this.parent(index, justOutline);
        this._label.set_text(index == -1 ? '' : this.icons[index].label.text);
    }
(uuay)gnome/
main.js
// -*- mode: js; js-indent-level: 4; indent-tabs-mode: nil -*-
const Clutter = imports.gi.Clutter;
const Gdk = imports.gi.Gdk;
const Gio = imports.gi.Gio;
const GLib = imports.gi.GLib;
const Gtk = imports.gi.Gtk;
const Lang = imports.lang;
const Mainloop = imports.mainloop;
const Meta = imports.gi.Meta;
const Shell = imports.gi.Shell;
const St = imports.gi.St;
const AccessDialog = imports.ui.accessDialog;
const AudioDeviceSelection = imports.ui.audioDeviceSelection;
const Components = imports.ui.components;
const CtrlAltTab = imports.ui.ctrlAltTab;
const EndSessionDialog = imports.ui.endSessionDialog;
const Environment = imports.ui.environment;
const ExtensionSystem = imports.ui.extensionSystem;
const ExtensionDownloader = imports.ui.extensionDownloader;
const Keyboard = imports.ui.keyboard;
const LegacyTray = imports.ui.legacyTray;
const MessageTray = imports.ui.messageTray;
const ModalDialog = imports.ui.modalDialog;
const OsdWindow = imports.ui.osdWindow;
const OsdMonitorLabeler = imports.ui.osdMonitorLabeler;
const Overview = imports.ui.overview;
const Panel = imports.ui.panel;
const Params = imports.misc.params;
const RunDialog = imports.ui.runDialog;
const Layout = imports.ui.layout;
const LoginManager = imports.misc.loginManager;
const LookingGlass = imports.ui.lookingGlass;
const NotificationDaemon = imports.ui.notificationDaemon;
const WindowAttentionHandler = imports.ui.windowAttentionHandler;
const Screencast = imports.ui.screencast;
const ScreenShield = imports.ui.screenShield;
const Scripting = imports.ui.scripting;
const SessionMode = imports.ui.sessionMode;
const ShellDBus = imports.ui.shellDBus;
const ShellMountOperation = imports.ui.shellMountOperation;
const WindowManager = imports.ui.windowManager;
const Magnifier = imports.ui.magnifier;
const XdndHandler = imports.ui.xdndHandler;
const Util = imports.misc.util;
const A11Y_SCHEMA = 'org.gnome.desktop.a11y.keyboard';
const STICKY_KEYS_ENABLE = 'stickykeys-enable';
const GNOMESHELL_STARTED_MESSAGE_ID = 'f3ea493c22934e26811cd62abe8e203a';
let componentManager = null;
let panel = null;
let overview = null;
let runDialog = null;
let lookingGlass = null;
let wm = null;
let legacyTray = null;
let messageTray = null;
let screenShield = null;
let notificationDaemon = null;
let windowAttentionHandler = null;
let ctrlAltTabManager = null;
let osdWindowManager = null;
let osdMonitorLabeler = null;
let sessionMode = null;
let shellAccessDialogDBusService = null;
let shellAudioSelectionDBusService = null;
let shellDBusService = null;
let shellMountOpDBusService = null;
let screenSaverDBus = null;
let screencastService = null;
let modalCount = 0;
let actionMode = Shell.ActionMode.NONE;
let modalActorFocusStack = [];
let uiGroup = null;
let magnifier = null;
let xdndHandler = null;
let keyboard = null;
let layoutManager = null;
let _startDate;
let _defaultCssStylesheet = null;
let _cssStylesheet = null;
let _a11ySettings = null;
let _themeResource = null;
function _sessionUpdated() {
    if (sessionMode.isPrimary)
        _loadDefaultStylesheet();
    wm.setCustomKeybindingHandler('panel-main-menu',
                                  Shell.ActionMode.NORMAL |
                                  Shell.ActionMode.OVERVIEW,
                                  sessionMode.hasOverview ? Lang.bind(overview, overview.toggle) : null);
    wm.allowKeybinding('overlay-key', Shell.ActionMode.NORMAL |
                                      Shell.ActionMode.OVERVIEW);
    wm.setCustomKeybindingHandler('panel-run-dialog',
                                  Shell.ActionMode.NORMAL |
                                  Shell.ActionMode.OVERVIEW,
                                  sessionMode.hasRunDialog ? openRunDialog : null);
    if (!sessionMode.hasRunDialog) {
        if (runDialog)
            runDialog.close();
        if (lookingGlass)
            lookingGlass.close();
    }
function start() {
    // These are here so we don't break compatibility.
    global.logError = window.log;
    global.log = window.log;
    // Chain up async errors reported from C
    global.connect('notify-error', function (global, msg, detail) { notifyError(msg, detail); });
    Gio.DesktopAppInfo.set_desktop_env('GNOME');
    sessionMode = new SessionMode.SessionMode();
    sessionMode.connect('updated', _sessionUpdated);
    Gtk.Settings.get_default().connect('notify::gtk-theme-name',
                                       _loadDefaultStylesheet);
    _initializeUI();
    shellAccessDialogDBusService = new AccessDialog.AccessDialogDBus();
    shellAudioSelectionDBusService = new AudioDeviceSelection.AudioDeviceSelectionDBus();
    shellDBusService = new ShellDBus.GnomeShell();
    shellMountOpDBusService = new ShellMountOperation.GnomeShellMountOpHandler();
    _sessionUpdated();
function _initializeUI() {
    // Ensure ShellWindowTracker and ShellAppUsage are initialized; this will
    // also initialize ShellAppSystem first.  ShellAppSystem
    // needs to load all the .desktop files, and ShellWindowTracker
    // will use those to associate with windows.  Right now
    // the Monitor doesn't listen for installed app changes
    // and recalculate application associations, so to avoid
    // races for now we initialize it here.  It's better to
    // be predictable anyways.
    Shell.WindowTracker.get_default();
    Shell.AppUsage.get_default();
    reloadThemeResource();
    _loadDefaultStylesheet();
    // Setup the stage hierarchy early
    layoutManager = new Layout.LayoutManager();
    // Various parts of the codebase still refers to Main.uiGroup
    // instead using the layoutManager.  This keeps that code
    // working until it's updated.
    uiGroup = layoutManager.uiGroup;
    screencastService = new Screencast.ScreencastService();
    xdndHandler = new XdndHandler.XdndHandler();
    ctrlAltTabManager = new CtrlAltTab.CtrlAltTabManager();
    osdWindowManager = new OsdWindow.OsdWindowManager();
    osdMonitorLabeler = new OsdMonitorLabeler.OsdMonitorLabeler();
    overview = new Overview.Overview();
    wm = new WindowManager.WindowManager();
    magnifier = new Magnifier.Magnifier();
    if (LoginManager.canLock())
        screenShield = new ScreenShield.ScreenShield();
    legacyTray = new LegacyTray.LegacyTray();
    messageTray = new MessageTray.MessageTray();
    panel = new Panel.Panel();
    keyboard = new Keyboard.Keyboard();
    notificationDaemon = new NotificationDaemon.NotificationDaemon();
    windowAttentionHandler = new WindowAttentionHandler.WindowAttentionHandler();
    componentManager = new Components.ComponentManager();
    layoutManager.init();
    overview.init();
    _a11ySettings = new Gio.Settings({ schema_id: A11Y_SCHEMA });
    global.display.connect('overlay-key', Lang.bind(overview, function () {
        if (!_a11ySettings.get_boolean (STICKY_KEYS_ENABLE))
            overview.toggle();
    }));
    global.display.connect('show-restart-message', function(display, message) {
        showRestartMessage(message);
        return true;
    });
    global.display.connect('restart', function() {
        global.reexec_self();
        return true;
    });
    global.display.connect('gl-video-memory-purged', loadTheme);
    // Provide the bus object for gnome-session to
    // initiate logouts.
    EndSessionDialog.init();
    // We're ready for the session manager to move to the next phase
    Meta.register_with_session();
    _startDate = new Date();
    let perfModuleName = GLib.getenv("SHELL_PERF_MODULE");
    if (perfModuleName) {
        let perfOutput = GLib.getenv("SHELL_PERF_OUTPUT");
        let module = eval('imports.perf.' + perfModuleName + ';');
        Scripting.runPerfScript(module, perfOutput);
    }
    ExtensionDownloader.init();
    ExtensionSystem.init();
    if (sessionMode.isGreeter && screenShield) {
        layoutManager.connect('startup-prepared', function() {
            screenShield.showDialog();
        });
    }
    layoutManager.connect('startup-complete', function() {
        if (actionMode == Shell.ActionMode.NONE) {
            actionMode = Shell.ActionMode.NORMAL;
        }
        if (screenShield) {
            screenShield.lockIfWasLocked();
        }
        if (sessionMode.currentMode != 'gdm' &&
            sessionMode.currentMode != 'initial-setup') {
            Shell.Global.log_structured('GNOME Shell started at ' + _startDate,
                                        ['MESSAGE_ID=' + GNOMESHELL_STARTED_MESSAGE_ID]);
        }
    });
function _getStylesheet(name) {
    let stylesheet;
    stylesheet = Gio.File.new_for_uri('resource:///org/gnome/shell/theme/' + name);
    if (stylesheet.query_exists(null))
        return stylesheet;
    stylesheet = Gio.File.new_for_path(global.datadir + '/theme/' + name);
    if (stylesheet.query_exists(null))
        return stylesheet;
    return null;
function _getDefaultStylesheet() {
    let stylesheet = null;
    let name = sessionMode.stylesheetName;
    // Look for a high-contrast variant first when using GTK+'s HighContrast
    // theme
    if (Gtk.Settings.get_default().gtk_theme_name == 'HighContrast')
        stylesheet = _getStylesheet(name.replace('.css', '-high-contrast.css'));
    if (stylesheet == null)
        stylesheet = _getStylesheet(sessionMode.stylesheetName);
    return stylesheet;
function _loadDefaultStylesheet() {
    let stylesheet = _getDefaultStylesheet();
    if (_defaultCssStylesheet && _defaultCssStylesheet.equal(stylesheet))
        return;
    _defaultCssStylesheet = stylesheet;
    loadTheme();
 * getThemeStylesheet:
 * Get the theme CSS file that the shell will load
 * Returns: A #GFile that contains the theme CSS,
 *          null if using the default
function getThemeStylesheet() {
    return _cssStylesheet;
 * setThemeStylesheet:
 * @cssStylesheet: A file path that contains the theme CSS,
 *                  set it to null to use the default
 * Set the theme CSS file that the shell will load
function setThemeStylesheet(cssStylesheet) {
    _cssStylesheet = cssStylesheet ? Gio.File.new_for_path(cssStylesheet) : null;
function reloadThemeResource() {
    if (_themeResource)
        _themeResource._unregister();
    _themeResource = Gio.Resource.load(global.datadir + '/gnome-shell-theme.gresource');
    _themeResource._register();
 * loadTheme:
 * Reloads the theme CSS file
function loadTheme() {
    let themeContext = St.ThemeContext.get_for_stage (global.stage);
    let previousTheme = themeContext.get_theme();
    let theme = new St.Theme ({ application_stylesheet: _cssStylesheet,
                                default_stylesheet: _defaultCssStylesheet });
    if (previousTheme) {
        let customStylesheets = previousTheme.get_custom_stylesheets();
        for (let i = 0; i < customStylesheets.length; i++)
            theme.load_stylesheet(customStylesheets[i]);
    }
    themeContext.set_theme (theme);
 * notify:
 * @msg: A message
 * @details: Additional information
function notify(msg, details) {
    let source = new MessageTray.SystemNotificationSource();
    messageTray.add(source);
    let notification = new MessageTray.Notification(source, msg, details);
    notification.setTransient(true);
    source.notify(notification);
 * notifyError:
 * @msg: An error message
 * @details: Additional information
 * See shell_global_notify_problem().
function notifyError(msg, details) {
    // Also print to stderr so it's logged somewhere
    if (details)
        log('error: ' + msg + ': ' + details);
    else
        log('error: ' + msg);
    notify(msg, details);
function _findModal(actor) {
    for (let i = 0; i < modalActorFocusStack.length; i++) {
        if (modalActorFocusStack[i].actor == actor)
            return i;
    }
    return -1;
 * pushModal:
 * @actor: #ClutterActor which will be given keyboard focus
 * @params: optional parameters
 * Ensure we are in a mode where all keyboard and mouse input goes to
 * the stage, and focus @actor. Multiple calls to this function act in
 * a stacking fashion; the effect will be undone when an equal number
 * of popModal() invocations have been made.
 * Next, record the current Clutter keyboard focus on a stack. If the
 * modal stack returns to this actor, reset the focus to the actor
 * which was focused at the time pushModal() was invoked.
 * @params may be used to provide the following parameters:
 *  - timestamp: used to associate the call with a specific user initiated
 *               event.  If not provided then the value of
 *               global.get_current_time() is assumed.
 *  - options: Meta.ModalOptions flags to indicate that the pointer is
 *             already grabbed
 *  - actionMode: used to set the current Shell.ActionMode to filter
 *                    global keybindings; the default of NONE will filter
 *                    out all keybindings
 * Returns: true iff we successfully acquired a grab or already had one
function pushModal(actor, params) {
    params = Params.parse(params, { timestamp: global.get_current_time(),
                                    options: 0,
                                    actionMode: Shell.ActionMode.NONE });
    if (modalCount == 0) {
        if (!global.begin_modal(params.timestamp, params.options)) {
            log('pushModal: invocation of begin_modal failed');
            return false;
        }
        Meta.disable_unredirect_for_screen(global.screen);
    }
    modalCount += 1;
    let actorDestroyId = actor.connect('destroy', function() {
        let index = _findModal(actor);
        if (index >= 0)
            popModal(actor);
    });
    let prevFocus = global.stage.get_key_focus();
    let prevFocusDestroyId;
    if (prevFocus != null) {
        prevFocusDestroyId = prevFocus.connect('destroy', function() {
            let index = _findModal(actor);
            if (index >= 0)
                modalActorFocusStack[index].prevFocus = null;
        });
    }
    modalActorFocusStack.push({ actor: actor,
                                destroyId: actorDestroyId,
                                prevFocus: prevFocus,
                                prevFocusDestroyId: prevFocusDestroyId,
                                actionMode: actionMode });
    actionMode = params.actionMode;
    global.stage.set_key_focus(actor);
    return true;
 * popModal:
 * @actor: #ClutterActor passed to original invocation of pushModal().
 * @timestamp: optional timestamp
 * Reverse the effect of pushModal().  If this invocation is undoing
 * the topmost invocation, then the focus will be restored to the
 * previous focus at the time when pushModal() was invoked.
 * @timestamp is optionally used to associate the call with a specific user
 * initiated event.  If not provided then the value of
 * global.get_current_time() is assumed.
function popModal(actor, timestamp) {
    if (timestamp == undefined)
        timestamp = global.get_current_time();
    let focusIndex = _findModal(actor);
    if (focusIndex < 0) {
        global.stage.set_key_focus(null);
        global.end_modal(timestamp);
        actionMode = Shell.ActionMode.NORMAL;
        throw new Error('incorrect pop');
    }
    modalCount -= 1;
    let record = modalActorFocusStack[focusIndex];
    record.actor.disconnect(record.destroyId);
    if (focusIndex == modalActorFocusStack.length - 1) {
        if (record.prevFocus)
            record.prevFocus.disconnect(record.prevFocusDestroyId);
        actionMode = record.actionMode;
        global.stage.set_key_focus(record.prevFocus);
    } else {
        // If we have:
        //     global.stage.set_focus(a);
        //     Main.pushModal(b);
        //     Main.pushModal(c);
        //     Main.pushModal(d);
        //
        // then we have the stack:
        //     [{ prevFocus: a, actor: b },
        //      { prevFocus: b, actor: c },
        //      { prevFocus: c, actor: d }]
        //
        // When actor c is destroyed/popped, if we only simply remove the
        // record, then the focus stack will be [a, c], rather than the correct
        // [a, b]. Shift the focus stack up before removing the record to ensure
        // that we get the correct result.
        let t = modalActorFocusStack[modalActorFocusStack.length - 1];
        if (t.prevFocus)
            t.prevFocus.disconnect(t.prevFocusDestroyId);
        // Remove from the middle, shift the focus chain up
        for (let i = modalActorFocusStack.length - 1; i > focusIndex; i--) {
            modalActorFocusStack[i].prevFocus = modalActorFocusStack[i - 1].prevFocus;
            modalActorFocusStack[i].prevFocusDestroyId = modalActorFocusStack[i - 1].prevFocusDestroyId;
            modalActorFocusStack[i].actionMode = modalActorFocusStack[i - 1].actionMode;
        }
    }
    modalActorFocusStack.splice(focusIndex, 1);
    if (modalCount > 0)
        return;
    layoutManager.modalEnded();
    global.end_modal(timestamp);
    Meta.enable_unredirect_for_screen(global.screen);
    actionMode = Shell.ActionMode.NORMAL;
function createLookingGlass() {
    if (lookingGlass == null) {
        lookingGlass = new LookingGlass.LookingGlass();
    }
    return lookingGlass;
function openRunDialog() {
    if (runDialog == null) {
        runDialog = new RunDialog.RunDialog();
    }
    runDialog.open();
 * activateWindow:
 * @window: the Meta.Window to activate
 * @time: (optional) current event time
 * @workspaceNum: (optional) window's workspace number
 * Activates @window, switching to its workspace first if necessary,
 * and switching out of the overview if it's currently active
function activateWindow(window, time, workspaceNum) {
    let activeWorkspaceNum = global.screen.get_active_workspace_index();
    let windowWorkspaceNum = (workspaceNum !== undefined) ? workspaceNum : window.get_workspace().index();
    if (!time)
        time = global.get_current_time();
    if (windowWorkspaceNum != activeWorkspaceNum) {
        let workspace = global.screen.get_workspace_by_index(windowWorkspaceNum);
        workspace.activate_with_focus(window, time);
    } else {
        window.activate(time);
    }
    overview.hide();
    panel.closeCalendar();
// TODO - replace this timeout with some system to guess when the user might
// be e.g. just reading the screen and not likely to interact.
const DEFERRED_TIMEOUT_SECONDS = 20;
var _deferredWorkData = {};
// Work scheduled for some point in the future
var _deferredWorkQueue = [];
// Work we need to process before the next redraw
var _beforeRedrawQueue = [];
// Counter to assign work ids
var _deferredWorkSequence = 0;
var _deferredTimeoutId = 0;
function _runDeferredWork(workId) {
    if (!_deferredWorkData[workId])
        return;
    let index = _deferredWorkQueue.indexOf(workId);
    if (index < 0)
        return;
    _deferredWorkQueue.splice(index, 1);
    _deferredWorkData[workId].callback();
    if (_deferredWorkQueue.length == 0 && _deferredTimeoutId > 0) {
        Mainloop.source_remove(_deferredTimeoutId);
        _deferredTimeoutId = 0;
    }
function _runAllDeferredWork() {
    while (_deferredWorkQueue.length > 0)
        _runDeferredWork(_deferredWorkQueue[0]);
function _runBeforeRedrawQueue() {
    for (let i = 0; i < _beforeRedrawQueue.length; i++) {
        let workId = _beforeRedrawQueue[i];
        _runDeferredWork(workId);
    }
    _beforeRedrawQueue = [];
function _queueBeforeRedraw(workId) {
    _beforeRedrawQueue.push(workId);
    if (_beforeRedrawQueue.length == 1) {
        Meta.later_add(Meta.LaterType.BEFORE_REDRAW, function () {
            _runBeforeRedrawQueue();
            return false;
        });
    }
 * initializeDeferredWork:
 * @actor: A #ClutterActor
 * @callback: Function to invoke to perform work
 * This function sets up a callback to be invoked when either the
 * given actor is mapped, or after some period of time when the machine
 * is idle.  This is useful if your actor isn't always visible on the
 * screen (for example, all actors in the overview), and you don't want
 * to consume resources updating if the actor isn't actually going to be
 * displaying to the user.
 * Note that queueDeferredWork is called by default immediately on
 * initialization as well, under the assumption that new actors
 * will need it.
 * Returns: A string work identifer
function initializeDeferredWork(actor, callback, props) {
    // Turn into a string so we can use as an object property
    let workId = '' + (++_deferredWorkSequence);
    _deferredWorkData[workId] = { 'actor': actor,
                                  'callback': callback };
    actor.connect('notify::mapped', function () {
        if (!(actor.mapped && _deferredWorkQueue.indexOf(workId) >= 0))
            return;
        _queueBeforeRedraw(workId);
    });
    actor.connect('destroy', function() {
        let index = _deferredWorkQueue.indexOf(workId);
        if (index >= 0)
            _deferredWorkQueue.splice(index, 1);
        delete _deferredWorkData[workId];
    });
    queueDeferredWork(workId);
    return workId;
 * queueDeferredWork:
 * @workId: work identifier
 * Ensure that the work identified by @workId will be
 * run on map or timeout.  You should call this function
 * for example when data being displayed by the actor has
 * changed.
function queueDeferredWork(workId) {
    let data = _deferredWorkData[workId];
    if (!data) {
        let message = 'Invalid work id %d'.format(workId);
        logError(new Error(message), message);
        return;
    }
    if (_deferredWorkQueue.indexOf(workId) < 0)
        _deferredWorkQueue.push(workId);
    if (data.actor.mapped) {
        _queueBeforeRedraw(workId);
        return;
    } else if (_deferredTimeoutId == 0) {
        _deferredTimeoutId = Mainloop.timeout_add_seconds(DEFERRED_TIMEOUT_SECONDS, function () {
            _runAllDeferredWork();
            _deferredTimeoutId = 0;
            return GLib.SOURCE_REMOVE;
        });
        GLib.Source.set_name_by_id(_deferredTimeoutId, '[gnome-shell] _runAllDeferredWork');
    }
const RestartMessage = new Lang.Class({
    Name: 'RestartMessage',
    Extends: ModalDialog.ModalDialog,
    _init : function(message) {
        this.parent({ shellReactive: true,
                      styleClass: 'restart-message headline',
                      shouldFadeIn: false,
                      destroyOnClose: true });
        let label = new St.Label({ text: message });
        this.contentLayout.add(label, { x_fill: false,
                                        y_fill: false,
                                        x_align: St.Align.MIDDLE,
                                        y_align: St.Align.MIDDLE });
        this.buttonLayout.hide();
    }
function showRestartMessage(message) {
    let restartMessage = new RestartMessage(message);
    restartMessage.open();
(uuay)main.js
const Lang = imports.lang;
const Gettext = imports.gettext;
const GLib = imports.gi.GLib;
const GObject = imports.gi.GObject;
const Gio = imports.gi.Gio;
const Gtk = imports.gi.Gtk;
const Pango = imports.gi.Pango;
const Format = imports.format;
const _ = Gettext.gettext;
const Config = imports.misc.config;
const ExtensionUtils = imports.misc.extensionUtils;
const GnomeShellIface = '<node> \
<interface name="org.gnome.Shell.Extensions"> \
<signal name="ExtensionStatusChanged"> \
    <arg type="s" name="uuid"/> \
    <arg type="i" name="state"/> \
    <arg type="s" name="error"/> \
</signal> \
</interface> \
</node>';
const GnomeShellProxy = Gio.DBusProxy.makeProxyWrapper(GnomeShellIface);
function stripPrefix(string, prefix) {
    if (string.slice(0, prefix.length) == prefix)
        return string.slice(prefix.length);
    return string;
const Application = new Lang.Class({
    Name: 'Application',
    _init: function() {
        GLib.set_prgname('gnome-shell-extension-prefs');
        this.application = new Gtk.Application({
            application_id: 'org.gnome.shell.ExtensionPrefs',
            flags: Gio.ApplicationFlags.HANDLES_COMMAND_LINE
        });
        this.application.connect('activate', Lang.bind(this, this._onActivate));
        this.application.connect('command-line', Lang.bind(this, this._onCommandLine));
        this.application.connect('startup', Lang.bind(this, this._onStartup));
        this._extensionPrefsModules = {};
        this._startupUuid = null;
        this._loaded = false;
        this._skipMainWindow = false;
    },
    _extensionAvailable: function(uuid) {
        let extension = ExtensionUtils.extensions[uuid];
        if (!extension)
            return false;
        if (!extension.dir.get_child('prefs.js').query_exists(null))
            return false;
        return true;
    },
    _getExtensionPrefsModule: function(extension) {
        let uuid = extension.metadata.uuid;
        if (this._extensionPrefsModules.hasOwnProperty(uuid))
            return this._extensionPrefsModules[uuid];
        ExtensionUtils.installImporter(extension);
        let prefsModule = extension.imports.prefs;
        prefsModule.init(extension.metadata);
        this._extensionPrefsModules[uuid] = prefsModule;
        return prefsModule;
    },
    _selectExtension: function(uuid) {
        if (!this._extensionAvailable(uuid))
            return;
        let extension = ExtensionUtils.extensions[uuid];
        let widget;
        try {
            let prefsModule = this._getExtensionPrefsModule(extension);
            widget = prefsModule.buildPrefsWidget();
        } catch (e) {
            widget = this._buildErrorUI(extension, e);
        }
        let dialog = new Gtk.Dialog({ use_header_bar: true,
                                      modal: true,
                                      title: extension.metadata.name });
        if (this._skipMainWindow) {
            this.application.add_window(dialog);
            if (this._window)
                this._window.destroy();
            this._window = dialog;
            this._window.window_position = Gtk.WindowPosition.CENTER;
        } else {
            dialog.transient_for = this._window;
        }
        dialog.set_default_size(600, 400);
        dialog.get_content_area().add(widget);
        dialog.show();
    },
    _buildErrorUI: function(extension, exc) {
        let box = new Gtk.Box({ orientation: Gtk.Orientation.VERTICAL });
        let label = new Gtk.Label({
            label: _("There was an error loading the preferences dialog for %s:").format(extension.metadata.name)
        });
        box.add(label);
        let errortext = '';
        errortext += exc;
        errortext += '\n\n';
        errortext += 'Stack trace:\n';
        // Indent stack trace.
        errortext += exc.stack.split('\n').map(function(line) {
            return '  ' + line;
        }).join('\n');
        let scroll = new Gtk.ScrolledWindow({ vexpand: true });
        let buffer = new Gtk.TextBuffer({ text: errortext });
        let textview = new Gtk.TextView({ buffer: buffer });
        textview.override_font(Pango.font_description_from_string('monospace'));
        scroll.add(textview);
        box.add(scroll);
        box.show_all();
        return box;
    },
    _buildUI: function(app) {
        this._window = new Gtk.ApplicationWindow({ application: app,
                                                   window_position: Gtk.WindowPosition.CENTER });
        this._window.set_size_request(800, 500);
        this._titlebar = new Gtk.HeaderBar({ show_close_button: true,
                                             title: _("GNOME Shell Extensions") });
        this._window.set_titlebar(this._titlebar);
        let scroll = new Gtk.ScrolledWindow({ hscrollbar_policy: Gtk.PolicyType.NEVER,
                                              shadow_type: Gtk.ShadowType.IN,
                                              halign: Gtk.Align.CENTER,
                                              propagate_natural_width: true,
                                              margin: 18 });
        this._window.add(scroll);
        this._extensionSelector = new Gtk.ListBox({ selection_mode: Gtk.SelectionMode.NONE });
        this._extensionSelector.set_sort_func(Lang.bind(this, this._sortList));
        this._extensionSelector.set_header_func(Lang.bind(this, this._updateHeader));
        scroll.add(this._extensionSelector);
        this._shellProxy = new GnomeShellProxy(Gio.DBus.session, 'org.gnome.Shell', '/org/gnome/Shell');
        this._shellProxy.connectSignal('ExtensionStatusChanged', Lang.bind(this, function(proxy, senderName, [uuid, state, error]) {
            if (ExtensionUtils.extensions[uuid] !== undefined)
                this._scanExtensions();
        }));
        this._window.show_all();
    },
    _sortList: function(row1, row2) {
        let name1 = ExtensionUtils.extensions[row1.uuid].metadata.name;
        let name2 = ExtensionUtils.extensions[row2.uuid].metadata.name;
        return name1.localeCompare(name2);
    },
    _updateHeader: function(row, before) {
        if (!before || row.get_header())
            return;
        let sep = new Gtk.Separator({ orientation: Gtk.Orientation.HORIZONTAL });
        row.set_header(sep);
    },
    _scanExtensions: function() {
        let finder = new ExtensionUtils.ExtensionFinder();
        finder.connect('extension-found', Lang.bind(this, this._extensionFound));
        finder.scanExtensions();
        this._extensionsLoaded();
    },
    _extensionFound: function(finder, extension) {
        let row = new ExtensionRow(extension.uuid);
        row.prefsButton.visible = this._extensionAvailable(row.uuid);
        row.prefsButton.connect('clicked', Lang.bind(this,
            function() {
                this._selectExtension(row.uuid);
            }));
        row.show_all();
        this._extensionSelector.add(row);
    },
    _extensionsLoaded: function() {
        if (this._startupUuid && this._extensionAvailable(this._startupUuid))
            this._selectExtension(this._startupUuid);
        this._startupUuid = null;
        this._skipMainWindow = false;
        this._loaded = true;
    },
    _onActivate: function() {
        this._window.present();
    },
    _onStartup: function(app) {
        this._buildUI(app);
        this._scanExtensions();
    },
    _onCommandLine: function(app, commandLine) {
        app.activate();
        let args = commandLine.get_arguments();
        if (args.length) {
            let uuid = args[0];
            this._skipMainWindow = true;
            // Strip off "extension:///" prefix which fakes a URI, if it exists
            uuid = stripPrefix(uuid, "extension:///");
            if (this._extensionAvailable(uuid))
                this._selectExtension(uuid);
            else if (!this._loaded)
                this._startupUuid = uuid;
            else
                this._skipMainWindow = false;
        }
        return 0;
    }
const ExtensionRow = new Lang.Class({
    Name: 'ExtensionRow',
    Extends: Gtk.ListBoxRow,
    _init: function(uuid) {
        this.parent();
        this.uuid = uuid;
        this._settings = new Gio.Settings({ schema_id: 'org.gnome.shell' });
        this._settings.connect('changed::enabled-extensions', Lang.bind(this,
            function() {
                this._switch.state = this._isEnabled();
            }));
        this._settings.connect('changed::disable-extension-version-validation',
            Lang.bind(this, function() {
                this._switch.sensitive = this._canEnable();
            }));
        this._buildUI();
    },
    _buildUI: function() {
        let extension = ExtensionUtils.extensions[this.uuid];
        let hbox = new Gtk.Box({ orientation: Gtk.Orientation.HORIZONTAL,
                                 hexpand: true, margin: 12, spacing: 6 });
        this.add(hbox);
        let vbox = new Gtk.Box({ orientation: Gtk.Orientation.VERTICAL,
                                 spacing: 6, hexpand: true });
        hbox.add(vbox);
        let name = GLib.markup_escape_text(extension.metadata.name, -1);
        let label = new Gtk.Label({ label: '<b>' + name + '</b>',
                                    use_markup: true,
                                    halign: Gtk.Align.START });
        vbox.add(label);
        let desc = extension.metadata.description.split('\n')[0];
        label = new Gtk.Label({ label: desc,
                                ellipsize: Pango.EllipsizeMode.END,
                                halign: Gtk.Align.START });
        vbox.add(label);
        let button = new Gtk.Button({ valign: Gtk.Align.CENTER,
                                      no_show_all: true });
        button.add(new Gtk.Image({ icon_name: 'emblem-system-symbolic',
                                   icon_size: Gtk.IconSize.BUTTON,
                                   visible: true }));
        button.get_style_context().add_class('circular');
        hbox.add(button);
        this.prefsButton = button;
        this._switch = new Gtk.Switch({ valign: Gtk.Align.CENTER,
                                        sensitive: this._canEnable(),
                                        state: this._isEnabled() });
        this._switch.connect('notify::active', Lang.bind(this,
            function() {
                if (this._switch.active)
                    this._enable();
                else
                    this._disable();
            }));
        this._switch.connect('state-set', function() { return true; });
        hbox.add(this._switch);
    },
    _canEnable: function() {
        let extension = ExtensionUtils.extensions[this.uuid];
        let checkVersion = !this._settings.get_boolean('disable-extension-version-validation');
        return !(checkVersion && ExtensionUtils.isOutOfDate(extension));
    },
    _isEnabled: function() {
        let extensions = this._settings.get_strv('enabled-extensions');
        return extensions.indexOf(this.uuid) != -1;
    },
    _enable: function() {
        let extensions = this._settings.get_strv('enabled-extensions');
        if (extensions.indexOf(this.uuid) != -1)
            return;
        extensions.push(this.uuid);
        this._settings.set_strv('enabled-extensions', extensions);
    },
    _disable: function() {
        let extensions = this._settings.get_strv('enabled-extensions');
        let pos = extensions.indexOf(this.uuid);
        if (pos == -1)
            return;
        do {
            extensions.splice(pos, 1);
            pos = extensions.indexOf(this.uuid);
        } while (pos != -1);
        this._settings.set_strv('enabled-extensions', extensions);
    }
function initEnvironment() {
    // Monkey-patch in a "global" object that fakes some Shell utilities
    // that ExtensionUtils depends on.
    window.global = {
        log: function() {
            print([].join.call(arguments, ', '));
        },
        logError: function(s) {
            log('ERROR: ' + s);
        },
        userdatadir: GLib.build_filenamev([GLib.get_user_data_dir(), 'gnome-shell'])
    };
    String.prototype.format = Format.format;
function main(argv) {
    initEnvironment();
    Gettext.bindtextdomain(Config.GETTEXT_PACKAGE, Config.LOCALEDIR);
    Gettext.textdomain(Config.GETTEXT_PACKAGE);
    let app = new Application();
    app.application.run(argv);
(uuay)loginDialog.js
// -*- mode: js; js-indent-level: 4; indent-tabs-mode: nil -*-
 * Copyright 2011 Red Hat, Inc
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2, or (at your option)
 * any later version.
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, see <http://www.gnu.org/licenses/>.
const AccountsService = imports.gi.AccountsService;
const Atk = imports.gi.Atk;
const Clutter = imports.gi.Clutter;
const Gdm = imports.gi.Gdm;
const Gio = imports.gi.Gio;
const GLib = imports.gi.GLib;
const GObject = imports.gi.GObject;
const Gtk = imports.gi.Gtk;
const Lang = imports.lang;
const Mainloop = imports.mainloop;
const Meta = imports.gi.Meta;
const Pango = imports.gi.Pango;
const Shell = imports.gi.Shell;
const Signals = imports.signals;
const St = imports.gi.St;
const AuthPrompt = imports.gdm.authPrompt;
const Batch = imports.gdm.batch;
const BoxPointer = imports.ui.boxpointer;
const CtrlAltTab = imports.ui.ctrlAltTab;
const GdmUtil = imports.gdm.util;
const Layout = imports.ui.layout;
const LoginManager = imports.misc.loginManager;
const Main = imports.ui.main;
const PopupMenu = imports.ui.popupMenu;
const Realmd = imports.gdm.realmd;
const Tweener = imports.ui.tweener;
const UserWidget = imports.ui.userWidget;
const _FADE_ANIMATION_TIME = 0.25;
const _SCROLL_ANIMATION_TIME = 0.5;
const _TIMED_LOGIN_IDLE_THRESHOLD = 5.0;
const _LOGO_ICON_HEIGHT = 48;
const _MAX_BOTTOM_MENU_ITEMS = 5;
const UserListItem = new Lang.Class({
    Name: 'UserListItem',
    _init: function(user) {
        this.user = user;
        this._userChangedId = this.user.connect('changed',
                                                 Lang.bind(this, this._onUserChanged));
        let layout = new St.BoxLayout({ vertical: true });
        this.actor = new St.Button({ style_class: 'login-dialog-user-list-item',
                                     button_mask: St.ButtonMask.ONE | St.ButtonMask.THREE,
                                     can_focus: true,
                                     child: layout,
                                     reactive: true,
                                     x_align: St.Align.START,
                                     x_fill: true });
        this.actor.connect('destroy',
                           Lang.bind(this, this._onDestroy));
        this._userWidget = new UserWidget.UserWidget(this.user);
        layout.add(this._userWidget.actor);
        this._userWidget.actor.bind_property('label-actor', this.actor, 'label-actor',
                                             GObject.BindingFlags.SYNC_CREATE);
        this._timedLoginIndicator = new St.Bin({ style_class: 'login-dialog-timed-login-indicator',
                                                 scale_x: 0 });
        layout.add(this._timedLoginIndicator);
        this.actor.connect('clicked', Lang.bind(this, this._onClicked));
        this._onUserChanged();
    },
    _onUserChanged: function() {
        this._updateLoggedIn();
    },
    _updateLoggedIn: function() {
        if (this.user.is_logged_in())
            this.actor.add_style_pseudo_class('logged-in');
        else
            this.actor.remove_style_pseudo_class('logged-in');
    },
    _onDestroy: function() {
        this.user.disconnect(this._userChangedId);
    },
    _onClicked: function() {
        this.emit('activate');
    },
    showTimedLoginIndicator: function(time) {
        let hold = new Batch.Hold();
        this.hideTimedLoginIndicator();
        Tweener.addTween(this._timedLoginIndicator,
                         { scale_x: 1.,
                           time: time,
                           transition: 'linear',
                           onComplete: function() {
                               hold.release();
                           },
                           onCompleteScope: this
                         });
        return hold;
    },
    hideTimedLoginIndicator: function() {
        Tweener.removeTweens(this._timedLoginIndicator);
        this._timedLoginIndicator.scale_x = 0.;
    }
Signals.addSignalMethods(UserListItem.prototype);
const UserList = new Lang.Class({
    Name: 'UserList',
    _init: function() {
        this.actor = new St.ScrollView({ style_class: 'login-dialog-user-list-view'});
        this.actor.set_policy(Gtk.PolicyType.NEVER,
                              Gtk.PolicyType.AUTOMATIC);
        this._box = new St.BoxLayout({ vertical: true,
                                       style_class: 'login-dialog-user-list',
                                       pseudo_class: 'expanded' });
        this.actor.add_actor(this._box);
        this._items = {};
        this.actor.connect('key-focus-in', Lang.bind(this, this._moveFocusToItems));
    },
    _moveFocusToItems: function() {
        let hasItems = Object.keys(this._items).length > 0;
        if (!hasItems)
            return;
        if (global.stage.get_key_focus() != this.actor)
            return;
        let focusSet = this.actor.navigate_focus(null, Gtk.DirectionType.TAB_FORWARD, false);
        if (!focusSet) {
            Meta.later_add(Meta.LaterType.BEFORE_REDRAW, Lang.bind(this, function() {
                this._moveFocusToItems();
                return false;
            }));
        }
    },
    _onItemActivated: function(activatedItem) {
        this.emit('activate', activatedItem);
    },
    updateStyle: function(isExpanded) {
        let tasks = [];
        if (isExpanded)
            this._box.add_style_pseudo_class('expanded');
        else
            this._box.remove_style_pseudo_class('expanded');
        for (let userName in this._items) {
            let item = this._items[userName];
            item.actor.sync_hover();
        }
    },
    scrollToItem: function(item) {
        let box = item.actor.get_allocation_box();
        let adjustment = this.actor.get_vscroll_bar().get_adjustment();
        let value = (box.y1 + adjustment.step_increment / 2.0) - (adjustment.page_size / 2.0);
        Tweener.removeTweens(adjustment);
        Tweener.addTween (adjustment,
                          { value: value,
                            time: _SCROLL_ANIMATION_TIME,
                            transition: 'easeOutQuad' });
    },
    jumpToItem: function(item) {
        let box = item.actor.get_allocation_box();
        let adjustment = this.actor.get_vscroll_bar().get_adjustment();
        let value = (box.y1 + adjustment.step_increment / 2.0) - (adjustment.page_size / 2.0);
        adjustment.set_value(value);
    },
    getItemFromUserName: function(userName) {
        let item = this._items[userName];
        if (!item)
            return null;
        return item;
    },
    containsUser: function(user) {
        return this._items[user.get_user_name()] != null;
    },
    addUser: function(user) {
        if (!user.is_loaded)
            return;
        if (user.is_system_account())
            return;
        if (user.locked)
           return;
        let userName = user.get_user_name();
        if (!userName)
            return;
        this.removeUser(user);
        let item = new UserListItem(user);
        this._box.add(item.actor, { x_fill: true });
        this._items[userName] = item;
        item.connect('activate',
                     Lang.bind(this, this._onItemActivated));
        // Try to keep the focused item front-and-center
        item.actor.connect('key-focus-in',
                           Lang.bind(this,
                                     function() {
                                         this.scrollToItem(item);
                                     }));
        this._moveFocusToItems();
        this.emit('item-added', item);
    },
    removeUser: function(user) {
        if (!user.is_loaded)
            return;
        let userName = user.get_user_name();
        if (!userName)
            return;
        let item = this._items[userName];
        if (!item)
            return;
        item.actor.destroy();
        delete this._items[userName];
    }
Signals.addSignalMethods(UserList.prototype);
const SessionMenuButton = new Lang.Class({
    Name: 'SessionMenuButton',
    _init: function() {
        let gearIcon = new St.Icon({ icon_name: 'emblem-system-symbolic' });
        this._button = new St.Button({ style_class: 'login-dialog-session-list-button',
                                       reactive: true,
                                       track_hover: true,
                                       can_focus: true,
                                       accessible_name: _("Choose Session"),
                                       accessible_role: Atk.Role.MENU,
                                       child: gearIcon });
        this.actor = new St.Bin({ child: this._button });
        let side = St.Side.TOP;
        let align = 0;
        if (Gdm.get_session_ids().length > _MAX_BOTTOM_MENU_ITEMS) {
            if (this.actor.text_direction == Clutter.TextDirection.RTL)
                side = St.Side.RIGHT;
            else
                side = St.Side.LEFT;
            align = 0.5;
        }
        this._menu = new PopupMenu.PopupMenu(this._button, align, side);
        Main.uiGroup.add_actor(this._menu.actor);
        this._menu.actor.hide();
        this._menu.connect('open-state-changed',
                           Lang.bind(this, function(menu, isOpen) {
                                if (isOpen)
                                    this._button.add_style_pseudo_class('active');
                                else
                                    this._button.remove_style_pseudo_class('active');
                           }));
        this._manager = new PopupMenu.PopupMenuManager({ actor: this._button });
        this._manager.addMenu(this._menu);
        this._button.connect('clicked', Lang.bind(this, function() {
            this._menu.toggle();
        }));
        this._items = {};
        this._activeSessionId = null;
        this._populate();
    },
    updateSensitivity: function(sensitive) {
        this._button.reactive = sensitive;
        this._button.can_focus = sensitive;
        this._menu.close(BoxPointer.PopupAnimation.NONE);
    },
    _updateOrnament: function() {
        let itemIds = Object.keys(this._items);
        for (let i = 0; i < itemIds.length; i++) {
            if (itemIds[i] == this._activeSessionId)
                this._items[itemIds[i]].setOrnament(PopupMenu.Ornament.DOT);
            else
                this._items[itemIds[i]].setOrnament(PopupMenu.Ornament.NONE);
        }
    },
    setActiveSession: function(sessionId) {
         if (sessionId == this._activeSessionId)
             return;
         this._activeSessionId = sessionId;
         this._updateOrnament();
         this.emit('session-activated', this._activeSessionId);
    },
    close: function() {
        this._menu.close();
    },
    _populate: function() {
        let ids = Gdm.get_session_ids();
        ids.sort();
        if (ids.length <= 1) {
            this._button.hide();
            return;
        }
        for (let i = 0; i < ids.length; i++) {
            let [sessionName, sessionDescription] = Gdm.get_session_name_and_description(ids[i]);
            let id = ids[i];
            let item = new PopupMenu.PopupMenuItem(sessionName);
            this._menu.addMenuItem(item);
            this._items[id] = item;
            if (!this._activeSessionId)
                this.setActiveSession(id);
            item.connect('activate', Lang.bind(this, function() {
                this.setActiveSession(id);
            }));
        }
    }
Signals.addSignalMethods(SessionMenuButton.prototype);
const LoginDialog = new Lang.Class({
    Name: 'LoginDialog',
    _init: function(parentActor) {
        this.actor = new Shell.GenericContainer({ style_class: 'login-dialog',
                                                  visible: false });
        this.actor.get_accessible().set_role(Atk.Role.WINDOW);
        this.actor.add_constraint(new Layout.MonitorConstraint({ primary: true }));
        this.actor.connect('allocate', Lang.bind(this, this._onAllocate));
        this.actor.connect('destroy', Lang.bind(this, this._onDestroy));
        parentActor.add_child(this.actor);
        this._userManager = AccountsService.UserManager.get_default()
        this._gdmClient = new Gdm.Client();
        this._settings = new Gio.Settings({ schema_id: GdmUtil.LOGIN_SCREEN_SCHEMA });
        this._settings.connect('changed::' + GdmUtil.BANNER_MESSAGE_KEY,
                               Lang.bind(this, this._updateBanner));
        this._settings.connect('changed::' + GdmUtil.BANNER_MESSAGE_TEXT_KEY,
                               Lang.bind(this, this._updateBanner));
        this._settings.connect('changed::' + GdmUtil.DISABLE_USER_LIST_KEY,
                               Lang.bind(this, this._updateDisableUserList));
        this._settings.connect('changed::' + GdmUtil.LOGO_KEY,
                               Lang.bind(this, this._updateLogo));
        this._textureCache = St.TextureCache.get_default();
        this._updateLogoTextureId = this._textureCache.connect('texture-file-changed',
                                                               Lang.bind(this, this._updateLogoTexture));
        this._userSelectionBox = new St.BoxLayout({ style_class: 'login-dialog-user-selection-box',
                                                    x_align: Clutter.ActorAlign.CENTER,
                                                    y_align: Clutter.ActorAlign.CENTER,
                                                    vertical: true,
                                                    visible: false });
        this.actor.add_child(this._userSelectionBox);
        this._userList = new UserList();
        this._userSelectionBox.add(this._userList.actor,
                                   { expand: true,
                                     x_fill: true,
                                     y_fill: true });
        this._authPrompt = new AuthPrompt.AuthPrompt(this._gdmClient, AuthPrompt.AuthPromptMode.UNLOCK_OR_LOG_IN);
        this._authPrompt.connect('prompted', Lang.bind(this, this._onPrompted));
        this._authPrompt.connect('reset', Lang.bind(this, this._onReset));
        this._authPrompt.hide();
        this.actor.add_child(this._authPrompt.actor);
        // translators: this message is shown below the user list on the
        // login screen. It can be activated to reveal an entry for
        // manually entering the username.
        let notListedLabel = new St.Label({ text: _("Not listed?"),
                                            style_class: 'login-dialog-not-listed-label' });
        this._notListedButton = new St.Button({ style_class: 'login-dialog-not-listed-button',
                                                button_mask: St.ButtonMask.ONE | St.ButtonMask.THREE,
                                                can_focus: true,
                                                child: notListedLabel,
                                                reactive: true,
                                                x_align: St.Align.START,
                                                x_fill: true });
        this._notListedButton.connect('clicked', Lang.bind(this, this._hideUserListAskForUsernameAndBeginVerification));
        this._notListedButton.hide();
        this._userSelectionBox.add(this._notListedButton,
                                   { expand: false,
                                     x_align: St.Align.START,
                                     x_fill: true });
        this._bannerView = new St.ScrollView({ style_class: 'login-dialog-banner-view',
                                               opacity: 0,
                                               vscrollbar_policy: Gtk.PolicyType.AUTOMATIC,
                                               hscrollbar_policy: Gtk.PolicyType.NEVER });
        this.actor.add_child(this._bannerView);
        let bannerBox = new St.BoxLayout({ vertical: true });
        this._bannerView.add_actor(bannerBox);
        this._bannerLabel = new St.Label({ style_class: 'login-dialog-banner',
                                           text: '' });
        this._bannerLabel.clutter_text.line_wrap = true;
        this._bannerLabel.clutter_text.ellipsize = Pango.EllipsizeMode.NONE;
        bannerBox.add_child(this._bannerLabel);
        this._updateBanner();
        this._logoBin = new St.Widget({ style_class: 'login-dialog-logo-bin',
                                        x_align: Clutter.ActorAlign.CENTER,
                                        y_align: Clutter.ActorAlign.END });
        this.actor.add_child(this._logoBin);
        this._updateLogo();
        this._userList.connect('activate',
                               Lang.bind(this, function(userList, item) {
                                   this._onUserListActivated(item);
                               }));
        this._sessionMenuButton = new SessionMenuButton();
        this._sessionMenuButton.connect('session-activated',
                                  Lang.bind(this, function(list, sessionId) {
                                                this._greeter.call_select_session_sync (sessionId, null);
                                            }));
        this._sessionMenuButton.actor.opacity = 0;
        this._sessionMenuButton.actor.show();
        this._authPrompt.addActorToDefaultButtonWell(this._sessionMenuButton.actor);
        this._disableUserList = undefined;
        this._userListLoaded = false;
        this._realmManager = new Realmd.Manager();
        this._realmSignalId = this._realmManager.connect('login-format-changed',
                                                         Lang.bind(this, this._showRealmLoginHint));
        LoginManager.getLoginManager().getCurrentSessionProxy(Lang.bind(this, this._gotGreeterSessionProxy));
        // If the user list is enabled, it should take key focus; make sure the
        // screen shield is initialized first to prevent it from stealing the
        // focus later
        this._startupCompleteId = Main.layoutManager.connect('startup-complete',
                                                             Lang.bind(this, this._updateDisableUserList));
    },
    _getBannerAllocation: function (dialogBox) {
        let actorBox = new Clutter.ActorBox();
        let [minWidth, minHeight, natWidth, natHeight] = this._bannerView.get_preferred_size();
        let centerX = dialogBox.x1 + (dialogBox.x2 - dialogBox.x1) / 2;
        actorBox.x1 = Math.floor(centerX - natWidth / 2);
        actorBox.y1 = dialogBox.y1 + Main.layoutManager.panelBox.height;
        actorBox.x2 = actorBox.x1 + natWidth;
        actorBox.y2 = actorBox.y1 + natHeight;
        return actorBox;
    },
    _getLogoBinAllocation: function (dialogBox) {
        let actorBox = new Clutter.ActorBox();
        let [minWidth, minHeight, natWidth, natHeight] = this._logoBin.get_preferred_size();
        let centerX = dialogBox.x1 + (dialogBox.x2 - dialogBox.x1) / 2;
        actorBox.x1 = Math.floor(centerX - natWidth / 2);
        actorBox.y1 = dialogBox.y2 - natHeight;
        actorBox.x2 = actorBox.x1 + natWidth;
        actorBox.y2 = actorBox.y1 + natHeight;
        return actorBox;
    },
    _getCenterActorAllocation: function (dialogBox, actor) {
        let actorBox = new Clutter.ActorBox();
        let [minWidth, minHeight, natWidth, natHeight] = actor.get_preferred_size();
        let centerX = dialogBox.x1 + (dialogBox.x2 - dialogBox.x1) / 2;
        let centerY = dialogBox.y1 + (dialogBox.y2 - dialogBox.y1) / 2;
        natWidth = Math.min(natWidth, dialogBox.x2 - dialogBox.x1);
        natHeight = Math.min(natHeight, dialogBox.y2 - dialogBox.y1);
        actorBox.x1 = Math.floor(centerX - natWidth / 2);
        actorBox.y1 = Math.floor(centerY - natHeight / 2);
        actorBox.x2 = actorBox.x1 + natWidth;
        actorBox.y2 = actorBox.y1 + natHeight;
        return actorBox;
    },
    _onAllocate: function (actor, dialogBox, flags) {
        let dialogWidth = dialogBox.x2 - dialogBox.x1;
        let dialogHeight = dialogBox.y2 - dialogBox.y1;
        // First find out what space the children require
        let bannerAllocation = null;
        let bannerHeight = 0;
        let bannerWidth = 0;
        if (this._bannerView.visible) {
            bannerAllocation = this._getBannerAllocation(dialogBox, this._bannerView);
            bannerHeight = bannerAllocation.y2 - bannerAllocation.y1;
            bannerWidth = bannerAllocation.x2 - bannerAllocation.x1;
        }
        let authPromptAllocation = null;
        let authPromptHeight = 0;
        let authPromptWidth = 0;
        if (this._authPrompt.actor.visible) {
            authPromptAllocation = this._getCenterActorAllocation(dialogBox, this._authPrompt.actor);
            authPromptHeight = authPromptAllocation.y2 - authPromptAllocation.y1;
            authPromptWidth = authPromptAllocation.x2 - authPromptAllocation.x1;
        }
        let userSelectionAllocation = null;
        let userSelectionHeight = 0;
        if (this._userSelectionBox.visible) {
            userSelectionAllocation = this._getCenterActorAllocation(dialogBox, this._userSelectionBox);
            userSelectionHeight = userSelectionAllocation.y2 - userSelectionAllocation.y1;
        }
        let logoAllocation = null;
        let logoHeight = 0;
        if (this._logoBin.visible) {
            logoAllocation = this._getLogoBinAllocation(dialogBox);
            logoHeight = logoAllocation.y2 - logoAllocation.y1;
        }
        // Then figure out if we're overly constrained and need to
        // try a different layout, or if we have what extra space we
        // can hand out
        if (bannerAllocation) {
            let bannerSpace;
            if (authPromptAllocation)
                bannerSpace = authPromptAllocation.y1 - bannerAllocation.y1;
            else
                bannerSpace = 0;
            let leftOverYSpace = bannerSpace - bannerHeight;
            if (leftOverYSpace > 0) {
                 // First figure out how much left over space is up top
                 let leftOverTopSpace = leftOverYSpace / 2;
                 // Then, shift the banner into the middle of that extra space
                 let yShift = Math.floor(leftOverTopSpace / 2);
                 bannerAllocation.y1 += yShift;
                 bannerAllocation.y2 += yShift;
            } else {
                 // Then figure out how much space there would be if we switched to a
                 // wide layout with banner on one side and authprompt on the other.
                 let leftOverXSpace = dialogWidth - authPromptWidth;
                 // In a wide view, half of the available space goes to the banner,
                 // and the other half goes to the margins.
                 let wideBannerWidth = leftOverXSpace / 2;
                 let wideSpacing  = leftOverXSpace - wideBannerWidth;
                 // If we do go with a wide layout, we need there to be at least enough
                 // space for the banner and the auth prompt to be the same width,
                 // so it doesn't look unbalanced.
                 if (authPromptWidth > 0 && wideBannerWidth > authPromptWidth) {
                     let centerX = dialogBox.x1 + dialogWidth / 2;
                     let centerY = dialogBox.y1 + dialogHeight / 2;
                     // A small portion of the spacing goes down the center of the
                     // screen to help delimit the two columns of the wide view
                     let centerGap = wideSpacing / 8;
                     // place the banner along the left edge of the center margin
                     bannerAllocation.x2 = Math.floor(centerX - centerGap / 2);
                     bannerAllocation.x1 = Math.floor(bannerAllocation.x2 - wideBannerWidth);
                     // figure out how tall it would like to be and try to accomodate
                     // but don't let it get too close to the logo
                     let [wideMinHeight, wideBannerHeight] = this._bannerView.get_preferred_height(wideBannerWidth);
                     let maxWideHeight = dialogHeight - 3 * logoHeight;
                     wideBannerHeight = Math.min(maxWideHeight, wideBannerHeight);
                     bannerAllocation.y1 = Math.floor(centerY - wideBannerHeight / 2);
                     bannerAllocation.y2 = bannerAllocation.y1 + wideBannerHeight;
                     // place the auth prompt along the right edge of the center margin
                     authPromptAllocation.x1 = Math.floor(centerX + centerGap / 2);
                     authPromptAllocation.x2 = authPromptAllocation.x1 + authPromptWidth;
                 } else {
                     // If we aren't going to do a wide view, then we need to limit
                     // the height of the banner so it will present scrollbars
                     // First figure out how much space there is without the banner
                     leftOverYSpace += bannerHeight;
                     // Then figure out how much of that space is up top
                     let availableTopSpace = Math.floor(leftOverYSpace / 2);
                     // Then give all of that space to the banner
                     bannerAllocation.y2 = bannerAllocation.y1 + availableTopSpace;
                 }
            }
        } else if (userSelectionAllocation) {
            // Grow the user list to fill the space
            let leftOverYSpace = dialogHeight - userSelectionHeight - logoHeight;
            if (leftOverYSpace > 0) {
                let topExpansion = Math.floor(leftOverYSpace / 2);
                let bottomExpansion = topExpansion;
                userSelectionAllocation.y1 -= topExpansion;
                userSelectionAllocation.y2 += bottomExpansion;
            }
        }
        // Finally hand out the allocations
        if (bannerAllocation) {
            this._bannerView.allocate(bannerAllocation, flags);
        }
        if (authPromptAllocation)
            this._authPrompt.actor.allocate(authPromptAllocation, flags);
        if (userSelectionAllocation)
            this._userSelectionBox.allocate(userSelectionAllocation, flags);
        if (logoAllocation)
            this._logoBin.allocate(logoAllocation, flags);
    },
    _ensureUserListLoaded: function() {
        if (!this._userManager.is_loaded) {
            this._userManagerLoadedId = this._userManager.connect('notify::is-loaded',
                                                                  Lang.bind(this, function() {
                                                                      if (this._userManager.is_loaded) {
                                                                          this._loadUserList();
                                                                          this._userManager.disconnect(this._userManagerLoadedId);
                                                                          this._userManagerLoadedId = 0;
                                                                      }
                                                                  }));
        } else {
            let id = GLib.idle_add(GLib.PRIORITY_DEFAULT, Lang.bind(this, this._loadUserList));
            GLib.Source.set_name_by_id(id, '[gnome-shell] _loadUserList');
        }
    },
    _updateDisableUserList: function() {
        let disableUserList = this._settings.get_boolean(GdmUtil.DISABLE_USER_LIST_KEY);
        if (disableUserList != this._disableUserList) {
            this._disableUserList = disableUserList;
            if (this._authPrompt.verificationStatus == AuthPrompt.AuthPromptStatus.NOT_VERIFYING)
                this._authPrompt.reset();
        }
    },
    _updateCancelButton: function() {
        let cancelVisible;
        // Hide the cancel button if the user list is disabled and we're asking for
        // a username
        if (this._authPrompt.verificationStatus == AuthPrompt.AuthPromptStatus.NOT_VERIFYING && this._disableUserList)
            cancelVisible = false;
        else
            cancelVisible = true;
        this._authPrompt.cancelButton.visible = cancelVisible;
    },
    _updateBanner: function() {
        let enabled = this._settings.get_boolean(GdmUtil.BANNER_MESSAGE_KEY);
        let text = this._settings.get_string(GdmUtil.BANNER_MESSAGE_TEXT_KEY);
        if (enabled && text) {
            this._bannerLabel.set_text(text);
            this._bannerLabel.show();
        } else {
            this._bannerLabel.hide();
        }
    },
    _fadeInBannerView: function() {
        this._bannerView.show();
        Tweener.addTween(this._bannerView,
                         { opacity: 255,
                           time: _FADE_ANIMATION_TIME,
                           transition: 'easeOutQuad' });
    },
    _hideBannerView: function() {
        Tweener.removeTweens(this._bannerView);
        this._bannerView.opacity = 0;
        this._bannerView.hide();
    },
    _updateLogoTexture: function(cache, file) {
        if (this._logoFile && !this._logoFile.equal(file))
            return;
        this._logoBin.destroy_all_children();
        if (this._logoFile) {
            let scaleFactor = St.ThemeContext.get_for_stage(global.stage).scale_factor;
            this._logoBin.add_child(this._textureCache.load_file_async(this._logoFile,
                                                                       -1, _LOGO_ICON_HEIGHT,
                                                                       scaleFactor));
        }
    },
    _updateLogo: function() {
        let path = this._settings.get_string(GdmUtil.LOGO_KEY);
        this._logoFile = path ? Gio.file_new_for_path(path) : null;
        this._updateLogoTexture(this._textureCache, this._logoFile);
    },
    _onPrompted: function() {
        this._sessionMenuButton.updateSensitivity(true);
        if (this._shouldShowSessionMenuButton())
            this._authPrompt.setActorInDefaultButtonWell(this._sessionMenuButton.actor);
        this._showPrompt();
    },
    _resetGreeterProxy: function() {
        if (GLib.getenv('GDM_GREETER_TEST') != '1') {
            if (this._greeter) {
                this._greeter.run_dispose();
            }
            this._greeter = this._gdmClient.get_greeter_sync(null);
            this._defaultSessionChangedId = this._greeter.connect('default-session-name-changed',
                                                                  Lang.bind(this, this._onDefaultSessionChanged));
            this._sessionOpenedId = this._greeter.connect('session-opened',
                                                          Lang.bind(this, this._onSessionOpened));
            this._timedLoginRequestedId = this._greeter.connect('timed-login-requested',
                                                                Lang.bind(this, this._onTimedLoginRequested));
        }
    },
    _onReset: function(authPrompt, beginRequest) {
        this._resetGreeterProxy();
        this._sessionMenuButton.updateSensitivity(true);
        this._user = null;
        if (this._nextSignalId) {
            this._authPrompt.disconnect(this._nextSignalId);
            this._nextSignalId = 0;
        }
        if (beginRequest == AuthPrompt.BeginRequestType.PROVIDE_USERNAME) {
            if (!this._disableUserList)
                this._showUserList();
            else
                this._hideUserListAskForUsernameAndBeginVerification();
        } else {
            this._hideUserListAndBeginVerification();
        }
    },
    _onDefaultSessionChanged: function(client, sessionId) {
        this._sessionMenuButton.setActiveSession(sessionId);
    },
    _shouldShowSessionMenuButton: function() {
        if (this._authPrompt.verificationStatus != AuthPrompt.AuthPromptStatus.VERIFYING &&
            this._authPrompt.verificationStatus != AuthPrompt.AuthPromptStatus.VERIFICATION_FAILED)
          return false;
        if (this._user && this._user.is_loaded && this._user.is_logged_in())
          return false;
        return true;
    },
    _showPrompt: function() {
        if (this._authPrompt.actor.visible)
            return;
        this._authPrompt.actor.opacity = 0;
        this._authPrompt.actor.show();
        Tweener.addTween(this._authPrompt.actor,
                         { opacity: 255,
                           time: _FADE_ANIMATION_TIME,
                           transition: 'easeOutQuad' });
        this._fadeInBannerView();
    },
    _showRealmLoginHint: function(realmManager, hint) {
        if (!hint)
            return;
        hint = hint.replace(/%U/g, 'user');
        hint = hint.replace(/%D/g, 'DOMAIN');
        hint = hint.replace(/%[^UD]/g, '');
        // Translators: this message is shown below the username entry field
        // to clue the user in on how to login to the local network realm
        this._authPrompt.setMessage(_("(e.g., user or %s)").format(hint), GdmUtil.MessageType.HINT);
    },
    _askForUsernameAndBeginVerification: function() {
        this._authPrompt.setPasswordChar('');
        this._authPrompt.setQuestion(_("Username: "));
        this._showRealmLoginHint(this._realmManager.loginFormat);
        if (this._nextSignalId)
            this._authPrompt.disconnect(this._nextSignalId);
        this._nextSignalId = this._authPrompt.connect('next',
                                                      Lang.bind(this, function() {
                                                          this._authPrompt.disconnect(this._nextSignalId);
                                                          this._nextSignalId = 0;
                                                          this._authPrompt.updateSensitivity(false);
                                                          let answer = this._authPrompt.getAnswer();
                                                          this._user = this._userManager.get_user(answer);
                                                          this._authPrompt.clear();
                                                          this._authPrompt.startSpinning();
                                                          this._authPrompt.begin({ userName: answer });
                                                          this._updateCancelButton();
                                                      }));
        this._updateCancelButton();
        this._authPrompt.updateSensitivity(true);
        this._showPrompt();
    },
    _loginScreenSessionActivated: function() {
        if (this.actor.opacity == 255 && this._authPrompt.verificationStatus == AuthPrompt.AuthPromptStatus.NOT_VERIFYING)
            return;
        Tweener.addTween(this.actor,
                         { opacity: 255,
                           time: _FADE_ANIMATION_TIME,
                           transition: 'easeOutQuad',
                           onUpdate: function() {
                               let children = Main.layoutManager.uiGroup.get_children();
                               for (let i = 0; i < children.length; i++) {
                                   if (children[i] != Main.layoutManager.screenShieldGroup)
                                       children[i].opacity = this.actor.opacity;
                               }
                           },
                           onUpdateScope: this,
                           onComplete: function() {
                               if (this._authPrompt.verificationStatus != AuthPrompt.AuthPromptStatus.NOT_VERIFYING)
                                   this._authPrompt.reset();
                           },
                           onCompleteScope: this });
    },
    _gotGreeterSessionProxy: function(proxy) {
        this._greeterSessionProxy = proxy;
        this._greeterSessionProxyChangedId =
            proxy.connect('g-properties-changed', Lang.bind(this, function() {
                if (proxy.Active)
                    this._loginScreenSessionActivated();
            }));
    },
    _startSession: function(serviceName) {
        Tweener.addTween(this.actor,
                         { opacity: 0,
                           time: _FADE_ANIMATION_TIME,
                           transition: 'easeOutQuad',
                           onUpdate: function() {
                               let children = Main.layoutManager.uiGroup.get_children();
                               for (let i = 0; i < children.length; i++) {
                                   if (children[i] != Main.layoutManager.screenShieldGroup)
                                       children[i].opacity = this.actor.opacity;
                               }
                           },
                           onUpdateScope: this,
                           onComplete: function() {
                               this._greeter.call_start_session_when_ready_sync(serviceName, true, null);
                           },
                           onCompleteScope: this });
    },
    _onSessionOpened: function(client, serviceName) {
        this._authPrompt.finish(Lang.bind(this, function() {
            this._startSession(serviceName);
        }));
    },
    _waitForItemForUser: function(userName) {
        let item = this._userList.getItemFromUserName(userName);
        if (item)
          return null;
        let hold = new Batch.Hold();
        let signalId = this._userList.connect('item-added',
                                              Lang.bind(this, function() {
                                                  let item = this._userList.getItemFromUserName(userName);
                                                  if (item)
                                                      hold.release();
                                              }));
        hold.connect('release', Lang.bind(this, function() {
                         this._userList.disconnect(signalId);
                     }));
        return hold;
    },
    _showTimedLoginAnimation: function() {
        this._timedLoginItem.actor.grab_key_focus();
        return this._timedLoginItem.showTimedLoginIndicator(this._timedLoginAnimationTime);
    },
    _blockTimedLoginUntilIdle: function() {
        // This blocks timed login from starting until a few
        // seconds after the user stops interacting with the
        // login screen.
        //
        // We skip this step if the timed login delay is very
        // short.
        if ((this._timedLoginDelay - _TIMED_LOGIN_IDLE_THRESHOLD) <= 0)
          return null;
        let hold = new Batch.Hold();
        this._timedLoginIdleTimeOutId = Mainloop.timeout_add_seconds(_TIMED_LOGIN_IDLE_THRESHOLD,
                                                                     function() {
                                                                         this._timedLoginAnimationTime -= _TIMED_LOGIN_IDLE_THRESHOLD;
                                                                         hold.release();
                                                                         return GLib.SOURCE_REMOVE;
                                                                     });
        GLib.Source.set_name_by_id(this._timedLoginIdleTimeOutId, '[gnome-shell] this._timedLoginAnimationTime');
        return hold;
    },
    _startTimedLogin: function(userName, delay) {
        this._timedLoginItem = null;
        this._timedLoginDelay = delay;
        this._timedLoginAnimationTime = delay;
        let tasks = [function() {
                         return this._waitForItemForUser(userName);
                     },
                     function() {
                         this._timedLoginItem = this._userList.getItemFromUserName(userName);
                     },
                     function() {
                         // If we're just starting out, start on the right
                         // item.
                         if (!this._userManager.is_loaded) {
                             this._userList.jumpToItem(this._timedLoginItem);
                         }
                     },
                     this._blockTimedLoginUntilIdle,
                     function() {
                         this._userList.scrollToItem(this._timedLoginItem);
                     },
                     this._showTimedLoginAnimation,
                     function() {
                         this._timedLoginBatch = null;
                         this._greeter.call_begin_auto_login_sync(userName, null);
                     }];
        this._timedLoginBatch = new Batch.ConsecutiveBatch(this, tasks);
        return this._timedLoginBatch.run();
    },
    _resetTimedLogin: function() {
        if (this._timedLoginBatch) {
            this._timedLoginBatch.cancel();
            this._timedLoginBatch = null;
        }
        if (this._timedLoginItem)
            this._timedLoginItem.hideTimedLoginIndicator();
        let userName = this._timedLoginItem.user.get_user_name();
        if (userName)
            this._startTimedLogin(userName, this._timedLoginDelay);
    },
    _onTimedLoginRequested: function(client, userName, seconds) {
        this._startTimedLogin(userName, seconds);
        global.stage.connect('captured-event',
                             Lang.bind(this, function(actor, event) {
                                if (this._timedLoginDelay == undefined)
                                    return Clutter.EVENT_PROPAGATE;
                                if (event.type() == Clutter.EventType.KEY_PRESS ||
                                    event.type() == Clutter.EventType.BUTTON_PRESS) {
                                    if (this._timedLoginBatch) {
                                        this._timedLoginBatch.cancel();
                                        this._timedLoginBatch = null;
                                    }
                                } else if (event.type() == Clutter.EventType.KEY_RELEASE ||
                                           event.type() == Clutter.EventType.BUTTON_RELEASE) {
                                    this._resetTimedLogin();
                                }
                                return Clutter.EVENT_PROPAGATE;
                             }));
    },
    _setUserListExpanded: function(expanded) {
        this._userList.updateStyle(expanded);
        this._userSelectionBox.visible = expanded;
    },
    _hideUserList: function() {
        this._setUserListExpanded(false);
        if (this._userSelectionBox.visible)
            GdmUtil.cloneAndFadeOutActor(this._userSelectionBox);
    },
    _hideUserListAskForUsernameAndBeginVerification: function() {
        this._hideUserList();
        this._askForUsernameAndBeginVerification();
    },
    _hideUserListAndBeginVerification: function() {
        this._hideUserList();
        this._authPrompt.begin();
    },
    _showUserList: function() {
        this._ensureUserListLoaded();
        this._authPrompt.hide();
        this._hideBannerView();
        this._sessionMenuButton.close();
        this._setUserListExpanded(true);
        this._notListedButton.show();
        this._userList.actor.grab_key_focus();
    },
    _beginVerificationForItem: function(item) {
        this._authPrompt.setUser(item.user);
        let userName = item.user.get_user_name();
        let hold = new Batch.Hold();
        this._authPrompt.begin({ userName: userName,
                                 hold: hold });
        return hold;
    },
    _onUserListActivated: function(activatedItem) {
        this._user = activatedItem.user;
        this._updateCancelButton();
        let batch = new Batch.ConcurrentBatch(this, [GdmUtil.cloneAndFadeOutActor(this._userSelectionBox),
                                                     this._beginVerificationForItem(activatedItem)]);
        batch.run();
    },
    _onDestroy: function() {
        if (this._userManagerLoadedId) {
            this._userManager.disconnect(this._userManagerLoadedId);
            this._userManagerLoadedId = 0;
        }
        if (this._userAddedId) {
            this._userManager.disconnect(this._userAddedId);
            this._userAddedId = 0;
        }
        if (this._userRemovedId) {
            this._userManager.disconnect(this._userRemovedId);
            this._userRemovedId = 0;
        }
        if (this._userChangedId) {
            this._userManager.disconnect(this._userChangedId);
            this._userChangedId = 0;
        }
        this._textureCache.disconnect(this._updateLogoTextureId);
        Main.layoutManager.disconnect(this._startupCompleteId);
        if (this._settings) {
            this._settings.run_dispose();
            this._settings = null;
        }
        if (this._greeter) {
            this._greeter.disconnect(this._defaultSessionChangedId);
            this._greeter.disconnect(this._sessionOpenedId);
            this._greeter.disconnect(this._timedLoginRequestedId);
            this._greeter = null;
        }
        if (this._greeterSessionProxy) {
            this._greeterSessionProxy.disconnect(this._greeterSessionProxyChangedId);
            this._greeterSessionProxy = null;
        }
        if (this._realmManager) {
            this._realmManager.disconnect(this._realmSignalId);
            this._realmSignalId = 0;
            this._realmManager.release();
            this._realmManager = null;
        }
    },
    _loadUserList: function() {
        if (this._userListLoaded)
            return GLib.SOURCE_REMOVE;
        this._userListLoaded = true;
        let users = this._userManager.list_users();
        for (let i = 0; i < users.length; i++) {
            this._userList.addUser(users[i]);
        }
        this._userAddedId = this._userManager.connect('user-added',
                                                      Lang.bind(this, function(userManager, user) {
                                                          this._userList.addUser(user);
                                                      }));
        this._userRemovedId = this._userManager.connect('user-removed',
                                                        Lang.bind(this, function(userManager, user) {
                                                            this._userList.removeUser(user);
                                                        }));
        this._userChangedId = this._userManager.connect('user-changed',
                                                        Lang.bind(this, function(userManager, user) {
                                                            if (this._userList.containsUser(user) && user.locked)
                                                                this._userList.removeUser(user);
                                                            else if (!this._userList.containsUser(user) && !user.locked)
                                                                this._userList.addUser(user);
                                                        }));
        return GLib.SOURCE_REMOVE;
    },
    open: function() {
        Main.ctrlAltTabManager.addGroup(this.actor,
                                        _("Login Window"),
                                        'dialog-password-symbolic',
                                        { sortGroup: CtrlAltTab.SortGroup.MIDDLE });
        this._userList.actor.grab_key_focus();
        this.actor.show();
        this.actor.opacity = 0;
        Main.pushModal(this.actor, { actionMode: Shell.ActionMode.LOGIN_SCREEN });
        Tweener.addTween(this.actor,
                         { opacity: 255,
                           time: 1,
                           transition: 'easeInQuad' });
        return true;
    },
    close: function() {
        Main.popModal(this.actor);
        Main.ctrlAltTabManager.removeGroup(this.actor);
    },
    cancel: function() {
        this._authPrompt.cancel();
    },
    addCharacter: function(unichar) {
        this._authPrompt.addCharacter(unichar);
    },
    finish: function(onComplete) {
        this._authPrompt.finish(onComplete);
    },
Signals.addSignalMethods(LoginDialog.prototype);
(uuay)ibusManager.js
// -*- mode: js; js-indent-level: 4; indent-tabs-mode: nil -*-
const Gio = imports.gi.Gio;
const GLib = imports.gi.GLib;
const Lang = imports.lang;
const Mainloop = imports.mainloop;
const Signals = imports.signals;
try {
    var IBus = imports.gi.IBus;
    _checkIBusVersion(1, 5, 2);
    const IBusCandidatePopup = imports.ui.ibusCandidatePopup;
} catch (e) {
    var IBus = null;
    log(e);
let _ibusManager = null;
function _checkIBusVersion(requiredMajor, requiredMinor, requiredMicro) {
    if ((IBus.MAJOR_VERSION > requiredMajor) ||
        (IBus.MAJOR_VERSION == requiredMajor && IBus.MINOR_VERSION > requiredMinor) ||
        (IBus.MAJOR_VERSION == requiredMajor && IBus.MINOR_VERSION == requiredMinor &&
         IBus.MICRO_VERSION >= requiredMicro))
        return;
    throw "Found IBus version %d.%d.%d but required is %d.%d.%d".
        format(IBus.MAJOR_VERSION, IBus.MINOR_VERSION, IBus.MINOR_VERSION,
               requiredMajor, requiredMinor, requiredMicro);
function getIBusManager() {
    if (_ibusManager == null)
        _ibusManager = new IBusManager();
    return _ibusManager;
const IBusManager = new Lang.Class({
    Name: 'IBusManager',
    // This is the longest we'll keep the keyboard frozen until an input
    // source is active.
    _MAX_INPUT_SOURCE_ACTIVATION_TIME: 4000, // ms
    _PRELOAD_ENGINES_DELAY_TIME: 30, // sec
    _init: function() {
        if (!IBus)
            return;
        IBus.init();
        this._candidatePopup = new IBusCandidatePopup.CandidatePopup();
        this._panelService = null;
        this._engines = {};
        this._ready = false;
        this._registerPropertiesId = 0;
        this._currentEngineName = null;
        this._preloadEnginesId = 0;
        this._ibus = IBus.Bus.new_async();
        this._ibus.connect('connected', Lang.bind(this, this._onConnected));
        this._ibus.connect('disconnected', Lang.bind(this, this._clear));
        // Need to set this to get 'global-engine-changed' emitions
        this._ibus.set_watch_ibus_signal(true);
        this._ibus.connect('global-engine-changed', Lang.bind(this, this._engineChanged));
        this._spawn();
    },
    _spawn: function() {
        try {
            Gio.Subprocess.new(['ibus-daemon', '--xim', '--panel', 'disable'],
                               Gio.SubprocessFlags.NONE);
        } catch(e) {
            log('Failed to launch ibus-daemon: ' + e.message);
        }
    },
    _clear: function() {
        if (this._panelService)
            this._panelService.destroy();
        this._panelService = null;
        this._candidatePopup.setPanelService(null);
        this._engines = {};
        this._ready = false;
        this._registerPropertiesId = 0;
        this._currentEngineName = null;
        this.emit('ready', false);
        this._spawn();
    },
    _onConnected: function() {
        this._ibus.list_engines_async(-1, null, Lang.bind(this, this._initEngines));
        this._ibus.request_name_async(IBus.SERVICE_PANEL,
                                      IBus.BusNameFlag.REPLACE_EXISTING,
                                      -1, null,
                                      Lang.bind(this, this._initPanelService));
    },
    _initEngines: function(ibus, result) {
        let enginesList = this._ibus.list_engines_async_finish(result);
        if (enginesList) {
            for (let i = 0; i < enginesList.length; ++i) {
                let name = enginesList[i].get_name();
                this._engines[name] = enginesList[i];
            }
            this._updateReadiness();
        } else {
            this._clear();
        }
    },
    _initPanelService: function(ibus, result) {
        let success = this._ibus.request_name_async_finish(result);
        if (success) {
            this._panelService = new IBus.PanelService({ connection: this._ibus.get_connection(),
                                                         object_path: IBus.PATH_PANEL });
            this._candidatePopup.setPanelService(this._panelService);
            this._panelService.connect('update-property', Lang.bind(this, this._updateProperty));
            try {
                // IBus versions older than 1.5.10 have a bug which
                // causes spurious set-content-type emissions when
                // switching input focus that temporarily lose purpose
                // and hints defeating its intended semantics and
                // confusing users. We thus don't use it in that case.
                _checkIBusVersion(1, 5, 10);
                this._panelService.connect('set-content-type', Lang.bind(this, this._setContentType));
            } catch (e) {
            }
            // If an engine is already active we need to get its properties
            this._ibus.get_global_engine_async(-1, null, Lang.bind(this, function(i, result) {
                let engine;
                try {
                    engine = this._ibus.get_global_engine_async_finish(result);
                    if (!engine)
                        return;
                } catch(e) {
                    return;
                }
                this._engineChanged(this._ibus, engine.get_name());
            }));
            this._updateReadiness();
        } else {
            this._clear();
        }
    },
    _updateReadiness: function() {
        this._ready = (Object.keys(this._engines).length > 0 &&
                       this._panelService != null);
        this.emit('ready', this._ready);
    },
    _engineChanged: function(bus, engineName) {
        if (!this._ready)
            return;
        this._currentEngineName = engineName;
        if (this._registerPropertiesId != 0)
            return;
        this._registerPropertiesId =
            this._panelService.connect('register-properties', Lang.bind(this, function(p, props) {
                if (!props.get(0))
                    return;
                this._panelService.disconnect(this._registerPropertiesId);
                this._registerPropertiesId = 0;
                this.emit('properties-registered', this._currentEngineName, props);
            }));
    },
    _updateProperty: function(panel, prop) {
        this.emit('property-updated', this._currentEngineName, prop);
    },
    _setContentType: function(panel, purpose, hints) {
        this.emit('set-content-type', purpose, hints);
    },
    activateProperty: function(key, state) {
        this._panelService.property_activate(key, state);
    },
    getEngineDesc: function(id) {
        if (!IBus || !this._ready)
            return null;
        return this._engines[id];
    },
    setEngine: function(id, callback) {
        // Send id even if id == this._currentEngineName
        // because 'properties-registered' signal can be emitted
        // while this._ibusSources == null on a lock screen.
        if (!IBus || !this._ready) {
            if (callback)
                callback();
            return;
        }
        this._ibus.set_global_engine_async(id, this._MAX_INPUT_SOURCE_ACTIVATION_TIME,
                                           null, callback);
    },
    preloadEngines: function(ids) {
        if (!IBus || !this._ibus || ids.length == 0)
            return;
        if (this._preloadEnginesId != 0) {
            Mainloop.source_remove(this._preloadEnginesId);
            this._preloadEnginesId = 0;
        }
        this._preloadEnginesId =
            Mainloop.timeout_add_seconds(this._PRELOAD_ENGINES_DELAY_TIME,
                                         Lang.bind(this, function() {
                                             this._ibus.preload_engines_async(
                                                 ids,
                                                 -1,
                                                 null,
                                                 null);
                                             this._preloadEnginesId = 0;
                                             return GLib.SOURCE_REMOVE;
                                         }));
    },
Signals.addSignalMethods(IBusManager.prototype);
(uuay)lookingGlass.js
// -*- mode: js; js-indent-level: 4; indent-tabs-mode: nil -*-
const Clutter = imports.gi.Clutter;
const Cogl = imports.gi.Cogl;
const GLib = imports.gi.GLib;
const Gio = imports.gi.Gio;
const Gtk = imports.gi.Gtk;
const Meta = imports.gi.Meta;
const Pango = imports.gi.Pango;
const St = imports.gi.St;
const Shell = imports.gi.Shell;
const Signals = imports.signals;
const Lang = imports.lang;
const Mainloop = imports.mainloop;
const System = imports.system;
const History = imports.misc.history;
const ExtensionSystem = imports.ui.extensionSystem;
const ExtensionUtils = imports.misc.extensionUtils;
const ShellEntry = imports.ui.shellEntry;
const Tweener = imports.ui.tweener;
const Main = imports.ui.main;
const JsParse = imports.misc.jsParse;
const CHEVRON = '>>> ';
/* Imports...feel free to add here as needed */
var commandHeader = 'const Clutter = imports.gi.Clutter; ' +
                    'const GLib = imports.gi.GLib; ' +
                    'const GObject = imports.gi.GObject; ' +
                    'const Gio = imports.gi.Gio; ' +
                    'const Gtk = imports.gi.Gtk; ' +
                    'const Mainloop = imports.mainloop; ' +
                    'const Meta = imports.gi.Meta; ' +
                    'const Shell = imports.gi.Shell; ' +
                    'const Tp = imports.gi.TelepathyGLib; ' +
                    'const Main = imports.ui.main; ' +
                    'const Lang = imports.lang; ' +
                    'const Tweener = imports.ui.tweener; ' +
                    /* Utility functions...we should probably be able to use these
                     * in the shell core code too. */
                    'const stage = global.stage; ' +
                    /* Special lookingGlass functions */
                    'const inspect = Lang.bind(Main.lookingGlass, Main.lookingGlass.inspect); ' +
                    'const it = Main.lookingGlass.getIt(); ' +
                    'const r = Lang.bind(Main.lookingGlass, Main.lookingGlass.getResult); ';
const HISTORY_KEY = 'looking-glass-history';
// Time between tabs for them to count as a double-tab event
const AUTO_COMPLETE_DOUBLE_TAB_DELAY = 500;
const AUTO_COMPLETE_SHOW_COMPLETION_ANIMATION_DURATION = 0.2;
const AUTO_COMPLETE_GLOBAL_KEYWORDS = _getAutoCompleteGlobalKeywords();
function _getAutoCompleteGlobalKeywords() {
    const keywords = ['true', 'false', 'null', 'new'];
    // Don't add the private properties of window (i.e., ones starting with '_')
    const windowProperties = Object.getOwnPropertyNames(window).filter(function(a){ return a.charAt(0) != '_' });
    const headerProperties = JsParse.getDeclaredConstants(commandHeader);
    return keywords.concat(windowProperties).concat(headerProperties);
const AutoComplete = new Lang.Class({
    Name: 'AutoComplete',
    _init: function(entry) {
        this._entry = entry;
        this._entry.connect('key-press-event', Lang.bind(this, this._entryKeyPressEvent));
        this._lastTabTime = global.get_current_time();
    },
    _processCompletionRequest: function(event) {
        if (event.completions.length == 0) {
            return;
        }
        // Unique match = go ahead and complete; multiple matches + single tab = complete the common starting string;
        // multiple matches + double tab = emit a suggest event with all possible options
        if (event.completions.length == 1) {
            this.additionalCompletionText(event.completions[0], event.attrHead);
            this.emit('completion', { completion: event.completions[0], type: 'whole-word' });
        } else if (event.completions.length > 1 && event.tabType === 'single') {
            let commonPrefix = JsParse.getCommonPrefix(event.completions);
            if (commonPrefix.length > 0) {
                this.additionalCompletionText(commonPrefix, event.attrHead);
                this.emit('completion', { completion: commonPrefix, type: 'prefix' });
                this.emit('suggest', { completions: event.completions});
            }
        } else if (event.completions.length > 1 && event.tabType === 'double') {
            this.emit('suggest', { completions: event.completions});
        }
    },
    _entryKeyPressEvent: function(actor, event) {
        let cursorPos = this._entry.clutter_text.get_cursor_position();
        let text = this._entry.get_text();
        if (cursorPos != -1) {
            text = text.slice(0, cursorPos);
        }
        if (event.get_key_symbol() == Clutter.Tab) {
            let [completions, attrHead] = JsParse.getCompletions(text, commandHeader, AUTO_COMPLETE_GLOBAL_KEYWORDS);
            let currTime = global.get_current_time();
            if ((currTime - this._lastTabTime) < AUTO_COMPLETE_DOUBLE_TAB_DELAY) {
                this._processCompletionRequest({ tabType: 'double',
                                                 completions: completions,
                                                 attrHead: attrHead });
            } else {
                this._processCompletionRequest({ tabType: 'single',
                                                 completions: completions,
                                                 attrHead: attrHead });
            }
            this._lastTabTime = currTime;
        }
        return Clutter.EVENT_PROPAGATE;
    },
    // Insert characters of text not already included in head at cursor position.  i.e., if text="abc" and head="a",
    // the string "bc" will be appended to this._entry
    additionalCompletionText: function(text, head) {
        let additionalCompletionText = text.slice(head.length);
        let cursorPos = this._entry.clutter_text.get_cursor_position();
        this._entry.clutter_text.insert_text(additionalCompletionText, cursorPos);
    }
Signals.addSignalMethods(AutoComplete.prototype);
const Notebook = new Lang.Class({
    Name: 'Notebook',
    _init: function() {
        this.actor = new St.BoxLayout({ vertical: true });
        this.tabControls = new St.BoxLayout({ style_class: 'labels' });
        this._selectedIndex = -1;
        this._tabs = [];
    },
    appendPage: function(name, child) {
        let labelBox = new St.BoxLayout({ style_class: 'notebook-tab',
                                          reactive: true,
                                          track_hover: true });
        let label = new St.Button({ label: name });
        label.connect('clicked', Lang.bind(this, function () {
            this.selectChild(child);
            return true;
        }));
        labelBox.add(label, { expand: true });
        this.tabControls.add(labelBox);
        let scrollview = new St.ScrollView({ x_fill: true, y_fill: true });
        scrollview.get_hscroll_bar().hide();
        scrollview.add_actor(child);
        let tabData = { child: child,
                        labelBox: labelBox,
                        label: label,
                        scrollView: scrollview,
                        _scrollToBottom: false };
        this._tabs.push(tabData);
        scrollview.hide();
        this.actor.add(scrollview, { expand: true });
        let vAdjust = scrollview.vscroll.adjustment;
        vAdjust.connect('changed', Lang.bind(this, function () { this._onAdjustScopeChanged(tabData); }));
        vAdjust.connect('notify::value', Lang.bind(this, function() { this._onAdjustValueChanged(tabData); }));
        if (this._selectedIndex == -1)
            this.selectIndex(0);
    },
    _unselect: function() {
        if (this._selectedIndex < 0)
            return;
        let tabData = this._tabs[this._selectedIndex];
        tabData.labelBox.remove_style_pseudo_class('selected');
        tabData.scrollView.hide();
        this._selectedIndex = -1;
    },
    selectIndex: function(index) {
        if (index == this._selectedIndex)
            return;
        if (index < 0) {
            this._unselect();
            this.emit('selection', null);
            return;
        }
        // Focus the new tab before unmapping the old one
        let tabData = this._tabs[index];
        if (!tabData.scrollView.navigate_focus(null, Gtk.DirectionType.TAB_FORWARD, false))
            this.actor.grab_key_focus();
        this._unselect();
        tabData.labelBox.add_style_pseudo_class('selected');
        tabData.scrollView.show();
        this._selectedIndex = index;
        this.emit('selection', tabData.child);
    },
    selectChild: function(child) {
        if (child == null)
            this.selectIndex(-1);
        else {
            for (let i = 0; i < this._tabs.length; i++) {
                let tabData = this._tabs[i];
                if (tabData.child == child) {
                    this.selectIndex(i);
                    return;
                }
            }
        }
    },
    scrollToBottom: function(index) {
        let tabData = this._tabs[index];
        tabData._scrollToBottom = true;
    },
    _onAdjustValueChanged: function (tabData) {
        let vAdjust = tabData.scrollView.vscroll.adjustment;
        if (vAdjust.value < (vAdjust.upper - vAdjust.lower - 0.5))
            tabData._scrolltoBottom = false;
    },
    _onAdjustScopeChanged: function (tabData) {
        if (!tabData._scrollToBottom)
            return;
        let vAdjust = tabData.scrollView.vscroll.adjustment;
        vAdjust.value = vAdjust.upper - vAdjust.page_size;
    },
    nextTab: function() {
        let nextIndex = this._selectedIndex;
        if (nextIndex < this._tabs.length - 1) {
            ++nextIndex;
        }
        this.selectIndex(nextIndex);
    },
    prevTab: function() {
        let prevIndex = this._selectedIndex;
        if (prevIndex > 0) {
            --prevIndex;
        }
        this.selectIndex(prevIndex);
    }
Signals.addSignalMethods(Notebook.prototype);
function objectToString(o) {
    if (typeof(o) == typeof(objectToString)) {
        // special case this since the default is way, way too verbose
        return '<js function>';
    } else {
        return '' + o;
    }
const ObjLink = new Lang.Class({
    Name: 'ObjLink',
    _init: function(lookingGlass, o, title) {
        let text;
        if (title)
            text = title;
        else
            text = objectToString(o);
        text = GLib.markup_escape_text(text, -1);
        this._obj = o;
        this.actor = new St.Button({ reactive: true,
                                     track_hover: true,
                                     style_class: 'shell-link',
                                     label: text });
        this.actor.get_child().single_line_mode = true;
        this.actor.connect('clicked', Lang.bind(this, this._onClicked));
        this._lookingGlass = lookingGlass;
    },
    _onClicked: function (link) {
        this._lookingGlass.inspectObject(this._obj, this.actor);
    }
const Result = new Lang.Class({
    Name: 'Result',
    _init: function(lookingGlass, command, o, index) {
        this.index = index;
        this.o = o;
        this.actor = new St.BoxLayout({ vertical: true });
        this._lookingGlass = lookingGlass;
        let cmdTxt = new St.Label({ text: command });
        cmdTxt.clutter_text.ellipsize = Pango.EllipsizeMode.END;
        this.actor.add(cmdTxt);
        let box = new St.BoxLayout({});
        this.actor.add(box);
        let resultTxt = new St.Label({ text: 'r(' + index + ') = ' });
        resultTxt.clutter_text.ellipsize = Pango.EllipsizeMode.END;
        box.add(resultTxt);
        let objLink = new ObjLink(this._lookingGlass, o);
        box.add(objLink.actor);
    }
const WindowList = new Lang.Class({
    Name: 'WindowList',
    _init: function(lookingGlass) {
        this.actor = new St.BoxLayout({ name: 'Windows', vertical: true, style: 'spacing: 8px' });
        let tracker = Shell.WindowTracker.get_default();
        this._updateId = Main.initializeDeferredWork(this.actor, Lang.bind(this, this._updateWindowList));
        global.display.connect('window-created', Lang.bind(this, this._updateWindowList));
        tracker.connect('tracked-windows-changed', Lang.bind(this, this._updateWindowList));
        this._lookingGlass = lookingGlass;
    },
    _updateWindowList: function() {
        this.actor.destroy_all_children();
        let windows = global.get_window_actors();
        let tracker = Shell.WindowTracker.get_default();
        for (let i = 0; i < windows.length; i++) {
            let metaWindow = windows[i].metaWindow;
            // Avoid multiple connections
            if (!metaWindow._lookingGlassManaged) {
                metaWindow.connect('unmanaged', Lang.bind(this, this._updateWindowList));
                metaWindow._lookingGlassManaged = true;
            }
            let box = new St.BoxLayout({ vertical: true });
            this.actor.add(box);
            let windowLink = new ObjLink(this._lookingGlass, metaWindow, metaWindow.title);
            box.add(windowLink.actor, { x_align: St.Align.START, x_fill: false });
            let propsBox = new St.BoxLayout({ vertical: true, style: 'padding-left: 6px;' });
            box.add(propsBox);
            propsBox.add(new St.Label({ text: 'wmclass: ' + metaWindow.get_wm_class() }));
            let app = tracker.get_window_app(metaWindow);
            if (app != null && !app.is_window_backed()) {
                let icon = app.create_icon_texture(22);
                let propBox = new St.BoxLayout({ style: 'spacing: 6px; ' });
                propsBox.add(propBox);
                propBox.add(new St.Label({ text: 'app: ' }), { y_fill: false });
                let appLink = new ObjLink(this._lookingGlass, app, app.get_id());
                propBox.add(appLink.actor, { y_fill: false });
                propBox.add(icon, { y_fill: false });
            } else {
                propsBox.add(new St.Label({ text: '<untracked>' }));
            }
        }
    }
Signals.addSignalMethods(WindowList.prototype);
const ObjInspector = new Lang.Class({
    Name: 'ObjInspector',
    _init: function(lookingGlass) {
        this._obj = null;
        this._previousObj = null;
        this._parentList = [];
        this.actor = new St.ScrollView({ pivot_point: new Clutter.Point({ x: 0.5, y: 0.5 }),
                                         x_fill: true, y_fill: true });
        this.actor.get_hscroll_bar().hide();
        this._container = new St.BoxLayout({ name: 'LookingGlassPropertyInspector',
                                             style_class: 'lg-dialog',
                                             vertical: true });
        this.actor.add_actor(this._container);
        this._lookingGlass = lookingGlass;
    },
    selectObject: function(obj, skipPrevious) {
        if (!skipPrevious)
            this._previousObj = this._obj;
        else
            this._previousObj = null;
        this._obj = obj;
        this._container.destroy_all_children();
        let hbox = new St.BoxLayout({ style_class: 'lg-obj-inspector-title' });
        this._container.add_actor(hbox);
        let label = new St.Label({ text: 'Inspecting: %s: %s'.format(typeof(obj),
                                                                     objectToString(obj)) });
        label.single_line_mode = true;
        hbox.add(label, { expand: true, y_fill: false });
        let button = new St.Button({ label: 'Insert', style_class: 'lg-obj-inspector-button' });
        button.connect('clicked', Lang.bind(this, this._onInsert));
        hbox.add(button);
        if (this._previousObj != null) {
            button = new St.Button({ label: 'Back', style_class: 'lg-obj-inspector-button' });
            button.connect('clicked', Lang.bind(this, this._onBack));
            hbox.add(button);
        }
        button = new St.Button({ style_class: 'window-close' });
        button.connect('clicked', Lang.bind(this, this.close));
        hbox.add(button);
        if (typeof(obj) == typeof({})) {
            let properties = [];
            for (let propName in obj) {
                properties.push(propName);
            }
            properties.sort();
            for (let i = 0; i < properties.length; i++) {
                let propName = properties[i];
                let valueStr;
                let link;
                try {
                    let prop = obj[propName];
                    link = new ObjLink(this._lookingGlass, prop).actor;
                } catch (e) {
                    link = new St.Label({ text: '<error>' });
                }
                let hbox = new St.BoxLayout();
                let propText = propName + ': ' + valueStr;
                hbox.add(new St.Label({ text: propName + ': ' }));
                hbox.add(link);
                this._container.add_actor(hbox);
            }
        }
    },
    open: function(sourceActor) {
        if (this._open)
            return;
        this._previousObj = null;
        this._open = true;
        this.actor.show();
        if (sourceActor) {
            this.actor.set_scale(0, 0);
            Tweener.addTween(this.actor, { scale_x: 1, scale_y: 1,
                                           transition: 'easeOutQuad',
                                           time: 0.2 });
        } else {
            this.actor.set_scale(1, 1);
        }
    },
    close: function() {
        if (!this._open)
            return;
        this._open = false;
        this.actor.hide();
        this._previousObj = null;
        this._obj = null;
    },
    _onInsert: function() {
        let obj = this._obj;
        this.close();
        this._lookingGlass.insertObject(obj);
    },
    _onBack: function() {
        this.selectObject(this._previousObj, true);
    }
const RedBorderEffect = new Lang.Class({
    Name: 'RedBorderEffect',
    Extends: Clutter.Effect,
    vfunc_paint: function() {
        let actor = this.get_actor();
        actor.continue_paint();
        let color = new Cogl.Color();
        color.init_from_4ub(0xff, 0, 0, 0xc4);
        Cogl.set_source_color(color);
        let geom = actor.get_allocation_geometry();
        let width = 2;
        // clockwise order
        Cogl.rectangle(0, 0, geom.width, width);
        Cogl.rectangle(geom.width - width, width,
                       geom.width, geom.height);
        Cogl.rectangle(0, geom.height,
                       geom.width - width, geom.height - width);
        Cogl.rectangle(0, geom.height - width,
                       width, width);
    },
const Inspector = new Lang.Class({
    Name: 'Inspector',
    _init: function(lookingGlass) {
        let container = new Shell.GenericContainer({ width: 0,
                                                     height: 0 });
        container.connect('allocate', Lang.bind(this, this._allocate));
        Main.uiGroup.add_actor(container);
        let eventHandler = new St.BoxLayout({ name: 'LookingGlassDialog',
                                              vertical: false,
                                              reactive: true });
        this._eventHandler = eventHandler;
        container.add_actor(eventHandler);
        this._displayText = new St.Label();
        eventHandler.add(this._displayText, { expand: true });
        eventHandler.connect('key-press-event', Lang.bind(this, this._onKeyPressEvent));
        eventHandler.connect('button-press-event', Lang.bind(this, this._onButtonPressEvent));
        eventHandler.connect('scroll-event', Lang.bind(this, this._onScrollEvent));
        eventHandler.connect('motion-event', Lang.bind(this, this._onMotionEvent));
        Clutter.grab_pointer(eventHandler);
        Clutter.grab_keyboard(eventHandler);
        // this._target is the actor currently shown by the inspector.
        // this._pointerTarget is the actor directly under the pointer.
        // Normally these are the same, but if you use the scroll wheel
        // to drill down, they'll diverge until you either scroll back
        // out, or move the pointer outside of _pointerTarget.
        this._target = null;
        this._pointerTarget = null;
        this._lookingGlass = lookingGlass;
    },
    _allocate: function(actor, box, flags) {
        if (!this._eventHandler)
            return;
        let primary = Main.layoutManager.primaryMonitor;
        let [minWidth, minHeight, natWidth, natHeight] =
            this._eventHandler.get_preferred_size();
        let childBox = new Clutter.ActorBox();
        childBox.x1 = primary.x + Math.floor((primary.width - natWidth) / 2);
        childBox.x2 = childBox.x1 + natWidth;
        childBox.y1 = primary.y + Math.floor((primary.height - natHeight) / 2);
        childBox.y2 = childBox.y1 + natHeight;
        this._eventHandler.allocate(childBox, flags);
    },
    _close: function() {
        Clutter.ungrab_pointer();
        Clutter.ungrab_keyboard();
        this._eventHandler.destroy();
        this._eventHandler = null;
        this.emit('closed');
    },
    _onKeyPressEvent: function (actor, event) {
        if (event.get_key_symbol() == Clutter.Escape)
            this._close();
        return Clutter.EVENT_STOP;
    },
    _onButtonPressEvent: function (actor, event) {
        if (this._target) {
            let [stageX, stageY] = event.get_coords();
            this.emit('target', this._target, stageX, stageY);
        }
        this._close();
        return Clutter.EVENT_STOP;
    },
    _onScrollEvent: function (actor, event) {
        switch (event.get_scroll_direction()) {
        case Clutter.ScrollDirection.UP:
            // select parent
            let parent = this._target.get_parent();
            if (parent != null) {
                this._target = parent;
                this._update(event);
            }
            break;
        case Clutter.ScrollDirection.DOWN:
            // select child
            if (this._target != this._pointerTarget) {
                let child = this._pointerTarget;
                while (child) {
                    let parent = child.get_parent();
                    if (parent == this._target)
                        break;
                    child = parent;
                }
                if (child) {
                    this._target = child;
                    this._update(event);
                }
            }
            break;
        default:
            break;
        }
        return Clutter.EVENT_STOP;
    },
    _onMotionEvent: function (actor, event) {
        this._update(event);
        return Clutter.EVENT_STOP;
    },
    _update: function(event) {
        let [stageX, stageY] = event.get_coords();
        let target = global.stage.get_actor_at_pos(Clutter.PickMode.ALL,
                                                   stageX,
                                                   stageY);
        if (target != this._pointerTarget)
            this._target = target;
        this._pointerTarget = target;
        let position = '[inspect x: ' + stageX + ' y: ' + stageY + ']';
        this._displayText.text = '';
        this._displayText.text = position + ' ' + this._target;
        this._lookingGlass.setBorderPaintTarget(this._target);
    }
Signals.addSignalMethods(Inspector.prototype);
const Extensions = new Lang.Class({
    Name: 'Extensions',
    _init: function(lookingGlass) {
        this._lookingGlass = lookingGlass;
        this.actor = new St.BoxLayout({ vertical: true,
                                        name: 'lookingGlassExtensions' });
        this._noExtensions = new St.Label({ style_class: 'lg-extensions-none',
                                             text: _("No extensions installed") });
        this._numExtensions = 0;
        this._extensionsList = new St.BoxLayout({ vertical: true,
                                                  style_class: 'lg-extensions-list' });
        this._extensionsList.add(this._noExtensions);
        this.actor.add(this._extensionsList);
        for (let uuid in ExtensionUtils.extensions)
            this._loadExtension(null, uuid);
        ExtensionSystem.connect('extension-loaded',
                                Lang.bind(this, this._loadExtension));
    },
    _loadExtension: function(o, uuid) {
        let extension = ExtensionUtils.extensions[uuid];
        // There can be cases where we create dummy extension metadata
        // that's not really a proper extension. Don't bother with these.
        if (!extension.metadata.name)
            return;
        let extensionDisplay = this._createExtensionDisplay(extension);
        if (this._numExtensions == 0)
            this._extensionsList.remove_actor(this._noExtensions);
        this._numExtensions ++;
        this._extensionsList.add(extensionDisplay);
    },
    _onViewSource: function (actor) {
        let extension = actor._extension;
        let uri = extension.dir.get_uri();
        Gio.app_info_launch_default_for_uri(uri, global.create_app_launch_context(0, -1));
        this._lookingGlass.close();
    },
    _onWebPage: function (actor) {
        let extension = actor._extension;
        Gio.app_info_launch_default_for_uri(extension.metadata.url, global.create_app_launch_context(0, -1));
        this._lookingGlass.close();
    },
    _onViewErrors: function (actor) {
        let extension = actor._extension;
        let shouldShow = !actor._isShowing;
        if (shouldShow) {
            let errors = extension.errors;
            let errorDisplay = new St.BoxLayout({ vertical: true });
            if (errors && errors.length) {
                for (let i = 0; i < errors.length; i ++)
                    errorDisplay.add(new St.Label({ text: errors[i] }));
            } else {
                /* Translators: argument is an extension UUID. */
                let message = _("%s has not emitted any errors.").format(extension.uuid);
                errorDisplay.add(new St.Label({ text: message }));
            }
            actor._errorDisplay = errorDisplay;
            actor._parentBox.add(errorDisplay);
            actor.label = _("Hide Errors");
        } else {
            actor._errorDisplay.destroy();
            actor._errorDisplay = null;
            actor.label = _("Show Errors");
        }
        actor._isShowing = shouldShow;
    },
    _stateToString: function(extensionState) {
        switch (extensionState) {
            case ExtensionSystem.ExtensionState.ENABLED:
                return _("Enabled");
            case ExtensionSystem.ExtensionState.DISABLED:
            case ExtensionSystem.ExtensionState.INITIALIZED:
                return _("Disabled");
            case ExtensionSystem.ExtensionState.ERROR:
                return _("Error");
            case ExtensionSystem.ExtensionState.OUT_OF_DATE:
                return _("Out of date");
            case ExtensionSystem.ExtensionState.DOWNLOADING:
                return _("Downloading");
        }
        return 'Unknown'; // Not translated, shouldn't appear
    },
    _createExtensionDisplay: function(extension) {
        let box = new St.BoxLayout({ style_class: 'lg-extension', vertical: true });
        let name = new St.Label({ style_class: 'lg-extension-name',
                                   text: extension.metadata.name });
        box.add(name, { expand: true });
        let description = new St.Label({ style_class: 'lg-extension-description',
                                         text: extension.metadata.description || 'No description' });
        box.add(description, { expand: true });
        let metaBox = new St.BoxLayout({ style_class: 'lg-extension-meta' });
        box.add(metaBox);
        let stateString = this._stateToString(extension.state);
        let state = new St.Label({ style_class: 'lg-extension-state',
                                   text: this._stateToString(extension.state) });
        metaBox.add(state);
        let viewsource = new St.Button({ reactive: true,
                                         track_hover: true,
                                         style_class: 'shell-link',
                                         label: _("View Source") });
        viewsource._extension = extension;
        viewsource.connect('clicked', Lang.bind(this, this._onViewSource));
        metaBox.add(viewsource);
        if (extension.metadata.url) {
            let webpage = new St.Button({ reactive: true,
                                          track_hover: true,
                                          style_class: 'shell-link',
                                          label: _("Web Page") });
            webpage._extension = extension;
            webpage.connect('clicked', Lang.bind(this, this._onWebPage));
            metaBox.add(webpage);
        }
        let viewerrors = new St.Button({ reactive: true,
                                         track_hover: true,
                                         style_class: 'shell-link',
                                         label: _("Show Errors") });
        viewerrors._extension = extension;
        viewerrors._parentBox = box;
        viewerrors._isShowing = false;
        viewerrors.connect('clicked', Lang.bind(this, this._onViewErrors));
        metaBox.add(viewerrors);
        return box;
    }
const LookingGlass = new Lang.Class({
    Name: 'LookingGlass',
    _init : function() {
        this._borderPaintTarget = null;
        this._redBorderEffect = new RedBorderEffect();
        this._open = false;
        this._offset = 0;
        this._results = [];
        // Sort of magic, but...eh.
        this._maxItems = 150;
        this.actor = new St.BoxLayout({ name: 'LookingGlassDialog',
                                        style_class: 'lg-dialog',
                                        vertical: true,
                                        visible: false,
                                        reactive: true });
        this.actor.connect('key-press-event', Lang.bind(this, this._globalKeyPressEvent));
        this._interfaceSettings = new Gio.Settings({ schema_id: 'org.gnome.desktop.interface' });
        this._interfaceSettings.connect('changed::monospace-font-name',
                                        Lang.bind(this, this._updateFont));
        this._updateFont();
        // We want it to appear to slide out from underneath the panel
        Main.uiGroup.add_actor(this.actor);
        Main.uiGroup.set_child_below_sibling(this.actor,
                                             Main.layoutManager.panelBox);
        Main.layoutManager.panelBox.connect('allocation-changed',
                                            Lang.bind(this, this._queueResize));
        Main.layoutManager.keyboardBox.connect('allocation-changed',
                                               Lang.bind(this, this._queueResize));
        this._objInspector = new ObjInspector(this);
        Main.uiGroup.add_actor(this._objInspector.actor);
        this._objInspector.actor.hide();
        let toolbar = new St.BoxLayout({ name: 'Toolbar' });
        this.actor.add_actor(toolbar);
        let inspectIcon = new St.Icon({ icon_name: 'gtk-color-picker',
                                        icon_size: 24 });
        toolbar.add_actor(inspectIcon);
        inspectIcon.reactive = true;
        inspectIcon.connect('button-press-event', Lang.bind(this, function () {
            let inspector = new Inspector(this);
            inspector.connect('target', Lang.bind(this, function(i, target, stageX, stageY) {
                this._pushResult('inspect(' + Math.round(stageX) + ', ' + Math.round(stageY) + ')', target);
            }));
            inspector.connect('closed', Lang.bind(this, function() {
                this.actor.show();
                global.stage.set_key_focus(this._entry);
            }));
            this.actor.hide();
            return Clutter.EVENT_STOP;
        }));
        let gcIcon = new St.Icon({ icon_name: 'gnome-fs-trash-full',
                                   icon_size: 24 });
        toolbar.add_actor(gcIcon);
        gcIcon.reactive = true;
        gcIcon.connect('button-press-event', Lang.bind(this, function () {
           gcIcon.icon_name = 'gnome-fs-trash-empty';
           System.gc();
           this._timeoutId = Mainloop.timeout_add(500, Lang.bind(this, function () {
                gcIcon.icon_name = 'gnome-fs-trash-full';
                this._timeoutId = 0;
                return GLib.SOURCE_REMOVE;
           }));
           GLib.Source.set_name_by_id(this._timeoutId, '[gnome-shell] gcIcon.icon_name = \'gnome-fs-trash-full\'');
           return Clutter.EVENT_PROPAGATE;
        }));
        let notebook = new Notebook();
        this._notebook = notebook;
        this.actor.add(notebook.actor, { expand: true });
        let emptyBox = new St.Bin();
        toolbar.add(emptyBox, { expand: true });
        toolbar.add_actor(notebook.tabControls);
        this._evalBox = new St.BoxLayout({ name: 'EvalBox', vertical: true });
        notebook.appendPage('Evaluator', this._evalBox);
        this._resultsArea = new St.BoxLayout({ name: 'ResultsArea', vertical: true });
        this._evalBox.add(this._resultsArea, { expand: true });
        this._entryArea = new St.BoxLayout({ name: 'EntryArea' });
        this._evalBox.add_actor(this._entryArea);
        let label = new St.Label({ text: CHEVRON });
        this._entryArea.add(label);
        this._entry = new St.Entry({ can_focus: true });
        ShellEntry.addContextMenu(this._entry);
        this._entryArea.add(this._entry, { expand: true });
        this._windowList = new WindowList(this);
        notebook.appendPage('Windows', this._windowList.actor);
        this._extensions = new Extensions(this);
        notebook.appendPage('Extensions', this._extensions.actor);
        this._entry.clutter_text.connect('activate', Lang.bind(this, function (o, e) {
            // Hide any completions we are currently showing
            this._hideCompletions();
            let text = o.get_text();
            // Ensure we don't get newlines in the command; the history file is
            // newline-separated.
            text = text.replace('\n', ' ');
            // Strip leading and trailing whitespace
            text = text.replace(/^\s+/g, '').replace(/\s+$/g, '');
            if (text == '')
                return true;
            this._evaluate(text);
            return true;
        }));
        this._history = new History.HistoryManager({ gsettingsKey: HISTORY_KEY, 
                                                     entry: this._entry.clutter_text });
        this._autoComplete = new AutoComplete(this._entry);
        this._autoComplete.connect('suggest', Lang.bind(this, function(a,e) {
            this._showCompletions(e.completions);
        }));
        // If a completion is completed unambiguously, the currently-displayed completion
        // suggestions become irrelevant.
        this._autoComplete.connect('completion', Lang.bind(this, function(a,e) {
            if (e.type == 'whole-word')
                this._hideCompletions();
        }));
        this._resize();
    },
    _updateFont: function() {
        let fontName = this._interfaceSettings.get_string('monospace-font-name');
        let fontDesc = Pango.FontDescription.from_string(fontName);
        // We ignore everything but size and style; you'd be crazy to set your system-wide
        // monospace font to be bold/oblique/etc. Could easily be added here.
        this.actor.style =
            'font-size: ' + fontDesc.get_size() / 1024. + (fontDesc.get_size_is_absolute() ? 'px' : 'pt') + ';'
            + 'font-family: "' + fontDesc.get_family() + '";';
    },
    setBorderPaintTarget: function(obj) {
        if (this._borderPaintTarget != null)
            this._borderPaintTarget.remove_effect(this._redBorderEffect);
        this._borderPaintTarget = obj;
        if (this._borderPaintTarget != null)
            this._borderPaintTarget.add_effect(this._redBorderEffect);
    },
    _pushResult: function(command, obj) {
        let index = this._results.length + this._offset;
        let result = new Result(this, CHEVRON + command, obj, index);
        this._results.push(result);
        this._resultsArea.add(result.actor);
        if (obj instanceof Clutter.Actor)
            this.setBorderPaintTarget(obj);
        let children = this._resultsArea.get_children();
        if (children.length > this._maxItems) {
            this._results.shift();
            children[0].destroy();
            this._offset++;
        }
        this._it = obj;
        // Scroll to bottom
        this._notebook.scrollToBottom(0);
    },
    _showCompletions: function(completions) {
        if (!this._completionActor) {
            this._completionActor = new St.Label({ name: 'LookingGlassAutoCompletionText', style_class: 'lg-completions-text' });
            this._completionActor.clutter_text.ellipsize = Pango.EllipsizeMode.NONE;
            this._completionActor.clutter_text.line_wrap = true;
            this._evalBox.insert_child_below(this._completionActor, this._entryArea);
        }
        this._completionActor.set_text(completions.join(', '));
        // Setting the height to -1 allows us to get its actual preferred height rather than
        // whatever was last given in set_height by Tweener.
        this._completionActor.set_height(-1);
        let [minHeight, naturalHeight] = this._completionActor.get_preferred_height(this._resultsArea.get_width());
        // Don't reanimate if we are already visible
        if (this._completionActor.visible) {
            this._completionActor.height = naturalHeight;
        } else {
            this._completionActor.show();
            Tweener.removeTweens(this._completionActor);
            Tweener.addTween(this._completionActor, { time: AUTO_COMPLETE_SHOW_COMPLETION_ANIMATION_DURATION / St.get_slow_down_factor(),
                                                      transition: 'easeOutQuad',
                                                      height: naturalHeight,
                                                      opacity: 255
                                                    });
        }
    },
    _hideCompletions: function() {
        if (this._completionActor) {
            Tweener.removeTweens(this._completionActor);
            Tweener.addTween(this._completionActor, { time: AUTO_COMPLETE_SHOW_COMPLETION_ANIMATION_DURATION / St.get_slow_down_factor(),
                                                      transition: 'easeOutQuad',
                                                      height: 0,
                                                      opacity: 0,
                                                      onComplete: Lang.bind(this, function () {
                                                          this._completionActor.hide();
                                                      })
                                                    });
        }
    },
    _evaluate : function(command) {
        this._history.addItem(command);
        let fullCmd = commandHeader + command;
        let resultObj;
        try {
            resultObj = eval(fullCmd);
        } catch (e) {
            resultObj = '<exception ' + e + '>';
        }
        this._pushResult(command, resultObj);
        this._entry.text = '';
    },
    inspect: function(x, y) {
        return global.stage.get_actor_at_pos(Clutter.PickMode.REACTIVE, x, y);
    },
    getIt: function () {
        return this._it;
    },
    getResult: function(idx) {
        return this._results[idx - this._offset].o;
    },
    toggle: function() {
        if (this._open)
            this.close();
        else
            this.open();
    },
    _queueResize: function() {
        Meta.later_add(Meta.LaterType.BEFORE_REDRAW,
                       Lang.bind(this, function () { this._resize(); }));
    },
    _resize: function() {
        let primary = Main.layoutManager.primaryMonitor;
        let myWidth = primary.width * 0.7;
        let availableHeight = primary.height - Main.layoutManager.keyboardBox.height;
        let myHeight = Math.min(primary.height * 0.7, availableHeight * 0.9);
        this.actor.x = primary.x + (primary.width - myWidth) / 2;
        this._hiddenY = primary.y + Main.layoutManager.panelBox.height - myHeight;
        this._targetY = this._hiddenY + myHeight;
        this.actor.y = this._hiddenY;
        this.actor.width = myWidth;
        this.actor.height = myHeight;
        this._objInspector.actor.set_size(Math.floor(myWidth * 0.8), Math.floor(myHeight * 0.8));
        this._objInspector.actor.set_position(this.actor.x + Math.floor(myWidth * 0.1),
                                              this._targetY + Math.floor(myHeight * 0.1));
    },
    insertObject: function(obj) {
        this._pushResult('<insert>', obj);
    },
    inspectObject: function(obj, sourceActor) {
        this._objInspector.open(sourceActor);
        this._objInspector.selectObject(obj);
    },
    // Handle key events which are relevant for all tabs of the LookingGlass
    _globalKeyPressEvent : function(actor, event) {
        let symbol = event.get_key_symbol();
        let modifierState = event.get_state();
        if (symbol == Clutter.Escape) {
            if (this._objInspector.actor.visible) {
                this._objInspector.close();
            } else {
                this.close();
            }
            return Clutter.EVENT_STOP;
        }
        // Ctrl+PgUp and Ctrl+PgDown switches tabs in the notebook view
        if (modifierState & Clutter.ModifierType.CONTROL_MASK) {
            if (symbol == Clutter.KEY_Page_Up) {
                this._notebook.prevTab();
            } else if (symbol == Clutter.KEY_Page_Down) {
                this._notebook.nextTab();
            }
        }
        return Clutter.EVENT_PROPAGATE;
    },
    open : function() {
        if (this._open)
            return;
        if (!Main.pushModal(this._entry, { actionMode: Shell.ActionMode.LOOKING_GLASS }))
            return;
        this._notebook.selectIndex(0);
        this.actor.show();
        this._open = true;
        this._history.lastItem();
        Tweener.removeTweens(this.actor);
        // We inverse compensate for the slow-down so you can change the factor
        // through LookingGlass without long waits.
        Tweener.addTween(this.actor, { time: 0.5 / St.get_slow_down_factor(),
                                       transition: 'easeOutQuad',
                                       y: this._targetY
                                     });
    },
    close : function() {
        if (!this._open)
            return;
        this._objInspector.actor.hide();
        this._open = false;
        Tweener.removeTweens(this.actor);
        this.setBorderPaintTarget(null);
        Main.popModal(this._entry);
        Tweener.addTween(this.actor, { time: Math.min(0.5 / St.get_slow_down_factor(), 0.5),
                                       transition: 'easeOutQuad',
                                       y: this._hiddenY,
                                       onComplete: Lang.bind(this, function () {
                                           this.actor.hide();
                                       })
                                     });
    }
Signals.addSignalMethods(LookingGlass.prototype);
(uuay)dash.js
// -*- mode: js; js-indent-level: 4; indent-tabs-mode: nil -*-
const Clutter = imports.gi.Clutter;
const Gio = imports.gi.Gio;
const GLib = imports.gi.GLib;
const Signals = imports.signals;
const Lang = imports.lang;
const Meta = imports.gi.Meta;
const Shell = imports.gi.Shell;
const St = imports.gi.St;
const Mainloop = imports.mainloop;
const AppDisplay = imports.ui.appDisplay;
const AppFavorites = imports.ui.appFavorites;
const DND = imports.ui.dnd;
const IconGrid = imports.ui.iconGrid;
const Main = imports.ui.main;
const Tweener = imports.ui.tweener;
const Workspace = imports.ui.workspace;
const DASH_ANIMATION_TIME = 0.2;
const DASH_ITEM_LABEL_SHOW_TIME = 0.15;
const DASH_ITEM_LABEL_HIDE_TIME = 0.1;
const DASH_ITEM_HOVER_TIMEOUT = 300;
function getAppFromSource(source) {
    if (source instanceof AppDisplay.AppIcon) {
        return source.app;
    } else {
        return null;
    }
// A container like StBin, but taking the child's scale into account
// when requesting a size
const DashItemContainer = new Lang.Class({
    Name: 'DashItemContainer',
    Extends: St.Widget,
    _init: function() {
        this.parent({ style_class: 'dash-item-container' });
        this._labelText = "";
        this.label = new St.Label({ style_class: 'dash-label'});
        this.label.hide();
        Main.layoutManager.addChrome(this.label);
        this.label_actor = this.label;
        this.child = null;
        this._childScale = 0;
        this._childOpacity = 0;
        this.animatingOut = false;
    },
    vfunc_allocate: function(box, flags) {
        this.set_allocation(box, flags);
        if (this.child == null)
            return;
        let availWidth = box.x2 - box.x1;
        let availHeight = box.y2 - box.y1;
        let [minChildWidth, minChildHeight, natChildWidth, natChildHeight] =
            this.child.get_preferred_size();
        let [childScaleX, childScaleY] = this.child.get_scale();
        let childWidth = Math.min(natChildWidth * childScaleX, availWidth);
        let childHeight = Math.min(natChildHeight * childScaleY, availHeight);
        let childBox = new Clutter.ActorBox();
        childBox.x1 = (availWidth - childWidth) / 2;
        childBox.y1 = (availHeight - childHeight) / 2;
        childBox.x2 = childBox.x1 + childWidth;
        childBox.y2 = childBox.y1 + childHeight;
        this.child.allocate(childBox, flags);
    },
    vfunc_get_preferred_height: function(forWidth) {
        let themeNode = this.get_theme_node();
        if (this.child == null)
            return [0, 0];
        forWidth = themeNode.adjust_for_width(forWidth);
        let [minHeight, natHeight] = this.child.get_preferred_height(forWidth);
        return themeNode.adjust_preferred_height(minHeight * this.child.scale_y,
                                                 natHeight * this.child.scale_y);
    },
    vfunc_get_preferred_width: function(forHeight) {
        let themeNode = this.get_theme_node();
        if (this.child == null)
            return [0, 0];
        forHeight = themeNode.adjust_for_height(forHeight);
        let [minWidth, natWidth] = this.child.get_preferred_width(forHeight);
        return themeNode.adjust_preferred_width(minWidth * this.child.scale_y,
                                                natWidth * this.child.scale_y);
    },
    showLabel: function() {
        if (!this._labelText)
            return;
        this.label.set_text(this._labelText);
        this.label.opacity = 0;
        this.label.show();
        let [stageX, stageY] = this.get_transformed_position();
        let itemHeight = this.allocation.y2 - this.allocation.y1;
        let labelHeight = this.label.get_height();
        let yOffset = Math.floor((itemHeight - labelHeight) / 2)
        let y = stageY + yOffset;
        let node = this.label.get_theme_node();
        let xOffset = node.get_length('-x-offset');
        let x;
        if (Clutter.get_default_text_direction() == Clutter.TextDirection.RTL)
            x = stageX - this.label.get_width() - xOffset;
        else
            x = stageX + this.get_width() + xOffset;
        this.label.set_position(x, y);
        Tweener.addTween(this.label,
                         { opacity: 255,
                           time: DASH_ITEM_LABEL_SHOW_TIME,
                           transition: 'easeOutQuad',
                         });
    },
    setLabelText: function(text) {
        this._labelText = text;
        this.child.accessible_name = text;
    },
    hideLabel: function () {
        Tweener.addTween(this.label,
                         { opacity: 0,
                           time: DASH_ITEM_LABEL_HIDE_TIME,
                           transition: 'easeOutQuad',
                           onComplete: Lang.bind(this, function() {
                               this.label.hide();
                           })
                         });
    },
    setChild: function(actor) {
        if (this.child == actor)
            return;
        this.destroy_all_children();
        this.child = actor;
        this.add_actor(this.child);
        this.child.set_scale_with_gravity(this._childScale, this._childScale,
                                          Clutter.Gravity.CENTER);
        this.child.set_opacity(this._childOpacity);
    },
    show: function(animate) {
        if (this.child == null)
            return;
        let time = animate ? DASH_ANIMATION_TIME : 0;
        Tweener.addTween(this,
                         { childScale: 1.0,
                           childOpacity: 255,
                           time: time,
                           transition: 'easeOutQuad'
                         });
    },
    destroy: function() {
        if (this.label)
            this.label.destroy();
        this.parent();
    },
    animateOutAndDestroy: function() {
        if (this.label)
            this.label.destroy();
        if (this.child == null) {
            this.destroy();
            return;
        }
        this.animatingOut = true;
        Tweener.addTween(this,
                         { childScale: 0.0,
                           childOpacity: 0,
                           time: DASH_ANIMATION_TIME,
                           transition: 'easeOutQuad',
                           onComplete: Lang.bind(this, function() {
                               this.destroy();
                           })
                         });
    },
    set childScale(scale) {
        this._childScale = scale;
        if (this.child == null)
            return;
        this.child.set_scale_with_gravity(scale, scale,
                                          Clutter.Gravity.CENTER);
        this.queue_relayout();
    },
    get childScale() {
        return this._childScale;
    },
    set childOpacity(opacity) {
        this._childOpacity = opacity;
        if (this.child == null)
            return;
        this.child.set_opacity(opacity);
        this.queue_redraw();
    },
    get childOpacity() {
        return this._childOpacity;
    }
const ShowAppsIcon = new Lang.Class({
    Name: 'ShowAppsIcon',
    Extends: DashItemContainer,
    _init: function() {
        this.parent();
        this.toggleButton = new St.Button({ style_class: 'show-apps',
                                            track_hover: true,
                                            can_focus: true,
                                            toggle_mode: true });
        this._iconActor = null;
        this.icon = new IconGrid.BaseIcon(_("Show Applications"),
                                           { setSizeManually: true,
                                             showLabel: false,
                                             createIcon: Lang.bind(this, this._createIcon) });
        this.toggleButton.add_actor(this.icon.actor);
        this.toggleButton._delegate = this;
        this.setChild(this.toggleButton);
        this.setDragApp(null);
    },
    _createIcon: function(size) {
        this._iconActor = new St.Icon({ icon_name: 'view-app-grid-symbolic',
                                        icon_size: size,
                                        style_class: 'show-apps-icon',
                                        track_hover: true });
        return this._iconActor;
    },
    _canRemoveApp: function(app) {
        if (app == null)
            return false;
        if (!global.settings.is_writable('favorite-apps'))
            return false;
        let id = app.get_id();
        let isFavorite = AppFavorites.getAppFavorites().isFavorite(id);
        return isFavorite;
    },
    setDragApp: function(app) {
        let canRemove = this._canRemoveApp(app);
        this.toggleButton.set_hover(canRemove);
        if (this._iconActor)
            this._iconActor.set_hover(canRemove);
        if (canRemove)
            this.setLabelText(_("Remove from Favorites"));
        else
            this.setLabelText(_("Show Applications"));
    },
    handleDragOver: function(source, actor, x, y, time) {
        if (!this._canRemoveApp(getAppFromSource(source)))
            return DND.DragMotionResult.NO_DROP;
        return DND.DragMotionResult.MOVE_DROP;
    },
    acceptDrop: function(source, actor, x, y, time) {
        let app = getAppFromSource(source);
        if (!this._canRemoveApp(app))
            return false;
        let id = app.get_id();
        Meta.later_add(Meta.LaterType.BEFORE_REDRAW, Lang.bind(this,
            function () {
                AppFavorites.getAppFavorites().removeFavorite(id);
                return false;
            }));
        return true;
    }
const DragPlaceholderItem = new Lang.Class({
    Name: 'DragPlaceholderItem',
    Extends: DashItemContainer,
    _init: function() {
        this.parent();
        this.setChild(new St.Bin({ style_class: 'placeholder' }));
    }
const EmptyDropTargetItem = new Lang.Class({
    Name: 'EmptyDropTargetItem',
    Extends: DashItemContainer,
    _init: function() {
        this.parent();
        this.setChild(new St.Bin({ style_class: 'empty-dash-drop-target' }));
    }
const DashActor = new Lang.Class({
    Name: 'DashActor',
    Extends: St.Widget,
    _init: function() {
        let layout = new Clutter.BoxLayout({ orientation: Clutter.Orientation.VERTICAL });
        this.parent({ name: 'dash',
                      layout_manager: layout,
                      clip_to_allocation: true });
    },
    vfunc_allocate: function(box, flags) {
        let contentBox = this.get_theme_node().get_content_box(box);
        let availWidth = contentBox.x2 - contentBox.x1;
        this.set_allocation(box, flags);
        let [appIcons, showAppsButton] = this.get_children();
        let [showAppsMinHeight, showAppsNatHeight] = showAppsButton.get_preferred_height(availWidth);
        let childBox = new Clutter.ActorBox();
        childBox.x1 = contentBox.x1;
        childBox.y1 = contentBox.y1;
        childBox.x2 = contentBox.x2;
        childBox.y2 = contentBox.y2 - showAppsNatHeight;
        appIcons.allocate(childBox, flags);
        childBox.y1 = contentBox.y2 - showAppsNatHeight;
        childBox.y2 = contentBox.y2;
        showAppsButton.allocate(childBox, flags);
    },
    vfunc_get_preferred_height: function(forWidth) {
        // We want to request the natural height of all our children
        // as our natural height, so we chain up to StWidget (which
        // then calls BoxLayout), but we only request the showApps
        // button as the minimum size
        let [, natHeight] = this.parent(forWidth);
        let themeNode = this.get_theme_node();
        let adjustedForWidth = themeNode.adjust_for_width(forWidth);
        let [, showAppsButton] = this.get_children();
        let [minHeight, ] = showAppsButton.get_preferred_height(adjustedForWidth);
        [minHeight, ] = themeNode.adjust_preferred_height(minHeight, natHeight);
        return [minHeight, natHeight];
    }
const baseIconSizes = [ 16, 22, 24, 32, 48, 64 ];
const Dash = new Lang.Class({
    Name: 'Dash',
    _init : function() {
        this._maxHeight = -1;
        this.iconSize = 64;
        this._shownInitially = false;
        this._dragPlaceholder = null;
        this._dragPlaceholderPos = -1;
        this._animatingPlaceholdersCount = 0;
        this._showLabelTimeoutId = 0;
        this._resetHoverTimeoutId = 0;
        this._labelShowing = false;
        this._container = new DashActor();
        this._box = new St.BoxLayout({ vertical: true,
                                       clip_to_allocation: true });
        this._box._delegate = this;
        this._container.add_actor(this._box);
        this._showAppsIcon = new ShowAppsIcon();
        this._showAppsIcon.childScale = 1;
        this._showAppsIcon.childOpacity = 255;
        this._showAppsIcon.icon.setIconSize(this.iconSize);
        this._hookUpLabel(this._showAppsIcon);
        this.showAppsButton = this._showAppsIcon.toggleButton;
        this._container.add_actor(this._showAppsIcon);
        this.actor = new St.Bin({ child: this._container });
        this.actor.connect('notify::height', Lang.bind(this,
            function() {
                if (this._maxHeight != this.actor.height)
                    this._queueRedisplay();
                this._maxHeight = this.actor.height;
            }));
        this._workId = Main.initializeDeferredWork(this._box, Lang.bind(this, this._redisplay));
        this._appSystem = Shell.AppSystem.get_default();
        this._appSystem.connect('installed-changed', Lang.bind(this, function() {
            AppFavorites.getAppFavorites().reload();
            this._queueRedisplay();
        }));
        AppFavorites.getAppFavorites().connect('changed', Lang.bind(this, this._queueRedisplay));
        this._appSystem.connect('app-state-changed', Lang.bind(this, this._queueRedisplay));
        Main.overview.connect('item-drag-begin',
                              Lang.bind(this, this._onDragBegin));
        Main.overview.connect('item-drag-end',
                              Lang.bind(this, this._onDragEnd));
        Main.overview.connect('item-drag-cancelled',
                              Lang.bind(this, this._onDragCancelled));
        // Translators: this is the name of the dock/favorites area on
        // the left of the overview
        Main.ctrlAltTabManager.addGroup(this.actor, _("Dash"), 'user-bookmarks-symbolic');
    },
    _onDragBegin: function() {
        this._dragCancelled = false;
        this._dragMonitor = {
            dragMotion: Lang.bind(this, this._onDragMotion)
        };
        DND.addDragMonitor(this._dragMonitor);
        if (this._box.get_n_children() == 0) {
            this._emptyDropTarget = new EmptyDropTargetItem();
            this._box.insert_child_at_index(this._emptyDropTarget, 0);
            this._emptyDropTarget.show(true);
        }
    },
    _onDragCancelled: function() {
        this._dragCancelled = true;
        this._endDrag();
    },
    _onDragEnd: function() {
        if (this._dragCancelled)
            return;
        this._endDrag();
    },
    _endDrag: function() {
        this._clearDragPlaceholder();
        this._clearEmptyDropTarget();
        this._showAppsIcon.setDragApp(null);
        DND.removeDragMonitor(this._dragMonitor);
    },
    _onDragMotion: function(dragEvent) {
        let app = getAppFromSource(dragEvent.source);
        if (app == null)
            return DND.DragMotionResult.CONTINUE;
        let showAppsHovered =
                this._showAppsIcon.contains(dragEvent.targetActor);
        if (!this._box.contains(dragEvent.targetActor) || showAppsHovered)
            this._clearDragPlaceholder();
        if (showAppsHovered)
            this._showAppsIcon.setDragApp(app);
        else
            this._showAppsIcon.setDragApp(null);
        return DND.DragMotionResult.CONTINUE;
    },
    _appIdListToHash: function(apps) {
        let ids = {};
        for (let i = 0; i < apps.length; i++)
            ids[apps[i].get_id()] = apps[i];
        return ids;
    },
    _queueRedisplay: function () {
        Main.queueDeferredWork(this._workId);
    },
    _hookUpLabel: function(item, appIcon) {
        item.child.connect('notify::hover', Lang.bind(this, function() {
            this._syncLabel(item, appIcon);
        }));
        let id = Main.overview.connect('hiding', Lang.bind(this, function() {
            this._labelShowing = false;
            item.hideLabel();
        }));
        item.child.connect('destroy', function() {
            Main.overview.disconnect(id);
        });
        if (appIcon) {
            appIcon.connect('sync-tooltip', Lang.bind(this, function() {
                this._syncLabel(item, appIcon);
            }));
        }
    },
    _createAppItem: function(app) {
        let appIcon = new AppDisplay.AppIcon(app,
                                             { setSizeManually: true,
                                               showLabel: false });
        if (appIcon._draggable) {
            appIcon._draggable.connect('drag-begin',
                                       Lang.bind(this, function() {
                                           appIcon.actor.opacity = 50;
                                       }));
            appIcon._draggable.connect('drag-end',
                                       Lang.bind(this, function() {
                                           appIcon.actor.opacity = 255;
                                       }));
        }
        appIcon.connect('menu-state-changed',
                        Lang.bind(this, function(appIcon, opened) {
                            this._itemMenuStateChanged(item, opened);
                        }));
        let item = new DashItemContainer();
        item.setChild(appIcon.actor);
        // Override default AppIcon label_actor, now the
        // accessible_name is set at DashItemContainer.setLabelText
        appIcon.actor.label_actor = null;
        item.setLabelText(app.get_name());
        appIcon.icon.setIconSize(this.iconSize);
        this._hookUpLabel(item, appIcon);
        return item;
    },
    _itemMenuStateChanged: function(item, opened) {
        // When the menu closes, it calls sync_hover, which means
        // that the notify::hover handler does everything we need to.
        if (opened) {
            if (this._showLabelTimeoutId > 0) {
                Mainloop.source_remove(this._showLabelTimeoutId);
                this._showLabelTimeoutId = 0;
            }
            item.hideLabel();
        }
    },
    _syncLabel: function (item, appIcon) {
        let shouldShow = appIcon ? appIcon.shouldShowTooltip() : item.child.get_hover();
        if (shouldShow) {
            if (this._showLabelTimeoutId == 0) {
                let timeout = this._labelShowing ? 0 : DASH_ITEM_HOVER_TIMEOUT;
                this._showLabelTimeoutId = Mainloop.timeout_add(timeout,
                    Lang.bind(this, function() {
                        this._labelShowing = true;
                        item.showLabel();
                        this._showLabelTimeoutId = 0;
                        return GLib.SOURCE_REMOVE;
                    }));
                GLib.Source.set_name_by_id(this._showLabelTimeoutId, '[gnome-shell] item.showLabel');
                if (this._resetHoverTimeoutId > 0) {
                    Mainloop.source_remove(this._resetHoverTimeoutId);
                    this._resetHoverTimeoutId = 0;
                }
            }
        } else {
            if (this._showLabelTimeoutId > 0)
                Mainloop.source_remove(this._showLabelTimeoutId);
            this._showLabelTimeoutId = 0;
            item.hideLabel();
            if (this._labelShowing) {
                this._resetHoverTimeoutId = Mainloop.timeout_add(DASH_ITEM_HOVER_TIMEOUT,
                    Lang.bind(this, function() {
                        this._labelShowing = false;
                        this._resetHoverTimeoutId = 0;
                        return GLib.SOURCE_REMOVE;
                    }));
                GLib.Source.set_name_by_id(this._resetHoverTimeoutId, '[gnome-shell] this._labelShowing');
            }
        }
    },
    _adjustIconSize: function() {
        // For the icon size, we only consider children which are "proper"
        // icons (i.e. ignoring drag placeholders) and which are not
        // animating out (which means they will be destroyed at the end of
        // the animation)
        let iconChildren = this._box.get_children().filter(function(actor) {
            return actor.child &&
                   actor.child._delegate &&
                   actor.child._delegate.icon &&
                   !actor.animatingOut;
        });
        iconChildren.push(this._showAppsIcon);
        if (this._maxHeight == -1)
            return;
        let themeNode = this._container.get_theme_node();
        let maxAllocation = new Clutter.ActorBox({ x1: 0, y1: 0,
                                                   x2: 42 /* whatever */,
                                                   y2: this._maxHeight });
        let maxContent = themeNode.get_content_box(maxAllocation);
        let availHeight = maxContent.y2 - maxContent.y1;
        let spacing = themeNode.get_length('spacing');
        let firstButton = iconChildren[0].child;
        let firstIcon = firstButton._delegate.icon;
        let minHeight, natHeight;
        let scaleFactor = St.ThemeContext.get_for_stage(global.stage).scale_factor;
        // Enforce the current icon size during the size request
        firstIcon.icon.ensure_style();
        let [currentWidth, currentHeight] = firstIcon.icon.get_size();
        firstIcon.icon.set_size(this.iconSize * scaleFactor, this.iconSize * scaleFactor);
        [minHeight, natHeight] = firstButton.get_preferred_height(-1);
        firstIcon.icon.set_size(currentWidth, currentHeight);
        // Subtract icon padding and box spacing from the available height
        availHeight -= iconChildren.length * (natHeight - this.iconSize * scaleFactor) +
                       (iconChildren.length - 1) * spacing;
        let availSize = availHeight / iconChildren.length;
        let iconSizes = baseIconSizes.map(function(s) {
            return s * scaleFactor;
        });
        let newIconSize = baseIconSizes[0];
        for (let i = 0; i < iconSizes.length; i++) {
            if (iconSizes[i] < availSize)
                newIconSize = baseIconSizes[i];
        }
        if (newIconSize == this.iconSize)
            return;
        let oldIconSize = this.iconSize;
        this.iconSize = newIconSize;
        this.emit('icon-size-changed');
        let scale = oldIconSize / newIconSize;
        for (let i = 0; i < iconChildren.length; i++) {
            let icon = iconChildren[i].child._delegate.icon;
            // Set the new size immediately, to keep the icons' sizes
            // in sync with this.iconSize
            icon.setIconSize(this.iconSize);
            // Don't animate the icon size change when the overview
            // is transitioning, not visible or when initially filling
            // the dash
            if (!Main.overview.visible || Main.overview.animationInProgress ||
                !this._shownInitially)
                continue;
            let [targetWidth, targetHeight] = icon.icon.get_size();
            // Scale the icon's texture to the previous size and
            // tween to the new size
            icon.icon.set_size(icon.icon.width * scale,
                               icon.icon.height * scale);
            Tweener.addTween(icon.icon,
                             { width: targetWidth,
                               height: targetHeight,
                               time: DASH_ANIMATION_TIME,
                               transition: 'easeOutQuad',
                             });
        }
    },
    _redisplay: function () {
        let favorites = AppFavorites.getAppFavorites().getFavoriteMap();
        let running = this._appSystem.get_running();
        let children = this._box.get_children().filter(function(actor) {
                return actor.child &&
                       actor.child._delegate &&
                       actor.child._delegate.app;
            });
        // Apps currently in the dash
        let oldApps = children.map(function(actor) {
                return actor.child._delegate.app;
            });
        // Apps supposed to be in the dash
        let newApps = [];
        for (let id in favorites)
            newApps.push(favorites[id]);
        for (let i = 0; i < running.length; i++) {
            let app = running[i];
            if (app.get_id() in favorites)
                continue;
            newApps.push(app);
        }
        // Figure out the actual changes to the list of items; we iterate
        // over both the list of items currently in the dash and the list
        // of items expected there, and collect additions and removals.
        // Moves are both an addition and a removal, where the order of
        // the operations depends on whether we encounter the position
        // where the item has been added first or the one from where it
        // was removed.
        // There is an assumption that only one item is moved at a given
        // time; when moving several items at once, everything will still
        // end up at the right position, but there might be additional
        // additions/removals (e.g. it might remove all the launchers
        // and add them back in the new order even if a smaller set of
        // additions and removals is possible).
        // If above assumptions turns out to be a problem, we might need
        // to use a more sophisticated algorithm, e.g. Longest Common
        // Subsequence as used by diff.
        let addedItems = [];
        let removedActors = [];
        let newIndex = 0;
        let oldIndex = 0;
        while (newIndex < newApps.length || oldIndex < oldApps.length) {
            // No change at oldIndex/newIndex
            if (oldApps[oldIndex] == newApps[newIndex]) {
                oldIndex++;
                newIndex++;
                continue;
            }
            // App removed at oldIndex
            if (oldApps[oldIndex] &&
                newApps.indexOf(oldApps[oldIndex]) == -1) {
                removedActors.push(children[oldIndex]);
                oldIndex++;
                continue;
            }
            // App added at newIndex
            if (newApps[newIndex] &&
                oldApps.indexOf(newApps[newIndex]) == -1) {
                addedItems.push({ app: newApps[newIndex],
                                  item: this._createAppItem(newApps[newIndex]),
                                  pos: newIndex });
                newIndex++;
                continue;
            }
            // App moved
            let insertHere = newApps[newIndex + 1] &&
                             newApps[newIndex + 1] == oldApps[oldIndex];
            let alreadyRemoved = removedActors.reduce(function(result, actor) {
                let removedApp = actor.child._delegate.app;
                return result || removedApp == newApps[newIndex];
            }, false);
            if (insertHere || alreadyRemoved) {
                let newItem = this._createAppItem(newApps[newIndex]);
                addedItems.push({ app: newApps[newIndex],
                                  item: newItem,
                                  pos: newIndex + removedActors.length });
                newIndex++;
            } else {
                removedActors.push(children[oldIndex]);
                oldIndex++;
            }
        }
        for (let i = 0; i < addedItems.length; i++)
            this._box.insert_child_at_index(addedItems[i].item,
                                            addedItems[i].pos);
        for (let i = 0; i < removedActors.length; i++) {
            let item = removedActors[i];
            // Don't animate item removal when the overview is transitioning
            // or hidden
            if (Main.overview.visible && !Main.overview.animationInProgress)
                item.animateOutAndDestroy();
            else
                item.destroy();
        }
        this._adjustIconSize();
        // Skip animations on first run when adding the initial set
        // of items, to avoid all items zooming in at once
        let animate = this._shownInitially && Main.overview.visible &&
            !Main.overview.animationInProgress;
        if (!this._shownInitially)
            this._shownInitially = true;
        for (let i = 0; i < addedItems.length; i++) {
            addedItems[i].item.show(animate);
        }
        // Workaround for https://bugzilla.gnome.org/show_bug.cgi?id=692744
        // Without it, StBoxLayout may use a stale size cache
        this._box.queue_relayout();
    },
    _clearDragPlaceholder: function() {
        if (this._dragPlaceholder) {
            this._animatingPlaceholdersCount++;
            this._dragPlaceholder.animateOutAndDestroy();
            this._dragPlaceholder.connect('destroy',
                Lang.bind(this, function() {
                    this._animatingPlaceholdersCount--;
                }));
            this._dragPlaceholder = null;
        }
        this._dragPlaceholderPos = -1;
    },
    _clearEmptyDropTarget: function() {
        if (this._emptyDropTarget) {
            this._emptyDropTarget.animateOutAndDestroy();
            this._emptyDropTarget = null;
        }
    },
    handleDragOver : function(source, actor, x, y, time) {
        let app = getAppFromSource(source);
        // Don't allow favoriting of transient apps
        if (app == null || app.is_window_backed())
            return DND.DragMotionResult.NO_DROP;
        if (!global.settings.is_writable('favorite-apps'))
            return DND.DragMotionResult.NO_DROP;
        let favorites = AppFavorites.getAppFavorites().getFavorites();
        let numFavorites = favorites.length;
        let favPos = favorites.indexOf(app);
        let children = this._box.get_children();
        let numChildren = children.length;
        let boxHeight = this._box.height;
        // Keep the placeholder out of the index calculation; assuming that
        // the remove target has the same size as "normal" items, we don't
        // need to do the same adjustment there.
        if (this._dragPlaceholder) {
            boxHeight -= this._dragPlaceholder.height;
            numChildren--;
        }
        let pos;
        if (!this._emptyDropTarget)
            pos = Math.floor(y * numChildren / boxHeight);
        else
            pos = 0; // always insert at the top when dash is empty
        if (pos != this._dragPlaceholderPos && pos <= numFavorites && this._animatingPlaceholdersCount == 0) {
            this._dragPlaceholderPos = pos;
            // Don't allow positioning before or after self
            if (favPos != -1 && (pos == favPos || pos == favPos + 1)) {
                this._clearDragPlaceholder();
                return DND.DragMotionResult.CONTINUE;
            }
            // If the placeholder already exists, we just move
            // it, but if we are adding it, expand its size in
            // an animation
            let fadeIn;
            if (this._dragPlaceholder) {
                this._dragPlaceholder.destroy();
                fadeIn = false;
            } else {
                fadeIn = true;
            }
            this._dragPlaceholder = new DragPlaceholderItem();
            this._dragPlaceholder.child.set_width (this.iconSize);
            this._dragPlaceholder.child.set_height (this.iconSize / 2);
            this._box.insert_child_at_index(this._dragPlaceholder,
                                            this._dragPlaceholderPos);
            this._dragPlaceholder.show(fadeIn);
        }
        // Remove the drag placeholder if we are not in the
        // "favorites zone"
        if (pos > numFavorites)
            this._clearDragPlaceholder();
        if (!this._dragPlaceholder)
            return DND.DragMotionResult.NO_DROP;
        let srcIsFavorite = (favPos != -1);
        if (srcIsFavorite)
            return DND.DragMotionResult.MOVE_DROP;
        return DND.DragMotionResult.COPY_DROP;
    },
    // Draggable target interface
    acceptDrop : function(source, actor, x, y, time) {
        let app = getAppFromSource(source);
        // Don't allow favoriting of transient apps
        if (app == null || app.is_window_backed()) {
            return false;
        }
        if (!global.settings.is_writable('favorite-apps'))
            return false;
        let id = app.get_id();
        let favorites = AppFavorites.getAppFavorites().getFavoriteMap();
        let srcIsFavorite = (id in favorites);
        let favPos = 0;
        let children = this._box.get_children();
        for (let i = 0; i < this._dragPlaceholderPos; i++) {
            if (this._dragPlaceholder &&
                children[i] == this._dragPlaceholder)
                continue;
            let childId = children[i].child._delegate.app.get_id();
            if (childId == id)
                continue;
            if (childId in favorites)
                favPos++;
        }
        // No drag placeholder means we don't wan't to favorite the app
        // and we are dragging it to its original position
        if (!this._dragPlaceholder)
            return true;
        Meta.later_add(Meta.LaterType.BEFORE_REDRAW, Lang.bind(this,
            function () {
                let appFavorites = AppFavorites.getAppFavorites();
                if (srcIsFavorite)
                    appFavorites.moveFavoriteToPos(id, favPos);
                else
                    appFavorites.addFavoriteAtPos(id, favPos);
                return false;
            }));
        return true;
    }
Signals.addSignalMethods(Dash.prototype);
(uuay)misc/6
shell/
runDialog.js
// -*- mode: js; js-indent-level: 4; indent-tabs-mode: nil -*-
const Clutter = imports.gi.Clutter;
const Gio = imports.gi.Gio;
const GLib = imports.gi.GLib;
const Lang = imports.lang;
const Meta = imports.gi.Meta;
const St = imports.gi.St;
const Shell = imports.gi.Shell;
const Signals = imports.signals;
const FileUtils = imports.misc.fileUtils;
const Main = imports.ui.main;
const ModalDialog = imports.ui.modalDialog;
const ShellEntry = imports.ui.shellEntry;
const Tweener = imports.ui.tweener;
const Util = imports.misc.util;
const History = imports.misc.history;
const MAX_FILE_DELETED_BEFORE_INVALID = 10;
const HISTORY_KEY = 'command-history';
const LOCKDOWN_SCHEMA = 'org.gnome.desktop.lockdown';
const DISABLE_COMMAND_LINE_KEY = 'disable-command-line';
const TERMINAL_SCHEMA = 'org.gnome.desktop.default-applications.terminal';
const EXEC_KEY = 'exec';
const EXEC_ARG_KEY = 'exec-arg';
const DIALOG_GROW_TIME = 0.1;
const RunDialog = new Lang.Class({
    Name: 'RunDialog',
    Extends: ModalDialog.ModalDialog,
    _init : function() {
        this.parent({ styleClass: 'run-dialog',
                      destroyOnClose: false });
        this._lockdownSettings = new Gio.Settings({ schema_id: LOCKDOWN_SCHEMA });
        this._terminalSettings = new Gio.Settings({ schema_id: TERMINAL_SCHEMA });
        global.settings.connect('changed::development-tools', Lang.bind(this, function () {
            this._enableInternalCommands = global.settings.get_boolean('development-tools');
        }));
        this._enableInternalCommands = global.settings.get_boolean('development-tools');
        this._internalCommands = { 'lg':
                                   Lang.bind(this, function() {
                                       Main.createLookingGlass().open();
                                   }),
                                   'r': Lang.bind(this, this._restart),
                                   // Developer brain backwards compatibility
                                   'restart': Lang.bind(this, this._restart),
                                   'debugexit': Lang.bind(this, function() {
                                       Meta.quit(Meta.ExitCode.ERROR);
                                   }),
                                   // rt is short for "reload theme"
                                   'rt': Lang.bind(this, function() {
                                       Main.reloadThemeResource();
                                       Main.loadTheme();
                                   })
                                 };
        let label = new St.Label({ style_class: 'run-dialog-label',
                                   text: _("Enter a Command") });
        this.contentLayout.add(label, { x_fill: false,
                                        x_align: St.Align.START,
                                        y_align: St.Align.START });
        let entry = new St.Entry({ style_class: 'run-dialog-entry',
                                   can_focus: true });
        ShellEntry.addContextMenu(entry);
        entry.label_actor = label;
        this._entryText = entry.clutter_text;
        this.contentLayout.add(entry, { y_align: St.Align.START });
        this.setInitialKeyFocus(this._entryText);
        this._errorBox = new St.BoxLayout({ style_class: 'run-dialog-error-box' });
        this.contentLayout.add(this._errorBox, { expand: true });
        let errorIcon = new St.Icon({ icon_name: 'dialog-error-symbolic',
                                      icon_size: 24,
                                      style_class: 'run-dialog-error-icon' });
        this._errorBox.add(errorIcon, { y_align: St.Align.MIDDLE });
        this._commandError = false;
        this._errorMessage = new St.Label({ style_class: 'run-dialog-error-label' });
        this._errorMessage.clutter_text.line_wrap = true;
        this._errorBox.add(this._errorMessage, { expand: true,
                                                 x_align: St.Align.START,
                                                 x_fill: false,
                                                 y_align: St.Align.MIDDLE,
                                                 y_fill: false });
        this._errorBox.hide();
        this.setButtons([{ action: Lang.bind(this, this.close),
                           label: _("Close"),
                           key: Clutter.Escape }]);
        this._pathCompleter = new Gio.FilenameCompleter();
        this._history = new History.HistoryManager({ gsettingsKey: HISTORY_KEY,
                                                     entry: this._entryText });
        this._entryText.connect('key-press-event', Lang.bind(this, function(o, e) {
            let symbol = e.get_key_symbol();
            if (symbol == Clutter.Return || symbol == Clutter.KP_Enter) {
                this.popModal();
                this._run(o.get_text(),
                          e.get_state() & Clutter.ModifierType.CONTROL_MASK);
                if (!this._commandError ||
                    !this.pushModal())
                    this.close();
                return Clutter.EVENT_STOP;
            }
            if (symbol == Clutter.Tab) {
                let text = o.get_text();
                let prefix;
                if (text.lastIndexOf(' ') == -1)
                    prefix = text;
                else
                    prefix = text.substr(text.lastIndexOf(' ') + 1);
                let postfix = this._getCompletion(prefix);
                if (postfix != null && postfix.length > 0) {
                    o.insert_text(postfix, -1);
                    o.set_cursor_position(text.length + postfix.length);
                }
                return Clutter.EVENT_STOP;
            }
            return Clutter.EVENT_PROPAGATE;
        }));
    },
    _getCommandCompletion: function(text) {
        function _getCommon(s1, s2) {
            if (s1 == null)
                return s2;
            let k = 0;
            for (; k < s1.length && k < s2.length; k++) {
                if (s1[k] != s2[k])
                    break;
            }
            if (k == 0)
                return '';
            return s1.substr(0, k);
        }
        let paths = GLib.getenv('PATH').split(':');
        paths.push(GLib.get_home_dir());
        let someResults = paths.map(function(path) {
            let results = [];
            try {
                let file = Gio.File.new_for_path(path);
                let fileEnum = file.enumerate_children('standard::name', Gio.FileQueryInfoFlags.NONE, null);
                let info;
                while ((info = fileEnum.next_file(null))) {
                    let name = info.get_name();
                    if (name.slice(0, text.length) == text)
                        results.push(name);
                }
            } catch (e if (!e.matches(Gio.IOErrorEnum, Gio.IOErrorEnum.NOT_FOUND) &&
                           !e.matches(Gio.IOErrorEnum, Gio.IOErrorEnum.NOT_DIRECTORY))) {
                log(e);
            } finally {
                return results;
            }
        });
        let results = someResults.reduce(function(a, b) {
            return a.concat(b);
        }, []);
        if (!results.length)
            return null;
        let common = results.reduce(_getCommon, null);
        return common.substr(text.length);
    },
    _getCompletion : function(text) {
        if (text.indexOf('/') != -1) {
            return this._pathCompleter.get_completion_suffix(text);
        } else {
            return this._getCommandCompletion(text);
        }
    },
    _run : function(input, inTerminal) {
        let command = input;
        this._history.addItem(input);
        this._commandError = false;
        let f;
        if (this._enableInternalCommands)
            f = this._internalCommands[input];
        else
            f = null;
        if (f) {
            f();
        } else if (input) {
            try {
                if (inTerminal) {
                    let exec = this._terminalSettings.get_string(EXEC_KEY);
                    let exec_arg = this._terminalSettings.get_string(EXEC_ARG_KEY);
                    command = exec + ' ' + exec_arg + ' ' + input;
                }
                Util.trySpawnCommandLine(command);
            } catch (e) {
                // Mmmh, that failed - see if @input matches an existing file
                let path = null;
                if (input.charAt(0) == '/') {
                    path = input;
                } else {
                    if (input.charAt(0) == '~')
                        input = input.slice(1);
                    path = GLib.get_home_dir() + '/' + input;
                }
                if (GLib.file_test(path, GLib.FileTest.EXISTS)) {
                    let file = Gio.file_new_for_path(path);
                    try {
                        Gio.app_info_launch_default_for_uri(file.get_uri(),
                                                            global.create_app_launch_context(0, -1));
                    } catch (e) {
                        // The exception from gjs contains an error string like:
                        //     Error invoking Gio.app_info_launch_default_for_uri: No application
                        //     is registered as handling this file
                        // We are only interested in the part after the first colon.
                        let message = e.message.replace(/[^:]*: *(.+)/, '$1');
                        this._showError(message);
                    }
                } else {
                    this._showError(e.message);
                }
            }
        }
    },
    _showError : function(message) {
        this._commandError = true;
        this._errorMessage.set_text(message);
        if (!this._errorBox.visible) {
            let [errorBoxMinHeight, errorBoxNaturalHeight] = this._errorBox.get_preferred_height(-1);
            let parentActor = this._errorBox.get_parent();
            Tweener.addTween(parentActor,
                             { height: parentActor.height + errorBoxNaturalHeight,
                               time: DIALOG_GROW_TIME,
                               transition: 'easeOutQuad',
                               onComplete: Lang.bind(this,
                                                     function() {
                                                         parentActor.set_height(-1);
                                                         this._errorBox.show();
                                                     })
                             });
        }
    },
    _restart: function() {
        if (Meta.is_wayland_compositor()) {
            this._showError('Restart is not available on Wayland');
            return;
        }
        this._shouldFadeOut = false;
        this.close();
        Meta.restart(_("Restarting
"));
    },
    open: function() {
        this._history.lastItem();
        this._errorBox.hide();
        this._entryText.set_text('');
        this._commandError = false;
        if (this._lockdownSettings.get_boolean(DISABLE_COMMAND_LINE_KEY))
            return;
        this.parent();
    },
Signals.addSignalMethods(RunDialog.prototype);
(uuay)osdMonitorLabeler.js
// -*- mode: js; js-indent-level: 4; indent-tabs-mode: nil -*-
const Clutter = imports.gi.Clutter;
const Gio = imports.gi.Gio;
const St = imports.gi.St;
const Lang = imports.lang;
const Main = imports.ui.main;
const Tweener = imports.ui.tweener;
const Meta = imports.gi.Meta;
const FADE_TIME = 0.1;
const OsdMonitorLabel = new Lang.Class({
    Name: 'OsdMonitorLabel',
    _init: function(monitor, label) {
        this._actor = new St.Widget({ x_expand: true,
                                      y_expand: true });
        this._monitor = monitor;
        this._box = new St.BoxLayout({ style_class: 'osd-window',
                                       vertical: true });
        this._actor.add_actor(this._box);
        this._label = new St.Label({ style_class: 'osd-monitor-label',
                                     text: label });
        this._box.add(this._label);
        Main.uiGroup.add_child(this._actor);
        Main.uiGroup.set_child_above_sibling(this._actor, null);
        this._position();
        Meta.disable_unredirect_for_screen(global.screen);
    },
    _position: function() {
        let workArea = Main.layoutManager.getWorkAreaForMonitor(this._monitor);
        if (Clutter.get_default_text_direction() == Clutter.TextDirection.RTL)
            this._box.x = workArea.x + (workArea.width - this._box.width);
        else
            this._box.x = workArea.x;
        this._box.y = workArea.y;
    },
    destroy: function() {
        this._actor.destroy();
        Meta.enable_unredirect_for_screen(global.screen);
    }
const OsdMonitorLabeler = new Lang.Class({
    Name: 'OsdMonitorLabeler',
    _init: function() {
        this._monitorManager = Meta.MonitorManager.get();
        this._client = null;
        this._clientWatchId = 0;
        this._osdLabels = [];
        this._monitorLabels = null;
        Main.layoutManager.connect('monitors-changed',
                                    Lang.bind(this, this._reset));
        this._reset();
    },
    _reset: function() {
        for (let i in this._osdLabels)
            this._osdLabels[i].destroy();
        this._osdLabels = [];
        this._monitorLabels = new Map();
        let monitors = Main.layoutManager.monitors;
        for (let i in monitors)
            this._monitorLabels.set(monitors[i].index, []);
    },
    _trackClient: function(client) {
        if (this._client)
            return (this._client == client);
        this._client = client;
        this._clientWatchId = Gio.bus_watch_name(Gio.BusType.SESSION, client, 0, null,
                                                 Lang.bind(this, function(c, name) {
                                                     this.hide(name);
                                                 }));
        return true;
    },
    _untrackClient: function(client) {
        if (!this._client || this._client != client)
            return false;
        Gio.bus_unwatch_name(this._clientWatchId);
        this._clientWatchId = 0;
        this._client = null;
        return true;
    },
    show: function(client, params) {
        if (!this._trackClient(client))
            return;
        this._reset();
        for (let id in params) {
            let monitor = this._monitorManager.get_monitor_for_output(id);
            if (monitor == -1)
                continue;
            this._monitorLabels.get(monitor).push(params[id].deep_unpack());
        }
        // In mirrored display setups, more than one physical outputs
        // might be showing the same logical monitor. In that case, we
        // join each output's labels on the same OSD widget.
        for (let [monitor, labels] of this._monitorLabels.entries()) {
            labels.sort();
            this._osdLabels.push(new OsdMonitorLabel(monitor, labels.join(' ')));
        }
    },
    hide: function(client) {
        if (!this._untrackClient(client))
            return;
        this._reset();
    }
(uuay)screencast.js
// -*- mode: js; js-indent-level: 4; indent-tabs-mode: nil -*-
const Lang = imports.lang;
const Main = imports.ui.main;
const PanelMenu = imports.ui.panelMenu;
const Indicator = new Lang.Class({
    Name: 'ScreencastIndicator',
    Extends: PanelMenu.SystemIndicator,
    _init: function() {
        this.parent();
        this._indicator = this._addIndicator();
        this._indicator.icon_name = 'media-record-symbolic';
        this._indicator.add_style_class_name('screencast-indicator');
        this._sync();
        Main.screencastService.connect('updated', Lang.bind(this, this._sync));
    },
    _sync: function() {
        this._indicator.visible = Main.screencastService.isRecording;
    },
(uuay)system.js
// -*- mode: js; js-indent-level: 4; indent-tabs-mode: nil -*-
const AccountsService = imports.gi.AccountsService;
const Clutter = imports.gi.Clutter;
const Gdm = imports.gi.Gdm;
const Gio = imports.gi.Gio;
const GLib = imports.gi.GLib;
const Lang = imports.lang;
const Meta = imports.gi.Meta;
const Shell = imports.gi.Shell;
const St = imports.gi.St;
const BoxPointer = imports.ui.boxpointer;
const GnomeSession = imports.misc.gnomeSession;
const LoginManager = imports.misc.loginManager;
const Main = imports.ui.main;
const PanelMenu = imports.ui.panelMenu;
const PopupMenu = imports.ui.popupMenu;
const LOCKDOWN_SCHEMA = 'org.gnome.desktop.lockdown';
const LOGIN_SCREEN_SCHEMA = 'org.gnome.login-screen';
const DISABLE_USER_SWITCH_KEY = 'disable-user-switching';
const DISABLE_LOCK_SCREEN_KEY = 'disable-lock-screen';
const DISABLE_LOG_OUT_KEY = 'disable-log-out';
const DISABLE_RESTART_KEY = 'disable-restart-buttons';
const ALWAYS_SHOW_LOG_OUT_KEY = 'always-show-log-out';
const SENSOR_BUS_NAME = 'net.hadess.SensorProxy';
const SENSOR_OBJECT_PATH = '/net/hadess/SensorProxy';
const SensorProxyInterface = '<node> \
<interface name="net.hadess.SensorProxy"> \
  <property name="HasAccelerometer" type="b" access="read"/> \
</interface> \
</node>';
const SensorProxy = Gio.DBusProxy.makeProxyWrapper(SensorProxyInterface);
const AltSwitcher = new Lang.Class({
    Name: 'AltSwitcher',
    _init: function(standard, alternate) {
        this._standard = standard;
        this._standard.connect('notify::visible', Lang.bind(this, this._sync));
        this._alternate = alternate;
        this._alternate.connect('notify::visible', Lang.bind(this, this._sync));
        this._capturedEventId = global.stage.connect('captured-event', Lang.bind(this, this._onCapturedEvent));
        this.actor = new St.Bin();
        this.actor.connect('destroy', Lang.bind(this, this._onDestroy));
    },
    _sync: function() {
        let childToShow = null;
        if (this._standard.visible && this._alternate.visible) {
            let [x, y, mods] = global.get_pointer();
            let altPressed = (mods & Clutter.ModifierType.MOD1_MASK) != 0;
            childToShow = altPressed ? this._alternate : this._standard;
        } else if (this._standard.visible) {
            childToShow = this._standard;
        } else if (this._alternate.visible) {
            childToShow = this._alternate;
        }
        if (this.actor.get_child() != childToShow) {
            let hasFocus = this.actor.contains(global.stage.get_key_focus());
            this.actor.set_child(childToShow);
            if (hasFocus)
                childToShow.grab_key_focus();
            // The actors might respond to hover, so
            // sync the pointer to make sure they update.
            global.sync_pointer();
        }
        this.actor.visible = (childToShow != null);
    },
    _onDestroy: function() {
        if (this._capturedEventId > 0) {
            global.stage.disconnect(this._capturedEventId);
            this._capturedEventId = 0;
        }
    },
    _onCapturedEvent: function(actor, event) {
        let type = event.type();
        if (type == Clutter.EventType.KEY_PRESS || type == Clutter.EventType.KEY_RELEASE) {
            let key = event.get_key_symbol();
            if (key == Clutter.KEY_Alt_L || key == Clutter.KEY_Alt_R)
                this._sync();
        }
        return Clutter.EVENT_PROPAGATE;
    },
const Indicator = new Lang.Class({
    Name: 'SystemIndicator',
    Extends: PanelMenu.SystemIndicator,
    _init: function() {
        this.parent();
        this._loginScreenSettings = new Gio.Settings({ schema_id: LOGIN_SCREEN_SCHEMA });
        this._lockdownSettings = new Gio.Settings({ schema_id: LOCKDOWN_SCHEMA });
        this._orientationSettings = new Gio.Settings({ schema_id: 'org.gnome.settings-daemon.peripherals.touchscreen' });
        this._session = new GnomeSession.SessionManager();
        this._loginManager = LoginManager.getLoginManager();
        this._monitorManager = Meta.MonitorManager.get();
        this._haveShutdown = true;
        this._haveSuspend = true;
        this._userManager = AccountsService.UserManager.get_default();
        this._user = this._userManager.get_user(GLib.get_user_name());
        this._createSubMenu();
        this._userManager.connect('notify::is-loaded',
                                  Lang.bind(this, this._updateMultiUser));
        this._userManager.connect('notify::has-multiple-users',
                                  Lang.bind(this, this._updateMultiUser));
        this._userManager.connect('user-added',
                                  Lang.bind(this, this._updateMultiUser));
        this._userManager.connect('user-removed',
                                  Lang.bind(this, this._updateMultiUser));
        this._lockdownSettings.connect('changed::' + DISABLE_USER_SWITCH_KEY,
                                       Lang.bind(this, this._updateMultiUser));
        this._lockdownSettings.connect('changed::' + DISABLE_LOG_OUT_KEY,
                                       Lang.bind(this, this._updateMultiUser));
        this._lockdownSettings.connect('changed::' + DISABLE_LOCK_SCREEN_KEY,
                                       Lang.bind(this, this._updateLockScreen));
        global.settings.connect('changed::' + ALWAYS_SHOW_LOG_OUT_KEY,
                                Lang.bind(this, this._updateMultiUser));
        this._updateSwitchUser();
        this._updateMultiUser();
        this._updateLockScreen();
        // Whether shutdown is available or not depends on both lockdown
        // settings (disable-log-out) and Polkit policy - the latter doesn't
        // notify, so we update the menu item each time the menu opens or
        // the lockdown setting changes, which should be close enough.
        this.menu.connect('open-state-changed', Lang.bind(this,
            function(menu, open) {
                if (!open)
                    return;
                this._updateHaveShutdown();
                this._updateHaveSuspend();
            }));
        this._lockdownSettings.connect('changed::' + DISABLE_LOG_OUT_KEY,
                                       Lang.bind(this, this._updateHaveShutdown));
        this._orientationSettings.connect('changed::orientation-lock',
                                          Lang.bind(this, this._updateOrientationLock));
        Main.layoutManager.connect('monitors-changed',
                                   Lang.bind(this, this._updateOrientationLock));
        Gio.DBus.system.watch_name(SENSOR_BUS_NAME,
                                   Gio.BusNameWatcherFlags.NONE,
                                   Lang.bind(this, this._sensorProxyAppeared),
                                   Lang.bind(this, function() {
                                       this._sensorProxy = null;
                                       this._updateOrientationLock();
                                   }));
        this._updateOrientationLock();
        Main.sessionMode.connect('updated', Lang.bind(this, this._sessionUpdated));
        this._sessionUpdated();
    },
    _sensorProxyAppeared: function() {
        this._sensorProxy = new SensorProxy(Gio.DBus.system, SENSOR_BUS_NAME, SENSOR_OBJECT_PATH,
            Lang.bind(this, function(proxy, error) {
                if (error) {
                    log(error.message);
                    return;
                }
                this._sensorProxy.connect('g-properties-changed',
                                          Lang.bind(this, this._updateOrientationLock));
                this._updateOrientationLock();
            }));
    },
    _updateActionsVisibility: function() {
        let visible = (this._settingsAction.visible ||
                       this._orientationLockAction.visible ||
                       this._lockScreenAction.visible ||
                       this._altSwitcher.actor.visible);
        this._actionsItem.actor.visible = visible;
    },
    _sessionUpdated: function() {
        this._updateLockScreen();
        this._updatePowerOff();
        this._updateSuspend();
        this._updateMultiUser();
        this._settingsAction.visible = Main.sessionMode.allowSettings;
        this._updateActionsVisibility();
    },
    _updateMultiUser: function() {
        let shouldShowInMode = !Main.sessionMode.isLocked && !Main.sessionMode.isGreeter;
        let hasSwitchUser = this._updateSwitchUser();
        let hasLogout = this._updateLogout();
        this._switchUserSubMenu.actor.visible = shouldShowInMode && (hasSwitchUser || hasLogout);
    },
    _updateSwitchUser: function() {
        let allowSwitch = !this._lockdownSettings.get_boolean(DISABLE_USER_SWITCH_KEY);
        let multiUser = this._userManager.can_switch() && this._userManager.has_multiple_users;
        let visible = allowSwitch && multiUser;
        this._loginScreenItem.actor.visible = visible;
        return visible;
    },
    _updateLogout: function() {
        let allowLogout = !this._lockdownSettings.get_boolean(DISABLE_LOG_OUT_KEY);
        let alwaysShow = global.settings.get_boolean(ALWAYS_SHOW_LOG_OUT_KEY);
        let systemAccount = this._user.system_account;
        let localAccount = this._user.local_account;
        let multiUser = this._userManager.has_multiple_users;
        let multiSession = Gdm.get_session_ids().length > 1;
        let visible = allowLogout && (alwaysShow || multiUser || multiSession || systemAccount || !localAccount);
        this._logoutItem.actor.visible = visible;
        return visible;
    },
    _updateSwitchUserSubMenu: function() {
        this._switchUserSubMenu.label.text = this._user.get_real_name();
        let clutterText = this._switchUserSubMenu.label.clutter_text;
        // XXX -- for some reason, the ClutterText's width changes
        // rapidly unless we force a relayout of the actor. Probably
        // a size cache issue or something. Moving this to be a layout
        // manager would be a much better idea.
        clutterText.get_allocation_box();
        let layout = clutterText.get_layout();
        if (layout.is_ellipsized())
            this._switchUserSubMenu.label.text = this._user.get_user_name();
        let iconFile = this._user.get_icon_file();
        if (iconFile && !GLib.file_test(iconFile, GLib.FileTest.EXISTS))
            iconFile = null;
        if (iconFile) {
            let file = Gio.File.new_for_path(iconFile);
            let gicon = new Gio.FileIcon({ file: file });
            this._switchUserSubMenu.icon.gicon = gicon;
            this._switchUserSubMenu.icon.add_style_class_name('user-icon');
            this._switchUserSubMenu.icon.remove_style_class_name('default-icon');
        } else {
            this._switchUserSubMenu.icon.icon_name = 'avatar-default-symbolic';
            this._switchUserSubMenu.icon.add_style_class_name('default-icon');
            this._switchUserSubMenu.icon.remove_style_class_name('user-icon');
        }
    },
    _updateOrientationLock: function() {
        if (this._sensorProxy)
            this._orientationLockAction.visible = this._sensorProxy.HasAccelerometer &&
                                                  this._monitorManager.get_is_builtin_display_on();
        else
            this._orientationLockAction.visible = false;
        let locked = this._orientationSettings.get_boolean('orientation-lock');
        let icon = this._orientationLockAction.child;
        icon.icon_name = locked ? 'rotation-locked-symbolic' : 'rotation-allowed-symbolic';
        this._updateActionsVisibility();
    },
    _updateLockScreen: function() {
        let showLock = !Main.sessionMode.isLocked && !Main.sessionMode.isGreeter;
        let allowLockScreen = !this._lockdownSettings.get_boolean(DISABLE_LOCK_SCREEN_KEY);
        this._lockScreenAction.visible = showLock && allowLockScreen && LoginManager.canLock();
        this._updateActionsVisibility();
    },
    _updateHaveShutdown: function() {
        this._session.CanShutdownRemote(Lang.bind(this, function(result, error) {
            if (error)
                return;
            this._haveShutdown = result[0];
            this._updatePowerOff();
        }));
    },
    _updatePowerOff: function() {
        let disabled = Main.sessionMode.isLocked ||
                       (Main.sessionMode.isGreeter &&
                        this._loginScreenSettings.get_boolean(DISABLE_RESTART_KEY));
        this._powerOffAction.visible = this._haveShutdown && !disabled;
        this._updateActionsVisibility();
    },
    _updateHaveSuspend: function() {
        this._loginManager.canSuspend(Lang.bind(this,
            function(canSuspend, needsAuth) {
                this._haveSuspend = canSuspend;
                this._suspendNeedsAuth = needsAuth;
                this._updateSuspend();
            }));
    },
    _updateSuspend: function() {
        let disabled = (Main.sessionMode.isLocked &&
                        this._suspendNeedsAuth) ||
                       (Main.sessionMode.isGreeter &&
                        this._loginScreenSettings.get_boolean(DISABLE_RESTART_KEY));
        this._suspendAction.visible = this._haveSuspend && !disabled;
        this._updateActionsVisibility();
    },
    _createActionButton: function(iconName, accessibleName) {
        let icon = new St.Button({ reactive: true,
                                   can_focus: true,
                                   track_hover: true,
                                   accessible_name: accessibleName,
                                   style_class: 'system-menu-action' });
        icon.child = new St.Icon({ icon_name: iconName });
        return icon;
    },
    _createSubMenu: function() {
        let item;
        this._switchUserSubMenu = new PopupMenu.PopupSubMenuMenuItem('', true);
        this._switchUserSubMenu.icon.style_class = 'system-switch-user-submenu-icon';
        // Since the label of the switch user submenu depends on the width of
        // the popup menu, and we can't easily connect on allocation-changed
        // or notify::width without creating layout cycles, simply update the
        // label whenever the menu is opened.
        this.menu.connect('open-state-changed', Lang.bind(this, function(menu, isOpen) {
            if (isOpen)
                this._updateSwitchUserSubMenu();
        }));
        item = new PopupMenu.PopupMenuItem(_("Switch User"));
        item.connect('activate', Lang.bind(this, this._onLoginScreenActivate));
        this._switchUserSubMenu.menu.addMenuItem(item);
        this._loginScreenItem = item;
        item = new PopupMenu.PopupMenuItem(_("Log Out"));
        item.connect('activate', Lang.bind(this, this._onQuitSessionActivate));
        this._switchUserSubMenu.menu.addMenuItem(item);
        this._logoutItem = item;
        this._switchUserSubMenu.menu.addSettingsAction(_("Account Settings"),
                                                       'gnome-user-accounts-panel.desktop');
        this._user.connect('notify::is-loaded', Lang.bind(this, this._updateSwitchUserSubMenu));
        this._user.connect('changed', Lang.bind(this, this._updateSwitchUserSubMenu));
        this.menu.addMenuItem(this._switchUserSubMenu);
        this.menu.addMenuItem(new PopupMenu.PopupSeparatorMenuItem());
        item = new PopupMenu.PopupBaseMenuItem({ reactive: false,
                                                 can_focus: false });
        this._settingsAction = this._createActionButton('preferences-system-symbolic', _("Settings"));
        this._settingsAction.connect('clicked', Lang.bind(this, this._onSettingsClicked));
        item.actor.add(this._settingsAction, { expand: true, x_fill: false });
        this._orientationLockAction = this._createActionButton('', _("Orientation Lock"));
        this._orientationLockAction.connect('clicked', Lang.bind(this, this._onOrientationLockClicked));
        item.actor.add(this._orientationLockAction, { expand: true, x_fill: false });
        this._lockScreenAction = this._createActionButton('changes-prevent-symbolic', _("Lock"));
        this._lockScreenAction.connect('clicked', Lang.bind(this, this._onLockScreenClicked));
        item.actor.add(this._lockScreenAction, { expand: true, x_fill: false });
        this._suspendAction = this._createActionButton('media-playback-pause-symbolic', _("Suspend"));
        this._suspendAction.connect('clicked', Lang.bind(this, this._onSuspendClicked));
        this._powerOffAction = this._createActionButton('system-shutdown-symbolic', _("Power Off"));
        this._powerOffAction.connect('clicked', Lang.bind(this, this._onPowerOffClicked));
        this._altSwitcher = new AltSwitcher(this._powerOffAction, this._suspendAction);
        item.actor.add(this._altSwitcher.actor, { expand: true, x_fill: false });
        this._actionsItem = item;
        this.menu.addMenuItem(item);
    },
    _onSettingsClicked: function() {
        this.menu.itemActivated();
        let app = Shell.AppSystem.get_default().lookup_app('gnome-control-center.desktop');
        Main.overview.hide();
        app.activate();
    },
    _onOrientationLockClicked: function() {
        this.menu.itemActivated();
        let locked = this._orientationSettings.get_boolean('orientation-lock');
        this._orientationSettings.set_boolean('orientation-lock', !locked);
        this._updateOrientationLock();
    },
    _onLockScreenClicked: function() {
        this.menu.itemActivated(BoxPointer.PopupAnimation.NONE);
        Main.overview.hide();
        Main.screenShield.lock(true);
    },
    _onLoginScreenActivate: function() {
        this.menu.itemActivated(BoxPointer.PopupAnimation.NONE);
        Main.overview.hide();
        if (Main.screenShield)
            Main.screenShield.lock(false);
        Clutter.threads_add_repaint_func_full(Clutter.RepaintFlags.POST_PAINT, function() {
            Gdm.goto_login_session_sync(null);
            return false;
        });
    },
    _onQuitSessionActivate: function() {
        Main.overview.hide();
        this._session.LogoutRemote(0);
    },
    _onPowerOffClicked: function() {
        this.menu.itemActivated();
        Main.overview.hide();
        this._session.ShutdownRemote(0);
    },
    _onSuspendClicked: function() {
        this.menu.itemActivated();
        this._loginManager.suspend();
    },
(uuay)shellEntry.js
// -*- mode: js; js-indent-level: 4; indent-tabs-mode: nil -*-
const Clutter = imports.gi.Clutter;
const Gtk = imports.gi.Gtk;
const Lang = imports.lang;
const St = imports.gi.St;
const BoxPointer = imports.ui.boxpointer;
const Main = imports.ui.main;
const Params = imports.misc.params;
const PopupMenu = imports.ui.popupMenu;
const EntryMenu = new Lang.Class({
    Name: 'ShellEntryMenu',
    Extends: PopupMenu.PopupMenu,
    _init: function(entry) {
        this.parent(entry, 0, St.Side.TOP);
        this._entry = entry;
        this._clipboard = St.Clipboard.get_default();
        // Populate menu
        let item;
        item = new PopupMenu.PopupMenuItem(_("Copy"));
        item.connect('activate', Lang.bind(this, this._onCopyActivated));
        this.addMenuItem(item);
        this._copyItem = item;
        item = new PopupMenu.PopupMenuItem(_("Paste"));
        item.connect('activate', Lang.bind(this, this._onPasteActivated));
        this.addMenuItem(item);
        this._pasteItem = item;
        this._passwordItem = null;
        Main.uiGroup.add_actor(this.actor);
        this.actor.hide();
    },
    _makePasswordItem: function() {
        let item = new PopupMenu.PopupMenuItem('');
        item.connect('activate', Lang.bind(this,
                                           this._onPasswordActivated));
        this.addMenuItem(item);
        this._passwordItem = item;
    },
    get isPassword() {
        return this._passwordItem != null;
    },
    set isPassword(v) {
        if (v == this.isPassword)
            return;
        if (v) {
            this._makePasswordItem();
            this._entry.input_purpose = Gtk.InputPurpose.PASSWORD;
        } else {
            this._passwordItem.destroy();
            this._passwordItem = null;
            this._entry.input_purpose = Gtk.InputPurpose.FREE_FORM;
        }
    },
    open: function(animate) {
        this._updatePasteItem();
        this._updateCopyItem();
        if (this._passwordItem)
            this._updatePasswordItem();
        this.parent(animate);
        this._entry.add_style_pseudo_class('focus');
        let direction = Gtk.DirectionType.TAB_FORWARD;
        if (!this.actor.navigate_focus(null, direction, false))
            this.actor.grab_key_focus();
    },
    _updateCopyItem: function() {
        let selection = this._entry.clutter_text.get_selection();
        this._copyItem.setSensitive(!this._entry.clutter_text.password_char &&
                                    selection && selection != '');
    },
    _updatePasteItem: function() {
        this._clipboard.get_text(St.ClipboardType.CLIPBOARD, Lang.bind(this,
            function(clipboard, text) {
                this._pasteItem.setSensitive(text && text != '');
            }));
    },
    _updatePasswordItem: function() {
        let textHidden = (this._entry.clutter_text.password_char);
        if (textHidden)
            this._passwordItem.label.set_text(_("Show Text"));
        else
            this._passwordItem.label.set_text(_("Hide Text"));
    },
    _onCopyActivated: function() {
        let selection = this._entry.clutter_text.get_selection();
        this._clipboard.set_text(St.ClipboardType.CLIPBOARD, selection);
    },
    _onPasteActivated: function() {
        this._clipboard.get_text(St.ClipboardType.CLIPBOARD, Lang.bind(this,
            function(clipboard, text) {
                if (!text)
                    return;
                this._entry.clutter_text.delete_selection();
                let pos = this._entry.clutter_text.get_cursor_position();
                this._entry.clutter_text.insert_text(text, pos);
            }));
    },
    _onPasswordActivated: function() {
        let visible = !!(this._entry.clutter_text.password_char);
        this._entry.clutter_text.set_password_char(visible ? '' : '\u25cf');
    }
function _setMenuAlignment(entry, stageX) {
    let [success, entryX, entryY] = entry.transform_stage_point(stageX, 0);
    if (success)
        entry.menu.setSourceAlignment(entryX / entry.width);
function _onButtonPressEvent(actor, event, entry) {
    if (entry.menu.isOpen) {
        entry.menu.close(BoxPointer.PopupAnimation.FULL);
        return Clutter.EVENT_STOP;
    } else if (event.get_button() == 3) {
        let [stageX, stageY] = event.get_coords();
        _setMenuAlignment(entry, stageX);
        entry.menu.open(BoxPointer.PopupAnimation.FULL);
        return Clutter.EVENT_STOP;
    }
    return Clutter.EVENT_PROPAGATE;
function _onPopup(actor, entry) {
    let [success, textX, textY, lineHeight] = entry.clutter_text.position_to_coords(-1);
    if (success)
        entry.menu.setSourceAlignment(textX / entry.width);
    entry.menu.open(BoxPointer.PopupAnimation.FULL);
function addContextMenu(entry, params) {
    if (entry.menu)
        return;
    params = Params.parse (params, { isPassword: false });
    entry.menu = new EntryMenu(entry);
    entry.menu.isPassword = params.isPassword;
    entry._menuManager = new PopupMenu.PopupMenuManager({ actor: entry });
    entry._menuManager.addMenu(entry.menu);
    // Add an event handler to both the entry and its clutter_text; the former
    // so padding is included in the clickable area, the latter because the
    // event processing of ClutterText prevents event-bubbling.
    entry.clutter_text.connect('button-press-event', Lang.bind(null, _onButtonPressEvent, entry));
    entry.connect('button-press-event', Lang.bind(null, _onButtonPressEvent, entry));
    entry.connect('popup-menu', Lang.bind(null, _onPopup, entry));
    entry.connect('destroy', function() {
        entry.menu.destroy();
        entry.menu = null;
        entry._menuManager = null;
    });
(uuay)userWidget.js
// -*- mode: js; js-indent-level: 4; indent-tabs-mode: nil -*-
// A widget showing the user avatar and name
const Clutter = imports.gi.Clutter;
const AccountsService = imports.gi.AccountsService;
const GLib = imports.gi.GLib;
const Gio = imports.gi.Gio;
const GObject = imports.gi.GObject;
const Lang = imports.lang;
const St = imports.gi.St;
const Params = imports.misc.params;
const AVATAR_ICON_SIZE = 64;
// Adapted from gdm/gui/user-switch-applet/applet.c
// Copyright (C) 2004-2005 James M. Cape <jcape@ignore-your.tv>.
// Copyright (C) 2008,2009 Red Hat, Inc.
const Avatar = new Lang.Class({
    Name: 'Avatar',
    _init: function(user, params) {
        this._user = user;
        params = Params.parse(params, { reactive: false,
                                        iconSize: AVATAR_ICON_SIZE,
                                        styleClass: 'framed-user-icon' });
        this._iconSize = params.iconSize;
        let scaleFactor = St.ThemeContext.get_for_stage(global.stage).scale_factor;
        this.actor = new St.Bin({ style_class: params.styleClass,
                                  track_hover: params.reactive,
                                  reactive: params.reactive,
                                  width: this._iconSize * scaleFactor,
                                  height: this._iconSize * scaleFactor });
    },
    setSensitive: function(sensitive) {
        this.actor.can_focus = sensitive;
        this.actor.reactive = sensitive;
    },
    update: function() {
        let iconFile = this._user.get_icon_file();
        if (iconFile && !GLib.file_test(iconFile, GLib.FileTest.EXISTS))
            iconFile = null;
        if (iconFile) {
            let file = Gio.File.new_for_path(iconFile);
            this.actor.child = null;
            this.actor.style = 'background-image: url("%s");'.format(iconFile);
        } else {
            this.actor.style = null;
            this.actor.child = new St.Icon({ icon_name: 'avatar-default-symbolic',
                                             icon_size: this._iconSize });
        }
    }
const UserWidgetLabel = new Lang.Class({
    Name: 'UserWidgetLabel',
    Extends: St.Widget,
    _init: function(user) {
        this.parent({ layout_manager: new Clutter.BinLayout() });
        this._user = user;
        this._realNameLabel = new St.Label({ style_class: 'user-widget-label',
                                             y_align: Clutter.ActorAlign.CENTER });
        this.add_child(this._realNameLabel);
        this._userNameLabel = new St.Label({ style_class: 'user-widget-label',
                                             y_align: Clutter.ActorAlign.CENTER });
        this.add_child(this._userNameLabel);
        this._currentLabel = null;
        this._userLoadedId = this._user.connect('notify::is-loaded', Lang.bind(this, this._updateUser));
        this._userChangedId = this._user.connect('changed', Lang.bind(this, this._updateUser));
        this._updateUser();
        // We can't override the destroy vfunc because that might be called during
        // object finalization, and we can't call any JS inside a GC finalize callback,
        // so we use a signal, that will be disconnected by GObject the first time
        // the actor is destroyed (which is guaranteed to be as part of a normal
        // destroy() call from JS, possibly from some ancestor)
        this.connect('destroy', Lang.bind(this, this._onDestroy));
    },
    _onDestroy: function() {
        if (this._userLoadedId != 0) {
            this._user.disconnect(this._userLoadedId);
            this._userLoadedId = 0;
        }
        if (this._userChangedId != 0) {
            this._user.disconnect(this._userChangedId);
            this._userChangedId = 0;
        }
    },
    vfunc_allocate: function(box, flags) {
        this.set_allocation(box, flags);
        let availWidth = box.x2 - box.x1;
        let availHeight = box.y2 - box.y1;
        let [minRealNameWidth, minRealNameHeight,
             natRealNameWidth, natRealNameHeight] = this._realNameLabel.get_preferred_size();
        let [minUserNameWidth, minUserNameHeight,
             natUserNameWidth, natUserNameHeight] = this._userNameLabel.get_preferred_size();
        if (natRealNameWidth <= availWidth)
            this._currentLabel = this._realNameLabel;
        else
            this._currentLabel = this._userNameLabel;
        this.label_actor = this._currentLabel;
        let childBox = new Clutter.ActorBox();
        childBox.x1 = 0;
        childBox.y1 = 0;
        childBox.x2 = availWidth;
        childBox.y2 = availHeight;
        this._currentLabel.allocate(childBox, flags);
    },
    vfunc_paint: function() {
        this._currentLabel.paint();
    },
    _updateUser: function() {
        if (this._user.is_loaded) {
            this._realNameLabel.text = this._user.get_real_name();
            this._userNameLabel.text = this._user.get_user_name();
        } else {
            this._realNameLabel.text = '';
            this._userNameLabel.text = '';
        }
    },
const UserWidget = new Lang.Class({
    Name: 'UserWidget',
    _init: function(user) {
        this._user = user;
        this.actor = new St.BoxLayout({ style_class: 'user-widget',
                                        vertical: false });
        this.actor.connect('destroy', Lang.bind(this, this._onDestroy));
        this._avatar = new Avatar(user);
        this.actor.add_child(this._avatar.actor);
        this._label = new UserWidgetLabel(user);
        this.actor.add_child(this._label);
        this._label.bind_property('label-actor', this.actor, 'label-actor',
                                  GObject.BindingFlags.SYNC_CREATE);
        this._userLoadedId = this._user.connect('notify::is-loaded', Lang.bind(this, this._updateUser));
        this._userChangedId = this._user.connect('changed', Lang.bind(this, this._updateUser));
        this._updateUser();
    },
    _onDestroy: function() {
        if (this._userLoadedId != 0) {
            this._user.disconnect(this._userLoadedId);
            this._userLoadedId = 0;
        }
        if (this._userChangedId != 0) {
            this._user.disconnect(this._userChangedId);
            this._userChangedId = 0;
        }
    },
    _updateUser: function() {
        this._avatar.update();
    }
(uuay)__init__.js
const Lang = imports.lang;
const Main = imports.ui.main;
const ComponentManager = new Lang.Class({
    Name: 'ComponentManager',
    _init: function() {
        this._allComponents = {};
        this._enabledComponents = [];
        Main.sessionMode.connect('updated', Lang.bind(this, this._sessionUpdated));
        this._sessionUpdated();
    },
    _sessionUpdated: function() {
        let newEnabledComponents = Main.sessionMode.components;
        newEnabledComponents.filter(Lang.bind(this, function(name) {
            return this._enabledComponents.indexOf(name) == -1;
        })).forEach(Lang.bind(this, function(name) {
            this._enableComponent(name);
        }));
        this._enabledComponents.filter(Lang.bind(this, function(name) {
            return newEnabledComponents.indexOf(name) == -1;
        })).forEach(Lang.bind(this, function(name) {
            this._disableComponent(name);
        }));
        this._enabledComponents = newEnabledComponents;
    },
    _importComponent: function(name) {
        let module = imports.ui.components[name];
        return module.Component;
    },
    _ensureComponent: function(name) {
        let component = this._allComponents[name];
        if (component)
            return component;
	if (Main.sessionMode.isLocked)
	    return null;
        let constructor = this._importComponent(name);
        component = new constructor();
        this._allComponents[name] = component;
        return component;
    },
    _enableComponent: function(name) {
        let component = this._ensureComponent(name);
	if (component)
            component.enable();
    },
    _disableComponent: function(name) {
        let component = this._allComponents[name];
        if (component == null)
            return;
        component.disable();
    }
(uuay)hwtest.js
const Clutter = imports.gi.Clutter;
const Gio = imports.gi.Gio;
const Gtk = imports.gi.Gtk;
const Meta = imports.gi.Meta;
const Main = imports.ui.main;
const Scripting = imports.ui.scripting;
const Shell = imports.gi.Shell;
let METRICS = {
    timeToDesktop:
    { description: "Time from starting graphical.target to desktop showing",
      units: "us" },
    overviewShowTime:
    { description: "Time to switch to overview view, first time",
      units: "us" },
    applicationsShowTime:
    { description: "Time to switch to applications view, first time",
      units: "us" },
    mainViewRedrawTime:
    { description: "Time to redraw the main view, full screen",
      units: "us" },
    overviewRedrawTime:
    { description: "Time to redraw the overview, full screen, 5 windows",
      units: "us" },
    applicationRedrawTime:
    { description: "Time to redraw frame with a maximized application update",
      units: "us" },
    geditStartTime:
    { description: "Time from gedit launch to window drawn",
      units: "us" },
function waitAndDraw(milliseconds) {
    let cb;
    let timeline = new Clutter.Timeline({ duration: milliseconds });
    timeline.start();
    timeline.connect('new-frame',
        function(timeline, frame) {
            global.stage.queue_redraw();
        });
    timeline.connect('completed',
        function() {
            timeline.stop();
            if (cb)
                cb();
        });
    return function(callback) {
        cb = callback;
    };
function waitSignal(object, signal) {
    let cb;
    let id = object.connect(signal, function() {
        object.disconnect(id);
        if (cb)
            cb();
    });
    return function(callback) {
        cb = callback;
    };
function extractBootTimestamp() {
    let sp = Gio.Subprocess.new(['journalctl', '-b',
                                 'MESSAGE_ID=7d4958e842da4a758f6c1cdc7b36dcc5',
                                 'UNIT=graphical.target',
                                 '-o',
                                 'json'],
                                Gio.SubprocessFlags.STDOUT_PIPE);
    let result = null;
    let datastream = Gio.DataInputStream.new(sp.get_stdout_pipe());
    while (true) {
        let [line, length] = datastream.read_line_utf8(null);
        if (line === null)
            break;
        let fields = JSON.parse(line);
        result = Number(fields['__MONOTONIC_TIMESTAMP']);
    }
    datastream.close(null);
    return result;
function run() {
    Scripting.defineScriptEvent("desktopShown", "Finished initial animation");
    Scripting.defineScriptEvent("overviewShowStart", "Starting to show the overview");
    Scripting.defineScriptEvent("overviewShowDone", "Overview finished showing");
    Scripting.defineScriptEvent("applicationsShowStart", "Starting to switch to applications view");
    Scripting.defineScriptEvent("applicationsShowDone", "Done switching to applications view");
    Scripting.defineScriptEvent("mainViewDrawStart", "Drawing main view");
    Scripting.defineScriptEvent("mainViewDrawDone", "Ending timing main view drawing");
    Scripting.defineScriptEvent("overviewDrawStart", "Drawing overview");
    Scripting.defineScriptEvent("overviewDrawDone", "Ending timing overview drawing");
    Scripting.defineScriptEvent("redrawTestStart", "Drawing application window");
    Scripting.defineScriptEvent("redrawTestDone", "Ending timing application window drawing");
    Scripting.defineScriptEvent("collectTimings", "Accumulate frame timings from redraw tests");
    Scripting.defineScriptEvent("geditLaunch", "gedit application launch");
    Scripting.defineScriptEvent("geditFirstFrame", "first frame of gedit window drawn");
    yield Scripting.waitLeisure();
    Scripting.scriptEvent('desktopShown');
    Gtk.Settings.get_default().gtk_enable_animations = false;
    Scripting.scriptEvent('overviewShowStart');
    Main.overview.show();
    yield Scripting.waitLeisure();
    Scripting.scriptEvent('overviewShowDone');
    yield Scripting.sleep(1000);
    Scripting.scriptEvent('applicationsShowStart');
    Main.overview._dash.showAppsButton.checked = true;
    yield Scripting.waitLeisure();
    Scripting.scriptEvent('applicationsShowDone');
    yield Scripting.sleep(1000);
    Main.overview.hide();
    yield Scripting.waitLeisure();
    ////////////////////////////////////////
    // Tests of redraw speed
    ////////////////////////////////////////
    global.frame_timestamps = true;
    global.frame_finish_timestamp = true;
    for (let k = 0; k < 5; k++)
        yield Scripting.createTestWindow(640, 480,
                                         { maximized: true });
    yield Scripting.waitTestWindows();
    yield Scripting.sleep(1000);
    Scripting.scriptEvent('mainViewDrawStart');
    yield waitAndDraw(1000);
    Scripting.scriptEvent('mainViewDrawDone');
    Main.overview.show();
    Scripting.waitLeisure();
    yield Scripting.sleep(1500);
    Scripting.scriptEvent('overviewDrawStart');
    yield waitAndDraw(1000);
    Scripting.scriptEvent('overviewDrawDone');
    yield Scripting.destroyTestWindows();
    Main.overview.hide();
    yield Scripting.createTestWindow(640, 480,
                                     { maximized: true,
                                       redraws: true});
    yield Scripting.waitTestWindows();
    yield Scripting.sleep(1000);
    Scripting.scriptEvent('redrawTestStart');
    yield Scripting.sleep(1000);
    Scripting.scriptEvent('redrawTestDone');
    yield Scripting.sleep(1000);
    Scripting.scriptEvent('collectTimings');
    yield Scripting.destroyTestWindows();
    global.frame_timestamps = false;
    global.frame_finish_timestamp = false;
    yield Scripting.sleep(1000);
    ////////////////////////////////////////
    let appSys = Shell.AppSystem.get_default();
    let app = appSys.lookup_app('org.gnome.gedit.desktop');
    Scripting.scriptEvent('geditLaunch');
    app.activate();
    let windows = app.get_windows();
    if (windows.length > 0)
        throw new Error('gedit was already running');
    while (windows.length == 0) {
        yield waitSignal(global.display, 'window-created');
        windows = app.get_windows();
    }
    let actor = windows[0].get_compositor_private();
    yield waitSignal(actor, 'first-frame');
    Scripting.scriptEvent('geditFirstFrame');
    yield Scripting.sleep(1000);
    windows[0].delete(global.get_current_time());
    yield Scripting.sleep(1000);
    Gtk.Settings.get_default().gtk_enable_animations = true;
let overviewShowStart;
let applicationsShowStart;
let stagePaintStart;
let redrawTiming;
let redrawTimes = {};
let geditLaunchTime;
function script_desktopShown(time) {
    let bootTimestamp = extractBootTimestamp();
    METRICS.timeToDesktop.value = time - bootTimestamp;
function script_overviewShowStart(time) {
    overviewShowStart = time;
function script_overviewShowDone(time) {
    METRICS.overviewShowTime.value = time - overviewShowStart;
function script_applicationsShowStart(time) {
    applicationsShowStart = time;
function script_applicationsShowDone(time) {
    METRICS.applicationsShowTime.value = time - applicationsShowStart;
function script_mainViewDrawStart(time) {
    redrawTiming = 'mainView';
function script_mainViewDrawDone(time) {
    redrawTiming = null;
function script_overviewDrawStart(time) {
    redrawTiming = 'overview';
function script_overviewDrawDone(time) {
    redrawTiming = null;
function script_redrawTestStart(time) {
    redrawTiming = 'application';
function script_redrawTestDone(time) {
    redrawTiming = null;
function script_collectTimings(time) {
    for (let timing in redrawTimes) {
        let times = redrawTimes[timing];
        times.sort(function(a, b) { return a - b });
        let len = times.length;
        let median;
        if (len == 0)
            median = -1;
        else if (len % 2 == 1)
            median = times[(len - 1)/ 2];
        else
            median = Math.round((times[len / 2 - 1] + times[len / 2]) / 2);
        METRICS[timing + 'RedrawTime'].value = median;
    }
function script_geditLaunch(time) {
    geditLaunchTime = time;
function script_geditFirstFrame(time) {
    METRICS.geditStartTime.value = time - geditLaunchTime;
function clutter_stagePaintStart(time) {
    stagePaintStart = time;
function clutter_paintCompletedTimestamp(time) {
    if (redrawTiming != null && stagePaintStart != null) {
        if (!(redrawTiming in redrawTimes))
            redrawTimes[redrawTiming] = [];
        redrawTimes[redrawTiming].push(time - stagePaintStart);
    }
    stagePaintStart = null;
(uuay)osdWindow.js
// -*- mode: js; js-indent-level: 4; indent-tabs-mode: nil -*-
const Clutter = imports.gi.Clutter;
const GLib = imports.gi.GLib;
const St = imports.gi.St;
const Lang = imports.lang;
const Layout = imports.ui.layout;
const Main = imports.ui.main;
const Mainloop = imports.mainloop;
const Tweener = imports.ui.tweener;
const Meta = imports.gi.Meta;
const HIDE_TIMEOUT = 1500;
const FADE_TIME = 0.1;
const LEVEL_ANIMATION_TIME = 0.1;
const LevelBar = new Lang.Class({
    Name: 'LevelBar',
    _init: function() {
        this._level = 0;
        this.actor = new St.Bin({ style_class: 'level',
                                  x_align: St.Align.START,
                                  y_fill: true });
        this._bar = new St.Widget({ style_class: 'level-bar' });
        this.actor.set_child(this._bar);
        this.actor.connect('notify::width', () => { this.level = this.level; });
    },
    get level() {
        return this._level;
    },
    set level(value) {
        this._level = Math.max(0, Math.min(value, 100));
        let alloc = this.actor.get_allocation_box();
        let newWidth = Math.round((alloc.x2 - alloc.x1) * this._level / 100);
        if (newWidth != this._bar.width)
            this._bar.width = newWidth;
    }
const OsdWindowConstraint = new Lang.Class({
    Name: 'OsdWindowConstraint',
    Extends: Clutter.Constraint,
    _init: function(props) {
        this._minSize = 0;
        this.parent(props);
    },
    set minSize(v) {
        this._minSize = v;
        if (this.actor)
            this.actor.queue_relayout();
    },
    vfunc_update_allocation: function(actor, actorBox) {
        // Clutter will adjust the allocation for margins,
        // so add it to our minimum size
        let minSize = this._minSize + actor.margin_top + actor.margin_bottom;
        let [width, height] = actorBox.get_size();
        // Enforce a ratio of 1
        let size = Math.ceil(Math.max(minSize, height));
        actorBox.set_size(size, size);
        // Recenter
        let [x, y] = actorBox.get_origin();
        actorBox.set_origin(Math.floor(x + width / 2 - size / 2),
                            Math.floor(y + height / 2 - size / 2));
    }
const OsdWindow = new Lang.Class({
    Name: 'OsdWindow',
    _init: function(monitorIndex) {
        this.actor = new St.Widget({ x_expand: true,
                                     y_expand: true,
                                     x_align: Clutter.ActorAlign.CENTER,
                                     y_align: Clutter.ActorAlign.CENTER });
        this._monitorIndex = monitorIndex;
        let constraint = new Layout.MonitorConstraint({ index: monitorIndex });
        this.actor.add_constraint(constraint);
        this._boxConstraint = new OsdWindowConstraint();
        this._box = new St.BoxLayout({ style_class: 'osd-window',
                                       vertical: true });
        this._box.add_constraint(this._boxConstraint);
        this.actor.add_actor(this._box);
        this._icon = new St.Icon();
        this._box.add(this._icon, { expand: true });
        this._label = new St.Label();
        this._box.add(this._label);
        this._level = new LevelBar();
        this._box.add(this._level.actor);
        this._hideTimeoutId = 0;
        this._reset();
        Main.layoutManager.connect('monitors-changed',
                                   Lang.bind(this, this._monitorsChanged));
        this._monitorsChanged();
        Main.uiGroup.add_child(this.actor);
    },
    setIcon: function(icon) {
        this._icon.gicon = icon;
    },
    setLabel: function(label) {
        this._label.visible = (label != undefined);
        if (label)
            this._label.text = label;
    },
    setLevel: function(level) {
        this._level.actor.visible = (level != undefined);
        if (level != undefined) {
            if (this.actor.visible)
                Tweener.addTween(this._level,
                                 { level: level,
                                   time: LEVEL_ANIMATION_TIME,
                                   transition: 'easeOutQuad' });
            else
                this._level.level = level;
        }
    },
    show: function() {
        if (!this._icon.gicon)
            return;
        if (!this.actor.visible) {
            Meta.disable_unredirect_for_screen(global.screen);
            this.actor.show();
            this.actor.opacity = 0;
            this.actor.get_parent().set_child_above_sibling(this.actor, null);
            Tweener.addTween(this.actor,
                             { opacity: 255,
                               time: FADE_TIME,
                               transition: 'easeOutQuad' });
        }
        if (this._hideTimeoutId)
            Mainloop.source_remove(this._hideTimeoutId);
        this._hideTimeoutId = Mainloop.timeout_add(HIDE_TIMEOUT,
                                                   Lang.bind(this, this._hide));
        GLib.Source.set_name_by_id(this._hideTimeoutId, '[gnome-shell] this._hide');
    },
    cancel: function() {
        if (!this._hideTimeoutId)
            return;
        Mainloop.source_remove(this._hideTimeoutId);
        this._hide();
    },
    _hide: function() {
        this._hideTimeoutId = 0;
        Tweener.addTween(this.actor,
                         { opacity: 0,
                           time: FADE_TIME,
                           transition: 'easeOutQuad',
                           onComplete: Lang.bind(this, function() {
                              this._reset();
                              Meta.enable_unredirect_for_screen(global.screen);
                           })
                         });
        return GLib.SOURCE_REMOVE;
    },
    _reset: function() {
        this.actor.hide();
        this.setLabel(null);
        this.setLevel(null);
    },
    _monitorsChanged: function() {
        /* assume 110x110 on a 640x480 display and scale from there */
        let monitor = Main.layoutManager.monitors[this._monitorIndex];
        if (!monitor)
            return; // we are about to be removed
        let scalew = monitor.width / 640.0;
        let scaleh = monitor.height / 480.0;
        let scale = Math.min(scalew, scaleh);
        let popupSize = 110 * Math.max(1, scale);
        let scaleFactor = St.ThemeContext.get_for_stage(global.stage).scale_factor;
        this._icon.icon_size = popupSize / (2 * scaleFactor);
        this._box.translation_y = monitor.height / 4;
        this._boxConstraint.minSize = popupSize;
    }
const OsdWindowManager = new Lang.Class({
    Name: 'OsdWindowManager',
    _init: function() {
        this._osdWindows = [];
        Main.layoutManager.connect('monitors-changed',
                                    Lang.bind(this, this._monitorsChanged));
        this._monitorsChanged();
    },
    _monitorsChanged: function() {
        for (let i = 0; i < Main.layoutManager.monitors.length; i++) {
            if (this._osdWindows[i] == undefined)
                this._osdWindows[i] = new OsdWindow(i);
        }
        for (let i = Main.layoutManager.monitors.length; i < this._osdWindows.length; i++) {
            this._osdWindows[i].actor.destroy();
            this._osdWindows[i] = null;
        }
        this._osdWindows.length = Main.layoutManager.monitors.length;
    },
    _showOsdWindow: function(monitorIndex, icon, label, level) {
        this._osdWindows[monitorIndex].setIcon(icon);
        this._osdWindows[monitorIndex].setLabel(label);
        this._osdWindows[monitorIndex].setLevel(level);
        this._osdWindows[monitorIndex].show();
    },
    show: function(monitorIndex, icon, label, level) {
        if (monitorIndex != -1) {
            for (let i = 0; i < this._osdWindows.length; i++) {
                if (i == monitorIndex)
                    this._showOsdWindow(i, icon, label, level);
                else
                    this._osdWindows[i].cancel();
            }
        } else {
            for (let i = 0; i < this._osdWindows.length; i++)
                this._showOsdWindow(i, icon, label, level);
        }
    },
    hideAll: function() {
        for (let i = 0; i < this._osdWindows.length; i++)
            this._osdWindows[i].cancel();
    }
(uuay)ctrlAltTab.js
// -*- mode: js; js-indent-level: 4; indent-tabs-mode: nil -*-
const Clutter = imports.gi.Clutter;
const Gtk = imports.gi.Gtk;
const Lang = imports.lang;
const Meta = imports.gi.Meta;
const Shell = imports.gi.Shell;
const St = imports.gi.St;
const Main = imports.ui.main;
const SwitcherPopup = imports.ui.switcherPopup;
const Params = imports.misc.params;
const Tweener = imports.ui.tweener;
const POPUP_APPICON_SIZE = 96;
const POPUP_FADE_TIME = 0.1; // seconds
const SortGroup = {
    TOP:    0,
    MIDDLE: 1,
    BOTTOM: 2
const CtrlAltTabManager = new Lang.Class({
    Name: 'CtrlAltTabManager',
    _init: function() {
        this._items = [];
        this.addGroup(global.window_group, _("Windows"),
                      'focus-windows-symbolic', { sortGroup: SortGroup.TOP,
                                                  focusCallback: Lang.bind(this, this._focusWindows) });
    },
    addGroup: function(root, name, icon, params) {
        let item = Params.parse(params, { sortGroup: SortGroup.MIDDLE,
                                          proxy: root,
                                          focusCallback: null });
        item.root = root;
        item.name = name;
        item.iconName = icon;
        this._items.push(item);
        root.connect('destroy', Lang.bind(this, function() { this.removeGroup(root); }));
        if (root instanceof St.Widget)
            global.focus_manager.add_group(root);
    },
    removeGroup: function(root) {
        if (root instanceof St.Widget)
            global.focus_manager.remove_group(root);
        for (let i = 0; i < this._items.length; i++) {
            if (this._items[i].root == root) {
                this._items.splice(i, 1);
                return;
            }
        }
    },
    focusGroup: function(item, timestamp) {
        if (item.focusCallback)
            item.focusCallback(timestamp);
        else
            item.root.navigate_focus(null, Gtk.DirectionType.TAB_FORWARD, false);
    },
    // Sort the items into a consistent order; panel first, tray last,
    // and everything else in between, sorted by X coordinate, so that
    // they will have the same left-to-right ordering in the
    // Ctrl-Alt-Tab dialog as they do onscreen.
    _sortItems: function(a, b) {
        if (a.sortGroup != b.sortGroup)
            return a.sortGroup - b.sortGroup;
        let ax, bx, y;
        [ax, y] = a.proxy.get_transformed_position();
        [bx, y] = b.proxy.get_transformed_position();
        return ax - bx;
    },
    popup: function(backward, binding, mask) {
        // Start with the set of focus groups that are currently mapped
        let items = this._items.filter(function (item) { return item.proxy.mapped; });
        // And add the windows metacity would show in its Ctrl-Alt-Tab list
        if (Main.sessionMode.hasWindows && !Main.overview.visible) {
            let screen = global.screen;
            let display = screen.get_display();
            let windows = display.get_tab_list(Meta.TabList.DOCKS, screen.get_active_workspace ());
            let windowTracker = Shell.WindowTracker.get_default();
            let textureCache = St.TextureCache.get_default();
            for (let i = 0; i < windows.length; i++) {
                let icon = null;
                let iconName = null;
                if (windows[i].get_window_type () == Meta.WindowType.DESKTOP) {
                    iconName = 'video-display-symbolic';
                } else {
                    let app = windowTracker.get_window_app(windows[i]);
                    if (app)
                        icon = app.create_icon_texture(POPUP_APPICON_SIZE);
                    else
                        icon = textureCache.bind_cairo_surface_property(windows[i], 'icon');
                }
                items.push({ name: windows[i].title,
                             proxy: windows[i].get_compositor_private(),
                             focusCallback: Lang.bind(windows[i],
                                 function(timestamp) {
                                     Main.activateWindow(this, timestamp);
                                 }),
                             iconActor: icon,
                             iconName: iconName,
                             sortGroup: SortGroup.MIDDLE });
            }
        }
        if (!items.length)
            return;
        items.sort(Lang.bind(this, this._sortItems));
        if (!this._popup) {
            this._popup = new CtrlAltTabPopup(items);
            this._popup.show(backward, binding, mask);
            this._popup.actor.connect('destroy',
                                      Lang.bind(this, function() {
                                          this._popup = null;
                                      }));
        }
    },
    _focusWindows: function(timestamp) {
        global.screen.focus_default_window(timestamp);
    }
const CtrlAltTabPopup = new Lang.Class({
    Name: 'CtrlAltTabPopup',
    Extends: SwitcherPopup.SwitcherPopup,
    _init: function(items) {
        this.parent(items);
        this._switcherList = new CtrlAltTabSwitcher(this._items);
    },
    _keyPressHandler: function(keysym, action) {
        if (action == Meta.KeyBindingAction.SWITCH_PANELS)
            this._select(this._next());
        else if (action == Meta.KeyBindingAction.SWITCH_PANELS_BACKWARD)
            this._select(this._previous());
        else if (keysym == Clutter.Left)
            this._select(this._previous());
        else if (keysym == Clutter.Right)
            this._select(this._next());
        else
            return Clutter.EVENT_PROPAGATE;
        return Clutter.EVENT_STOP;
    },
    _finish : function(time) {
        this.parent(time);
        Main.ctrlAltTabManager.focusGroup(this._items[this._selectedIndex], time);
    },
const CtrlAltTabSwitcher = new Lang.Class({
    Name: 'CtrlAltTabSwitcher',
    Extends: SwitcherPopup.SwitcherList,
    _init : function(items) {
        this.parent(true);
        for (let i = 0; i < items.length; i++)
            this._addIcon(items[i]);
    },
    _addIcon : function(item) {
        let box = new St.BoxLayout({ style_class: 'alt-tab-app',
                                     vertical: true });
        let icon = item.iconActor;
        if (!icon) {
            icon = new St.Icon({ icon_name: item.iconName,
                                 icon_size: POPUP_APPICON_SIZE });
        }
        box.add(icon, { x_fill: false, y_fill: false } );
        let text = new St.Label({ text: item.name });
        box.add(text, { x_fill: false });
        this.addItem(box, text);
    }
(uuay)workspacesView.js
// -*- mode: js; js-indent-level: 4; indent-tabs-mode: nil -*-
const Clutter = imports.gi.Clutter;
const Gio = imports.gi.Gio;
const GObject = imports.gi.GObject;
const Lang = imports.lang;
const Mainloop = imports.mainloop;
const Meta = imports.gi.Meta;
const Shell = imports.gi.Shell;
const St = imports.gi.St;
const Signals = imports.signals;
const DND = imports.ui.dnd;
const Main = imports.ui.main;
const Overview = imports.ui.overview;
const Tweener = imports.ui.tweener;
const Workspace = imports.ui.workspace;
const WorkspaceThumbnail = imports.ui.workspaceThumbnail;
const WORKSPACE_SWITCH_TIME = 0.25;
const AnimationType = {
    ZOOM: 0,
    FADE: 1
const OVERRIDE_SCHEMA = 'org.gnome.shell.overrides';
const WorkspacesViewBase = new Lang.Class({
    Name: 'WorkspacesViewBase',
    _init: function(monitorIndex) {
        this.actor = new St.Widget({ style_class: 'workspaces-view',
                                     reactive: true });
        this.actor.connect('destroy', Lang.bind(this, this._onDestroy));
        global.focus_manager.add_group(this.actor);
        // The actor itself isn't a drop target, so we don't want to pick on its area
        this.actor.set_size(0, 0);
        this._monitorIndex = monitorIndex;
        this._fullGeometry = null;
        this._actualGeometry = null;
        this._inDrag = false;
        this._windowDragBeginId = Main.overview.connect('window-drag-begin', Lang.bind(this, this._dragBegin));
        this._windowDragEndId = Main.overview.connect('window-drag-end', Lang.bind(this, this._dragEnd));
    },
    _onDestroy: function() {
        this._dragEnd();
        if (this._windowDragBeginId > 0) {
            Main.overview.disconnect(this._windowDragBeginId);
            this._windowDragBeginId = 0;
        }
        if (this._windowDragEndId > 0) {
            Main.overview.disconnect(this._windowDragEndId);
            this._windowDragEndId = 0;
        }
    },
    _dragBegin: function(overview, window) {
        this._inDrag = true;
        this._setReservedSlot(window);
    },
    _dragEnd: function() {
        this._inDrag = false;
        this._setReservedSlot(null);
    },
    destroy: function() {
        this.actor.destroy();
    },
    setFullGeometry: function(geom) {
        this._fullGeometry = geom;
        this._syncFullGeometry();
    },
    setActualGeometry: function(geom) {
        this._actualGeometry = geom;
        this._syncActualGeometry();
    },
const WorkspacesView = new Lang.Class({
    Name: 'WorkspacesView',
    Extends: WorkspacesViewBase,
    _init: function(monitorIndex) {
        this.parent(monitorIndex);
        this._animating = false; // tweening
        this._scrolling = false; // swipe-scrolling
        this._animatingScroll = false; // programatically updating the adjustment
        let activeWorkspaceIndex = global.screen.get_active_workspace_index();
        this.scrollAdjustment = new St.Adjustment({ value: activeWorkspaceIndex,
                                                    lower: 0,
                                                    page_increment: 1,
                                                    page_size: 1,
                                                    step_increment: 0,
                                                    upper: global.screen.n_workspaces });
        this.scrollAdjustment.connect('notify::value',
                                      Lang.bind(this, this._onScroll));
        this._workspaces = [];
        this._updateWorkspaces();
        this._updateWorkspacesId = global.screen.connect('notify::n-workspaces', Lang.bind(this, this._updateWorkspaces));
        this._overviewShownId =
            Main.overview.connect('shown',
                                 Lang.bind(this, function() {
                this.actor.set_clip(this._fullGeometry.x, this._fullGeometry.y,
                                    this._fullGeometry.width, this._fullGeometry.height);
        }));
        this._switchWorkspaceNotifyId =
            global.window_manager.connect('switch-workspace',
                                          Lang.bind(this, this._activeWorkspaceChanged));
    },
    _setReservedSlot: function(window) {
        for (let i = 0; i < this._workspaces.length; i++)
            this._workspaces[i].setReservedSlot(window);
    },
    _syncFullGeometry: function() {
        for (let i = 0; i < this._workspaces.length; i++)
            this._workspaces[i].setFullGeometry(this._fullGeometry);
    },
    _syncActualGeometry: function() {
        for (let i = 0; i < this._workspaces.length; i++)
            this._workspaces[i].setActualGeometry(this._actualGeometry);
    },
    getActiveWorkspace: function() {
        let active = global.screen.get_active_workspace_index();
        return this._workspaces[active];
    },
    animateToOverview: function(animationType) {
        for (let w = 0; w < this._workspaces.length; w++) {
            if (animationType == AnimationType.ZOOM)
                this._workspaces[w].zoomToOverview();
            else
                this._workspaces[w].fadeToOverview();
        }
        this._updateWorkspaceActors(false);
    },
    animateFromOverview: function(animationType) {
        this.actor.remove_clip();
        for (let w = 0; w < this._workspaces.length; w++) {
            if (animationType == AnimationType.ZOOM)
                this._workspaces[w].zoomFromOverview();
            else
                this._workspaces[w].fadeFromOverview();
        }
    },
    syncStacking: function(stackIndices) {
        for (let i = 0; i < this._workspaces.length; i++)
            this._workspaces[i].syncStacking(stackIndices);
    },
    _scrollToActive: function() {
        let active = global.screen.get_active_workspace_index();
        this._updateWorkspaceActors(true);
        this._updateScrollAdjustment(active);
    },
    // Update workspace actors parameters
    // @showAnimation: iff %true, transition between states
    _updateWorkspaceActors: function(showAnimation) {
        let active = global.screen.get_active_workspace_index();
        this._animating = showAnimation;
        for (let w = 0; w < this._workspaces.length; w++) {
            let workspace = this._workspaces[w];
            Tweener.removeTweens(workspace.actor);
            let y = (w - active) * this._fullGeometry.height;
            if (showAnimation) {
                let params = { y: y,
                               time: WORKSPACE_SWITCH_TIME,
                               transition: 'easeOutQuad'
                             };
                // we have to call _updateVisibility() once before the
                // animation and once afterwards - it does not really
                // matter which tween we use, so we pick the first one ...
                if (w == 0) {
                    this._updateVisibility();
                    params.onComplete = Lang.bind(this,
                        function() {
                            this._animating = false;
                            this._updateVisibility();
                        });
                }
                Tweener.addTween(workspace.actor, params);
            } else {
                workspace.actor.set_position(0, y);
                if (w == 0)
                    this._updateVisibility();
            }
        }
    },
    _updateVisibility: function() {
        let active = global.screen.get_active_workspace_index();
        for (let w = 0; w < this._workspaces.length; w++) {
            let workspace = this._workspaces[w];
            if (this._animating || this._scrolling) {
                workspace.actor.show();
            } else {
                if (this._inDrag)
                    workspace.actor.visible = (Math.abs(w - active) <= 1);
                else
                    workspace.actor.visible = (w == active);
            }
        }
    },
    _updateScrollAdjustment: function(index) {
        if (this._scrolling)
            return;
        this._animatingScroll = true;
        Tweener.addTween(this.scrollAdjustment, {
            value: index,
            time: WORKSPACE_SWITCH_TIME,
            transition: 'easeOutQuad',
            onComplete: Lang.bind(this,
                                  function() {
                                      this._animatingScroll = false;
                                  })
        });
    },
    _updateWorkspaces: function() {
        let newNumWorkspaces = global.screen.n_workspaces;
        this.scrollAdjustment.upper = newNumWorkspaces;
        let needsUpdate = false;
        for (let j = 0; j < newNumWorkspaces; j++) {
            let metaWorkspace = global.screen.get_workspace_by_index(j);
            let workspace;
            if (j >= this._workspaces.length) { /* added */
                workspace = new Workspace.Workspace(metaWorkspace, this._monitorIndex);
                this.actor.add_actor(workspace.actor);
                this._workspaces[j] = workspace;
            } else  {
                workspace = this._workspaces[j];
                if (workspace.metaWorkspace != metaWorkspace) { /* removed */
                    workspace.destroy();
                    this._workspaces.splice(j, 1);
                } /* else kept */
            }
        }
        if (this._fullGeometry) {
            this._updateWorkspaceActors(false);
            this._syncFullGeometry();
        }
        if (this._actualGeometry)
            this._syncActualGeometry();
    },
    _activeWorkspaceChanged: function(wm, from, to, direction) {
        if (this._scrolling)
            return;
        this._scrollToActive();
    },
    _onDestroy: function() {
        this.parent();
        this.scrollAdjustment.run_dispose();
        Main.overview.disconnect(this._overviewShownId);
        global.window_manager.disconnect(this._switchWorkspaceNotifyId);
        global.screen.disconnect(this._updateWorkspacesId);
    },
    startSwipeScroll: function() {
        this._scrolling = true;
    },
    endSwipeScroll: function() {
        this._scrolling = false;
        // Make sure title captions etc are shown as necessary
        this._scrollToActive();
        this._updateVisibility();
    },
    // sync the workspaces' positions to the value of the scroll adjustment
    // and change the active workspace if appropriate
    _onScroll: function(adj) {
        if (this._animatingScroll)
            return;
        let active = global.screen.get_active_workspace_index();
        let current = Math.round(adj.value);
        if (active != current) {
            if (!this._workspaces[current]) {
                // The current workspace was destroyed. This could happen
                // when you are on the last empty workspace, and consolidate
                // windows using the thumbnail bar.
                // In that case, the intended behavior is to stay on the empty
                // workspace, which is the last one, so pick it.
                current = this._workspaces.length - 1;
            }
            let metaWorkspace = this._workspaces[current].metaWorkspace;
            metaWorkspace.activate(global.get_current_time());
        }
        let last = this._workspaces.length - 1;
        let firstWorkspaceY = this._workspaces[0].actor.y;
        let lastWorkspaceY = this._workspaces[last].actor.y;
        let workspacesHeight = lastWorkspaceY - firstWorkspaceY;
        if (adj.upper == 1)
            return;
        let currentY = firstWorkspaceY;
        let newY =  - adj.value / (adj.upper - 1) * workspacesHeight;
        let dy = newY - currentY;
        for (let i = 0; i < this._workspaces.length; i++) {
            this._workspaces[i].actor.visible = Math.abs(i - adj.value) <= 1;
            this._workspaces[i].actor.y += dy;
        }
    },
Signals.addSignalMethods(WorkspacesView.prototype);
const ExtraWorkspaceView = new Lang.Class({
    Name: 'ExtraWorkspaceView',
    Extends: WorkspacesViewBase,
    _init: function(monitorIndex) {
        this.parent(monitorIndex);
        this._workspace = new Workspace.Workspace(null, monitorIndex);
        this.actor.add_actor(this._workspace.actor);
    },
    _setReservedSlot: function(window) {
        this._workspace.setReservedSlot(window);
    },
    _syncFullGeometry: function() {
        this._workspace.setFullGeometry(this._fullGeometry);
    },
    _syncActualGeometry: function() {
        this._workspace.setActualGeometry(this._actualGeometry);
    },
    getActiveWorkspace: function() {
        return this._workspace;
    },
    animateToOverview: function(animationType) {
        if (animationType == AnimationType.ZOOM)
            this._workspace.zoomToOverview();
        else
            this._workspace.fadeToOverview();
    },
    animateFromOverview: function(animationType) {
        if (animationType == AnimationType.ZOOM)
            this._workspace.zoomFromOverview();
        else
            this._workspace.fadeFromOverview();
    },
    syncStacking: function(stackIndices) {
        this._workspace.syncStacking(stackIndices);
    },
    startSwipeScroll: function() {
    },
    endSwipeScroll: function() {
    },
const DelegateFocusNavigator = new Lang.Class({
    Name: 'DelegateFocusNavigator',
    Extends: St.Widget,
    vfunc_navigate_focus: function(from, direction) {
        return this._delegate.navigateFocus(from, direction);
    },
const WorkspacesDisplay = new Lang.Class({
    Name: 'WorkspacesDisplay',
    _init: function() {
        this.actor = new DelegateFocusNavigator({ clip_to_allocation: true });
        this.actor._delegate = this;
        this.actor.connect('notify::allocation', Lang.bind(this, this._updateWorkspacesActualGeometry));
        this.actor.connect('parent-set', Lang.bind(this, this._parentSet));
        let clickAction = new Clutter.ClickAction();
        clickAction.connect('clicked', Lang.bind(this, function(action) {
            // Only switch to the workspace when there's no application
            // windows open. The problem is that it's too easy to miss
            // an app window and get the wrong one focused.
            let event = Clutter.get_current_event();
            let index = this._getMonitorIndexForEvent(event);
            if ((action.get_button() == 1 || action.get_button() == 0) &&
                this._workspacesViews[index].getActiveWorkspace().isEmpty())
                Main.overview.hide();
        }));
        Main.overview.addAction(clickAction);
        this.actor.bind_property('mapped', clickAction, 'enabled', GObject.BindingFlags.SYNC_CREATE);
        let panAction = new Clutter.PanAction({ threshold_trigger_edge: Clutter.GestureTriggerEdge.AFTER });
        panAction.connect('pan', Lang.bind(this, this._onPan));
        panAction.connect('gesture-begin', Lang.bind(this, function() {
            if (this._workspacesOnlyOnPrimary) {
                let event = Clutter.get_current_event();
                if (this._getMonitorIndexForEvent(event) != this._primaryIndex)
                    return false;
            }
            for (let i = 0; i < this._workspacesViews.length; i++)
                this._workspacesViews[i].startSwipeScroll();
            return true;
        }));
        panAction.connect('gesture-cancel', Lang.bind(this, function() {
            clickAction.release();
            for (let i = 0; i < this._workspacesViews.length; i++)
                this._workspacesViews[i].endSwipeScroll();
        }));
        panAction.connect('gesture-end', Lang.bind(this, function() {
            clickAction.release();
            for (let i = 0; i < this._workspacesViews.length; i++)
                this._workspacesViews[i].endSwipeScroll();
        }));
        Main.overview.addAction(panAction);
        this.actor.bind_property('mapped', panAction, 'enabled', GObject.BindingFlags.SYNC_CREATE);
        this._primaryIndex = Main.layoutManager.primaryIndex;
        this._workspacesViews = [];
        this._primaryScrollAdjustment = null;
        this._settings = new Gio.Settings({ schema_id: OVERRIDE_SCHEMA });
        this._settings.connect('changed::workspaces-only-on-primary',
                               Lang.bind(this,
                                         this._workspacesOnlyOnPrimaryChanged));
        this._workspacesOnlyOnPrimaryChanged();
        this._switchWorkspaceNotifyId = 0;
        this._notifyOpacityId = 0;
        this._scrollEventId = 0;
        this._keyPressEventId = 0;
        this._fullGeometry = null;
    },
    _onPan: function(action) {
        let [dist, dx, dy] = action.get_motion_delta(0);
        let adjustment = this._scrollAdjustment;
        adjustment.value -= (dy / this.actor.height) * adjustment.page_size;
        return false;
    },
    navigateFocus: function(from, direction) {
        return this._getPrimaryView().actor.navigate_focus(from, direction, false);
    },
    show: function(fadeOnPrimary) {
        this._updateWorkspacesViews();
        for (let i = 0; i < this._workspacesViews.length; i++) {
            let animationType;
            if (fadeOnPrimary && i == this._primaryIndex)
                animationType = AnimationType.FADE;
            else
                animationType = AnimationType.ZOOM;
            this._workspacesViews[i].animateToOverview(animationType);
        }
        this._restackedNotifyId =
            Main.overview.connect('windows-restacked',
                                  Lang.bind(this, this._onRestacked));
        if (this._scrollEventId == 0)
            this._scrollEventId = Main.overview.connect('scroll-event', Lang.bind(this, this._onScrollEvent));
        if (this._keyPressEventId == 0)
            this._keyPressEventId = global.stage.connect('key-press-event', Lang.bind(this, this._onKeyPressEvent));
    },
    animateFromOverview: function(fadeOnPrimary) {
        for (let i = 0; i < this._workspacesViews.length; i++) {
            let animationType;
            if (fadeOnPrimary && i == this._primaryIndex)
                animationType = AnimationType.FADE;
            else
                animationType = AnimationType.ZOOM;
            this._workspacesViews[i].animateFromOverview(animationType);
        }
    },
    hide: function() {
        if (this._restackedNotifyId > 0){
            Main.overview.disconnect(this._restackedNotifyId);
            this._restackedNotifyId = 0;
        }
        if (this._scrollEventId > 0) {
            Main.overview.disconnect(this._scrollEventId);
            this._scrollEventId = 0;
        }
        if (this._keyPressEventId > 0) {
            global.stage.disconnect(this._keyPressEventId);
            this._keyPressEventId = 0;
        }
        for (let i = 0; i < this._workspacesViews.length; i++)
            this._workspacesViews[i].destroy();
        this._workspacesViews = [];
    },
    _workspacesOnlyOnPrimaryChanged: function() {
        this._workspacesOnlyOnPrimary = this._settings.get_boolean('workspaces-only-on-primary');
        if (!Main.overview.visible)
            return;
        this._updateWorkspacesViews();
    },
    _updateWorkspacesViews: function() {
        for (let i = 0; i < this._workspacesViews.length; i++)
            this._workspacesViews[i].destroy();
        this._primaryIndex = Main.layoutManager.primaryIndex;
        this._workspacesViews = [];
        let monitors = Main.layoutManager.monitors;
        for (let i = 0; i < monitors.length; i++) {
            let view;
            if (this._workspacesOnlyOnPrimary && i != this._primaryIndex)
                view = new ExtraWorkspaceView(i);
            else
                view = new WorkspacesView(i);
            view.actor.connect('scroll-event', Lang.bind(this, this._onScrollEvent));
            if (i == this._primaryIndex) {
                this._scrollAdjustment = view.scrollAdjustment;
                this._scrollAdjustment.connect('notify::value',
                                               Lang.bind(this, this._scrollValueChanged));
            }
            this._workspacesViews.push(view);
            Main.layoutManager.overviewGroup.add_actor(view.actor);
        }
        this._updateWorkspacesFullGeometry();
        this._updateWorkspacesActualGeometry();
    },
    _scrollValueChanged: function() {
        for (let i = 0; i < this._workspacesViews.length; i++) {
            if (i == this._primaryIndex)
                continue;
            let adjustment = this._workspacesViews[i].scrollAdjustment;
            if (!adjustment)
                continue;
            // the adjustments work in terms of workspaces, so the
            // values map directly
            adjustment.value = this._scrollAdjustment.value;
        }
    },
    _getMonitorIndexForEvent: function(event) {
        let [x, y] = event.get_coords();
        let rect = new Meta.Rectangle({ x: x, y: y, width: 1, height: 1 });
        return global.screen.get_monitor_index_for_rect(rect);
    },
    _getPrimaryView: function() {
        if (!this._workspacesViews.length)
            return null;
        return this._workspacesViews[this._primaryIndex];
    },
    activeWorkspaceHasMaximizedWindows: function() {
        return this._getPrimaryView().getActiveWorkspace().hasMaximizedWindows();
    },
    _parentSet: function(actor, oldParent) {
        if (oldParent && this._notifyOpacityId)
            oldParent.disconnect(this._notifyOpacityId);
        this._notifyOpacityId = 0;
        Meta.later_add(Meta.LaterType.BEFORE_REDRAW, Lang.bind(this,
            function() {
                let newParent = this.actor.get_parent();
                if (!newParent)
                    return;
                // This is kinda hackish - we want the primary view to
                // appear as parent of this.actor, though in reality it
                // is added directly to Main.layoutManager.overviewGroup
                this._notifyOpacityId = newParent.connect('notify::opacity',
                    Lang.bind(this, function() {
                        let opacity = this.actor.get_parent().opacity;
                        let primaryView = this._getPrimaryView();
                        if (!primaryView)
                            return;
                        primaryView.actor.opacity = opacity;
                        primaryView.actor.visible = opacity != 0;
                    }));
        }));
    },
    // This geometry should always be the fullest geometry
    // the workspaces switcher can ever be allocated, as if
    // the sliding controls were never slid in at all.
    setWorkspacesFullGeometry: function(geom) {
        this._fullGeometry = geom;
        this._updateWorkspacesFullGeometry();
    },
    _updateWorkspacesFullGeometry: function() {
        if (!this._workspacesViews.length)
            return;
        let monitors = Main.layoutManager.monitors;
        for (let i = 0; i < monitors.length; i++) {
            let geometry = (i == this._primaryIndex) ? this._fullGeometry : monitors[i];
            this._workspacesViews[i].setFullGeometry(geometry);
        }
    },
    _updateWorkspacesActualGeometry: function() {
        if (!this._workspacesViews.length)
            return;
        let [x, y] = this.actor.get_transformed_position();
        let allocation = this.actor.allocation;
        let width = allocation.x2 - allocation.x1;
        let height = allocation.y2 - allocation.y1;
        let primaryGeometry = { x: x, y: y, width: width, height: height };
        let monitors = Main.layoutManager.monitors;
        for (let i = 0; i < monitors.length; i++) {
            let geometry = (i == this._primaryIndex) ? primaryGeometry : monitors[i];
            this._workspacesViews[i].setActualGeometry(geometry);
        }
    },
    _onRestacked: function(overview, stackIndices) {
        for (let i = 0; i < this._workspacesViews.length; i++)
            this._workspacesViews[i].syncStacking(stackIndices);
    },
    _onScrollEvent: function(actor, event) {
        if (!this.actor.mapped)
            return Clutter.EVENT_PROPAGATE;
        if (this._workspacesOnlyOnPrimary &&
            this._getMonitorIndexForEvent(event) != this._primaryIndex)
            return Clutter.EVENT_PROPAGATE;
        let activeWs = global.screen.get_active_workspace();
        let ws;
        switch (event.get_scroll_direction()) {
        case Clutter.ScrollDirection.UP:
            ws = activeWs.get_neighbor(Meta.MotionDirection.UP);
            break;
        case Clutter.ScrollDirection.DOWN:
            ws = activeWs.get_neighbor(Meta.MotionDirection.DOWN);
            break;
        default:
            return Clutter.EVENT_PROPAGATE;
        }
        Main.wm.actionMoveWorkspace(ws);
        return Clutter.EVENT_STOP;
    },
    _onKeyPressEvent: function(actor, event) {
        if (!this.actor.mapped)
            return Clutter.EVENT_PROPAGATE;
        let activeWs = global.screen.get_active_workspace();
        let ws;
        switch (event.get_key_symbol()) {
        case Clutter.KEY_Page_Up:
            ws = activeWs.get_neighbor(Meta.MotionDirection.UP);
            break;
        case Clutter.KEY_Page_Down:
            ws = activeWs.get_neighbor(Meta.MotionDirection.DOWN);
            break;
        default:
            return Clutter.EVENT_PROPAGATE;
        }
        Main.wm.actionMoveWorkspace(ws);
        return Clutter.EVENT_STOP;
    }
Signals.addSignalMethods(WorkspacesDisplay.prototype);
(uuay)dnd.js
// -*- mode: js; js-indent-level: 4; indent-tabs-mode: nil -*-
const Clutter = imports.gi.Clutter;
const GLib = imports.gi.GLib;
const Gtk = imports.gi.Gtk;
const St = imports.gi.St;
const Lang = imports.lang;
const Meta = imports.gi.Meta;
const Shell = imports.gi.Shell;
const Signals = imports.signals;
const Tweener = imports.ui.tweener;
const Main = imports.ui.main;
const Params = imports.misc.params;
// Time to scale down to maxDragActorSize
const SCALE_ANIMATION_TIME = 0.25;
// Time to animate to original position on cancel
const SNAP_BACK_ANIMATION_TIME = 0.25;
// Time to animate to original position on success
const REVERT_ANIMATION_TIME = 0.75;
const DragMotionResult = {
    NO_DROP:   0,
    COPY_DROP: 1,
    MOVE_DROP: 2,
    CONTINUE:  3
const DRAG_CURSOR_MAP = {
    0: Meta.Cursor.DND_UNSUPPORTED_TARGET,
    1: Meta.Cursor.DND_COPY,
    2: Meta.Cursor.DND_MOVE
const DragDropResult = {
    FAILURE:  0,
    SUCCESS:  1,
    CONTINUE: 2
let eventHandlerActor = null;
let currentDraggable = null;
let dragMonitors = [];
function _getEventHandlerActor() {
    if (!eventHandlerActor) {
        eventHandlerActor = new Clutter.Actor({ width: 0, height: 0 });
        Main.uiGroup.add_actor(eventHandlerActor);
        // We connect to 'event' rather than 'captured-event' because the capturing phase doesn't happen
        // when you've grabbed the pointer.
        eventHandlerActor.connect('event',
                                  function(actor, event) {
                                      return currentDraggable._onEvent(actor, event);
                                  });
    }
    return eventHandlerActor;
function addDragMonitor(monitor) {
    dragMonitors.push(monitor);
function removeDragMonitor(monitor) {
    for (let i = 0; i < dragMonitors.length; i++)
        if (dragMonitors[i] == monitor) {
            dragMonitors.splice(i, 1);
            return;
        }
const _Draggable = new Lang.Class({
    Name: 'Draggable',
    _init : function(actor, params) {
        params = Params.parse(params, { manualMode: false,
                                        restoreOnSuccess: false,
                                        dragActorMaxSize: undefined,
                                        dragActorOpacity: undefined });
        this.actor = actor;
        if (!params.manualMode) {
            this.actor.connect('button-press-event',
                               Lang.bind(this, this._onButtonPress));
            this.actor.connect('touch-event',
                               Lang.bind(this, this._onTouchEvent));
        }
        this.actor.connect('destroy', Lang.bind(this, function() {
            this._actorDestroyed = true;
            if (this._dragInProgress && this._dragCancellable)
                this._cancelDrag(global.get_current_time());
            this.disconnectAll();
        }));
        this._onEventId = null;
        this._restoreOnSuccess = params.restoreOnSuccess;
        this._dragActorMaxSize = params.dragActorMaxSize;
        this._dragActorOpacity = params.dragActorOpacity;
        this._buttonDown = false; // The mouse button has been pressed and has not yet been released.
        this._dragInProgress = false; // The drag has been started, and has not been dropped or cancelled yet.
        this._animationInProgress = false; // The drag is over and the item is in the process of animating to its original position (snapping back or reverting).
        this._dragCancellable = true;
        this._eventsGrabbed = false;
    },
    _onButtonPress : function (actor, event) {
        if (event.get_button() != 1)
            return Clutter.EVENT_PROPAGATE;
        if (Tweener.getTweenCount(actor))
            return Clutter.EVENT_PROPAGATE;
        this._buttonDown = true;
        this._grabActor();
        let [stageX, stageY] = event.get_coords();
        this._dragStartX = stageX;
        this._dragStartY = stageY;
        return Clutter.EVENT_PROPAGATE;
    },
    _onTouchEvent: function (actor, event) {
        if (event.type() != Clutter.EventType.TOUCH_BEGIN ||
            !global.display.is_pointer_emulating_sequence(event.get_event_sequence()))
            return Clutter.EVENT_PROPAGATE;
        if (Tweener.getTweenCount(actor))
            return Clutter.EVENT_PROPAGATE;
        this._touchSequence = event.get_event_sequence();
        this._buttonDown = true;
        this._grabActor();
        let [stageX, stageY] = event.get_coords();
        this._dragStartX = stageX;
        this._dragStartY = stageY;
        return Clutter.EVENT_PROPAGATE;
    },
    _grabDevice: function(actor) {
        let manager = Clutter.DeviceManager.get_default();
        let pointer = manager.get_core_device(Clutter.InputDeviceType.POINTER_DEVICE);
        if (pointer && this._touchSequence)
            pointer.sequence_grab(this._touchSequence, actor);
        else if (pointer)
            pointer.grab (actor);
        this._grabbedDevice = pointer;
    },
    _ungrabDevice: function() {
        if (this._touchSequence)
            this._grabbedDevice.sequence_ungrab (this._touchSequence);
        else
            this._grabbedDevice.ungrab();
        this._touchSequence = null;
        this._grabbedDevice = null;
    },
    _grabActor: function() {
        this._grabDevice(this.actor);
        this._onEventId = this.actor.connect('event',
                                             Lang.bind(this, this._onEvent));
    },
    _ungrabActor: function() {
        if (!this._onEventId)
            return;
        this._ungrabDevice();
        this.actor.disconnect(this._onEventId);
        this._onEventId = null;
    },
    _grabEvents: function() {
        if (!this._eventsGrabbed) {
            this._eventsGrabbed = Main.pushModal(_getEventHandlerActor());
            if (this._eventsGrabbed)
                this._grabDevice(_getEventHandlerActor());
        }
    },
    _ungrabEvents: function() {
        if (this._eventsGrabbed) {
            this._ungrabDevice();
            Main.popModal(_getEventHandlerActor());
            this._eventsGrabbed = false;
        }
    },
    _onEvent: function(actor, event) {
        // We intercept BUTTON_RELEASE event to know that the button was released in case we
        // didn't start the drag, to drop the draggable in case the drag was in progress, and
        // to complete the drag and ensure that whatever happens to be under the pointer does
        // not get triggered if the drag was cancelled with Esc.
        if (event.type() == Clutter.EventType.BUTTON_RELEASE ||
            (event.type() == Clutter.EventType.TOUCH_END &&
             global.display.is_pointer_emulating_sequence(event.get_event_sequence()))) {
            this._buttonDown = false;
            if (this._dragInProgress) {
                return this._dragActorDropped(event);
            } else if (this._dragActor != null && !this._animationInProgress) {
                // Drag must have been cancelled with Esc.
                this._dragComplete();
                return Clutter.EVENT_STOP;
            } else {
                // Drag has never started.
                this._ungrabActor();
                return Clutter.EVENT_PROPAGATE;
            }
        // We intercept MOTION event to figure out if the drag has started and to draw
        // this._dragActor under the pointer when dragging is in progress
        } else if (event.type() == Clutter.EventType.MOTION ||
                   (event.type() == Clutter.EventType.TOUCH_UPDATE &&
                    global.display.is_pointer_emulating_sequence(event.get_event_sequence()))) {
            if (this._dragInProgress) {
                return this._updateDragPosition(event);
            } else if (this._dragActor == null) {
                return this._maybeStartDrag(event);
            }
        // We intercept KEY_PRESS event so that we can process Esc key press to cancel
        // dragging and ignore all other key presses.
        } else if (event.type() == Clutter.EventType.KEY_PRESS && this._dragInProgress) {
            let symbol = event.get_key_symbol();
            if (symbol == Clutter.Escape) {
                this._cancelDrag(event.get_time());
                return Clutter.EVENT_STOP;
            }
        }
        return Clutter.EVENT_PROPAGATE;
    },
    /**
     * fakeRelease:
     *
     * Fake a release event.
     * Must be called if you want to intercept release events on draggable
     * actors for other purposes (for example if you're using
     * PopupMenu.ignoreRelease())
     */
    fakeRelease: function() {
        this._buttonDown = false;
        this._ungrabActor();
    },
    /**
     * startDrag:
     * @stageX: X coordinate of event
     * @stageY: Y coordinate of event
     * @time: Event timestamp
     *
     * Directly initiate a drag and drop operation from the given actor.
     * This function is useful to call if you've specified manualMode
     * for the draggable.
     */
    startDrag: function (stageX, stageY, time, sequence) {
        currentDraggable = this;
        this._dragInProgress = true;
        // Special-case St.Button: the pointer grab messes with the internal
        // state, so force a reset to a reasonable state here
        if (this.actor instanceof St.Button) {
            this.actor.fake_release();
            this.actor.hover = false;
        }
        this.emit('drag-begin', time);
        if (this._onEventId)
            this._ungrabActor();
        this._touchSequence = sequence;
        this._grabEvents();
        global.screen.set_cursor(Meta.Cursor.DND_IN_DRAG);
        this._dragX = this._dragStartX = stageX;
        this._dragY = this._dragStartY = stageY;
        if (this.actor._delegate && this.actor._delegate.getDragActor) {
            this._dragActor = this.actor._delegate.getDragActor();
            Main.uiGroup.add_child(this._dragActor);
            this._dragActor.raise_top();
            Shell.util_set_hidden_from_pick(this._dragActor, true);
            // Drag actor does not always have to be the same as actor. For example drag actor
            // can be an image that's part of the actor. So to perform "snap back" correctly we need
            // to know what was the drag actor source.
            if (this.actor._delegate.getDragActorSource) {
                this._dragActorSource = this.actor._delegate.getDragActorSource();
                // If the user dragged from the source, then position
                // the dragActor over it. Otherwise, center it
                // around the pointer
                let [sourceX, sourceY] = this._dragActorSource.get_transformed_position();
                let x, y;
                if (stageX > sourceX && stageX <= sourceX + this._dragActor.width &&
                    stageY > sourceY && stageY <= sourceY + this._dragActor.height) {
                    x = sourceX;
                    y = sourceY;
                } else {
                    x = stageX - this._dragActor.width / 2;
                    y = stageY - this._dragActor.height / 2;
                }
                this._dragActor.set_position(x, y);
            } else {
                this._dragActorSource = this.actor;
            }
            this._dragOrigParent = undefined;
            this._dragOffsetX = this._dragActor.x - this._dragStartX;
            this._dragOffsetY = this._dragActor.y - this._dragStartY;
        } else {
            this._dragActor = this.actor;
            this._dragActorSource = undefined;
            this._dragOrigParent = this.actor.get_parent();
            this._dragOrigX = this._dragActor.x;
            this._dragOrigY = this._dragActor.y;
            this._dragOrigScale = this._dragActor.scale_x;
            // Set the actor's scale such that it will keep the same
            // transformed size when it's reparented to the uiGroup
            let [scaledWidth, scaledHeight] = this.actor.get_transformed_size();
            this._dragActor.set_scale(scaledWidth / this.actor.width,
                                      scaledHeight / this.actor.height);
            let [actorStageX, actorStageY] = this.actor.get_transformed_position();
            this._dragOffsetX = actorStageX - this._dragStartX;
            this._dragOffsetY = actorStageY - this._dragStartY;
            this._dragOrigParent.remove_actor(this._dragActor);
            Main.uiGroup.add_child(this._dragActor);
            this._dragActor.raise_top();
            Shell.util_set_hidden_from_pick(this._dragActor, true);
        }
        this._dragOrigOpacity = this._dragActor.opacity;
        if (this._dragActorOpacity != undefined)
            this._dragActor.opacity = this._dragActorOpacity;
        this._snapBackX = this._dragStartX + this._dragOffsetX;
        this._snapBackY = this._dragStartY + this._dragOffsetY;
        this._snapBackScale = this._dragActor.scale_x;
        if (this._dragActorMaxSize != undefined) {
            let [scaledWidth, scaledHeight] = this._dragActor.get_transformed_size();
            let currentSize = Math.max(scaledWidth, scaledHeight);
            if (currentSize > this._dragActorMaxSize) {
                let scale = this._dragActorMaxSize / currentSize;
                let origScale =  this._dragActor.scale_x;
                let origDragOffsetX = this._dragOffsetX;
                let origDragOffsetY = this._dragOffsetY;
                // The position of the actor changes as we scale
                // around the drag position, but we can't just tween
                // to the final position because that tween would
                // fight with updates as the user continues dragging
                // the mouse; instead we do the position computations in
                // an onUpdate() function.
                Tweener.addTween(this._dragActor,
                                 { scale_x: scale * origScale,
                                   scale_y: scale * origScale,
                                   time: SCALE_ANIMATION_TIME,
                                   transition: 'easeOutQuad',
                                   onUpdate: function() {
                                       let currentScale = this._dragActor.scale_x / origScale;
                                       this._dragOffsetX = currentScale * origDragOffsetX;
                                       this._dragOffsetY = currentScale * origDragOffsetY;
                                       this._dragActor.set_position(this._dragX + this._dragOffsetX,
                                                                    this._dragY + this._dragOffsetY);
                                   },
                                   onUpdateScope: this });
            }
        }
    },
    _maybeStartDrag:  function(event) {
        let [stageX, stageY] = event.get_coords();
        // See if the user has moved the mouse enough to trigger a drag
        let threshold = Gtk.Settings.get_default().gtk_dnd_drag_threshold;
        if ((Math.abs(stageX - this._dragStartX) > threshold ||
             Math.abs(stageY - this._dragStartY) > threshold)) {
            this.startDrag(stageX, stageY, event.get_time(), this._touchSequence);
            this._updateDragPosition(event);
        }
        return true;
    },
    _updateDragHover : function () {
        this._updateHoverId = 0;
        let target = this._dragActor.get_stage().get_actor_at_pos(Clutter.PickMode.ALL,
                                                                  this._dragX, this._dragY);
        let dragEvent = {
            x: this._dragX,
            y: this._dragY,
            dragActor: this._dragActor,
            source: this.actor._delegate,
            targetActor: target
        };
        for (let i = 0; i < dragMonitors.length; i++) {
            let motionFunc = dragMonitors[i].dragMotion;
            if (motionFunc) {
                let result = motionFunc(dragEvent);
                if (result != DragMotionResult.CONTINUE) {
                    global.screen.set_cursor(DRAG_CURSOR_MAP[result]);
                    return GLib.SOURCE_REMOVE;
                }
            }
        }
        while (target) {
            if (target._delegate && target._delegate.handleDragOver) {
                let [r, targX, targY] = target.transform_stage_point(this._dragX, this._dragY);
                // We currently loop through all parents on drag-over even if one of the children has handled it.
                // We can check the return value of the function and break the loop if it's true if we don't want
                // to continue checking the parents.
                let result = target._delegate.handleDragOver(this.actor._delegate,
                                                             this._dragActor,
                                                             targX,
                                                             targY,
                                                             0);
                if (result != DragMotionResult.CONTINUE) {
                    global.screen.set_cursor(DRAG_CURSOR_MAP[result]);
                    return GLib.SOURCE_REMOVE;
                }
            }
            target = target.get_parent();
        }
        global.screen.set_cursor(Meta.Cursor.DND_IN_DRAG);
        return GLib.SOURCE_REMOVE;
    },
    _queueUpdateDragHover: function() {
        if (this._updateHoverId)
            return;
        this._updateHoverId = GLib.idle_add(GLib.PRIORITY_DEFAULT,
                                            Lang.bind(this, this._updateDragHover));
        GLib.Source.set_name_by_id(this._updateHoverId, '[gnome-shell] this._updateDragHover');
    },
    _updateDragPosition : function (event) {
        let [stageX, stageY] = event.get_coords();
        this._dragX = stageX;
        this._dragY = stageY;
        this._dragActor.set_position(stageX + this._dragOffsetX,
                                     stageY + this._dragOffsetY);
        this._queueUpdateDragHover();
        return true;
    },
    _dragActorDropped: function(event) {
        let [dropX, dropY] = event.get_coords();
        let target = this._dragActor.get_stage().get_actor_at_pos(Clutter.PickMode.ALL,
                                                                  dropX, dropY);
        // We call observers only once per motion with the innermost
        // target actor. If necessary, the observer can walk the
        // parent itself.
        let dropEvent = {
            dropActor: this._dragActor,
            targetActor: target,
            clutterEvent: event
        };
        for (let i = 0; i < dragMonitors.length; i++) {
            let dropFunc = dragMonitors[i].dragDrop;
            if (dropFunc)
                switch (dropFunc(dropEvent)) {
                    case DragDropResult.FAILURE:
                    case DragDropResult.SUCCESS:
                        return true;
                    case DragDropResult.CONTINUE:
                        continue;
                }
        }
        // At this point it is too late to cancel a drag by destroying
        // the actor, the fate of which is decided by acceptDrop and its
        // side-effects
        this._dragCancellable = false;
        while (target) {
            if (target._delegate && target._delegate.acceptDrop) {
                let [r, targX, targY] = target.transform_stage_point(dropX, dropY);
                if (target._delegate.acceptDrop(this.actor._delegate,
                                                this._dragActor,
                                                targX,
                                                targY,
                                                event.get_time())) {
                    // If it accepted the drop without taking the actor,
                    // handle it ourselves.
                    if (this._dragActor.get_parent() == Main.uiGroup) {
                        if (this._restoreOnSuccess) {
                            this._restoreDragActor(event.get_time());
                            return true;
                        } else
                            this._dragActor.destroy();
                    }
                    this._dragInProgress = false;
                    global.screen.set_cursor(Meta.Cursor.DEFAULT);
                    this.emit('drag-end', event.get_time(), true);
                    this._dragComplete();
                    return true;
                }
            }
            target = target.get_parent();
        }
        this._cancelDrag(event.get_time());
        return true;
    },
    _getRestoreLocation: function() {
        let x, y, scale;
        if (this._dragActorSource && this._dragActorSource.visible) {
            // Snap the clone back to its source
            [x, y] = this._dragActorSource.get_transformed_position();
            let [sourceScaledWidth, sourceScaledHeight] = this._dragActorSource.get_transformed_size();
            scale = this._dragActor.width / sourceScaledWidth;
        } else if (this._dragOrigParent) {
            // Snap the actor back to its original position within
            // its parent, adjusting for the fact that the parent
            // may have been moved or scaled
            let [parentX, parentY] = this._dragOrigParent.get_transformed_position();
            let [parentWidth, parentHeight] = this._dragOrigParent.get_size();
            let [parentScaledWidth, parentScaledHeight] = this._dragOrigParent.get_transformed_size();
            let parentScale = 1.0;
            if (parentWidth != 0)
                parentScale = parentScaledWidth / parentWidth;
            x = parentX + parentScale * this._dragOrigX;
            y = parentY + parentScale * this._dragOrigY;
            scale = this._dragOrigScale * parentScale;
        } else {
            // Snap back actor to its original stage position
            x = this._snapBackX;
            y = this._snapBackY;
            scale = this._snapBackScale;
        }
        return [x, y, scale];
    },
    _cancelDrag: function(eventTime) {
        this.emit('drag-cancelled', eventTime);
        this._dragInProgress = false;
        let [snapBackX, snapBackY, snapBackScale] = this._getRestoreLocation();
        if (this._actorDestroyed) {
            global.screen.set_cursor(Meta.Cursor.DEFAULT);
            if (!this._buttonDown)
                this._dragComplete();
            this.emit('drag-end', eventTime, false);
            if (!this._dragOrigParent)
                this._dragActor.destroy();
            return;
        }
        this._animateDragEnd(eventTime,
                             { x: snapBackX,
                               y: snapBackY,
                               scale_x: snapBackScale,
                               scale_y: snapBackScale,
                               time: SNAP_BACK_ANIMATION_TIME,
                             });
    },
    _restoreDragActor: function(eventTime) {
        this._dragInProgress = false;
        [restoreX, restoreY, restoreScale] = this._getRestoreLocation();
        // fade the actor back in at its original location
        this._dragActor.set_position(restoreX, restoreY);
        this._dragActor.set_scale(restoreScale, restoreScale);
        this._dragActor.opacity = 0;
        this._animateDragEnd(eventTime,
                             { time: REVERT_ANIMATION_TIME });
    },
    _animateDragEnd: function (eventTime, params) {
        this._animationInProgress = true;
        // finish animation if the actor gets destroyed
        // during it
        this._dragActorDestroyId =
            this._dragActor.connect('destroy',
                                    Lang.bind(this, this._finishAnimation));
        params['opacity']          = this._dragOrigOpacity;
        params['transition']       = 'easeOutQuad';
        params['onComplete']       = this._onAnimationComplete;
        params['onCompleteScope']  = this;
        params['onCompleteParams'] = [this._dragActor, eventTime];
        // start the animation
        Tweener.addTween(this._dragActor, params)
    },
    _finishAnimation : function () {
        if (!this._animationInProgress)
            return
        this._animationInProgress = false;
        if (!this._buttonDown)
            this._dragComplete();
        global.screen.set_cursor(Meta.Cursor.DEFAULT);
    },
    _onAnimationComplete : function (dragActor, eventTime) {
        dragActor.disconnect(this._dragActorDestroyId);
        this._dragActorDestroyId = 0;
        if (this._dragOrigParent) {
            Main.uiGroup.remove_child(this._dragActor);
            this._dragOrigParent.add_actor(this._dragActor);
            dragActor.set_scale(this._dragOrigScale, this._dragOrigScale);
            dragActor.set_position(this._dragOrigX, this._dragOrigY);
        } else {
            dragActor.destroy();
        }
        this.emit('drag-end', eventTime, false);
        this._finishAnimation();
    },
    _dragComplete: function() {
        if (!this._actorDestroyed)
            Shell.util_set_hidden_from_pick(this._dragActor, false);
        this._ungrabEvents();
        global.sync_pointer();
        if (this._updateHoverId) {
            GLib.source_remove(this._updateHoverId);
            this._updateHoverId = 0;
        }
        this._dragActor = undefined;
        currentDraggable = null;
    }
Signals.addSignalMethods(_Draggable.prototype);
 * makeDraggable:
 * @actor: Source actor
 * @params: (optional) Additional parameters
 * Create an object which controls drag and drop for the given actor.
 * If %manualMode is %true in @params, do not automatically start
 * drag and drop on click
 * If %dragActorMaxSize is present in @params, the drag actor will
 * be scaled down to be no larger than that size in pixels.
 * If %dragActorOpacity is present in @params, the drag actor will
 * will be set to have that opacity during the drag.
 * Note that when the drag actor is the source actor and the drop
 * succeeds, the actor scale and opacity aren't reset; if the drop
 * target wants to reuse the actor, it's up to the drop target to
 * reset these values.
function makeDraggable(actor, params) {
    return new _Draggable(actor, params);
(uuay)workspaceThumbnail.js
// -*- mode: js; js-indent-level: 4; indent-tabs-mode: nil -*-
const Clutter = imports.gi.Clutter;
const Gio = imports.gi.Gio;
const GLib = imports.gi.GLib;
const Lang = imports.lang;
const Mainloop = imports.mainloop;
const Meta = imports.gi.Meta;
const Shell = imports.gi.Shell;
const Signals = imports.signals;
const St = imports.gi.St;
const Background = imports.ui.background;
const DND = imports.ui.dnd;
const Main = imports.ui.main;
const Tweener = imports.ui.tweener;
const WindowManager = imports.ui.windowManager;
const Workspace = imports.ui.workspace;
const WorkspacesView = imports.ui.workspacesView;
// The maximum size of a thumbnail is 1/8 the width and height of the screen
let MAX_THUMBNAIL_SCALE = 1/8.;
const RESCALE_ANIMATION_TIME = 0.2;
const SLIDE_ANIMATION_TIME = 0.2;
// When we create workspaces by dragging, we add a "cut" into the top and
// bottom of each workspace so that the user doesn't have to hit the
// placeholder exactly.
const WORKSPACE_CUT_SIZE = 10;
const WORKSPACE_KEEP_ALIVE_TIME = 100;
const OVERRIDE_SCHEMA = 'org.gnome.shell.overrides';
/* A layout manager that requests size only for primary_actor, but then allocates
   all using a fixed layout */
const PrimaryActorLayout = new Lang.Class({
    Name: 'PrimaryActorLayout',
    Extends: Clutter.FixedLayout,
    _init: function(primaryActor) {
        this.parent();
        this.primaryActor = primaryActor;
    },
    vfunc_get_preferred_width: function(container, forHeight) {
        return this.primaryActor.get_preferred_width(forHeight);
    },
    vfunc_get_preferred_height: function(container, forWidth) {
        return this.primaryActor.get_preferred_height(forWidth);
    },
const WindowClone = new Lang.Class({
    Name: 'WindowClone',
    _init : function(realWindow) {
        this.clone = new Clutter.Clone({ source: realWindow });
        /* Can't use a Shell.GenericContainer because of DND and reparenting... */
        this.actor = new Clutter.Actor({ layout_manager: new PrimaryActorLayout(this.clone),
                                         reactive: true });
        this.actor._delegate = this;
        this.actor.add_child(this.clone);
        this.realWindow = realWindow;
        this.metaWindow = realWindow.meta_window;
        this.clone._updateId = this.metaWindow.connect('position-changed',
                                                       Lang.bind(this, this._onPositionChanged));
        this.clone._destroyId = this.realWindow.connect('destroy', Lang.bind(this, function() {
            // First destroy the clone and then destroy everything
            // This will ensure that we never see it in the _disconnectSignals loop
            this.clone.destroy();
            this.destroy();
        }));
        this._onPositionChanged();
        this.actor.connect('button-release-event',
                           Lang.bind(this, this._onButtonRelease));
        this.actor.connect('touch-event',
                           Lang.bind(this, this._onTouchEvent));
        this.actor.connect('destroy', Lang.bind(this, this._onDestroy));
        this._draggable = DND.makeDraggable(this.actor,
                                            { restoreOnSuccess: true,
                                              dragActorMaxSize: Workspace.WINDOW_DND_SIZE,
                                              dragActorOpacity: Workspace.DRAGGING_WINDOW_OPACITY });
        this._draggable.connect('drag-begin', Lang.bind(this, this._onDragBegin));
        this._draggable.connect('drag-cancelled', Lang.bind(this, this._onDragCancelled));
        this._draggable.connect('drag-end', Lang.bind(this, this._onDragEnd));
        this.inDrag = false;
        let iter = Lang.bind(this, function(win) {
            let actor = win.get_compositor_private();
            if (!actor)
                return false;
            if (!win.is_attached_dialog())
                return false;
            this._doAddAttachedDialog(win, actor);
            win.foreach_transient(iter);
            return true;
        });
        this.metaWindow.foreach_transient(iter);
    },
    // Find the actor just below us, respecting reparenting done
    // by DND code
    getActualStackAbove: function() {
        if (this._stackAbove == null)
            return null;
        if (this.inDrag) {
            if (this._stackAbove._delegate)
                return this._stackAbove._delegate.getActualStackAbove();
            else
                return null;
        } else {
            return this._stackAbove;
        }
    },
    setStackAbove: function (actor) {
        this._stackAbove = actor;
        // Don't apply the new stacking now, it will be applied
        // when dragging ends and window are stacked again
        if (actor.inDrag)
            return;
        let actualAbove = this.getActualStackAbove();
        if (actualAbove == null)
            this.actor.lower_bottom();
        else
            this.actor.raise(actualAbove);
    },
    destroy: function () {
        this.actor.destroy();
    },
    addAttachedDialog: function(win) {
        this._doAddAttachedDialog(win, win.get_compositor_private());
    },
    _doAddAttachedDialog: function(metaDialog, realDialog) {
        let clone = new Clutter.Clone({ source: realDialog });
        this._updateDialogPosition(realDialog, clone);
        clone._updateId = metaDialog.connect('position-changed',
                                             Lang.bind(this, this._updateDialogPosition, clone));
        clone._destroyId = realDialog.connect('destroy', Lang.bind(this, function() {
            clone.destroy();
        }));
        this.actor.add_child(clone);
    },
    _updateDialogPosition: function(realDialog, cloneDialog) {
        let metaDialog = realDialog.meta_window;
        let dialogRect = metaDialog.get_frame_rect();
        let rect = this.metaWindow.get_frame_rect();
        cloneDialog.set_position(dialogRect.x - rect.x, dialogRect.y - rect.y);
    },
    _onPositionChanged: function() {
        let rect = this.metaWindow.get_frame_rect();
        this.actor.set_position(this.realWindow.x, this.realWindow.y);
    },
    _disconnectSignals: function() {
        this.actor.get_children().forEach(function(child) {
            let realWindow = child.source;
            realWindow.meta_window.disconnect(child._updateId);
            realWindow.disconnect(child._destroyId);
        });
    },
    _onDestroy: function() {
        this._disconnectSignals();
        this.actor._delegate = null;
        if (this.inDrag) {
            this.emit('drag-end');
            this.inDrag = false;
        }
        this.disconnectAll();
    },
    _onButtonRelease : function (actor, event) {
        this.emit('selected', event.get_time());
        return Clutter.EVENT_STOP;
    },
    _onTouchEvent : function (actor, event) {
        if (event.type() != Clutter.EventType.TOUCH_END ||
            !global.display.is_pointer_emulating_sequence(event.get_event_sequence()))
            return Clutter.EVENT_PROPAGATE;
        this.emit('selected', event.get_time());
        return Clutter.EVENT_STOP;
    },
    _onDragBegin : function (draggable, time) {
        this.inDrag = true;
        this.emit('drag-begin');
    },
    _onDragCancelled : function (draggable, time) {
        this.emit('drag-cancelled');
    },
    _onDragEnd : function (draggable, time, snapback) {
        this.inDrag = false;
        // We may not have a parent if DnD completed successfully, in
        // which case our clone will shortly be destroyed and replaced
        // with a new one on the target workspace.
        if (this.actor.get_parent() != null) {
            if (this._stackAbove == null)
                this.actor.lower_bottom();
            else
                this.actor.raise(this._stackAbove);
        }
        this.emit('drag-end');
    }
Signals.addSignalMethods(WindowClone.prototype);
const ThumbnailState = {
    NEW   :         0,
    ANIMATING_IN :  1,
    NORMAL:         2,
    REMOVING :      3,
    ANIMATING_OUT : 4,
    ANIMATED_OUT :  5,
    COLLAPSING :    6,
    DESTROYED :     7
 * @metaWorkspace: a #Meta.Workspace
const WorkspaceThumbnail = new Lang.Class({
    Name: 'WorkspaceThumbnail',
    _init : function(metaWorkspace) {
        this.metaWorkspace = metaWorkspace;
        this.monitorIndex = Main.layoutManager.primaryIndex;
        this._removed = false;
        this.actor = new St.Widget({ clip_to_allocation: true,
                                     style_class: 'workspace-thumbnail' });
        this.actor._delegate = this;
        this._contents = new Clutter.Actor();
        this.actor.add_child(this._contents);
        this.actor.connect('destroy', Lang.bind(this, this._onDestroy));
        this._createBackground();
        let monitor = Main.layoutManager.primaryMonitor;
        this.setPorthole(monitor.x, monitor.y, monitor.width, monitor.height);
        let windows = global.get_window_actors().filter(Lang.bind(this, function(actor) {
            let win = actor.meta_window;
            return win.located_on_workspace(metaWorkspace);
        }));
        // Create clones for windows that should be visible in the Overview
        this._windows = [];
        this._allWindows = [];
        this._minimizedChangedIds = [];
        for (let i = 0; i < windows.length; i++) {
            let minimizedChangedId =
                windows[i].meta_window.connect('notify::minimized',
                                               Lang.bind(this,
                                                         this._updateMinimized));
            this._allWindows.push(windows[i].meta_window);
            this._minimizedChangedIds.push(minimizedChangedId);
            if (this._isMyWindow(windows[i]) && this._isOverviewWindow(windows[i])) {
                this._addWindowClone(windows[i]);
            }
        }
        // Track window changes
        this._windowAddedId = this.metaWorkspace.connect('window-added',
                                                          Lang.bind(this, this._windowAdded));
        this._windowRemovedId = this.metaWorkspace.connect('window-removed',
                                                           Lang.bind(this, this._windowRemoved));
        this._windowEnteredMonitorId = global.screen.connect('window-entered-monitor',
                                                           Lang.bind(this, this._windowEnteredMonitor));
        this._windowLeftMonitorId = global.screen.connect('window-left-monitor',
                                                           Lang.bind(this, this._windowLeftMonitor));
        this.state = ThumbnailState.NORMAL;
        this._slidePosition = 0; // Fully slid in
        this._collapseFraction = 0; // Not collapsed
    },
    _createBackground: function() {
        this._bgManager = new Background.BackgroundManager({ monitorIndex: Main.layoutManager.primaryIndex,
                                                             container: this._contents,
                                                             vignette: false });
    },
    setPorthole: function(x, y, width, height) {
        this._portholeX = x;
        this._portholeY = y;
        this.actor.set_size(width, height);
        this._contents.set_position(-x, -y);
    },
    _lookupIndex: function (metaWindow) {
        for (let i = 0; i < this._windows.length; i++) {
            if (this._windows[i].metaWindow == metaWindow) {
                return i;
            }
        }
        return -1;
    },
    syncStacking: function(stackIndices) {
        this._windows.sort(function (a, b) { return stackIndices[a.metaWindow.get_stable_sequence()] - stackIndices[b.metaWindow.get_stable_sequence()]; });
        for (let i = 0; i < this._windows.length; i++) {
            let clone = this._windows[i];
            let metaWindow = clone.metaWindow;
            if (i == 0) {
                clone.setStackAbove(this._bgManager.backgroundActor);
            } else {
                let previousClone = this._windows[i - 1];
                clone.setStackAbove(previousClone.actor);
            }
        }
    },
    set slidePosition(slidePosition) {
        this._slidePosition = slidePosition;
        this.actor.queue_relayout();
    },
    get slidePosition() {
        return this._slidePosition;
    },
    set collapseFraction(collapseFraction) {
        this._collapseFraction = collapseFraction;
        this.actor.queue_relayout();
    },
    get collapseFraction() {
        return this._collapseFraction;
    },
    _doRemoveWindow : function(metaWin) {
        let win = metaWin.get_compositor_private();
        // find the position of the window in our list
        let index = this._lookupIndex (metaWin);
        if (index == -1)
            return;
        let clone = this._windows[index];
        this._windows.splice(index, 1);
        clone.destroy();
    },
    _doAddWindow : function(metaWin) {
        if (this._removed)
            return;
        let win = metaWin.get_compositor_private();
        if (!win) {
            // Newly-created windows are added to a workspace before
            // the compositor finds out about them...
            let id = Mainloop.idle_add(Lang.bind(this,
                                       function () {
                                            if (!this._removed &&
                                                metaWin.get_compositor_private() &&
                                                metaWin.get_workspace() == this.metaWorkspace)
                                                this._doAddWindow(metaWin);
                                            return GLib.SOURCE_REMOVE;
                                        }));
            GLib.Source.set_name_by_id(id, '[gnome-shell] this._doAddWindow');
            return;
        }
        if (this._allWindows.indexOf(metaWin) == -1) {
            let minimizedChangedId = metaWin.connect('notify::minimized',
                                                     Lang.bind(this,
                                                               this._updateMinimized));
            this._allWindows.push(metaWin);
            this._minimizedChangedIds.push(minimizedChangedId);
        }
        // We might have the window in our list already if it was on all workspaces and
        // now was moved to this workspace
        if (this._lookupIndex (metaWin) != -1)
            return;
        if (!this._isMyWindow(win))
            return;
        if (this._isOverviewWindow(win)) {
            this._addWindowClone(win);
        } else if (metaWin.is_attached_dialog()) {
            let parent = metaWin.get_transient_for();
            while (parent.is_attached_dialog())
                parent = metaWin.get_transient_for();
            let idx = this._lookupIndex (parent);
            if (idx < 0) {
                // parent was not created yet, it will take care
                // of the dialog when created
                return;
            }
            let clone = this._windows[idx];
            clone.addAttachedDialog(metaWin);
        }
    },
    _windowAdded : function(metaWorkspace, metaWin) {
        this._doAddWindow(metaWin);
    },
    _windowRemoved : function(metaWorkspace, metaWin) {
        let index = this._allWindows.indexOf(metaWin);
        if (index != -1) {
            metaWin.disconnect(this._minimizedChangedIds[index]);
            this._allWindows.splice(index, 1);
            this._minimizedChangedIds.splice(index, 1);
        }
        this._doRemoveWindow(metaWin);
    },
    _windowEnteredMonitor : function(metaScreen, monitorIndex, metaWin) {
        if (monitorIndex == this.monitorIndex) {
            this._doAddWindow(metaWin);
        }
    },
    _windowLeftMonitor : function(metaScreen, monitorIndex, metaWin) {
        if (monitorIndex == this.monitorIndex) {
            this._doRemoveWindow(metaWin);
        }
    },
    _updateMinimized: function(metaWin) {
        if (metaWin.minimized)
            this._doRemoveWindow(metaWin);
        else
            this._doAddWindow(metaWin);
    },
    destroy : function() {
        if (this.actor)
          this.actor.destroy();
    },
    workspaceRemoved : function() {
        if (this._removed)
            return;
        this._removed = true;
        this.metaWorkspace.disconnect(this._windowAddedId);
        this.metaWorkspace.disconnect(this._windowRemovedId);
        global.screen.disconnect(this._windowEnteredMonitorId);
        global.screen.disconnect(this._windowLeftMonitorId);
        for (let i = 0; i < this._allWindows.length; i++)
            this._allWindows[i].disconnect(this._minimizedChangedIds[i]);
    },
    _onDestroy: function(actor) {
        this.workspaceRemoved();
        if (this._bgManager) {
          this._bgManager.destroy();
          this._bgManager = null;
        }
        this._windows = [];
        this.actor = null;
    },
    // Tests if @actor belongs to this workspace and monitor
    _isMyWindow : function (actor) {
        let win = actor.meta_window;
        return win.located_on_workspace(this.metaWorkspace) &&
            (win.get_monitor() == this.monitorIndex);
    },
    // Tests if @win should be shown in the Overview
    _isOverviewWindow : function (win) {
        return !win.get_meta_window().skip_taskbar &&
               win.get_meta_window().showing_on_its_workspace();
    },
    // Create a clone of a (non-desktop) window and add it to the window list
    _addWindowClone : function(win) {
        let clone = new WindowClone(win);
        clone.connect('selected',
                      Lang.bind(this, function(clone, time) {
                          this.activate(time);
                      }));
        clone.connect('drag-begin',
                      Lang.bind(this, function() {
                          Main.overview.beginWindowDrag(clone.metaWindow);
                      }));
        clone.connect('drag-cancelled',
                      Lang.bind(this, function() {
                          Main.overview.cancelledWindowDrag(clone.metaWindow);
                      }));
        clone.connect('drag-end',
                      Lang.bind(this, function() {
                          Main.overview.endWindowDrag(clone.metaWindow);
                      }));
        this._contents.add_actor(clone.actor);
        if (this._windows.length == 0)
            clone.setStackAbove(this._bgManager.backgroundActor);
        else
            clone.setStackAbove(this._windows[this._windows.length - 1].actor);
        this._windows.push(clone);
        return clone;
    },
    activate : function (time) {
        if (this.state > ThumbnailState.NORMAL)
            return;
        // a click on the already current workspace should go back to the main view
        if (this.metaWorkspace == global.screen.get_active_workspace())
            Main.overview.hide();
        else
            this.metaWorkspace.activate(time);
    },
    // Draggable target interface used only by ThumbnailsBox
    handleDragOverInternal : function(source, time) {
        if (source == Main.xdndHandler) {
            this.metaWorkspace.activate(time);
            return DND.DragMotionResult.CONTINUE;
        }
        if (this.state > ThumbnailState.NORMAL)
            return DND.DragMotionResult.CONTINUE;
        if (source.realWindow && !this._isMyWindow(source.realWindow))
            return DND.DragMotionResult.MOVE_DROP;
        if (source.shellWorkspaceLaunch)
            return DND.DragMotionResult.COPY_DROP;
        return DND.DragMotionResult.CONTINUE;
    },
    acceptDropInternal : function(source, time) {
        if (this.state > ThumbnailState.NORMAL)
            return false;
        if (source.realWindow) {
            let win = source.realWindow;
            if (this._isMyWindow(win))
                return false;
            let metaWindow = win.get_meta_window();
            // We need to move the window before changing the workspace, because
            // the move itself could cause a workspace change if the window enters
            // the primary monitor
            if (metaWindow.get_monitor() != this.monitorIndex)
                metaWindow.move_to_monitor(this.monitorIndex);
            metaWindow.change_workspace_by_index(this.metaWorkspace.index(), false);
            return true;
        } else if (source.shellWorkspaceLaunch) {
            source.shellWorkspaceLaunch({ workspace: this.metaWorkspace ? this.metaWorkspace.index() : -1,
                                          timestamp: time });
            return true;
        }
        return false;
    }
Signals.addSignalMethods(WorkspaceThumbnail.prototype);
const ThumbnailsBox = new Lang.Class({
    Name: 'ThumbnailsBox',
    _init: function() {
        this.actor = new Shell.GenericContainer({ reactive: true,
                                                  style_class: 'workspace-thumbnails',
                                                  request_mode: Clutter.RequestMode.WIDTH_FOR_HEIGHT });
        this.actor.connect('get-preferred-width', Lang.bind(this, this._getPreferredWidth));
        this.actor.connect('get-preferred-height', Lang.bind(this, this._getPreferredHeight));
        this.actor.connect('allocate', Lang.bind(this, this._allocate));
        this.actor._delegate = this;
        let indicator = new St.Bin({ style_class: 'workspace-thumbnail-indicator' });
        // We don't want the indicator to affect drag-and-drop
        Shell.util_set_hidden_from_pick(indicator, true);
        this._indicator = indicator;
        this.actor.add_actor(indicator);
        this._dropWorkspace = -1;
        this._dropPlaceholderPos = -1;
        this._dropPlaceholder = new St.Bin({ style_class: 'placeholder' });
        this.actor.add_actor(this._dropPlaceholder);
        this._spliceIndex = -1;
        this._targetScale = 0;
        this._scale = 0;
        this._pendingScaleUpdate = false;
        this._stateUpdateQueued = false;
        this._animatingIndicator = false;
        this._indicatorY = 0; // only used when _animatingIndicator is true
        this._stateCounts = {};
        for (let key in ThumbnailState)
            this._stateCounts[ThumbnailState[key]] = 0;
        this._thumbnails = [];
        this.actor.connect('button-press-event', function() { return Clutter.EVENT_STOP; });
        this.actor.connect('button-release-event', Lang.bind(this, this._onButtonRelease));
        this.actor.connect('touch-event', Lang.bind(this, this._onTouchEvent));
        Main.overview.connect('showing',
                              Lang.bind(this, this._createThumbnails));
        Main.overview.connect('hidden',
                              Lang.bind(this, this._destroyThumbnails));
        Main.overview.connect('item-drag-begin',
                              Lang.bind(this, this._onDragBegin));
        Main.overview.connect('item-drag-end',
                              Lang.bind(this, this._onDragEnd));
        Main.overview.connect('item-drag-cancelled',
                              Lang.bind(this, this._onDragCancelled));
        Main.overview.connect('window-drag-begin',
                              Lang.bind(this, this._onDragBegin));
        Main.overview.connect('window-drag-end',
                              Lang.bind(this, this._onDragEnd));
        Main.overview.connect('window-drag-cancelled',
                              Lang.bind(this, this._onDragCancelled));
        this._settings = new Gio.Settings({ schema_id: OVERRIDE_SCHEMA });
        this._settings.connect('changed::dynamic-workspaces',
            Lang.bind(this, this._updateSwitcherVisibility));
    },
    _updateSwitcherVisibility: function() {
        this.actor.visible =
            this._settings.get_boolean('dynamic-workspaces') ||
                global.screen.n_workspaces > 1;
    },
    _activateThumbnailAtPoint: function (stageX, stageY, time) {
        let [r, x, y] = this.actor.transform_stage_point(stageX, stageY);
        for (let i = 0; i < this._thumbnails.length; i++) {
            let thumbnail = this._thumbnails[i]
            let [w, h] = thumbnail.actor.get_transformed_size();
            if (y >= thumbnail.actor.y && y <= thumbnail.actor.y + h) {
                thumbnail.activate(time);
                break;
            }
        }
    },
    _onButtonRelease: function(actor, event) {
        let [stageX, stageY] = event.get_coords();
        this._activateThumbnailAtPoint(stageX, stageY, event.get_time());
        return Clutter.EVENT_STOP;
    },
    _onTouchEvent: function (actor, event) {
        if (event.type() == Clutter.EventType.TOUCH_END &&
            global.display.is_pointer_emulating_sequence(event.get_event_sequence())) {
            let [stageX, stageY] = event.get_coords();
            this._activateThumbnailAtPoint(stageX, stageY, event.get_time());
        }
        return Clutter.EVENT_STOP;
    },
    _onDragBegin: function() {
        this._dragCancelled = false;
        this._dragMonitor = {
            dragMotion: Lang.bind(this, this._onDragMotion)
        };
        DND.addDragMonitor(this._dragMonitor);
    },
    _onDragEnd: function() {
        if (this._dragCancelled)
            return;
        this._endDrag();
    },
    _onDragCancelled: function() {
        this._dragCancelled = true;
        this._endDrag();
    },
    _endDrag: function() {
        this._clearDragPlaceholder();
        DND.removeDragMonitor(this._dragMonitor);
    },
    _onDragMotion: function(dragEvent) {
        if (!this.actor.contains(dragEvent.targetActor))
            this._onLeave();
        return DND.DragMotionResult.CONTINUE;
    },
    _onLeave: function() {
        this._clearDragPlaceholder();
    },
    _clearDragPlaceholder: function() {
        if (this._dropPlaceholderPos == -1)
            return;
        this._dropPlaceholderPos = -1;
        this.actor.queue_relayout();
    },
    // Draggable target interface
    handleDragOver : function(source, actor, x, y, time) {
        if (!source.realWindow && !source.shellWorkspaceLaunch && source != Main.xdndHandler)
            return DND.DragMotionResult.CONTINUE;
        let canCreateWorkspaces = Meta.prefs_get_dynamic_workspaces();
        let spacing = this.actor.get_theme_node().get_length('spacing');
        this._dropWorkspace = -1;
        let placeholderPos = -1;
        let targetBase;
        if (this._dropPlaceholderPos == 0)
            targetBase = this._dropPlaceholder.y;
        else
            targetBase = this._thumbnails[0].actor.y;
        let targetTop = targetBase - spacing - WORKSPACE_CUT_SIZE;
        let length = this._thumbnails.length;
        for (let i = 0; i < length; i ++) {
            // Allow the reorder target to have a 10px "cut" into
            // each side of the thumbnail, to make dragging onto the
            // placeholder easier
            let [w, h] = this._thumbnails[i].actor.get_transformed_size();
            let targetBottom = targetBase + WORKSPACE_CUT_SIZE;
            let nextTargetBase = targetBase + h + spacing;
            let nextTargetTop =  nextTargetBase - spacing - ((i == length - 1) ? 0: WORKSPACE_CUT_SIZE);
            // Expand the target to include the placeholder, if it exists.
            if (i == this._dropPlaceholderPos)
                targetBottom += this._dropPlaceholder.get_height();
            if (y > targetTop && y <= targetBottom && source != Main.xdndHandler && canCreateWorkspaces) {
                placeholderPos = i;
                break;
            } else if (y > targetBottom && y <= nextTargetTop) {
                this._dropWorkspace = i;
                break
            }
            targetBase = nextTargetBase;
            targetTop = nextTargetTop;
        }
        if (this._dropPlaceholderPos != placeholderPos) {
            this._dropPlaceholderPos = placeholderPos;
            this.actor.queue_relayout();
        }
        if (this._dropWorkspace != -1)
            return this._thumbnails[this._dropWorkspace].handleDragOverInternal(source, time);
        else if (this._dropPlaceholderPos != -1)
            return source.realWindow ? DND.DragMotionResult.MOVE_DROP : DND.DragMotionResult.COPY_DROP;
        else
            return DND.DragMotionResult.CONTINUE;
    },
    acceptDrop: function(source, actor, x, y, time) {
        if (this._dropWorkspace != -1) {
            return this._thumbnails[this._dropWorkspace].acceptDropInternal(source, time);
        } else if (this._dropPlaceholderPos != -1) {
            if (!source.realWindow && !source.shellWorkspaceLaunch)
                return false;
            let isWindow = !!source.realWindow;
            let newWorkspaceIndex;
            [newWorkspaceIndex, this._dropPlaceholderPos] = [this._dropPlaceholderPos, -1];
            this._spliceIndex = newWorkspaceIndex;
            Main.wm.insertWorkspace(newWorkspaceIndex);
            if (isWindow) {
                // Move the window to our monitor first if necessary.
                let thumbMonitor = this._thumbnails[newWorkspaceIndex].monitorIndex;
                if (source.metaWindow.get_monitor() != thumbMonitor)
                    source.metaWindow.move_to_monitor(thumbMonitor);
                source.metaWindow.change_workspace_by_index(newWorkspaceIndex, true);
            } else if (source.shellWorkspaceLaunch) {
                source.shellWorkspaceLaunch({ workspace: newWorkspaceIndex,
                                              timestamp: time });
                // This new workspace will be automatically removed if the application fails
                // to open its first window within some time, as tracked by Shell.WindowTracker.
                // Here, we only add a very brief timeout to avoid the _immediate_ removal of the
                // workspace while we wait for the startup sequence to load.
                Main.wm.keepWorkspaceAlive(global.screen.get_workspace_by_index(newWorkspaceIndex),
                                           WORKSPACE_KEEP_ALIVE_TIME);
            }
            // Start the animation on the workspace (which is actually
            // an old one which just became empty)
            let thumbnail = this._thumbnails[newWorkspaceIndex];
            this._setThumbnailState(thumbnail, ThumbnailState.NEW);
            thumbnail.slidePosition = 1;
            this._queueUpdateStates();
            return true;
        } else {
            return false;
        }
    },
    _createThumbnails: function() {
        this._switchWorkspaceNotifyId =
            global.window_manager.connect('switch-workspace',
                                          Lang.bind(this, this._activeWorkspaceChanged));
        this._nWorkspacesNotifyId =
            global.screen.connect('notify::n-workspaces',
                                  Lang.bind(this, this._workspacesChanged));
        this._syncStackingId =
            Main.overview.connect('windows-restacked',
                                  Lang.bind(this, this._syncStacking));
        this._targetScale = 0;
        this._scale = 0;
        this._pendingScaleUpdate = false;
        this._stateUpdateQueued = false;
        this._stateCounts = {};
        for (let key in ThumbnailState)
            this._stateCounts[ThumbnailState[key]] = 0;
        this.addThumbnails(0, global.screen.n_workspaces);
        this._updateSwitcherVisibility();
    },
    _destroyThumbnails: function() {
        if (this._switchWorkspaceNotifyId > 0) {
            global.window_manager.disconnect(this._switchWorkspaceNotifyId);
            this._switchWorkspaceNotifyId = 0;
        }
        if (this._nWorkspacesNotifyId > 0) {
            global.screen.disconnect(this._nWorkspacesNotifyId);
            this._nWorkspacesNotifyId = 0;
        }
        if (this._syncStackingId > 0) {
            Main.overview.disconnect(this._syncStackingId);
            this._syncStackingId = 0;
        }
        for (let w = 0; w < this._thumbnails.length; w++)
            this._thumbnails[w].destroy();
        this._thumbnails = [];
        this._porthole = null;
    },
    _workspacesChanged: function() {
        let validThumbnails = this._thumbnails.filter(function(t) {
            return t.state <= ThumbnailState.NORMAL;
        });
        let oldNumWorkspaces = validThumbnails.length;
        let newNumWorkspaces = global.screen.n_workspaces;
        let active = global.screen.get_active_workspace_index();
        if (newNumWorkspaces > oldNumWorkspaces) {
            this.addThumbnails(oldNumWorkspaces, newNumWorkspaces - oldNumWorkspaces);
        } else {
            let removedIndex;
            let removedNum = oldNumWorkspaces - newNumWorkspaces;
            for (let w = 0; w < oldNumWorkspaces; w++) {
                let metaWorkspace = global.screen.get_workspace_by_index(w);
                if (this._thumbnails[w].metaWorkspace != metaWorkspace) {
                    removedIndex = w;
                    break;
                }
            }
            this.removeThumbnails(removedIndex, removedNum);
        }
        this._updateSwitcherVisibility();
    },
    addThumbnails: function(start, count) {
        this._ensurePorthole();
        for (let k = start; k < start + count; k++) {
            let metaWorkspace = global.screen.get_workspace_by_index(k);
            let thumbnail = new WorkspaceThumbnail(metaWorkspace);
            thumbnail.setPorthole(this._porthole.x, this._porthole.y,
                                  this._porthole.width, this._porthole.height);
            this._thumbnails.push(thumbnail);
            this.actor.add_actor(thumbnail.actor);
            if (start > 0 && this._spliceIndex == -1) {
                // not the initial fill, and not splicing via DND
                thumbnail.state = ThumbnailState.NEW;
                thumbnail.slidePosition = 1; // start slid out
                this._haveNewThumbnails = true;
            } else {
                thumbnail.state = ThumbnailState.NORMAL;
            }
            this._stateCounts[thumbnail.state]++;
        }
        this._queueUpdateStates();
        // The thumbnails indicator actually needs to be on top of the thumbnails
        this._indicator.raise_top();
        // Clear the splice index, we got the message
        this._spliceIndex = -1;
    },
    removeThumbnails: function(start, count) {
        let currentPos = 0;
        for (let k = 0; k < this._thumbnails.length; k++) {
            let thumbnail = this._thumbnails[k];
            if (thumbnail.state > ThumbnailState.NORMAL)
                continue;
            if (currentPos >= start && currentPos < start + count) {
                thumbnail.workspaceRemoved();
                this._setThumbnailState(thumbnail, ThumbnailState.REMOVING);
            }
            currentPos++;
        }
        this._queueUpdateStates();
    },
    _syncStacking: function(overview, stackIndices) {
        for (let i = 0; i < this._thumbnails.length; i++)
            this._thumbnails[i].syncStacking(stackIndices);
    },
    set scale(scale) {
        this._scale = scale;
        this.actor.queue_relayout();
    },
    get scale() {
        return this._scale;
    },
    set indicatorY(indicatorY) {
        this._indicatorY = indicatorY;
        this.actor.queue_relayout();
    },
    get indicatorY() {
        return this._indicatorY;
    },
    _setThumbnailState: function(thumbnail, state) {
        this._stateCounts[thumbnail.state]--;
        thumbnail.state = state;
        this._stateCounts[thumbnail.state]++;
    },
    _iterateStateThumbnails: function(state, callback) {
        if (this._stateCounts[state] == 0)
            return;
        for (let i = 0; i < this._thumbnails.length; i++) {
            if (this._thumbnails[i].state == state)
                callback.call(this, this._thumbnails[i]);
        }
    },
    _tweenScale: function() {
        Tweener.addTween(this,
                         { scale: this._targetScale,
                           time: RESCALE_ANIMATION_TIME,
                           transition: 'easeOutQuad',
                           onComplete: this._queueUpdateStates,
                           onCompleteScope: this });
    },
    _updateStates: function() {
        this._stateUpdateQueued = false;
        // If we are animating the indicator, wait
        if (this._animatingIndicator)
            return;
        // Then slide out any thumbnails that have been destroyed
        this._iterateStateThumbnails(ThumbnailState.REMOVING,
            function(thumbnail) {
                this._setThumbnailState(thumbnail, ThumbnailState.ANIMATING_OUT);
                Tweener.addTween(thumbnail,
                                 { slidePosition: 1,
                                   time: SLIDE_ANIMATION_TIME,
                                   transition: 'linear',
                                   onComplete: function() {
                                       this._setThumbnailState(thumbnail, ThumbnailState.ANIMATED_OUT);
                                       this._queueUpdateStates();
                                   },
                                   onCompleteScope: this
                                 });
            });
        // As long as things are sliding out, don't proceed
        if (this._stateCounts[ThumbnailState.ANIMATING_OUT] > 0)
            return;
        // Once that's complete, we can start scaling to the new size and collapse any removed thumbnails
        this._iterateStateThumbnails(ThumbnailState.ANIMATED_OUT,
            function(thumbnail) {
                this.actor.set_skip_paint(thumbnail.actor, true);
                this._setThumbnailState(thumbnail, ThumbnailState.COLLAPSING);
                Tweener.addTween(thumbnail,
                                 { collapseFraction: 1,
                                   time: RESCALE_ANIMATION_TIME,
                                   transition: 'easeOutQuad',
                                   onComplete: function() {
                                       this._stateCounts[thumbnail.state]--;
                                       thumbnail.state = ThumbnailState.DESTROYED;
                                       let index = this._thumbnails.indexOf(thumbnail);
                                       this._thumbnails.splice(index, 1);
                                       thumbnail.destroy();
                                       this._queueUpdateStates();
                                   },
                                   onCompleteScope: this
                                 });
                });
        if (this._pendingScaleUpdate) {
            this._tweenScale();
            this._pendingScaleUpdate = false;
        }
        // Wait until that's done
        if (this._scale != this._targetScale || this._stateCounts[ThumbnailState.COLLAPSING] > 0)
            return;
        // And then slide in any new thumbnails
        this._iterateStateThumbnails(ThumbnailState.NEW,
            function(thumbnail) {
                this._setThumbnailState(thumbnail, ThumbnailState.ANIMATING_IN);
                Tweener.addTween(thumbnail,
                                 { slidePosition: 0,
                                   time: SLIDE_ANIMATION_TIME,
                                   transition: 'easeOutQuad',
                                   onComplete: function() {
                                       this._setThumbnailState(thumbnail, ThumbnailState.NORMAL);
                                   },
                                   onCompleteScope: this
                                 });
            });
    },
    _queueUpdateStates: function() {
        if (this._stateUpdateQueued)
            return;
        Meta.later_add(Meta.LaterType.BEFORE_REDRAW,
                       Lang.bind(this, this._updateStates));
        this._stateUpdateQueued = true;
    },
    _getPreferredHeight: function(actor, forWidth, alloc) {
        // Note that for getPreferredWidth/Height we cheat a bit and skip propagating
        // the size request to our children because we know how big they are and know
        // that the actors aren't depending on the virtual functions being called.
        this._ensurePorthole();
        let themeNode = this.actor.get_theme_node();
        let spacing = themeNode.get_length('spacing');
        let nWorkspaces = global.screen.n_workspaces;
        let totalSpacing = (nWorkspaces - 1) * spacing;
        alloc.min_size = totalSpacing;
        alloc.natural_size = totalSpacing + nWorkspaces * this._porthole.height * MAX_THUMBNAIL_SCALE;
    },
    _getPreferredWidth: function(actor, forHeight, alloc) {
        this._ensurePorthole();
        let themeNode = this.actor.get_theme_node();
        let spacing = this.actor.get_theme_node().get_length('spacing');
        let nWorkspaces = global.screen.n_workspaces;
        let totalSpacing = (nWorkspaces - 1) * spacing;
        let avail = forHeight - totalSpacing;
        let scale = (avail / nWorkspaces) / this._porthole.height;
        scale = Math.min(scale, MAX_THUMBNAIL_SCALE);
        let width = Math.round(this._porthole.width * scale);
        alloc.min_size = width;
        alloc.natural_size = width;
    },
    // The "porthole" is the portion of the screen that we show in the
    // workspaces
    _ensurePorthole: function() {
        if (!this._porthole)
            this._porthole = Main.layoutManager.getWorkAreaForMonitor(Main.layoutManager.primaryIndex);
    },
    _allocate: function(actor, box, flags) {
        let rtl = (Clutter.get_default_text_direction () == Clutter.TextDirection.RTL);
        if (this._thumbnails.length == 0) // not visible
            return;
        let themeNode = this.actor.get_theme_node();
        let portholeWidth = this._porthole.width;
        let portholeHeight = this._porthole.height;
        let spacing = themeNode.get_length('spacing');
        // Compute the scale we'll need once everything is updated
        let nWorkspaces = global.screen.n_workspaces;
        let totalSpacing = (nWorkspaces - 1) * spacing;
        let avail = (box.y2 - box.y1) - totalSpacing;
        let newScale = (avail / nWorkspaces) / portholeHeight;
        newScale = Math.min(newScale, MAX_THUMBNAIL_SCALE);
        if (newScale != this._targetScale) {
            if (this._targetScale > 0) {
                // We don't do the tween immediately because we need to observe the ordering
                // in queueUpdateStates - if workspaces have been removed we need to slide them
                // out as the first thing.
                this._targetScale = newScale;
                this._pendingScaleUpdate = true;
            } else {
                this._targetScale = this._scale = newScale;
            }
            this._queueUpdateStates();
        }
        let thumbnailHeight = portholeHeight * this._scale;
        let thumbnailWidth = Math.round(portholeWidth * this._scale);
        let roundedHScale = thumbnailWidth / portholeWidth;
        let slideOffset; // X offset when thumbnail is fully slid offscreen
        if (rtl)
            slideOffset = - (thumbnailWidth + themeNode.get_padding(St.Side.LEFT));
        else
            slideOffset = thumbnailWidth + themeNode.get_padding(St.Side.RIGHT);
        let indicatorY1 = this._indicatorY;
        let indicatorY2;
        // when not animating, the workspace position overrides this._indicatorY
        let indicatorWorkspace = !this._animatingIndicator ? global.screen.get_active_workspace() : null;
        let indicatorThemeNode = this._indicator.get_theme_node();
        let indicatorTopFullBorder = indicatorThemeNode.get_padding(St.Side.TOP) + indicatorThemeNode.get_border_width(St.Side.TOP);
        let indicatorBottomFullBorder = indicatorThemeNode.get_padding(St.Side.BOTTOM) + indicatorThemeNode.get_border_width(St.Side.BOTTOM);
        let indicatorLeftFullBorder = indicatorThemeNode.get_padding(St.Side.LEFT) + indicatorThemeNode.get_border_width(St.Side.LEFT);
        let indicatorRightFullBorder = indicatorThemeNode.get_padding(St.Side.RIGHT) + indicatorThemeNode.get_border_width(St.Side.RIGHT);
        let y = box.y1;
        if (this._dropPlaceholderPos == -1) {
            Meta.later_add(Meta.LaterType.BEFORE_REDRAW, Lang.bind(this, function() {
                this._dropPlaceholder.hide();
            }));
        }
        let childBox = new Clutter.ActorBox();
        for (let i = 0; i < this._thumbnails.length; i++) {
            let thumbnail = this._thumbnails[i];
            if (i > 0)
                y += spacing - Math.round(thumbnail.collapseFraction * spacing);
            let x1, x2;
            if (rtl) {
                x1 = box.x1 + slideOffset * thumbnail.slidePosition;
                x2 = x1 + thumbnailWidth;
            } else {
                x1 = box.x2 - thumbnailWidth + slideOffset * thumbnail.slidePosition;
                x2 = x1 + thumbnailWidth;
            }
            if (i == this._dropPlaceholderPos) {
                let [minHeight, placeholderHeight] = this._dropPlaceholder.get_preferred_height(-1);
                childBox.x1 = x1;
                childBox.x2 = x1 + thumbnailWidth;
                childBox.y1 = Math.round(y);
                childBox.y2 = Math.round(y + placeholderHeight);
                this._dropPlaceholder.allocate(childBox, flags);
                Meta.later_add(Meta.LaterType.BEFORE_REDRAW, Lang.bind(this, function() {
                    this._dropPlaceholder.show();
                }));
                y += placeholderHeight + spacing;
            }
            // We might end up with thumbnailHeight being something like 99.33
            // pixels. To make this work and not end up with a gap at the bottom,
            // we need some thumbnails to be 99 pixels and some 100 pixels height;
            // we compute an actual scale separately for each thumbnail.
            let y1 = Math.round(y);
            let y2 = Math.round(y + thumbnailHeight);
            let roundedVScale = (y2 - y1) / portholeHeight;
            if (thumbnail.metaWorkspace == indicatorWorkspace) {
                indicatorY1 = y1;
                indicatorY2 = y2;
            }
            // Allocating a scaled actor is funny - x1/y1 correspond to the origin
            // of the actor, but x2/y2 are increased by the *unscaled* size.
            childBox.x1 = x1;
            childBox.x2 = x1 + portholeWidth;
            childBox.y1 = y1;
            childBox.y2 = y1 + portholeHeight;
            thumbnail.actor.set_scale(roundedHScale, roundedVScale);
            thumbnail.actor.allocate(childBox, flags);
            // We round the collapsing portion so that we don't get thumbnails resizing
            // during an animation due to differences in rounded, but leave the uncollapsed
            // portion unrounded so that non-animating we end up with the right total
            y += thumbnailHeight - Math.round(thumbnailHeight * thumbnail.collapseFraction);
        }
        if (rtl) {
            childBox.x1 = box.x1;
            childBox.x2 = box.x1 + thumbnailWidth;
        } else {
            childBox.x1 = box.x2 - thumbnailWidth;
            childBox.x2 = box.x2;
        }
        childBox.x1 -= indicatorLeftFullBorder;
        childBox.x2 += indicatorRightFullBorder;
        childBox.y1 = indicatorY1 - indicatorTopFullBorder;
        childBox.y2 = (indicatorY2 ? indicatorY2 : (indicatorY1 + thumbnailHeight)) + indicatorBottomFullBorder;
        this._indicator.allocate(childBox, flags);
    },
    _activeWorkspaceChanged: function(wm, from, to, direction) {
        let thumbnail;
        let activeWorkspace = global.screen.get_active_workspace();
        for (let i = 0; i < this._thumbnails.length; i++) {
            if (this._thumbnails[i].metaWorkspace == activeWorkspace) {
                thumbnail = this._thumbnails[i];
                break;
            }
        }
        this._animatingIndicator = true;
        let indicatorThemeNode = this._indicator.get_theme_node();
        let indicatorTopFullBorder = indicatorThemeNode.get_padding(St.Side.TOP) + indicatorThemeNode.get_border_width(St.Side.TOP);
        this.indicatorY = this._indicator.allocation.y1 + indicatorTopFullBorder;
        Tweener.addTween(this,
                         { indicatorY: thumbnail.actor.allocation.y1,
                           time: WorkspacesView.WORKSPACE_SWITCH_TIME,
                           transition: 'easeOutQuad',
                           onComplete: function() {
                               this._animatingIndicator = false;
                               this._queueUpdateStates();
                           },
                           onCompleteScope: this
                         });
    }
(uuay)modemManager.js
// -*- mode: js; js-indent-level: 4; indent-tabs-mode: nil -*-
const Gio = imports.gi.Gio;
const Lang = imports.lang;
const NMGtk = imports.gi.NMGtk;
const Signals = imports.signals;
// _getMobileProvidersDatabase:
// Gets the database of mobile providers, with references between MCCMNC/SID and
// operator name
let _mpd;
function _getMobileProvidersDatabase() {
    if (_mpd == null) {
        try {
            _mpd = new NMGtk.MobileProvidersDatabase();
            _mpd.init(null);
        } catch (e) {
            log(e.message);
            _mpd = null;
        }
    }
    return _mpd;
// _findProviderForMccMnc:
// @operator_name: operator name
// @operator_code: operator code
// Given an operator name string (which may not be a real operator name) and an
// operator code string, tries to find a proper operator name to display.
function _findProviderForMccMnc(operator_name, operator_code) {
    if (operator_name) {
        if (operator_name.length != 0 &&
            (operator_name.length > 6 || operator_name.length < 5)) {
            // this looks like a valid name, i.e. not an MCCMNC (that some
            // devices return when not yet connected
            return operator_name;
        }
        if (isNaN(parseInt(operator_name))) {
            // name is definitely not a MCCMNC, so it may be a name
            // after all; return that
            return operator_name;
        }
    }
    let needle;
    if ((!operator_name || operator_name.length == 0) && operator_code)
        needle = operator_code;
    else if (operator_name && (operator_name.length == 6 || operator_name.length == 5))
        needle = operator_name;
    else // nothing to search
        return null;
    let mpd = _getMobileProvidersDatabase();
    if (mpd) {
        let provider = mpd.lookup_3gpp_mcc_mnc(needle);
        if (provider)
            return provider.get_name();
    }
    return null;
// _findProviderForSid:
// @sid: System Identifier of the serving CDMA network
// Tries to find the operator name corresponding to the given SID
function _findProviderForSid(sid) {
    if (sid == 0)
        return null;
    let mpd = _getMobileProvidersDatabase();
    if (mpd) {
        let provider = mpd.lookup_cdma_sid(sid);
        if (provider)
            return provider.get_name();
    }
    return null;
//------------------------------------------------------------------------------
// Support for the old ModemManager interface (MM < 0.7)
//------------------------------------------------------------------------------
// The following are not the complete interfaces, just the methods we need
// (or may need in the future)
const ModemGsmNetworkInterface = '<node> \
<interface name="org.freedesktop.ModemManager.Modem.Gsm.Network"> \
<method name="GetRegistrationInfo"> \
    <arg type="(uss)" direction="out" /> \
</method> \
<method name="GetSignalQuality"> \
    <arg type="u" direction="out" /> \
</method> \
<property name="AccessTechnology" type="u" access="read" /> \
<signal name="SignalQuality"> \
    <arg type="u" direction="out" /> \
</signal> \
<signal name="RegistrationInfo"> \
    <arg type="u" direction="out" /> \
    <arg type="s" direction="out" /> \
    <arg type="s" direction="out" /> \
</signal> \
</interface> \
</node>';
const ModemGsmNetworkProxy = Gio.DBusProxy.makeProxyWrapper(ModemGsmNetworkInterface);
const ModemCdmaInterface = '<node> \
<interface name="org.freedesktop.ModemManager.Modem.Cdma"> \
<method name="GetSignalQuality"> \
    <arg type="u" direction="out" /> \
</method> \
<method name="GetServingSystem"> \
    <arg type="(usu)" direction="out" /> \
</method> \
<signal name="SignalQuality"> \
    <arg type="u" direction="out" /> \
</signal> \
</interface> \
</node>';
const ModemCdmaProxy = Gio.DBusProxy.makeProxyWrapper(ModemCdmaInterface);
const ModemGsm = new Lang.Class({
    Name: 'ModemGsm',
    _init: function(path) {
        this._proxy = new ModemGsmNetworkProxy(Gio.DBus.system, 'org.freedesktop.ModemManager', path);
        this.signal_quality = 0;
        this.operator_name = null;
        // Code is duplicated because the function have different signatures
        this._proxy.connectSignal('SignalQuality', Lang.bind(this, function(proxy, sender, [quality]) {
            this.signal_quality = quality;
            this.emit('notify::signal-quality');
        }));
        this._proxy.connectSignal('RegistrationInfo', Lang.bind(this, function(proxy, sender, [status, code, name]) {
            this.operator_name = _findProviderForMccMnc(name, code);
            this.emit('notify::operator-name');
        }));
        this._proxy.GetRegistrationInfoRemote(Lang.bind(this, function([result], err) {
            if (err) {
                log(err);
                return;
            }
            let [status, code, name] = result;
            this.operator_name = _findProviderForMccMnc(name, code);
            this.emit('notify::operator-name');
        }));
        this._proxy.GetSignalQualityRemote(Lang.bind(this, function(result, err) {
            if (err) {
                // it will return an error if the device is not connected
                this.signal_quality = 0;
            } else {
                let [quality] = result;
                this.signal_quality = quality;
            }
            this.emit('notify::signal-quality');
        }));
    }
Signals.addSignalMethods(ModemGsm.prototype);
const ModemCdma = new Lang.Class({
    Name: 'ModemCdma',
    _init: function(path) {
        this._proxy = new ModemCdmaProxy(Gio.DBus.system, 'org.freedesktop.ModemManager', path);
        this.signal_quality = 0;
        this.operator_name = null;
        this._proxy.connectSignal('SignalQuality', Lang.bind(this, function(proxy, sender, params) {
            this.signal_quality = params[0];
            this.emit('notify::signal-quality');
            // receiving this signal means the device got activated
            // and we can finally call GetServingSystem
            if (this.operator_name == null)
                this._refreshServingSystem();
        }));
        this._proxy.GetSignalQualityRemote(Lang.bind(this, function(result, err) {
            if (err) {
                // it will return an error if the device is not connected
                this.signal_quality = 0;
            } else {
                let [quality] = result;
                this.signal_quality = quality;
            }
            this.emit('notify::signal-quality');
        }));
    },
    _refreshServingSystem: function() {
        this._proxy.GetServingSystemRemote(Lang.bind(this, function([result], err) {
            if (err) {
                // it will return an error if the device is not connected
                this.operator_name = null;
            } else {
                let [bandClass, band, sid] = result;
                this.operator_name = _findProviderForSid(sid)
            }
            this.emit('notify::operator-name');
        }));
    }
Signals.addSignalMethods(ModemCdma.prototype);
//------------------------------------------------------------------------------
// Support for the new ModemManager1 interface (MM >= 0.7)
//------------------------------------------------------------------------------
const BroadbandModemInterface = '<node> \
<interface name="org.freedesktop.ModemManager1.Modem"> \
<property name="SignalQuality" type="(ub)" access="read" /> \
</interface> \
</node>';
const BroadbandModemProxy = Gio.DBusProxy.makeProxyWrapper(BroadbandModemInterface);
const BroadbandModem3gppInterface = '<node> \
<interface name="org.freedesktop.ModemManager1.Modem.Modem3gpp"> \
<property name="OperatorCode" type="s" access="read" /> \
<property name="OperatorName" type="s" access="read" /> \
</interface> \
</node>';
const BroadbandModem3gppProxy = Gio.DBusProxy.makeProxyWrapper(BroadbandModem3gppInterface);
const BroadbandModemCdmaInterface = '<node> \
<interface name="org.freedesktop.ModemManager1.Modem.ModemCdma"> \
<property name="Sid" type="u" access="read" /> \
</interface> \
</node>';
const BroadbandModemCdmaProxy = Gio.DBusProxy.makeProxyWrapper(BroadbandModemCdmaInterface);
const BroadbandModem = new Lang.Class({
    Name: 'BroadbandModem',
    _init: function(path, capabilities) {
        this._proxy = new BroadbandModemProxy(Gio.DBus.system, 'org.freedesktop.ModemManager1', path);
        this._proxy_3gpp = new BroadbandModem3gppProxy(Gio.DBus.system, 'org.freedesktop.ModemManager1', path);
        this._proxy_cdma = new BroadbandModemCdmaProxy(Gio.DBus.system, 'org.freedesktop.ModemManager1', path);
        this._capabilities = capabilities;
        this._proxy.connect('g-properties-changed', Lang.bind(this, function(proxy, properties) {
            if ('SignalQuality' in properties.deep_unpack())
                this._reloadSignalQuality();
        }));
        this._reloadSignalQuality();
        this._proxy_3gpp.connect('g-properties-changed', Lang.bind(this, function(proxy, properties) {
            let unpacked = properties.deep_unpack();
            if ('OperatorName' in unpacked || 'OperatorCode' in unpacked)
                this._reload3gppOperatorName();
        }));
        this._reload3gppOperatorName();
        this._proxy_cdma.connect('g-properties-changed', Lang.bind(this, function(proxy, properties) {
            let unpacked = properties.deep_unpack();
            if ('Nid' in unpacked || 'Sid' in unpacked)
                this._reloadCdmaOperatorName();
        }));
        this._reloadCdmaOperatorName();
    },
    _reloadSignalQuality: function() {
        let [quality, recent] = this._proxy.SignalQuality;
        this.signal_quality = quality;
        this.emit('notify::signal-quality');
    },
    _reloadOperatorName: function() {
        let new_name = "";
        if (this.operator_name_3gpp && this.operator_name_3gpp.length > 0)
            new_name += this.operator_name_3gpp;
        if (this.operator_name_cdma && this.operator_name_cdma.length > 0) {
            if (new_name != "")
                new_name += ", ";
            new_name += this.operator_name_cdma;
        }
        this.operator_name = new_name;
        this.emit('notify::operator-name');
    },
    _reload3gppOperatorName: function() {
        let name = this._proxy_3gpp.OperatorName;
        let code = this._proxy_3gpp.OperatorCode;
        this.operator_name_3gpp = _findProviderForMccMnc(name, code);
        this._reloadOperatorName();
    },
    _reloadCdmaOperatorName: function() {
        let sid = this._proxy_cdma.Sid;
        this.operator_name_cdma = _findProviderForSid(sid);
        this._reloadOperatorName();
    }
Signals.addSignalMethods(BroadbandModem.prototype);
(uuay)keyboardManager.js
// -*- mode: js; js-indent-level: 4; indent-tabs-mode: nil -*-
const GLib = imports.gi.GLib;
const GnomeDesktop = imports.gi.GnomeDesktop;
const Lang = imports.lang;
const Meta = imports.gi.Meta;
const Main = imports.ui.main;
const DEFAULT_LOCALE = 'en_US';
const DEFAULT_LAYOUT = 'us';
const DEFAULT_VARIANT = '';
let _xkbInfo = null;
function getXkbInfo() {
    if (_xkbInfo == null)
        _xkbInfo = new GnomeDesktop.XkbInfo();
    return _xkbInfo;
let _keyboardManager = null;
function getKeyboardManager() {
    if (_keyboardManager == null)
        _keyboardManager = new KeyboardManager();
    return _keyboardManager;
function releaseKeyboard() {
    if (Main.modalCount > 0)
        global.display.unfreeze_keyboard(global.get_current_time());
    else
        global.display.ungrab_keyboard(global.get_current_time());
function holdKeyboard() {
    global.display.freeze_keyboard(global.get_current_time());
const KeyboardManager = new Lang.Class({
    Name: 'KeyboardManager',
    // The XKB protocol doesn't allow for more that 4 layouts in a
    // keymap. Wayland doesn't impose this limit and libxkbcommon can
    // handle up to 32 layouts but since we need to support X clients
    // even as a Wayland compositor, we can't bump this.
    MAX_LAYOUTS_PER_GROUP: 4,
    _init: function() {
        this._xkbInfo = getXkbInfo();
        this._current = null;
        this._localeLayoutInfo = this._getLocaleLayout();
        this._layoutInfos = {};
    },
    _applyLayoutGroup: function(group) {
        let options = this._buildOptionsString();
        let [layouts, variants] = this._buildGroupStrings(group);
        Meta.get_backend().set_keymap(layouts, variants, options);
    },
    _applyLayoutGroupIndex: function(idx) {
        Meta.get_backend().lock_layout_group(idx);
    },
    apply: function(id) {
        let info = this._layoutInfos[id];
        if (!info)
            return;
        if (this._current && this._current.group == info.group) {
            if (this._current.groupIndex != info.groupIndex)
                this._applyLayoutGroupIndex(info.groupIndex);
        } else {
            this._applyLayoutGroup(info.group);
            this._applyLayoutGroupIndex(info.groupIndex);
        }
        this._current = info;
    },
    reapply: function() {
        if (!this._current)
            return;
        this._applyLayoutGroup(this._current.group);
        this._applyLayoutGroupIndex(this._current.groupIndex);
    },
    setUserLayouts: function(ids) {
        this._current = null;
        this._layoutInfos = {};
        for (let i = 0; i < ids.length; ++i) {
            let [found, , , _layout, _variant] = this._xkbInfo.get_layout_info(ids[i]);
            if (found)
                this._layoutInfos[ids[i]] = { id: ids[i], layout: _layout, variant: _variant };
        }
        let i = 0;
        let group = [];
        for (let id in this._layoutInfos) {
            // We need to leave one slot on each group free so that we
            // can add a layout containing the symbols for the
            // language used in UI strings to ensure that toolkits can
            // handle mnemonics like Alt+
 even if the user is
            // actually typing in a different layout.
            let groupIndex = i % (this.MAX_LAYOUTS_PER_GROUP - 1);
            if (groupIndex == 0)
                group = [];
            let info = this._layoutInfos[id];
            group[groupIndex] = info;
            info.group = group;
            info.groupIndex = groupIndex;
            i += 1;
        }
    },
    _getLocaleLayout: function() {
        let locale = GLib.get_language_names()[0];
        if (locale.indexOf('_') == -1)
            locale = DEFAULT_LOCALE;
        let [found, , id] = GnomeDesktop.get_input_source_from_locale(locale);
        if (!found)
            [, , id] = GnomeDesktop.get_input_source_from_locale(DEFAULT_LOCALE);
        let [found, , , _layout, _variant] = this._xkbInfo.get_layout_info(id);
        if (found)
            return { layout: _layout, variant: _variant };
        else
            return { layout: DEFAULT_LAYOUT, variant: DEFAULT_VARIANT };
    },
    _buildGroupStrings: function(_group) {
        let group = _group.concat(this._localeLayoutInfo);
        let layouts = group.map(function(g) { return g.layout; }).join(',');
        let variants = group.map(function(g) { return g.variant; }).join(',');
        return [layouts, variants];
    },
    setKeyboardOptions: function(options) {
        this._xkbOptions = options;
    },
    _buildOptionsString: function() {
        let options = this._xkbOptions.join(',');
        return options;
    }
(uuay)/
autorunManager.js
// -*- mode: js; js-indent-level: 4; indent-tabs-mode: nil -*-
const Lang = imports.lang;
const Gio = imports.gi.Gio;
const St = imports.gi.St;
const GnomeSession = imports.misc.gnomeSession;
const Main = imports.ui.main;
const MessageTray = imports.ui.messageTray;
const ShellMountOperation = imports.ui.shellMountOperation;
// GSettings keys
const SETTINGS_SCHEMA = 'org.gnome.desktop.media-handling';
const SETTING_DISABLE_AUTORUN = 'autorun-never';
const SETTING_START_APP = 'autorun-x-content-start-app';
const SETTING_IGNORE = 'autorun-x-content-ignore';
const SETTING_OPEN_FOLDER = 'autorun-x-content-open-folder';
const AutorunSetting = {
    RUN: 0,
    IGNORE: 1,
    FILES: 2,
    ASK: 3
// misc utils
function shouldAutorunMount(mount) {
    let root = mount.get_root();
    let volume = mount.get_volume();
    if (!volume || !volume.allowAutorun)
        return false;
    if (root.is_native() && isMountRootHidden(root))
        return false;
    return true;
function isMountRootHidden(root) {
    let path = root.get_path();
    // skip any mounts in hidden directory hierarchies
    return (path.indexOf('/.') != -1);
function isMountNonLocal(mount) {
    // If the mount doesn't have an associated volume, that means it's
    // an uninteresting filesystem. Most devices that we care about will
    // have a mount, like media players and USB sticks.
    let volume = mount.get_volume();
    if (volume == null)
        return true;
    return (volume.get_identifier("class") == "network");
function startAppForMount(app, mount) {
    let files = [];
    let root = mount.get_root();
    let retval = false;
    files.push(root);
    try {
        retval = app.launch(files, 
                            global.create_app_launch_context(0, -1))
    } catch (e) {
        log('Unable to launch the application ' + app.get_name()
            + ': ' + e.toString());
    }
    return retval;
/******************************************/
const HotplugSnifferIface = '<node> \
<interface name="org.gnome.Shell.HotplugSniffer"> \
<method name="SniffURI"> \
    <arg type="s" direction="in" /> \
    <arg type="as" direction="out" /> \
</method> \
</interface> \
</node>';
const HotplugSnifferProxy = Gio.DBusProxy.makeProxyWrapper(HotplugSnifferIface);
function HotplugSniffer() {
    return new HotplugSnifferProxy(Gio.DBus.session,
                                   'org.gnome.Shell.HotplugSniffer',
                                   '/org/gnome/Shell/HotplugSniffer');
const ContentTypeDiscoverer = new Lang.Class({
    Name: 'ContentTypeDiscoverer',
    _init: function(callback) {
        this._callback = callback;
        this._settings = new Gio.Settings({ schema_id: SETTINGS_SCHEMA });
    },
    guessContentTypes: function(mount) {
        let autorunEnabled = !this._settings.get_boolean(SETTING_DISABLE_AUTORUN);
        let shouldScan = autorunEnabled && !isMountNonLocal(mount);
        if (shouldScan) {
            // guess mount's content types using GIO
            mount.guess_content_type(false, null,
                                     Lang.bind(this,
                                               this._onContentTypeGuessed));
        } else {
            this._emitCallback(mount, []);
        }
    },
    _onContentTypeGuessed: function(mount, res) {
        let contentTypes = [];
        try {
            contentTypes = mount.guess_content_type_finish(res);
        } catch (e) {
            log('Unable to guess content types on added mount ' + mount.get_name()
                + ': ' + e.toString());
        }
        if (contentTypes.length) {
            this._emitCallback(mount, contentTypes);
        } else {
            let root = mount.get_root();
            let hotplugSniffer = new HotplugSniffer();
            hotplugSniffer.SniffURIRemote(root.get_uri(),
                 Lang.bind(this, function([contentTypes]) {
                     this._emitCallback(mount, contentTypes);
                 }));
        }
    },
    _emitCallback: function(mount, contentTypes) {
        if (!contentTypes)
            contentTypes = [];
        // we're not interested in win32 software content types here
        contentTypes = contentTypes.filter(function(type) {
            return (type != 'x-content/win32-software');
        });
        let apps = [];
        contentTypes.forEach(function(type) {
            let app = Gio.app_info_get_default_for_type(type, false);
            if (app)
                apps.push(app);
        });
        if (apps.length == 0)
            apps.push(Gio.app_info_get_default_for_type('inode/directory', false));
        this._callback(mount, apps, contentTypes);
    }
const AutorunManager = new Lang.Class({
    Name: 'AutorunManager',
    _init: function() {
        this._session = new GnomeSession.SessionManager();
        this._volumeMonitor = Gio.VolumeMonitor.get();
        this._dispatcher = new AutorunDispatcher(this);
    },
    enable: function() {
        this._mountAddedId = this._volumeMonitor.connect('mount-added', Lang.bind(this, this._onMountAdded));
        this._mountRemovedId = this._volumeMonitor.connect('mount-removed', Lang.bind(this, this._onMountRemoved));
    },
    disable: function() {
        this._volumeMonitor.disconnect(this._mountAddedId);
        this._volumeMonitor.disconnect(this._mountRemovedId);
    },
    _onMountAdded: function(monitor, mount) {
        // don't do anything if our session is not the currently
        // active one
        if (!this._session.SessionIsActive)
            return;
        let discoverer = new ContentTypeDiscoverer(Lang.bind(this, function(mount, apps, contentTypes) {
            this._dispatcher.addMount(mount, apps, contentTypes);
        }));
        discoverer.guessContentTypes(mount);
    },
    _onMountRemoved: function(monitor, mount) {
        this._dispatcher.removeMount(mount);
    }
const AutorunDispatcher = new Lang.Class({
    Name: 'AutorunDispatcher',
    _init: function(manager) {
        this._manager = manager;
        this._sources = [];
        this._settings = new Gio.Settings({ schema_id: SETTINGS_SCHEMA });
    },
    _getAutorunSettingForType: function(contentType) {
        let runApp = this._settings.get_strv(SETTING_START_APP);
        if (runApp.indexOf(contentType) != -1)
            return AutorunSetting.RUN;
        let ignore = this._settings.get_strv(SETTING_IGNORE);
        if (ignore.indexOf(contentType) != -1)
            return AutorunSetting.IGNORE;
        let openFiles = this._settings.get_strv(SETTING_OPEN_FOLDER);
        if (openFiles.indexOf(contentType) != -1)
            return AutorunSetting.FILES;
        return AutorunSetting.ASK;
    },
    _getSourceForMount: function(mount) {
        let filtered =
            this._sources.filter(function (source) {
                return (source.mount == mount);
            });
        // we always make sure not to add two sources for the same
        // mount in addMount(), so it's safe to assume filtered.length
        // is always either 1 or 0.
        if (filtered.length == 1)
            return filtered[0];
        return null;
    },
    _addSource: function(mount, apps) {
        // if we already have a source showing for this 
        // mount, return
        if (this._getSourceForMount(mount))
            return;
     
        // add a new source
        this._sources.push(new AutorunSource(this._manager, mount, apps));
    },
    addMount: function(mount, apps, contentTypes) {
        // if autorun is disabled globally, return
        if (this._settings.get_boolean(SETTING_DISABLE_AUTORUN))
            return;
        // if the mount doesn't want to be autorun, return
        if (!shouldAutorunMount(mount))
            return;
        let setting = this._getAutorunSettingForType(contentTypes[0]);
        // check at the settings for the first content type
        // to see whether we should ask
        if (setting == AutorunSetting.IGNORE)
            return; // return right away
        let success = false;
        let app = null;
        if (setting == AutorunSetting.RUN) {
            app = Gio.app_info_get_default_for_type(contentTypes[0], false);
        } else if (setting == AutorunSetting.FILES) {
            app = Gio.app_info_get_default_for_type('inode/directory', false);
        }
        if (app)
            success = startAppForMount(app, mount);
        // we fallback here also in case the settings did not specify 'ask',
        // but we failed launching the default app or the default file manager
        if (!success)
            this._addSource(mount, apps);
    },
    removeMount: function(mount) {
        let source = this._getSourceForMount(mount);
        
        // if we aren't tracking this mount, don't do anything
        if (!source)
            return;
        // destroy the notification source
        source.destroy();
    }
const AutorunSource = new Lang.Class({
    Name: 'AutorunSource',
    Extends: MessageTray.Source,
    _init: function(manager, mount, apps) {
        this._manager = manager;
        this.mount = mount;
        this.apps = apps;
        this.parent(mount.get_name());
        this._notification = new AutorunNotification(this._manager, this);
        // add ourselves as a source, and popup the notification
        Main.messageTray.add(this);
        this.notify(this._notification);
    },
    getIcon: function() {
        return this.mount.get_icon();
    },
    _createPolicy: function() {
        return new MessageTray.NotificationApplicationPolicy('org.gnome.Nautilus');
    }
const AutorunNotification = new Lang.Class({
    Name: 'AutorunNotification',
    Extends: MessageTray.Notification,
    _init: function(manager, source) {
        this.parent(source, source.title);
        this._manager = manager;
        this._mount = source.mount;
    },
    createBanner: function() {
        let banner = new MessageTray.NotificationBanner(this);
        this.source.apps.forEach(Lang.bind(this, function (app) {
            let actor = this._buttonForApp(app);
            if (actor)
                banner.addButton(actor);
        }));
        return banner;
    },
    _buttonForApp: function(app) {
        let box = new St.BoxLayout();
        let icon = new St.Icon({ gicon: app.get_icon(),
                                 style_class: 'hotplug-notification-item-icon' });
        box.add(icon);
        let label = new St.Bin({ y_align: St.Align.MIDDLE,
                                 child: new St.Label
                                 ({ text: _("Open with %s").format(app.get_name()) })
                               });
        box.add(label);
        let button = new St.Button({ child: box,
                                     x_fill: true,
                                     x_align: St.Align.START,
                                     x_expand: true,
                                     button_mask: St.ButtonMask.ONE,
                                     style_class: 'hotplug-notification-item button' });
        button.connect('clicked', Lang.bind(this, function() {
            startAppForMount(app, this._mount);
            this.destroy();
        }));
        return button;
    },
    activate: function() {
        this.parent();
        let app = Gio.app_info_get_default_for_type('inode/directory', false);
        startAppForMount(app, this._mount);
    }
const Component = AutorunManager;
(uuay)viewSelector.js
// -*- mode: js; js-indent-level: 4; indent-tabs-mode: nil -*-
const Clutter = imports.gi.Clutter;
const Gio = imports.gi.Gio;
const GLib = imports.gi.GLib;
const Gtk = imports.gi.Gtk;
const Mainloop = imports.mainloop;
const Meta = imports.gi.Meta;
const Signals = imports.signals;
const Lang = imports.lang;
const Shell = imports.gi.Shell;
const St = imports.gi.St;
const AppDisplay = imports.ui.appDisplay;
const Main = imports.ui.main;
const OverviewControls = imports.ui.overviewControls;
const Params = imports.misc.params;
const Search = imports.ui.search;
const ShellEntry = imports.ui.shellEntry;
const Tweener = imports.ui.tweener;
const WorkspacesView = imports.ui.workspacesView;
const EdgeDragAction = imports.ui.edgeDragAction;
const IconGrid = imports.ui.iconGrid;
const SHELL_KEYBINDINGS_SCHEMA = 'org.gnome.shell.keybindings';
const ViewPage = {
    WINDOWS: 1,
    APPS: 2,
    SEARCH: 3
const FocusTrap = new Lang.Class({
    Name: 'FocusTrap',
    Extends: St.Widget,
    vfunc_navigate_focus: function(from, direction) {
        if (direction == Gtk.DirectionType.TAB_FORWARD ||
            direction == Gtk.DirectionType.TAB_BACKWARD)
            return this.parent(from, direction);
        return false;
    }
function getTermsForSearchString(searchString) {
    searchString = searchString.replace(/^\s+/g, '').replace(/\s+$/g, '');
    if (searchString == '')
        return [];
    let terms = searchString.split(/\s+/);
    return terms;
const ShowOverviewAction = new Lang.Class({
    Name: 'ShowOverviewAction',
    Extends: Clutter.GestureAction,
    _init : function() {
        this.parent();
        this.set_n_touch_points(3);
        global.display.connect('grab-op-begin', Lang.bind(this, function() {
            this.cancel();
        }));
    },
    vfunc_gesture_prepare : function(action, actor) {
        return Main.actionMode == Shell.ActionMode.NORMAL &&
               this.get_n_current_points() == this.get_n_touch_points();
    },
    _getBoundingRect : function(motion) {
        let minX, minY, maxX, maxY;
        for (let i = 0; i < this.get_n_current_points(); i++) {
            let x, y;
            if (motion == true) {
                [x, y] = this.get_motion_coords(i);
            } else {
                [x, y] = this.get_press_coords(i);
            }
            if (i == 0) {
                minX = maxX = x;
                minY = maxY = y;
            } else {
                minX = Math.min(minX, x);
                minY = Math.min(minY, y);
                maxX = Math.max(maxX, x);
                maxY = Math.max(maxY, y);
            }
        }
        return new Meta.Rectangle({ x: minX,
                                    y: minY,
                                    width: maxX - minX,
                                    height: maxY - minY });
    },
    vfunc_gesture_begin : function(action, actor) {
        this._initialRect = this._getBoundingRect(false);
        return true;
    },
    vfunc_gesture_end : function(action, actor) {
        let rect = this._getBoundingRect(true);
        let oldArea = this._initialRect.width * this._initialRect.height;
        let newArea = rect.width * rect.height;
        let areaDiff = newArea / oldArea;
        this.emit('activated', areaDiff);
    }
Signals.addSignalMethods(ShowOverviewAction.prototype);
const ViewSelector = new Lang.Class({
    Name: 'ViewSelector',
    _init : function(searchEntry, showAppsButton) {
        this.actor = new Shell.Stack({ name: 'viewSelector' });
        this._showAppsButton = showAppsButton;
        this._showAppsButton.connect('notify::checked', Lang.bind(this, this._onShowAppsButtonToggled));
        this._activePage = null;
        this._searchActive = false;
        this._entry = searchEntry;
        ShellEntry.addContextMenu(this._entry);
        this._text = this._entry.clutter_text;
        this._text.connect('text-changed', Lang.bind(this, this._onTextChanged));
        this._text.connect('key-press-event', Lang.bind(this, this._onKeyPress));
        this._text.connect('key-focus-in', Lang.bind(this, function() {
            this._searchResults.highlightDefault(true);
        }));
        this._text.connect('key-focus-out', Lang.bind(this, function() {
            this._searchResults.highlightDefault(false);
        }));
        this._entry.connect('notify::mapped', Lang.bind(this, this._onMapped));
        global.stage.connect('notify::key-focus', Lang.bind(this, this._onStageKeyFocusChanged));
        this._entry.set_primary_icon(new St.Icon({ style_class: 'search-entry-icon',
                                                   icon_name: 'edit-find-symbolic' }));
        this._clearIcon = new St.Icon({ style_class: 'search-entry-icon',
                                        icon_name: 'edit-clear-symbolic' });
        this._iconClickedId = 0;
        this._capturedEventId = 0;
        this._workspacesDisplay = new WorkspacesView.WorkspacesDisplay();
        this._workspacesPage = this._addPage(this._workspacesDisplay.actor,
                                             _("Windows"), 'focus-windows-symbolic');
        this.appDisplay = new AppDisplay.AppDisplay();
        this._appsPage = this._addPage(this.appDisplay.actor,
                                       _("Applications"), 'view-app-grid-symbolic');
        this._searchResults = new Search.SearchResults();
        this._searchPage = this._addPage(this._searchResults.actor,
                                         _("Search"), 'edit-find-symbolic',
                                         { a11yFocus: this._entry });
        // Since the entry isn't inside the results container we install this
        // dummy widget as the last results container child so that we can
        // include the entry in the keynav tab path
        this._focusTrap = new FocusTrap({ can_focus: true });
        this._focusTrap.connect('key-focus-in', Lang.bind(this, function() {
            this._entry.grab_key_focus();
        }));
        this._searchResults.actor.add_actor(this._focusTrap);
        global.focus_manager.add_group(this._searchResults.actor);
        this._stageKeyPressId = 0;
        Main.overview.connect('showing', Lang.bind(this,
            function () {
                this._stageKeyPressId = global.stage.connect('key-press-event',
                                                             Lang.bind(this, this._onStageKeyPress));
            }));
        Main.overview.connect('hiding', Lang.bind(this,
            function () {
                if (this._stageKeyPressId != 0) {
                    global.stage.disconnect(this._stageKeyPressId);
                    this._stageKeyPressId = 0;
                }
            }));
        Main.overview.connect('shown', Lang.bind(this,
            function() {
                // If we were animating from the desktop view to the
                // apps page the workspace page was visible, allowing
                // the windows to animate, but now we no longer want to
                // show it given that we are now on the apps page or
                // search page.
                if (this._activePage != this._workspacesPage) {
                    this._workspacesPage.opacity = 0;
                    this._workspacesPage.hide();
                }
            }));
        Main.wm.addKeybinding('toggle-application-view',
                              new Gio.Settings({ schema_id: SHELL_KEYBINDINGS_SCHEMA }),
                              Meta.KeyBindingFlags.NONE,
                              Shell.ActionMode.NORMAL |
                              Shell.ActionMode.OVERVIEW,
                              Lang.bind(this, this._toggleAppsPage));
        Main.wm.addKeybinding('toggle-overview',
                              new Gio.Settings({ schema_id: SHELL_KEYBINDINGS_SCHEMA }),
                              Meta.KeyBindingFlags.NONE,
                              Shell.ActionMode.NORMAL |
                              Shell.ActionMode.OVERVIEW,
                              Lang.bind(Main.overview, Main.overview.toggle));
        let side;
        if (Clutter.get_default_text_direction() == Clutter.TextDirection.RTL)
            side = St.Side.RIGHT;
        else
            side = St.Side.LEFT;
        let gesture = new EdgeDragAction.EdgeDragAction(side,
                                                        Shell.ActionMode.NORMAL);
        gesture.connect('activated', Lang.bind(this, function() {
            if (Main.overview.visible)
                Main.overview.hide();
            else
                this.showApps();
        }));
        global.stage.add_action(gesture);
        gesture = new ShowOverviewAction();
        gesture.connect('activated', Lang.bind(this, function(action, areaDiff) {
            if (areaDiff < 0.7)
                Main.overview.show();
        }));
        global.stage.add_action(gesture);
    },
    _toggleAppsPage: function() {
        this._showAppsButton.checked = !this._showAppsButton.checked;
        Main.overview.show();
    },
    showApps: function() {
        this._showAppsButton.checked = true;
        Main.overview.show();
    },
    show: function() {
        this.reset();
        this._workspacesDisplay.show(this._showAppsButton.checked);
        this._activePage = null;
        if (this._showAppsButton.checked)
            this._showPage(this._appsPage);
        else
            this._showPage(this._workspacesPage);
        if (!this._workspacesDisplay.activeWorkspaceHasMaximizedWindows())
            Main.overview.fadeOutDesktop();
    },
    animateFromOverview: function() {
        // Make sure workspace page is fully visible to allow
        // workspace.js do the animation of the windows
        this._workspacesPage.opacity = 255;
        this._workspacesDisplay.animateFromOverview(this._activePage != this._workspacesPage);
        this._showAppsButton.checked = false;
        if (!this._workspacesDisplay.activeWorkspaceHasMaximizedWindows())
            Main.overview.fadeInDesktop();
    },
    setWorkspacesFullGeometry: function(geom) {
        this._workspacesDisplay.setWorkspacesFullGeometry(geom);
    },
    hide: function() {
        this._workspacesDisplay.hide();
    },
    _addPage: function(actor, name, a11yIcon, params) {
        params = Params.parse(params, { a11yFocus: null });
        let page = new St.Bin({ child: actor,
                                x_align: St.Align.START,
                                y_align: St.Align.START,
                                x_fill: true,
                                y_fill: true });
        if (params.a11yFocus)
            Main.ctrlAltTabManager.addGroup(params.a11yFocus, name, a11yIcon);
        else
            Main.ctrlAltTabManager.addGroup(actor, name, a11yIcon,
                                            { proxy: this.actor,
                                              focusCallback: Lang.bind(this,
                                                  function() {
                                                      this._a11yFocusPage(page);
                                                  })
                                            });;
        page.hide();
        this.actor.add_actor(page);
        return page;
    },
    _fadePageIn: function() {
        Tweener.addTween(this._activePage,
                         { opacity: 255,
                           time: OverviewControls.SIDE_CONTROLS_ANIMATION_TIME,
                           transition: 'easeOutQuad'
                         });
    },
    _fadePageOut: function(page) {
        let oldPage = page;
        Tweener.addTween(page,
                         { opacity: 0,
                           time: OverviewControls.SIDE_CONTROLS_ANIMATION_TIME,
                           transition: 'easeOutQuad',
                           onComplete: Lang.bind(this, function() {
                               this._animateIn(oldPage);
                           })
                         });
    },
    _animateIn: function(oldPage) {
        if (oldPage)
            oldPage.hide();
        this.emit('page-empty');
        this._activePage.show();
        if (this._activePage == this._appsPage && oldPage == this._workspacesPage) {
            // Restore opacity, in case we animated via _fadePageOut
            this._activePage.opacity = 255;
            this.appDisplay.animate(IconGrid.AnimationDirection.IN);
        } else {
            this._fadePageIn();
        }
    },
    _animateOut: function(page) {
        let oldPage = page;
        if (page == this._appsPage &&
            this._activePage == this._workspacesPage &&
            !Main.overview.animationInProgress) {
            this.appDisplay.animate(IconGrid.AnimationDirection.OUT, Lang.bind(this,
                function() {
                    this._animateIn(oldPage)
                }));
        } else {
            this._fadePageOut(page);
        }
    },
    _showPage: function(page) {
        if (!Main.overview.visible)
            return;
        if (page == this._activePage)
            return;
        let oldPage = this._activePage;
        this._activePage = page;
        this.emit('page-changed');
        if (oldPage)
            this._animateOut(oldPage)
        else
            this._animateIn();
    },
    _a11yFocusPage: function(page) {
        this._showAppsButton.checked = page == this._appsPage;
        page.navigate_focus(null, Gtk.DirectionType.TAB_FORWARD, false);
    },
    _onShowAppsButtonToggled: function() {
        this._showPage(this._showAppsButton.checked ?
                       this._appsPage : this._workspacesPage);
    },
    _onStageKeyPress: function(actor, event) {
        // Ignore events while anything but the overview has
        // pushed a modal (system modals, looking glass, ...)
        if (Main.modalCount > 1)
            return Clutter.EVENT_PROPAGATE;
        let modifiers = event.get_state();
        let symbol = event.get_key_symbol();
        if (symbol == Clutter.Escape) {
            if (this._searchActive)
                this.reset();
            else if (this._showAppsButton.checked)
                this._showAppsButton.checked = false;
            else
                Main.overview.hide();
            return Clutter.EVENT_STOP;
        } else if (this._shouldTriggerSearch(symbol)) {
            this.startSearch(event);
        } else if (!this._searchActive && !global.stage.key_focus) {
            if (symbol == Clutter.Tab || symbol == Clutter.Down) {
                this._activePage.navigate_focus(null, Gtk.DirectionType.TAB_FORWARD, false);
                return Clutter.EVENT_STOP;
            } else if (symbol == Clutter.ISO_Left_Tab) {
                this._activePage.navigate_focus(null, Gtk.DirectionType.TAB_BACKWARD, false);
                return Clutter.EVENT_STOP;
            }
        }
        return Clutter.EVENT_PROPAGATE;
    },
    _searchCancelled: function() {
        this._showPage(this._showAppsButton.checked ? this._appsPage
                                                    : this._workspacesPage);
        // Leave the entry focused when it doesn't have any text;
        // when replacing a selected search term, Clutter emits
        // two 'text-changed' signals, one for deleting the previous
        // text and one for the new one - the second one is handled
        // incorrectly when we remove focus
        // (https://bugzilla.gnome.org/show_bug.cgi?id=636341) */
        if (this._text.text != '')
            this.reset();
    },
    reset: function () {
        global.stage.set_key_focus(null);
        this._entry.text = '';
        this._text.set_cursor_visible(true);
        this._text.set_selection(0, 0);
    },
    _onStageKeyFocusChanged: function() {
        let focus = global.stage.get_key_focus();
        let appearFocused = (this._entry.contains(focus) ||
                             this._searchResults.actor.contains(focus));
        this._text.set_cursor_visible(appearFocused);
        if (appearFocused)
            this._entry.add_style_pseudo_class('focus');
        else
            this._entry.remove_style_pseudo_class('focus');
    },
    _onMapped: function() {
        if (this._entry.mapped) {
            // Enable 'find-as-you-type'
            this._capturedEventId = global.stage.connect('captured-event',
                                 Lang.bind(this, this._onCapturedEvent));
            this._text.set_cursor_visible(true);
            this._text.set_selection(0, 0);
        } else {
            // Disable 'find-as-you-type'
            if (this._capturedEventId > 0)
                global.stage.disconnect(this._capturedEventId);
            this._capturedEventId = 0;
        }
    },
    _shouldTriggerSearch: function(symbol) {
        if (symbol == Clutter.Multi_key)
            return true;
        if (symbol == Clutter.BackSpace && this._searchActive)
            return true;
        let unicode = Clutter.keysym_to_unicode(symbol);
        if (unicode == 0)
            return false;
        if (getTermsForSearchString(String.fromCharCode(unicode)).length > 0)
            return true;
        return false;
    },
    startSearch: function(event) {
        global.stage.set_key_focus(this._text);
        let synthEvent = event.copy();
        synthEvent.set_source(this._text);
        this._text.event(synthEvent, true);
    },
    // the entry does not show the hint
    _isActivated: function() {
        return this._text.text == this._entry.get_text();
    },
    _onTextChanged: function (se, prop) {
        let terms = getTermsForSearchString(this._entry.get_text());
        this._searchActive = (terms.length > 0);
        this._searchResults.setTerms(terms);
        if (this._searchActive) {
            this._showPage(this._searchPage);
            this._entry.set_secondary_icon(this._clearIcon);
            if (this._iconClickedId == 0)
                this._iconClickedId = this._entry.connect('secondary-icon-clicked',
                    Lang.bind(this, this.reset));
        } else {
            if (this._iconClickedId > 0) {
                this._entry.disconnect(this._iconClickedId);
                this._iconClickedId = 0;
            }
            this._entry.set_secondary_icon(null);
            this._searchCancelled();
        }
    },
    _onKeyPress: function(entry, event) {
        let symbol = event.get_key_symbol();
        if (symbol == Clutter.Escape) {
            if (this._isActivated()) {
                this.reset();
                return Clutter.EVENT_STOP;
            }
        } else if (this._searchActive) {
            let arrowNext, nextDirection;
            if (entry.get_text_direction() == Clutter.TextDirection.RTL) {
                arrowNext = Clutter.Left;
                nextDirection = Gtk.DirectionType.LEFT;
            } else {
                arrowNext = Clutter.Right;
                nextDirection = Gtk.DirectionType.RIGHT;
            }
            if (symbol == Clutter.Tab) {
                this._searchResults.navigateFocus(Gtk.DirectionType.TAB_FORWARD);
                return Clutter.EVENT_STOP;
            } else if (symbol == Clutter.ISO_Left_Tab) {
                this._focusTrap.can_focus = false;
                this._searchResults.navigateFocus(Gtk.DirectionType.TAB_BACKWARD);
                this._focusTrap.can_focus = true;
                return Clutter.EVENT_STOP;
            } else if (symbol == Clutter.Down) {
                this._searchResults.navigateFocus(Gtk.DirectionType.DOWN);
                return Clutter.EVENT_STOP;
            } else if (symbol == arrowNext && this._text.position == -1) {
                this._searchResults.navigateFocus(nextDirection);
                return Clutter.EVENT_STOP;
            } else if (symbol == Clutter.Return || symbol == Clutter.KP_Enter) {
                this._searchResults.activateDefault();
                return Clutter.EVENT_STOP;
            }
        }
        return Clutter.EVENT_PROPAGATE;
    },
    _onCapturedEvent: function(actor, event) {
        if (event.type() == Clutter.EventType.BUTTON_PRESS) {
            let source = event.get_source();
            if (source != this._text &&
                this._text.text == '' &&
                !this._text.has_preedit () &&
                !Main.layoutManager.keyboardBox.contains(source)) {
                // the user clicked outside after activating the entry, but
                // with no search term entered and no keyboard button pressed
                // - cancel the search
                this.reset();
            }
        }
        return Clutter.EVENT_PROPAGATE;
    },
    getActivePage: function() {
        if (this._activePage == this._workspacesPage)
            return ViewPage.WINDOWS;
        else if (this._activePage == this._appsPage)
            return ViewPage.APPS;
        else
            return ViewPage.SEARCH;
    },
    fadeIn: function() {
        let actor = this._activePage;
        Tweener.addTween(actor, { opacity: 255,
                                  time: OverviewControls.SIDE_CONTROLS_ANIMATION_TIME / 2,
                                  transition: 'easeInQuad'
                                });
    },
    fadeHalf: function() {
        let actor = this._activePage;
        Tweener.addTween(actor, { opacity: 128,
                                  time: OverviewControls.SIDE_CONTROLS_ANIMATION_TIME / 2,
                                  transition: 'easeOutQuad'
                                });
    }
Signals.addSignalMethods(ViewSelector.prototype);
(uuay)remoteSearch.js
// -*- mode: js; js-indent-level: 4; indent-tabs-mode: nil -*-
const GdkPixbuf = imports.gi.GdkPixbuf;
const Gio = imports.gi.Gio;
const GLib = imports.gi.GLib;
const Lang = imports.lang;
const St = imports.gi.St;
const Shell = imports.gi.Shell;
const FileUtils = imports.misc.fileUtils;
const Search = imports.ui.search;
const KEY_FILE_GROUP = 'Shell Search Provider';
const SearchProviderIface = '<node> \
<interface name="org.gnome.Shell.SearchProvider"> \
<method name="GetInitialResultSet"> \
    <arg type="as" direction="in" /> \
    <arg type="as" direction="out" /> \
</method> \
<method name="GetSubsearchResultSet"> \
    <arg type="as" direction="in" /> \
    <arg type="as" direction="in" /> \
    <arg type="as" direction="out" /> \
</method> \
<method name="GetResultMetas"> \
    <arg type="as" direction="in" /> \
    <arg type="aa{sv}" direction="out" /> \
</method> \
<method name="ActivateResult"> \
    <arg type="s" direction="in" /> \
</method> \
</interface> \
</node>';
const SearchProvider2Iface = '<node> \
<interface name="org.gnome.Shell.SearchProvider2"> \
<method name="GetInitialResultSet"> \
    <arg type="as" direction="in" /> \
    <arg type="as" direction="out" /> \
</method> \
<method name="GetSubsearchResultSet"> \
    <arg type="as" direction="in" /> \
    <arg type="as" direction="in" /> \
    <arg type="as" direction="out" /> \
</method> \
<method name="GetResultMetas"> \
    <arg type="as" direction="in" /> \
    <arg type="aa{sv}" direction="out" /> \
</method> \
<method name="ActivateResult"> \
    <arg type="s" direction="in" /> \
    <arg type="as" direction="in" /> \
    <arg type="u" direction="in" /> \
</method> \
<method name="LaunchSearch"> \
    <arg type="as" direction="in" /> \
    <arg type="u" direction="in" /> \
</method> \
</interface> \
</node>';
var SearchProviderProxyInfo = Gio.DBusInterfaceInfo.new_for_xml(SearchProviderIface);
var SearchProvider2ProxyInfo = Gio.DBusInterfaceInfo.new_for_xml(SearchProvider2Iface);
function loadRemoteSearchProviders(searchSettings, callback) {
    let objectPaths = {};
    let loadedProviders = [];
    function loadRemoteSearchProvider(file) {
        let keyfile = new GLib.KeyFile();
        let path = file.get_path();
        try {
            keyfile.load_from_file(path, 0);
        } catch(e) {
            return;
        }
        if (!keyfile.has_group(KEY_FILE_GROUP))
            return;
        let remoteProvider;
        try {
            let group = KEY_FILE_GROUP;
            let busName = keyfile.get_string(group, 'BusName');
            let objectPath = keyfile.get_string(group, 'ObjectPath');
            if (objectPaths[objectPath])
                return;
            let appInfo = null;
            try {
                let desktopId = keyfile.get_string(group, 'DesktopId');
                appInfo = Gio.DesktopAppInfo.new(desktopId);
            } catch (e) {
                log('Ignoring search provider ' + path + ': missing DesktopId');
                return;
            }
            let version = '1';
            try {
                version = keyfile.get_string(group, 'Version');
            } catch (e) {
                // ignore error
            }
            if (version >= 2)
                remoteProvider = new RemoteSearchProvider2(appInfo, busName, objectPath);
            else
                remoteProvider = new RemoteSearchProvider(appInfo, busName, objectPath);
            remoteProvider.defaultEnabled = true;
            try {
                remoteProvider.defaultEnabled = !keyfile.get_boolean(group, 'DefaultDisabled');
            } catch(e) {
                // ignore error
            }
            objectPaths[objectPath] = remoteProvider;
            loadedProviders.push(remoteProvider);
        } catch(e) {
            log('Failed to add search provider %s: %s'.format(path, e.toString()));
        }
    }
    if (searchSettings.get_boolean('disable-external')) {
        callback([]);
        return;
    }
    FileUtils.collectFromDatadirs('search-providers', false, loadRemoteSearchProvider);
    let sortOrder = searchSettings.get_strv('sort-order');
    // Special case gnome-control-center to be always active and always first
    sortOrder.unshift('gnome-control-center.desktop');
    loadedProviders = loadedProviders.filter(function(provider) {
        let appId = provider.appInfo.get_id();
        if (provider.defaultEnabled) {
            let disabled = searchSettings.get_strv('disabled');
            return disabled.indexOf(appId) == -1;
        } else {
            let enabled = searchSettings.get_strv('enabled');
            return enabled.indexOf(appId) != -1;
        }
    });
    loadedProviders.sort(function(providerA, providerB) {
        let idxA, idxB;
        let appIdA, appIdB;
        appIdA = providerA.appInfo.get_id();
        appIdB = providerB.appInfo.get_id();
        idxA = sortOrder.indexOf(appIdA);
        idxB = sortOrder.indexOf(appIdB);
        // if no provider is found in the order, use alphabetical order
        if ((idxA == -1) && (idxB == -1)) {
            let nameA = providerA.appInfo.get_name();
            let nameB = providerB.appInfo.get_name();
            return GLib.utf8_collate(nameA, nameB);
        }
        // if providerA isn't found, it's sorted after providerB
        if (idxA == -1)
            return 1;
        // if providerB isn't found, it's sorted after providerA
        if (idxB == -1)
            return -1;
        // finally, if both providers are found, return their order in the list
        return (idxA - idxB);
    });
    callback(loadedProviders);
const RemoteSearchProvider = new Lang.Class({
    Name: 'RemoteSearchProvider',
    _init: function(appInfo, dbusName, dbusPath, proxyInfo) {
        if (!proxyInfo)
            proxyInfo = SearchProviderProxyInfo;
        this.proxy = new Gio.DBusProxy({ g_bus_type: Gio.BusType.SESSION,
                                         g_name: dbusName,
                                         g_object_path: dbusPath,
                                         g_interface_info: proxyInfo,
                                         g_interface_name: proxyInfo.name,
                                         g_flags: (Gio.DBusProxyFlags.DO_NOT_AUTO_START_AT_CONSTRUCTION |
                                                   Gio.DBusProxyFlags.DO_NOT_LOAD_PROPERTIES) });
        this.proxy.init_async(GLib.PRIORITY_DEFAULT, null, null);
        this.appInfo = appInfo;
        this.id = appInfo.get_id();
        this.isRemoteProvider = true;
    },
    createIcon: function(size, meta) {
        let gicon = null;
        let icon = null;
        if (meta['icon']) {
            gicon = Gio.icon_deserialize(meta['icon']);
        } else if (meta['gicon']) {
            gicon = Gio.icon_new_for_string(meta['gicon']);
        } else if (meta['icon-data']) {
            let [width, height, rowStride, hasAlpha,
                 bitsPerSample, nChannels, data] = meta['icon-data'];
            gicon = Shell.util_create_pixbuf_from_data(data, GdkPixbuf.Colorspace.RGB, hasAlpha,
                                                       bitsPerSample, width, height, rowStride);
        }
        if (gicon)
            icon = new St.Icon({ gicon: gicon,
                                 icon_size: size });
        return icon;
    },
    filterResults: function(results, maxNumber) {
        if (results.length <= maxNumber)
            return results;
        let regularResults = results.filter(function(r) { return !r.startsWith('special:'); });
        let specialResults = results.filter(function(r) { return r.startsWith('special:'); });
        return regularResults.slice(0, maxNumber).concat(specialResults.slice(0, maxNumber));
    },
    _getResultsFinished: function(results, error, callback) {
        if (error) {
            if (error.matches(Gio.IOErrorEnum, Gio.IOErrorEnum.CANCELLED))
                return;
            log('Received error from DBus search provider %s: %s'.format(this.id, String(error)));
            callback([]);
            return;
        }
        callback(results[0]);
    },
    getInitialResultSet: function(terms, callback, cancellable) {
        this.proxy.GetInitialResultSetRemote(terms,
                                             Lang.bind(this, this._getResultsFinished, callback),
                                             cancellable);
    },
    getSubsearchResultSet: function(previousResults, newTerms, callback, cancellable) {
        this.proxy.GetSubsearchResultSetRemote(previousResults, newTerms,
                                               Lang.bind(this, this._getResultsFinished, callback),
                                               cancellable);
    },
    _getResultMetasFinished: function(results, error, callback) {
        if (error) {
            if (!error.matches(Gio.IOErrorEnum, Gio.IOErrorEnum.CANCELLED))
                log('Received error from DBus search provider %s during GetResultMetas: %s'.format(this.id, String(error)));
            callback([]);
            return;
        }
        let metas = results[0];
        let resultMetas = [];
        for (let i = 0; i < metas.length; i++) {
            for (let prop in metas[i]) {
                // we can use the serialized icon variant directly
                if (prop != 'icon')
                    metas[i][prop] = metas[i][prop].deep_unpack();
            }
            resultMetas.push({ id: metas[i]['id'],
                               name: metas[i]['name'],
                               description: metas[i]['description'],
                               createIcon: Lang.bind(this,
                                                     this.createIcon, metas[i]) });
        }
        callback(resultMetas);
    },
    getResultMetas: function(ids, callback, cancellable) {
        this.proxy.GetResultMetasRemote(ids,
                                        Lang.bind(this, this._getResultMetasFinished, callback),
                                        cancellable);
    },
    activateResult: function(id) {
        this.proxy.ActivateResultRemote(id);
    },
    launchSearch: function(terms) {
        // the provider is not compatible with the new version of the interface, launch
        // the app itself but warn so we can catch the error in logs
        log('Search provider ' + this.appInfo.get_id() + ' does not implement LaunchSearch');
        this.appInfo.launch([], global.create_app_launch_context(0, -1));
    }
const RemoteSearchProvider2 = new Lang.Class({
    Name: 'RemoteSearchProvider2',
    Extends: RemoteSearchProvider,
    _init: function(appInfo, dbusName, dbusPath) {
        this.parent(appInfo, dbusName, dbusPath, SearchProvider2ProxyInfo);
        this.canLaunchSearch = true;
    },
    activateResult: function(id, terms) {
        this.proxy.ActivateResultRemote(id, terms, global.get_current_time());
    },
    launchSearch: function(terms) {
        this.proxy.LaunchSearchRemote(terms, global.get_current_time());
    }
(uuay)objectManager.js
// -*- mode: js; js-indent-level: 4; indent-tabs-mode: nil -*-
const Gio = imports.gi.Gio;
const GLib = imports.gi.GLib;
const Lang = imports.lang;
const Params = imports.misc.params;
const Signals = imports.signals;
// Specified in the D-Bus specification here:
// http://dbus.freedesktop.org/doc/dbus-specification.html#standard-interfaces-objectmanager
const ObjectManagerIface = '<node> \
<interface name="org.freedesktop.DBus.ObjectManager"> \
  <method name="GetManagedObjects"> \
    <arg name="objects" type="a{oa{sa{sv}}}" direction="out"/> \
  </method> \
  <signal name="InterfacesAdded"> \
    <arg name="objectPath" type="o"/> \
    <arg name="interfaces" type="a{sa{sv}}" /> \
  </signal> \
  <signal name="InterfacesRemoved"> \
    <arg name="objectPath" type="o"/> \
    <arg name="interfaces" type="as" /> \
  </signal> \
</interface> \
</node>';
const ObjectManagerInfo = Gio.DBusInterfaceInfo.new_for_xml(ObjectManagerIface);
const ObjectManager = new Lang.Class({
    Name: 'ObjectManager',
    _init: function(params) {
        params = Params.parse(params, { connection: null,
                                        name: null,
                                        objectPath: null,
                                        knownInterfaces: null,
                                        cancellable: null,
                                        onLoaded: null });
        this._connection = params.connection;
        this._serviceName = params.name;
        this._managerPath = params.objectPath;
        this._cancellable = params.cancellable;
        this._managerProxy = new Gio.DBusProxy({ g_connection: this._connection,
                                                 g_interface_name: ObjectManagerInfo.name,
                                                 g_interface_info: ObjectManagerInfo,
                                                 g_name: this._serviceName,
                                                 g_object_path: this._managerPath,
                                                 g_flags: Gio.DBusProxyFlags.NONE });
        this._interfaceInfos = {};
        this._objects = {};
        this._interfaces = {};
        this._onLoaded = params.onLoaded;
        if (params.knownInterfaces)
            this._registerInterfaces(params.knownInterfaces);
        // Start out inhibiting load until at least the proxy
        // manager is loaded and the remote objects are fetched
        this._numLoadInhibitors = 1;
        this._managerProxy.init_async(GLib.PRIORITY_DEFAULT,
                                      this._cancellable,
                                      Lang.bind(this, this._onManagerProxyLoaded));
    },
    _tryToCompleteLoad: function() {
        this._numLoadInhibitors--;
        if (this._numLoadInhibitors == 0) {
            if (this._onLoaded)
                this._onLoaded();
        }
    },
    _addInterface: function(objectPath, interfaceName, onFinished) {
        let info = this._interfaceInfos[interfaceName];
        if (!info) {
           if (onFinished)
               onFinished();
           return;
        }
        let proxy = new Gio.DBusProxy({ g_connection: this._connection,
                                       g_name: this._serviceName,
                                       g_object_path: objectPath,
                                       g_interface_name: interfaceName,
                                       g_interface_info: info,
                                       g_flags: Gio.DBusProxyFlags.NONE });
        proxy.init_async(GLib.PRIORITY_DEFAULT,
                         this._cancellable,
                         Lang.bind(this, function(initable, result) {
               let error = null;
               try {
                   initable.init_finish(result);
               } catch(e) {
                   logError(e, 'could not initialize proxy for interface ' + interfaceName);
                   if (onFinished)
                       onFinished();
                   return;
               }
               let isNewObject;
               if (!this._objects[objectPath]) {
                   this._objects[objectPath] = {};
                   isNewObject = true;
               } else {
                   isNewObject = false;
               }
               this._objects[objectPath][interfaceName] = proxy;
               if (!this._interfaces[interfaceName])
                   this._interfaces[interfaceName] = [];
               this._interfaces[interfaceName].push(proxy);
               if (isNewObject)
                   this.emit('object-added', objectPath);
               this.emit('interface-added', interfaceName, proxy);
               if (onFinished)
                   onFinished();
        }));
    },
    _removeInterface: function(objectPath, interfaceName) {
        if (!this._objects[objectPath])
            return;
        let proxy = this._objects[objectPath][interfaceName];
        if (this._interfaces[interfaceName]) {
            let index = this._interfaces[interfaceName].indexOf(proxy);
            if (index >= 0)
                this._interfaces[interfaceName].splice(index, 1);
            if (this._interfaces[interfaceName].length == 0)
                delete this._interfaces[interfaceName];
        }
        this.emit('interface-removed', interfaceName, proxy);
        this._objects[objectPath][interfaceName] = null;
        if (Object.keys(this._objects[objectPath]).length == 0) {
            delete this._objects[objectPath];
            this.emit('object-removed', objectPath);
        }
    },
    _onManagerProxyLoaded: function(initable, result) {
        let error = null;
        try {
            initable.init_finish(result);
        } catch(e) {
            logError(e, 'could not initialize object manager for object ' + params.name);
            this._tryToCompleteLoad();
            return;
        }
        this._managerProxy.connectSignal('InterfacesAdded',
                                         Lang.bind(this, function(objectManager, sender, [objectPath, interfaces]) {
                                             let interfaceNames = Object.keys(interfaces);
                                             for (let i = 0; i < interfaceNames.length; i++)
                                                 this._addInterface(objectPath, interfaceNames[i]);
                                         }));
        this._managerProxy.connectSignal('InterfacesRemoved',
                                         Lang.bind(this, function(objectManager, sender, [objectPath, interfaceNames]) {
                                             for (let i = 0; i < interfaceNames.length; i++)
                                                 this._removeInterface(objectPath, interfaceNames[i]);
                                         }));
        if (Object.keys(this._interfaceInfos).length == 0) {
            this._tryToCompleteLoad();
            return;
        }
        this._managerProxy.GetManagedObjectsRemote(Lang.bind(this, function(result, error) {
            if (!result) {
                if (error) {
                   logError(error, 'could not get remote objects for service ' + this._serviceName + ' path ' + this._managerPath);
                }
                this._tryToCompleteLoad();
                return;
            }
            let [objects] = result;
            let objectPaths = Object.keys(objects);
            for (let i = 0; i < objectPaths.length; i++) {
                let objectPath = objectPaths[i];
                let object = objects[objectPath];
                let interfaceNames = Object.getOwnPropertyNames(object);
                for (let j = 0; j < interfaceNames.length; j++) {
                    let interfaceName = interfaceNames[j];
                    // Prevent load from completing until the interface is loaded
                    this._numLoadInhibitors++;
                    this._addInterface(objectPath,
                                       interfaceName,
                                       Lang.bind(this, this._tryToCompleteLoad));
                }
            }
            this._tryToCompleteLoad();
        }));
    },
    _registerInterfaces: function(interfaces) {
        for (let i = 0; i < interfaces.length; i++) {
            let info = Gio.DBusInterfaceInfo.new_for_xml(interfaces[i]);
            this._interfaceInfos[info.name] = info;
        }
    },
    getProxy: function(objectPath, interfaceName) {
        let object = this._objects[objectPath];
        if (!object)
            return null;
        return object[interfaceName];
    },
    getProxiesForInterface: function(interfaceName) {
        let proxyList = this._interfaces[interfaceName];
        if (!proxyList)
            return [];
        return proxyList;
    },
    getAllProxies: function() {
        let proxies = [];
        let objectPaths = Object.keys(this._objects);
        for (let i = 0; i < objectPaths.length; i++) {
            let object = this._objects[objectPaths];
            let interfaceNames = Object.keys(object);
            for (let j = 0; i < interfaceNames.length; i++) {
                let interfaceName = interfaceNames[i];
                if (object[interfaceName])
                    proxies.push(object(interfaceName));
            }
        }
        return proxies;
    }
Signals.addSignalMethods(ObjectManager.prototype);
(uuay)perf/}
screenShield.js
// -*- mode: js; js-indent-level: 4; indent-tabs-mode: nil -*-
const AccountsService = imports.gi.AccountsService;
const Cairo = imports.cairo;
const Clutter = imports.gi.Clutter;
const Gio = imports.gi.Gio;
const GLib = imports.gi.GLib;
const GnomeDesktop = imports.gi.GnomeDesktop;
const Gtk = imports.gi.Gtk;
const Lang = imports.lang;
const Mainloop = imports.mainloop;
const Meta = imports.gi.Meta;
const Shell = imports.gi.Shell;
const Signals = imports.signals;
const St = imports.gi.St;
const TweenerEquations = imports.tweener.equations;
const Background = imports.ui.background;
const GnomeSession = imports.misc.gnomeSession;
const Layout = imports.ui.layout;
const OVirt = imports.gdm.oVirt;
const LoginManager = imports.misc.loginManager;
const Lightbox = imports.ui.lightbox;
const Main = imports.ui.main;
const Overview = imports.ui.overview;
const MessageTray = imports.ui.messageTray;
const ShellDBus = imports.ui.shellDBus;
const SmartcardManager = imports.misc.smartcardManager;
const Tweener = imports.ui.tweener;
const Util = imports.misc.util;
const SCREENSAVER_SCHEMA = 'org.gnome.desktop.screensaver';
const LOCK_ENABLED_KEY = 'lock-enabled';
const LOCK_DELAY_KEY = 'lock-delay';
const LOCKED_STATE_STR = 'screenShield.locked';
// fraction of screen height the arrow must reach before completing
// the slide up automatically
const ARROW_DRAG_THRESHOLD = 0.1;
// Parameters for the arrow animation
const N_ARROWS = 3;
const ARROW_ANIMATION_TIME = 0.6;
const ARROW_ANIMATION_PEAK_OPACITY = 0.4;
const ARROW_IDLE_TIME = 30000; // ms
const SUMMARY_ICON_SIZE = 48;
// ScreenShield animation time
// - STANDARD_FADE_TIME is used when the session goes idle
// - MANUAL_FADE_TIME is used for lowering the shield when asked by the user,
//   or when cancelling the dialog
// - BACKGROUND_FADE_TIME is used when the background changes to crossfade to new background
// - CURTAIN_SLIDE_TIME is used when raising the shield before unlocking
const STANDARD_FADE_TIME = 10;
const MANUAL_FADE_TIME = 0.3;
const BACKGROUND_FADE_TIME = 1.0;
const CURTAIN_SLIDE_TIME = 0.3;
const Clock = new Lang.Class({
    Name: 'ScreenShieldClock',
    _init: function() {
        this.actor = new St.BoxLayout({ style_class: 'screen-shield-clock',
                                        vertical: true });
        this._time = new St.Label({ style_class: 'screen-shield-clock-time' });
        this._date = new St.Label({ style_class: 'screen-shield-clock-date' });
        this.actor.add(this._time, { x_align: St.Align.MIDDLE });
        this.actor.add(this._date, { x_align: St.Align.MIDDLE });
        this._wallClock = new GnomeDesktop.WallClock({ time_only: true });
        this._wallClock.connect('notify::clock', Lang.bind(this, this._updateClock));
        this._updateClock();
    },
    _updateClock: function() {
        this._time.text = this._wallClock.clock;
        let date = new Date();
        /* Translators: This is a time format for a date in
           long format */
        let dateFormat = Shell.util_translate_time_string(N_("%A, %B %d"));
        this._date.text = date.toLocaleFormat(dateFormat);
    },
    destroy: function() {
        this.actor.destroy();
        this._wallClock.run_dispose();
    }
const NotificationsBox = new Lang.Class({
    Name: 'NotificationsBox',
    _init: function() {
        this.actor = new St.BoxLayout({ vertical: true,
                                        name: 'screenShieldNotifications',
                                        style_class: 'screen-shield-notifications-container' });
        this._scrollView = new St.ScrollView({ x_fill: false, x_align: St.Align.START,
                                               hscrollbar_policy: Gtk.PolicyType.NEVER });
        this._notificationBox = new St.BoxLayout({ vertical: true,
                                                   style_class: 'screen-shield-notifications-container' });
        this._scrollView.add_actor(this._notificationBox);
        this.actor.add(this._scrollView, { x_fill: true, x_align: St.Align.START });
        this._sources = new Map();
        Main.messageTray.getSources().forEach(Lang.bind(this, function(source) {
            this._sourceAdded(Main.messageTray, source, true);
        }));
        this._updateVisibility();
        this._sourceAddedId = Main.messageTray.connect('source-added', Lang.bind(this, this._sourceAdded));
    },
    destroy: function() {
        if (this._sourceAddedId) {
            Main.messageTray.disconnect(this._sourceAddedId);
            this._sourceAddedId = 0;
        }
        let items = this._sources.entries();
        for (let [source, obj] of items) {
            this._removeSource(source, obj);
        }
        this.actor.destroy();
    },
    _updateVisibility: function() {
        this._notificationBox.visible = this._notificationBox.get_children().some(function(a) {
            return a.visible;
        });
        this.actor.visible = this._notificationBox.visible;
    },
    _makeNotificationCountText: function(count, isChat) {
        if (isChat)
            return ngettext("%d new message", "%d new messages", count).format(count);
        else
            return ngettext("%d new notification", "%d new notifications", count).format(count);
    },
    _makeNotificationSource: function(source, box) {
        let sourceActor = new MessageTray.SourceActor(source, SUMMARY_ICON_SIZE);
        box.add(sourceActor.actor, { y_fill: true });
        let textBox = new St.BoxLayout({ vertical: true });
        box.add(textBox, { y_fill: false, y_align: St.Align.START });
        let title = new St.Label({ text: source.title,
                                   style_class: 'screen-shield-notification-label' });
        textBox.add(title);
        let count = source.unseenCount;
        let countLabel = new St.Label({ text: this._makeNotificationCountText(count, source.isChat),
                                        style_class: 'screen-shield-notification-count-text' });
        textBox.add(countLabel);
        box.visible = count != 0;
        return [title, countLabel];
    },
    _makeNotificationDetailedSource: function(source, box) {
        let sourceActor = new MessageTray.SourceActor(source, SUMMARY_ICON_SIZE);
        let sourceBin = new St.Bin({ y_align: St.Align.START,
                                     x_align: St.Align.START,
                                     child: sourceActor.actor });
        box.add(sourceBin);
        let textBox = new St.BoxLayout({ vertical: true });
        box.add(textBox, { y_fill: false, y_align: St.Align.START });
        let title = new St.Label({ text: source.title,
                                   style_class: 'screen-shield-notification-label' });
        textBox.add(title);
        let visible = false;
        for (let i = 0; i < source.notifications.length; i++) {
            let n = source.notifications[i];
            if (n.acknowledged)
                continue;
            let body = '';
            if (n.bannerBodyText) {
                body = n.bannerBodyMarkup ? n.bannerBodyText
                                          : GLib.markup_escape_text(n.bannerBodyText, -1);
            }
            let label = new St.Label({ style_class: 'screen-shield-notification-count-text' });
            label.clutter_text.set_markup('<b>' + n.title + '</b> ' + body);
            textBox.add(label);
            visible = true;
        }
        box.visible = visible;
        return [title, null];
    },
    _showSource: function(source, obj, box) {
        if (obj.detailed) {
            [obj.titleLabel, obj.countLabel] = this._makeNotificationDetailedSource(source, box);
        } else {
            [obj.titleLabel, obj.countLabel] = this._makeNotificationSource(source, box);
        }
        box.visible = obj.visible && (source.unseenCount > 0);
    },
    _sourceAdded: function(tray, source, initial) {
        let obj = {
            visible: source.policy.showInLockScreen,
            detailed: source.policy.detailsInLockScreen,
            sourceDestroyId: 0,
            sourceCountChangedId: 0,
            sourceTitleChangedId: 0,
            sourceUpdatedId: 0,
            sourceBox: null,
            titleLabel: null,
            countLabel: null,
        };
        obj.sourceBox = new St.BoxLayout({ style_class: 'screen-shield-notification-source',
                                           x_expand: true });
        this._showSource(source, obj, obj.sourceBox);
        this._notificationBox.add(obj.sourceBox, { x_fill: false, x_align: St.Align.START });
        obj.sourceCountChangedId = source.connect('count-updated', Lang.bind(this, function(source) {
            this._countChanged(source, obj);
        }));
        obj.sourceTitleChangedId = source.connect('title-changed', Lang.bind(this, function(source) {
            this._titleChanged(source, obj);
        }));
        obj.policyChangedId = source.policy.connect('policy-changed', Lang.bind(this, function(policy, key) {
            if (key == 'show-in-lock-screen')
                this._visibleChanged(source, obj);
            else
                this._detailedChanged(source, obj);
        }));
        obj.sourceDestroyId = source.connect('destroy', Lang.bind(this, function(source) {
            this._onSourceDestroy(source, obj);
        }));
        this._sources.set(source, obj);
        if (!initial) {
            // block scrollbars while animating, if they're not needed now
            let boxHeight = this._notificationBox.height;
            if (this._scrollView.height >= boxHeight)
                this._scrollView.vscrollbar_policy = Gtk.PolicyType.NEVER;
            let widget = obj.sourceBox;
            let [, natHeight] = widget.get_preferred_height(-1);
            widget.height = 0;
            Tweener.addTween(widget,
                             { height: natHeight,
                               transition: 'easeOutQuad',
                               time: 0.25,
                               onComplete: function() {
                                   this._scrollView.vscrollbar_policy = Gtk.PolicyType.AUTOMATIC;
                                   widget.set_height(-1);
                               },
                               onCompleteScope: this
                             });
            this._updateVisibility();
            if (obj.sourceBox.visible)
                this.emit('wake-up-screen');
        }
    },
    _titleChanged: function(source, obj) {
        obj.titleLabel.text = source.title;
    },
    _countChanged: function(source, obj) {
        if (obj.detailed) {
            // A new notification was pushed, or a previous notification was destroyed.
            // Give up, and build the list again.
            obj.sourceBox.destroy_all_children();
            obj.titleLabel = obj.countLabel = null;
            this._showSource(source, obj, obj.sourceBox);
        } else {
            let count = source.unseenCount;
            obj.countLabel.text = this._makeNotificationCountText(count, source.isChat);
        }
        obj.sourceBox.visible = obj.visible && (source.unseenCount > 0);
        this._updateVisibility();
        if (obj.sourceBox.visible)
            this.emit('wake-up-screen');
    },
    _visibleChanged: function(source, obj) {
        if (obj.visible == source.policy.showInLockScreen)
            return;
        obj.visible = source.policy.showInLockScreen;
        obj.sourceBox.visible = obj.visible && source.unseenCount > 0;
        this._updateVisibility();
        if (obj.sourceBox.visible)
            this.emit('wake-up-screen');
    },
    _detailedChanged: function(source, obj) {
        if (obj.detailed == source.policy.detailsInLockScreen)
            return;
        obj.detailed = source.policy.detailsInLockScreen;
        obj.sourceBox.destroy_all_children();
        obj.titleLabel = obj.countLabel = null;
        this._showSource(source, obj, obj.sourceBox);
    },
    _onSourceDestroy: function(source, obj) {
        this._removeSource(source, obj);
        this._updateVisibility();
    },
    _removeSource: function(source, obj) {
        obj.sourceBox.destroy();
        obj.sourceBox = obj.titleLabel = obj.countLabel = null;
        source.disconnect(obj.sourceDestroyId);
        source.disconnect(obj.sourceCountChangedId);
        source.disconnect(obj.sourceTitleChangedId);
        source.policy.disconnect(obj.policyChangedId);
        this._sources.delete(source);
    },
Signals.addSignalMethods(NotificationsBox.prototype);
const Arrow = new Lang.Class({
    Name: 'Arrow',
    Extends: St.Bin,
    _init: function(params) {
        this.parent(params);
        this.x_fill = this.y_fill = true;
        this._drawingArea = new St.DrawingArea();
        this._drawingArea.connect('repaint', Lang.bind(this, this._drawArrow));
        this.child = this._drawingArea;
        this._shadowHelper = null;
        this._shadowWidth = this._shadowHeight = 0;
    },
    _drawArrow: function(arrow) {
        let cr = arrow.get_context();
        let [w, h] = arrow.get_surface_size();
        let node = this.get_theme_node();
        let thickness = node.get_length('-arrow-thickness');
        Clutter.cairo_set_source_color(cr, node.get_foreground_color());
        cr.setLineCap(Cairo.LineCap.ROUND);
        cr.setLineWidth(thickness);
        cr.moveTo(thickness / 2, h - thickness / 2);
        cr.lineTo(w/2, thickness);
        cr.lineTo(w - thickness / 2, h - thickness / 2);
        cr.stroke();
        cr.$dispose();
    },
    vfunc_get_paint_volume: function(volume) {
        if (!this.parent(volume))
            return false;
        if (!this._shadow)
            return true;
        let shadow_box = new Clutter.ActorBox();
        this._shadow.get_box(this._drawingArea.get_allocation_box(), shadow_box);
        volume.set_width(Math.max(shadow_box.x2 - shadow_box.x1, volume.get_width()));
        volume.set_height(Math.max(shadow_box.y2 - shadow_box.y1, volume.get_height()));
        return true;
    },
    vfunc_style_changed: function() {
        let node = this.get_theme_node();
        this._shadow = node.get_shadow('-arrow-shadow');
        if (this._shadow)
            this._shadowHelper = St.ShadowHelper.new(this._shadow);
        else
            this._shadowHelper = null;
        this.parent();
    },
    vfunc_paint: function() {
        if (this._shadowHelper) {
            this._shadowHelper.update(this._drawingArea);
            let allocation = this._drawingArea.get_allocation_box();
            let paintOpacity = this._drawingArea.get_paint_opacity();
            this._shadowHelper.paint(allocation, paintOpacity);
        }
        this._drawingArea.paint();
    }
function clamp(value, min, max) {
    return Math.max(min, Math.min(max, value));
 * If you are setting org.gnome.desktop.session.idle-delay directly in dconf,
 * rather than through System Settings, you also need to set
 * org.gnome.settings-daemon.plugins.power.sleep-display-ac and
 * org.gnome.settings-daemon.plugins.power.sleep-display-battery to the same value.
 * This will ensure that the screen blanks at the right time when it fades out.
 * https://bugzilla.gnome.org/show_bug.cgi?id=668703 explains the dependency.
const ScreenShield = new Lang.Class({
    Name: 'ScreenShield',
    _init: function() {
        this.actor = Main.layoutManager.screenShieldGroup;
        this._lockScreenState = MessageTray.State.HIDDEN;
        this._lockScreenGroup = new St.Widget({ x_expand: true,
                                                y_expand: true,
                                                reactive: true,
                                                can_focus: true,
                                                name: 'lockScreenGroup',
                                                visible: false,
                                              });
        this._lockScreenGroup.connect('key-press-event',
                                      Lang.bind(this, this._onLockScreenKeyPress));
        this._lockScreenGroup.connect('scroll-event',
                                      Lang.bind(this, this._onLockScreenScroll));
        Main.ctrlAltTabManager.addGroup(this._lockScreenGroup, _("Lock"), 'changes-prevent-symbolic');
        this._lockScreenContents = new St.Widget({ layout_manager: new Clutter.BinLayout(),
                                                   name: 'lockScreenContents' });
        this._lockScreenContents.add_constraint(new Layout.MonitorConstraint({ primary: true }));
        this._lockScreenGroup.add_actor(this._lockScreenContents);
        this._backgroundGroup = new Clutter.Actor();
        this._lockScreenGroup.add_actor(this._backgroundGroup);
        this._backgroundGroup.lower_bottom();
        this._bgManagers = [];
        this._updateBackgrounds();
        Main.layoutManager.connect('monitors-changed', Lang.bind(this, this._updateBackgrounds));
        this._arrowAnimationId = 0;
        this._arrowWatchId = 0;
        this._arrowActiveWatchId = 0;
        this._arrowContainer = new St.BoxLayout({ style_class: 'screen-shield-arrows',
                                                  vertical: true,
                                                  x_align: Clutter.ActorAlign.CENTER,
                                                  y_align: Clutter.ActorAlign.END,
                                                  // HACK: without these, ClutterBinLayout
                                                  // ignores alignment properties on the actor
                                                  x_expand: true,
                                                  y_expand: true });
        for (let i = 0; i < N_ARROWS; i++) {
            let arrow = new Arrow({ opacity: 0 });
            this._arrowContainer.add_actor(arrow);
        }
        this._lockScreenContents.add_actor(this._arrowContainer);
        this._dragAction = new Clutter.GestureAction();
        this._dragAction.connect('gesture-begin', Lang.bind(this, this._onDragBegin));
        this._dragAction.connect('gesture-progress', Lang.bind(this, this._onDragMotion));
        this._dragAction.connect('gesture-end', Lang.bind(this, this._onDragEnd));
        this._lockScreenGroup.add_action(this._dragAction);
        this._lockDialogGroup = new St.Widget({ x_expand: true,
                                                y_expand: true,
                                                reactive: true,
                                                pivot_point: new Clutter.Point({ x: 0.5, y: 0.5 }),
                                                name: 'lockDialogGroup' });
        this.actor.add_actor(this._lockDialogGroup);
        this.actor.add_actor(this._lockScreenGroup);
        this._presence = new GnomeSession.Presence(Lang.bind(this, function(proxy, error) {
            if (error) {
                logError(error, 'Error while reading gnome-session presence');
                return;
            }
            this._onStatusChanged(proxy.status);
        }));
        this._presence.connectSignal('StatusChanged', Lang.bind(this, function(proxy, senderName, [status]) {
            this._onStatusChanged(status);
        }));
        this._screenSaverDBus = new ShellDBus.ScreenSaverDBus(this);
        this._smartcardManager = SmartcardManager.getSmartcardManager();
        this._smartcardManager.connect('smartcard-inserted',
                                       Lang.bind(this, function(manager, token) {
                                           if (this._isLocked && token.UsedToLogin)
                                               this._liftShield(true, 0);
                                       }));
        this._oVirtCredentialsManager = OVirt.getOVirtCredentialsManager();
        this._oVirtCredentialsManager.connect('user-authenticated',
                                              Lang.bind(this, function() {
                                                  if (this._isLocked)
                                                      this._liftShield(true, 0);
                                              }));
        this._loginManager = LoginManager.getLoginManager();
        this._loginManager.connect('prepare-for-sleep',
                                   Lang.bind(this, this._prepareForSleep));
        this._loginSession = null;
        this._loginManager.getCurrentSessionProxy(Lang.bind(this,
            function(sessionProxy) {
                this._loginSession = sessionProxy;
                this._loginSession.connectSignal('Lock', Lang.bind(this, function() { this.lock(false); }));
                this._loginSession.connectSignal('Unlock', Lang.bind(this, function() { this.deactivate(false); }));
                this._loginSession.connect('g-properties-changed', Lang.bind(this, this._syncInhibitor));
                this._syncInhibitor();
            }));
        this._settings = new Gio.Settings({ schema_id: SCREENSAVER_SCHEMA });
        this._settings.connect('changed::' + LOCK_ENABLED_KEY, Lang.bind(this, this._syncInhibitor));
        this._isModal = false;
        this._hasLockScreen = false;
        this._isGreeter = false;
        this._isActive = false;
        this._isLocked = false;
        this._inUnlockAnimation = false;
        this._activationTime = 0;
        this._becameActiveId = 0;
        this._lockTimeoutId = 0;
        // The "long" lightbox is used for the longer (20 seconds) fade from session
        // to idle status, the "short" is used for quickly fading to black when locking
        // manually
        this._longLightbox = new Lightbox.Lightbox(Main.uiGroup,
                                                   { inhibitEvents: true,
                                                     fadeFactor: 1 });
        this._longLightbox.connect('shown', Lang.bind(this, this._onLongLightboxShown));
        this._shortLightbox = new Lightbox.Lightbox(Main.uiGroup,
                                                    { inhibitEvents: true,
                                                      fadeFactor: 1 });
        this._shortLightbox.connect('shown', Lang.bind(this, this._onShortLightboxShown));
        this.idleMonitor = Meta.IdleMonitor.get_core();
        this._cursorTracker = Meta.CursorTracker.get_for_screen(global.screen);
        this._syncInhibitor();
    },
    _setActive: function(active) {
        let prevIsActive = this._isActive;
        this._isActive = active;
        if (prevIsActive != this._isActive)
            this.emit('active-changed');
        if (this._loginSession)
            this._loginSession.SetLockedHintRemote(active);
        this._syncInhibitor();
    },
    _createBackground: function(monitorIndex) {
        let monitor = Main.layoutManager.monitors[monitorIndex];
        let widget = new St.Widget({ style_class: 'screen-shield-background',
                                     x: monitor.x,
                                     y: monitor.y,
                                     width: monitor.width,
                                     height: monitor.height });
        let bgManager = new Background.BackgroundManager({ container: widget,
                                                           monitorIndex: monitorIndex,
                                                           controlPosition: false,
                                                           settingsSchema: SCREENSAVER_SCHEMA });
        this._bgManagers.push(bgManager);
        this._backgroundGroup.add_child(widget);
    },
    _updateBackgrounds: function() {
        for (let i = 0; i < this._bgManagers.length; i++)
            this._bgManagers[i].destroy();
        this._bgManagers = [];
        this._backgroundGroup.destroy_all_children();
        for (let i = 0; i < Main.layoutManager.monitors.length; i++)
            this._createBackground(i);
    },
    _liftShield: function(onPrimary, velocity) {
        if (this._isLocked) {
            if (this._ensureUnlockDialog(onPrimary, true /* allowCancel */))
                this._hideLockScreen(true /* animate */, velocity);
        } else {
            this.deactivate(true /* animate */);
        }
    },
    _maybeCancelDialog: function() {
        if (!this._dialog)
            return;
        this._dialog.cancel();
        if (this._isGreeter) {
            // LoginDialog.cancel() will grab the key focus
            // on its own, so ensure it stays on lock screen
            // instead
            this._lockScreenGroup.grab_key_focus();
        } else {
            this._dialog = null;
        }
    },
    _becomeModal: function() {
        if (this._isModal)
            return true;
        this._isModal = Main.pushModal(this.actor, { actionMode: Shell.ActionMode.LOCK_SCREEN });
        if (this._isModal)
            return true;
        // We failed to get a pointer grab, it means that
        // something else has it. Try with a keyboard grab only
        this._isModal = Main.pushModal(this.actor, { options: Meta.ModalOptions.POINTER_ALREADY_GRABBED,
                                                     actionMode: Shell.ActionMode.LOCK_SCREEN });
        return this._isModal;
    },
    _onLockScreenKeyPress: function(actor, event) {
        let symbol = event.get_key_symbol();
        let unichar = event.get_key_unicode();
        // Do nothing if the lock screen is not fully shown.
        // This avoids reusing the previous (and stale) unlock
        // dialog if esc is pressed while the curtain is going
        // down after cancel.
        if (this._lockScreenState != MessageTray.State.SHOWN)
            return Clutter.EVENT_PROPAGATE;
        let isEnter = (symbol == Clutter.KEY_Return ||
                       symbol == Clutter.KEY_KP_Enter ||
                       symbol == Clutter.KEY_ISO_Enter);
        if (!isEnter && !(GLib.unichar_isprint(unichar) || symbol == Clutter.KEY_Escape))
            return Clutter.EVENT_PROPAGATE;
        if (this._isLocked &&
            this._ensureUnlockDialog(true, true) &&
            GLib.unichar_isgraph(unichar))
            this._dialog.addCharacter(unichar);
        this._liftShield(true, 0);
        return Clutter.EVENT_STOP;
    },
    _onLockScreenScroll: function(actor, event) {
        if (this._lockScreenState != MessageTray.State.SHOWN)
            return Clutter.EVENT_PROPAGATE;
        let delta = 0;
        if (event.get_scroll_direction() == Clutter.ScrollDirection.SMOOTH)
            delta = Math.abs(event.get_scroll_delta()[0]);
        else
            delta = 5;
        this._lockScreenScrollCounter += delta;
        // 7 standard scrolls to lift up
        if (this._lockScreenScrollCounter > 35) {
            this._liftShield(true, 0);
        }
        return Clutter.EVENT_STOP;
    },
    _syncInhibitor: function() {
        let inhibit = (this._loginSession && this._loginSession.Active &&
                       !this._isActive && this._settings.get_boolean(LOCK_ENABLED_KEY));
        if (inhibit) {
            this._loginManager.inhibit(_("GNOME needs to lock the screen"),
                                       Lang.bind(this, function(inhibitor) {
                                           if (this._inhibitor)
                                               this._inhibitor.close(null);
                                           this._inhibitor = inhibitor;
                                       }));
        } else {
            if (this._inhibitor)
                this._inhibitor.close(null);
            this._inhibitor = null;
        }
    },
    _prepareForSleep: function(loginManager, aboutToSuspend) {
        if (aboutToSuspend) {
            if (this._settings.get_boolean(LOCK_ENABLED_KEY))
                this.lock(true);
        } else {
            this._wakeUpScreen();
        }
    },
    _animateArrows: function() {
        let arrows = this._arrowContainer.get_children();
        let unitaryDelay = ARROW_ANIMATION_TIME / (arrows.length + 1);
        let maxOpacity = 255 * ARROW_ANIMATION_PEAK_OPACITY;
        for (let i = 0; i < arrows.length; i++) {
            arrows[i].opacity = 0;
            Tweener.addTween(arrows[i],
                             { opacity: 0,
                               delay: unitaryDelay * (N_ARROWS - (i + 1)),
                               time: ARROW_ANIMATION_TIME,
                               transition: function(t, b, c, d) {
                                 if (t < d/2)
                                     return TweenerEquations.easeOutQuad(t, 0, maxOpacity, d/2);
                                 else
                                     return TweenerEquations.easeInQuad(t - d/2, maxOpacity, -maxOpacity, d/2);
                               }
                             });
        }
        return GLib.SOURCE_CONTINUE;
    },
    _onDragBegin: function() {
        Tweener.removeTweens(this._lockScreenGroup);
        this._lockScreenState = MessageTray.State.HIDING;
        if (this._isLocked)
            this._ensureUnlockDialog(false, false);
        return true;
    },
    _onDragMotion: function() {
	let [origX, origY] = this._dragAction.get_press_coords(0);
	let [currentX, currentY] = this._dragAction.get_motion_coords(0);
	let newY = currentY - origY;
	newY = clamp(newY, -global.stage.height, 0);
	this._lockScreenGroup.y = newY;
	return true;
    },
    _onDragEnd: function(action, actor, eventX, eventY, modifiers) {
        if (this._lockScreenState != MessageTray.State.HIDING)
            return;
        if (this._lockScreenGroup.y < -(ARROW_DRAG_THRESHOLD * global.stage.height)) {
            // Complete motion automatically
	    let [velocity, velocityX, velocityY] = this._dragAction.get_velocity(0);
            this._liftShield(true, -velocityY);
        } else {
            // restore the lock screen to its original place
            // try to use the same speed as the normal animation
            let h = global.stage.height;
            let time = MANUAL_FADE_TIME * (-this._lockScreenGroup.y) / h;
            Tweener.removeTweens(this._lockScreenGroup);
            Tweener.addTween(this._lockScreenGroup,
                             { y: 0,
                               time: time,
                               transition: 'easeInQuad',
                               onComplete: function() {
                                   this._lockScreenGroup.fixed_position_set = false;
                                   this._lockScreenState = MessageTray.State.SHOWN;
                               },
                               onCompleteScope: this,
                             });
            this._maybeCancelDialog();
        }
    },
    _onStatusChanged: function(status) {
        if (status != GnomeSession.PresenceStatus.IDLE)
            return;
        this._maybeCancelDialog();
        if (this._longLightbox.actor.visible ||
            this._isActive) {
            // We're either shown and active, or in the process of
            // showing.
            // The latter is a very unlikely condition (it requires
            // idle-delay < 20), but in any case we have nothing
            // to do at this point: either isActive is true, or
            // it will soon be.
            // isActive can also be true if the lightbox is hidden,
            // in case the shield is down and the user hasn't unlocked yet
            return;
        }
        if (!this._becomeModal()) {
            // We could not become modal, so we can't activate the
            // screenshield. The user is probably very upset at this
            // point, but any application using global grabs is broken
            // Just tell him to stop using this app
            //
            // XXX: another option is to kick the user into the gdm login
            // screen, where we're not affected by grabs
            Main.notifyError(_("Unable to lock"),
                             _("Lock was blocked by an application"));
            return;
        }
        if (this._activationTime == 0)
            this._activationTime = GLib.get_monotonic_time();
        let shouldLock = this._settings.get_boolean(LOCK_ENABLED_KEY) && !this._isLocked;
        if (shouldLock) {
            let lockTimeout = Math.max(STANDARD_FADE_TIME, this._settings.get_uint(LOCK_DELAY_KEY));
            this._lockTimeoutId = Mainloop.timeout_add(lockTimeout * 1000,
                                                       Lang.bind(this, function() {
                                                           this._lockTimeoutId = 0;
                                                           this.lock(false);
                                                           return GLib.SOURCE_REMOVE;
                                                       }));
            GLib.Source.set_name_by_id(this._lockTimeoutId, '[gnome-shell] this.lock');
        }
        this._activateFade(this._longLightbox, STANDARD_FADE_TIME);
    },
    _activateFade: function(lightbox, time) {
        lightbox.show(time);
        if (this._becameActiveId == 0)
            this._becameActiveId = this.idleMonitor.add_user_active_watch(Lang.bind(this, this._onUserBecameActive));
    },
    _onUserBecameActive: function() {
        // This function gets called here when the user becomes active
        // after we activated a lightbox
        // There are two possibilities here:
        // - we're called when already locked/active; isLocked or isActive is true,
        //   we just go back to the lock screen curtain
        //   (isActive == isLocked == true: normal case
        //    isActive == false, isLocked == true: during the fade for manual locking
        //    isActive == true, isLocked == false: after session idle, before lock-delay)
        // - we're called because the session is IDLE but before the lightbox
        //   is fully shown; at this point isActive is false, so we just hide
        //   the lightbox, reset the activationTime and go back to the unlocked
        //   desktop
        //   using deactivate() is a little of overkill, but it ensures we
        //   don't forget of some bit like modal, DBus properties or idle watches
        //
        // Note: if the (long) lightbox is shown then we're necessarily
        // active, because we call activate() without animation.
        this.idleMonitor.remove_watch(this._becameActiveId);
        this._becameActiveId = 0;
        if (this._isActive || this._isLocked) {
            this._longLightbox.hide();
            this._shortLightbox.hide();
        } else {
            this.deactivate(false);
        }
    },
    _onLongLightboxShown: function() {
        this.activate(false);
    },
    _onShortLightboxShown: function() {
        this._completeLockScreenShown();
    },
    showDialog: function() {
        if (!this._becomeModal()) {
            // In the login screen, this is a hard error. Fail-whale
            log('Could not acquire modal grab for the login screen. Aborting login process.');
            Meta.quit(Meta.ExitCode.ERROR);
        }
        this.actor.show();
        this._isGreeter = Main.sessionMode.isGreeter;
        this._isLocked = true;
        if (this._ensureUnlockDialog(true, true))
            this._hideLockScreen(false, 0);
    },
    _hideLockScreenComplete: function() {
        if (Main.sessionMode.currentMode == 'lock-screen')
            Main.sessionMode.popMode('lock-screen');
        this._lockScreenState = MessageTray.State.HIDDEN;
        this._lockScreenGroup.hide();
        if (this._dialog) {
            this._dialog.actor.grab_key_focus();
            this._dialog.actor.navigate_focus(null, Gtk.DirectionType.TAB_FORWARD, false);
        }
    },
    _hideLockScreen: function(animate, velocity) {
        if (this._lockScreenState == MessageTray.State.HIDDEN)
            return;
        this._lockScreenState = MessageTray.State.HIDING;
        Tweener.removeTweens(this._lockScreenGroup);
        if (animate) {
            // Tween the lock screen out of screen
            // if velocity is not specified (i.e. we come here from pressing ESC),
            // use the same speed regardless of original position
            // if velocity is specified, it's in pixels per milliseconds
            let h = global.stage.height;
            let delta = (h + this._lockScreenGroup.y);
            let min_velocity = global.stage.height / (CURTAIN_SLIDE_TIME * 1000);
            velocity = Math.max(min_velocity, velocity);
            let time = (delta / velocity) / 1000;
            Tweener.addTween(this._lockScreenGroup,
                             { y: -h,
                               time: time,
                               transition: 'easeInQuad',
                               onComplete: Lang.bind(this, this._hideLockScreenComplete),
                             });
        } else {
            this._hideLockScreenComplete();
        }
        this._cursorTracker.set_pointer_visible(true);
    },
    _ensureUnlockDialog: function(onPrimary, allowCancel) {
        if (!this._dialog) {
            let constructor = Main.sessionMode.unlockDialog;
            if (!constructor) {
                // This session mode has no locking capabilities
                this.deactivate(true);
                return false;
            }
            this._dialog = new constructor(this._lockDialogGroup);
            let time = global.get_current_time();
            if (!this._dialog.open(time, onPrimary)) {
                // This is kind of an impossible error: we're already modal
                // by the time we reach this...
                log('Could not open login dialog: failed to acquire grab');
                this.deactivate(true);
                return false;
            }
            this._dialog.connect('failed', Lang.bind(this, this._onUnlockFailed));
        }
        this._dialog.allowCancel = allowCancel;
        return true;
    },
    _onUnlockFailed: function() {
        this._resetLockScreen({ animateLockScreen: true,
                                fadeToBlack: false });
    },
    _resetLockScreen: function(params) {
        // Don't reset the lock screen unless it is completely hidden
        // This prevents the shield going down if the lock-delay timeout
        // fires while the user is dragging (which has the potential
        // to confuse our state)
        if (this._lockScreenState != MessageTray.State.HIDDEN)
            return;
        this._ensureLockScreen();
        this._lockDialogGroup.scale_x = 1;
        this._lockDialogGroup.scale_y = 1;
        this._lockScreenGroup.show();
        this._lockScreenState = MessageTray.State.SHOWING;
        let fadeToBlack = params.fadeToBlack;
        if (params.animateLockScreen) {
            this._lockScreenGroup.y = -global.screen_height;
            Tweener.removeTweens(this._lockScreenGroup);
            Tweener.addTween(this._lockScreenGroup,
                             { y: 0,
                               time: MANUAL_FADE_TIME,
                               transition: 'easeOutQuad',
                               onComplete: function() {
                                   this._lockScreenShown({ fadeToBlack: fadeToBlack,
                                                           animateFade: true });
                               },
                               onCompleteScope: this
                             });
        } else {
            this._lockScreenGroup.fixed_position_set = false;
            this._lockScreenShown({ fadeToBlack: fadeToBlack,
                                    animateFade: false });
        }
        this._lockScreenGroup.grab_key_focus();
        if (Main.sessionMode.currentMode != 'lock-screen')
            Main.sessionMode.pushMode('lock-screen');
    },
    _startArrowAnimation: function() {
        this._arrowActiveWatchId = 0;
        if (!this._arrowAnimationId) {
            this._arrowAnimationId = Mainloop.timeout_add(6000, Lang.bind(this, this._animateArrows));
            GLib.Source.set_name_by_id(this._arrowAnimationId, '[gnome-shell] this._animateArrows');
            this._animateArrows();
        }
        if (!this._arrowWatchId)
            this._arrowWatchId = this.idleMonitor.add_idle_watch(ARROW_IDLE_TIME,
                                                                 Lang.bind(this, this._pauseArrowAnimation));
    },
    _pauseArrowAnimation: function() {
        if (this._arrowAnimationId) {
            Mainloop.source_remove(this._arrowAnimationId);
            this._arrowAnimationId = 0;
        }
        if (!this._arrowActiveWatchId)
            this._arrowActiveWatchId = this.idleMonitor.add_user_active_watch(Lang.bind(this, this._startArrowAnimation));
    },
    _stopArrowAnimation: function() {
        if (this._arrowAnimationId) {
            Mainloop.source_remove(this._arrowAnimationId);
            this._arrowAnimationId = 0;
        }
        if (this._arrowActiveWatchId) {
            this.idleMonitor.remove_watch(this._arrowActiveWatchId);
            this._arrowActiveWatchId = 0;
        }
        if (this._arrowWatchId) {
            this.idleMonitor.remove_watch(this._arrowWatchId);
            this._arrowWatchId = 0;
        }
    },
    _checkArrowAnimation: function() {
        let idleTime = this.idleMonitor.get_idletime();
        if (idleTime < ARROW_IDLE_TIME)
            this._startArrowAnimation();
        else
            this._pauseArrowAnimation();
    },
    _lockScreenShown: function(params) {
        if (this._dialog && !this._isGreeter) {
            this._dialog.destroy();
            this._dialog = null;
        }
        this._checkArrowAnimation();
        let motionId = global.stage.connect('captured-event', Lang.bind(this, function(stage, event) {
            if (event.type() == Clutter.EventType.MOTION) {
                this._cursorTracker.set_pointer_visible(true);
                global.stage.disconnect(motionId);
            }
            return Clutter.EVENT_PROPAGATE;
        }));
        this._cursorTracker.set_pointer_visible(false);
        this._lockScreenState = MessageTray.State.SHOWN;
        this._lockScreenGroup.fixed_position_set = false;
        this._lockScreenScrollCounter = 0;
        if (params.fadeToBlack && params.animateFade) {
            // Take a beat
            let id = Mainloop.timeout_add(1000 * MANUAL_FADE_TIME, Lang.bind(this, function() {
                this._activateFade(this._shortLightbox, MANUAL_FADE_TIME);
                return GLib.SOURCE_REMOVE;
            }));
            GLib.Source.set_name_by_id(id, '[gnome-shell] this._activateFade');
        } else {
            if (params.fadeToBlack)
                this._activateFade(this._shortLightbox, 0);
            this._completeLockScreenShown();
        }
    },
    _completeLockScreenShown: function() {
        this._setActive(true);
        this.emit('lock-screen-shown');
    },
    // Some of the actors in the lock screen are heavy in
    // resources, so we only create them when needed
    _ensureLockScreen: function() {
        if (this._hasLockScreen)
            return;
        this._lockScreenContentsBox = new St.BoxLayout({ x_align: Clutter.ActorAlign.CENTER,
                                                         y_align: Clutter.ActorAlign.CENTER,
                                                         x_expand: true,
                                                         y_expand: true,
                                                         vertical: true,
                                                         style_class: 'screen-shield-contents-box' });
        this._clock = new Clock();
        this._lockScreenContentsBox.add(this._clock.actor, { x_fill: true,
                                                             y_fill: true });
        this._lockScreenContents.add_actor(this._lockScreenContentsBox);
        this._notificationsBox = new NotificationsBox();
        this._wakeUpScreenId = this._notificationsBox.connect('wake-up-screen', Lang.bind(this, this._wakeUpScreen));
        this._lockScreenContentsBox.add(this._notificationsBox.actor, { x_fill: true,
                                                                        y_fill: true,
                                                                        expand: true });
        this._hasLockScreen = true;
    },
    _wakeUpScreen: function() {
        this._onUserBecameActive();
        this.emit('wake-up-screen');
    },
    _clearLockScreen: function() {
        this._clock.destroy();
        this._clock = null;
        if (this._notificationsBox) {
            this._notificationsBox.disconnect(this._wakeUpScreenId);
            this._notificationsBox.destroy();
            this._notificationsBox = null;
        }
        this._stopArrowAnimation();
        this._lockScreenContentsBox.destroy();
        this._hasLockScreen = false;
    },
    get locked() {
        return this._isLocked;
    },
    get active() {
        return this._isActive;
    },
    get activationTime() {
        return this._activationTime;
    },
    deactivate: function(animate) {
        if (this._dialog)
            this._dialog.finish(Lang.bind(this, function() {
                this._continueDeactivate(animate);
            }));
        else
            this._continueDeactivate(animate);
    },
    _continueDeactivate: function(animate) {
        this._hideLockScreen(animate, 0);
        if (this._hasLockScreen)
            this._clearLockScreen();
        if (Main.sessionMode.currentMode == 'lock-screen')
            Main.sessionMode.popMode('lock-screen');
        if (Main.sessionMode.currentMode == 'unlock-dialog')
            Main.sessionMode.popMode('unlock-dialog');
        if (this._isGreeter) {
            // We don't want to "deactivate" any more than
            // this. In particular, we don't want to drop
            // the modal, hide ourselves or destroy the dialog
            // But we do want to set isActive to false, so that
            // gnome-session will reset the idle counter, and
            // gnome-settings-daemon will stop blanking the screen
            this._activationTime = 0;
            this._setActive(false);
            return;
        }
        if (this._dialog && !this._isGreeter)
            this._dialog.popModal();
        if (this._isModal) {
            Main.popModal(this.actor);
            this._isModal = false;
        }
        Tweener.addTween(this._lockDialogGroup, {
            scale_x: 0,
            scale_y: 0,
            time: animate ? Overview.ANIMATION_TIME : 0,
            transition: 'easeOutQuad',
            onComplete: Lang.bind(this, this._completeDeactivate),
            onCompleteScope: this
        });
    },
    _completeDeactivate: function() {
        if (this._dialog) {
            this._dialog.destroy();
            this._dialog = null;
        }
        this._longLightbox.hide();
        this._shortLightbox.hide();
        this.actor.hide();
        if (this._becameActiveId != 0) {
            this.idleMonitor.remove_watch(this._becameActiveId);
            this._becameActiveId = 0;
        }
        if (this._lockTimeoutId != 0) {
            Mainloop.source_remove(this._lockTimeoutId);
            this._lockTimeoutId = 0;
        }
        this._activationTime = 0;
        this._setActive(false);
        this._isLocked = false;
        this.emit('locked-changed');
        global.set_runtime_state(LOCKED_STATE_STR, null);
    },
    activate: function(animate) {
        if (this._activationTime == 0)
            this._activationTime = GLib.get_monotonic_time();
        this.actor.show();
        if (Main.sessionMode.currentMode != 'unlock-dialog' &&
            Main.sessionMode.currentMode != 'lock-screen') {
            this._isGreeter = Main.sessionMode.isGreeter;
            if (!this._isGreeter)
                Main.sessionMode.pushMode('unlock-dialog');
        }
        this._resetLockScreen({ animateLockScreen: animate,
                                fadeToBlack: true });
        global.set_runtime_state(LOCKED_STATE_STR, GLib.Variant.new('b', true));
        // We used to set isActive and emit active-changed here,
        // but now we do that from lockScreenShown, which means
        // there is a 0.3 seconds window during which the lock
        // screen is effectively visible and the screen is locked, but
        // the DBus interface reports the screensaver is off.
        // This is because when we emit ActiveChanged(true),
        // gnome-settings-daemon blanks the screen, and we don't want
        // blank during the animation.
        // This is not a problem for the idle fade case, because we
        // activate without animation in that case.
    },
    lock: function(animate) {
        // Warn the user if we can't become modal
        if (!this._becomeModal()) {
            Main.notifyError(_("Unable to lock"),
                             _("Lock was blocked by an application"));
            return;
        }
        // Clear the clipboard - otherwise, its contents may be leaked
        // to unauthorized parties by pasting into the unlock dialog's
        // password entry and unmasking the entry
        St.Clipboard.get_default().set_text(St.ClipboardType.CLIPBOARD, '');
        St.Clipboard.get_default().set_text(St.ClipboardType.PRIMARY, '');
        let userManager = AccountsService.UserManager.get_default();
        let user = userManager.get_user(GLib.get_user_name());
        if (this._isGreeter)
            this._isLocked = true;
        else
            this._isLocked = user.password_mode != AccountsService.UserPasswordMode.NONE;
        this.activate(animate);
        this.emit('locked-changed');
    },
    // If the previous shell crashed, and gnome-session restarted us, then re-lock
    lockIfWasLocked: function() {
        if (!this._settings.get_boolean(LOCK_ENABLED_KEY))
            return;
        let wasLocked = global.get_runtime_state('b', LOCKED_STATE_STR);
        if (wasLocked === null)
            return;
        Meta.later_add(Meta.LaterType.BEFORE_REDRAW, Lang.bind(this, function() {
            this.lock(false);
        }));
    }
Signals.addSignalMethods(ScreenShield.prototype);
(uuay)screenshot.js
// -*- mode: js; js-indent-level: 4; indent-tabs-mode: nil -*-
const Clutter = imports.gi.Clutter;
const Gdk = imports.gi.Gdk;
const Gio = imports.gi.Gio;
const GLib = imports.gi.GLib;
const Gtk = imports.gi.Gtk;
const Lang = imports.lang;
const Meta = imports.gi.Meta;
const Shell = imports.gi.Shell;
const Signals = imports.signals;
const St = imports.gi.St;
const GrabHelper = imports.ui.grabHelper;
const Lightbox = imports.ui.lightbox;
const Main = imports.ui.main;
const Tweener = imports.ui.tweener;
const ScreenshotIface = '<node> \
<interface name="org.gnome.Shell.Screenshot"> \
<method name="ScreenshotArea"> \
    <arg type="i" direction="in" name="x"/> \
    <arg type="i" direction="in" name="y"/> \
    <arg type="i" direction="in" name="width"/> \
    <arg type="i" direction="in" name="height"/> \
    <arg type="b" direction="in" name="flash"/> \
    <arg type="s" direction="in" name="filename"/> \
    <arg type="b" direction="out" name="success"/> \
    <arg type="s" direction="out" name="filename_used"/> \
</method> \
<method name="ScreenshotWindow"> \
    <arg type="b" direction="in" name="include_frame"/> \
    <arg type="b" direction="in" name="include_cursor"/> \
    <arg type="b" direction="in" name="flash"/> \
    <arg type="s" direction="in" name="filename"/> \
    <arg type="b" direction="out" name="success"/> \
    <arg type="s" direction="out" name="filename_used"/> \
</method> \
<method name="Screenshot"> \
    <arg type="b" direction="in" name="include_cursor"/> \
    <arg type="b" direction="in" name="flash"/> \
    <arg type="s" direction="in" name="filename"/> \
    <arg type="b" direction="out" name="success"/> \
    <arg type="s" direction="out" name="filename_used"/> \
</method> \
<method name="SelectArea"> \
    <arg type="i" direction="out" name="x"/> \
    <arg type="i" direction="out" name="y"/> \
    <arg type="i" direction="out" name="width"/> \
    <arg type="i" direction="out" name="height"/> \
</method> \
<method name="FlashArea"> \
    <arg type="i" direction="in" name="x"/> \
    <arg type="i" direction="in" name="y"/> \
    <arg type="i" direction="in" name="width"/> \
    <arg type="i" direction="in" name="height"/> \
</method> \
</interface> \
</node>';
const ScreenshotService = new Lang.Class({
    Name: 'ScreenshotService',
    _init: function() {
        this._dbusImpl = Gio.DBusExportedObject.wrapJSObject(ScreenshotIface, this);
        this._dbusImpl.export(Gio.DBus.session, '/org/gnome/Shell/Screenshot');
        this._screenShooter = new Map();
        this._lockdownSettings = new Gio.Settings({ schema_id: 'org.gnome.desktop.lockdown' });
        Gio.DBus.session.own_name('org.gnome.Shell.Screenshot', Gio.BusNameOwnerFlags.REPLACE, null, null);
    },
    _createScreenshot: function(invocation) {
        let sender = invocation.get_sender();
        if (this._screenShooter.has(sender) ||
            this._lockdownSettings.get_boolean('disable-save-to-disk')) {
            invocation.return_value(GLib.Variant.new('(bs)', [false, '']));
            return null;
        }
        let shooter = new Shell.Screenshot();
        shooter._watchNameId =
                        Gio.bus_watch_name(Gio.BusType.SESSION, sender, 0, null,
                                           Lang.bind(this, this._onNameVanished));
        this._screenShooter.set(sender, shooter);
        return shooter;
    },
    _onNameVanished: function(connection, name) {
        this._removeShooterForSender(name);
    },
    _removeShooterForSender: function(sender) {
        let shooter = this._screenShooter.get(sender);
        if (!shooter)
            return;
        Gio.bus_unwatch_name(shooter._watchNameId);
        this._screenShooter.delete(sender);
    },
    _checkArea: function(x, y, width, height) {
        return x >= 0 && y >= 0 &&
               width > 0 && height > 0 &&
               x + width <= global.screen_width &&
               y + height <= global.screen_height;
    },
    _onScreenshotComplete: function(obj, result, area, filenameUsed, flash, invocation) {
        if (result) {
            if (flash) {
                let flashspot = new Flashspot(area);
                flashspot.fire(Lang.bind(this, function() {
                    this._removeShooterForSender(invocation.get_sender());
                }));
            }
            else
                this._removeShooterForSender(invocation.get_sender());
        }
        let retval = GLib.Variant.new('(bs)', [result, filenameUsed]);
        invocation.return_value(retval);
    },
    _scaleArea: function(x, y, width, height) {
        let scaleFactor = St.ThemeContext.get_for_stage(global.stage).scale_factor;
        x *= scaleFactor;
        y *= scaleFactor;
        width *= scaleFactor;
        height *= scaleFactor;
        return [x, y, width, height];
    },
    _unscaleArea: function(x, y, width, height) {
        let scaleFactor = St.ThemeContext.get_for_stage(global.stage).scale_factor;
        x /= scaleFactor;
        y /= scaleFactor;
        width /= scaleFactor;
        height /= scaleFactor;
        return [x, y, width, height];
    },
    ScreenshotAreaAsync : function (params, invocation) {
        let [x, y, width, height, flash, filename, callback] = params;
        [x, y, width, height] = this._scaleArea(x, y, width, height);
        if (!this._checkArea(x, y, width, height)) {
            invocation.return_error_literal(Gio.IOErrorEnum,
                                            Gio.IOErrorEnum.CANCELLED,
                                            "Invalid params");
            return;
        }
        let screenshot = this._createScreenshot(invocation);
        if (!screenshot)
            return;
        screenshot.screenshot_area (x, y, width, height, filename,
                                Lang.bind(this, this._onScreenshotComplete,
                                          flash, invocation));
    },
    ScreenshotWindowAsync : function (params, invocation) {
        let [include_frame, include_cursor, flash, filename] = params;
        let screenshot = this._createScreenshot(invocation);
        if (!screenshot)
            return;
        screenshot.screenshot_window (include_frame, include_cursor, filename,
                                  Lang.bind(this, this._onScreenshotComplete,
                                            flash, invocation));
    },
    ScreenshotAsync : function (params, invocation) {
        let [include_cursor, flash, filename] = params;
        let screenshot = this._createScreenshot(invocation);
        if (!screenshot)
            return;
        screenshot.screenshot(include_cursor, filename,
                          Lang.bind(this, this._onScreenshotComplete,
                                    flash, invocation));
    },
    SelectAreaAsync: function (params, invocation) {
        let selectArea = new SelectArea();
        selectArea.show();
        selectArea.connect('finished', Lang.bind(this,
            function(selectArea, areaRectangle) {
                if (areaRectangle) {
                    let retRectangle = this._unscaleArea(areaRectangle.x, areaRectangle.y,
                        areaRectangle.width, areaRectangle.height);
                    let retval = GLib.Variant.new('(iiii)', retRectangle);
                    invocation.return_value(retval);
                } else {
                    invocation.return_error_literal(Gio.IOErrorEnum, Gio.IOErrorEnum.CANCELLED,
                        "Operation was cancelled");
                }
            }));
    },
    FlashAreaAsync: function(params, invocation) {
        let [x, y, width, height] = params;
        [x, y, width, height] = this._scaleArea(x, y, width, height);
        if (!this._checkArea(x, y, width, height)) {
            invocation.return_error_literal(Gio.IOErrorEnum,
                                            Gio.IOErrorEnum.CANCELLED,
                                            "Invalid params");
            return;
        }
        let flashspot = new Flashspot({ x : x, y : y, width: width, height: height});
        flashspot.fire();
        invocation.return_value(null);
    }
const SelectArea = new Lang.Class({
    Name: 'SelectArea',
    _init: function() {
        this._startX = -1;
        this._startY = -1;
        this._lastX = 0;
        this._lastY = 0;
        this._result = null;
        this._initRubberbandColors();
        this._group = new St.Widget({ visible: false,
                                      reactive: true,
                                      x: 0,
                                      y: 0 });
        Main.uiGroup.add_actor(this._group);
        this._grabHelper = new GrabHelper.GrabHelper(this._group);
        this._group.connect('button-press-event',
                            Lang.bind(this, this._onButtonPress));
        this._group.connect('button-release-event',
                            Lang.bind(this, this._onButtonRelease));
        this._group.connect('motion-event',
                            Lang.bind(this, this._onMotionEvent));
        let constraint = new Clutter.BindConstraint({ source: global.stage,
                                                      coordinate: Clutter.BindCoordinate.ALL });
        this._group.add_constraint(constraint);
        this._rubberband = new Clutter.Rectangle({ color: this._background,
                                                   has_border: true,
                                                   border_width: 1,
                                                   border_color: this._border });
        this._group.add_actor(this._rubberband);
    },
    show: function() {
        if (!this._grabHelper.grab({ actor: this._group,
                                     onUngrab: Lang.bind(this, this._onUngrab) }))
            return;
        global.screen.set_cursor(Meta.Cursor.CROSSHAIR);
        Main.uiGroup.set_child_above_sibling(this._group, null);
        this._group.visible = true;
    },
    _initRubberbandColors: function() {
        function colorFromRGBA(rgba) {
            return new Clutter.Color({ red: rgba.red * 255,
                                       green: rgba.green * 255,
                                       blue: rgba.blue * 255,
                                       alpha: rgba.alpha * 255 });
        }
        let path = new Gtk.WidgetPath();
        path.append_type(Gtk.IconView);
        let context = new Gtk.StyleContext();
        context.set_path(path);
        context.add_class('rubberband');
        this._background = colorFromRGBA(context.get_background_color(Gtk.StateFlags.NORMAL));
        this._border = colorFromRGBA(context.get_border_color(Gtk.StateFlags.NORMAL));
    },
    _getGeometry: function() {
        return { x: Math.min(this._startX, this._lastX),
                 y: Math.min(this._startY, this._lastY),
                 width: Math.abs(this._startX - this._lastX) + 1,
                 height: Math.abs(this._startY - this._lastY) + 1 };
    },
    _onMotionEvent: function(actor, event) {
        if (this._startX == -1 || this._startY == -1)
            return Clutter.EVENT_PROPAGATE;
        [this._lastX, this._lastY] = event.get_coords();
        this._lastX = Math.floor(this._lastX);
        this._lastY = Math.floor(this._lastY);
        let geometry = this._getGeometry();
        this._rubberband.set_position(geometry.x, geometry.y);
        this._rubberband.set_size(geometry.width, geometry.height);
        return Clutter.EVENT_PROPAGATE;
    },
    _onButtonPress: function(actor, event) {
        [this._startX, this._startY] = event.get_coords();
        this._startX = Math.floor(this._startX);
        this._startY = Math.floor(this._startY);
        this._rubberband.set_position(this._startX, this._startY);
        return Clutter.EVENT_PROPAGATE;
    },
    _onButtonRelease: function(actor, event) {
        this._result = this._getGeometry();
        Tweener.addTween(this._group,
                         { opacity: 0,
                           time: 0.2,
                           transition: 'easeOutQuad',
                           onComplete: Lang.bind(this,
                               function() {
                                   this._grabHelper.ungrab();
                               })
                         });
        return Clutter.EVENT_PROPAGATE;
    },
    _onUngrab: function() {
        global.screen.set_cursor(Meta.Cursor.DEFAULT);
        this.emit('finished', this._result);
        GLib.idle_add(GLib.PRIORITY_DEFAULT, Lang.bind(this,
            function() {
                this._group.destroy();
                return GLib.SOURCE_REMOVE;
            }));
    }
Signals.addSignalMethods(SelectArea.prototype);
const FLASHSPOT_ANIMATION_OUT_TIME = 0.5; // seconds
const Flashspot = new Lang.Class({
    Name: 'Flashspot',
    Extends: Lightbox.Lightbox,
    _init: function(area) {
        this.parent(Main.uiGroup, { inhibitEvents: true,
                                    width: area.width,
                                    height: area.height });
        this.actor.style_class = 'flashspot';
        this.actor.set_position(area.x, area.y);
    },
    fire: function(doneCallback) {
        this.actor.show();
        this.actor.opacity = 255;
        Tweener.addTween(this.actor,
                         { opacity: 0,
                           time: FLASHSPOT_ANIMATION_OUT_TIME,
                           transition: 'easeOutQuad',
                           onComplete: Lang.bind(this, function() {
                               if (doneCallback)
                                   doneCallback();
                               this.destroy();
                           })
                         });
    }
(uuay)animation.js
// -*- mode: js; js-indent-level: 4; indent-tabs-mode: nil -*-
const GLib = imports.gi.GLib;
const Lang = imports.lang;
const Mainloop = imports.mainloop;
const St = imports.gi.St;
const Signals = imports.signals;
const Atk = imports.gi.Atk;
const ANIMATED_ICON_UPDATE_TIMEOUT = 16;
const Animation = new Lang.Class({
    Name: 'Animation',
    _init: function(file, width, height, speed) {
        this.actor = new St.Bin();
        this.actor.connect('destroy', Lang.bind(this, this._onDestroy));
        this._speed = speed;
        this._isLoaded = false;
        this._isPlaying = false;
        this._timeoutId = 0;
        this._frame = 0;
        let scaleFactor = St.ThemeContext.get_for_stage(global.stage).scale_factor;
        this._animations = St.TextureCache.get_default().load_sliced_image (file, width, height, scaleFactor,
                                                                            Lang.bind(this, this._animationsLoaded));
        this.actor.set_child(this._animations);
    },
    play: function() {
        if (this._isLoaded && this._timeoutId == 0) {
            if (this._frame == 0)
                this._showFrame(0);
            this._timeoutId = GLib.timeout_add(GLib.PRIORITY_LOW, this._speed, Lang.bind(this, this._update));
            GLib.Source.set_name_by_id(this._timeoutId, '[gnome-shell] this._update');
        }
        this._isPlaying = true;
    },
    stop: function() {
        if (this._timeoutId > 0) {
            Mainloop.source_remove(this._timeoutId);
            this._timeoutId = 0;
        }
        this._isPlaying = false;
    },
    _showFrame: function(frame) {
        let oldFrameActor = this._animations.get_child_at_index(this._frame);
        if (oldFrameActor)
            oldFrameActor.hide();
        this._frame = (frame % this._animations.get_n_children());
        let newFrameActor = this._animations.get_child_at_index(this._frame);
        if (newFrameActor)
            newFrameActor.show();
    },
    _update: function() {
        this._showFrame(this._frame + 1);
        return GLib.SOURCE_CONTINUE;
    },
    _animationsLoaded: function() {
        this._isLoaded = true;
        if (this._isPlaying)
            this.play();
    },
    _onDestroy: function() {
        this.stop();
    }
const AnimatedIcon = new Lang.Class({
    Name: 'AnimatedIcon',
    Extends: Animation,
    _init: function(file, size) {
        this.parent(file, size, size, ANIMATED_ICON_UPDATE_TIMEOUT);
    }
(uuay)boxpointer.js
// -*- mode: js; js-indent-level: 4; indent-tabs-mode: nil -*-
const Clutter = imports.gi.Clutter;
const Lang = imports.lang;
const Meta = imports.gi.Meta;
const Shell = imports.gi.Shell;
const Signals = imports.signals;
const St = imports.gi.St;
const Main = imports.ui.main;
const Tweener = imports.ui.tweener;
const PopupAnimation = {
    NONE:  0,
    SLIDE: 1 << 0,
    FADE:  1 << 1,
    FULL:  ~0,
const POPUP_ANIMATION_TIME = 0.15;
 * BoxPointer:
 * @side: side to draw the arrow on
 * @binProperties: Properties to set on contained bin
 * An actor which displays a triangle "arrow" pointing to a given
 * side.  The .bin property is a container in which content can be
 * placed.  The arrow position may be controlled via
 * setArrowOrigin(). The arrow side might be temporarily flipped
 * depending on the box size and source position to keep the box
 * totally inside the monitor if possible.
const BoxPointer = new Lang.Class({
    Name: 'BoxPointer',
    _init: function(arrowSide, binProperties) {
        this._arrowSide = arrowSide;
        this._userArrowSide = arrowSide;
        this._arrowOrigin = 0;
        this._arrowActor = null;
        this.actor = new St.Bin({ x_fill: true,
                                  y_fill: true });
        this._container = new Shell.GenericContainer();
        this.actor.set_child(this._container);
        this._container.connect('get-preferred-width', Lang.bind(this, this._getPreferredWidth));
        this._container.connect('get-preferred-height', Lang.bind(this, this._getPreferredHeight));
        this._container.connect('allocate', Lang.bind(this, this._allocate));
        this.bin = new St.Bin(binProperties);
        this._container.add_actor(this.bin);
        this._border = new St.DrawingArea();
        this._border.connect('repaint', Lang.bind(this, this._drawBorder));
        this._container.add_actor(this._border);
        this.bin.raise(this._border);
        this._xOffset = 0;
        this._yOffset = 0;
        this._xPosition = 0;
        this._yPosition = 0;
        this._sourceAlignment = 0.5;
        this._capturedEventId = 0;
        this._muteInput();
    },
    get arrowSide() {
        return this._arrowSide;
    },
    _muteInput: function() {
        if (this._capturedEventId == 0)
            this._capturedEventId = this.actor.connect('captured-event',
                                                       function() { return Clutter.EVENT_STOP; });
    },
    _unmuteInput: function() {
        if (this._capturedEventId != 0) {
            this.actor.disconnect(this._capturedEventId);
            this._capturedEventId = 0;
        }
    },
    show: function(animate, onComplete) {
        let themeNode = this.actor.get_theme_node();
        let rise = themeNode.get_length('-arrow-rise');
        let animationTime = (animate & PopupAnimation.FULL) ? POPUP_ANIMATION_TIME : 0;
        if (animate & PopupAnimation.FADE)
            this.opacity = 0;
        else
            this.opacity = 255;
        this.actor.show();
        if (animate & PopupAnimation.SLIDE) {
            switch (this._arrowSide) {
                case St.Side.TOP:
                    this.yOffset = -rise;
                    break;
                case St.Side.BOTTOM:
                    this.yOffset = rise;
                    break;
                case St.Side.LEFT:
                    this.xOffset = -rise;
                    break;
                case St.Side.RIGHT:
                    this.xOffset = rise;
                    break;
            }
        }
        Tweener.addTween(this, { opacity: 255,
                                 xOffset: 0,
                                 yOffset: 0,
                                 transition: 'linear',
                                 onComplete: Lang.bind(this, function() {
                                     this._unmuteInput();
                                     if (onComplete)
                                         onComplete();
                                 }),
                                 time: animationTime });
    },
    hide: function(animate, onComplete) {
        if (!this.actor.visible)
            return;
        let xOffset = 0;
        let yOffset = 0;
        let themeNode = this.actor.get_theme_node();
        let rise = themeNode.get_length('-arrow-rise');
        let fade = (animate & PopupAnimation.FADE);
        let animationTime = (animate & PopupAnimation.FULL) ? POPUP_ANIMATION_TIME : 0;
        if (animate & PopupAnimation.SLIDE) {
            switch (this._arrowSide) {
                case St.Side.TOP:
                    yOffset = rise;
                    break;
                case St.Side.BOTTOM:
                    yOffset = -rise;
                    break;
                case St.Side.LEFT:
                    xOffset = rise;
                    break;
                case St.Side.RIGHT:
                    xOffset = -rise;
                    break;
            }
        }
        this._muteInput();
        Tweener.removeTweens(this);
        Tweener.addTween(this, { opacity: fade ? 0 : 255,
                                 xOffset: xOffset,
                                 yOffset: yOffset,
                                 transition: 'linear',
                                 time: animationTime,
                                 onComplete: Lang.bind(this, function () {
                                     this.actor.hide();
                                     this.opacity = 0;
                                     this.xOffset = 0;
                                     this.yOffset = 0;
                                     if (onComplete)
                                         onComplete();
                                 })
                               });
    },
    _adjustAllocationForArrow: function(isWidth, alloc) {
        let themeNode = this.actor.get_theme_node();
        let borderWidth = themeNode.get_length('-arrow-border-width');
        alloc.min_size += borderWidth * 2;
        alloc.natural_size += borderWidth * 2;
        if ((!isWidth && (this._arrowSide == St.Side.TOP || this._arrowSide == St.Side.BOTTOM))
            || (isWidth && (this._arrowSide == St.Side.LEFT || this._arrowSide == St.Side.RIGHT))) {
            let rise = themeNode.get_length('-arrow-rise');
            alloc.min_size += rise;
            alloc.natural_size += rise;
        }
    },
    _getPreferredWidth: function(actor, forHeight, alloc) {
        let [minInternalSize, natInternalSize] = this.bin.get_preferred_width(forHeight);
        alloc.min_size = minInternalSize;
        alloc.natural_size = natInternalSize;
        this._adjustAllocationForArrow(true, alloc);
    },
    _getPreferredHeight: function(actor, forWidth, alloc) {
        let themeNode = this.actor.get_theme_node();
        let borderWidth = themeNode.get_length('-arrow-border-width');
        let [minSize, naturalSize] = this.bin.get_preferred_height(forWidth - 2 * borderWidth);
        alloc.min_size = minSize;
        alloc.natural_size = naturalSize;
        this._adjustAllocationForArrow(false, alloc);
    },
    _allocate: function(actor, box, flags) {
        let themeNode = this.actor.get_theme_node();
        let borderWidth = themeNode.get_length('-arrow-border-width');
        let rise = themeNode.get_length('-arrow-rise');
        let childBox = new Clutter.ActorBox();
        let availWidth = box.x2 - box.x1;
        let availHeight = box.y2 - box.y1;
        childBox.x1 = 0;
        childBox.y1 = 0;
        childBox.x2 = availWidth;
        childBox.y2 = availHeight;
        this._border.allocate(childBox, flags);
        childBox.x1 = borderWidth;
        childBox.y1 = borderWidth;
        childBox.x2 = availWidth - borderWidth;
        childBox.y2 = availHeight - borderWidth;
        switch (this._arrowSide) {
            case St.Side.TOP:
                childBox.y1 += rise;
                break;
            case St.Side.BOTTOM:
                childBox.y2 -= rise;
                break;
            case St.Side.LEFT:
                childBox.x1 += rise;
                break;
            case St.Side.RIGHT:
                childBox.x2 -= rise;
                break;
        }
        this.bin.allocate(childBox, flags);
        if (this._sourceActor && this._sourceActor.mapped) {
            this._reposition();
            this._updateFlip();
        }
    },
    _drawBorder: function(area) {
        let themeNode = this.actor.get_theme_node();
        if (this._arrowActor) {
            let [sourceX, sourceY] = this._arrowActor.get_transformed_position();
            let [sourceWidth, sourceHeight] = this._arrowActor.get_transformed_size();
            let [absX, absY] = this.actor.get_transformed_position();
            if (this._arrowSide == St.Side.TOP ||
                this._arrowSide == St.Side.BOTTOM) {
                this._arrowOrigin = sourceX - absX + sourceWidth / 2;
            } else {
                this._arrowOrigin = sourceY - absY + sourceHeight / 2;
            }
        }
        let borderWidth = themeNode.get_length('-arrow-border-width');
        let base = themeNode.get_length('-arrow-base');
        let rise = themeNode.get_length('-arrow-rise');
        let borderRadius = themeNode.get_length('-arrow-border-radius');
        let halfBorder = borderWidth / 2;
        let halfBase = Math.floor(base/2);
        let backgroundColor = themeNode.get_color('-arrow-background-color');
        let [width, height] = area.get_surface_size();
        let [boxWidth, boxHeight] = [width, height];
        if (this._arrowSide == St.Side.TOP || this._arrowSide == St.Side.BOTTOM) {
            boxHeight -= rise;
        } else {
            boxWidth -= rise;
        }
        let cr = area.get_context();
        // Translate so that box goes from 0,0 to boxWidth,boxHeight,
        // with the arrow poking out of that
        if (this._arrowSide == St.Side.TOP) {
            cr.translate(0, rise);
        } else if (this._arrowSide == St.Side.LEFT) {
            cr.translate(rise, 0);
        }
        let [x1, y1] = [halfBorder, halfBorder];
        let [x2, y2] = [boxWidth - halfBorder, boxHeight - halfBorder];
        let skipTopLeft = false;
        let skipTopRight = false;
        let skipBottomLeft = false;
        let skipBottomRight = false;
        if (rise) {
            switch (this._arrowSide) {
            case St.Side.TOP:
                if (this._arrowOrigin == x1)
                    skipTopLeft = true;
                else if (this._arrowOrigin == x2)
                    skipTopRight = true;
                break;
            case St.Side.RIGHT:
                if (this._arrowOrigin == y1)
                    skipTopRight = true;
                else if (this._arrowOrigin == y2)
                    skipBottomRight = true;
                break;
            case St.Side.BOTTOM:
                if (this._arrowOrigin == x1)
                    skipBottomLeft = true;
                else if (this._arrowOrigin == x2)
                    skipBottomRight = true;
                break;
            case St.Side.LEFT:
                if (this._arrowOrigin == y1)
                    skipTopLeft = true;
                else if (this._arrowOrigin == y2)
                    skipBottomLeft = true;
                break;
            }
        }
        cr.moveTo(x1 + borderRadius, y1);
        if (this._arrowSide == St.Side.TOP && rise) {
            if (skipTopLeft) {
                cr.moveTo(x1, y2 - borderRadius);
                cr.lineTo(x1, y1 - rise);
                cr.lineTo(x1 + halfBase, y1);
            } else if (skipTopRight) {
                cr.lineTo(x2 - halfBase, y1);
                cr.lineTo(x2, y1 - rise);
                cr.lineTo(x2, y1 + borderRadius);
            } else {
                cr.lineTo(this._arrowOrigin - halfBase, y1);
                cr.lineTo(this._arrowOrigin, y1 - rise);
                cr.lineTo(this._arrowOrigin + halfBase, y1);
            }
        }
        if (!skipTopRight) {
            cr.lineTo(x2 - borderRadius, y1);
            cr.arc(x2 - borderRadius, y1 + borderRadius, borderRadius,
                   3*Math.PI/2, Math.PI*2);
        }
        if (this._arrowSide == St.Side.RIGHT && rise) {
            if (skipTopRight) {
                cr.lineTo(x2 + rise, y1);
                cr.lineTo(x2 + rise, y1 + halfBase);
            } else if (skipBottomRight) {
                cr.lineTo(x2, y2 - halfBase);
                cr.lineTo(x2 + rise, y2);
                cr.lineTo(x2 - borderRadius, y2);
            } else {
                cr.lineTo(x2, this._arrowOrigin - halfBase);
                cr.lineTo(x2 + rise, this._arrowOrigin);
                cr.lineTo(x2, this._arrowOrigin + halfBase);
            }
        }
        if (!skipBottomRight) {
            cr.lineTo(x2, y2 - borderRadius);
            cr.arc(x2 - borderRadius, y2 - borderRadius, borderRadius,
                   0, Math.PI/2);
        }
        if (this._arrowSide == St.Side.BOTTOM && rise) {
            if (skipBottomLeft) {
                cr.lineTo(x1 + halfBase, y2);
                cr.lineTo(x1, y2 + rise);
                cr.lineTo(x1, y2 - borderRadius);
            } else if (skipBottomRight) {
                cr.lineTo(x2, y2 + rise);
                cr.lineTo(x2 - halfBase, y2);
            } else {
                cr.lineTo(this._arrowOrigin + halfBase, y2);
                cr.lineTo(this._arrowOrigin, y2 + rise);
                cr.lineTo(this._arrowOrigin - halfBase, y2);
            }
        }
        if (!skipBottomLeft) {
            cr.lineTo(x1 + borderRadius, y2);
            cr.arc(x1 + borderRadius, y2 - borderRadius, borderRadius,
                   Math.PI/2, Math.PI);
        }
        if (this._arrowSide == St.Side.LEFT && rise) {
            if (skipTopLeft) {
                cr.lineTo(x1, y1 + halfBase);
                cr.lineTo(x1 - rise, y1);
                cr.lineTo(x1 + borderRadius, y1);
            } else if (skipBottomLeft) {
                cr.lineTo(x1 - rise, y2)
                cr.lineTo(x1 - rise, y2 - halfBase);
            } else {
                cr.lineTo(x1, this._arrowOrigin + halfBase);
                cr.lineTo(x1 - rise, this._arrowOrigin);
                cr.lineTo(x1, this._arrowOrigin - halfBase);
            }
        }
        if (!skipTopLeft) {
            cr.lineTo(x1, y1 + borderRadius);
            cr.arc(x1 + borderRadius, y1 + borderRadius, borderRadius,
                   Math.PI, 3*Math.PI/2);
        }
        Clutter.cairo_set_source_color(cr, backgroundColor);
        cr.fillPreserve();
        if (borderWidth > 0) {
            let borderColor = themeNode.get_color('-arrow-border-color');
            Clutter.cairo_set_source_color(cr, borderColor);
            cr.setLineWidth(borderWidth);
            cr.stroke();
        }
        cr.$dispose();
    },
    setPosition: function(sourceActor, alignment) {
        // We need to show it now to force an allocation,
        // so that we can query the correct size.
        this.actor.show();
        this._sourceActor = sourceActor;
        this._arrowAlignment = alignment;
        this._reposition();
        this._updateFlip();
    },
    setSourceAlignment: function(alignment) {
        this._sourceAlignment = alignment;
        if (!this._sourceActor)
            return;
        this.setPosition(this._sourceActor, this._arrowAlignment);
    },
    _reposition: function() {
        let sourceActor = this._sourceActor;
        let alignment = this._arrowAlignment;
        // Position correctly relative to the sourceActor
        let sourceNode = sourceActor.get_theme_node();
        let sourceContentBox = sourceNode.get_content_box(sourceActor.get_allocation_box());
        let sourceAllocation = Shell.util_get_transformed_allocation(sourceActor);
        let sourceCenterX = sourceAllocation.x1 + sourceContentBox.x1 + (sourceContentBox.x2 - sourceContentBox.x1) * this._sourceAlignment;
        let sourceCenterY = sourceAllocation.y1 + sourceContentBox.y1 + (sourceContentBox.y2 - sourceContentBox.y1) * this._sourceAlignment;
        let [minWidth, minHeight, natWidth, natHeight] = this.actor.get_preferred_size();
        // We also want to keep it onscreen, and separated from the
        // edge by the same distance as the main part of the box is
        // separated from its sourceActor
        let monitor = Main.layoutManager.findMonitorForActor(sourceActor);
        let themeNode = this.actor.get_theme_node();
        let borderWidth = themeNode.get_length('-arrow-border-width');
        let arrowBase = themeNode.get_length('-arrow-base');
        let borderRadius = themeNode.get_length('-arrow-border-radius');
        let margin = (4 * borderRadius + borderWidth + arrowBase);
        let gap = themeNode.get_length('-boxpointer-gap');
        let padding = themeNode.get_length('-arrow-rise');
        let resX, resY;
        switch (this._arrowSide) {
        case St.Side.TOP:
            resY = sourceAllocation.y2 + gap;
            break;
        case St.Side.BOTTOM:
            resY = sourceAllocation.y1 - natHeight - gap;
            break;
        case St.Side.LEFT:
            resX = sourceAllocation.x2 + gap;
            break;
        case St.Side.RIGHT:
            resX = sourceAllocation.x1 - natWidth - gap;
            break;
        }
        // Now align and position the pointing axis, making sure it fits on
        // screen. If the arrowOrigin is so close to the edge that the arrow
        // will not be isosceles, we try to compensate as follows:
        //   - We skip the rounded corner and settle for a right angled arrow
        //     as shown below. See _drawBorder for further details.
        //     |\_____
        //     |
        //     |
        //   - If the arrow was going to be acute angled, we move the position
        //     of the box to maintain the arrow's accuracy.
        let arrowOrigin;
        let halfBase = Math.floor(arrowBase/2);
        let halfBorder = borderWidth / 2;
        let halfMargin = margin / 2;
        let [x1, y1] = [halfBorder, halfBorder];
        let [x2, y2] = [natWidth - halfBorder, natHeight - halfBorder];
        switch (this._arrowSide) {
        case St.Side.TOP:
        case St.Side.BOTTOM:
            resX = sourceCenterX - (halfMargin + (natWidth - margin) * alignment);
            resX = Math.max(resX, monitor.x + padding);
            resX = Math.min(resX, monitor.x + monitor.width - (padding + natWidth));
            arrowOrigin = sourceCenterX - resX;
            if (arrowOrigin <= (x1 + (borderRadius + halfBase))) {
                if (arrowOrigin > x1)
                    resX += (arrowOrigin - x1);
                arrowOrigin = x1;
            } else if (arrowOrigin >= (x2 - (borderRadius + halfBase))) {
                if (arrowOrigin < x2)
                    resX -= (x2 - arrowOrigin);
                arrowOrigin = x2;
            }
            break;
        case St.Side.LEFT:
        case St.Side.RIGHT:
            resY = sourceCenterY - (halfMargin + (natHeight - margin) * alignment);
            resY = Math.max(resY, monitor.y + padding);
            resY = Math.min(resY, monitor.y + monitor.height - (padding + natHeight));
            arrowOrigin = sourceCenterY - resY;
            if (arrowOrigin <= (y1 + (borderRadius + halfBase))) {
                if (arrowOrigin > y1)
                    resY += (arrowOrigin - y1);
                arrowOrigin = y1;
            } else if (arrowOrigin >= (y2 - (borderRadius + halfBase))) {
                if (arrowOrigin < y2)
                    resX -= (y2 - arrowOrigin);
                arrowOrigin = y2;
            }
            break;
        }
        this.setArrowOrigin(arrowOrigin);
        let parent = this.actor.get_parent();
        let success, x, y;
        while (!success) {
            [success, x, y] = parent.transform_stage_point(resX, resY);
            parent = parent.get_parent();
        }
        this._xPosition = Math.floor(x);
        this._yPosition = Math.floor(y);
        this._shiftActor();
    },
    // @origin: Coordinate specifying middle of the arrow, along
    // the Y axis for St.Side.LEFT, St.Side.RIGHT from the top and X axis from
    // the left for St.Side.TOP and St.Side.BOTTOM.
    setArrowOrigin: function(origin) {
        if (this._arrowOrigin != origin) {
            this._arrowOrigin = origin;
            this._border.queue_repaint();
        }
    },
    // @actor: an actor relative to which the arrow is positioned.
    // Differently from setPosition, this will not move the boxpointer itself,
    // on the arrow
    setArrowActor: function(actor) {
        if (this._arrowActor != actor) {
            this._arrowActor = actor;
            this._border.queue_repaint();
        }
    },
    _shiftActor : function() {
        // Since the position of the BoxPointer depends on the allocated size
        // of the BoxPointer and the position of the source actor, trying
        // to position the BoxPointer via the x/y properties will result in
        // allocation loops and warnings. Instead we do the positioning via
        // the anchor point, which is independent of allocation, and leave
        // x == y == 0.
        this.actor.set_anchor_point(-(this._xPosition + this._xOffset),
                                    -(this._yPosition + this._yOffset));
    },
    _calculateArrowSide: function(arrowSide) {
        let sourceAllocation = Shell.util_get_transformed_allocation(this._sourceActor);
        let [minWidth, minHeight, boxWidth, boxHeight] = this._container.get_preferred_size();
        let monitor = Main.layoutManager.findMonitorForActor(this.actor);
        switch (arrowSide) {
        case St.Side.TOP:
            if (sourceAllocation.y2 + boxHeight > monitor.y + monitor.height &&
                boxHeight < sourceAllocation.y1 - monitor.y)
                return St.Side.BOTTOM;
            break;
        case St.Side.BOTTOM:
            if (sourceAllocation.y1 - boxHeight < monitor.y &&
                boxHeight < monitor.y + monitor.height - sourceAllocation.y2)
                return St.Side.TOP;
            break;
        case St.Side.LEFT:
            if (sourceAllocation.x2 + boxWidth > monitor.x + monitor.width &&
                boxWidth < sourceAllocation.x1 - monitor.x)
                return St.Side.RIGHT;
            break;
        case St.Side.RIGHT:
            if (sourceAllocation.x1 - boxWidth < monitor.x &&
                boxWidth < monitor.x + monitor.width - sourceAllocation.x2)
                return St.Side.LEFT;
            break;
        }
        return arrowSide;
    },
    _updateFlip: function() {
        let arrowSide = this._calculateArrowSide(this._userArrowSide);
        if (this._arrowSide != arrowSide) {
            this._arrowSide = arrowSide;
            this._reposition();
            Meta.later_add(Meta.LaterType.BEFORE_REDRAW, Lang.bind(this, function() {
                this._container.queue_relayout();
                return false;
            }));
            this.emit('arrow-side-changed');
        }
    },
    set xOffset(offset) {
        this._xOffset = offset;
        this._shiftActor();
    },
    get xOffset() {
        return this._xOffset;
    },
    set yOffset(offset) {
        this._yOffset = offset;
        this._shiftActor();
    },
    get yOffset() {
        return this._yOffset;
    },
    set opacity(opacity) {
        this.actor.opacity = opacity;
    },
    get opacity() {
        return this.actor.opacity;
    },
    updateArrowSide: function(side) {
        this._arrowSide = side;
        this._border.queue_repaint();
        this.emit('arrow-side-changed');
    },
    getPadding: function(side) {
        return this.bin.get_theme_node().get_padding(side);
    },
    getArrowHeight: function() {
        return this.actor.get_theme_node().get_length('-arrow-rise');
    }
Signals.addSignalMethods(BoxPointer.prototype);
(uuay)messageTray.js
// -*- mode: js; js-indent-level: 4; indent-tabs-mode: nil -*-
const Clutter = imports.gi.Clutter;
const GLib = imports.gi.GLib;
const Gio = imports.gi.Gio;
const GObject = imports.gi.GObject;
const Gtk = imports.gi.Gtk;
const Atk = imports.gi.Atk;
const Lang = imports.lang;
const Mainloop = imports.mainloop;
const Meta = imports.gi.Meta;
const Pango = imports.gi.Pango;
const Shell = imports.gi.Shell;
const Signals = imports.signals;
const St = imports.gi.St;
const Calendar = imports.ui.calendar;
const GnomeSession = imports.misc.gnomeSession;
const Layout = imports.ui.layout;
const Main = imports.ui.main;
const Params = imports.misc.params;
const Tweener = imports.ui.tweener;
const Util = imports.misc.util;
const SHELL_KEYBINDINGS_SCHEMA = 'org.gnome.shell.keybindings';
const ANIMATION_TIME = 0.2;
const NOTIFICATION_TIMEOUT = 4;
const HIDE_TIMEOUT = 0.2;
const LONGER_HIDE_TIMEOUT = 0.6;
const MAX_NOTIFICATIONS_IN_QUEUE = 3;
const MAX_NOTIFICATIONS_PER_SOURCE = 3;
const MAX_NOTIFICATION_BUTTONS = 3;
// We delay hiding of the tray if the mouse is within MOUSE_LEFT_ACTOR_THRESHOLD
// range from the point where it left the tray.
const MOUSE_LEFT_ACTOR_THRESHOLD = 20;
const IDLE_TIME = 1000;
const State = {
    HIDDEN:  0,
    SHOWING: 1,
    SHOWN:   2,
    HIDING:  3
// These reasons are useful when we destroy the notifications received through
// the notification daemon. We use EXPIRED for notifications that we dismiss
// and the user did not interact with, DISMISSED for all other notifications
// that were destroyed as a result of a user action, and SOURCE_CLOSED for the
// notifications that were requested to be destroyed by the associated source.
const NotificationDestroyedReason = {
    EXPIRED: 1,
    DISMISSED: 2,
    SOURCE_CLOSED: 3
// Message tray has its custom Urgency enumeration. LOW, NORMAL and CRITICAL
// urgency values map to the corresponding values for the notifications received
// through the notification daemon. HIGH urgency value is used for chats received
// through the Telepathy client.
const Urgency = {
    LOW: 0,
    NORMAL: 1,
    HIGH: 2,
    CRITICAL: 3
const FocusGrabber = new Lang.Class({
    Name: 'FocusGrabber',
    _init: function(actor) {
        this._actor = actor;
        this._prevKeyFocusActor = null;
        this._focusActorChangedId = 0;
        this._focused = false;
    },
    grabFocus: function() {
        if (this._focused)
            return;
        this._prevKeyFocusActor = global.stage.get_key_focus();
        this._focusActorChangedId = global.stage.connect('notify::key-focus', Lang.bind(this, this._focusActorChanged));
        if (!this._actor.navigate_focus(null, Gtk.DirectionType.TAB_FORWARD, false))
            this._actor.grab_key_focus();
        this._focused = true;
    },
    _focusUngrabbed: function() {
        if (!this._focused)
            return false;
        if (this._focusActorChangedId > 0) {
            global.stage.disconnect(this._focusActorChangedId);
            this._focusActorChangedId = 0;
        }
        this._focused = false;
        return true;
    },
    _focusActorChanged: function() {
        let focusedActor = global.stage.get_key_focus();
        if (!focusedActor || !this._actor.contains(focusedActor))
            this._focusUngrabbed();
    },
    ungrabFocus: function() {
        if (!this._focusUngrabbed())
            return;
        if (this._prevKeyFocusActor) {
            global.stage.set_key_focus(this._prevKeyFocusActor);
            this._prevKeyFocusActor = null;
        } else {
            let focusedActor = global.stage.get_key_focus();
            if (focusedActor && this._actor.contains(focusedActor))
                global.stage.set_key_focus(null);
        }
    }
// NotificationPolicy:
// An object that holds all bits of configurable policy related to a notification
// source, such as whether to play sound or honour the critical bit.
// A notification without a policy object will inherit the default one.
const NotificationPolicy = new Lang.Class({
    Name: 'NotificationPolicy',
    _init: function(params) {
        params = Params.parse(params, { enable: true,
                                        enableSound: true,
                                        showBanners: true,
                                        forceExpanded: false,
                                        showInLockScreen: true,
                                        detailsInLockScreen: false
                                      });
        Lang.copyProperties(params, this);
    },
    // Do nothing for the default policy. These methods are only useful for the
    // GSettings policy.
    store: function() { },
    destroy: function() { }
Signals.addSignalMethods(NotificationPolicy.prototype);
const NotificationGenericPolicy = new Lang.Class({
    Name: 'NotificationGenericPolicy',
    Extends: NotificationPolicy,
    _init: function() {
        // Don't chain to parent, it would try setting
        // our properties to the defaults
        this.id = 'generic';
        this._masterSettings = new Gio.Settings({ schema_id: 'org.gnome.desktop.notifications' });
        this._masterSettings.connect('changed', Lang.bind(this, this._changed));
    },
    store: function() { },
    destroy: function() {
        this._masterSettings.run_dispose();
    },
    _changed: function(settings, key) {
        this.emit('policy-changed', key);
    },
    get enable() {
        return true;
    },
    get enableSound() {
        return true;
    },
    get showBanners() {
        return this._masterSettings.get_boolean('show-banners');
    },
    get forceExpanded() {
        return false;
    },
    get showInLockScreen() {
        return this._masterSettings.get_boolean('show-in-lock-screen');
    },
    get detailsInLockScreen() {
        return false;
    }
const NotificationApplicationPolicy = new Lang.Class({
    Name: 'NotificationApplicationPolicy',
    Extends: NotificationPolicy,
    _init: function(id) {
        // Don't chain to parent, it would try setting
        // our properties to the defaults
        this.id = id;
        this._canonicalId = this._canonicalizeId(id);
        this._masterSettings = new Gio.Settings({ schema_id: 'org.gnome.desktop.notifications' });
        this._settings = new Gio.Settings({ schema_id: 'org.gnome.desktop.notifications.application',
                                            path: '/org/gnome/desktop/notifications/application/' + this._canonicalId + '/' });
        this._masterSettings.connect('changed', Lang.bind(this, this._changed));
        this._settings.connect('changed', Lang.bind(this, this._changed));
    },
    store: function() {
        this._settings.set_string('application-id', this.id + '.desktop');
        let apps = this._masterSettings.get_strv('application-children');
        if (apps.indexOf(this._canonicalId) < 0) {
            apps.push(this._canonicalId);
            this._masterSettings.set_strv('application-children', apps);
        }
    },
    destroy: function() {
        this._masterSettings.run_dispose();
        this._settings.run_dispose();
    },
    _changed: function(settings, key) {
        this.emit('policy-changed', key);
        if (key == 'enable')
            this.emit('enable-changed');
    },
    _canonicalizeId: function(id) {
        // Keys are restricted to lowercase alphanumeric characters and dash,
        // and two dashes cannot be in succession
        return id.toLowerCase().replace(/[^a-z0-9\-]/g, '-').replace(/--+/g, '-');
    },
    get enable() {
        return this._settings.get_boolean('enable');
    },
    get enableSound() {
        return this._settings.get_boolean('enable-sound-alerts');
    },
    get showBanners() {
        return this._masterSettings.get_boolean('show-banners') &&
            this._settings.get_boolean('show-banners');
    },
    get forceExpanded() {
        return this._settings.get_boolean('force-expanded');
    },
    get showInLockScreen() {
        return this._masterSettings.get_boolean('show-in-lock-screen') &&
            this._settings.get_boolean('show-in-lock-screen');
    },
    get detailsInLockScreen() {
        return this._settings.get_boolean('details-in-lock-screen');
    }
// Notification:
// @source: the notification's Source
// @title: the title
// @banner: the banner text
// @params: optional additional params
// Creates a notification. In the banner mode, the notification
// will show an icon, @title (in bold) and @banner, all on a single
// line (with @banner ellipsized if necessary).
// The notification will be expandable if either it has additional
// elements that were added to it or if the @banner text did not
// fit fully in the banner mode. When the notification is expanded,
// the @banner text from the top line is always removed. The complete
// @banner text is added as the first element in the content section,
// unless 'customContent' parameter with the value 'true' is specified
// in @params.
// Additional notification content can be added with addActor() and
// addBody() methods. The notification content is put inside a
// scrollview, so if it gets too tall, the notification will scroll
// rather than continue to grow. In addition to this main content
// area, there is also a single-row action area, which is not
// scrolled and can contain a single actor. The action area can
// be set by calling setActionArea() method. There is also a
// convenience method addButton() for adding a button to the action
// area.
// If @params contains a 'customContent' parameter with the value %true,
// then @banner will not be shown in the body of the notification when the
// notification is expanded and calls to update() will not clear the content
// unless 'clear' parameter with value %true is explicitly specified.
// By default, the icon shown is the same as the source's.
// However, if @params contains a 'gicon' parameter, the passed in gicon
// will be used.
// You can add a secondary icon to the banner with 'secondaryGIcon'. There
// is no fallback for this icon.
// If @params contains 'bannerMarkup', with the value %true, then
// the corresponding element is assumed to use pango markup. If the
// parameter is not present for an element, then anything that looks
// like markup in that element will appear literally in the output.
// If @params contains a 'clear' parameter with the value %true, then
// the content and the action area of the notification will be cleared.
// The content area is also always cleared if 'customContent' is false
// because it might contain the @banner that didn't fit in the banner mode.
// If @params contains 'soundName' or 'soundFile', the corresponding
// event sound is played when the notification is shown (if the policy for
// @source allows playing sounds).
const Notification = new Lang.Class({
    Name: 'Notification',
    _init: function(source, title, banner, params) {
        this.source = source;
        this.title = title;
        this.urgency = Urgency.NORMAL;
        this.resident = false;
        // 'transient' is a reserved keyword in JS, so we have to use an alternate variable name
        this.isTransient = false;
        this.forFeedback = false;
        this._acknowledged = false;
        this.bannerBodyText = null;
        this.bannerBodyMarkup = false;
        this._soundName = null;
        this._soundFile = null;
        this._soundPlayed = false;
        this.actions = [];
        // If called with only one argument we assume the caller
        // will call .update() later on. This is the case of
        // NotificationDaemon, which wants to use the same code
        // for new and updated notifications
        if (arguments.length != 1)
            this.update(title, banner, params);
    },
    // update:
    // @title: the new title
    // @banner: the new banner
    // @params: as in the Notification constructor
    //
    // Updates the notification by regenerating its icon and updating
    // the title/banner. If @params.clear is %true, it will also
    // remove any additional actors/action buttons previously added.
    update: function(title, banner, params) {
        params = Params.parse(params, { gicon: null,
                                        secondaryGIcon: null,
                                        bannerMarkup: false,
                                        clear: false,
                                        soundName: null,
                                        soundFile: null });
        this.title = title;
        this.bannerBodyText = banner;
        this.bannerBodyMarkup = params.bannerMarkup;
        if (params.gicon || params.clear)
            this.gicon = params.gicon;
        if (params.secondaryGIcon || params.clear)
            this.secondaryGIcon = params.secondaryGIcon;
        if (params.clear)
            this.actions = [];
        if (this._soundName != params.soundName ||
            this._soundFile != params.soundFile) {
            this._soundName = params.soundName;
            this._soundFile = params.soundFile;
            this._soundPlayed = false;
        }
        this.emit('updated', params.clear);
    },
    // addAction:
    // @label: the label for the action's button
    // @callback: the callback for the action
    addAction: function(label, callback) {
        this.actions.push({ label: label, callback: callback });
    },
    get acknowledged() {
        return this._acknowledged;
    },
    set acknowledged(v) {
        if (this._acknowledged == v)
            return;
        this._acknowledged = v;
        this.emit('acknowledged-changed');
    },
    setUrgency: function(urgency) {
        this.urgency = urgency;
    },
    setResident: function(resident) {
        this.resident = resident;
    },
    setTransient: function(isTransient) {
        this.isTransient = isTransient;
    },
    setForFeedback: function(forFeedback) {
        this.forFeedback = forFeedback;
    },
    playSound: function() {
        if (this._soundPlayed)
            return;
        if (!this.source.policy.enableSound) {
            this._soundPlayed = true;
            return;
        }
        if (this._soundName) {
            if (this.source.app) {
                let app = this.source.app;
                global.play_theme_sound_full(0, this._soundName,
                                             this.title, null,
                                             app.get_id(), app.get_name());
            } else {
                global.play_theme_sound(0, this._soundName, this.title, null);
            }
        } else if (this._soundFile) {
            if (this.source.app) {
                let app = this.source.app;
                global.play_sound_file_full(0, this._soundFile,
                                            this.title, null,
                                            app.get_id(), app.get_name());
            } else {
                global.play_sound_file(0, this._soundFile, this.title, null);
            }
        }
    },
    // Allow customizing the banner UI:
    // the default implementation defers the creation to
    // the source (which will create a NotificationBanner),
    // so customization can be done by subclassing either
    // Notification or Source
    createBanner: function() {
        return this.source.createBanner(this);
    },
    activate: function() {
        this.emit('activated');
        if (!this.resident)
            this.destroy();
    },
    destroy: function(reason) {
        if (!reason)
            reason = NotificationDestroyedReason.DISMISSED;
        this.emit('destroy', reason);
    }
Signals.addSignalMethods(Notification.prototype);
const NotificationBanner = new Lang.Class({
    Name: 'NotificationBanner',
    Extends: Calendar.NotificationMessage,
    _init: function(notification) {
        this.parent(notification);
        this.actor.can_focus = false;
        this.actor.add_style_class_name('notification-banner');
        this._buttonBox = null;
        this._addActions();
        this._addSecondaryIcon();
        this._activatedId = this.notification.connect('activated',
            Lang.bind(this, function() {
                // We hide all types of notifications once the user clicks on
                // them because the common outcome of clicking should be the
                // relevant window being brought forward and the user's
                // attention switching to the window.
                this.emit('done-displaying');
            }));
    },
    _onDestroy: function() {
        this.parent();
        this.notification.disconnect(this._activatedId);
    },
    _onUpdated: function(n, clear) {
        this.parent(n, clear);
        if (clear) {
            this.setSecondaryActor(null);
            this.setActionArea(null);
            this._buttonBox = null;
        }
        this._addActions();
        this._addSecondaryIcon();
    },
    _addActions: function() {
        this.notification.actions.forEach(Lang.bind(this,
            function(action) {
                this.addAction(action.label, action.callback);
            }));
    },
    _addSecondaryIcon: function() {
        if (this.notification.secondaryGIcon) {
            let icon = new St.Icon({ gicon: this.notification.secondaryGIcon });
            this.setSecondaryActor(icon);
        }
    },
    addButton: function(button, callback) {
        if (!this._buttonBox) {
            this._buttonBox = new St.BoxLayout({ style_class: 'notification-actions',
                                                 x_expand: true });
            this.setActionArea(this._buttonBox);
            global.focus_manager.add_group(this._buttonBox);
        }
        if (this._buttonBox.get_n_children() >= MAX_NOTIFICATION_BUTTONS)
            return null;
        this._buttonBox.add(button);
        button.connect('clicked', Lang.bind(this, function() {
            callback();
            if (!this.notification.resident) {
                // We don't hide a resident notification when the user invokes one of its actions,
                // because it is common for such notifications to update themselves with new
                // information based on the action. We'd like to display the updated information
                // in place, rather than pop-up a new notification.
                this.emit('done-displaying');
                this.notification.destroy();
            }
        }));
        return button;
    },
    addAction: function(label, callback) {
        let button = new St.Button({ style_class: 'notification-button',
                                     label: label,
                                     x_expand: true,
                                     can_focus: true });
        return this.addButton(button, callback);
    }
const SourceActor = new Lang.Class({
    Name: 'SourceActor',
    _init: function(source, size) {
        this._source = source;
        this._size = size;
        this.actor = new Shell.GenericContainer();
        this.actor.connect('get-preferred-width', Lang.bind(this, this._getPreferredWidth));
        this.actor.connect('get-preferred-height', Lang.bind(this, this._getPreferredHeight));
        this.actor.connect('allocate', Lang.bind(this, this._allocate));
        this.actor.connect('destroy', Lang.bind(this, function() {
            this._source.disconnect(this._iconUpdatedId);
            this._actorDestroyed = true;
        }));
        this._actorDestroyed = false;
        let scale_factor = St.ThemeContext.get_for_stage(global.stage).scale_factor;
        this._iconBin = new St.Bin({ x_fill: true,
                                     height: size * scale_factor,
                                     width: size * scale_factor });
        this.actor.add_actor(this._iconBin);
        this._iconUpdatedId = this._source.connect('icon-updated', Lang.bind(this, this._updateIcon));
        this._updateIcon();
    },
    setIcon: function(icon) {
        this._iconBin.child = icon;
        this._iconSet = true;
    },
    _getPreferredWidth: function (actor, forHeight, alloc) {
        let [min, nat] = this._iconBin.get_preferred_width(forHeight);
        alloc.min_size = min; alloc.nat_size = nat;
    },
    _getPreferredHeight: function (actor, forWidth, alloc) {
        let [min, nat] = this._iconBin.get_preferred_height(forWidth);
        alloc.min_size = min; alloc.nat_size = nat;
    },
    _allocate: function(actor, box, flags) {
        // the iconBin should fill our entire box
        this._iconBin.allocate(box, flags);
    },
    _updateIcon: function() {
        if (this._actorDestroyed)
            return;
        if (!this._iconSet)
            this._iconBin.child = this._source.createIcon(this._size);
    }
const SourceActorWithLabel = new Lang.Class({
    Name: 'SourceActorWithLabel',
    Extends: SourceActor,
    _init: function(source, size) {
        this.parent(source, size);
        this._counterLabel = new St.Label({ x_align: Clutter.ActorAlign.CENTER,
                                            x_expand: true,
                                            y_align: Clutter.ActorAlign.CENTER,
                                            y_expand: true });
        this._counterBin = new St.Bin({ style_class: 'summary-source-counter',
                                        child: this._counterLabel,
                                        layout_manager: new Clutter.BinLayout() });
        this._counterBin.hide();
        this._counterBin.connect('style-changed', Lang.bind(this, function() {
            let themeNode = this._counterBin.get_theme_node();
            this._counterBin.translation_x = themeNode.get_length('-shell-counter-overlap-x');
            this._counterBin.translation_y = themeNode.get_length('-shell-counter-overlap-y');
        }));
        this.actor.add_actor(this._counterBin);
        this._countUpdatedId = this._source.connect('count-updated', Lang.bind(this, this._updateCount));
        this._updateCount();
        this.actor.connect('destroy', function() {
            this._source.disconnect(this._countUpdatedId);
        });
    },
    _allocate: function(actor, box, flags) {
        this.parent(actor, box, flags);
        let childBox = new Clutter.ActorBox();
        let [minWidth, minHeight, naturalWidth, naturalHeight] = this._counterBin.get_preferred_size();
        let direction = this.actor.get_text_direction();
        if (direction == Clutter.TextDirection.LTR) {
            // allocate on the right in LTR
            childBox.x1 = box.x2 - naturalWidth;
            childBox.x2 = box.x2;
        } else {
            // allocate on the left in RTL
            childBox.x1 = 0;
            childBox.x2 = naturalWidth;
        }
        childBox.y1 = box.y2 - naturalHeight;
        childBox.y2 = box.y2;
        this._counterBin.allocate(childBox, flags);
    },
    _updateCount: function() {
        if (this._actorDestroyed)
            return;
        this._counterBin.visible = this._source.countVisible;
        let text;
        if (this._source.count < 100)
            text = this._source.count.toString();
        else
            text = String.fromCharCode(0x22EF); // midline horizontal ellipsis
        this._counterLabel.set_text(text);
    }
const Source = new Lang.Class({
    Name: 'MessageTraySource',
    SOURCE_ICON_SIZE: 48,
    _init: function(title, iconName) {
        this.title = title;
        this.iconName = iconName;
        this.isChat = false;
        this.notifications = [];
        this.policy = this._createPolicy();
    },
    get count() {
        return this.notifications.length;
    },
    get unseenCount() {
        return this.notifications.filter(function(n) { return !n.acknowledged; }).length;
    },
    get countVisible() {
        return this.count > 1;
    },
    countUpdated: function() {
        this.emit('count-updated');
    },
    _createPolicy: function() {
        return new NotificationPolicy();
    },
    setTitle: function(newTitle) {
        this.title = newTitle;
        this.emit('title-changed');
    },
    createBanner: function(notification) {
        return new NotificationBanner(notification);
    },
    // Called to create a new icon actor.
    // Provides a sane default implementation, override if you need
    // something more fancy.
    createIcon: function(size) {
        return new St.Icon({ gicon: this.getIcon(),
                             icon_size: size });
    },
    getIcon: function() {
        return new Gio.ThemedIcon({ name: this.iconName });
    },
    _onNotificationDestroy: function(notification) {
        let index = this.notifications.indexOf(notification);
        if (index < 0)
            return;
        this.notifications.splice(index, 1);
        if (this.notifications.length == 0)
            this.destroy();
        this.countUpdated();
    },
    pushNotification: function(notification) {
        if (this.notifications.indexOf(notification) >= 0)
            return;
        while (this.notifications.length >= MAX_NOTIFICATIONS_PER_SOURCE)
            this.notifications.shift().destroy(NotificationDestroyedReason.EXPIRED);
        notification.connect('destroy', Lang.bind(this, this._onNotificationDestroy));
        notification.connect('acknowledged-changed', Lang.bind(this, this.countUpdated));
        this.notifications.push(notification);
        this.emit('notification-added', notification);
        this.countUpdated();
    },
    notify: function(notification) {
        notification.acknowledged = false;
        this.pushNotification(notification);
        if (this.policy.showBanners) {
            this.emit('notify', notification);
        } else {
            notification.playSound();
        }
    },
    destroy: function(reason) {
        this.policy.destroy();
        let notifications = this.notifications;
        this.notifications = [];
        for (let i = 0; i < notifications.length; i++)
            notifications[i].destroy(reason);
        this.emit('destroy', reason);
    },
    iconUpdated: function() {
        this.emit('icon-updated');
    },
    // To be overridden by subclasses
    open: function() {
    },
    destroyNonResidentNotifications: function() {
        for (let i = this.notifications.length - 1; i >= 0; i--)
            if (!this.notifications[i].resident)
                this.notifications[i].destroy();
        this.countUpdated();
    }
Signals.addSignalMethods(Source.prototype);
const MessageTray = new Lang.Class({
    Name: 'MessageTray',
    _init: function() {
        this._presence = new GnomeSession.Presence(Lang.bind(this, function(proxy, error) {
            this._onStatusChanged(proxy.status);
        }));
        this._busy = false;
        this._bannerBlocked = false;
        this._presence.connectSignal('StatusChanged', Lang.bind(this, function(proxy, senderName, [status]) {
            this._onStatusChanged(status);
        }));
        global.stage.connect('enter-event', Lang.bind(this,
            function(a, ev) {
                // HACK: St uses ClutterInputDevice for hover tracking, which
                // misses relevant X11 events when untracked actors are
                // involved (read: the notification banner in normal mode),
                // so fix up Clutter's view of the pointer position in
                // that case.
                let related = ev.get_related();
                if (!related || this.actor.contains(related))
                    global.sync_pointer();
            }));
        this.actor = new St.Widget({ visible: false,
                                     clip_to_allocation: true,
                                     layout_manager: new Clutter.BinLayout() });
        let constraint = new Layout.MonitorConstraint({ primary: true });
        Main.layoutManager.panelBox.bind_property('visible',
                                                  constraint, 'work-area',
                                                  GObject.BindingFlags.SYNC_CREATE);
        this.actor.add_constraint(constraint);
        this._bannerBin = new St.Widget({ name: 'notification-container',
                                          reactive: true,
                                          track_hover: true,
                                          y_align: Clutter.ActorAlign.START,
                                          x_align: Clutter.ActorAlign.CENTER,
                                          y_expand: true,
                                          x_expand: true,
                                          layout_manager: new Clutter.BinLayout() });
        this._bannerBin.connect('key-release-event',
                                Lang.bind(this, this._onNotificationKeyRelease));
        this._bannerBin.connect('notify::hover',
                                Lang.bind(this, this._onNotificationHoverChanged));
        this.actor.add_actor(this._bannerBin);
        this._notificationFocusGrabber = new FocusGrabber(this._bannerBin);
        this._notificationQueue = [];
        this._notification = null;
        this._banner = null;
        this._bannerClickedId = 0;
        this._userActiveWhileNotificationShown = false;
        this.idleMonitor = Meta.IdleMonitor.get_core();
        this._useLongerNotificationLeftTimeout = false;
        // pointerInNotification is sort of a misnomer -- it tracks whether
        // a message tray notification should expand. The value is
        // partially driven by the hover state of the notification, but has
        // a lot of complex state related to timeouts and the current
        // state of the pointer when a notification pops up.
        this._pointerInNotification = false;
        // This tracks this._bannerBin.hover and is used to fizzle
        // out non-changing hover notifications in onNotificationHoverChanged.
        this._notificationHovered = false;
        this._notificationState = State.HIDDEN;
        this._notificationTimeoutId = 0;
        this._notificationRemoved = false;
        Main.layoutManager.addChrome(this.actor, { affectsInputRegion: false });
        Main.layoutManager.trackChrome(this._bannerBin, { affectsInputRegion: true });
        global.screen.connect('in-fullscreen-changed', Lang.bind(this, this._updateState));
        Main.sessionMode.connect('updated', Lang.bind(this, this._sessionUpdated));
        Main.overview.connect('window-drag-begin',
                              Lang.bind(this, this._onDragBegin));
        Main.overview.connect('window-drag-cancelled',
                              Lang.bind(this, this._onDragEnd));
        Main.overview.connect('window-drag-end',
                              Lang.bind(this, this._onDragEnd));
        Main.overview.connect('item-drag-begin',
                              Lang.bind(this, this._onDragBegin));
        Main.overview.connect('item-drag-cancelled',
                              Lang.bind(this, this._onDragEnd));
        Main.overview.connect('item-drag-end',
                              Lang.bind(this, this._onDragEnd));
        Main.xdndHandler.connect('drag-begin',
                                 Lang.bind(this, this._onDragBegin));
        Main.xdndHandler.connect('drag-end',
                                 Lang.bind(this, this._onDragEnd));
        Main.wm.addKeybinding('focus-active-notification',
                              new Gio.Settings({ schema_id: SHELL_KEYBINDINGS_SCHEMA }),
                              Meta.KeyBindingFlags.NONE,
                              Shell.ActionMode.NORMAL |
                              Shell.ActionMode.OVERVIEW,
                              Lang.bind(this, this._expandActiveNotification));
        this._sources = new Map();
        this._sessionUpdated();
    },
    _sessionUpdated: function() {
        this._updateState();
    },
    _onDragBegin: function() {
        Shell.util_set_hidden_from_pick(this.actor, true);
    },
    _onDragEnd: function() {
        Shell.util_set_hidden_from_pick(this.actor, false);
    },
    get bannerAlignment() {
        return this._bannerBin.get_x_align();
    },
    set bannerAlignment(align) {
        this._bannerBin.set_x_align(align);
    },
    _onNotificationKeyRelease: function(actor, event) {
        if (event.get_key_symbol() == Clutter.KEY_Escape && event.get_state() == 0) {
            this._expireNotification();
            return Clutter.EVENT_STOP;
        }
        return Clutter.EVENT_PROPAGATE;
    },
    _expireNotification: function() {
        this._notificationExpired = true;
        this._updateState();
    },
    get queueCount() {
        return this._notificationQueue.length;
    },
    set bannerBlocked(v) {
        if (this._bannerBlocked == v)
            return;
        this._bannerBlocked = v;
        this._updateState();
    },
    contains: function(source) {
        return this._sources.has(source);
    },
    add: function(source) {
        if (this.contains(source)) {
            log('Trying to re-add source ' + source.title);
            return;
        }
        // Register that we got a notification for this source
        source.policy.store();
        source.policy.connect('enable-changed', Lang.bind(this, this._onSourceEnableChanged, source));
        source.policy.connect('policy-changed', Lang.bind(this, this._updateState));
        this._onSourceEnableChanged(source.policy, source);
    },
    _addSource: function(source) {
        let obj = {
            source: source,
            notifyId: 0,
            destroyId: 0,
        };
        this._sources.set(source, obj);
        obj.notifyId = source.connect('notify', Lang.bind(this, this._onNotify));
        obj.destroyId = source.connect('destroy', Lang.bind(this, this._onSourceDestroy));
        this.emit('source-added', source);
    },
    _removeSource: function(source) {
        let obj = this._sources.get(source);
        this._sources.delete(source);
        source.disconnect(obj.notifyId);
        source.disconnect(obj.destroyId);
        this.emit('source-removed', source);
    },
    getSources: function() {
        return [k for (k of this._sources.keys())];
    },
    _onSourceEnableChanged: function(policy, source) {
        let wasEnabled = this.contains(source);
        let shouldBeEnabled = policy.enable;
        if (wasEnabled != shouldBeEnabled) {
            if (shouldBeEnabled)
                this._addSource(source);
            else
                this._removeSource(source);
        }
    },
    _onSourceDestroy: function(source) {
        this._removeSource(source);
    },
    _onNotificationDestroy: function(notification) {
        if (this._notification == notification && (this._notificationState == State.SHOWN || this._notificationState == State.SHOWING)) {
            this._updateNotificationTimeout(0);
            this._notificationRemoved = true;
            this._updateState();
            return;
        }
        let index = this._notificationQueue.indexOf(notification);
        if (index != -1) {
            this._notificationQueue.splice(index, 1);
            this.emit('queue-changed');
        }
    },
    _onNotify: function(source, notification) {
        if (this._notification == notification) {
            // If a notification that is being shown is updated, we update
            // how it is shown and extend the time until it auto-hides.
            // If a new notification is updated while it is being hidden,
            // we stop hiding it and show it again.
            this._updateShowingNotification();
        } else if (this._notificationQueue.indexOf(notification) < 0) {
            // If the queue is "full", we skip banner mode and just show a small
            // indicator in the panel; however do make an exception for CRITICAL
            // notifications, as only banner mode allows expansion.
            let bannerCount = this._notification ? 1 : 0;
            let full = (this.queueCount + bannerCount >= MAX_NOTIFICATIONS_IN_QUEUE);
            if (!full || notification.urgency == Urgency.CRITICAL) {
                notification.connect('destroy',
                                     Lang.bind(this, this._onNotificationDestroy));
                this._notificationQueue.push(notification);
                this._notificationQueue.sort(function(notification1, notification2) {
                    return (notification2.urgency - notification1.urgency);
                });
                this.emit('queue-changed');
            }
        }
        this._updateState();
    },
    _resetNotificationLeftTimeout: function() {
        this._useLongerNotificationLeftTimeout = false;
        if (this._notificationLeftTimeoutId) {
            Mainloop.source_remove(this._notificationLeftTimeoutId);
            this._notificationLeftTimeoutId = 0;
            this._notificationLeftMouseX = -1;
            this._notificationLeftMouseY = -1;
        }
    },
    _onNotificationHoverChanged: function() {
        if (this._bannerBin.hover == this._notificationHovered)
            return;
        this._notificationHovered = this._bannerBin.hover;
        if (this._notificationHovered) {
            this._resetNotificationLeftTimeout();
            if (this._showNotificationMouseX >= 0) {
                let actorAtShowNotificationPosition =
                    global.stage.get_actor_at_pos(Clutter.PickMode.ALL, this._showNotificationMouseX, this._showNotificationMouseY);
                this._showNotificationMouseX = -1;
                this._showNotificationMouseY = -1;
                // Don't set this._pointerInNotification to true if the pointer was initially in the area where the notification
                // popped up. That way we will not be expanding notifications that happen to pop up over the pointer
                // automatically. Instead, the user is able to expand the notification by mousing away from it and then
                // mousing back in. Because this is an expected action, we set the boolean flag that indicates that a longer
                // timeout should be used before popping down the notification.
                if (this._bannerBin.contains(actorAtShowNotificationPosition)) {
                    this._useLongerNotificationLeftTimeout = true;
                    return;
                }
            }
            this._pointerInNotification = true;
            this._updateState();
        } else {
            // We record the position of the mouse the moment it leaves the tray. These coordinates are used in
            // this._onNotificationLeftTimeout() to determine if the mouse has moved far enough during the initial timeout for us
            // to consider that the user intended to leave the tray and therefore hide the tray. If the mouse is still
            // close to its previous position, we extend the timeout once.
            let [x, y, mods] = global.get_pointer();
            this._notificationLeftMouseX = x;
            this._notificationLeftMouseY = y;
            // We wait just a little before hiding the message tray in case the user quickly moves the mouse back into it.
            // We wait for a longer period if the notification popped up where the mouse pointer was already positioned.
            // That gives the user more time to mouse away from the notification and mouse back in in order to expand it.
            let timeout = this._useLongerNotificationLeftTimeout ? LONGER_HIDE_TIMEOUT * 1000 : HIDE_TIMEOUT * 1000;
            this._notificationLeftTimeoutId = Mainloop.timeout_add(timeout, Lang.bind(this, this._onNotificationLeftTimeout));
            GLib.Source.set_name_by_id(this._notificationLeftTimeoutId, '[gnome-shell] this._onNotificationLeftTimeout');
        }
    },
    _onStatusChanged: function(status) {
        if (status == GnomeSession.PresenceStatus.BUSY) {
            // remove notification and allow the summary to be closed now
            this._updateNotificationTimeout(0);
            this._busy = true;
        } else if (status != GnomeSession.PresenceStatus.IDLE) {
            // We preserve the previous value of this._busy if the status turns to IDLE
            // so that we don't start showing notifications queued during the BUSY state
            // as the screensaver gets activated.
            this._busy = false;
        }
        this._updateState();
    },
    _onNotificationLeftTimeout: function() {
        let [x, y, mods] = global.get_pointer();
        // We extend the timeout once if the mouse moved no further than MOUSE_LEFT_ACTOR_THRESHOLD to either side.
        if (this._notificationLeftMouseX > -1 &&
            y < this._notificationLeftMouseY + MOUSE_LEFT_ACTOR_THRESHOLD &&
            y > this._notificationLeftMouseY - MOUSE_LEFT_ACTOR_THRESHOLD &&
            x < this._notificationLeftMouseX + MOUSE_LEFT_ACTOR_THRESHOLD &&
            x > this._notificationLeftMouseX - MOUSE_LEFT_ACTOR_THRESHOLD) {
            this._notificationLeftMouseX = -1;
            this._notificationLeftTimeoutId = Mainloop.timeout_add(LONGER_HIDE_TIMEOUT * 1000,
                                                             Lang.bind(this, this._onNotificationLeftTimeout));
            GLib.Source.set_name_by_id(this._notificationLeftTimeoutId, '[gnome-shell] this._onNotificationLeftTimeout');
        } else {
            this._notificationLeftTimeoutId = 0;
            this._useLongerNotificationLeftTimeout = false;
            this._pointerInNotification = false;
            this._updateNotificationTimeout(0);
            this._updateState();
        }
        return GLib.SOURCE_REMOVE;
    },
    _escapeTray: function() {
        this._pointerInNotification = false;
        this._updateNotificationTimeout(0);
        this._updateState();
    },
    // All of the logic for what happens when occurs here; the various
    // event handlers merely update variables such as
    // 'this._pointerInNotification', 'this._traySummoned', etc, and
    // _updateState() figures out what (if anything) needs to be done
    // at the present time.
    _updateState: function() {
        this.actor.visible = !this._bannerBlocked && this._banner != null;
        if (this._bannerBlocked)
            return;
        // If our state changes caused _updateState to be called,
        // just exit now to prevent reentrancy issues.
        if (this._updatingState)
            return;
        this._updatingState = true;
        // Filter out acknowledged notifications.
        let changed = false;
        this._notificationQueue = this._notificationQueue.filter(function(n) {
            changed = changed || n.acknowledged;
            return !n.acknowledged;
        });
        if (changed)
            this.emit('queue-changed');
        let hasNotifications = Main.sessionMode.hasNotifications;
        if (this._notificationState == State.HIDDEN) {
            let nextNotification = this._notificationQueue[0] || null;
            if (hasNotifications && nextNotification) {
                let limited = this._busy || Main.layoutManager.bottomMonitor.inFullscreen;
                let showNextNotification = (!limited || nextNotification.forFeedback || nextNotification.urgency == Urgency.CRITICAL);
                if (showNextNotification)
                    this._showNotification();
            }
        } else if (this._notificationState == State.SHOWN) {
            let expired = (this._userActiveWhileNotificationShown &&
                           this._notificationTimeoutId == 0 &&
                           this._notification.urgency != Urgency.CRITICAL &&
                           !this._banner.focused &&
                           !this._pointerInNotification) || this._notificationExpired;
            let mustClose = (this._notificationRemoved || !hasNotifications || expired);
            if (mustClose) {
                let animate = hasNotifications && !this._notificationRemoved;
                this._hideNotification(animate);
            } else if (this._pointerInNotification && !this._banner.expanded) {
                this._expandBanner(false);
            } else if (this._pointerInNotification) {
                this._ensureBannerFocused();
            }
        }
        this._updatingState = false;
        // Clean transient variables that are used to communicate actions
        // to updateState()
        this._notificationExpired = false;
    },
    _tween: function(actor, statevar, value, params) {
        let onComplete = params.onComplete;
        let onCompleteScope = params.onCompleteScope;
        let onCompleteParams = params.onCompleteParams;
        params.onComplete = this._tweenComplete;
        params.onCompleteScope = this;
        params.onCompleteParams = [statevar, value, onComplete, onCompleteScope, onCompleteParams];
        // Remove other tweens that could mess with the state machine
        Tweener.removeTweens(actor);
        Tweener.addTween(actor, params);
        let valuing = (value == State.SHOWN) ? State.SHOWING : State.HIDING;
        this[statevar] = valuing;
    },
    _tweenComplete: function(statevar, value, onComplete, onCompleteScope, onCompleteParams) {
        this[statevar] = value;
        if (onComplete)
            onComplete.apply(onCompleteScope, onCompleteParams);
        this._updateState();
    },
    _clampOpacity: function() {
        this._bannerBin.opacity = Math.max(0, Math.min(this._bannerBin._opacity, 255));
    },
    _onIdleMonitorBecameActive: function() {
        this._userActiveWhileNotificationShown = true;
        this._updateNotificationTimeout(2000);
        this._updateState();
    },
    _showNotification: function() {
        this._notification = this._notificationQueue.shift();
        this.emit('queue-changed');
        this._userActiveWhileNotificationShown = this.idleMonitor.get_idletime() <= IDLE_TIME;
        if (!this._userActiveWhileNotificationShown) {
            // If the user isn't active, set up a watch to let us know
            // when the user becomes active.
            this.idleMonitor.add_user_active_watch(Lang.bind(this, this._onIdleMonitorBecameActive));
        }
        this._banner = this._notification.createBanner();
        this._bannerClickedId = this._banner.connect('done-displaying',
                                                     Lang.bind(this, this._escapeTray));
        this._bannerUnfocusedId = this._banner.connect('unfocused', Lang.bind(this, function() {
            this._updateState();
        }));
        this._bannerBin.add_actor(this._banner.actor);
        this._bannerBin._opacity = 0;
        this._bannerBin.opacity = 0;
        this._bannerBin.y = -this._banner.actor.height;
        this.actor.show();
        this._updateShowingNotification();
        let [x, y, mods] = global.get_pointer();
        // We save the position of the mouse at the time when we started showing the notification
        // in order to determine if the notification popped up under it. We make that check if
        // the user starts moving the mouse and _onNotificationHoverChanged() gets called. We don't
        // expand the notification if it just happened to pop up under the mouse unless the user
        // explicitly mouses away from it and then mouses back in.
        this._showNotificationMouseX = x;
        this._showNotificationMouseY = y;
        // We save the coordinates of the mouse at the time when we started showing the notification
        // and then we update it in _notificationTimeout(). We don't pop down the notification if
        // the mouse is moving towards it or within it.
        this._lastSeenMouseX = x;
        this._lastSeenMouseY = y;
        this._resetNotificationLeftTimeout();
    },
    _updateShowingNotification: function() {
        this._notification.acknowledged = true;
        this._notification.playSound();
        // We auto-expand notifications with CRITICAL urgency, or for which the relevant setting
        // is on in the control center.
        if (this._notification.urgency == Urgency.CRITICAL ||
            this._notification.source.policy.forceExpanded)
            this._expandBanner(true);
        // We tween all notifications to full opacity. This ensures that both new notifications and
        // notifications that might have been in the process of hiding get full opacity.
        //
        // We tween any notification showing in the banner mode to the appropriate height
        // (which is banner height or expanded height, depending on the notification state)
        // This ensures that both new notifications and notifications in the banner mode that might
        // have been in the process of hiding are shown with the correct height.
        //
        // We use this._showNotificationCompleted() onComplete callback to extend the time the updated
        // notification is being shown.
        let tweenParams = { y: 0,
                            _opacity: 255,
                            time: ANIMATION_TIME,
                            transition: 'easeOutBack',
                            onUpdate: this._clampOpacity,
                            onUpdateScope: this,
                            onComplete: this._showNotificationCompleted,
                            onCompleteScope: this
                          };
        this._tween(this._bannerBin, '_notificationState', State.SHOWN, tweenParams);
   },
    _showNotificationCompleted: function() {
        if (this._notification.urgency != Urgency.CRITICAL)
            this._updateNotificationTimeout(NOTIFICATION_TIMEOUT * 1000);
    },
    _updateNotificationTimeout: function(timeout) {
        if (this._notificationTimeoutId) {
            Mainloop.source_remove(this._notificationTimeoutId);
            this._notificationTimeoutId = 0;
        }
        if (timeout > 0) {
            this._notificationTimeoutId =
                Mainloop.timeout_add(timeout,
                                     Lang.bind(this, this._notificationTimeout));
            GLib.Source.set_name_by_id(this._notificationTimeoutId, '[gnome-shell] this._notificationTimeout');
        }
    },
    _notificationTimeout: function() {
        let [x, y, mods] = global.get_pointer();
        if (y < this._lastSeenMouseY - 10 && !this._notificationHovered) {
            // The mouse is moving towards the notification, so don't
            // hide it yet. (We just create a new timeout (and destroy
            // the old one) each time because the bookkeeping is
            // simpler.)
            this._updateNotificationTimeout(1000);
        } else if (this._useLongerNotificationLeftTimeout && !this._notificationLeftTimeoutId &&
                  (x != this._lastSeenMouseX || y != this._lastSeenMouseY)) {
            // Refresh the timeout if the notification originally
            // popped up under the pointer, and the pointer is hovering
            // inside it.
            this._updateNotificationTimeout(1000);
        } else {
            this._notificationTimeoutId = 0;
            this._updateState();
        }
        this._lastSeenMouseX = x;
        this._lastSeenMouseY = y;
        return GLib.SOURCE_REMOVE;
    },
    _hideNotification: function(animate) {
        this._notificationFocusGrabber.ungrabFocus();
        if (this._bannerClickedId) {
            this._banner.disconnect(this._bannerClickedId);
            this._bannerClickedId = 0;
        }
        if (this._bannerUnfocusedId) {
            this._banner.disconnect(this._bannerUnfocusedId);
            this._bannerUnfocusedId = 0;
        }
        this._resetNotificationLeftTimeout();
        if (animate) {
            this._tween(this._bannerBin, '_notificationState', State.HIDDEN,
                        { y: -this._bannerBin.height,
                          _opacity: 0,
                          time: ANIMATION_TIME,
                          transition: 'easeOutBack',
                          onUpdate: this._clampOpacity,
                          onUpdateScope: this,
                          onComplete: this._hideNotificationCompleted,
                          onCompleteScope: this
                        });
        } else {
            Tweener.removeTweens(this._bannerBin);
            this._bannerBin.y = -this._bannerBin.height;
            this._bannerBin.opacity = 0;
            this._notificationState = State.HIDDEN;
            this._hideNotificationCompleted();
        }
    },
    _hideNotificationCompleted: function() {
        let notification = this._notification;
        this._notification = null;
        if (notification.isTransient)
            notification.destroy(NotificationDestroyedReason.EXPIRED);
        this._pointerInNotification = false;
        this._notificationRemoved = false;
        this._banner.actor.destroy();
        this._banner = null;
        this.actor.hide();
    },
    _expandActiveNotification: function() {
        if (!this._banner)
            return;
        this._expandBanner(false);
    },
    _expandBanner: function(autoExpanding) {
        // Don't animate changes in notifications that are auto-expanding.
        this._banner.expand(!autoExpanding);
        // Don't focus notifications that are auto-expanding.
        if (!autoExpanding)
            this._ensureBannerFocused();
    },
    _ensureBannerFocused: function() {
        this._notificationFocusGrabber.grabFocus();
    }
Signals.addSignalMethods(MessageTray.prototype);
const SystemNotificationSource = new Lang.Class({
    Name: 'SystemNotificationSource',
    Extends: Source,
    _init: function() {
        this.parent(_("System Information"), 'dialog-information-symbolic');
    },
    open: function() {
        this.destroy();
    }
(uuay)grabHelper.js
// -*- mode: js; js-indent-level: 4; indent-tabs-mode: nil -*-
const Clutter = imports.gi.Clutter;
const Gtk = imports.gi.Gtk;
const Lang = imports.lang;
const Meta = imports.gi.Meta;
const Shell = imports.gi.Shell;
const St = imports.gi.St;
const Main = imports.ui.main;
const Params = imports.misc.params;
let _capturedEventId = 0;
let _grabHelperStack = [];
function _onCapturedEvent(actor, event) {
    let grabHelper = _grabHelperStack[_grabHelperStack.length - 1];
    return grabHelper.onCapturedEvent(event);
function _pushGrabHelper(grabHelper) {
    _grabHelperStack.push(grabHelper);
    if (_capturedEventId == 0)
        _capturedEventId = global.stage.connect('captured-event', _onCapturedEvent);
function _popGrabHelper(grabHelper) {
    let poppedHelper = _grabHelperStack.pop();
    if (poppedHelper != grabHelper)
        throw new Error("incorrect grab helper pop");
    if (_grabHelperStack.length == 0) {
        global.stage.disconnect(_capturedEventId);
        _capturedEventId = 0;
    }
// GrabHelper:
// @owner: the actor that owns the GrabHelper
// @params: optional parameters to pass to Main.pushModal()
// Creates a new GrabHelper object, for dealing with keyboard and pointer grabs
// associated with a set of actors.
// Note that the grab can be automatically dropped at any time by the user, and
// your code just needs to deal with it; you shouldn't adjust behavior directly
// after you call ungrab(), but instead pass an 'onUngrab' callback when you
// call grab().
const GrabHelper = new Lang.Class({
    Name: 'GrabHelper',
    _init: function(owner, params) {
        this._owner = owner;
        this._modalParams = params;
        this._grabStack = [];
        this._actors = [];
        this._ignoreUntilRelease = false;
        this._modalCount = 0;
    },
    // addActor:
    // @actor: an actor
    //
    // Adds @actor to the set of actors that are allowed to process events
    // during a grab.
    addActor: function(actor) {
        actor.__grabHelperDestroyId = actor.connect('destroy', Lang.bind(this, function() { this.removeActor(actor); }));
        this._actors.push(actor);
    },
    // removeActor:
    // @actor: an actor
    //
    // Removes @actor from the set of actors that are allowed to
    // process events during a grab.
    removeActor: function(actor) {
        let index = this._actors.indexOf(actor);
        if (index != -1)
            this._actors.splice(index, 1);
        if (actor.__grabHelperDestroyId) {
            actor.disconnect(actor.__grabHelperDestroyId);
            delete actor.__grabHelperDestroyId;
        }
    },
    _isWithinGrabbedActor: function(actor) {
        let currentActor = this.currentGrab.actor;
        while (actor) {
            if (this._actors.indexOf(actor) != -1)
                return true;
            if (actor == currentActor)
                return true;
            actor = actor.get_parent();
        }
        return false;
    },
    get currentGrab() {
        return this._grabStack[this._grabStack.length - 1] || {};
    },
    get grabbed() {
        return this._grabStack.length > 0;
    },
    get grabStack() {
        return this._grabStack;
    },
    _findStackIndex: function(actor) {
        if (!actor)
            return -1;
        for (let i = 0; i < this._grabStack.length; i++) {
            if (this._grabStack[i].actor === actor)
                return i;
        }
        return -1;
    },
    _actorInGrabStack: function(actor) {
        while (actor) {
            let idx = this._findStackIndex(actor);
            if (idx >= 0)
                return idx;
            actor = actor.get_parent();
        }
        return -1;
    },
    isActorGrabbed: function(actor) {
        return this._findStackIndex(actor) >= 0;
    },
    // grab:
    // @params: A bunch of parameters, see below
    //
    // The general effect of a "grab" is to ensure that the passed in actor
    // and all actors inside the grab get exclusive control of the mouse and
    // keyboard, with the grab automatically being dropped if the user tries
    // to dismiss it. The actor is passed in through @params.actor.
    //
    // grab() can be called multiple times, with the scope of the grab being
    // changed to a different actor every time. A nested grab does not have
    // to have its grabbed actor inside the parent grab actors.
    //
    // Grabs can be automatically dropped if the user tries to dismiss it
    // in one of two ways: the user clicking outside the currently grabbed
    // actor, or the user typing the Escape key.
    //
    // If the user clicks outside the grabbed actors, and the clicked on
    // actor is part of a previous grab in the stack, grabs will be popped
    // until that grab is active. However, the click event will not be
    // replayed to the actor.
    //
    // If the user types the Escape key, one grab from the grab stack will
    // be popped.
    //
    // When a grab is popped by user interacting as described above, if you
    // pass a callback as @params.onUngrab, it will be called with %true.
    //
    // If @params.focus is not null, we'll set the key focus directly
    // to that actor instead of navigating in @params.actor. This is for
    // use cases like menus, where we want to grab the menu actor, but keep
    // focus on the clicked on menu item.
    grab: function(params) {
        params = Params.parse(params, { actor: null,
                                        focus: null,
                                        onUngrab: null });
        let focus = global.stage.key_focus;
        let hadFocus = focus && this._isWithinGrabbedActor(focus);
        let newFocus = params.actor;
        if (this.isActorGrabbed(params.actor))
            return true;
        params.savedFocus = focus;
        if (!this._takeModalGrab())
            return false;
        this._grabStack.push(params);
        if (params.focus) {
            params.focus.grab_key_focus();
        } else if (newFocus && hadFocus) {
            if (!newFocus.navigate_focus(null, Gtk.DirectionType.TAB_FORWARD, false))
                newFocus.grab_key_focus();
        }
        return true;
    },
    _takeModalGrab: function() {
        let firstGrab = (this._modalCount == 0);
        if (firstGrab) {
            if (!Main.pushModal(this._owner, this._modalParams))
                return false;
            _pushGrabHelper(this);
        }
        this._modalCount++;
        return true;
    },
    _releaseModalGrab: function() {
        this._modalCount--;
        if (this._modalCount > 0)
            return;
        _popGrabHelper(this);
        this._ignoreUntilRelease = false;
        Main.popModal(this._owner);
        global.sync_pointer();
    },
    // ignoreRelease:
    //
    // Make sure that the next button release event evaluated by the
    // capture event handler returns false. This is designed for things
    // like the ComboBoxMenu that go away on press, but need to eat
    // the next release event.
    ignoreRelease: function() {
        this._ignoreUntilRelease = true;
    },
    // ungrab:
    // @params: The parameters for the grab; see below.
    //
    // Pops @params.actor from the grab stack, potentially dropping
    // the grab. If the actor is not on the grab stack, this call is
    // ignored with no ill effects.
    //
    // If the actor is not at the top of the grab stack, grabs are
    // popped until the grabbed actor is at the top of the grab stack.
    // The onUngrab callback for every grab is called for every popped
    // grab with the parameter %false.
    ungrab: function(params) {
        params = Params.parse(params, { actor: this.currentGrab.actor,
                                        isUser: false });
        let grabStackIndex = this._findStackIndex(params.actor);
        if (grabStackIndex < 0)
            return;
        let focus = global.stage.key_focus;
        let hadFocus = focus && this._isWithinGrabbedActor(focus);
        let poppedGrabs = this._grabStack.slice(grabStackIndex);
        // "Pop" all newly ungrabbed actors off the grab stack
        // by truncating the array.
        this._grabStack.length = grabStackIndex;
        for (let i = poppedGrabs.length - 1; i >= 0; i--) {
            let poppedGrab = poppedGrabs[i];
            if (poppedGrab.onUngrab)
                poppedGrab.onUngrab(params.isUser);
            this._releaseModalGrab();
        }
        if (hadFocus) {
            let poppedGrab = poppedGrabs[0];
            if (poppedGrab.savedFocus)
                poppedGrab.savedFocus.grab_key_focus();
        }
    },
    onCapturedEvent: function(event) {
        let type = event.type();
        if (type == Clutter.EventType.KEY_PRESS &&
            event.get_key_symbol() == Clutter.KEY_Escape) {
            this.ungrab({ isUser: true });
            return Clutter.EVENT_STOP;
        }
        let motion = type == Clutter.EventType.MOTION;
        let press = type == Clutter.EventType.BUTTON_PRESS;
        let release = type == Clutter.EventType.BUTTON_RELEASE;
        let button = press || release;
        let touchUpdate = type == Clutter.EventType.TOUCH_UPDATE;
        let touchBegin = type == Clutter.EventType.TOUCH_BEGIN;
        let touchEnd = type == Clutter.EventType.TOUCH_END;
        let touch = touchUpdate || touchBegin || touchEnd;
        if (touch && !global.display.is_pointer_emulating_sequence (event.get_event_sequence()))
            return Clutter.EVENT_PROPAGATE;
        if (this._ignoreUntilRelease && (motion || release || touch)) {
            if (release || touchEnd)
                this._ignoreUntilRelease = false;
            return Clutter.EVENT_STOP;
        }
        if (this._isWithinGrabbedActor(event.get_source()))
            return Clutter.EVENT_PROPAGATE;
        if (Main.keyboard.shouldTakeEvent(event))
            return Clutter.EVENT_PROPAGATE;
        if (button || touchBegin) {
            // If we have a press event, ignore the next
            // motion/release events.
            if (press || touchBegin)
                this._ignoreUntilRelease = true;
            let i = this._actorInGrabStack(event.get_source()) + 1;
            this.ungrab({ actor: this._grabStack[i].actor, isUser: true });
            return Clutter.EVENT_STOP;
        }
        return Clutter.EVENT_STOP;
    },
(uuay)layout.js
// -*- mode: js; js-indent-level: 4; indent-tabs-mode: nil -*-
const Clutter = imports.gi.Clutter;
const GLib = imports.gi.GLib;
const GObject = imports.gi.GObject;
const Lang = imports.lang;
const Meta = imports.gi.Meta;
const Shell = imports.gi.Shell;
const Signals = imports.signals;
const St = imports.gi.St;
const Background = imports.ui.background;
const BackgroundMenu = imports.ui.backgroundMenu;
const LoginManager = imports.misc.loginManager;
const DND = imports.ui.dnd;
const Main = imports.ui.main;
const Params = imports.misc.params;
const Tweener = imports.ui.tweener;
const STARTUP_ANIMATION_TIME = 0.5;
const KEYBOARD_ANIMATION_TIME = 0.15;
const BACKGROUND_FADE_ANIMATION_TIME = 1.0;
const HOT_CORNER_PRESSURE_THRESHOLD = 100; // pixels
const HOT_CORNER_PRESSURE_TIMEOUT = 1000; // ms
function isPopupMetaWindow(actor) {
    switch(actor.meta_window.get_window_type()) {
    case Meta.WindowType.DROPDOWN_MENU:
    case Meta.WindowType.POPUP_MENU:
    case Meta.WindowType.COMBO:
        return true;
    default:
        return false;
    }
const MonitorConstraint = new Lang.Class({
    Name: 'MonitorConstraint',
    Extends: Clutter.Constraint,
    Properties: {'primary': GObject.ParamSpec.boolean('primary', 
                                                      'Primary', 'Track primary monitor',
                                                      GObject.ParamFlags.READABLE | GObject.ParamFlags.WRITABLE,
                                                      false),
                 'index': GObject.ParamSpec.int('index',
                                                'Monitor index', 'Track specific monitor',
                                                GObject.ParamFlags.READABLE | GObject.ParamFlags.WRITABLE,
                                                -1, 64, -1),
                 'work-area': GObject.ParamSpec.boolean('work-area',
                                                        'Work-area', 'Track monitor\'s work-area',
                                                        GObject.ParamFlags.READABLE | GObject.ParamFlags.WRITABLE,
                                                        false)},
    _init: function(props) {
        this._primary = false;
        this._index = -1;
        this._workArea = false;
        this.parent(props);
    },
    get primary() {
        return this._primary;
    },
    set primary(v) {
        if (v)
            this._index = -1;
        this._primary = v;
        if (this.actor)
            this.actor.queue_relayout();
        this.notify('primary');
    },
    get index() {
        return this._index;
    },
    set index(v) {
        this._primary = false;
        this._index = v;
        if (this.actor)
            this.actor.queue_relayout();
        this.notify('index');
    },
    get work_area() {
        return this._workArea;
    },
    set work_area(v) {
        if (v == this._workArea)
            return;
        this._workArea = v;
        if (this.actor)
            this.actor.queue_relayout();
        this.notify('work-area');
    },
    vfunc_set_actor: function(actor) {
        if (actor) {
            if (!this._monitorsChangedId) {
                this._monitorsChangedId = Main.layoutManager.connect('monitors-changed', Lang.bind(this, function() {
                    this.actor.queue_relayout();
                }));
            }
            if (!this._workareasChangedId) {
                this._workareasChangedId = global.screen.connect('workareas-changed', Lang.bind(this, function() {
                    if (this._workArea)
                        this.actor.queue_relayout();
                }));
            }
        } else {
            if (this._monitorsChangedId)
                Main.layoutManager.disconnect(this._monitorsChangedId);
            this._monitorsChangedId = 0;
            if (this._workareasChangedId)
                global.screen.disconnect(this._workareasChangedId);
            this._workareasChangedId = 0;
        }
        this.parent(actor);
    },
    vfunc_update_allocation: function(actor, actorBox) {
        if (!this._primary && this._index < 0)
            return;
        let index;
        if (this._primary)
            index = Main.layoutManager.primaryIndex;
        else
            index = Math.min(this._index, Main.layoutManager.monitors.length - 1);
        let rect;
        if (this._workArea) {
            let ws = global.screen.get_workspace_by_index(0);
            rect = ws.get_work_area_for_monitor(index);
        } else {
            rect = Main.layoutManager.monitors[index];
        }
        actorBox.init_rect(rect.x, rect.y, rect.width, rect.height);
    }
const Monitor = new Lang.Class({
    Name: 'Monitor',
    _init: function(index, geometry) {
        this.index = index;
        this.x = geometry.x;
        this.y = geometry.y;
        this.width = geometry.width;
        this.height = geometry.height;
    },
    get inFullscreen() {
        return global.screen.get_monitor_in_fullscreen(this.index);
    }
const defaultParams = {
    trackFullscreen: false,
    affectsStruts: false,
    affectsInputRegion: true
const LayoutManager = new Lang.Class({
    Name: 'LayoutManager',
    _init: function () {
        this._rtl = (Clutter.get_default_text_direction() == Clutter.TextDirection.RTL);
        this.monitors = [];
        this.primaryMonitor = null;
        this.primaryIndex = -1;
        this.hotCorners = [];
        this._keyboardIndex = -1;
        this._rightPanelBarrier = null;
        this._inOverview = false;
        this._updateRegionIdle = 0;
        this._trackedActors = [];
        this._topActors = [];
        this._isPopupWindowVisible = false;
        this._startingUp = true;
        // We don't want to paint the stage background color because either
        // the SystemBackground we create or the MetaBackgroundActor inside
        // global.window_group covers the entirety of the screen.
        global.stage.no_clear_hint = true;
        // Set up stage hierarchy to group all UI actors under one container.
        this.uiGroup = new Shell.GenericContainer({ name: 'uiGroup' });
        this.uiGroup.connect('allocate',
                        function (actor, box, flags) {
                            let children = actor.get_children();
                            for (let i = 0; i < children.length; i++)
                                children[i].allocate_preferred_size(flags);
                        });
        this.uiGroup.connect('get-preferred-width',
                        function(actor, forHeight, alloc) {
                            let width = global.stage.width;
                            [alloc.min_size, alloc.natural_size] = [width, width];
                        });
        this.uiGroup.connect('get-preferred-height',
                        function(actor, forWidth, alloc) {
                            let height = global.stage.height;
                            [alloc.min_size, alloc.natural_size] = [height, height];
                        });
        global.stage.remove_actor(global.window_group);
        this.uiGroup.add_actor(global.window_group);
        global.stage.add_child(this.uiGroup);
        this.overviewGroup = new St.Widget({ name: 'overviewGroup',
                                             visible: false,
                                             reactive: true });
        this.addChrome(this.overviewGroup);
        this.screenShieldGroup = new St.Widget({ name: 'screenShieldGroup',
                                                 visible: false,
                                                 clip_to_allocation: true,
                                                 layout_manager: new Clutter.BinLayout(),
                                               });
        this.addChrome(this.screenShieldGroup);
        this.panelBox = new St.BoxLayout({ name: 'panelBox',
                                           vertical: true });
        this.addChrome(this.panelBox, { affectsStruts: true,
                                        trackFullscreen: true });
        this.panelBox.connect('allocation-changed',
                              Lang.bind(this, this._panelBoxChanged));
        this.modalDialogGroup = new St.Widget({ name: 'modalDialogGroup',
                                                layout_manager: new Clutter.BinLayout() });
        this.uiGroup.add_actor(this.modalDialogGroup);
        this.keyboardBox = new St.BoxLayout({ name: 'keyboardBox',
                                              reactive: true,
                                              track_hover: true });
        this.addChrome(this.keyboardBox);
        this._keyboardHeightNotifyId = 0;
        // A dummy actor that tracks the mouse or text cursor, based on the
        // position and size set in setDummyCursorGeometry.
        this.dummyCursor = new St.Widget({ width: 0, height: 0, visible: false });
        this.uiGroup.add_actor(this.dummyCursor);
        global.stage.remove_actor(global.top_window_group);
        this.uiGroup.add_actor(global.top_window_group);
        let feedbackGroup = Meta.get_feedback_group_for_screen(global.screen);
        global.stage.remove_actor(feedbackGroup);
        this.uiGroup.add_actor(feedbackGroup);
        this._backgroundGroup = new Meta.BackgroundGroup();
        global.window_group.add_child(this._backgroundGroup);
        this._backgroundGroup.lower_bottom();
        this._bgManagers = [];
        // Need to update struts on new workspaces when they are added
        global.screen.connect('notify::n-workspaces',
                              Lang.bind(this, this._queueUpdateRegions));
        global.screen.connect('restacked',
                              Lang.bind(this, this._windowsRestacked));
        global.screen.connect('monitors-changed',
                              Lang.bind(this, this._monitorsChanged));
        global.screen.connect('in-fullscreen-changed',
                              Lang.bind(this, this._updateFullscreen));
        this._monitorsChanged();
        // NVIDIA drivers don't preserve FBO contents across
        // suspend/resume, see
        // https://bugzilla.gnome.org/show_bug.cgi?id=739178
        if (Shell.util_need_background_refresh()) {
            LoginManager.getLoginManager().connect('prepare-for-sleep',
                                                   function(lm, suspending) {
                                                       if (suspending)
                                                           return;
                                                       Meta.Background.refresh_all();
                                                   });
        }
    },
    // This is called by Main after everything else is constructed
    init: function() {
        Main.sessionMode.connect('updated', Lang.bind(this, this._sessionUpdated));
        this._loadBackground();
    },
    showOverview: function() {
        this.overviewGroup.show();
        this._inOverview = true;
        this._updateVisibility();
    },
    hideOverview: function() {
        this.overviewGroup.hide();
        this._inOverview = false;
        this._updateVisibility();
    },
    _sessionUpdated: function() {
        this._updateVisibility();
        this._queueUpdateRegions();
    },
    _updateMonitors: function() {
        let screen = global.screen;
        this.monitors = [];
        let nMonitors = screen.get_n_monitors();
        for (let i = 0; i < nMonitors; i++)
            this.monitors.push(new Monitor(i, screen.get_monitor_geometry(i)));
        if (nMonitors == 1) {
            this.primaryIndex = this.bottomIndex = 0;
        } else {
            // If there are monitors below the primary, then we need
            // to split primary from bottom.
            this.primaryIndex = this.bottomIndex = screen.get_primary_monitor();
            for (let i = 0; i < this.monitors.length; i++) {
                let monitor = this.monitors[i];
                if (this._isAboveOrBelowPrimary(monitor)) {
                    if (monitor.y > this.monitors[this.bottomIndex].y)
                        this.bottomIndex = i;
                }
            }
        }
        this.primaryMonitor = this.monitors[this.primaryIndex];
        this.bottomMonitor = this.monitors[this.bottomIndex];
    },
    _updateHotCorners: function() {
        // destroy old hot corners
        this.hotCorners.forEach(function(corner) {
            if (corner)
                corner.destroy();
        });
        this.hotCorners = [];
        let size = this.panelBox.height;
        // build new hot corners
        for (let i = 0; i < this.monitors.length; i++) {
            let monitor = this.monitors[i];
            let cornerX = this._rtl ? monitor.x + monitor.width : monitor.x;
            let cornerY = monitor.y;
            let haveTopLeftCorner = true;
            if (i != this.primaryIndex) {
                // Check if we have a top left (right for RTL) corner.
                // I.e. if there is no monitor directly above or to the left(right)
                let besideX = this._rtl ? monitor.x + 1 : cornerX - 1;
                let besideY = cornerY;
                let aboveX = cornerX;
                let aboveY = cornerY - 1;
                for (let j = 0; j < this.monitors.length; j++) {
                    if (i == j)
                        continue;
                    let otherMonitor = this.monitors[j];
                    if (besideX >= otherMonitor.x &&
                        besideX < otherMonitor.x + otherMonitor.width &&
                        besideY >= otherMonitor.y &&
                        besideY < otherMonitor.y + otherMonitor.height) {
                        haveTopLeftCorner = false;
                        break;
                    }
                    if (aboveX >= otherMonitor.x &&
                        aboveX < otherMonitor.x + otherMonitor.width &&
                        aboveY >= otherMonitor.y &&
                        aboveY < otherMonitor.y + otherMonitor.height) {
                        haveTopLeftCorner = false;
                        break;
                    }
                }
            }
            if (haveTopLeftCorner) {
                let corner = new HotCorner(this, monitor, cornerX, cornerY);
                corner.setBarrierSize(size);
                this.hotCorners.push(corner);
            } else {
                this.hotCorners.push(null);
            }
        }
        this.emit('hot-corners-changed');
    },
    _addBackgroundMenu: function(bgManager) {
        BackgroundMenu.addBackgroundMenu(bgManager.backgroundActor, this);
    },
    _createBackgroundManager: function(monitorIndex) {
        let bgManager = new Background.BackgroundManager({ container: this._backgroundGroup,
                                                           layoutManager: this,
                                                           monitorIndex: monitorIndex });
        bgManager.connect('changed', Lang.bind(this, this._addBackgroundMenu));
        this._addBackgroundMenu(bgManager);
        return bgManager;
    },
    _showSecondaryBackgrounds: function() {
        for (let i = 0; i < this.monitors.length; i++) {
            if (i != this.primaryIndex) {
                let backgroundActor = this._bgManagers[i].backgroundActor;
                backgroundActor.show();
                backgroundActor.opacity = 0;
                Tweener.addTween(backgroundActor,
                                 { opacity: 255,
                                   time: BACKGROUND_FADE_ANIMATION_TIME,
                                   transition: 'easeOutQuad' });
            }
        }
    },
    _updateBackgrounds: function() {
        let i;
        for (i = 0; i < this._bgManagers.length; i++)
            this._bgManagers[i].destroy();
        this._bgManagers = [];
        if (Main.sessionMode.isGreeter)
            return;
        for (let i = 0; i < this.monitors.length; i++) {
            let bgManager = this._createBackgroundManager(i);
            this._bgManagers.push(bgManager);
            if (i != this.primaryIndex && this._startingUp)
                bgManager.backgroundActor.hide();
        }
    },
    _updateKeyboardBox: function() {
        this.keyboardBox.set_position(this.keyboardMonitor.x,
                                      this.keyboardMonitor.y + this.keyboardMonitor.height);
        this.keyboardBox.set_size(this.keyboardMonitor.width, -1);
    },
    _updateBoxes: function() {
        this.screenShieldGroup.set_position(0, 0);
        this.screenShieldGroup.set_size(global.screen_width, global.screen_height);
        this.panelBox.set_position(this.primaryMonitor.x, this.primaryMonitor.y);
        this.panelBox.set_size(this.primaryMonitor.width, -1);
        this.keyboardIndex = this.primaryIndex;
    },
    _panelBoxChanged: function() {
        this._updatePanelBarrier();
        let size = this.panelBox.height;
        this.hotCorners.forEach(function(corner) {
            if (corner)
                corner.setBarrierSize(size);
        });
    },
    _updatePanelBarrier: function() {
        if (this._rightPanelBarrier) {
            this._rightPanelBarrier.destroy();
            this._rightPanelBarrier = null;
        }
        if (this.panelBox.height) {
            let primary = this.primaryMonitor;
            this._rightPanelBarrier = new Meta.Barrier({ display: global.display,
                                                         x1: primary.x + primary.width, y1: primary.y,
                                                         x2: primary.x + primary.width, y2: primary.y + this.panelBox.height,
                                                         directions: Meta.BarrierDirection.NEGATIVE_X });
        }
    },
    _monitorsChanged: function() {
        this._updateMonitors();
        this._updateBoxes();
        this._updateHotCorners();
        this._updateBackgrounds();
        this._updateFullscreen();
        this._updateVisibility();
        this._queueUpdateRegions();
        this.emit('monitors-changed');
    },
    _isAboveOrBelowPrimary: function(monitor) {
        let primary = this.monitors[this.primaryIndex];
        let monitorLeft = monitor.x, monitorRight = monitor.x + monitor.width;
        let primaryLeft = primary.x, primaryRight = primary.x + primary.width;
        if ((monitorLeft >= primaryLeft && monitorLeft < primaryRight) ||
            (monitorRight > primaryLeft && monitorRight <= primaryRight) ||
            (primaryLeft >= monitorLeft && primaryLeft < monitorRight) ||
            (primaryRight > monitorLeft && primaryRight <= monitorRight))
            return true;
        return false;
    },
    get currentMonitor() {
        let index = global.screen.get_current_monitor();
        return this.monitors[index];
    },
    get keyboardMonitor() {
        return this.monitors[this.keyboardIndex];
    },
    get focusIndex() {
        let i = Main.layoutManager.primaryIndex;
        if (global.stage.key_focus != null)
            i = this.findIndexForActor(global.stage.key_focus);
        else if (global.display.focus_window != null)
            i = global.display.focus_window.get_monitor();
        return i;
    },
    get focusMonitor() {
        return this.monitors[this.focusIndex];
    },
    set keyboardIndex(v) {
        this._keyboardIndex = v;
        this._updateKeyboardBox();
    },
    get keyboardIndex() {
        return this._keyboardIndex;
    },
    _loadBackground: function() {
        this._systemBackground = new Background.SystemBackground();
        this._systemBackground.actor.hide();
        global.stage.insert_child_below(this._systemBackground.actor, null);
        let constraint = new Clutter.BindConstraint({ source: global.stage,
                                                      coordinate: Clutter.BindCoordinate.ALL });
        this._systemBackground.actor.add_constraint(constraint);
        let signalId = this._systemBackground.connect('loaded', Lang.bind(this, function() {
            this._systemBackground.disconnect(signalId);
            this._systemBackground.actor.show();
            global.stage.show();
            this._prepareStartupAnimation();
        }));
    },
    // Startup Animations
    //
    // We have two different animations, depending on whether we're a greeter
    // or a normal session.
    //
    // In the greeter, we want to animate the panel from the top, and smoothly
    // fade the login dialog on top of whatever plymouth left on screen which
    // we get as a still frame background before drawing anything else.
    //
    // Here we just have the code to animate the panel, and fade up the background.
    // The login dialog animation is handled by modalDialog.js
    //
    // When starting a normal user session, we want to grow it out of the middle
    // of the screen.
    _prepareStartupAnimation: function() {
        // During the initial transition, add a simple actor to block all events,
        // so they don't get delivered to X11 windows that have been transformed.
        this._coverPane = new Clutter.Actor({ opacity: 0,
                                              width: global.screen_width,
                                              height: global.screen_height,
                                              reactive: true });
        this.addChrome(this._coverPane);
        if (Meta.is_restart()) {
            // On restart, we don't do an animation. Force an update of the
            // regions immediately so that maximized windows restore to the
            // right size taking struts into account.
            this._updateRegions();
        } else if (Main.sessionMode.isGreeter) {
            this.panelBox.translation_y = -this.panelBox.height;
        } else {
            this._updateBackgrounds();
            // We need to force an update of the regions now before we scale
            // the UI group to get the correct allocation for the struts.
            this._updateRegions();
            this.keyboardBox.hide();
            let monitor = this.primaryMonitor;
            let x = monitor.x + monitor.width / 2.0;
            let y = monitor.y + monitor.height / 2.0;
            this.uiGroup.set_pivot_point(x / global.screen_width,
                                         y / global.screen_height);
            this.uiGroup.scale_x = this.uiGroup.scale_y = 0.75;
            this.uiGroup.opacity = 0;
            global.window_group.set_clip(monitor.x, monitor.y, monitor.width, monitor.height);
        }
        this.emit('startup-prepared');
        // We're mostly prepared for the startup animation
        // now, but since a lot is going on asynchronously
        // during startup, let's defer the startup animation
        // until the event loop is uncontended and idle.
        // This helps to prevent us from running the animation
        // when the system is bogged down
        let id = GLib.idle_add(GLib.PRIORITY_LOW, Lang.bind(this, function() {
            this._startupAnimation();
            return GLib.SOURCE_REMOVE;
        }));
        GLib.Source.set_name_by_id(id, '[gnome-shell] this._startupAnimation');
    },
    _startupAnimation: function() {
        if (Meta.is_restart())
            this._startupAnimationComplete();
        else if (Main.sessionMode.isGreeter)
            this._startupAnimationGreeter();
        else
            this._startupAnimationSession();
    },
    _startupAnimationGreeter: function() {
        Tweener.addTween(this.panelBox,
                         { translation_y: 0,
                           time: STARTUP_ANIMATION_TIME,
                           transition: 'easeOutQuad',
                           onComplete: this._startupAnimationComplete,
                           onCompleteScope: this });
    },
    _startupAnimationSession: function() {
        Tweener.addTween(this.uiGroup,
                         { scale_x: 1,
                           scale_y: 1,
                           opacity: 255,
                           time: STARTUP_ANIMATION_TIME,
                           transition: 'easeOutQuad',
                           onComplete: this._startupAnimationComplete,
                           onCompleteScope: this });
    },
    _startupAnimationComplete: function() {
        this._coverPane.destroy();
        this._coverPane = null;
        this._systemBackground.actor.destroy();
        this._systemBackground = null;
        this._startingUp = false;
        this.keyboardBox.show();
        if (!Main.sessionMode.isGreeter) {
            this._showSecondaryBackgrounds();
            global.window_group.remove_clip();
        }
        this._queueUpdateRegions();
        this.emit('startup-complete');
    },
    showKeyboard: function () {
        Tweener.addTween(this.keyboardBox,
                         { anchor_y: this.keyboardBox.height,
                           time: KEYBOARD_ANIMATION_TIME,
                           transition: 'easeOutQuad',
                           onComplete: this._showKeyboardComplete,
                           onCompleteScope: this
                         });
        this.emit('keyboard-visible-changed', true);
    },
    _showKeyboardComplete: function() {
        // Poke Chrome to update the input shape; it doesn't notice
        // anchor point changes
        this._updateRegions();
        this._keyboardHeightNotifyId = this.keyboardBox.connect('notify::height', Lang.bind(this, function () {
            this.keyboardBox.anchor_y = this.keyboardBox.height;
        }));
    },
    hideKeyboard: function (immediate) {
        if (this._keyboardHeightNotifyId) {
            this.keyboardBox.disconnect(this._keyboardHeightNotifyId);
            this._keyboardHeightNotifyId = 0;
        }
        Tweener.addTween(this.keyboardBox,
                         { anchor_y: 0,
                           time: immediate ? 0 : KEYBOARD_ANIMATION_TIME,
                           transition: 'easeInQuad',
                           onComplete: this._hideKeyboardComplete,
                           onCompleteScope: this
                         });
        this.emit('keyboard-visible-changed', false);
    },
    _hideKeyboardComplete: function() {
        this._updateRegions();
    },
    // setDummyCursorGeometry:
    //
    // The cursor dummy is a standard widget commonly used for popup
    // menus and box pointers to track, as the box pointer API only
    // tracks actors. If you want to pop up a menu based on where the
    // user clicked, or where the text cursor is, the cursor dummy
    // is what you should use. Given that the menu should not track
    // the actual mouse pointer as it moves, you need to call this
    // function before you show the menu to ensure it is at the right
    // position and has the right size.
    setDummyCursorGeometry: function(x, y, w, h) {
        this.dummyCursor.set_position(Math.round(x), Math.round(y));
        this.dummyCursor.set_size(Math.round(w), Math.round(h));
    },
    // addChrome:
    // @actor: an actor to add to the chrome
    // @params: (optional) additional params
    //
    // Adds @actor to the chrome, and (unless %affectsInputRegion in
    // @params is %false) extends the input region to include it.
    // Changes in @actor's size, position, and visibility will
    // automatically result in appropriate changes to the input
    // region.
    //
    // If %affectsStruts in @params is %true (and @actor is along a
    // screen edge), then @actor's size and position will also affect
    // the window manager struts. Changes to @actor's visibility will
    // NOT affect whether or not the strut is present, however.
    //
    // If %trackFullscreen in @params is %true, the actor's visibility
    // will be bound to the presence of fullscreen windows on the same
    // monitor (it will be hidden whenever a fullscreen window is visible,
    // and shown otherwise)
    addChrome: function(actor, params) {
        this.uiGroup.add_actor(actor);
        if (this.uiGroup.contains(global.top_window_group))
            this.uiGroup.set_child_below_sibling(actor, global.top_window_group);
        this._trackActor(actor, params);
    },
    // trackChrome:
    // @actor: a descendant of the chrome to begin tracking
    // @params: parameters describing how to track @actor
    //
    // Tells the chrome to track @actor, which must be a descendant
    // of an actor added via addChrome(). This can be used to extend the
    // struts or input region to cover specific children.
    //
    // @params can have any of the same values as in addChrome(),
    // though some possibilities don't make sense. By default, @actor has
    // the same params as its chrome ancestor.
    trackChrome: function(actor, params) {
        let ancestor = actor.get_parent();
        let index = this._findActor(ancestor);
        while (ancestor && index == -1) {
            ancestor = ancestor.get_parent();
            index = this._findActor(ancestor);
        }
        if (!ancestor)
            throw new Error('actor is not a descendent of a chrome actor');
        let ancestorData = this._trackedActors[index];
        if (!params)
            params = {};
        // We can't use Params.parse here because we want to drop
        // the extra values like ancestorData.actor
        for (let prop in defaultParams) {
            if (!params.hasOwnProperty(prop))
                params[prop] = ancestorData[prop];
        }
        this._trackActor(actor, params);
    },
    // untrackChrome:
    // @actor: an actor previously tracked via trackChrome()
    //
    // Undoes the effect of trackChrome()
    untrackChrome: function(actor) {
        this._untrackActor(actor);
    },
    // removeChrome:
    // @actor: a chrome actor
    //
    // Removes @actor from the chrome
    removeChrome: function(actor) {
        this.uiGroup.remove_actor(actor);
        this._untrackActor(actor);
    },
    _findActor: function(actor) {
        for (let i = 0; i < this._trackedActors.length; i++) {
            let actorData = this._trackedActors[i];
            if (actorData.actor == actor)
                return i;
        }
        return -1;
    },
    _trackActor: function(actor, params) {
        if (this._findActor(actor) != -1)
            throw new Error('trying to re-track existing chrome actor');
        let actorData = Params.parse(params, defaultParams);
        actorData.actor = actor;
        actorData.visibleId = actor.connect('notify::visible',
                                            Lang.bind(this, this._queueUpdateRegions));
        actorData.allocationId = actor.connect('notify::allocation',
                                               Lang.bind(this, this._queueUpdateRegions));
        actorData.destroyId = actor.connect('destroy',
                                            Lang.bind(this, this._untrackActor));
        // Note that destroying actor will unset its parent, so we don't
        // need to connect to 'destroy' too.
        this._trackedActors.push(actorData);
        this._updateActorVisibility(actorData);
        this._queueUpdateRegions();
    },
    _untrackActor: function(actor) {
        let i = this._findActor(actor);
        if (i == -1)
            return;
        let actorData = this._trackedActors[i];
        this._trackedActors.splice(i, 1);
        actor.disconnect(actorData.visibleId);
        actor.disconnect(actorData.allocationId);
        actor.disconnect(actorData.destroyId);
        this._queueUpdateRegions();
    },
    _updateActorVisibility: function(actorData) {
        if (!actorData.trackFullscreen)
            return;
        let monitor = this.findMonitorForActor(actorData.actor);
        actorData.actor.visible = !(global.window_group.visible &&
                                    monitor &&
                                    monitor.inFullscreen);
    },
    _updateVisibility: function() {
        let windowsVisible = Main.sessionMode.hasWindows && !this._inOverview;
        global.window_group.visible = windowsVisible;
        global.top_window_group.visible = windowsVisible;
        this._trackedActors.forEach(Lang.bind(this, this._updateActorVisibility));
    },
    getWorkAreaForMonitor: function(monitorIndex) {
        // Assume that all workspaces will have the same
        // struts and pick the first one.
        let ws = global.screen.get_workspace_by_index(0);
        return ws.get_work_area_for_monitor(monitorIndex);
    },
    // This call guarantees that we return some monitor to simplify usage of it
    // In practice all tracked actors should be visible on some monitor anyway
    findIndexForActor: function(actor) {
        let [x, y] = actor.get_transformed_position();
        let [w, h] = actor.get_transformed_size();
        let rect = new Meta.Rectangle({ x: x, y: y, width: w, height: h });
        return global.screen.get_monitor_index_for_rect(rect);
    },
    findMonitorForActor: function(actor) {
        return this.monitors[this.findIndexForActor(actor)];
    },
    _queueUpdateRegions: function() {
        if (this._startingUp)
            return;
        if (!this._updateRegionIdle)
            this._updateRegionIdle = Meta.later_add(Meta.LaterType.BEFORE_REDRAW,
                                                    Lang.bind(this, this._updateRegions));
    },
    _getWindowActorsForWorkspace: function(workspace) {
        return global.get_window_actors().filter(function (actor) {
            let win = actor.meta_window;
            return win.located_on_workspace(workspace);
        });
    },
    _updateFullscreen: function() {
        this._updateVisibility();
        this._queueUpdateRegions();
    },
    _windowsRestacked: function() {
        let changed = false;
        if (this._isPopupWindowVisible != global.top_window_group.get_children().some(isPopupMetaWindow))
            changed = true;
        if (changed) {
            this._updateVisibility();
            this._queueUpdateRegions();
        }
    },
    _updateRegions: function() {
        if (this._updateRegionIdle) {
            Meta.later_remove(this._updateRegionIdle);
            delete this._updateRegionIdle;
        }
        // No need to update when we have a modal.
        if (Main.modalCount > 0)
            return GLib.SOURCE_REMOVE;
        // Bug workaround - get_transformed_position()/get_transformed_size() don't work after
        // a change in stage size until the first pick or paint.
        // https://bugzilla.gnome.org/show_bug.cgi?id=761565
        global.stage.get_actor_at_pos(Clutter.PickMode.ALL, 0, 0);
        let rects = [], struts = [], i;
        let isPopupMenuVisible = global.top_window_group.get_children().some(isPopupMetaWindow);
        let wantsInputRegion = !isPopupMenuVisible;
        for (i = 0; i < this._trackedActors.length; i++) {
            let actorData = this._trackedActors[i];
            if (!(actorData.affectsInputRegion && wantsInputRegion) && !actorData.affectsStruts)
                continue;
            let [x, y] = actorData.actor.get_transformed_position();
            let [w, h] = actorData.actor.get_transformed_size();
            x = Math.round(x);
            y = Math.round(y);
            w = Math.round(w);
            h = Math.round(h);
            if (actorData.affectsInputRegion && wantsInputRegion && actorData.actor.get_paint_visibility())
                rects.push(new Meta.Rectangle({ x: x, y: y, width: w, height: h }));
            if (actorData.affectsStruts) {
                // Limit struts to the size of the screen
                let x1 = Math.max(x, 0);
                let x2 = Math.min(x + w, global.screen_width);
                let y1 = Math.max(y, 0);
                let y2 = Math.min(y + h, global.screen_height);
                // Metacity wants to know what side of the monitor the
                // strut is considered to be attached to. First, we find
                // the monitor that contains the strut. If the actor is
                // only touching one edge, or is touching the entire
                // border of that monitor, then it's obvious which side
                // to call it. If it's in a corner, we pick a side
                // arbitrarily. If it doesn't touch any edges, or it
                // spans the width/height across the middle of the
                // screen, then we don't create a strut for it at all.
                let monitor = this.findMonitorForActor(actorData.actor);
                let side;
                if (x1 <= monitor.x && x2 >= monitor.x + monitor.width) {
                    if (y1 <= monitor.y)
                        side = Meta.Side.TOP;
                    else if (y2 >= monitor.y + monitor.height)
                        side = Meta.Side.BOTTOM;
                    else
                        continue;
                } else if (y1 <= monitor.y && y2 >= monitor.y + monitor.height) {
                    if (x1 <= monitor.x)
                        side = Meta.Side.LEFT;
                    else if (x2 >= monitor.x + monitor.width)
                        side = Meta.Side.RIGHT;
                    else
                        continue;
                } else if (x1 <= monitor.x)
                    side = Meta.Side.LEFT;
                else if (y1 <= monitor.y)
                    side = Meta.Side.TOP;
                else if (x2 >= monitor.x + monitor.width)
                    side = Meta.Side.RIGHT;
                else if (y2 >= monitor.y + monitor.height)
                    side = Meta.Side.BOTTOM;
                else
                    continue;
                let strutRect = new Meta.Rectangle({ x: x1, y: y1, width: x2 - x1, height: y2 - y1});
                let strut = new Meta.Strut({ rect: strutRect, side: side });
                struts.push(strut);
            }
        }
        global.set_stage_input_region(rects);
        this._isPopupWindowVisible = isPopupMenuVisible;
        let screen = global.screen;
        for (let w = 0; w < screen.n_workspaces; w++) {
            let workspace = screen.get_workspace_by_index(w);
            workspace.set_builtin_struts(struts);
        }
        return GLib.SOURCE_REMOVE;
    },
    modalEnded: function() {
        // We don't update the stage input region while in a modal,
        // so queue an update now.
        this._queueUpdateRegions();
    },
Signals.addSignalMethods(LayoutManager.prototype);
// HotCorner:
// This class manages a "hot corner" that can toggle switching to
// overview.
const HotCorner = new Lang.Class({
    Name: 'HotCorner',
    _init : function(layoutManager, monitor, x, y) {
        // We use this flag to mark the case where the user has entered the
        // hot corner and has not left both the hot corner and a surrounding
        // guard area (the "environs"). This avoids triggering the hot corner
        // multiple times due to an accidental jitter.
        this._entered = false;
        this._monitor = monitor;
        this._x = x;
        this._y = y;
        this._setupFallbackCornerIfNeeded(layoutManager);
        this._pressureBarrier = new PressureBarrier(HOT_CORNER_PRESSURE_THRESHOLD,
                                                    HOT_CORNER_PRESSURE_TIMEOUT,
                                                    Shell.ActionMode.NORMAL |
                                                    Shell.ActionMode.OVERVIEW);
        this._pressureBarrier.connect('trigger', Lang.bind(this, this._toggleOverview));
        // Cache the three ripples instead of dynamically creating and destroying them.
        this._ripple1 = new St.BoxLayout({ style_class: 'ripple-box', opacity: 0, visible: false });
        this._ripple2 = new St.BoxLayout({ style_class: 'ripple-box', opacity: 0, visible: false });
        this._ripple3 = new St.BoxLayout({ style_class: 'ripple-box', opacity: 0, visible: false });
        layoutManager.uiGroup.add_actor(this._ripple1);
        layoutManager.uiGroup.add_actor(this._ripple2);
        layoutManager.uiGroup.add_actor(this._ripple3);
    },
    setBarrierSize: function(size) {
        if (this._verticalBarrier) {
            this._pressureBarrier.removeBarrier(this._verticalBarrier);
            this._verticalBarrier.destroy();
            this._verticalBarrier = null;
        }
        if (this._horizontalBarrier) {
            this._pressureBarrier.removeBarrier(this._horizontalBarrier);
            this._horizontalBarrier.destroy();
            this._horizontalBarrier = null;
        }
        if (size > 0) {
            if (Clutter.get_default_text_direction() == Clutter.TextDirection.RTL) {
                this._verticalBarrier = new Meta.Barrier({ display: global.display,
                                                           x1: this._x, x2: this._x, y1: this._y, y2: this._y + size,
                                                           directions: Meta.BarrierDirection.NEGATIVE_X });
                this._horizontalBarrier = new Meta.Barrier({ display: global.display,
                                                             x1: this._x - size, x2: this._x, y1: this._y, y2: this._y,
                                                             directions: Meta.BarrierDirection.POSITIVE_Y });
            } else {
                this._verticalBarrier = new Meta.Barrier({ display: global.display,
                                                           x1: this._x, x2: this._x, y1: this._y, y2: this._y + size,
                                                           directions: Meta.BarrierDirection.POSITIVE_X });
                this._horizontalBarrier = new Meta.Barrier({ display: global.display,
                                                             x1: this._x, x2: this._x + size, y1: this._y, y2: this._y,
                                                             directions: Meta.BarrierDirection.POSITIVE_Y });
            }
            this._pressureBarrier.addBarrier(this._verticalBarrier);
            this._pressureBarrier.addBarrier(this._horizontalBarrier);
        }
    },
    _setupFallbackCornerIfNeeded: function(layoutManager) {
        if (!global.display.supports_extended_barriers()) {
            this.actor = new Clutter.Actor({ name: 'hot-corner-environs',
                                             x: this._x, y: this._y,
                                             width: 3,
                                             height: 3,
                                             reactive: true });
            this._corner = new Clutter.Actor({ name: 'hot-corner',
                                               width: 1,
                                               height: 1,
                                               opacity: 0,
                                               reactive: true });
            this._corner._delegate = this;
            this.actor.add_child(this._corner);
            layoutManager.addChrome(this.actor);
            if (Clutter.get_default_text_direction() == Clutter.TextDirection.RTL) {
                this._corner.set_position(this.actor.width - this._corner.width, 0);
                this.actor.set_anchor_point_from_gravity(Clutter.Gravity.NORTH_EAST);
            } else {
                this._corner.set_position(0, 0);
            }
            this.actor.connect('leave-event',
                               Lang.bind(this, this._onEnvironsLeft));
            this._corner.connect('enter-event',
                                 Lang.bind(this, this._onCornerEntered));
            this._corner.connect('leave-event',
                                 Lang.bind(this, this._onCornerLeft));
        }
    },
    destroy: function() {
        this.setBarrierSize(0);
        this._pressureBarrier.destroy();
        this._pressureBarrier = null;
        if (this.actor)
            this.actor.destroy();
    },
    _animRipple : function(ripple, delay, time, startScale, startOpacity, finalScale) {
        // We draw a ripple by using a source image and animating it scaling
        // outwards and fading away. We want the ripples to move linearly
        // or it looks unrealistic, but if the opacity of the ripple goes
        // linearly to zero it fades away too quickly, so we use Tweener's
        // 'onUpdate' to give a non-linear curve to the fade-away and make
        // it more visible in the middle section.
        ripple._opacity = startOpacity;
        if (ripple.get_text_direction() == Clutter.TextDirection.RTL)
            ripple.set_anchor_point_from_gravity(Clutter.Gravity.NORTH_EAST);
        ripple.visible = true;
        ripple.opacity = 255 * Math.sqrt(startOpacity);
        ripple.scale_x = ripple.scale_y = startScale;
        ripple.x = this._x;
        ripple.y = this._y;
        Tweener.addTween(ripple, { _opacity: 0,
                                   scale_x: finalScale,
                                   scale_y: finalScale,
                                   delay: delay,
                                   time: time,
                                   transition: 'linear',
                                   onUpdate: function() { ripple.opacity = 255 * Math.sqrt(ripple._opacity); },
                                   onComplete: function() { ripple.visible = false; } });
    },
    _rippleAnimation: function() {
        // Show three concentric ripples expanding outwards; the exact
        // parameters were found by trial and error, so don't look
        // for them to make perfect sense mathematically
        //                              delay  time  scale opacity => scale
        this._animRipple(this._ripple1, 0.0,   0.83,  0.25,  1.0,     1.5);
        this._animRipple(this._ripple2, 0.05,  1.0,   0.0,   0.7,     1.25);
        this._animRipple(this._ripple3, 0.35,  1.0,   0.0,   0.3,     1);
    },
    _toggleOverview: function() {
        if (this._monitor.inFullscreen)
            return;
        if (Main.overview.shouldToggleByCornerOrButton()) {
            this._rippleAnimation();
            Main.overview.toggle();
        }
    },
    handleDragOver: function(source, actor, x, y, time) {
        if (source != Main.xdndHandler)
            return DND.DragMotionResult.CONTINUE;
        this._toggleOverview();
        return DND.DragMotionResult.CONTINUE;
    },
    _onCornerEntered : function() {
        if (!this._entered) {
            this._entered = true;
            this._toggleOverview();
        }
        return Clutter.EVENT_PROPAGATE;
    },
    _onCornerLeft : function(actor, event) {
        if (event.get_related() != this.actor)
            this._entered = false;
        // Consume event, otherwise this will confuse onEnvironsLeft
        return Clutter.EVENT_STOP;
    },
    _onEnvironsLeft : function(actor, event) {
        if (event.get_related() != this._corner)
            this._entered = false;
        return Clutter.EVENT_PROPAGATE;
    }
const PressureBarrier = new Lang.Class({
    Name: 'PressureBarrier',
    _init: function(threshold, timeout, actionMode) {
        this._threshold = threshold;
        this._timeout = timeout;
        this._actionMode = actionMode;
        this._barriers = [];
        this._eventFilter = null;
        this._isTriggered = false;
        this._reset();
    },
    addBarrier: function(barrier) {
        barrier._pressureHitId = barrier.connect('hit', Lang.bind(this, this._onBarrierHit));
        barrier._pressureLeftId = barrier.connect('left', Lang.bind(this, this._onBarrierLeft));
        this._barriers.push(barrier);
    },
    _disconnectBarrier: function(barrier) {
        barrier.disconnect(barrier._pressureHitId);
        barrier.disconnect(barrier._pressureLeftId);
    },
    removeBarrier: function(barrier) {
        this._disconnectBarrier(barrier);
        this._barriers.splice(this._barriers.indexOf(barrier), 1);
    },
    destroy: function() {
        this._barriers.forEach(Lang.bind(this, this._disconnectBarrier));
        this._barriers = [];
    },
    setEventFilter: function(filter) {
        this._eventFilter = filter;
    },
    _reset: function() {
        this._barrierEvents = [];
        this._currentPressure = 0;
        this._lastTime = 0;
    },
    _isHorizontal: function(barrier) {
        return barrier.y1 == barrier.y2;
    },
    _getDistanceAcrossBarrier: function(barrier, event) {
        if (this._isHorizontal(barrier))
            return Math.abs(event.dy);
        else
            return Math.abs(event.dx);
    },
    _getDistanceAlongBarrier: function(barrier, event) {
        if (this._isHorizontal(barrier))
            return Math.abs(event.dx);
        else
            return Math.abs(event.dy);
    },
    _trimBarrierEvents: function() {
        // Events are guaranteed to be sorted in time order from
        // oldest to newest, so just look for the first old event,
        // and then chop events after that off.
        let i = 0;
        let threshold = this._lastTime - this._timeout;
        while (i < this._barrierEvents.length) {
            let [time, distance] = this._barrierEvents[i];
            if (time >= threshold)
                break;
            i++;
        }
        let firstNewEvent = i;
        for (i = 0; i < firstNewEvent; i++) {
            let [time, distance] = this._barrierEvents[i];
            this._currentPressure -= distance;
        }
        this._barrierEvents = this._barrierEvents.slice(firstNewEvent);
    },
    _onBarrierLeft: function(barrier, event) {
        barrier._isHit = false;
        if (this._barriers.every(function(b) { return !b._isHit; })) {
            this._reset();
            this._isTriggered = false;
        }
    },
    _trigger: function() {
        this._isTriggered = true;
        this.emit('trigger');
        this._reset();
    },
    _onBarrierHit: function(barrier, event) {
        barrier._isHit = true;
        // If we've triggered the barrier, wait until the pointer has the
        // left the barrier hitbox until we trigger it again.
        if (this._isTriggered)
            return;
        if (this._eventFilter && this._eventFilter(event))
            return;
        // Throw out all events not in the proper keybinding mode
        if (!(this._actionMode & Main.actionMode))
            return;
        let slide = this._getDistanceAlongBarrier(barrier, event);
        let distance = this._getDistanceAcrossBarrier(barrier, event);
        if (distance >= this._threshold) {
            this._trigger();
            return;
        }
        // Throw out events where the cursor is move more
        // along the axis of the barrier than moving with
        // the barrier.
        if (slide > distance)
            return;
        this._lastTime = event.time;
        this._trimBarrierEvents();
        distance = Math.min(15, distance);
        this._barrierEvents.push([event.time, distance]);
        this._currentPressure += distance;
        if (this._currentPressure >= this._threshold)
            this._trigger();
    }
Signals.addSignalMethods(PressureBarrier.prototype);
(uuay)gdm/
calendar.js
// -*- mode: js; js-indent-level: 4; indent-tabs-mode: nil -*-
const Clutter = imports.gi.Clutter;
const Gio = imports.gi.Gio;
const GLib = imports.gi.GLib;
const Gtk = imports.gi.Gtk;
const Lang = imports.lang;
const St = imports.gi.St;
const Signals = imports.signals;
const Gettext_gtk30 = imports.gettext.domain('gtk30');
const Shell = imports.gi.Shell;
const Main = imports.ui.main;
const MessageList = imports.ui.messageList;
const MessageTray = imports.ui.messageTray;
const Mpris = imports.ui.mpris;
const Util = imports.misc.util;
const MSECS_IN_DAY = 24 * 60 * 60 * 1000;
const SHOW_WEEKDATE_KEY = 'show-weekdate';
const ELLIPSIS_CHAR = '\u2026';
const MESSAGE_ICON_SIZE = 32;
// alias to prevent xgettext from picking up strings translated in GTK+
const gtk30_ = Gettext_gtk30.gettext;
const NC_ = function(context, str) { return context + '\u0004' + str; };
function sameYear(dateA, dateB) {
    return (dateA.getYear() == dateB.getYear());
function sameMonth(dateA, dateB) {
    return sameYear(dateA, dateB) && (dateA.getMonth() == dateB.getMonth());
function sameDay(dateA, dateB) {
    return sameMonth(dateA, dateB) && (dateA.getDate() == dateB.getDate());
function isToday(date) {
    return sameDay(new Date(), date);
function _isWorkDay(date) {
    /* Translators: Enter 0-6 (Sunday-Saturday) for non-work days. Examples: "0" (Sunday) "6" (Saturday) "06" (Sunday and Saturday). */
    let days = C_('calendar-no-work', "06");
    return days.indexOf(date.getDay().toString()) == -1;
function _getBeginningOfDay(date) {
    let ret = new Date(date.getTime());
    ret.setHours(0);
    ret.setMinutes(0);
    ret.setSeconds(0);
    ret.setMilliseconds(0);
    return ret;
function _getEndOfDay(date) {
    let ret = new Date(date.getTime());
    ret.setHours(23);
    ret.setMinutes(59);
    ret.setSeconds(59);
    ret.setMilliseconds(999);
    return ret;
function _getCalendarDayAbbreviation(dayNumber) {
    let abbreviations = [
        /* Translators: Calendar grid abbreviation for Sunday.
         *
         * NOTE: These grid abbreviations are always shown together
         * and in order, e.g. "S M T W T F S".
         */
        NC_("grid sunday", "S"),
        /* Translators: Calendar grid abbreviation for Monday */
        NC_("grid monday", "M"),
        /* Translators: Calendar grid abbreviation for Tuesday */
        NC_("grid tuesday", "T"),
        /* Translators: Calendar grid abbreviation for Wednesday */
        NC_("grid wednesday", "W"),
        /* Translators: Calendar grid abbreviation for Thursday */
        NC_("grid thursday", "T"),
        /* Translators: Calendar grid abbreviation for Friday */
        NC_("grid friday", "F"),
        /* Translators: Calendar grid abbreviation for Saturday */
        NC_("grid saturday", "S")
    ];
    return Shell.util_translate_time_string(abbreviations[dayNumber]);
// Abstraction for an appointment/event in a calendar
const CalendarEvent = new Lang.Class({
    Name: 'CalendarEvent',
    _init: function(id, date, end, summary, allDay) {
        this.id = id;
        this.date = date;
        this.end = end;
        this.summary = summary;
        this.allDay = allDay;
    }
// Interface for appointments/events - e.g. the contents of a calendar
// First, an implementation with no events
const EmptyEventSource = new Lang.Class({
    Name: 'EmptyEventSource',
    _init: function() {
        this.isLoading = false;
        this.isDummy = true;
        this.hasCalendars = false;
    },
    destroy: function() {
    },
    ignoreEvent: function(event) {
    },
    requestRange: function(begin, end) {
    },
    getEvents: function(begin, end) {
        let result = [];
        return result;
    },
    hasEvents: function(day) {
        return false;
    }
Signals.addSignalMethods(EmptyEventSource.prototype);
const CalendarServerIface = '<node> \
<interface name="org.gnome.Shell.CalendarServer"> \
<method name="GetEvents"> \
    <arg type="x" direction="in" /> \
    <arg type="x" direction="in" /> \
    <arg type="b" direction="in" /> \
    <arg type="a(sssbxxa{sv})" direction="out" /> \
</method> \
<property name="HasCalendars" type="b" access="read" /> \
<signal name="Changed" /> \
</interface> \
</node>';
const CalendarServerInfo  = Gio.DBusInterfaceInfo.new_for_xml(CalendarServerIface);
function CalendarServer() {
    return new Gio.DBusProxy({ g_connection: Gio.DBus.session,
                               g_interface_name: CalendarServerInfo.name,
                               g_interface_info: CalendarServerInfo,
                               g_name: 'org.gnome.Shell.CalendarServer',
                               g_object_path: '/org/gnome/Shell/CalendarServer' });
function _datesEqual(a, b) {
    if (a < b)
        return false;
    else if (a > b)
        return false;
    return true;
function _dateIntervalsOverlap(a0, a1, b0, b1)
    if (a1 <= b0)
        return false;
    else if (b1 <= a0)
        return false;
    else
        return true;
// an implementation that reads data from a session bus service
const DBusEventSource = new Lang.Class({
    Name: 'DBusEventSource',
    _init: function() {
        this._resetCache();
        this.isLoading = false;
        this.isDummy = false;
        this._ignoredEvents = new Map();
        let savedState = global.get_persistent_state('as', 'ignored_events');
        if (savedState)
            savedState.deep_unpack().forEach(Lang.bind(this,
                function(eventId) {
                    this._ignoredEvents.set(eventId, true);
                }));
        this._initialized = false;
        this._dbusProxy = new CalendarServer();
        this._dbusProxy.init_async(GLib.PRIORITY_DEFAULT, null, Lang.bind(this, function(object, result) {
            let loaded = false;
            try {
                this._dbusProxy.init_finish(result);
                loaded = true;
            } catch(e) {
                if (e.matches(Gio.DBusError, Gio.DBusError.TIMED_OUT)) {
                    // Ignore timeouts and install signals as normal, because with high
                    // probability the service will appear later on, and we will get a
                    // NameOwnerChanged which will finish loading
                    //
                    // (But still _initialized to false, because the proxy does not know
                    // about the HasCalendars property and would cause an exception trying
                    // to read it)
                } else {
                    log('Error loading calendars: ' + e.message);
                    return;
                }
            }
            this._dbusProxy.connectSignal('Changed', Lang.bind(this, this._onChanged));
            this._dbusProxy.connect('notify::g-name-owner', Lang.bind(this, function() {
                if (this._dbusProxy.g_name_owner)
                    this._onNameAppeared();
                else
                    this._onNameVanished();
            }));
            this._dbusProxy.connect('g-properties-changed', Lang.bind(this, function() {
                this.emit('notify::has-calendars');
            }));
            this._initialized = loaded;
            if (loaded) {
                this.emit('notify::has-calendars');
                this._onNameAppeared();
            }
        }));
    },
    destroy: function() {
        this._dbusProxy.run_dispose();
    },
    get hasCalendars() {
        if (this._initialized)
            return this._dbusProxy.HasCalendars;
        else
            return false;
    },
    _resetCache: function() {
        this._events = [];
        this._lastRequestBegin = null;
        this._lastRequestEnd = null;
    },
    _onNameAppeared: function(owner) {
        this._initialized = true;
        this._resetCache();
        this._loadEvents(true);
    },
    _onNameVanished: function(oldOwner) {
        this._resetCache();
        this.emit('changed');
    },
    _onChanged: function() {
        this._loadEvents(false);
    },
    _onEventsReceived: function(results, error) {
        let newEvents = [];
        let appointments = results ? results[0] : null;
        if (appointments != null) {
            for (let n = 0; n < appointments.length; n++) {
                let a = appointments[n];
                let date = new Date(a[4] * 1000);
                let end = new Date(a[5] * 1000);
                let id = a[0];
                let summary = a[1];
                let allDay = a[3];
                let event = new CalendarEvent(id, date, end, summary, allDay);
                newEvents.push(event);
            }
            newEvents.sort(function(event1, event2) {
                return event1.date.getTime() - event2.date.getTime();
            });
        }
        this._events = newEvents;
        this.isLoading = false;
        this.emit('changed');
    },
    _loadEvents: function(forceReload) {
        // Ignore while loading
        if (!this._initialized)
            return;
        if (this._curRequestBegin && this._curRequestEnd){
            this._dbusProxy.GetEventsRemote(this._curRequestBegin.getTime() / 1000,
                                            this._curRequestEnd.getTime() / 1000,
                                            forceReload,
                                            Lang.bind(this, this._onEventsReceived),
                                            Gio.DBusCallFlags.NONE);
        }
    },
    ignoreEvent: function(event) {
        if (this._ignoredEvents.get(event.id))
            return;
        this._ignoredEvents.set(event.id, true);
        let savedState = new GLib.Variant('as', [...this._ignoredEvents.keys()]);
        global.set_persistent_state('ignored_events', savedState);
        this.emit('changed');
    },
    requestRange: function(begin, end) {
        if (!(_datesEqual(begin, this._lastRequestBegin) && _datesEqual(end, this._lastRequestEnd))) {
            this.isLoading = true;
            this._lastRequestBegin = begin;
            this._lastRequestEnd = end;
            this._curRequestBegin = begin;
            this._curRequestEnd = end;
            this._loadEvents(false);
        }
    },
    getEvents: function(begin, end) {
        let result = [];
        for(let n = 0; n < this._events.length; n++) {
            let event = this._events[n];
            if (this._ignoredEvents.has(event.id))
                continue;
            if (_dateIntervalsOverlap (event.date, event.end, begin, end)) {
                result.push(event);
            }
        }
        result.sort(function(event1, event2) {
            // sort events by end time on ending day
            let d1 = event1.date < begin && event1.end <= end ? event1.end : event1.date;
            let d2 = event2.date < begin && event2.end <= end ? event2.end : event2.date;
            return d1.getTime() - d2.getTime();
        });
        return result;
    },
    hasEvents: function(day) {
        let dayBegin = _getBeginningOfDay(day);
        let dayEnd = _getEndOfDay(day);
        let events = this.getEvents(dayBegin, dayEnd);
        if (events.length == 0)
            return false;
        return true;
    }
Signals.addSignalMethods(DBusEventSource.prototype);
const Calendar = new Lang.Class({
    Name: 'Calendar',
    _init: function() {
        this._weekStart = Shell.util_get_week_start();
        this._settings = new Gio.Settings({ schema_id: 'org.gnome.desktop.calendar' });
        this._settings.connect('changed::' + SHOW_WEEKDATE_KEY, Lang.bind(this, this._onSettingsChange));
        this._useWeekdate = this._settings.get_boolean(SHOW_WEEKDATE_KEY);
        // Find the ordering for month/year in the calendar heading
        this._headerFormatWithoutYear = '%B';
        switch (gtk30_('calendar:MY')) {
        case 'calendar:MY':
            this._headerFormat = '%B %Y';
            break;
        case 'calendar:YM':
            this._headerFormat = '%Y %B';
            break;
        default:
            log('Translation of "calendar:MY" in GTK+ is not correct');
            this._headerFormat = '%B %Y';
            break;
        }
        // Start off with the current date
        this._selectedDate = new Date();
        this._shouldDateGrabFocus = false;
        this.actor = new St.Widget({ style_class: 'calendar',
                                     layout_manager: new Clutter.TableLayout(),
                                     reactive: true });
        this.actor.connect('scroll-event',
                           Lang.bind(this, this._onScroll));
        this._buildHeader ();
    },
    // @eventSource: is an object implementing the EventSource API, e.g. the
    // requestRange(), getEvents(), hasEvents() methods and the ::changed signal.
    setEventSource: function(eventSource) {
        this._eventSource = eventSource;
        this._eventSource.connect('changed', Lang.bind(this, function() {
            this._rebuildCalendar();
            this._update();
        }));
        this._rebuildCalendar();
        this._update();
    },
    // Sets the calendar to show a specific date
    setDate: function(date) {
        if (sameDay(date, this._selectedDate))
            return;
        this._selectedDate = date;
        this._update();
        this.emit('selected-date-changed', new Date(this._selectedDate));
    },
    _buildHeader: function() {
        let layout = this.actor.layout_manager;
        let offsetCols = this._useWeekdate ? 1 : 0;
        this.actor.destroy_all_children();
        // Top line of the calendar '<| September 2009 |>'
        this._topBox = new St.BoxLayout();
        layout.pack(this._topBox, 0, 0);
        layout.set_span(this._topBox, offsetCols + 7, 1);
        this._backButton = new St.Button({ style_class: 'calendar-change-month-back pager-button',
                                           accessible_name: _("Previous month"),
                                           can_focus: true });
        this._topBox.add(this._backButton);
        this._backButton.connect('clicked', Lang.bind(this, this._onPrevMonthButtonClicked));
        this._monthLabel = new St.Label({style_class: 'calendar-month-label',
                                         can_focus: true });
        this._topBox.add(this._monthLabel, { expand: true, x_fill: false, x_align: St.Align.MIDDLE });
        this._forwardButton = new St.Button({ style_class: 'calendar-change-month-forward pager-button',
                                              accessible_name: _("Next month"),
                                              can_focus: true });
        this._topBox.add(this._forwardButton);
        this._forwardButton.connect('clicked', Lang.bind(this, this._onNextMonthButtonClicked));
        // Add weekday labels...
        //
        // We need to figure out the abbreviated localized names for the days of the week;
        // we do this by just getting the next 7 days starting from right now and then putting
        // them in the right cell in the table. It doesn't matter if we add them in order
        let iter = new Date(this._selectedDate);
        iter.setSeconds(0); // Leap second protection. Hah!
        iter.setHours(12);
        for (let i = 0; i < 7; i++) {
            // Could use iter.toLocaleFormat('%a') but that normally gives three characters
            // and we want, ideally, a single character for e.g. S M T W T F S
            let customDayAbbrev = _getCalendarDayAbbreviation(iter.getDay());
            let label = new St.Label({ style_class: 'calendar-day-base calendar-day-heading',
                                       text: customDayAbbrev,
                                       can_focus: true });
            label.accessible_name = iter.toLocaleFormat('%A');
            let col;
            if (this.actor.get_text_direction() == Clutter.TextDirection.RTL)
                col = 6 - (7 + iter.getDay() - this._weekStart) % 7;
            else
                col = offsetCols + (7 + iter.getDay() - this._weekStart) % 7;
            layout.pack(label, col, 1);
            iter.setTime(iter.getTime() + MSECS_IN_DAY);
        }
        // All the children after this are days, and get removed when we update the calendar
        this._firstDayIndex = this.actor.get_n_children();
    },
    _onScroll : function(actor, event) {
        switch (event.get_scroll_direction()) {
        case Clutter.ScrollDirection.UP:
        case Clutter.ScrollDirection.LEFT:
            this._onPrevMonthButtonClicked();
            break;
        case Clutter.ScrollDirection.DOWN:
        case Clutter.ScrollDirection.RIGHT:
            this._onNextMonthButtonClicked();
            break;
        }
        return Clutter.EVENT_PROPAGATE;
    },
    _onPrevMonthButtonClicked: function() {
        let newDate = new Date(this._selectedDate);
        let oldMonth = newDate.getMonth();
        if (oldMonth == 0) {
            newDate.setMonth(11);
            newDate.setFullYear(newDate.getFullYear() - 1);
            if (newDate.getMonth() != 11) {
                let day = 32 - new Date(newDate.getFullYear() - 1, 11, 32).getDate();
                newDate = new Date(newDate.getFullYear() - 1, 11, day);
            }
        }
        else {
            newDate.setMonth(oldMonth - 1);
            if (newDate.getMonth() != oldMonth - 1) {
                let day = 32 - new Date(newDate.getFullYear(), oldMonth - 1, 32).getDate();
                newDate = new Date(newDate.getFullYear(), oldMonth - 1, day);
            }
        }
        this._backButton.grab_key_focus();
        this.setDate(newDate);
    },
    _onNextMonthButtonClicked: function() {
        let newDate = new Date(this._selectedDate);
        let oldMonth = newDate.getMonth();
        if (oldMonth == 11) {
            newDate.setMonth(0);
            newDate.setFullYear(newDate.getFullYear() + 1);
            if (newDate.getMonth() != 0) {
                let day = 32 - new Date(newDate.getFullYear() + 1, 0, 32).getDate();
                newDate = new Date(newDate.getFullYear() + 1, 0, day);
            }
        }
        else {
            newDate.setMonth(oldMonth + 1);
            if (newDate.getMonth() != oldMonth + 1) {
                let day = 32 - new Date(newDate.getFullYear(), oldMonth + 1, 32).getDate();
                newDate = new Date(newDate.getFullYear(), oldMonth + 1, day);
            }
        }
        this._forwardButton.grab_key_focus();
        this.setDate(newDate);
    },
    _onSettingsChange: function() {
        this._useWeekdate = this._settings.get_boolean(SHOW_WEEKDATE_KEY);
        this._buildHeader();
        this._rebuildCalendar();
        this._update();
    },
    _rebuildCalendar: function() {
        let now = new Date();
        // Remove everything but the topBox and the weekday labels
        let children = this.actor.get_children();
        for (let i = this._firstDayIndex; i < children.length; i++)
            children[i].destroy();
        this._buttons = [];
        // Start at the beginning of the week before the start of the month
        //
        // We want to show always 6 weeks (to keep the calendar menu at the same
        // height if there are no events), so we pad it according to the following
        // policy:
        //
        // 1 - If a month has 6 weeks, we place no padding (example: Dec 2012)
        // 2 - If a month has 5 weeks and it starts on week start, we pad one week
        //     before it (example: Apr 2012)
        // 3 - If a month has 5 weeks and it starts on any other day, we pad one week
        //     after it (example: Nov 2012)
        // 4 - If a month has 4 weeks, we pad one week before and one after it
        //     (example: Feb 2010)
        //
        // Actually computing the number of weeks is complex, but we know that the
        // problematic categories (2 and 4) always start on week start, and that
        // all months at the end have 6 weeks.
        let beginDate = new Date(this._selectedDate);
        beginDate.setDate(1);
        beginDate.setSeconds(0);
        beginDate.setHours(12);
        this._calendarBegin = new Date(beginDate);
        this._markedAsToday = now;
        let year = beginDate.getYear();
        let daysToWeekStart = (7 + beginDate.getDay() - this._weekStart) % 7;
        let startsOnWeekStart = daysToWeekStart == 0;
        let weekPadding = startsOnWeekStart ? 7 : 0;
        beginDate.setTime(beginDate.getTime() - (weekPadding + daysToWeekStart) * MSECS_IN_DAY);
        let layout = this.actor.layout_manager;
        let iter = new Date(beginDate);
        let row = 2;
        // nRows here means 6 weeks + one header + one navbar
        let nRows = 8;
        while (row < 8) {
            // xgettext:no-javascript-format
            let button = new St.Button({ label: iter.toLocaleFormat(C_("date day number format", "%d")),
                                         can_focus: true });
            let rtl = button.get_text_direction() == Clutter.TextDirection.RTL;
            if (this._eventSource.isDummy)
                button.reactive = false;
            button._date = new Date(iter);
            button.connect('clicked', Lang.bind(this, function() {
                this._shouldDateGrabFocus = true;
                this.setDate(button._date);
                this._shouldDateGrabFocus = false;
            }));
            let hasEvents = this._eventSource.hasEvents(iter);
            let styleClass = 'calendar-day-base calendar-day';
            if (_isWorkDay(iter))
                styleClass += ' calendar-work-day';
            else
                styleClass += ' calendar-nonwork-day';
            // Hack used in lieu of border-collapse - see gnome-shell.css
            if (row == 2)
                styleClass = 'calendar-day-top ' + styleClass;
            let leftMost = rtl ? iter.getDay() == (this._weekStart + 6) % 7
                               : iter.getDay() == this._weekStart;
            if (leftMost)
                styleClass = 'calendar-day-left ' + styleClass;
            if (sameDay(now, iter))
                styleClass += ' calendar-today';
            else if (iter.getMonth() != this._selectedDate.getMonth())
                styleClass += ' calendar-other-month-day';
            if (hasEvents)
                styleClass += ' calendar-day-with-events';
            button.style_class = styleClass;
            let offsetCols = this._useWeekdate ? 1 : 0;
            let col;
            if (rtl)
                col = 6 - (7 + iter.getDay() - this._weekStart) % 7;
            else
                col = offsetCols + (7 + iter.getDay() - this._weekStart) % 7;
            layout.pack(button, col, row);
            this._buttons.push(button);
            if (this._useWeekdate && iter.getDay() == 4) {
                let label = new St.Label({ text: iter.toLocaleFormat('%V'),
                                           style_class: 'calendar-day-base calendar-week-number',
                                           can_focus: true });
                let weekFormat = Shell.util_translate_time_string(N_("Week %V"));
                label.accessible_name = iter.toLocaleFormat(weekFormat);
                layout.pack(label, rtl ? 7 : 0, row);
            }
            iter.setTime(iter.getTime() + MSECS_IN_DAY);
            if (iter.getDay() == this._weekStart)
                row++;
        }
        // Signal to the event source that we are interested in events
        // only from this date range
        this._eventSource.requestRange(beginDate, iter);
    },
    _update: function() {
        let now = new Date();
        if (sameYear(this._selectedDate, now))
            this._monthLabel.text = this._selectedDate.toLocaleFormat(this._headerFormatWithoutYear);
        else
            this._monthLabel.text = this._selectedDate.toLocaleFormat(this._headerFormat);
        if (!this._calendarBegin || !sameMonth(this._selectedDate, this._calendarBegin) || !sameDay(now, this._markedAsToday))
            this._rebuildCalendar();
        this._buttons.forEach(Lang.bind(this, function(button) {
            if (sameDay(button._date, this._selectedDate)) {
                button.add_style_pseudo_class('selected');
                if (this._shouldDateGrabFocus)
                    button.grab_key_focus();
            }
            else
                button.remove_style_pseudo_class('selected');
        }));
    }
Signals.addSignalMethods(Calendar.prototype);
const EventMessage = new Lang.Class({
    Name: 'EventMessage',
    Extends: MessageList.Message,
    _init: function(event, date) {
        this._event = event;
        this._date = date;
        this.parent(this._formatEventTime(), event.summary);
    },
    _formatEventTime: function() {
        let periodBegin = _getBeginningOfDay(this._date);
        let periodEnd = _getEndOfDay(this._date);
        let allDay = (this._event.allDay || (this._event.date <= periodBegin &&
                                             this._event.end >= periodEnd));
        let title;
        if (allDay) {
            /* Translators: Shown in calendar event list for all day events
             * Keep it short, best if you can use less then 10 characters
             */
            title = C_("event list time", "All Day");
        } else {
            let date = this._event.date >= periodBegin ? this._event.date
                                                       : this._event.end;
            title = Util.formatTime(date, { timeOnly: true });
        }
        let rtl = Clutter.get_default_text_direction() == Clutter.TextDirection.RTL;
        if (this._event.date < periodBegin && !this._event.allDay) {
            if (rtl)
                title = title + ELLIPSIS_CHAR;
            else
                title = ELLIPSIS_CHAR + title;
        }
        if (this._event.end > periodEnd && !this._event.allDay) {
            if (rtl)
                title = ELLIPSIS_CHAR + title;
            else
                title = title + ELLIPSIS_CHAR;
        }
        return title;
    },
    canClose: function() {
        return isToday(this._date);
    }
const NotificationMessage = new Lang.Class({
    Name: 'NotificationMessage',
    Extends: MessageList.Message,
    _init: function(notification) {
        this.notification = notification;
        this.setUseBodyMarkup(notification.bannerBodyMarkup);
        this.parent(notification.title, notification.bannerBodyText);
        this.setIcon(this._getIcon());
        this.connect('close', Lang.bind(this,
            function() {
                this._closed = true;
                this.notification.destroy(MessageTray.NotificationDestroyedReason.DISMISSED);
            }));
        this._destroyId = notification.connect('destroy', Lang.bind(this,
            function() {
                if (!this._closed)
                    this.close();
            }));
        this._updatedId = notification.connect('updated',
                                               Lang.bind(this, this._onUpdated));
    },
    _getIcon: function() {
        if (this.notification.gicon)
            return new St.Icon({ gicon: this.notification.gicon,
                                 icon_size: MESSAGE_ICON_SIZE });
        else
            return this.notification.source.createIcon(MESSAGE_ICON_SIZE);
    },
    _onUpdated: function(n, clear) {
        this.setIcon(this._getIcon());
        this.setTitle(n.title);
        this.setBody(n.bannerBodyText);
        this.setUseBodyMarkup(n.bannerBodyMarkup);
    },
    _onClicked: function() {
        this.notification.activate();
    },
    _onDestroy: function() {
        if (this._updatedId)
            this.notification.disconnect(this._updatedId);
        this._updatedId = 0;
        if (this._destroyId)
            this.notification.disconnect(this._destroyId);
        this._destroyId = 0;
    }
const EventsSection = new Lang.Class({
    Name: 'EventsSection',
    Extends: MessageList.MessageListSection,
    _init: function() {
        this._desktopSettings = new Gio.Settings({ schema_id: 'org.gnome.desktop.interface' });
        this._desktopSettings.connect('changed', Lang.bind(this, this._reloadEvents));
        this._eventSource = new EmptyEventSource();
        this.parent('');
        Shell.AppSystem.get_default().connect('installed-changed',
                                              Lang.bind(this, this._appInstalledChanged));
        this._appInstalledChanged();
    },
    _ignoreEvent: function(event) {
        this._eventSource.ignoreEvent(event);
    },
    setEventSource: function(eventSource) {
        this._eventSource = eventSource;
        this._eventSource.connect('changed', Lang.bind(this, this._reloadEvents));
    },
    get allowed() {
        return Main.sessionMode.showCalendarEvents;
    },
    _updateTitle: function() {
        if (isToday(this._date)) {
            this._title.label = _("Events");
            return;
        }
        let dayFormat;
        let now = new Date();
        if (sameYear(this._date, now))
            /* Translators: Shown on calendar heading when selected day occurs on current year */
            dayFormat = Shell.util_translate_time_string(NC_("calendar heading",
                                                             "%A, %B %d"));
        else
            /* Translators: Shown on calendar heading when selected day occurs on different year */
            dayFormat = Shell.util_translate_time_string(NC_("calendar heading",
                                                             "%A, %B %d, %Y"));
        this._title.label = this._date.toLocaleFormat(dayFormat);
    },
    _reloadEvents: function() {
        if (this._eventSource.isLoading)
            return;
        this._reloading = true;
        this._list.destroy_all_children();
        let periodBegin = _getBeginningOfDay(this._date);
        let periodEnd = _getEndOfDay(this._date);
        let events = this._eventSource.getEvents(periodBegin, periodEnd);
        for (let i = 0; i < events.length; i++) {
            let event = events[i];
            let message = new EventMessage(event, this._date);
            message.connect('close', Lang.bind(this, function() {
                this._ignoreEvent(event);
            }));
            this.addMessage(message, false);
        }
        this._reloading = false;
        this._sync();
    },
    _appInstalledChanged: function() {
        this._calendarApp = undefined;
        this._title.reactive = (this._getCalendarApp() != null);
    },
    _getCalendarApp: function() {
        if (this._calendarApp !== undefined)
            return this._calendarApp;
        let apps = Gio.AppInfo.get_recommended_for_type('text/calendar');
        if (apps && (apps.length > 0)) {
            let app = Gio.AppInfo.get_default_for_type('text/calendar', false);
            let defaultInRecommended = apps.some(function(a) { return a.equal(app); });
            this._calendarApp = defaultInRecommended ? app : apps[0];
        } else {
            this._calendarApp = null;
        }
        return this._calendarApp;
    },
    _onTitleClicked: function() {
        this.parent();
        let app = this._getCalendarApp();
        if (app.get_id() == 'evolution.desktop')
            app = Gio.DesktopAppInfo.new('evolution-calendar.desktop');
        app.launch([], global.create_app_launch_context(0, -1));
    },
    setDate: function(date) {
        this.parent(date);
        this._updateTitle();
        this._reloadEvents();
    },
    _shouldShow: function() {
        return !this.empty || !isToday(this._date);
    },
    _sync: function() {
        if (this._reloading)
            return;
        this.parent();
    }
const NotificationSection = new Lang.Class({
    Name: 'NotificationSection',
    Extends: MessageList.MessageListSection,
    _init: function() {
        this.parent(_("Notifications"));
        this._sources = new Map();
        this._nUrgent = 0;
        Main.messageTray.connect('source-added', Lang.bind(this, this._sourceAdded));
        Main.messageTray.getSources().forEach(Lang.bind(this, function(source) {
            this._sourceAdded(Main.messageTray, source);
        }));
        this.actor.connect('notify::mapped', Lang.bind(this, this._onMapped));
    },
    get allowed() {
        return Main.sessionMode.hasNotifications &&
               !Main.sessionMode.isGreeter;
    },
    _createTimeLabel: function() {
        let label = Util.createTimeLabel(new Date());
        label.style_class = 'event-time',
        label.x_align = Clutter.ActorAlign.END;
        return label;
    },
    _sourceAdded: function(tray, source) {
        let obj = {
            destroyId: 0,
            notificationAddedId: 0,
        };
        obj.destroyId = source.connect('destroy', Lang.bind(this, function(source) {
            this._onSourceDestroy(source, obj);
        }));
        obj.notificationAddedId = source.connect('notification-added',
                                                 Lang.bind(this, this._onNotificationAdded));
        this._sources.set(source, obj);
    },
    _onNotificationAdded: function(source, notification) {
        let message = new NotificationMessage(notification);
        message.setSecondaryActor(this._createTimeLabel());
        let isUrgent = notification.urgency == MessageTray.Urgency.CRITICAL;
        let updatedId = notification.connect('updated', Lang.bind(this,
            function() {
                message.setSecondaryActor(this._createTimeLabel());
                this.moveMessage(message, isUrgent ? 0 : this._nUrgent, this.actor.mapped);
            }));
        let destroyId = notification.connect('destroy', Lang.bind(this,
            function() {
                notification.disconnect(destroyId);
                notification.disconnect(updatedId);
                if (isUrgent)
                    this._nUrgent--;
            }));
        if (isUrgent) {
            // Keep track of urgent notifications to keep them on top
            this._nUrgent++;
        } else if (this.mapped) {
            // Only acknowledge non-urgent notifications in case it
            // has important actions that are inaccessible when not
            // shown as banner
            notification.acknowledged = true;
        }
        let index = isUrgent ? 0 : this._nUrgent;
        this.addMessageAtIndex(message, index, this.actor.mapped);
    },
    _onSourceDestroy: function(source, obj) {
        source.disconnect(obj.destroyId);
        source.disconnect(obj.notificationAddedId);
        this._sources.delete(source);
    },
    _onMapped: function() {
        if (!this.actor.mapped)
            return;
        for (let message of this._messages.keys())
            if (message.notification.urgency != MessageTray.Urgency.CRITICAL)
                message.notification.acknowledged = true;
    },
    _onTitleClicked: function() {
        this.parent();
        let app = Shell.AppSystem.get_default().lookup_app('gnome-notifications-panel.desktop');
        if (!app) {
            log('Settings panel for desktop file ' + desktopFile + ' could not be loaded!');
            return;
        }
        app.activate();
    },
    _shouldShow: function() {
        return !this.empty && isToday(this._date);
    },
    _sync: function() {
        this.parent();
        this._title.reactive = Main.sessionMode.allowSettings;
    }
const Placeholder = new Lang.Class({
    Name: 'Placeholder',
    _init: function() {
        this.actor = new St.BoxLayout({ style_class: 'message-list-placeholder',
                                        vertical: true });
        this._date = new Date();
        let todayFile = Gio.File.new_for_uri('resource:///org/gnome/shell/theme/no-notifications.svg');
        let otherFile = Gio.File.new_for_uri('resource:///org/gnome/shell/theme/no-events.svg');
        this._todayIcon = new Gio.FileIcon({ file: todayFile });
        this._otherIcon = new Gio.FileIcon({ file: otherFile });
        this._icon = new St.Icon();
        this.actor.add_actor(this._icon);
        this._label = new St.Label();
        this.actor.add_actor(this._label);
        this._sync();
    },
    setDate: function(date) {
        if (sameDay(this._date, date))
            return;
        this._date = date;
        this._sync();
    },
    _sync: function() {
        let today = isToday(this._date);
        if (today && this._icon.gicon == this._todayIcon)
            return;
        if (!today && this._icon.gicon == this._otherIcon)
            return;
        if (today) {
            this._icon.gicon = this._todayIcon;
            this._label.text = _("No Notifications");
        } else {
            this._icon.gicon = this._otherIcon;
            this._label.text = _("No Events");
        }
    }
const CalendarMessageList = new Lang.Class({
    Name: 'CalendarMessageList',
    _init: function() {
        this.actor = new St.Widget({ style_class: 'message-list',
                                     layout_manager: new Clutter.BinLayout(),
                                     x_expand: true, y_expand: true });
        this._placeholder = new Placeholder();
        this.actor.add_actor(this._placeholder.actor);
        this._scrollView = new St.ScrollView({ style_class: 'vfade',
                                               overlay_scrollbars: true,
                                               x_expand: true, y_expand: true,
                                               x_fill: true, y_fill: true });
        this._scrollView.set_policy(Gtk.PolicyType.NEVER, Gtk.PolicyType.AUTOMATIC);
        this.actor.add_actor(this._scrollView);
        this._sectionList = new St.BoxLayout({ style_class: 'message-list-sections',
                                               vertical: true,
                                               y_expand: true,
                                               y_align: Clutter.ActorAlign.START });
        this._scrollView.add_actor(this._sectionList);
        this._sections = new Map();
        this._mediaSection = new Mpris.MediaSection();
        this._addSection(this._mediaSection);
        this._notificationSection = new NotificationSection();
        this._addSection(this._notificationSection);
        this._eventsSection = new EventsSection();
        this._addSection(this._eventsSection);
        Main.sessionMode.connect('updated', Lang.bind(this, this._sync));
    },
    _addSection: function(section) {
        let obj = {
            destroyId: 0,
            visibleId:  0,
            emptyChangedId: 0,
            keyFocusId: 0
        };
        obj.destroyId = section.actor.connect('destroy', Lang.bind(this,
            function() {
                this._removeSection(section);
            }));
        obj.visibleId = section.actor.connect('notify::visible',
                                              Lang.bind(this, this._sync));
        obj.emptyChangedId = section.connect('empty-changed',
                                             Lang.bind(this, this._sync));
        obj.keyFocusId = section.connect('key-focus-in',
                                         Lang.bind(this, this._onKeyFocusIn));
        this._sections.set(section, obj);
        this._sectionList.add_actor(section.actor);
        this._sync();
    },
    _removeSection: function(section) {
        let obj = this._sections.get(section);
        section.actor.disconnect(obj.destroyId);
        section.actor.disconnect(obj.visibleId);
        section.disconnect(obj.emptyChangedId);
        section.disconnect(obj.keyFocusId);
        this._sections.delete(section);
        this._sectionList.remove_actor(section.actor);
        this._sync();
    },
    _onKeyFocusIn: function(section, actor) {
        Util.ensureActorVisibleInScrollView(this._scrollView, actor);
    },
    _sync: function() {
        let sections = [...this._sections.keys()];
        let visible = sections.some(function(s) {
            return s.allowed;
        });
        this.actor.visible = visible;
        if (!visible)
            return;
        let showPlaceholder = sections.every(function(s) {
            return s.empty || !s.actor.visible;
        });
        this._placeholder.actor.visible = showPlaceholder;
    },
    setEventSource: function(eventSource) {
        this._eventsSection.setEventSource(eventSource);
    },
    setDate: function(date) {
        for (let section of this._sections.keys())
            section.setDate(date);
        this._placeholder.setDate(date);
    }
(uuay)smartcardManager.js
// -*- mode: js; js-indent-level: 4; indent-tabs-mode: nil -*-
const Gio = imports.gi.Gio;
const Lang = imports.lang;
const Shell = imports.gi.Shell;
const Signals = imports.signals;
const ObjectManager = imports.misc.objectManager;
const SmartcardTokenIface = '<node> \
<interface name="org.gnome.SettingsDaemon.Smartcard.Token"> \
  <property name="Name" type="s" access="read"/> \
  <property name="Driver" type="o" access="read"/> \
  <property name="IsInserted" type="b" access="read"/> \
  <property name="UsedToLogin" type="b" access="read"/> \
</interface> \
</node>';
let _smartcardManager = null;
function getSmartcardManager() {
    if (_smartcardManager == null)
        _smartcardManager = new SmartcardManager();
    return _smartcardManager;
const SmartcardManager = new Lang.Class({
    Name: 'SmartcardManager',
    _init: function() {
        this._objectManager = new ObjectManager.ObjectManager({ connection: Gio.DBus.session,
                                                                name: "org.gnome.SettingsDaemon.Smartcard",
                                                                objectPath: '/org/gnome/SettingsDaemon/Smartcard',
                                                                knownInterfaces: [ SmartcardTokenIface ],
                                                                onLoaded: Lang.bind(this, this._onLoaded) });
        this._insertedTokens = {};
        this._loginToken = null;
    },
    _onLoaded: function() {
        let tokens = this._objectManager.getProxiesForInterface('org.gnome.SettingsDaemon.Smartcard.Token');
        for (let i = 0; i < tokens.length; i++)
            this._addToken(tokens[i]);
        this._objectManager.connect('interface-added', Lang.bind(this, function(objectManager, interfaceName, proxy) {
            if (interfaceName == 'org.gnome.SettingsDaemon.Smartcard.Token')
                this._addToken(proxy);
        }));
        this._objectManager.connect('interface-removed', Lang.bind(this, function(objectManager, interfaceName, proxy) {
            if (interfaceName == 'org.gnome.SettingsDaemon.Smartcard.Token')
                this._removeToken(proxy);
        }));
    },
    _updateToken: function(token) {
        let objectPath = token.get_object_path();
        delete this._insertedTokens[objectPath];
        if (token.IsInserted)
            this._insertedTokens[objectPath] = token;
        if (token.UsedToLogin)
            this._loginToken = token;
    },
    _addToken: function(token) {
        this._updateToken(token);
        token.connect('g-properties-changed',
                      Lang.bind(this, function(proxy, properties) {
                          if ('IsInserted' in properties.deep_unpack()) {
                              this._updateToken(token);
                              if (token.IsInserted) {
                                  this.emit('smartcard-inserted', token);
                              } else {
                                  this.emit('smartcard-removed', token);
                              }
                          }
                      }));
        // Emit a smartcard-inserted at startup if it's already plugged in
        if (token.IsInserted)
            this.emit('smartcard-inserted', token);
    },
    _removeToken: function(token) {
        let objectPath = token.get_object_path();
        if (this._insertedTokens[objectPath] == token) {
            delete this._insertedTokens[objectPath];
            this.emit('smartcard-removed', token);
        }
        if (this._loginToken == token)
            this._loginToken = null;
        token.disconnectAll();
    },
    hasInsertedTokens: function() {
        return Object.keys(this._insertedTokens).length > 0;
    },
    hasInsertedLoginToken: function() {
        if (!this._loginToken)
            return false;
        if (!this._loginToken.IsInserted)
            return false;
        return true;
    }
Signals.addSignalMethods(SmartcardManager.prototype);
(uuay)environment.js
// -*- mode: js; js-indent-level: 4; indent-tabs-mode: nil -*-
imports.gi.versions.Clutter = '1.0';
imports.gi.versions.Gio = '2.0';
imports.gi.versions.Gdk = '3.0';
imports.gi.versions.GdkPixbuf = '2.0';
imports.gi.versions.Gtk = '3.0';
imports.gi.versions.TelepathyGLib = '0.12';
imports.gi.versions.TelepathyLogger = '0.2';
const Clutter = imports.gi.Clutter;;
const Gettext = imports.gettext;
const GLib = imports.gi.GLib;
const Gtk = imports.gi.Gtk;
const Lang = imports.lang;
const Shell = imports.gi.Shell;
const St = imports.gi.St;
// We can't import shell JS modules yet, because they may have
// variable initializations, etc, that depend on init() already having
// been run.
// "monkey patch" in some varargs ClutterContainer methods; we need
// to do this per-container class since there is no representation
// of interfaces in Javascript
function _patchContainerClass(containerClass) {
    // This one is a straightforward mapping of the C method
    containerClass.prototype.child_set = function(actor, props) {
        let meta = this.get_child_meta(actor);
        for (let prop in props)
            meta[prop] = props[prop];
    };
    // clutter_container_add() actually is a an add-many-actors
    // method. We conveniently, but somewhat dubiously, take the
    // this opportunity to make it do something more useful.
    containerClass.prototype.add = function(actor, props) {
        this.add_actor(actor);
        if (props)
            this.child_set(actor, props);
    };
function _patchLayoutClass(layoutClass, styleProps) {
    if (styleProps)
        layoutClass.prototype.hookup_style = function(container) {
            container.connect('style-changed', Lang.bind(this, function() {
                let node = container.get_theme_node();
                for (let prop in styleProps) {
                    let [found, length] = node.lookup_length(styleProps[prop], false);
                    if (found)
                        this[prop] = length;
                }
            }));
        };
    layoutClass.prototype.child_set = function(actor, props) {
        let meta = this.get_child_meta(actor.get_parent(), actor);
        for (let prop in props)
            meta[prop] = props[prop];
    };
function _makeLoggingFunc(func) {
    return function() {
        return func([].join.call(arguments, ', '));
    };
function init() {
    // Add some bindings to the global JS namespace; (gjs keeps the web
    // browser convention of having that namespace be called 'window'.)
    window.global = Shell.Global.get();
    window.log = _makeLoggingFunc(window.log);
    window._ = Gettext.gettext;
    window.C_ = Gettext.pgettext;
    window.ngettext = Gettext.ngettext;
    window.N_ = function(s) { return s; };
    // Miscellaneous monkeypatching
    _patchContainerClass(St.BoxLayout);
    _patchLayoutClass(Clutter.TableLayout, { row_spacing: 'spacing-rows',
                                             column_spacing: 'spacing-columns' });
    _patchLayoutClass(Clutter.GridLayout, { row_spacing: 'spacing-rows',
                                            column_spacing: 'spacing-columns' });
    _patchLayoutClass(Clutter.BoxLayout, { spacing: 'spacing' });
    Clutter.Actor.prototype.toString = function() {
        return St.describe_actor(this);
    };
    let origToString = Object.prototype.toString;
    Object.prototype.toString = function() {
        let base = origToString.call(this);
        try {
            if ('actor' in this && this.actor instanceof Clutter.Actor)
                return base.replace(/\]$/, ' delegate for ' + this.actor.toString().substring(1));
            else
                return base;
        } catch(e) {
            return base;
        }
    };
    // Work around https://bugzilla.mozilla.org/show_bug.cgi?id=508783
    Date.prototype.toLocaleFormat = function(format) {
        return Shell.util_format_date(format, this.getTime());
    };
    let slowdownEnv = GLib.getenv('GNOME_SHELL_SLOWDOWN_FACTOR');
    if (slowdownEnv) {
        let factor = parseFloat(slowdownEnv);
        if (!isNaN(factor) && factor > 0.0)
            St.set_slow_down_factor(factor);
    }
    // OK, now things are initialized enough that we can import shell JS
    const Format = imports.format;
    const Tweener = imports.ui.tweener;
    Tweener.init();
    String.prototype.format = Format.format;
(uuay)rfkill.js
// -*- mode: js; js-indent-level: 4; indent-tabs-mode: nil -*-
const Gio = imports.gi.Gio;
const Lang = imports.lang;
const Signals = imports.signals;
const Main = imports.ui.main;
const PanelMenu = imports.ui.panelMenu;
const PopupMenu = imports.ui.popupMenu;
const BUS_NAME = 'org.gnome.SettingsDaemon.Rfkill';
const OBJECT_PATH = '/org/gnome/SettingsDaemon/Rfkill';
const RfkillManagerInterface = '<node> \
<interface name="org.gnome.SettingsDaemon.Rfkill"> \
<property name="AirplaneMode" type="b" access="readwrite" /> \
<property name="HardwareAirplaneMode" type="b" access="read" /> \
<property name="ShouldShowAirplaneMode" type="b" access="read" /> \
</interface> \
</node>';
const RfkillManagerProxy = Gio.DBusProxy.makeProxyWrapper(RfkillManagerInterface);
const RfkillManager = new Lang.Class({
    Name: 'RfkillManager',
    _init: function() {
        this._proxy = new RfkillManagerProxy(Gio.DBus.session, BUS_NAME, OBJECT_PATH,
                                             Lang.bind(this, function(proxy, error) {
                                                 if (error) {
                                                     log(error.message);
                                                     return;
                                                 }
                                                 this._proxy.connect('g-properties-changed',
                                                                     Lang.bind(this, this._changed));
                                                 this._changed();
                                             }));
    },
    get airplaneMode() {
        return this._proxy.AirplaneMode;
    },
    set airplaneMode(v) {
        this._proxy.AirplaneMode = v;
    },
    get hwAirplaneMode() {
        return this._proxy.HardwareAirplaneMode;
    },
    get shouldShowAirplaneMode() {
        return this._proxy.ShouldShowAirplaneMode;
    },
    _changed: function() {
        this.emit('airplane-mode-changed');
    }
Signals.addSignalMethods(RfkillManager.prototype);
var _manager;
function getRfkillManager() {
    if (_manager != null)
        return _manager;
    _manager = new RfkillManager();
    return _manager;
const Indicator = new Lang.Class({
    Name: 'RfkillIndicator',
    Extends: PanelMenu.SystemIndicator,
    _init: function() {
        this.parent();
        this._manager = getRfkillManager();
        this._manager.connect('airplane-mode-changed', Lang.bind(this, this._sync));
        this._indicator = this._addIndicator();
        this._indicator.icon_name = 'airplane-mode-symbolic';
        this._indicator.hide();
        // The menu only appears when airplane mode is on, so just
        // statically build it as if it was on, rather than dynamically
        // changing the menu contents.
        this._item = new PopupMenu.PopupSubMenuMenuItem(_("Airplane Mode On"), true);
        this._item.icon.icon_name = 'airplane-mode-symbolic';
        this._offItem = this._item.menu.addAction(_("Turn Off"), Lang.bind(this, function() {
            this._manager.airplaneMode = false;
        }));
        this._item.menu.addSettingsAction(_("Network Settings"), 'gnome-network-panel.desktop');
        this.menu.addMenuItem(this._item);
        Main.sessionMode.connect('updated', Lang.bind(this, this._sessionUpdated));
        this._sessionUpdated();
    },
    _sessionUpdated: function() {
        let sensitive = !Main.sessionMode.isLocked && !Main.sessionMode.isGreeter;
        this.menu.setSensitive(sensitive);
    },
    _sync: function() {
        let airplaneMode = this._manager.airplaneMode;
        let hwAirplaneMode = this._manager.hwAirplaneMode;
        let showAirplaneMode = this._manager.shouldShowAirplaneMode;
        this._indicator.visible = (airplaneMode && showAirplaneMode);
        this._item.actor.visible = (airplaneMode && showAirplaneMode);
        this._offItem.setSensitive(!hwAirplaneMode);
        if (hwAirplaneMode)
            this._offItem.label.text = _("Use hardware switch to turn off");
        else
            this._offItem.label.text = _("Turn Off");
    },
(uuay)util.js
// -*- mode: js; js-indent-level: 4; indent-tabs-mode: nil -*-
const Clutter = imports.gi.Clutter;
const Gio = imports.gi.Gio;
const GLib = imports.gi.GLib;
const Lang = imports.lang;
const Mainloop = imports.mainloop;
const Signals = imports.signals;
const St = imports.gi.St;
const Batch = imports.gdm.batch;
const Fprint = imports.gdm.fingerprint;
const OVirt = imports.gdm.oVirt;
const Main = imports.ui.main;
const Params = imports.misc.params;
const ShellEntry = imports.ui.shellEntry;
const SmartcardManager = imports.misc.smartcardManager;
const Tweener = imports.ui.tweener;
const PASSWORD_SERVICE_NAME = 'gdm-password';
const FINGERPRINT_SERVICE_NAME = 'gdm-fingerprint';
const SMARTCARD_SERVICE_NAME = 'gdm-smartcard';
const OVIRT_SERVICE_NAME = 'gdm-ovirtcred';
const FADE_ANIMATION_TIME = 0.16;
const CLONE_FADE_ANIMATION_TIME = 0.25;
const LOGIN_SCREEN_SCHEMA = 'org.gnome.login-screen';
const PASSWORD_AUTHENTICATION_KEY = 'enable-password-authentication';
const FINGERPRINT_AUTHENTICATION_KEY = 'enable-fingerprint-authentication';
const SMARTCARD_AUTHENTICATION_KEY = 'enable-smartcard-authentication';
const BANNER_MESSAGE_KEY = 'banner-message-enable';
const BANNER_MESSAGE_TEXT_KEY = 'banner-message-text';
const ALLOWED_FAILURES_KEY = 'allowed-failures';
const LOGO_KEY = 'logo';
const DISABLE_USER_LIST_KEY = 'disable-user-list';
// Give user 48ms to read each character of a PAM message
const USER_READ_TIME = 48
const MessageType = {
    NONE: 0,
    ERROR: 1,
    INFO: 2,
    HINT: 3
function fadeInActor(actor) {
    if (actor.opacity == 255 && actor.visible)
        return null;
    let hold = new Batch.Hold();
    actor.show();
    let [minHeight, naturalHeight] = actor.get_preferred_height(-1);
    actor.opacity = 0;
    actor.set_height(0);
    Tweener.addTween(actor,
                     { opacity: 255,
                       height: naturalHeight,
                       time: FADE_ANIMATION_TIME,
                       transition: 'easeOutQuad',
                       onComplete: function() {
                           this.set_height(-1);
                           hold.release();
                       },
                     });
    return hold;
function fadeOutActor(actor) {
    if (!actor.visible || actor.opacity == 0) {
        actor.opacity = 0;
        actor.hide();
        return null;
    }
    let hold = new Batch.Hold();
    Tweener.addTween(actor,
                     { opacity: 0,
                       height: 0,
                       time: FADE_ANIMATION_TIME,
                       transition: 'easeOutQuad',
                       onComplete: function() {
                           this.hide();
                           this.set_height(-1);
                           hold.release();
                       },
                     });
    return hold;
function cloneAndFadeOutActor(actor) {
    // Immediately hide actor so its sibling can have its space
    // and position, but leave a non-reactive clone on-screen,
    // so from the user's point of view it smoothly fades away
    // and reveals its sibling.
    actor.hide();
    let clone = new Clutter.Clone({ source: actor,
                                    reactive: false });
    Main.uiGroup.add_child(clone);
    let [x, y] = actor.get_transformed_position();
    clone.set_position(x, y);
    let hold = new Batch.Hold();
    Tweener.addTween(clone,
                     { opacity: 0,
                       time: CLONE_FADE_ANIMATION_TIME,
                       transition: 'easeOutQuad',
                       onComplete: function() {
                           clone.destroy();
                           hold.release();
                       }
                     });
    return hold;
const ShellUserVerifier = new Lang.Class({
    Name: 'ShellUserVerifier',
    _init: function(client, params) {
        params = Params.parse(params, { reauthenticationOnly: false });
        this._reauthOnly = params.reauthenticationOnly;
        this._client = client;
        this._settings = new Gio.Settings({ schema_id: LOGIN_SCREEN_SCHEMA });
        this._settings.connect('changed',
                               Lang.bind(this, this._updateDefaultService));
        this._updateDefaultService();
        this._fprintManager = new Fprint.FprintManager();
        this._smartcardManager = SmartcardManager.getSmartcardManager();
        // We check for smartcards right away, since an inserted smartcard
        // at startup should result in immediately initiating authentication.
        // This is different than fingeprint readers, where we only check them
        // after a user has been picked.
        this._checkForSmartcard();
        this._smartcardInsertedId = this._smartcardManager.connect('smartcard-inserted',
                                                                   Lang.bind(this, this._checkForSmartcard));
        this._smartcardRemovedId = this._smartcardManager.connect('smartcard-removed',
                                                                  Lang.bind(this, this._checkForSmartcard));
        this._messageQueue = [];
        this._messageQueueTimeoutId = 0;
        this.hasPendingMessages = false;
        this.reauthenticating = false;
        this._failCounter = 0;
        this._oVirtCredentialsManager = OVirt.getOVirtCredentialsManager();
        if (this._oVirtCredentialsManager.hasToken())
            this._oVirtUserAuthenticated(this._oVirtCredentialsManager.getToken());
        this._oVirtUserAuthenticatedId = this._oVirtCredentialsManager.connect('user-authenticated',
                                                                               Lang.bind(this, this._oVirtUserAuthenticated));
    },
    begin: function(userName, hold) {
        this._cancellable = new Gio.Cancellable();
        this._hold = hold;
        this._userName = userName;
        this.reauthenticating = false;
        this._checkForFingerprintReader();
        if (userName) {
            // If possible, reauthenticate an already running session,
            // so any session specific credentials get updated appropriately
            this._client.open_reauthentication_channel(userName, this._cancellable,
                                                       Lang.bind(this, this._reauthenticationChannelOpened));
        } else {
            this._client.get_user_verifier(this._cancellable, Lang.bind(this, this._userVerifierGot));
        }
    },
    cancel: function() {
        if (this._cancellable)
            this._cancellable.cancel();
        if (this._userVerifier) {
            this._userVerifier.call_cancel_sync(null);
            this.clear();
        }
    },
    _clearUserVerifier: function() {
        if (this._userVerifier) {
            this._userVerifier.run_dispose();
            this._userVerifier = null;
        }
    },
    clear: function() {
        if (this._cancellable) {
            this._cancellable.cancel();
            this._cancellable = null;
        }
        this._clearUserVerifier();
        this._clearMessageQueue();
    },
    destroy: function() {
        this.clear();
        this._settings.run_dispose();
        this._settings = null;
        this._smartcardManager.disconnect(this._smartcardInsertedId);
        this._smartcardManager.disconnect(this._smartcardRemovedId);
        this._smartcardManager = null;
        this._oVirtCredentialsManager.disconnect(this._oVirtUserAuthenticatedId);
        this._oVirtCredentialsManager = null;
    },
    answerQuery: function(serviceName, answer) {
        if (!this.hasPendingMessages) {
            this._userVerifier.call_answer_query(serviceName, answer, this._cancellable, null);
        } else {
            let signalId = this.connect('no-more-messages',
                                        Lang.bind(this, function() {
                                            this.disconnect(signalId);
                                            this._userVerifier.call_answer_query(serviceName, answer, this._cancellable, null);
                                        }));
        }
    },
    _getIntervalForMessage: function(message) {
        // We probably could be smarter here
        return message.length * USER_READ_TIME;
    },
    finishMessageQueue: function() {
        if (!this.hasPendingMessages)
            return;
        this._messageQueue = [];
        this.hasPendingMessages = false;
        this.emit('no-more-messages');
    },
    _queueMessageTimeout: function() {
        if (this._messageQueue.length == 0) {
            this.finishMessageQueue();
            return;
        }
        if (this._messageQueueTimeoutId != 0)
            return;
        let message = this._messageQueue.shift();
        this.emit('show-message', message.text, message.type);
        this._messageQueueTimeoutId = GLib.timeout_add(GLib.PRIORITY_DEFAULT,
                                                       message.interval,
                                                       Lang.bind(this, function() {
                                                           this._messageQueueTimeoutId = 0;
                                                           this._queueMessageTimeout();
                                                           return GLib.SOURCE_REMOVE;
                                                       }));
        GLib.Source.set_name_by_id(this._messageQueueTimeoutId, '[gnome-shell] this._queueMessageTimeout');
    },
    _queueMessage: function(message, messageType) {
        let interval = this._getIntervalForMessage(message);
        this.hasPendingMessages = true;
        this._messageQueue.push({ text: message, type: messageType, interval: interval });
        this._queueMessageTimeout();
    },
    _clearMessageQueue: function() {
        this.finishMessageQueue();
        if (this._messageQueueTimeoutId != 0) {
            GLib.source_remove(this._messageQueueTimeoutId);
            this._messageQueueTimeoutId = 0;
        }
        this.emit('show-message', null, MessageType.NONE);
    },
    _checkForFingerprintReader: function() {
        this._haveFingerprintReader = false;
        if (!this._settings.get_boolean(FINGERPRINT_AUTHENTICATION_KEY)) {
            this._updateDefaultService();
            return;
        }
        this._fprintManager.GetDefaultDeviceRemote(Gio.DBusCallFlags.NONE, this._cancellable, Lang.bind(this,
            function(device, error) {
                if (!error && device) {
                    this._haveFingerprintReader = true;
                    this._updateDefaultService();
                }
            }));
    },
    _oVirtUserAuthenticated: function(token) {
        this._preemptingService = OVIRT_SERVICE_NAME;
        this.emit('ovirt-user-authenticated');
    },
    _checkForSmartcard: function() {
        let smartcardDetected;
        if (!this._settings.get_boolean(SMARTCARD_AUTHENTICATION_KEY))
            smartcardDetected = false;
        else if (this._reauthOnly)
            smartcardDetected = this._smartcardManager.hasInsertedLoginToken();
        else
            smartcardDetected = this._smartcardManager.hasInsertedTokens();
        if (smartcardDetected != this.smartcardDetected) {
            this.smartcardDetected = smartcardDetected;
            if (this.smartcardDetected)
                this._preemptingService = SMARTCARD_SERVICE_NAME;
            else if (this._preemptingService == SMARTCARD_SERVICE_NAME)
                this._preemptingService = null;
            this.emit('smartcard-status-changed');
        }
    },
    _reportInitError: function(where, error) {
        logError(error, where);
        this._hold.release();
        this._queueMessage(_("Authentication error"), MessageType.ERROR);
        this._verificationFailed(false);
    },
    _reauthenticationChannelOpened: function(client, result) {
        try {
            this._clearUserVerifier();
            this._userVerifier = client.open_reauthentication_channel_finish(result);
        } catch(e if e.matches(Gio.IOErrorEnum, Gio.IOErrorEnum.CANCELLED)) {
            return;
        } catch(e if e.matches(Gio.DBusError, Gio.DBusError.ACCESS_DENIED) &&
                !this._reauthOnly) {
            // Gdm emits org.freedesktop.DBus.Error.AccessDenied when there is
            // no session to reauthenticate. Fall back to performing verification
            // from this login session
            client.get_user_verifier(this._cancellable, Lang.bind(this, this._userVerifierGot));
            return;
        } catch(e) {
            this._reportInitError('Failed to open reauthentication channel', e);
            return;
        }
        this.reauthenticating = true;
        this._connectSignals();
        this._beginVerification();
        this._hold.release();
    },
    _userVerifierGot: function(client, result) {
        try {
            this._clearUserVerifier();
            this._userVerifier = client.get_user_verifier_finish(result);
        } catch(e if e.matches(Gio.IOErrorEnum, Gio.IOErrorEnum.CANCELLED)) {
            return;
        } catch(e) {
            this._reportInitError('Failed to obtain user verifier', e);
            return;
        }
        this._connectSignals();
        this._beginVerification();
        this._hold.release();
    },
    _connectSignals: function() {
        this._userVerifier.connect('info', Lang.bind(this, this._onInfo));
        this._userVerifier.connect('problem', Lang.bind(this, this._onProblem));
        this._userVerifier.connect('info-query', Lang.bind(this, this._onInfoQuery));
        this._userVerifier.connect('secret-info-query', Lang.bind(this, this._onSecretInfoQuery));
        this._userVerifier.connect('conversation-stopped', Lang.bind(this, this._onConversationStopped));
        this._userVerifier.connect('reset', Lang.bind(this, this._onReset));
        this._userVerifier.connect('verification-complete', Lang.bind(this, this._onVerificationComplete));
    },
    _getForegroundService: function() {
        if (this._preemptingService)
            return this._preemptingService;
        return this._defaultService;
    },
    serviceIsForeground: function(serviceName) {
        return serviceName == this._getForegroundService();
    },
    serviceIsDefault: function(serviceName) {
        return serviceName == this._defaultService;
    },
    _updateDefaultService: function() {
        if (this._settings.get_boolean(PASSWORD_AUTHENTICATION_KEY))
            this._defaultService = PASSWORD_SERVICE_NAME;
        else if (this._settings.get_boolean(SMARTCARD_AUTHENTICATION_KEY))
            this._defaultService = SMARTCARD_SERVICE_NAME;
        else if (this._haveFingerprintReader)
            this._defaultService = FINGERPRINT_SERVICE_NAME;
    },
    _startService: function(serviceName) {
        this._hold.acquire();
        if (this._userName) {
           this._userVerifier.call_begin_verification_for_user(serviceName,
                                                               this._userName,
                                                               this._cancellable,
                                                               Lang.bind(this, function(obj, result) {
               try {
                   obj.call_begin_verification_for_user_finish(result);
               } catch(e if e.matches(Gio.IOErrorEnum, Gio.IOErrorEnum.CANCELLED)) {
                   return;
               } catch(e) {
                   this._reportInitError('Failed to start verification for user', e);
                   return;
               }
               this._hold.release();
           }));
        } else {
           this._userVerifier.call_begin_verification(serviceName,
                                                      this._cancellable,
                                                      Lang.bind(this, function(obj, result) {
               try {
                   obj.call_begin_verification_finish(result);
               } catch(e if e.matches(Gio.IOErrorEnum, Gio.IOErrorEnum.CANCELLED)) {
                   return;
               } catch(e) {
                   this._reportInitError('Failed to start verification', e);
                   return;
               }
               this._hold.release();
           }));
        }
    },
    _beginVerification: function() {
        this._startService(this._getForegroundService());
        if (this._userName && this._haveFingerprintReader && !this.serviceIsForeground(FINGERPRINT_SERVICE_NAME))
            this._startService(FINGERPRINT_SERVICE_NAME);
    },
    _onInfo: function(client, serviceName, info) {
        if (this.serviceIsForeground(serviceName)) {
            this._queueMessage(info, MessageType.INFO);
        } else if (serviceName == FINGERPRINT_SERVICE_NAME &&
            this._haveFingerprintReader) {
            // We don't show fingerprint messages directly since it's
            // not the main auth service. Instead we use the messages
            // as a cue to display our own message.
            // Translators: this message is shown below the password entry field
            // to indicate the user can swipe their finger instead
            this._queueMessage(_("(or swipe finger)"), MessageType.HINT);
        }
    },
    _onProblem: function(client, serviceName, problem) {
        if (!this.serviceIsForeground(serviceName))
            return;
        this._queueMessage(problem, MessageType.ERROR);
    },
    _onInfoQuery: function(client, serviceName, question) {
        if (!this.serviceIsForeground(serviceName))
            return;
        this.emit('ask-question', serviceName, question, '');
    },
    _onSecretInfoQuery: function(client, serviceName, secretQuestion) {
        if (!this.serviceIsForeground(serviceName))
            return;
        if (serviceName == OVIRT_SERVICE_NAME) {
            // The only question asked by this service is "Token?"
            this.answerQuery(serviceName, this._oVirtCredentialsManager.getToken());
            return;
        }
        this.emit('ask-question', serviceName, secretQuestion, '\u25cf');
    },
    _onReset: function() {
        // Clear previous attempts to authenticate
        this._failCounter = 0;
        this._updateDefaultService();
        this.emit('reset');
    },
    _onVerificationComplete: function() {
        this.emit('verification-complete');
    },
    _cancelAndReset: function() {
        this.cancel();
        this._onReset();
    },
    _retry: function() {
        this.begin(this._userName, new Batch.Hold());
    },
    _verificationFailed: function(retry) {
        // For Not Listed / enterprise logins, immediately reset
        // the dialog
        // Otherwise, we allow ALLOWED_FAILURES attempts. After that, we
        // go back to the welcome screen.
        this._failCounter++;
        let canRetry = retry && this._userName &&
            this._failCounter < this._settings.get_int(ALLOWED_FAILURES_KEY);
        if (canRetry) {
            if (!this.hasPendingMessages) {
                this._retry();
            } else {
                let signalId = this.connect('no-more-messages',
                                            Lang.bind(this, function() {
                                                this.disconnect(signalId);
                                                this._retry();
                                            }));
            }
        } else {
            if (!this.hasPendingMessages) {
                this._cancelAndReset();
            } else {
                let signalId = this.connect('no-more-messages',
                                            Lang.bind(this, function() {
                                                this.disconnect(signalId);
                                                this._cancelAndReset();
                                            }));
            }
        }
        this.emit('verification-failed');
    },
    _onConversationStopped: function(client, serviceName) {
        // If the login failed with the preauthenticated oVirt credentials
        // then discard the credentials and revert to default authentication
        // mechanism.
        if (this.serviceIsForeground(OVIRT_SERVICE_NAME)) {
            this._oVirtCredentialsManager.resetToken();
            this._preemptingService = null;
            this._verificationFailed(false);
            return;
        }
        // if the password service fails, then cancel everything.
        // But if, e.g., fingerprint fails, still give
        // password authentication a chance to succeed
        if (this.serviceIsForeground(serviceName)) {
            this._verificationFailed(true);
        }
    },
Signals.addSignalMethods(ShellUserVerifier.prototype);
(uuay)accessibility.js
// -*- mode: js; js-indent-level: 4; indent-tabs-mode: nil -*-
const Clutter = imports.gi.Clutter;
const Gio = imports.gi.Gio;
const GLib = imports.gi.GLib;
const Lang = imports.lang;
const Mainloop = imports.mainloop;
const St = imports.gi.St;
const PanelMenu = imports.ui.panelMenu;
const PopupMenu = imports.ui.popupMenu;
const A11Y_SCHEMA                   = 'org.gnome.desktop.a11y';
const KEY_ALWAYS_SHOW               = 'always-show-universal-access-status';
const A11Y_KEYBOARD_SCHEMA          = 'org.gnome.desktop.a11y.keyboard';
const KEY_STICKY_KEYS_ENABLED       = 'stickykeys-enable';
const KEY_BOUNCE_KEYS_ENABLED       = 'bouncekeys-enable';
const KEY_SLOW_KEYS_ENABLED         = 'slowkeys-enable';
const KEY_MOUSE_KEYS_ENABLED        = 'mousekeys-enable';
const APPLICATIONS_SCHEMA           = 'org.gnome.desktop.a11y.applications';
const DPI_FACTOR_LARGE              = 1.25;
const WM_SCHEMA                     = 'org.gnome.desktop.wm.preferences';
const KEY_VISUAL_BELL               = 'visual-bell';
const DESKTOP_INTERFACE_SCHEMA      = 'org.gnome.desktop.interface';
const KEY_GTK_THEME                 = 'gtk-theme';
const KEY_ICON_THEME                = 'icon-theme';
const KEY_WM_THEME                  = 'theme';
const KEY_TEXT_SCALING_FACTOR       = 'text-scaling-factor';
const HIGH_CONTRAST_THEME           = 'HighContrast';
const ATIndicator = new Lang.Class({
    Name: 'ATIndicator',
    Extends: PanelMenu.Button,
    _init: function() {
        this.parent(0.0, _("Accessibility"));
        this._hbox = new St.BoxLayout({ style_class: 'panel-status-menu-box' });
        this._hbox.add_child(new St.Icon({ style_class: 'system-status-icon',
                                           icon_name: 'preferences-desktop-accessibility-symbolic' }));
        this._hbox.add_child(PopupMenu.arrowIcon(St.Side.BOTTOM));
        this.actor.add_child(this._hbox);
        this._a11ySettings = new Gio.Settings({ schema_id: A11Y_SCHEMA });
        this._a11ySettings.connect('changed::' + KEY_ALWAYS_SHOW, Lang.bind(this, this._queueSyncMenuVisibility));
        let highContrast = this._buildHCItem();
        this.menu.addMenuItem(highContrast);
        let magnifier = this._buildItem(_("Zoom"), APPLICATIONS_SCHEMA,
                                                   'screen-magnifier-enabled');
        this.menu.addMenuItem(magnifier);
        let textZoom = this._buildFontItem();
        this.menu.addMenuItem(textZoom);
        let screenReader = this._buildItem(_("Screen Reader"), APPLICATIONS_SCHEMA,
                                                               'screen-reader-enabled');
        this.menu.addMenuItem(screenReader);
        let screenKeyboard = this._buildItem(_("Screen Keyboard"), APPLICATIONS_SCHEMA,
                                                                   'screen-keyboard-enabled');
        this.menu.addMenuItem(screenKeyboard);
        let visualBell = this._buildItem(_("Visual Alerts"), WM_SCHEMA, KEY_VISUAL_BELL);
        this.menu.addMenuItem(visualBell);
        let stickyKeys = this._buildItem(_("Sticky Keys"), A11Y_KEYBOARD_SCHEMA, KEY_STICKY_KEYS_ENABLED);
        this.menu.addMenuItem(stickyKeys);
        let slowKeys = this._buildItem(_("Slow Keys"), A11Y_KEYBOARD_SCHEMA, KEY_SLOW_KEYS_ENABLED);
        this.menu.addMenuItem(slowKeys);
        let bounceKeys = this._buildItem(_("Bounce Keys"), A11Y_KEYBOARD_SCHEMA, KEY_BOUNCE_KEYS_ENABLED);
        this.menu.addMenuItem(bounceKeys);
        let mouseKeys = this._buildItem(_("Mouse Keys"), A11Y_KEYBOARD_SCHEMA, KEY_MOUSE_KEYS_ENABLED);
        this.menu.addMenuItem(mouseKeys);
        this._syncMenuVisibility();
    },
    _syncMenuVisibility: function() {
        this._syncMenuVisibilityIdle = 0;
        let alwaysShow = this._a11ySettings.get_boolean(KEY_ALWAYS_SHOW);
        let items = this.menu._getMenuItems();
        this.actor.visible = alwaysShow || items.some(function(f) { return !!f.state; });
        return GLib.SOURCE_REMOVE;
    },
    _queueSyncMenuVisibility: function() {
        if (this._syncMenuVisibilityIdle)
            return;
        this._syncMenuVisbilityIdle = Mainloop.idle_add(Lang.bind(this, this._syncMenuVisibility));
        GLib.Source.set_name_by_id(this._syncMenuVisbilityIdle, '[gnome-shell] this._syncMenuVisibility');
    },
    _buildItemExtended: function(string, initial_value, writable, on_set) {
        let widget = new PopupMenu.PopupSwitchMenuItem(string, initial_value);
        if (!writable)
            widget.actor.reactive = false;
        else
            widget.connect('toggled', function(item) {
                on_set(item.state);
            });
        return widget;
    },
    _buildItem: function(string, schema, key) {
        let settings = new Gio.Settings({ schema_id: schema });
        settings.connect('changed::'+key, Lang.bind(this, function() {
            widget.setToggleState(settings.get_boolean(key));
            this._queueSyncMenuVisibility();
        }));
        let widget = this._buildItemExtended(string,
            settings.get_boolean(key),
            settings.is_writable(key),
            function(enabled) {
                return settings.set_boolean(key, enabled);
            });
        return widget;
    },
    _buildHCItem: function() {
        let interfaceSettings = new Gio.Settings({ schema_id: DESKTOP_INTERFACE_SCHEMA });
        let wmSettings = new Gio.Settings({ schema_id: WM_SCHEMA });
        interfaceSettings.connect('changed::' + KEY_GTK_THEME, Lang.bind(this, function() {
            let value = interfaceSettings.get_string(KEY_GTK_THEME);
            if (value == HIGH_CONTRAST_THEME) {
                highContrast.setToggleState(true);
            } else {
                highContrast.setToggleState(false);
                gtkTheme = value;
            }
            this._queueSyncMenuVisibility();
        }));
        interfaceSettings.connect('changed::' + KEY_ICON_THEME, function() {
            let value = interfaceSettings.get_string(KEY_ICON_THEME);
            if (value != HIGH_CONTRAST_THEME)
                iconTheme = value;
        });
        wmSettings.connect('changed::' + KEY_WM_THEME, function() {
            let value = wmSettings.get_string(KEY_WM_THEME);
            if (value != HIGH_CONTRAST_THEME)
                wmTheme = value;
        });
        let gtkTheme = interfaceSettings.get_string(KEY_GTK_THEME);
        let iconTheme = interfaceSettings.get_string(KEY_ICON_THEME);
        let wmTheme = wmSettings.get_string(KEY_WM_THEME);
        let hasHC = (gtkTheme == HIGH_CONTRAST_THEME);
        let highContrast = this._buildItemExtended(
            _("High Contrast"),
            hasHC,
            interfaceSettings.is_writable(KEY_GTK_THEME) &&
            interfaceSettings.is_writable(KEY_ICON_THEME) &&
            wmSettings.is_writable(KEY_WM_THEME),
            function (enabled) {
                if (enabled) {
                    interfaceSettings.set_string(KEY_GTK_THEME, HIGH_CONTRAST_THEME);
                    interfaceSettings.set_string(KEY_ICON_THEME, HIGH_CONTRAST_THEME);
                    wmSettings.set_string(KEY_WM_THEME, HIGH_CONTRAST_THEME);
                } else if(!hasHC) {
                    interfaceSettings.set_string(KEY_GTK_THEME, gtkTheme);
                    interfaceSettings.set_string(KEY_ICON_THEME, iconTheme);
                    wmSettings.set_string(KEY_WM_THEME, wmTheme);
                } else {
                    interfaceSettings.reset(KEY_GTK_THEME);
                    interfaceSettings.reset(KEY_ICON_THEME);
                    wmSettings.reset(KEY_WM_THEME);
                }
            });
        return highContrast;
    },
    _buildFontItem: function() {
        let settings = new Gio.Settings({ schema_id: DESKTOP_INTERFACE_SCHEMA });
        settings.connect('changed::' + KEY_TEXT_SCALING_FACTOR, Lang.bind(this, function() {
            let factor = settings.get_double(KEY_TEXT_SCALING_FACTOR);
            let active = (factor > 1.0);
            widget.setToggleState(active);
            this._queueSyncMenuVisibility();
        }));
        let factor = settings.get_double(KEY_TEXT_SCALING_FACTOR);
        let initial_setting = (factor > 1.0);
        let widget = this._buildItemExtended(_("Large Text"),
            initial_setting,
            settings.is_writable(KEY_TEXT_SCALING_FACTOR),
            function (enabled) {
                if (enabled)
                    settings.set_double(KEY_TEXT_SCALING_FACTOR,
                                        DPI_FACTOR_LARGE);
                else
                    settings.reset(KEY_TEXT_SCALING_FACTOR);
            });
        return widget;
    }
const ATGreeterIndicator = new Lang.Class({
    Name: 'ATGreeterIndicator',
    Extends: ATIndicator,
    // Override visibility handling to be always visible
    _syncMenuVisibility: function() { },
    _queueSyncMenuVisibility: function() { }
(uuay)gnomeSession.js
// -*- mode: js; js-indent-level: 4; indent-tabs-mode: nil -*-
const Gio = imports.gi.Gio;
const Lang = imports.lang;
const Signals = imports.signals;
const PresenceIface = '<node> \
<interface name="org.gnome.SessionManager.Presence"> \
<method name="SetStatus"> \
    <arg type="u" direction="in"/> \
</method> \
<property name="status" type="u" access="readwrite"/> \
<signal name="StatusChanged"> \
    <arg type="u" direction="out"/> \
</signal> \
</interface> \
</node>';
const PresenceStatus = {
    AVAILABLE: 0,
    INVISIBLE: 1,
    BUSY: 2,
    IDLE: 3
var PresenceProxy = Gio.DBusProxy.makeProxyWrapper(PresenceIface);
function Presence(initCallback, cancellable) {
    return new PresenceProxy(Gio.DBus.session, 'org.gnome.SessionManager',
                             '/org/gnome/SessionManager/Presence', initCallback, cancellable);
// Note inhibitors are immutable objects, so they don't
// change at runtime (changes always come in the form
// of new inhibitors)
const InhibitorIface = '<node> \
<interface name="org.gnome.SessionManager.Inhibitor"> \
<method name="GetAppId"> \
    <arg type="s" direction="out" /> \
</method> \
<method name="GetReason"> \
    <arg type="s" direction="out" /> \
</method> \
</interface> \
</node>';
var InhibitorProxy = Gio.DBusProxy.makeProxyWrapper(InhibitorIface);
function Inhibitor(objectPath, initCallback, cancellable) {
    return new InhibitorProxy(Gio.DBus.session, 'org.gnome.SessionManager', objectPath, initCallback, cancellable);
// Not the full interface, only the methods we use
const SessionManagerIface = '<node> \
<interface name="org.gnome.SessionManager"> \
<method name="Logout"> \
    <arg type="u" direction="in" /> \
</method> \
<method name="Shutdown" /> \
<method name="Reboot" /> \
<method name="CanShutdown"> \
    <arg type="b" direction="out" /> \
</method> \
<method name="IsInhibited"> \
    <arg type="u" direction="in" /> \
    <arg type="b" direction="out" /> \
</method> \
<property name="SessionIsActive" type="b" access="read"/> \
<signal name="InhibitorAdded"> \
    <arg type="o" direction="out"/> \
</signal> \
<signal name="InhibitorRemoved"> \
    <arg type="o" direction="out"/> \
</signal> \
</interface> \
</node>';
var SessionManagerProxy = Gio.DBusProxy.makeProxyWrapper(SessionManagerIface);
function SessionManager(initCallback, cancellable) {
    return new SessionManagerProxy(Gio.DBus.session, 'org.gnome.SessionManager', '/org/gnome/SessionManager', initCallback, cancellable);
(uuay)extensionPrefs/
accessDialog.js
const Clutter = imports.gi.Clutter;
const Gio = imports.gi.Gio;
const GLib = imports.gi.GLib;
const Lang = imports.lang;
const Pango = imports.gi.Pango;
const Shell = imports.gi.Shell;
const St = imports.gi.St;
const CheckBox = imports.ui.checkBox;
const ModalDialog = imports.ui.modalDialog;
const RequestIface = '<node> \
<interface name="org.freedesktop.impl.portal.Request"> \
<method name="Close"/> \
</interface> \
</node>';
const AccessIface = '<node> \
<interface name="org.freedesktop.impl.portal.Access"> \
<method name="AccessDialog"> \
  <arg type="o" name="handle" direction="in"/> \
  <arg type="s" name="app_id" direction="in"/> \
  <arg type="s" name="parent_window" direction="in"/> \
  <arg type="s" name="title" direction="in"/> \
  <arg type="s" name="subtitle" direction="in"/> \
  <arg type="s" name="body" direction="in"/> \
  <arg type="a{sv}" name="options" direction="in"/> \
  <arg type="u" name="response" direction="out"/> \
  <arg type="a{sv}" name="results" direction="out"/> \
</method> \
</interface> \
</node>';
const DialogResponse = {
    OK: 0,
    CANCEL: 1,
    CLOSED: 2
const AccessDialog = new Lang.Class({
    Name: 'AccessDialog',
    Extends: ModalDialog.ModalDialog,
    _init: function(invocation, handle, title, subtitle, body, options) {
        this.parent({ styleClass: 'access-dialog' });
        this._invocation = invocation;
        this._handle = handle;
        this._requestExported = false;
        this._request = Gio.DBusExportedObject.wrapJSObject(RequestIface, this);
        for (let option in options)
            options[option] = options[option].deep_unpack();
        this._buildLayout(title, subtitle, body, options);
    },
    _buildLayout: function(title, subtitle, body, options) {
        // No support for non-modal system dialogs, so ignore the option
        //let modal = options['modal'] || true;
        let denyLabel = options['deny_label'] || _("Deny Access");
        let grantLabel = options['grant_label'] || _("Grant Access");
        let iconName = options['icon'] || null;
        let choices = options['choices'] || [];
        let mainContentBox = new St.BoxLayout();
        mainContentBox.style_class = 'access-dialog-main-layout';
        this.contentLayout.add_actor(mainContentBox);
        let icon = new St.Icon({ style_class: 'access-dialog-icon',
                                 icon_name: iconName,
                                 y_align: Clutter.ActorAlign.START });
        mainContentBox.add_actor(icon);
        let messageBox = new St.BoxLayout({ vertical: true });
        messageBox.style_class = 'access-dialog-content',
        mainContentBox.add_actor(messageBox);
        let label;
        label = new St.Label({ style_class: 'access-dialog-title headline',
                               text: title });
        messageBox.add_actor(label);
        label = new St.Label({ style_class: 'access-dialog-subtitle',
                               text: subtitle });
        label.clutter_text.ellipsize = Pango.EllipsizeMode.NONE;
        label.clutter_text.line_wrap = true;
        messageBox.add_actor(label);
        this._choices = new Map();
        for (let i = 0; i < choices.length; i++) {
            let [id, name, opts, selected] = choices[i];
            if (opts.length > 0)
                continue; // radio buttons, not implemented
            let check = new CheckBox.CheckBox();
            check.getLabelActor().text = name;
            check.actor.checked = selected == "true";
            messageBox.add_actor(check.actor);
            this._choices.set(id, check);
        }
        label = new St.Label({ text: body });
        label.clutter_text.ellipsize = Pango.EllipsizeMode.NONE;
        label.clutter_text.line_wrap = true;
        messageBox.add_actor(label);
        this.addButton({ label: denyLabel,
                         action: () => {
                             this._sendResponse(DialogResponse.CANCEL);
                         },
                         key: Clutter.KEY_Escape });
        this.addButton({ label: grantLabel,
                         action: () => {
                             this._sendResponse(DialogResponse.OK);
                         }});
    },
    open: function() {
        this.parent();
        let connection = this._invocation.get_connection();
        this._requestExported = this._request.export(connection, this._handle);
    },
    CloseAsync: function(invocation, params) {
        if (this._invocation.get_sender() != invocation.get_sender()) {
            invocation.return_error_literal(Gio.DBusError,
                                            Gio.DBusError.ACCESS_DENIED,
                                            '');
            return;
        }
        this._sendResponse(DialogResponse.CLOSED);
    },
    _sendResponse: function(response) {
        if (this._requestExported)
            this._request.unexport();
        this._requestExported = false;
        let results = {};
        if (response == DialogResponse.OK) {
            for (let [id, check] of this._choices) {
                let checked = check.actor.checked ? 'true' : 'false';
                results[id] = new GLib.Variant('s', checked);
            }
        }
        // Delay actual response until the end of the close animation (if any)
        this.connect('closed', () => {
            this._invocation.return_value(new GLib.Variant('(ua{sv})',
                                                           [response, results]));
        });
        this.close();
    }
const AccessDialogDBus = new Lang.Class({
    Name: 'AccessDialogDBus',
    _init: function() {
        this._accessDialog = null;
        this._windowTracker = Shell.WindowTracker.get_default();
        this._dbusImpl = Gio.DBusExportedObject.wrapJSObject(AccessIface, this);
        this._dbusImpl.export(Gio.DBus.session, '/org/freedesktop/portal/desktop');
        Gio.DBus.session.own_name('org.freedesktop.impl.portal.desktop.gnome', Gio.BusNameOwnerFlags.REPLACE, null, null);
    },
    AccessDialogAsync: function(params, invocation) {
        if (this._accessDialog) {
            invocation.return_error_literal(Gio.DBusError,
                                            Gio.DBusError.LIMITS_EXCEEDED,
                                            'Already showing a system access dialog');
            return;
        }
        let [handle, appId, parentWindow, title, subtitle, body, options] = params;
        // We probably want to use parentWindow and global.display.focus_window
        // for this check in the future
        if (appId && appId + '.desktop' != this._windowTracker.focus_app.id) {
            invocation.return_error_literal(Gio.DBusError,
                                            Gio.DBusError.ACCESS_DENIED,
                                            'Only the focused app is allowed to show a system access dialog');
            return;
        }
        let dialog = new AccessDialog(invocation, handle, title,
                                      subtitle, body, options);
        dialog.open();
        dialog.connect('closed', () => { this._accessDialog = null; });
        this._accessDialog = dialog;
    }
(uuay)modalDialog.js
// -*- mode: js; js-indent-level: 4; indent-tabs-mode: nil -*-
const Clutter = imports.gi.Clutter;
const Gdk = imports.gi.Gdk;
const Gio = imports.gi.Gio;
const GLib = imports.gi.GLib;
const Lang = imports.lang;
const Meta = imports.gi.Meta;
const Pango = imports.gi.Pango;
const St = imports.gi.St;
const Shell = imports.gi.Shell;
const Signals = imports.signals;
const Atk = imports.gi.Atk;
const Params = imports.misc.params;
const Layout = imports.ui.layout;
const Lightbox = imports.ui.lightbox;
const Main = imports.ui.main;
const Tweener = imports.ui.tweener;
const OPEN_AND_CLOSE_TIME = 0.1;
const FADE_OUT_DIALOG_TIME = 1.0;
const State = {
    OPENED: 0,
    CLOSED: 1,
    OPENING: 2,
    CLOSING: 3,
    FADED_OUT: 4
const ModalDialog = new Lang.Class({
    Name: 'ModalDialog',
    _init: function(params) {
        params = Params.parse(params, { shellReactive: false,
                                        styleClass: null,
                                        actionMode: Shell.ActionMode.SYSTEM_MODAL,
                                        shouldFadeIn: true,
                                        shouldFadeOut: true,
                                        destroyOnClose: true });
        this.state = State.CLOSED;
        this._hasModal = false;
        this._actionMode = params.actionMode;
        this._shellReactive = params.shellReactive;
        this._shouldFadeIn = params.shouldFadeIn;
        this._shouldFadeOut = params.shouldFadeOut;
        this._destroyOnClose = params.destroyOnClose;
        this._group = new St.Widget({ visible: false,
                                      x: 0,
                                      y: 0,
                                      accessible_role: Atk.Role.DIALOG });
        Main.layoutManager.modalDialogGroup.add_actor(this._group);
        let constraint = new Clutter.BindConstraint({ source: global.stage,
                                                      coordinate: Clutter.BindCoordinate.ALL });
        this._group.add_constraint(constraint);
        this._group.connect('destroy', Lang.bind(this, this._onGroupDestroy));
        this._pressedKey = null;
        this._buttonKeys = {};
        this._group.connect('key-press-event', Lang.bind(this, this._onKeyPressEvent));
        this._group.connect('key-release-event', Lang.bind(this, this._onKeyReleaseEvent));
        this.backgroundStack = new St.Widget({ layout_manager: new Clutter.BinLayout() });
        this._backgroundBin = new St.Bin({ child: this.backgroundStack,
                                           x_fill: true, y_fill: true });
        this._monitorConstraint = new Layout.MonitorConstraint();
        this._backgroundBin.add_constraint(this._monitorConstraint);
        this._group.add_actor(this._backgroundBin);
        this.dialogLayout = new St.BoxLayout({ style_class: 'modal-dialog',
                                               x_align:      Clutter.ActorAlign.CENTER,
                                               y_align:      Clutter.ActorAlign.CENTER,
                                               vertical:     true });
        // modal dialogs are fixed width and grow vertically; set the request
        // mode accordingly so wrapped labels are handled correctly during
        // size requests.
        this.dialogLayout.request_mode = Clutter.RequestMode.HEIGHT_FOR_WIDTH;
        if (params.styleClass != null)
            this.dialogLayout.add_style_class_name(params.styleClass);
        if (!this._shellReactive) {
            this._lightbox = new Lightbox.Lightbox(this._group,
                                                   { inhibitEvents: true,
                                                     radialEffect: true });
            this._lightbox.highlight(this._backgroundBin);
            this._eventBlocker = new Clutter.Actor({ reactive: true });
            this.backgroundStack.add_actor(this._eventBlocker);
        }
        this.backgroundStack.add_actor(this.dialogLayout);
        this.contentLayout = new St.BoxLayout({ vertical: true,
                                                style_class: "modal-dialog-content-box" });
        this.dialogLayout.add(this.contentLayout,
                              { expand:  true,
                                x_fill:  true,
                                y_fill:  true,
                                x_align: St.Align.MIDDLE,
                                y_align: St.Align.START });
        this.buttonLayout = new St.Widget ({ layout_manager: new Clutter.BoxLayout ({ homogeneous:true }) });
        this.dialogLayout.add(this.buttonLayout,
                              { x_align: St.Align.MIDDLE,
                                y_align: St.Align.END });
        global.focus_manager.add_group(this.dialogLayout);
        this._initialKeyFocus = this.dialogLayout;
        this._initialKeyFocusDestroyId = 0;
        this._savedKeyFocus = null;
    },
    destroy: function() {
        this._group.destroy();
    },
    clearButtons: function() {
        this.buttonLayout.destroy_all_children();
        this._buttonKeys = {};
    },
    setButtons: function(buttons) {
        this.clearButtons();
        for (let i = 0; i < buttons.length; i++) {
            let buttonInfo = buttons[i];
            let x_alignment;
            if (buttons.length == 1)
                x_alignment = St.Align.END;
            else if (i == 0)
                x_alignment = St.Align.START;
            else if (i == buttons.length - 1)
                x_alignment = St.Align.END;
            else
                x_alignment = St.Align.MIDDLE;
            this.addButton(buttonInfo);
        }
    },
    addButton: function(buttonInfo) {
        let label = buttonInfo['label']
        let action = buttonInfo['action'];
        let key = buttonInfo['key'];
        let isDefault = buttonInfo['default'];
        let keys;
        if (key)
            keys = [key];
        else if (isDefault)
            keys = [Clutter.KEY_Return, Clutter.KEY_KP_Enter, Clutter.KEY_ISO_Enter];
        else
            keys = [];
        let button = new St.Button({ style_class: 'modal-dialog-linked-button',
                                     button_mask: St.ButtonMask.ONE | St.ButtonMask.THREE,
                                     reactive:    true,
                                     can_focus:   true,
                                     x_expand:    true,
                                     y_expand:    true,
                                     label:       label });
        button.connect('clicked', action);
        buttonInfo['button'] = button;
        if (isDefault)
            button.add_style_pseudo_class('default');
        if (!this._initialKeyFocusDestroyId)
            this._initialKeyFocus = button;
        for (let i in keys)
            this._buttonKeys[keys[i]] = buttonInfo;
        this.buttonLayout.add_actor(button);
        return button;
    },
    _onKeyPressEvent: function(object, event) {
        this._pressedKey = event.get_key_symbol();
        return Clutter.EVENT_PROPAGATE;
    },
    _onKeyReleaseEvent: function(object, event) {
        let pressedKey = this._pressedKey;
        this._pressedKey = null;
        let symbol = event.get_key_symbol();
        if (symbol != pressedKey)
            return Clutter.EVENT_PROPAGATE;
        let buttonInfo = this._buttonKeys[symbol];
        if (!buttonInfo)
            return Clutter.EVENT_PROPAGATE;
        let button = buttonInfo['button'];
        let action = buttonInfo['action'];
        if (action && button.reactive) {
            action();
            return Clutter.EVENT_STOP;
        }
        return Clutter.EVENT_PROPAGATE;
    },
    _onGroupDestroy: function() {
        this.emit('destroy');
    },
    _fadeOpen: function(onPrimary) {
        if (onPrimary)
            this._monitorConstraint.primary = true;
        else
            this._monitorConstraint.index = global.screen.get_current_monitor();
        this.state = State.OPENING;
        this.dialogLayout.opacity = 255;
        if (this._lightbox)
            this._lightbox.show();
        this._group.opacity = 0;
        this._group.show();
        Tweener.addTween(this._group,
                         { opacity: 255,
                           time: this._shouldFadeIn ? OPEN_AND_CLOSE_TIME : 0,
                           transition: 'easeOutQuad',
                           onComplete: Lang.bind(this,
                               function() {
                                   this.state = State.OPENED;
                                   this.emit('opened');
                               })
                         });
    },
    setInitialKeyFocus: function(actor) {
        if (this._initialKeyFocusDestroyId)
            this._initialKeyFocus.disconnect(this._initialKeyFocusDestroyId);
        this._initialKeyFocus = actor;
        this._initialKeyFocusDestroyId = actor.connect('destroy', Lang.bind(this, function() {
            this._initialKeyFocus = this.dialogLayout;
            this._initialKeyFocusDestroyId = 0;
        }));
    },
    open: function(timestamp, onPrimary) {
        if (this.state == State.OPENED || this.state == State.OPENING)
            return true;
        if (!this.pushModal(timestamp))
            return false;
        this._fadeOpen(onPrimary);
        return true;
    },
    _closeComplete: function() {
        this.state = State.CLOSED;
        this._group.hide();
        this.emit('closed');
        if (this._destroyOnClose)
            this.destroy();
    },
    close: function(timestamp) {
        if (this.state == State.CLOSED || this.state == State.CLOSING)
            return;
        this.state = State.CLOSING;
        this.popModal(timestamp);
        this._savedKeyFocus = null;
        if (this._shouldFadeOut)
            Tweener.addTween(this._group,
                             { opacity: 0,
                               time: OPEN_AND_CLOSE_TIME,
                               transition: 'easeOutQuad',
                               onComplete: Lang.bind(this,
                                                     this._closeComplete)
                             })
        else
            this._closeComplete();
    },
    // Drop modal status without closing the dialog; this makes the
    // dialog insensitive as well, so it needs to be followed shortly
    // by either a close() or a pushModal()
    popModal: function(timestamp) {
        if (!this._hasModal)
            return;
        let focus = global.stage.key_focus;
        if (focus && this._group.contains(focus))
            this._savedKeyFocus = focus;
        else
            this._savedKeyFocus = null;
        Main.popModal(this._group, timestamp);
        global.gdk_screen.get_display().sync();
        this._hasModal = false;
        if (!this._shellReactive)
            this._eventBlocker.raise_top();
    },
    pushModal: function (timestamp) {
        if (this._hasModal)
            return true;
        let params = { actionMode: this._actionMode };
        if (timestamp)
            params['timestamp'] = timestamp;
        if (!Main.pushModal(this._group, params))
            return false;
        this._hasModal = true;
        if (this._savedKeyFocus) {
            this._savedKeyFocus.grab_key_focus();
            this._savedKeyFocus = null;
        } else {
            this._initialKeyFocus.grab_key_focus();
        }
        if (!this._shellReactive)
            this._eventBlocker.lower_bottom();
        return true;
    },
    // This method is like close, but fades the dialog out much slower,
    // and leaves the lightbox in place. Once in the faded out state,
    // the dialog can be brought back by an open call, or the lightbox
    // can be dismissed by a close call.
    //
    // The main point of this method is to give some indication to the user
    // that the dialog reponse has been acknowledged but will take a few
    // moments before being processed.
    // e.g., if a user clicked "Log Out" then the dialog should go away
    // imediately, but the lightbox should remain until the logout is
    // complete.
    _fadeOutDialog: function(timestamp) {
        if (this.state == State.CLOSED || this.state == State.CLOSING)
            return;
        if (this.state == State.FADED_OUT)
            return;
        this.popModal(timestamp);
        Tweener.addTween(this.dialogLayout,
                         { opacity: 0,
                           time:    FADE_OUT_DIALOG_TIME,
                           transition: 'easeOutQuad',
                           onComplete: Lang.bind(this,
                               function() {
                                   this.state = State.FADED_OUT;
                               })
                         });
    }
Signals.addSignalMethods(ModalDialog.prototype);
(uuay)windowManager.js
// -*- mode: js; js-indent-level: 4; indent-tabs-mode: nil -*-
const Clutter = imports.gi.Clutter;
const GLib = imports.gi.GLib;
const Gio = imports.gi.Gio;
const Lang = imports.lang;
const Mainloop = imports.mainloop;
const Meta = imports.gi.Meta;
const Pango = imports.gi.Pango;
const St = imports.gi.St;
const Shell = imports.gi.Shell;
const Signals = imports.signals;
const AltTab = imports.ui.altTab;
const WorkspaceSwitcherPopup = imports.ui.workspaceSwitcherPopup;
const Main = imports.ui.main;
const ModalDialog = imports.ui.modalDialog;
const Tweener = imports.ui.tweener;
const WindowMenu = imports.ui.windowMenu;
const SHELL_KEYBINDINGS_SCHEMA = 'org.gnome.shell.keybindings';
const MINIMIZE_WINDOW_ANIMATION_TIME = 0.2;
const SHOW_WINDOW_ANIMATION_TIME = 0.15;
const DIALOG_SHOW_WINDOW_ANIMATION_TIME = 0.1;
const DESTROY_WINDOW_ANIMATION_TIME = 0.15;
const DIALOG_DESTROY_WINDOW_ANIMATION_TIME = 0.1;
const WINDOW_ANIMATION_TIME = 0.25;
const DIM_BRIGHTNESS = -0.3;
const DIM_TIME = 0.500;
const UNDIM_TIME = 0.250;
const DISPLAY_REVERT_TIMEOUT = 20; // in seconds - keep in sync with mutter
const ONE_SECOND = 1000; // in ms
const DisplayChangeDialog = new Lang.Class({
    Name: 'DisplayChangeDialog',
    Extends: ModalDialog.ModalDialog,
    _init: function(wm) {
        this.parent({ styleClass: 'prompt-dialog' });
        this._wm = wm;
        let mainContentBox = new St.BoxLayout({ style_class: 'prompt-dialog-main-layout',
                                                vertical: false });
        this.contentLayout.add(mainContentBox,
                               { x_fill: true,
                                 y_fill: true });
        let icon = new St.Icon({ icon_name: 'preferences-desktop-display-symbolic' });
        mainContentBox.add(icon,
                           { x_fill:  true,
                             y_fill:  false,
                             x_align: St.Align.END,
                             y_align: St.Align.START });
        let messageBox = new St.BoxLayout({ style_class: 'prompt-dialog-message-layout',
                                            vertical: true });
        mainContentBox.add(messageBox,
                           { expand: true, y_align: St.Align.START });
        let subjectLabel = new St.Label({ style_class: 'prompt-dialog-headline',
                                            text: _("Do you want to keep these display settings?") });
        messageBox.add(subjectLabel,
                       { y_fill:  false,
                         y_align: St.Align.START });
        this._countDown = DISPLAY_REVERT_TIMEOUT;
        let message = this._formatCountDown();
        this._descriptionLabel = new St.Label({ style_class: 'prompt-dialog-description',
                                                text: this._formatCountDown() });
        this._descriptionLabel.clutter_text.ellipsize = Pango.EllipsizeMode.NONE;
        this._descriptionLabel.clutter_text.line_wrap = true;
        messageBox.add(this._descriptionLabel,
                       { y_fill:  true,
                         y_align: St.Align.START });
        /* Translators: this and the following message should be limited in lenght,
           to avoid ellipsizing the labels.
        */
        this._cancelButton = this.addButton({ label: _("Revert Settings"),
                                              action: Lang.bind(this, this._onFailure),
                                              key: Clutter.Escape });
        this._okButton = this.addButton({ label:  _("Keep Changes"),
                                          action: Lang.bind(this, this._onSuccess),
                                          default: true });
        this._timeoutId = Mainloop.timeout_add(ONE_SECOND, Lang.bind(this, this._tick));
        GLib.Source.set_name_by_id(this._timeoutId, '[gnome-shell] this._tick');
    },
    close: function(timestamp) {
        if (this._timeoutId > 0) {
            Mainloop.source_remove(this._timeoutId);
            this._timeoutId = 0;
        }
        this.parent(timestamp);
    },
    _formatCountDown: function() {
        let fmt = ngettext("Settings changes will revert in %d second",
                           "Settings changes will revert in %d seconds");
        return fmt.format(this._countDown);
    },
    _tick: function() {
        this._countDown--;
        if (this._countDown == 0) {
            /* mutter already takes care of failing at timeout */
            this._timeoutId = 0;
            this.close();
            return GLib.SOURCE_REMOVE;
        }
        this._descriptionLabel.text = this._formatCountDown();
        return GLib.SOURCE_CONTINUE;
    },
    _onFailure: function() {
        this._wm.complete_display_change(false);
        this.close();
    },
    _onSuccess: function() {
        this._wm.complete_display_change(true);
        this.close();
    },
const WindowDimmer = new Lang.Class({
    Name: 'WindowDimmer',
    _init: function(actor) {
        this._brightnessEffect = new Clutter.BrightnessContrastEffect();
        actor.add_effect(this._brightnessEffect);
        this.actor = actor;
        this._enabled = true;
        this._dimFactor = 0.0;
        this._syncEnabled();
    },
    _syncEnabled: function() {
        this._brightnessEffect.enabled = (this._enabled && this._dimFactor > 0);
    },
    setEnabled: function(enabled) {
        this._enabled = enabled;
        this._syncEnabled();
    },
    set dimFactor(factor) {
        this._dimFactor = factor;
        this._brightnessEffect.set_brightness(factor * DIM_BRIGHTNESS);
        this._syncEnabled();
    },
    get dimFactor() {
        return this._dimFactor;
    }
function getWindowDimmer(actor) {
    let enabled = Meta.prefs_get_attach_modal_dialogs();
    if (actor._windowDimmer)
        actor._windowDimmer.setEnabled(enabled);
    if (enabled) {
        if (!actor._windowDimmer)
            actor._windowDimmer = new WindowDimmer(actor);
        return actor._windowDimmer;
    } else {
        return null;
    }
 * When the last window closed on a workspace is a dialog or splash
 * screen, we assume that it might be an initial window shown before
 * the main window of an application, and give the app a grace period
 * where it can map another window before we remove the workspace.
const LAST_WINDOW_GRACE_TIME = 1000;
const WorkspaceTracker = new Lang.Class({
    Name: 'WorkspaceTracker',
    _init: function(wm) {
        this._wm = wm;
        this._workspaces = [];
        this._checkWorkspacesId = 0;
        this._pauseWorkspaceCheck = false;
        let tracker = Shell.WindowTracker.get_default();
        tracker.connect('startup-sequence-changed', Lang.bind(this, this._queueCheckWorkspaces));
        global.screen.connect('notify::n-workspaces', Lang.bind(this, this._nWorkspacesChanged));
        global.window_manager.connect('switch-workspace', Lang.bind(this, this._queueCheckWorkspaces));
        global.screen.connect('window-entered-monitor', Lang.bind(this, this._windowEnteredMonitor));
        global.screen.connect('window-left-monitor', Lang.bind(this, this._windowLeftMonitor));
        global.screen.connect('restacked', Lang.bind(this, this._windowsRestacked));
        this._workspaceSettings = this._getWorkspaceSettings();
        this._workspaceSettings.connect('changed::dynamic-workspaces', Lang.bind(this, this._queueCheckWorkspaces));
        this._nWorkspacesChanged();
    },
    _getWorkspaceSettings: function() {
        let settings = global.get_overrides_settings();
        if (settings &&
            settings.settings_schema.list_keys().indexOf('dynamic-workspaces') > -1)
            return settings;
        return new Gio.Settings({ schema_id: 'org.gnome.mutter' });
    },
    blockUpdates: function() {
        this._pauseWorkspaceCheck = true;
    },
    unblockUpdates: function() {
        this._pauseWorkspaceCheck = false;
    },
    _checkWorkspaces: function() {
        let i;
        let emptyWorkspaces = [];
        if (!Meta.prefs_get_dynamic_workspaces()) {
            this._checkWorkspacesId = 0;
            return false;
        }
        // Update workspaces only if Dynamic Workspace Management has not been paused by some other function
        if (this._pauseWorkspaceCheck)
            return true;
        for (i = 0; i < this._workspaces.length; i++) {
            let lastRemoved = this._workspaces[i]._lastRemovedWindow;
            if ((lastRemoved &&
                 (lastRemoved.get_window_type() == Meta.WindowType.SPLASHSCREEN ||
                  lastRemoved.get_window_type() == Meta.WindowType.DIALOG ||
                  lastRemoved.get_window_type() == Meta.WindowType.MODAL_DIALOG)) ||
                this._workspaces[i]._keepAliveId)
                emptyWorkspaces[i] = false;
            else
                emptyWorkspaces[i] = true;
        }
        let sequences = Shell.WindowTracker.get_default().get_startup_sequences();
        for (i = 0; i < sequences.length; i++) {
            let index = sequences[i].get_workspace();
            if (index >= 0 && index <= global.screen.n_workspaces)
                emptyWorkspaces[index] = false;
        }
        let windows = global.get_window_actors();
        for (i = 0; i < windows.length; i++) {
            let actor = windows[i];
            let win = actor.get_meta_window();
            if (win.is_on_all_workspaces())
                continue;
            let workspaceIndex = win.get_workspace().index();
            emptyWorkspaces[workspaceIndex] = false;
        }
        // If we don't have an empty workspace at the end, add one
        if (!emptyWorkspaces[emptyWorkspaces.length -1]) {
            global.screen.append_new_workspace(false, global.get_current_time());
            emptyWorkspaces.push(false);
        }
        let activeWorkspaceIndex = global.screen.get_active_workspace_index();
        emptyWorkspaces[activeWorkspaceIndex] = false;
        // Delete other empty workspaces; do it from the end to avoid index changes
        for (i = emptyWorkspaces.length - 2; i >= 0; i--) {
            if (emptyWorkspaces[i])
                global.screen.remove_workspace(this._workspaces[i], global.get_current_time());
        }
        this._checkWorkspacesId = 0;
        return false;
    },
    keepWorkspaceAlive: function(workspace, duration) {
        if (workspace._keepAliveId)
            Mainloop.source_remove(workspace._keepAliveId);
        workspace._keepAliveId = Mainloop.timeout_add(duration, Lang.bind(this, function() {
            workspace._keepAliveId = 0;
            this._queueCheckWorkspaces();
            return GLib.SOURCE_REMOVE;
        }));
        GLib.Source.set_name_by_id(workspace._keepAliveId, '[gnome-shell] this._queueCheckWorkspaces');
    },
    _windowRemoved: function(workspace, window) {
        workspace._lastRemovedWindow = window;
        this._queueCheckWorkspaces();
        let id = Mainloop.timeout_add(LAST_WINDOW_GRACE_TIME, Lang.bind(this, function() {
            if (workspace._lastRemovedWindow == window) {
                workspace._lastRemovedWindow = null;
                this._queueCheckWorkspaces();
            }
            return GLib.SOURCE_REMOVE;
        }));
        GLib.Source.set_name_by_id(id, '[gnome-shell] this._queueCheckWorkspaces');
    },
    _windowLeftMonitor: function(metaScreen, monitorIndex, metaWin) {
        // If the window left the primary monitor, that
        // might make that workspace empty
        if (monitorIndex == Main.layoutManager.primaryIndex)
            this._queueCheckWorkspaces();
    },
    _windowEnteredMonitor: function(metaScreen, monitorIndex, metaWin) {
        // If the window entered the primary monitor, that
        // might make that workspace non-empty
        if (monitorIndex == Main.layoutManager.primaryIndex)
            this._queueCheckWorkspaces();
    },
    _windowsRestacked: function() {
        // Figure out where the pointer is in case we lost track of
        // it during a grab. (In particular, if a trayicon popup menu
        // is dismissed, see if we need to close the message tray.)
        global.sync_pointer();
    },
    _queueCheckWorkspaces: function() {
        if (this._checkWorkspacesId == 0)
            this._checkWorkspacesId = Meta.later_add(Meta.LaterType.BEFORE_REDRAW, Lang.bind(this, this._checkWorkspaces));
    },
    _nWorkspacesChanged: function() {
        let oldNumWorkspaces = this._workspaces.length;
        let newNumWorkspaces = global.screen.n_workspaces;
        if (oldNumWorkspaces == newNumWorkspaces)
            return false;
        let lostWorkspaces = [];
        if (newNumWorkspaces > oldNumWorkspaces) {
            let w;
            // Assume workspaces are only added at the end
            for (w = oldNumWorkspaces; w < newNumWorkspaces; w++)
                this._workspaces[w] = global.screen.get_workspace_by_index(w);
            for (w = oldNumWorkspaces; w < newNumWorkspaces; w++) {
                let workspace = this._workspaces[w];
                workspace._windowAddedId = workspace.connect('window-added', Lang.bind(this, this._queueCheckWorkspaces));
                workspace._windowRemovedId = workspace.connect('window-removed', Lang.bind(this, this._windowRemoved));
            }
        } else {
            // Assume workspaces are only removed sequentially
            // (e.g. 2,3,4 - not 2,4,7)
            let removedIndex;
            let removedNum = oldNumWorkspaces - newNumWorkspaces;
            for (let w = 0; w < oldNumWorkspaces; w++) {
                let workspace = global.screen.get_workspace_by_index(w);
                if (this._workspaces[w] != workspace) {
                    removedIndex = w;
                    break;
                }
            }
            let lostWorkspaces = this._workspaces.splice(removedIndex, removedNum);
            lostWorkspaces.forEach(function(workspace) {
                workspace.disconnect(workspace._windowAddedId);
                workspace.disconnect(workspace._windowRemovedId);
            });
        }
        this._queueCheckWorkspaces();
        return false;
    }
const TilePreview = new Lang.Class({
    Name: 'TilePreview',
    _init: function() {
        this.actor = new St.Widget();
        global.window_group.add_actor(this.actor);
        this._reset();
        this._showing = false;
    },
    show: function(window, tileRect, monitorIndex) {
        let windowActor = window.get_compositor_private();
        if (!windowActor)
            return;
        global.window_group.set_child_below_sibling(this.actor, windowActor);
        if (this._rect && this._rect.equal(tileRect))
            return;
        let changeMonitor = (this._monitorIndex == -1 ||
                             this._monitorIndex != monitorIndex);
        this._monitorIndex = monitorIndex;
        this._rect = tileRect;
        let monitor = Main.layoutManager.monitors[monitorIndex];
        this._updateStyle(monitor);
        if (!this._showing || changeMonitor) {
            let monitorRect = new Meta.Rectangle({ x: monitor.x,
                                                   y: monitor.y,
                                                   width: monitor.width,
                                                   height: monitor.height });
            let [, rect] = window.get_frame_rect().intersect(monitorRect);
            this.actor.set_size(rect.width, rect.height);
            this.actor.set_position(rect.x, rect.y);
            this.actor.opacity = 0;
        }
        this._showing = true;
        this.actor.show();
        Tweener.addTween(this.actor,
                         { x: tileRect.x,
                           y: tileRect.y,
                           width: tileRect.width,
                           height: tileRect.height,
                           opacity: 255,
                           time: WINDOW_ANIMATION_TIME,
                           transition: 'easeOutQuad'
                         });
    },
    hide: function() {
        if (!this._showing)
            return;
        this._showing = false;
        Tweener.addTween(this.actor,
                         { opacity: 0,
                           time: WINDOW_ANIMATION_TIME,
                           transition: 'easeOutQuad',
                           onComplete: Lang.bind(this, this._reset)
                         });
    },
    _reset: function() {
        this.actor.hide();
        this._rect = null;
        this._monitorIndex = -1;
    },
    _updateStyle: function(monitor) {
        let styles = ['tile-preview'];
        if (this._monitorIndex == Main.layoutManager.primaryIndex)
            styles.push('on-primary');
        if (this._rect.x == monitor.x)
            styles.push('tile-preview-left');
        if (this._rect.x + this._rect.width == monitor.x + monitor.width)
            styles.push('tile-preview-right');
        this.actor.style_class = styles.join(' ');
    }
const TouchpadWorkspaceSwitchAction = new Lang.Class({
    Name: 'TouchpadWorkspaceSwitchAction',
    _init: function(actor) {
        this._dx = 0;
        this._dy = 0;
        actor.connect('captured-event', Lang.bind(this, this._handleEvent));
    },
    _checkActivated: function() {
        const MOTION_THRESHOLD = 50;
        let allowedModes = Shell.ActionMode.NORMAL | Shell.ActionMode.OVERVIEW;
        let dir;
        if ((allowedModes & Main.actionMode) == 0)
            return;
        if (this._dy < -MOTION_THRESHOLD)
            dir = Meta.MotionDirection.DOWN;
        else if (this._dy > MOTION_THRESHOLD)
            dir = Meta.MotionDirection.UP;
        else if (this._dx < -MOTION_THRESHOLD)
            dir = Meta.MotionDirection.RIGHT;
        else if (this._dx > MOTION_THRESHOLD)
            dir = Meta.MotionDirection.LEFT;
        else
            return;
        this.emit('activated', dir);
    },
    _handleEvent: function(actor, event) {
        if (event.type() != Clutter.EventType.TOUCHPAD_SWIPE)
            return Clutter.EVENT_PROPAGATE;
        if (event.get_gesture_swipe_finger_count() != 4)
            return Clutter.EVENT_PROPAGATE;
        if (event.get_gesture_phase() == Clutter.TouchpadGesturePhase.UPDATE) {
            let [dx, dy] = event.get_gesture_motion_delta(event);
            this._dx += dx;
            this._dy += dy;
        } else {
            if (event.get_gesture_phase() == Clutter.TouchpadGesturePhase.END)
                this._checkActivated();
            this._dx = 0;
            this._dy = 0;
        }
        return Clutter.EVENT_STOP;
    }
Signals.addSignalMethods(TouchpadWorkspaceSwitchAction.prototype);
const WorkspaceSwitchAction = new Lang.Class({
    Name: 'WorkspaceSwitchAction',
    Extends: Clutter.SwipeAction,
    _init : function() {
        const MOTION_THRESHOLD = 50;
        this.parent();
        this.set_n_touch_points(4);
        this.set_threshold_trigger_distance(MOTION_THRESHOLD, MOTION_THRESHOLD);
        global.display.connect('grab-op-begin', Lang.bind(this, function() {
            this.cancel();
        }));
    },
    vfunc_gesture_prepare : function(actor) {
        let allowedModes = Shell.ActionMode.NORMAL | Shell.ActionMode.OVERVIEW;
        if (!this.parent(actor))
            return false;
        return (allowedModes & Main.actionMode);
    },
    vfunc_swept : function(actor, direction) {
        let dir;
        if (direction & Clutter.SwipeDirection.UP)
            dir = Meta.MotionDirection.DOWN;
        else if (direction & Clutter.SwipeDirection.DOWN)
            dir = Meta.MotionDirection.UP;
        else if (direction & Clutter.SwipeDirection.LEFT)
            dir = Meta.MotionDirection.RIGHT;
        else if (direction & Clutter.SwipeDirection.RIGHT)
            dir = Meta.MotionDirection.LEFT;
        this.emit('activated', dir);
    }
Signals.addSignalMethods(WorkspaceSwitchAction.prototype);
const AppSwitchAction = new Lang.Class({
    Name: 'AppSwitchAction',
    Extends: Clutter.GestureAction,
    _init : function() {
        this.parent();
        this.set_n_touch_points(3);
        global.display.connect('grab-op-begin', Lang.bind(this, function() {
            this.cancel();
        }));
    },
    vfunc_gesture_prepare : function(action, actor) {
        if (Main.actionMode != Shell.ActionMode.NORMAL) {
            this.cancel();
            return false;
        }
        return this.get_n_current_points() <= 4;
    },
    vfunc_gesture_begin : function(action, actor) {
        // in milliseconds
        const LONG_PRESS_TIMEOUT = 250;
        let nPoints = this.get_n_current_points();
        let event = this.get_last_event (nPoints - 1);
        if (nPoints == 3)
            this._longPressStartTime = event.get_time();
        else if (nPoints == 4) {
            // Check whether the 4th finger press happens after a 3-finger long press,
            // this only needs to be checked on the first 4th finger press
            if (this._longPressStartTime != null &&
                event.get_time() < this._longPressStartTime + LONG_PRESS_TIMEOUT)
                this.cancel();
            else {
                this._longPressStartTime = null;
                this.emit('activated');
            }
        }
        return this.get_n_current_points() <= 4;
    },
    vfunc_gesture_progress : function(action, actor) {
        const MOTION_THRESHOLD = 30;
        if (this.get_n_current_points() == 3) {
            for (let i = 0; i < this.get_n_current_points(); i++) {
                [startX, startY] = this.get_press_coords(i);
                [x, y] = this.get_motion_coords(i);
                if (Math.abs(x - startX) > MOTION_THRESHOLD ||
                    Math.abs(y - startY) > MOTION_THRESHOLD)
                    return false;
            }
        }
        return true;
    }
Signals.addSignalMethods(AppSwitchAction.prototype);
const ResizePopup = new Lang.Class({
    Name: 'ResizePopup',
    _init: function() {
        this._widget = new St.Widget({ layout_manager: new Clutter.BinLayout() });
        this._label = new St.Label({ style_class: 'resize-popup',
                                     x_align: Clutter.ActorAlign.CENTER,
                                     y_align: Clutter.ActorAlign.CENTER,
                                     x_expand: true, y_expand: true });
        this._widget.add_child(this._label);
        Main.uiGroup.add_actor(this._widget);
    },
    set: function(rect, displayW, displayH) {
        /* Translators: This represents the size of a window. The first number is
         * the width of the window and the second is the height. */
        let text = _("%d x %d").format(displayW, displayH);
        this._label.set_text(text);
        this._widget.set_position(rect.x, rect.y);
        this._widget.set_size(rect.width, rect.height);
    },
    destroy: function() {
        this._widget.destroy();
        this._widget = null;
    },
const WindowManager = new Lang.Class({
    Name: 'WindowManager',
    _init : function() {
        this._shellwm =  global.window_manager;
        this._minimizing = [];
        this._unminimizing = [];
        this._mapping = [];
        this._resizing = [];
        this._destroying = [];
        this._movingWindow = null;
        this._dimmedWindows = [];
        this._skippedActors = [];
        this._allowedKeybindings = {};
        this._isWorkspacePrepended = false;
        this._switchData = null;
        this._shellwm.connect('kill-switch-workspace', Lang.bind(this, this._switchWorkspaceDone));
        this._shellwm.connect('kill-window-effects', Lang.bind(this, function (shellwm, actor) {
            this._minimizeWindowDone(shellwm, actor);
            this._mapWindowDone(shellwm, actor);
            this._destroyWindowDone(shellwm, actor);
            this._sizeChangeWindowDone(shellwm, actor);
        }));
        this._shellwm.connect('switch-workspace', Lang.bind(this, this._switchWorkspace));
        this._shellwm.connect('show-tile-preview', Lang.bind(this, this._showTilePreview));
        this._shellwm.connect('hide-tile-preview', Lang.bind(this, this._hideTilePreview));
        this._shellwm.connect('show-window-menu', Lang.bind(this, this._showWindowMenu));
        this._shellwm.connect('minimize', Lang.bind(this, this._minimizeWindow));
        this._shellwm.connect('unminimize', Lang.bind(this, this._unminimizeWindow));
        this._shellwm.connect('size-change', Lang.bind(this, this._sizeChangeWindow));
        this._shellwm.connect('map', Lang.bind(this, this._mapWindow));
        this._shellwm.connect('destroy', Lang.bind(this, this._destroyWindow));
        this._shellwm.connect('filter-keybinding', Lang.bind(this, this._filterKeybinding));
        this._shellwm.connect('confirm-display-change', Lang.bind(this, this._confirmDisplayChange));
        global.screen.connect('restacked', Lang.bind(this, this._syncStacking));
        this._workspaceSwitcherPopup = null;
        this._tilePreview = null;
        this.allowKeybinding('switch-to-session-1', Shell.ActionMode.ALL);
        this.allowKeybinding('switch-to-session-2', Shell.ActionMode.ALL);
        this.allowKeybinding('switch-to-session-3', Shell.ActionMode.ALL);
        this.allowKeybinding('switch-to-session-4', Shell.ActionMode.ALL);
        this.allowKeybinding('switch-to-session-5', Shell.ActionMode.ALL);
        this.allowKeybinding('switch-to-session-6', Shell.ActionMode.ALL);
        this.allowKeybinding('switch-to-session-7', Shell.ActionMode.ALL);
        this.allowKeybinding('switch-to-session-8', Shell.ActionMode.ALL);
        this.allowKeybinding('switch-to-session-9', Shell.ActionMode.ALL);
        this.allowKeybinding('switch-to-session-10', Shell.ActionMode.ALL);
        this.allowKeybinding('switch-to-session-11', Shell.ActionMode.ALL);
        this.allowKeybinding('switch-to-session-12', Shell.ActionMode.ALL);
        this.setCustomKeybindingHandler('switch-to-workspace-left',
                                        Shell.ActionMode.NORMAL |
                                        Shell.ActionMode.OVERVIEW,
                                        Lang.bind(this, this._showWorkspaceSwitcher));
        this.setCustomKeybindingHandler('switch-to-workspace-right',
                                        Shell.ActionMode.NORMAL |
                                        Shell.ActionMode.OVERVIEW,
                                        Lang.bind(this, this._showWorkspaceSwitcher));
        this.setCustomKeybindingHandler('switch-to-workspace-up',
                                        Shell.ActionMode.NORMAL |
                                        Shell.ActionMode.OVERVIEW,
                                        Lang.bind(this, this._showWorkspaceSwitcher));
        this.setCustomKeybindingHandler('switch-to-workspace-down',
                                        Shell.ActionMode.NORMAL |
                                        Shell.ActionMode.OVERVIEW,
                                        Lang.bind(this, this._showWorkspaceSwitcher));
        this.setCustomKeybindingHandler('switch-to-workspace-last',
                                        Shell.ActionMode.NORMAL |
                                        Shell.ActionMode.OVERVIEW,
                                        Lang.bind(this, this._showWorkspaceSwitcher));
        this.setCustomKeybindingHandler('move-to-workspace-left',
                                        Shell.ActionMode.NORMAL |
                                        Shell.ActionMode.OVERVIEW,
                                        Lang.bind(this, this._showWorkspaceSwitcher));
        this.setCustomKeybindingHandler('move-to-workspace-right',
                                        Shell.ActionMode.NORMAL |
                                        Shell.ActionMode.OVERVIEW,
                                        Lang.bind(this, this._showWorkspaceSwitcher));
        this.setCustomKeybindingHandler('move-to-workspace-up',
                                        Shell.ActionMode.NORMAL |
                                        Shell.ActionMode.OVERVIEW,
                                        Lang.bind(this, this._showWorkspaceSwitcher));
        this.setCustomKeybindingHandler('move-to-workspace-down',
                                        Shell.ActionMode.NORMAL |
                                        Shell.ActionMode.OVERVIEW,
                                        Lang.bind(this, this._showWorkspaceSwitcher));
        this.setCustomKeybindingHandler('switch-to-workspace-1',
                                        Shell.ActionMode.NORMAL |
                                        Shell.ActionMode.OVERVIEW,
                                        Lang.bind(this, this._showWorkspaceSwitcher));
        this.setCustomKeybindingHandler('switch-to-workspace-2',
                                        Shell.ActionMode.NORMAL |
                                        Shell.ActionMode.OVERVIEW,
                                        Lang.bind(this, this._showWorkspaceSwitcher));
        this.setCustomKeybindingHandler('switch-to-workspace-3',
                                        Shell.ActionMode.NORMAL |
                                        Shell.ActionMode.OVERVIEW,
                                        Lang.bind(this, this._showWorkspaceSwitcher));
        this.setCustomKeybindingHandler('switch-to-workspace-4',
                                        Shell.ActionMode.NORMAL |
                                        Shell.ActionMode.OVERVIEW,
                                        Lang.bind(this, this._showWorkspaceSwitcher));
        this.setCustomKeybindingHandler('switch-to-workspace-5',
                                        Shell.ActionMode.NORMAL |
                                        Shell.ActionMode.OVERVIEW,
                                        Lang.bind(this, this._showWorkspaceSwitcher));
        this.setCustomKeybindingHandler('switch-to-workspace-6',
                                        Shell.ActionMode.NORMAL |
                                        Shell.ActionMode.OVERVIEW,
                                        Lang.bind(this, this._showWorkspaceSwitcher));
        this.setCustomKeybindingHandler('switch-to-workspace-7',
                                        Shell.ActionMode.NORMAL |
                                        Shell.ActionMode.OVERVIEW,
                                        Lang.bind(this, this._showWorkspaceSwitcher));
        this.setCustomKeybindingHandler('switch-to-workspace-8',
                                        Shell.ActionMode.NORMAL |
                                        Shell.ActionMode.OVERVIEW,
                                        Lang.bind(this, this._showWorkspaceSwitcher));
        this.setCustomKeybindingHandler('switch-to-workspace-9',
                                        Shell.ActionMode.NORMAL |
                                        Shell.ActionMode.OVERVIEW,
                                        Lang.bind(this, this._showWorkspaceSwitcher));
        this.setCustomKeybindingHandler('switch-to-workspace-10',
                                        Shell.ActionMode.NORMAL |
                                        Shell.ActionMode.OVERVIEW,
                                        Lang.bind(this, this._showWorkspaceSwitcher));
        this.setCustomKeybindingHandler('switch-to-workspace-11',
                                        Shell.ActionMode.NORMAL |
                                        Shell.ActionMode.OVERVIEW,
                                        Lang.bind(this, this._showWorkspaceSwitcher));
        this.setCustomKeybindingHandler('switch-to-workspace-12',
                                        Shell.ActionMode.NORMAL |
                                        Shell.ActionMode.OVERVIEW,
                                        Lang.bind(this, this._showWorkspaceSwitcher));
        this.setCustomKeybindingHandler('move-to-workspace-1',
                                        Shell.ActionMode.NORMAL,
                                        Lang.bind(this, this._showWorkspaceSwitcher));
        this.setCustomKeybindingHandler('move-to-workspace-2',
                                        Shell.ActionMode.NORMAL,
                                        Lang.bind(this, this._showWorkspaceSwitcher));
        this.setCustomKeybindingHandler('move-to-workspace-3',
                                        Shell.ActionMode.NORMAL,
                                        Lang.bind(this, this._showWorkspaceSwitcher));
        this.setCustomKeybindingHandler('move-to-workspace-4',
                                        Shell.ActionMode.NORMAL,
                                        Lang.bind(this, this._showWorkspaceSwitcher));
        this.setCustomKeybindingHandler('move-to-workspace-5',
                                        Shell.ActionMode.NORMAL,
                                        Lang.bind(this, this._showWorkspaceSwitcher));
        this.setCustomKeybindingHandler('move-to-workspace-6',
                                        Shell.ActionMode.NORMAL,
                                        Lang.bind(this, this._showWorkspaceSwitcher));
        this.setCustomKeybindingHandler('move-to-workspace-7',
                                        Shell.ActionMode.NORMAL,
                                        Lang.bind(this, this._showWorkspaceSwitcher));
        this.setCustomKeybindingHandler('move-to-workspace-8',
                                        Shell.ActionMode.NORMAL,
                                        Lang.bind(this, this._showWorkspaceSwitcher));
        this.setCustomKeybindingHandler('move-to-workspace-9',
                                        Shell.ActionMode.NORMAL,
                                        Lang.bind(this, this._showWorkspaceSwitcher));
        this.setCustomKeybindingHandler('move-to-workspace-10',
                                        Shell.ActionMode.NORMAL,
                                        Lang.bind(this, this._showWorkspaceSwitcher));
        this.setCustomKeybindingHandler('move-to-workspace-11',
                                        Shell.ActionMode.NORMAL,
                                        Lang.bind(this, this._showWorkspaceSwitcher));
        this.setCustomKeybindingHandler('move-to-workspace-12',
                                        Shell.ActionMode.NORMAL,
                                        Lang.bind(this, this._showWorkspaceSwitcher));
        this.setCustomKeybindingHandler('move-to-workspace-last',
                                        Shell.ActionMode.NORMAL,
                                        Lang.bind(this, this._showWorkspaceSwitcher));
        this.setCustomKeybindingHandler('switch-applications',
                                        Shell.ActionMode.NORMAL,
                                        Lang.bind(this, this._startSwitcher));
        this.setCustomKeybindingHandler('switch-group',
                                        Shell.ActionMode.NORMAL,
                                        Lang.bind(this, this._startSwitcher));
        this.setCustomKeybindingHandler('switch-applications-backward',
                                        Shell.ActionMode.NORMAL,
                                        Lang.bind(this, this._startSwitcher));
        this.setCustomKeybindingHandler('switch-group-backward',
                                        Shell.ActionMode.NORMAL,
                                        Lang.bind(this, this._startSwitcher));
        this.setCustomKeybindingHandler('switch-windows',
                                        Shell.ActionMode.NORMAL,
                                        Lang.bind(this, this._startSwitcher));
        this.setCustomKeybindingHandler('switch-windows-backward',
                                        Shell.ActionMode.NORMAL,
                                        Lang.bind(this, this._startSwitcher));
        this.setCustomKeybindingHandler('cycle-windows',
                                        Shell.ActionMode.NORMAL,
                                        Lang.bind(this, this._startSwitcher));
        this.setCustomKeybindingHandler('cycle-windows-backward',
                                        Shell.ActionMode.NORMAL,
                                        Lang.bind(this, this._startSwitcher));
        this.setCustomKeybindingHandler('cycle-group',
                                        Shell.ActionMode.NORMAL,
                                        Lang.bind(this, this._startSwitcher));
        this.setCustomKeybindingHandler('cycle-group-backward',
                                        Shell.ActionMode.NORMAL,
                                        Lang.bind(this, this._startSwitcher));
        this.setCustomKeybindingHandler('switch-panels',
                                        Shell.ActionMode.NORMAL |
                                        Shell.ActionMode.OVERVIEW |
                                        Shell.ActionMode.LOCK_SCREEN |
                                        Shell.ActionMode.UNLOCK_SCREEN |
                                        Shell.ActionMode.LOGIN_SCREEN,
                                        Lang.bind(this, this._startA11ySwitcher));
        this.setCustomKeybindingHandler('switch-panels-backward',
                                        Shell.ActionMode.NORMAL |
                                        Shell.ActionMode.OVERVIEW |
                                        Shell.ActionMode.LOCK_SCREEN |
                                        Shell.ActionMode.UNLOCK_SCREEN |
                                        Shell.ActionMode.LOGIN_SCREEN,
                                        Lang.bind(this, this._startA11ySwitcher));
        this.addKeybinding('pause-resume-tweens',
                           new Gio.Settings({ schema_id: SHELL_KEYBINDINGS_SCHEMA }),
                           Meta.KeyBindingFlags.NONE,
                           Shell.ActionMode.ALL,
                           Lang.bind(this, this._toggleTweens));
        this.addKeybinding('open-application-menu',
                           new Gio.Settings({ schema_id: SHELL_KEYBINDINGS_SCHEMA }),
                           Meta.KeyBindingFlags.NONE,
                           Shell.ActionMode.NORMAL |
                           Shell.ActionMode.POPUP,
                           Lang.bind(this, this._toggleAppMenu));
        this.addKeybinding('toggle-message-tray',
                           new Gio.Settings({ schema_id: SHELL_KEYBINDINGS_SCHEMA }),
                           Meta.KeyBindingFlags.NONE,
                           Shell.ActionMode.NORMAL |
                           Shell.ActionMode.OVERVIEW |
                           Shell.ActionMode.POPUP,
                           Lang.bind(this, this._toggleCalendar));
        global.display.connect('show-resize-popup', Lang.bind(this, this._showResizePopup));
        Main.overview.connect('showing', Lang.bind(this, function() {
            for (let i = 0; i < this._dimmedWindows.length; i++)
                this._undimWindow(this._dimmedWindows[i]);
        }));
        Main.overview.connect('hiding', Lang.bind(this, function() {
            for (let i = 0; i < this._dimmedWindows.length; i++)
                this._dimWindow(this._dimmedWindows[i]);
        }));
        this._windowMenuManager = new WindowMenu.WindowMenuManager();
        if (Main.sessionMode.hasWorkspaces)
            this._workspaceTracker = new WorkspaceTracker(this);
        global.screen.override_workspace_layout(Meta.ScreenCorner.TOPLEFT,
                                                false, -1, 1);
        let gesture = new WorkspaceSwitchAction();
        gesture.connect('activated', Lang.bind(this, this._actionSwitchWorkspace));
        global.stage.add_action(gesture);
        // This is not a normal Clutter.GestureAction, doesn't need add_action()
        gesture = new TouchpadWorkspaceSwitchAction(global.stage);
        gesture.connect('activated', Lang.bind(this, this._actionSwitchWorkspace));
        gesture = new AppSwitchAction();
        gesture.connect('activated', Lang.bind(this, this._switchApp));
        global.stage.add_action(gesture);
    },
    _actionSwitchWorkspace: function(action, direction) {
            let newWs = global.screen.get_active_workspace().get_neighbor(direction);
            this.actionMoveWorkspace(newWs);
    },
    _lookupIndex: function (windows, metaWindow) {
        for (let i = 0; i < windows.length; i++) {
            if (windows[i].metaWindow == metaWindow) {
                return i;
            }
        }
        return -1;
    },
    _switchApp : function () {
        let windows = global.get_window_actors().filter(Lang.bind(this, function(actor) {
            let win = actor.metaWindow;
            return (!win.is_override_redirect() &&
                    win.located_on_workspace(global.screen.get_active_workspace()));
        }));
        if (windows.length == 0)
            return;
        let focusWindow = global.display.focus_window;
        let nextWindow;
        if (focusWindow == null)
            nextWindow = windows[0].metaWindow;
        else {
            let index = this._lookupIndex (windows, focusWindow) + 1;
            if (index >= windows.length)
                index = 0;
            nextWindow = windows[index].metaWindow;
        }
        Main.activateWindow(nextWindow);
    },
    insertWorkspace: function(pos) {
        if (!Meta.prefs_get_dynamic_workspaces())
            return;
        global.screen.append_new_workspace(false, global.get_current_time());
        let windows = global.get_window_actors().map(function(winActor) {
            return winActor.meta_window;
        });
        // To create a new workspace, we slide all the windows on workspaces
        // below us to the next workspace, leaving a blank workspace for us
        // to recycle.
        windows.forEach(function(window) {
            // If the window is attached to an ancestor, we don't need/want
            // to move it
            if (window.get_transient_for() != null)
                return;
            // Same for OR windows
            if (window.is_override_redirect())
                return;
            // Windows on workspaces below pos don't need moving
            let index = window.get_workspace().index();
            if (index < pos)
                return;
            window.change_workspace_by_index(index + 1, true);
        });
        // If the new workspace was inserted before the active workspace,
        // activate the workspace to which its windows went
        let activeIndex = global.screen.get_active_workspace_index();
        if (activeIndex >= pos) {
            let newWs = global.screen.get_workspace_by_index(activeIndex + 1);
            this._blockAnimations = true;
            newWs.activate(global.get_current_time());
            this._blockAnimations = false;
        }
    },
    keepWorkspaceAlive: function(workspace, duration) {
        if (!this._workspaceTracker)
            return;
        this._workspaceTracker.keepWorkspaceAlive(workspace, duration);
    },
    skipNextEffect: function(actor) {
        this._skippedActors.push(actor);
    },
    setCustomKeybindingHandler: function(name, modes, handler) {
        if (Meta.keybindings_set_custom_handler(name, handler))
            this.allowKeybinding(name, modes);
    },
    addKeybinding: function(name, settings, flags, modes, handler) {
        let action = global.display.add_keybinding(name, settings, flags, handler);
        if (action != Meta.KeyBindingAction.NONE)
            this.allowKeybinding(name, modes);
        return action;
    },
    removeKeybinding: function(name) {
        if (global.display.remove_keybinding(name))
            this.allowKeybinding(name, Shell.ActionMode.NONE);
    },
    allowKeybinding: function(name, modes) {
        this._allowedKeybindings[name] = modes;
    },
    _shouldAnimate: function() {
        return !(Main.overview.visible || this._blockAnimations);
    },
    _shouldAnimateActor: function(actor, types) {
        if (this._removeEffect(this._skippedActors, actor))
            return false;
        if (!this._shouldAnimate())
            return false;
        let type = actor.meta_window.get_window_type();
        return types.indexOf(type) >= 0;
    },
    _removeEffect : function(list, actor) {
        let idx = list.indexOf(actor);
        if (idx != -1) {
            list.splice(idx, 1);
            return true;
        }
        return false;
    },
    _minimizeWindow : function(shellwm, actor) {
        let types = [Meta.WindowType.NORMAL,
                     Meta.WindowType.MODAL_DIALOG,
                     Meta.WindowType.DIALOG];
        if (!this._shouldAnimateActor(actor, types)) {
            shellwm.completed_minimize(actor);
            return;
        }
        actor.set_scale(1.0, 1.0);
        this._minimizing.push(actor);
        if (actor.meta_window.is_monitor_sized()) {
            Tweener.addTween(actor,
                         { opacity: 0,
                           time: MINIMIZE_WINDOW_ANIMATION_TIME,
                           transition: 'easeOutQuad',
                           onComplete: this._minimizeWindowDone,
                           onCompleteScope: this,
                           onCompleteParams: [shellwm, actor],
                           onOverwrite: this._minimizeWindowOverwritten,
                           onOverwriteScope: this,
                           onOverwriteParams: [shellwm, actor]
                         });
        } else {
            let xDest, yDest, xScale, yScale;
            let [success, geom] = actor.meta_window.get_icon_geometry();
            if (success) {
                xDest = geom.x;
                yDest = geom.y;
                xScale = geom.width / actor.width;
                yScale = geom.height / actor.height;
            } else {
                let monitor = Main.layoutManager.monitors[actor.meta_window.get_monitor()];
                xDest = monitor.x;
                yDest = monitor.y;
                if (Clutter.get_default_text_direction() == Clutter.TextDirection.RTL)
                    xDest += monitor.width;
                xScale = 0;
                yScale = 0;
            }
            Tweener.addTween(actor,
                             { scale_x: xScale,
                               scale_y: yScale,
                               x: xDest,
                               y: yDest,
                               time: MINIMIZE_WINDOW_ANIMATION_TIME,
                               transition: 'easeInExpo',
                               onComplete: this._minimizeWindowDone,
                               onCompleteScope: this,
                               onCompleteParams: [shellwm, actor],
                               onOverwrite: this._minimizeWindowOverwritten,
                               onOverwriteScope: this,
                               onOverwriteParams: [shellwm, actor]
                             });
        }
    },
    _minimizeWindowDone : function(shellwm, actor) {
        if (this._removeEffect(this._minimizing, actor)) {
            Tweener.removeTweens(actor);
            actor.set_scale(1.0, 1.0);
            actor.set_opacity(255);
            actor.set_pivot_point(0, 0);
            shellwm.completed_minimize(actor);
        }
    },
    _minimizeWindowOverwritten : function(shellwm, actor) {
        if (this._removeEffect(this._minimizing, actor)) {
            shellwm.completed_minimize(actor);
        }
    },
    _unminimizeWindow : function(shellwm, actor) {
        let types = [Meta.WindowType.NORMAL,
                     Meta.WindowType.MODAL_DIALOG,
                     Meta.WindowType.DIALOG];
        if (!this._shouldAnimateActor(actor, types)) {
            shellwm.completed_unminimize(actor);
            return;
        }
        this._unminimizing.push(actor);
        if (actor.meta_window.is_monitor_sized()) {
            actor.opacity = 0;
            actor.set_scale(1.0, 1.0);
            Tweener.addTween(actor,
                         { opacity: 255,
                           time: MINIMIZE_WINDOW_ANIMATION_TIME,
                           transition: 'easeOutQuad',
                           onComplete: this._unminimizeWindowDone,
                           onCompleteScope: this,
                           onCompleteParams: [shellwm, actor],
                           onOverwrite: this._unminimizeWindowOverwritten,
                           onOverwriteScope: this,
                           onOverwriteParams: [shellwm, actor]
                         });
        } else {
            let [success, geom] = actor.meta_window.get_icon_geometry();
            if (success) {
                actor.set_position(geom.x, geom.y);
                actor.set_scale(geom.width / actor.width,
                                geom.height / actor.height);
            } else {
                let monitor = Main.layoutManager.monitors[actor.meta_window.get_monitor()];
                actor.set_position(monitor.x, monitor.y);
                if (Clutter.get_default_text_direction() == Clutter.TextDirection.RTL)
                    actor.x += monitor.width;
                actor.set_scale(0, 0);
            }
            let rect = actor.meta_window.get_frame_rect();
            let [xDest, yDest] = [rect.x, rect.y];
            actor.show();
            Tweener.addTween(actor,
                             { scale_x: 1.0,
                               scale_y: 1.0,
                               x: xDest,
                               y: yDest,
                               time: MINIMIZE_WINDOW_ANIMATION_TIME,
                               transition: 'easeInExpo',
                               onComplete: this._unminimizeWindowDone,
                               onCompleteScope: this,
                               onCompleteParams: [shellwm, actor],
                               onOverwrite: this._unminimizeWindowOverwritten,
                               onOverwriteScope: this,
                               onOverwriteParams: [shellwm, actor]
                             });
        }
    },
    _unminimizeWindowDone : function(shellwm, actor) {
        if (this._removeEffect(this._unminimizing, actor)) {
            Tweener.removeTweens(actor);
            actor.set_scale(1.0, 1.0);
            actor.set_opacity(255);
            actor.set_pivot_point(0, 0);
            shellwm.completed_unminimize(actor);
        }
    },
    _unminimizeWindowOverwritten : function(shellwm, actor) {
        if (this._removeEffect(this._unminimizing, actor)) {
            shellwm.completed_unminimize(actor);
        }
    },
    _sizeChangeWindow : function(shellwm, actor, whichChange, oldFrameRect, oldBufferRect) {
        let types = [Meta.WindowType.NORMAL];
        if (!this._shouldAnimateActor(actor, types)) {
            shellwm.completed_size_change(actor);
            return;
        }
        if (whichChange == Meta.SizeChange.FULLSCREEN)
            this._fullscreenWindow(shellwm, actor, oldFrameRect, oldBufferRect);
        else if (whichChange == Meta.SizeChange.UNFULLSCREEN)
            this._unfullscreenWindow(shellwm, actor, oldFrameRect, oldBufferRect);
        else
            shellwm.completed_size_change(actor);
    },
    _fullscreenWindow: function(shellwm, actor, oldFrameRect, oldBufferRect) {
        let monitor = Main.layoutManager.monitors[actor.meta_window.get_monitor()];
        actor.translation_x = oldFrameRect.x - monitor.x;
        actor.translation_y = oldFrameRect.y - monitor.y;
        this._fullscreenAnimation(shellwm, actor, oldFrameRect);
    },
    _unfullscreenWindow: function(shellwm, actor, oldFrameRect, oldBufferRect) {
        let targetRect = actor.meta_window.get_frame_rect();
        let monitor = Main.layoutManager.monitors[actor.meta_window.get_monitor()];
        actor.translation_x = -(targetRect.x - monitor.x);
        actor.translation_y = -(targetRect.y - monitor.y);
        this._fullscreenAnimation(shellwm, actor, oldFrameRect);
    },
    _fullscreenAnimation: function(shellwm, actor, oldFrameRect) {
        this._resizing.push(actor);
        // Position a clone of the window on top of the old position,
        // while actor updates are frozen.
        // Note that the MetaWindow has up to date sizing information for
        // the new geometry already.
        let targetRect = actor.meta_window.get_frame_rect();
        let actorContent = Shell.util_get_content_for_window_actor(actor, oldFrameRect);
        let actorClone = new St.Widget({ content: actorContent });
        actorClone.set_offscreen_redirect(Clutter.OffscreenRedirect.ALWAYS);
        actorClone.set_position(oldFrameRect.x, oldFrameRect.y);
        actorClone.set_size(oldFrameRect.width, oldFrameRect.height);
        Main.uiGroup.add_actor(actorClone);
        actor.__fullscreenClone = actorClone;
        let scaleX = targetRect.width / oldFrameRect.width;
        let scaleY = targetRect.height / oldFrameRect.height;
        // Now scale and fade out the clone
        Tweener.addTween(actorClone,
                         { x: targetRect.x,
                           y: targetRect.y,
                           scale_x: scaleX,
                           scale_y: scaleY,
                           opacity: 0,
                           time: WINDOW_ANIMATION_TIME,
                           transition: 'easeOutQuad'
                         });
        // Now set scale the actor to size it as the clone.
        // Note that the caller of this function already set a translation
        // on the actor.
        actor.scale_x = 1 / scaleX;
        actor.scale_y = 1 / scaleY;
        // Scale it to its actual new size
        Tweener.addTween(actor,
                         { scale_x: 1.0,
                           scale_y: 1.0,
                           translation_x: 0,
                           translation_y: 0,
                           time: WINDOW_ANIMATION_TIME,
                           transition: 'easeOutQuad',
                           onComplete: this._sizeChangeWindowDone,
                           onCompleteScope: this,
                           onCompleteParams: [shellwm, actor],
                           onOverwrite: this._sizeChangeWindowOverwritten,
                           onOverwriteScope: this,
                           onOverwriteParams: [shellwm, actor]
                         });
        // Now unfreeze actor updates, to get it to the new size.
        // It's important that we don't wait until the animation is completed to
        // do this, otherwise our scale will be applied to the old texture size.
        shellwm.completed_size_change(actor);
    },
    _sizeChangeWindowDone: function(shellwm, actor) {
        if (this._removeEffect(this._resizing, actor)) {
            Tweener.removeTweens(actor);
            actor.scale_x = 1.0;
            actor.scale_y = 1.0;
            actor.translation_x = 0;
            actor.translation_y = 0;
            let actorClone = actor.__fullscreenClone;
            if (actorClone) {
                actorClone.destroy();
                delete actor.__fullscreenClone;
            }
        }
    },
    _sizeChangeWindowOverwritten: function(shellwm, actor) {
        if (this._removeEffect(this._resizing, actor)) {
            let actorClone = actor.__fullscreenClone;
            if (actorClone) {
                actorClone.destroy();
                delete actor.__fullscreenClone;
            }
        }
    },
    _hasAttachedDialogs: function(window, ignoreWindow) {
        var count = 0;
        window.foreach_transient(function(win) {
            if (win != ignoreWindow &&
                win.is_attached_dialog() &&
                win.get_transient_for() == window) {
                count++;
                return false;
            }
            return true;
        });
        return count != 0;
    },
    _checkDimming: function(window, ignoreWindow) {
        let shouldDim = this._hasAttachedDialogs(window, ignoreWindow);
        if (shouldDim && !window._dimmed) {
            window._dimmed = true;
            this._dimmedWindows.push(window);
            this._dimWindow(window);
        } else if (!shouldDim && window._dimmed) {
            window._dimmed = false;
            this._dimmedWindows = this._dimmedWindows.filter(function(win) {
                                                                 return win != window;
                                                             });
            this._undimWindow(window);
        }
    },
    _dimWindow: function(window) {
        let actor = window.get_compositor_private();
        if (!actor)
            return;
        let dimmer = getWindowDimmer(actor);
        if (!dimmer)
            return;
        if (this._shouldAnimate())
            Tweener.addTween(dimmer,
                             { dimFactor: 1.0,
                               time: DIM_TIME,
                               transition: 'linear'
                             });
        else
            dimmer.dimFactor = 1.0;
    },
    _undimWindow: function(window) {
        let actor = window.get_compositor_private();
        if (!actor)
            return;
        let dimmer = getWindowDimmer(actor);
        if (!dimmer)
            return;
        if (this._shouldAnimate())
            Tweener.addTween(dimmer,
                             { dimFactor: 0.0,
                               time: UNDIM_TIME,
                               transition: 'linear' });
        else
            dimmer.dimFactor = 0.0;
    },
    _mapWindow : function(shellwm, actor) {
        actor._windowType = actor.meta_window.get_window_type();
        actor._notifyWindowTypeSignalId = actor.meta_window.connect('notify::window-type', Lang.bind(this, function () {
            let type = actor.meta_window.get_window_type();
            if (type == actor._windowType)
                return;
            if (type == Meta.WindowType.MODAL_DIALOG ||
                actor._windowType == Meta.WindowType.MODAL_DIALOG) {
                let parent = actor.get_meta_window().get_transient_for();
                if (parent)
                    this._checkDimming(parent);
            }
            actor._windowType = type;
        }));
        actor.meta_window.connect('unmanaged', Lang.bind(this, function(window) {
                let parent = window.get_transient_for();
                if (parent)
                    this._checkDimming(parent);
        }));
        if (actor.meta_window.is_attached_dialog())
            this._checkDimming(actor.get_meta_window().get_transient_for());
        let types = [Meta.WindowType.NORMAL,
                     Meta.WindowType.DIALOG,
                     Meta.WindowType.MODAL_DIALOG];
        if (!this._shouldAnimateActor(actor, types)) {
            shellwm.completed_map(actor);
            return;
        }
        switch (actor._windowType) {
        case Meta.WindowType.NORMAL:
            actor.set_pivot_point(0.5, 1.0);
            actor.scale_x = 0.01;
            actor.scale_y = 0.05;
            actor.opacity = 0;
            actor.show();
            this._mapping.push(actor);
            Tweener.addTween(actor,
                             { opacity: 255,
                               scale_x: 1,
                               scale_y: 1,
                               time: SHOW_WINDOW_ANIMATION_TIME,
                               transition: 'easeOutExpo',
                               onComplete: this._mapWindowDone,
                               onCompleteScope: this,
                               onCompleteParams: [shellwm, actor],
                               onOverwrite: this._mapWindowOverwrite,
                               onOverwriteScope: this,
                               onOverwriteParams: [shellwm, actor]
                             });
            break;
        case Meta.WindowType.MODAL_DIALOG:
        case Meta.WindowType.DIALOG:
            actor.set_pivot_point(0.5, 0.5);
            actor.scale_y = 0;
            actor.opacity = 0;
            actor.show();
            this._mapping.push(actor);
            Tweener.addTween(actor,
                             { opacity: 255,
                               scale_x: 1,
                               scale_y: 1,
                               time: DIALOG_SHOW_WINDOW_ANIMATION_TIME,
                               transition: 'easeOutQuad',
                               onComplete: this._mapWindowDone,
                               onCompleteScope: this,
                               onCompleteParams: [shellwm, actor],
                               onOverwrite: this._mapWindowOverwrite,
                               onOverwriteScope: this,
                               onOverwriteParams: [shellwm, actor]
                             });
            break;
        default:
            shellwm.completed_map(actor);
            return;
        }
    },
    _mapWindowDone : function(shellwm, actor) {
        if (this._removeEffect(this._mapping, actor)) {
            Tweener.removeTweens(actor);
            actor.opacity = 255;
            actor.set_pivot_point(0, 0);
            actor.scale_y = 1;
            actor.scale_x = 1;
            actor.translation_y = 0;
            actor.translation_x = 0;
            shellwm.completed_map(actor);
        }
    },
    _mapWindowOverwrite : function(shellwm, actor) {
        if (this._removeEffect(this._mapping, actor)) {
            shellwm.completed_map(actor);
        }
    },
    _destroyWindow : function(shellwm, actor) {
        let window = actor.meta_window;
        if (actor._notifyWindowTypeSignalId) {
            window.disconnect(actor._notifyWindowTypeSignalId);
            actor._notifyWindowTypeSignalId = 0;
        }
        if (window._dimmed) {
            this._dimmedWindows = this._dimmedWindows.filter(function(win) {
                                                                 return win != window;
                                                             });
        }
        if (window.is_attached_dialog())
            this._checkDimming(window.get_transient_for(), window);
        let types = [Meta.WindowType.NORMAL,
                     Meta.WindowType.DIALOG,
                     Meta.WindowType.MODAL_DIALOG];
        if (!this._shouldAnimateActor(actor, types)) {
            shellwm.completed_destroy(actor);
            return;
        }
        switch (actor._windowType) {
        case Meta.WindowType.NORMAL:
            actor.set_pivot_point(0.5, 0.5);
            this._destroying.push(actor);
            Tweener.addTween(actor,
                             { opacity: 0,
                               scale_x: 0.8,
                               scale_y: 0.8,
                               time: DESTROY_WINDOW_ANIMATION_TIME,
                               transition: 'easeOutQuad',
                               onComplete: this._destroyWindowDone,
                               onCompleteScope: this,
                               onCompleteParams: [shellwm, actor],
                               onOverwrite: this._destroyWindowDone,
                               onOverwriteScope: this,
                               onOverwriteParams: [shellwm, actor]
                             });
            break;
        case Meta.WindowType.MODAL_DIALOG:
        case Meta.WindowType.DIALOG:
            actor.set_pivot_point(0.5, 0.5);
            this._destroying.push(actor);
            if (window.is_attached_dialog()) {
                let parent = window.get_transient_for();
                actor._parentDestroyId = parent.connect('unmanaged', Lang.bind(this, function () {
                    Tweener.removeTweens(actor);
                    this._destroyWindowDone(shellwm, actor);
                }));
            }
            Tweener.addTween(actor,
                             { scale_y: 0,
                               time: DIALOG_DESTROY_WINDOW_ANIMATION_TIME,
                               transition: 'easeOutQuad',
                               onComplete: this._destroyWindowDone,
                               onCompleteScope: this,
                               onCompleteParams: [shellwm, actor],
                               onOverwrite: this._destroyWindowDone,
                               onOverwriteScope: this,
                               onOverwriteParams: [shellwm, actor]
                             });
            break;
        default:
            shellwm.completed_destroy(actor);
            return;
        }
    },
    _destroyWindowDone : function(shellwm, actor) {
        if (this._removeEffect(this._destroying, actor)) {
            let parent = actor.get_meta_window().get_transient_for();
            if (parent && actor._parentDestroyId) {
                parent.disconnect(actor._parentDestroyId);
                actor._parentDestroyId = 0;
            }
            shellwm.completed_destroy(actor);
        }
    },
    _filterKeybinding: function(shellwm, binding) {
        if (Main.actionMode == Shell.ActionMode.NONE)
            return true;
        // There's little sense in implementing a keybinding in mutter and
        // not having it work in NORMAL mode; handle this case generically
        // so we don't have to explicitly allow all builtin keybindings in
        // NORMAL mode.
        if (Main.actionMode == Shell.ActionMode.NORMAL &&
            binding.is_builtin())
            return false;
        return !(this._allowedKeybindings[binding.get_name()] & Main.actionMode);
    },
    _syncStacking: function() {
        if (this._switchData == null)
            return;
        // Update stacking of windows in inGroup (aka the workspace we are
        // switching to). Windows in outGroup are about to be hidden anyway,
        // so we just ignore them here.
        let windows = global.get_window_actors();
        let sibling = null;
        for (let i = 0; i < windows.length; i++) {
            if (windows[i].get_parent() != this._switchData.inGroup)
                continue;
            this._switchData.inGroup.set_child_above_sibling(windows[i], sibling);
            sibling = windows[i];
        }
    },
    _switchWorkspace : function(shellwm, from, to, direction) {
        if (!Main.sessionMode.hasWorkspaces || !this._shouldAnimate()) {
            shellwm.completed_switch_workspace();
            return;
        }
        let windows = global.get_window_actors();
        /* @direction is the direction that the "camera" moves, so the
         * screen contents have to move one screen's worth in the
         * opposite direction.
         */
        let xDest = 0, yDest = 0;
        if (direction == Meta.MotionDirection.UP ||
            direction == Meta.MotionDirection.UP_LEFT ||
            direction == Meta.MotionDirection.UP_RIGHT)
                yDest = global.screen_height - Main.panel.actor.height;
        else if (direction == Meta.MotionDirection.DOWN ||
            direction == Meta.MotionDirection.DOWN_LEFT ||
            direction == Meta.MotionDirection.DOWN_RIGHT)
                yDest = -global.screen_height + Main.panel.actor.height;
        if (direction == Meta.MotionDirection.LEFT ||
            direction == Meta.MotionDirection.UP_LEFT ||
            direction == Meta.MotionDirection.DOWN_LEFT)
                xDest = global.screen_width;
        else if (direction == Meta.MotionDirection.RIGHT ||
                 direction == Meta.MotionDirection.UP_RIGHT ||
                 direction == Meta.MotionDirection.DOWN_RIGHT)
                xDest = -global.screen_width;
        let switchData = {};
        this._switchData = switchData;
        switchData.inGroup = new Clutter.Actor();
        switchData.outGroup = new Clutter.Actor();
        switchData.movingWindowBin = new Clutter.Actor();
        switchData.windows = [];
        let wgroup = global.window_group;
        wgroup.add_actor(switchData.inGroup);
        wgroup.add_actor(switchData.outGroup);
        wgroup.add_actor(switchData.movingWindowBin);
        for (let i = 0; i < windows.length; i++) {
            let actor = windows[i];
            let window = actor.get_meta_window();
            if (!window.showing_on_its_workspace())
                continue;
            if (window.is_on_all_workspaces())
                continue;
            let record = { window: actor,
                           parent: actor.get_parent() };
            if (this._movingWindow && window == this._movingWindow) {
                switchData.movingWindow = record;
                switchData.windows.push(switchData.movingWindow);
                actor.reparent(switchData.movingWindowBin);
            } else if (window.get_workspace().index() == from) {
                switchData.windows.push(record);
                actor.reparent(switchData.outGroup);
            } else if (window.get_workspace().index() == to) {
                switchData.windows.push(record);
                actor.reparent(switchData.inGroup);
                actor.show();
            }
        }
        switchData.inGroup.set_position(-xDest, -yDest);
        switchData.inGroup.raise_top();
        switchData.movingWindowBin.raise_top();
        Tweener.addTween(switchData.outGroup,
                         { x: xDest,
                           y: yDest,
                           time: WINDOW_ANIMATION_TIME,
                           transition: 'easeOutQuad',
                           onComplete: this._switchWorkspaceDone,
                           onCompleteScope: this,
                           onCompleteParams: [shellwm]
                         });
        Tweener.addTween(switchData.inGroup,
                         { x: 0,
                           y: 0,
                           time: WINDOW_ANIMATION_TIME,
                           transition: 'easeOutQuad'
                         });
    },
    _switchWorkspaceDone : function(shellwm) {
        let switchData = this._switchData;
        if (!switchData)
            return;
        this._switchData = null;
        for (let i = 0; i < switchData.windows.length; i++) {
                let w = switchData.windows[i];
                if (w.window.is_destroyed()) // Window gone
                    continue;
                if (w.window.get_parent() == switchData.outGroup) {
                    w.window.reparent(w.parent);
                    w.window.hide();
                } else
                    w.window.reparent(w.parent);
        }
        Tweener.removeTweens(switchData.inGroup);
        Tweener.removeTweens(switchData.outGroup);
        switchData.inGroup.destroy();
        switchData.outGroup.destroy();
        switchData.movingWindowBin.destroy();
        if (this._movingWindow)
            this._movingWindow = null;
        shellwm.completed_switch_workspace();
    },
    _showTilePreview: function(shellwm, window, tileRect, monitorIndex) {
        if (!this._tilePreview)
            this._tilePreview = new TilePreview();
        this._tilePreview.show(window, tileRect, monitorIndex);
    },
    _hideTilePreview: function(shellwm) {
        if (!this._tilePreview)
            return;
        this._tilePreview.hide();
    },
    _showWindowMenu: function(shellwm, window, menu, rect) {
        this._windowMenuManager.showWindowMenuForWindow(window, menu, rect);
    },
    _startSwitcher: function(display, screen, window, binding) {
        let constructor = null;
        switch (binding.get_name()) {
            case 'switch-applications':
            case 'switch-applications-backward':
            case 'switch-group':
            case 'switch-group-backward':
                constructor = AltTab.AppSwitcherPopup;
                break;
            case 'switch-windows':
            case 'switch-windows-backward':
                constructor = AltTab.WindowSwitcherPopup;
                break;
            case 'cycle-windows':
            case 'cycle-windows-backward':
                constructor = AltTab.WindowCyclerPopup;
                break;
            case 'cycle-group':
            case 'cycle-group-backward':
                constructor = AltTab.GroupCyclerPopup;
                break;
        }
        if (!constructor)
            return;
        /* prevent a corner case where both popups show up at once */
        if (this._workspaceSwitcherPopup != null)
            this._workspaceSwitcherPopup.destroy();
        let tabPopup = new constructor();
        if (!tabPopup.show(binding.is_reversed(), binding.get_name(), binding.get_mask()))
            tabPopup.destroy();
    },
    _startA11ySwitcher : function(display, screen, window, binding) {
        Main.ctrlAltTabManager.popup(binding.is_reversed(), binding.get_name(), binding.get_mask());
    },
    _toggleAppMenu : function(display, screen, window, event, binding) {
        Main.panel.toggleAppMenu();
    },
    _toggleCalendar: function(display, screen, window, event, binding) {
        Main.panel.toggleCalendar();
    },
    _toggleTweens: function() {
        this._tweensPaused = !this._tweensPaused;
        const OrigTweener = imports.tweener.tweener;
        if (this._tweensPaused)
            OrigTweener.pauseAllTweens();
        else
            OrigTweener.resumeAllTweens();
    },
    _showWorkspaceSwitcher : function(display, screen, window, binding) {
        if (!Main.sessionMode.hasWorkspaces)
            return;
        if (screen.n_workspaces == 1)
            return;
        let [action,,,target] = binding.get_name().split('-');
        let newWs;
        let direction;
        if (action == 'move') {
            // "Moving" a window to another workspace doesn't make sense when
            // it cannot be unstuck, and is potentially confusing if a new
            // workspaces is added at the start/end
            if (window.is_always_on_all_workspaces() ||
                (Meta.prefs_get_workspaces_only_on_primary() &&
                 window.get_monitor() != Main.layoutManager.primaryIndex))
              return;
        }
        if (target == 'last') {
            direction = Meta.MotionDirection.DOWN;
            newWs = screen.get_workspace_by_index(screen.n_workspaces - 1);
        } else if (isNaN(target)) {
            // Prepend a new workspace dynamically
            if (screen.get_active_workspace_index() == 0 &&
                action == 'move' && target == 'up' && this._isWorkspacePrepended == false) {
                this.insertWorkspace(0);
                this._isWorkspacePrepended = true;
            }
            direction = Meta.MotionDirection[target.toUpperCase()];
            newWs = screen.get_active_workspace().get_neighbor(direction);
        } else if (target > 0) {
            target--;
            newWs = screen.get_workspace_by_index(target);
            if (screen.get_active_workspace().index() > target)
                direction = Meta.MotionDirection.UP;
            else
                direction = Meta.MotionDirection.DOWN;
        }
        if (direction != Meta.MotionDirection.UP &&
            direction != Meta.MotionDirection.DOWN)
            return;
        if (action == 'switch')
            this.actionMoveWorkspace(newWs);
        else
            this.actionMoveWindow(window, newWs);
        if (!Main.overview.visible) {
            if (this._workspaceSwitcherPopup == null) {
                this._workspaceTracker.blockUpdates();
                this._workspaceSwitcherPopup = new WorkspaceSwitcherPopup.WorkspaceSwitcherPopup();
                this._workspaceSwitcherPopup.connect('destroy', Lang.bind(this, function() {
                    this._workspaceTracker.unblockUpdates();
                    this._workspaceSwitcherPopup = null;
                    this._isWorkspacePrepended = false;
                }));
            }
            this._workspaceSwitcherPopup.display(direction, newWs.index());
        }
    },
    actionMoveWorkspace: function(workspace) {
        if (!Main.sessionMode.hasWorkspaces)
            return;
        let activeWorkspace = global.screen.get_active_workspace();
        if (activeWorkspace != workspace)
            workspace.activate(global.get_current_time());
    },
    actionMoveWindow: function(window, workspace) {
        if (!Main.sessionMode.hasWorkspaces)
            return;
        let activeWorkspace = global.screen.get_active_workspace();
        if (activeWorkspace != workspace) {
            // This won't have any effect for "always sticky" windows
            // (like desktop windows or docks)
            this._movingWindow = window;
            window.change_workspace(workspace);
            global.display.clear_mouse_mode();
            workspace.activate_with_focus (window, global.get_current_time());
        }
    },
    _confirmDisplayChange: function() {
        let dialog = new DisplayChangeDialog(this._shellwm);
        dialog.open();
    },
    _showResizePopup: function(display, show, rect, displayW, displayH) {
        if (show) {
            if (!this._resizePopup)
                this._resizePopup = new ResizePopup();
            this._resizePopup.set(rect, displayW, displayH);
        } else {
            if (this._resizePopup) {
                this._resizePopup.destroy();
                this._resizePopup = null;
            }
        }
    },
(uuay)main.js
const Format = imports.format;
const Gettext = imports.gettext;
const GLib = imports.gi.GLib;
const GObject = imports.gi.GObject;
const Gio = imports.gi.Gio;
const Gtk = imports.gi.Gtk;
const Lang = imports.lang;
const Pango = imports.gi.Pango;
const Soup = imports.gi.Soup;
const WebKit = imports.gi.WebKit2;
const _ = Gettext.gettext;
const Config = imports.misc.config;
const PortalHelperResult = {
    CANCELLED: 0,
    COMPLETED: 1,
    RECHECK: 2
const INACTIVITY_TIMEOUT = 30000; //ms
const CONNECTIVITY_RECHECK_RATELIMIT_TIMEOUT = 30 * GLib.USEC_PER_SEC;
const HelperDBusInterface = '<node> \
<interface name="org.gnome.Shell.PortalHelper"> \
<method name="Authenticate"> \
    <arg type="o" direction="in" name="connection" /> \
    <arg type="s" direction="in" name="url" /> \
    <arg type="u" direction="in" name="timestamp" /> \
</method> \
<method name="Close"> \
    <arg type="o" direction="in" name="connection" /> \
</method> \
<method name="Refresh"> \
    <arg type="o" direction="in" name="connection" /> \
</method> \
<signal name="Done"> \
    <arg type="o" name="connection" /> \
    <arg type="u" name="result" /> \
</signal> \
</interface> \
</node>';
const PortalWindow = new Lang.Class({
    Name: 'PortalWindow',
    Extends: Gtk.ApplicationWindow,
    _init: function(application, url, timestamp, doneCallback) {
        this.parent({ application: application });
        if (!url) {
            url = 'http://www.gnome.org';
            this._originalUrlWasGnome = true;
        } else {
            this._originalUrlWasGnome = false;
        }
        this._uri = new Soup.URI(url);
        this._everSeenRedirect = false;
        this._originalUrl = url;
        this._doneCallback = doneCallback;
        this._lastRecheck = 0;
        this._recheckAtExit = false;
        this._webView = new WebKit.WebView();
        this._webView.connect('decide-policy', Lang.bind(this, this._onDecidePolicy));
        this._webView.load_uri(url);
        this._webView.connect('notify::title', Lang.bind(this, this._syncTitle));
        this._syncTitle();
        this.add(this._webView);
        this._webView.show();
        this.maximize();
        this.present_with_time(timestamp);
    },
    _syncTitle: function() {
        let title = this._webView.title;
        if (title) {
            this.title = title;
        } else {
            /* TRANSLATORS: this is the title of the wifi captive portal login
             * window, until we know the title of the actual login page */
            this.title = _("Web Authentication Redirect");
        }
    },
    refresh: function() {
        this._everSeenRedirect = false;
        this._webView.load_uri(this._originalUrl);
    },
    vfunc_delete_event: function(event) {
        if (this._recheckAtExit)
            this._doneCallback(PortalHelperResult.RECHECK);
        else
            this._doneCallback(PortalHelperResult.CANCELLED);
        return false;
    },
    _onDecidePolicy: function(view, decision, type) {
        if (type == WebKit.PolicyDecisionType.NEW_WINDOW_ACTION) {
            decision.ignore();
            return true;
        }
        if (type != WebKit.PolicyDecisionType.NAVIGATION_ACTION)
            return false;
        let request = decision.get_request();
        let uri = new Soup.URI(request.get_uri());
        if (!uri.host_equal(this._uri) && this._originalUrlWasGnome) {
            if (uri.get_host() == 'www.gnome.org' && this._everSeenRedirect) {
                // Yay, we got to gnome!
                decision.ignore();
                this._doneCallback(PortalHelperResult.COMPLETED);
                return true;
            } else if (uri.get_host() != 'www.gnome.org') {
                this._everSeenRedirect = true;
            }
        }
        // We *may* have finished here, but we don't know for
        // sure. Tell gnome-shell to run another connectivity check
        // (but ratelimit the checks, we don't want to spam
        // nmcheck.gnome.org for portals that have 10 or more internal
        // redirects - and unfortunately they exist)
        // If we hit the rate limit, we also queue a recheck
        // when the window is closed, just in case we miss the
        // final check and don't realize we're connected
        // This should not be a problem in the cancelled logic,
        // because if the user doesn't want to start the login,
        // we should not see any redirect at all, outside this._uri
        let now = GLib.get_monotonic_time();
        let shouldRecheck = (now - this._lastRecheck) >
            CONNECTIVITY_RECHECK_RATELIMIT_TIMEOUT;
        if (shouldRecheck) {
            this._lastRecheck = now;
            this._recheckAtExit = false;
            this._doneCallback(PortalHelperResult.RECHECK);
        } else {
            this._recheckAtExit = true;
        }
        // Update the URI, in case of chained redirects, so we still
        // think we're doing the login until gnome-shell kills us
        this._uri = uri;
        decision.use();
        return true;
    },
const WebPortalHelper = new Lang.Class({
    Name: 'WebPortalHelper',
    Extends: Gtk.Application,
    _init: function() {
        this.parent({ application_id: 'org.gnome.Shell.PortalHelper',
                      flags: Gio.ApplicationFlags.IS_SERVICE,
                      inactivity_timeout: 30000 });
        this._dbusImpl = Gio.DBusExportedObject.wrapJSObject(HelperDBusInterface, this);
        this._queue = [];
    },
    vfunc_dbus_register: function(connection, path) {
        this._dbusImpl.export(connection, path);
        this.parent(connection, path);
        return true;
    },
    vfunc_dbus_unregister: function(connection, path) {
        this._dbusImpl.unexport_from_connection(connection);
        this.parent(connection, path);
    },
    vfunc_activate: function() {
        // If launched manually (for example for testing), force a dummy authentication
        // session with the default url
        this.Authenticate('/org/gnome/dummy', '', 0);
    },
    Authenticate: function(connection, url, timestamp) {
        this._queue.push({ connection: connection, url: url, timestamp: timestamp });
        this._processQueue();
    },
    Close: function(connection) {
        for (let i = 0; i < this._queue.length; i++) {
            let obj = this._queue[i];
            if (obj.connection == connection) {
                if (obj.window)
                    obj.window.destroy();
                this._queue.splice(i, 1);
                break;
            }
        }
        this._processQueue();
    },
    Refresh: function(connection) {
        for (let i = 0; i < this._queue.length; i++) {
            let obj = this._queue[i];
            if (obj.connection == connection) {
                if (obj.window)
                    obj.window.refresh();
                break;
            }
        }
    },
    _processQueue: function() {
        if (this._queue.length == 0)
            return;
        let top = this._queue[0];
        if (top.window != null)
            return;
        top.window = new PortalWindow(this, top.uri, top.timestamp, Lang.bind(this, function(result) {
            this._dbusImpl.emit_signal('Done', new GLib.Variant('(ou)', [top.connection, result]));
        }));
    },
function initEnvironment() {
    String.prototype.format = Format.format;
function main(argv) {
    initEnvironment();
    Gettext.bindtextdomain(Config.GETTEXT_PACKAGE, Config.LOCALEDIR);
    Gettext.textdomain(Config.GETTEXT_PACKAGE);
    let app = new WebPortalHelper();
    return app.run(argv);
(uuay)shellDBus.js
// -*- mode: js; js-indent-level: 4; indent-tabs-mode: nil -*-
const Gio = imports.gi.Gio;
const GLib = imports.gi.GLib;
const Lang = imports.lang;
const Meta = imports.gi.Meta;
const Shell = imports.gi.Shell;
const Config = imports.misc.config;
const ExtensionSystem = imports.ui.extensionSystem;
const ExtensionDownloader = imports.ui.extensionDownloader;
const ExtensionUtils = imports.misc.extensionUtils;
const Main = imports.ui.main;
const Screenshot = imports.ui.screenshot;
const ViewSelector = imports.ui.viewSelector;
const GnomeShellIface = '<node> \
<interface name="org.gnome.Shell"> \
<method name="Eval"> \
    <arg type="s" direction="in" name="script" /> \
    <arg type="b" direction="out" name="success" /> \
    <arg type="s" direction="out" name="result" /> \
</method> \
<method name="FocusSearch"/> \
<method name="ShowOSD"> \
    <arg type="a{sv}" direction="in" name="params"/> \
</method> \
<method name="ShowMonitorLabels"> \
    <arg type="a{uv}" direction="in" name="params" /> \
</method> \
<method name="HideMonitorLabels" /> \
<method name="FocusApp"> \
    <arg type="s" direction="in" name="id"/> \
</method> \
<method name="ShowApplications" /> \
<method name="GrabAccelerator"> \
    <arg type="s" direction="in" name="accelerator"/> \
    <arg type="u" direction="in" name="flags"/> \
    <arg type="u" direction="out" name="action"/> \
</method> \
<method name="GrabAccelerators"> \
    <arg type="a(su)" direction="in" name="accelerators"/> \
    <arg type="au" direction="out" name="actions"/> \
</method> \
<method name="UngrabAccelerator"> \
    <arg type="u" direction="in" name="action"/> \
    <arg type="b" direction="out" name="success"/> \
</method> \
<signal name="AcceleratorActivated"> \
    <arg name="action" type="u" /> \
    <arg name="parameters" type="a{sv}" /> \
</signal> \
<property name="Mode" type="s" access="read" /> \
<property name="OverviewActive" type="b" access="readwrite" /> \
<property name="ShellVersion" type="s" access="read" /> \
</interface> \
</node>';
const ScreenSaverIface = '<node> \
<interface name="org.gnome.ScreenSaver"> \
<method name="Lock"> \
</method> \
<method name="GetActive"> \
    <arg name="active" direction="out" type="b" /> \
</method> \
<method name="SetActive"> \
    <arg name="value" direction="in" type="b" /> \
</method> \
<method name="GetActiveTime"> \
    <arg name="value" direction="out" type="u" /> \
</method> \
<signal name="ActiveChanged"> \
    <arg name="new_value" type="b" /> \
</signal> \
<signal name="WakeUpScreen" /> \
</interface> \
</node>';
const GnomeShell = new Lang.Class({
    Name: 'GnomeShellDBus',
    _init: function() {
        this._dbusImpl = Gio.DBusExportedObject.wrapJSObject(GnomeShellIface, this);
        this._dbusImpl.export(Gio.DBus.session, '/org/gnome/Shell');
        this._extensionsService = new GnomeShellExtensions();
        this._screenshotService = new Screenshot.ScreenshotService();
        this._grabbedAccelerators = new Map();
        this._grabbers = new Map();
        global.display.connect('accelerator-activated', Lang.bind(this,
            function(display, action, deviceid, timestamp) {
                this._emitAcceleratorActivated(action, deviceid, timestamp);
            }));
        this._cachedOverviewVisible = false;
        Main.overview.connect('showing',
                              Lang.bind(this, this._checkOverviewVisibleChanged));
        Main.overview.connect('hidden',
                              Lang.bind(this, this._checkOverviewVisibleChanged));
    },
    /**
     * Eval:
     * @code: A string containing JavaScript code
     *
     * This function executes arbitrary code in the main
     * loop, and returns a boolean success and
     * JSON representation of the object as a string.
     *
     * If evaluation completes without throwing an exception,
     * then the return value will be [true, JSON.stringify(result)].
     * If evaluation fails, then the return value will be
     * [false, JSON.stringify(exception)];
     *
     */
    Eval: function(code) {
        if (!global.settings.get_boolean('development-tools'))
            return [false, ''];
        let returnValue;
        let success;
        try {
            returnValue = JSON.stringify(eval(code));
            // A hack; DBus doesn't have null/undefined
            if (returnValue == undefined)
                returnValue = '';
            success = true;
        } catch (e) {
            returnValue = '' + e;
            success = false;
        }
        return [success, returnValue];
    },
    FocusSearch: function() {
        Main.overview.focusSearch();
    },
    ShowOSD: function(params) {
        for (let param in params)
            params[param] = params[param].deep_unpack();
        let monitorIndex = -1;
        if (params['monitor'] >= 0)
            monitorIndex = params['monitor'];
        let icon = null;
        if (params['icon'])
            icon = Gio.Icon.new_for_string(params['icon']);
        Main.osdWindowManager.show(monitorIndex, icon, params['label'], params['level']);
    },
    FocusApp: function(id) {
        this.ShowApplications();
        Main.overview.viewSelector.appDisplay.selectApp(id);
    },
    ShowApplications: function() {
        Main.overview.viewSelector.showApps();
    },
    GrabAcceleratorAsync: function(params, invocation) {
        let [accel, flags] = params;
        let sender = invocation.get_sender();
        let bindingAction = this._grabAcceleratorForSender(accel, flags, sender);
        return invocation.return_value(GLib.Variant.new('(u)', [bindingAction]));
    },
    GrabAcceleratorsAsync: function(params, invocation) {
        let [accels] = params;
        let sender = invocation.get_sender();
        let bindingActions = [];
        for (let i = 0; i < accels.length; i++) {
            let [accel, flags] = accels[i];
            bindingActions.push(this._grabAcceleratorForSender(accel, flags, sender));
        }
        return invocation.return_value(GLib.Variant.new('(au)', [bindingActions]));
    },
    UngrabAcceleratorAsync: function(params, invocation) {
        let [action] = params;
        let grabbedBy = this._grabbedAccelerators.get(action);
        if (invocation.get_sender() != grabbedBy)
            return invocation.return_value(GLib.Variant.new('(b)', [false]));
        let ungrabSucceeded = global.display.ungrab_accelerator(action);
        if (ungrabSucceeded)
            this._grabbedAccelerators.delete(action);
        return invocation.return_value(GLib.Variant.new('(b)', [ungrabSucceeded]));
    },
    _emitAcceleratorActivated: function(action, deviceid, timestamp) {
        let destination = this._grabbedAccelerators.get(action);
        if (!destination)
            return;
        let connection = this._dbusImpl.get_connection();
        let info = this._dbusImpl.get_info();
        let params = { 'device-id': GLib.Variant.new('u', deviceid),
                       'timestamp': GLib.Variant.new('u', timestamp),
                       'action-mode': GLib.Variant.new('u', Main.actionMode) };
        connection.emit_signal(destination,
                               this._dbusImpl.get_object_path(),
                               info ? info.name : null,
                               'AcceleratorActivated',
                               GLib.Variant.new('(ua{sv})', [action, params]));
    },
    _grabAcceleratorForSender: function(accelerator, flags, sender) {
        let bindingAction = global.display.grab_accelerator(accelerator);
        if (bindingAction == Meta.KeyBindingAction.NONE)
            return Meta.KeyBindingAction.NONE;
        let bindingName = Meta.external_binding_name_for_action(bindingAction);
        Main.wm.allowKeybinding(bindingName, flags);
        this._grabbedAccelerators.set(bindingAction, sender);
        if (!this._grabbers.has(sender)) {
            let id = Gio.bus_watch_name(Gio.BusType.SESSION, sender, 0, null,
                                        Lang.bind(this, this._onGrabberBusNameVanished));
            this._grabbers.set(sender, id);
        }
        return bindingAction;
    },
    _ungrabAccelerator: function(action) {
        let ungrabSucceeded = global.display.ungrab_accelerator(action);
        if (ungrabSucceeded)
            this._grabbedAccelerators.delete(action);
    },
    _onGrabberBusNameVanished: function(connection, name) {
        let grabs = this._grabbedAccelerators.entries();
        for (let [action, sender] of grabs) {
            if (sender == name)
                this._ungrabAccelerator(action);
        }
        Gio.bus_unwatch_name(this._grabbers.get(name));
        this._grabbers.delete(name);
    },
    ShowMonitorLabelsAsync: function(params, invocation) {
        let sender = invocation.get_sender();
        let [dict] = params;
        Main.osdMonitorLabeler.show(sender, dict);
    },
    HideMonitorLabelsAsync: function(params, invocation) {
        let sender = invocation.get_sender();
        Main.osdMonitorLabeler.hide(sender);
    },
    Mode: global.session_mode,
    _checkOverviewVisibleChanged: function() {
        if (Main.overview.visible !== this._cachedOverviewVisible) {
            this._cachedOverviewVisible = Main.overview.visible;
            this._dbusImpl.emit_property_changed('OverviewActive', new GLib.Variant('b', this._cachedOverviewVisible));
        }
    },
    get OverviewActive() {
        return this._cachedOverviewVisible;
    },
    set OverviewActive(visible) {
        if (visible)
            Main.overview.show();
        else
            Main.overview.hide();
    },
    ShellVersion: Config.PACKAGE_VERSION
const GnomeShellExtensionsIface = '<node> \
<interface name="org.gnome.Shell.Extensions"> \
<method name="ListExtensions"> \
    <arg type="a{sa{sv}}" direction="out" name="extensions" /> \
</method> \
<method name="GetExtensionInfo"> \
    <arg type="s" direction="in" name="extension" /> \
    <arg type="a{sv}" direction="out" name="info" /> \
</method> \
<method name="GetExtensionErrors"> \
    <arg type="s" direction="in" name="extension" /> \
    <arg type="as" direction="out" name="errors" /> \
</method> \
<signal name="ExtensionStatusChanged"> \
    <arg type="s" name="uuid"/> \
    <arg type="i" name="state"/> \
    <arg type="s" name="error"/> \
</signal> \
<method name="InstallRemoteExtension"> \
    <arg type="s" direction="in" name="uuid"/> \
    <arg type="s" direction="out" name="result"/> \
</method> \
<method name="UninstallExtension"> \
    <arg type="s" direction="in" name="uuid"/> \
    <arg type="b" direction="out" name="success"/> \
</method> \
<method name="LaunchExtensionPrefs"> \
    <arg type="s" direction="in" name="uuid"/> \
</method> \
<method name="ReloadExtension"> \
    <arg type="s" direction="in" name="uuid"/> \
</method> \
<method name="CheckForUpdates"> \
</method> \
<property name="ShellVersion" type="s" access="read" /> \
</interface> \
</node>';
const GnomeShellExtensions = new Lang.Class({
    Name: 'GnomeShellExtensionsDBus',
    _init: function() {
        this._dbusImpl = Gio.DBusExportedObject.wrapJSObject(GnomeShellExtensionsIface, this);
        this._dbusImpl.export(Gio.DBus.session, '/org/gnome/Shell');
        ExtensionSystem.connect('extension-state-changed',
                                Lang.bind(this, this._extensionStateChanged));
    },
    ListExtensions: function() {
        let out = {};
        for (let uuid in ExtensionUtils.extensions) {
            let dbusObj = this.GetExtensionInfo(uuid);
            out[uuid] = dbusObj;
        }
        return out;
    },
    GetExtensionInfo: function(uuid) {
        let extension = ExtensionUtils.extensions[uuid];
        if (!extension)
            return {};
        let obj = {};
        Lang.copyProperties(extension.metadata, obj);
        // Only serialize the properties that we actually need.
        const serializedProperties = ["type", "state", "path", "error", "hasPrefs"];
        serializedProperties.forEach(function(prop) {
            obj[prop] = extension[prop];
        });
        let out = {};
        for (let key in obj) {
            let val = obj[key];
            let type;
            switch (typeof val) {
            case 'string':
                type = 's';
                break;
            case 'number':
                type = 'd';
                break;
            case 'boolean':
                type = 'b';
                break;
            default:
                continue;
            }
            out[key] = GLib.Variant.new(type, val);
        }
        return out;
    },
    GetExtensionErrors: function(uuid) {
        let extension = ExtensionUtils.extensions[uuid];
        if (!extension)
            return [];
        if (!extension.errors)
            return [];
        return extension.errors;
    },
    InstallRemoteExtensionAsync: function([uuid], invocation) {
        return ExtensionDownloader.installExtension(uuid, invocation);
    },
    UninstallExtension: function(uuid) {
        return ExtensionDownloader.uninstallExtension(uuid);
    },
    LaunchExtensionPrefs: function(uuid) {
        let appSys = Shell.AppSystem.get_default();
        let app = appSys.lookup_app('gnome-shell-extension-prefs.desktop');
        let info = app.get_app_info();
        let timestamp = global.display.get_current_time_roundtrip();
        info.launch_uris(['extension:///' + uuid],
                         global.create_app_launch_context(timestamp, -1));
    },
    ReloadExtension: function(uuid) {
        let extension = ExtensionUtils.extensions[uuid];
        if (!extension)
            return;
        ExtensionSystem.reloadExtension(extension);
    },
    CheckForUpdates: function() {
        ExtensionDownloader.checkForUpdates();
    },
    ShellVersion: Config.PACKAGE_VERSION,
    _extensionStateChanged: function(_, newState) {
        this._dbusImpl.emit_signal('ExtensionStatusChanged',
                                   GLib.Variant.new('(sis)', [newState.uuid, newState.state, newState.error]));
    }
const ScreenSaverDBus = new Lang.Class({
    Name: 'ScreenSaverDBus',
    _init: function(screenShield) {
        this.parent();
        this._screenShield = screenShield;
        screenShield.connect('active-changed', Lang.bind(this, function(shield) {
            this._dbusImpl.emit_signal('ActiveChanged', GLib.Variant.new('(b)', [shield.active]));
        }));
        screenShield.connect('wake-up-screen', Lang.bind(this, function(shield) {
            this._dbusImpl.emit_signal('WakeUpScreen', null);
        }));
        this._dbusImpl = Gio.DBusExportedObject.wrapJSObject(ScreenSaverIface, this);
        this._dbusImpl.export(Gio.DBus.session, '/org/gnome/ScreenSaver');
        Gio.DBus.session.own_name('org.gnome.ScreenSaver', Gio.BusNameOwnerFlags.REPLACE, null, null);
    },
    LockAsync: function(parameters, invocation) {
        let tmpId = this._screenShield.connect('lock-screen-shown', Lang.bind(this, function() {
            this._screenShield.disconnect(tmpId);
            invocation.return_value(null);
        }));
        this._screenShield.lock(true);
    },
    SetActive: function(active) {
        if (active)
            this._screenShield.activate(true);
        else
            this._screenShield.deactivate(false);
    },
    GetActive: function() {
        return this._screenShield.active;
    },
    GetActiveTime: function() {
        let started = this._screenShield.activationTime;
        if (started > 0)
            return Math.floor((GLib.get_monotonic_time() - started) / 1000000);
        else
            return 0;
    },
(uuay)ibusCandidatePopup.js
// -*- mode: js; js-indent-level: 4; indent-tabs-mode: nil -*-
const Clutter = imports.gi.Clutter;
const IBus = imports.gi.IBus;
const Lang = imports.lang;
const Signals = imports.signals;
const St = imports.gi.St;
const BoxPointer = imports.ui.boxpointer;
const Main = imports.ui.main;
const MAX_CANDIDATES_PER_PAGE = 16;
const DEFAULT_INDEX_LABELS = [ '1', '2', '3', '4', '5', '6', '7', '8',
                               '9', '0', 'a', 'b', 'c', 'd', 'e', 'f' ];
const CandidateArea = new Lang.Class({
    Name: 'CandidateArea',
    _init: function() {
        this.actor = new St.BoxLayout({ vertical: true,
                                        visible: false });
        this._candidateBoxes = [];
        for (let i = 0; i < MAX_CANDIDATES_PER_PAGE; ++i) {
            let box = new St.BoxLayout({ style_class: 'candidate-box',
                                         reactive: true,
                                         track_hover: true });
            box._indexLabel = new St.Label({ style_class: 'candidate-index' });
            box._candidateLabel = new St.Label({ style_class: 'candidate-label' });
            box.add(box._indexLabel, { y_fill: false });
            box.add(box._candidateLabel, { y_fill: false });
            this._candidateBoxes.push(box);
            this.actor.add(box);
            let j = i;
            box.connect('button-release-event', Lang.bind(this, function(actor, event) {
                this.emit('candidate-clicked', j, event.get_button(), event.get_state());
                return Clutter.EVENT_PROPAGATE;
            }));
        }
        this._buttonBox = new St.BoxLayout({ style_class: 'candidate-page-button-box' });
        this._previousButton = new St.Button({ style_class: 'candidate-page-button candidate-page-button-previous button' });
        this._previousButton.child = new St.Icon({ style_class: 'candidate-page-button-icon' });
        this._buttonBox.add(this._previousButton, { expand: true });
        this._nextButton = new St.Button({ style_class: 'candidate-page-button candidate-page-button-next button' });
        this._nextButton.child = new St.Icon({ style_class: 'candidate-page-button-icon' });
        this._buttonBox.add(this._nextButton, { expand: true });
        this.actor.add(this._buttonBox);
        this._previousButton.connect('clicked', Lang.bind(this, function() {
            this.emit('previous-page');
        }));
        this._nextButton.connect('clicked', Lang.bind(this, function() {
            this.emit('next-page');
        }));
        this._orientation = -1;
        this._cursorPosition = 0;
    },
    setOrientation: function(orientation) {
        if (this._orientation == orientation)
            return;
        this._orientation = orientation;
        if (this._orientation == IBus.Orientation.HORIZONTAL) {
            this.actor.vertical = false;
            this.actor.remove_style_class_name('vertical');
            this.actor.add_style_class_name('horizontal');
            this._previousButton.child.icon_name = 'go-previous-symbolic';
            this._nextButton.child.icon_name = 'go-next-symbolic';
        } else {                // VERTICAL || SYSTEM
            this.actor.vertical = true;
            this.actor.add_style_class_name('vertical');
            this.actor.remove_style_class_name('horizontal');
            this._previousButton.child.icon_name = 'go-up-symbolic';
            this._nextButton.child.icon_name = 'go-down-symbolic';
        }
    },
    setCandidates: function(indexes, candidates, cursorPosition, cursorVisible) {
        for (let i = 0; i < MAX_CANDIDATES_PER_PAGE; ++i) {
            let visible = i < candidates.length;
            let box = this._candidateBoxes[i];
            box.visible = visible;
            if (!visible)
                continue;
            box._indexLabel.text = ((indexes && indexes[i]) ? indexes[i] : DEFAULT_INDEX_LABELS[i]);
            box._candidateLabel.text = candidates[i];
        }
        this._candidateBoxes[this._cursorPosition].remove_style_pseudo_class('selected');
        this._cursorPosition = cursorPosition;
        if (cursorVisible)
            this._candidateBoxes[cursorPosition].add_style_pseudo_class('selected');
    },
    updateButtons: function(wrapsAround, page, nPages) {
        if (nPages < 2) {
            this._buttonBox.hide();
            return;
        }
        this._buttonBox.show();
        this._previousButton.reactive = wrapsAround || page > 0;
        this._nextButton.reactive = wrapsAround || page < nPages - 1;
    },
Signals.addSignalMethods(CandidateArea.prototype);
const CandidatePopup = new Lang.Class({
    Name: 'CandidatePopup',
    _init: function() {
        this._boxPointer = new BoxPointer.BoxPointer(St.Side.TOP);
        this._boxPointer.actor.visible = false;
        this._boxPointer.actor.style_class = 'candidate-popup-boxpointer';
        Main.layoutManager.addChrome(this._boxPointer.actor);
        let box = new St.BoxLayout({ style_class: 'candidate-popup-content',
                                     vertical: true });
        this._boxPointer.bin.set_child(box);
        this._preeditText = new St.Label({ style_class: 'candidate-popup-text',
                                           visible: false });
        box.add(this._preeditText);
        this._auxText = new St.Label({ style_class: 'candidate-popup-text',
                                       visible: false });
        box.add(this._auxText);
        this._candidateArea = new CandidateArea();
        box.add(this._candidateArea.actor);
        this._candidateArea.connect('previous-page', Lang.bind(this, function() {
            this._panelService.page_up();
        }));
        this._candidateArea.connect('next-page', Lang.bind(this, function() {
            this._panelService.page_down();
        }));
        this._candidateArea.connect('candidate-clicked', Lang.bind(this, function(ca, index, button, state) {
            this._panelService.candidate_clicked(index, button, state);
        }));
        this._panelService = null;
    },
    setPanelService: function(panelService) {
        this._panelService = panelService;
        if (!panelService)
            return;
        panelService.connect('set-cursor-location',
                             Lang.bind(this, function(ps, x, y, w, h) {
                                 this._setDummyCursorGeometry(x, y, w, h);
                             }));
        try {
            panelService.connect('set-cursor-location-relative',
                                 Lang.bind(this, function(ps, x, y, w, h) {
                                     if (!global.display.focus_window)
                                         return;
                                     let window = global.display.focus_window.get_compositor_private();
                                     this._setDummyCursorGeometry(window.x + x, window.y + y, w, h);
                                 }));
        } catch(e) {
            // Only recent IBus versions have support for this signal
            // which is used for wayland clients. In order to work
            // with older IBus versions we can silently ignore the
            // signal's absence.
        }
        panelService.connect('update-preedit-text',
                             Lang.bind(this, function(ps, text, cursorPosition, visible) {
                                 this._preeditText.visible = visible;
                                 this._updateVisibility();
                                 this._preeditText.text = text.get_text();
                                 let attrs = text.get_attributes();
                                 if (attrs)
                                     this._setTextAttributes(this._preeditText.clutter_text,
                                                             attrs);
                             }));
        panelService.connect('show-preedit-text',
                             Lang.bind(this, function(ps) {
                                 this._preeditText.show();
                                 this._updateVisibility();
                             }));
        panelService.connect('hide-preedit-text',
                             Lang.bind(this, function(ps) {
                                 this._preeditText.hide();
                                 this._updateVisibility();
                             }));
        panelService.connect('update-auxiliary-text',
                             Lang.bind(this, function(ps, text, visible) {
                                 this._auxText.visible = visible;
                                 this._updateVisibility();
                                 this._auxText.text = text.get_text();
                             }));
        panelService.connect('show-auxiliary-text',
                             Lang.bind(this, function(ps) {
                                 this._auxText.show();
                                 this._updateVisibility();
                             }));
        panelService.connect('hide-auxiliary-text',
                             Lang.bind(this, function(ps) {
                                 this._auxText.hide();
                                 this._updateVisibility();
                             }));
        panelService.connect('update-lookup-table',
                             Lang.bind(this, function(ps, lookupTable, visible) {
                                 this._candidateArea.actor.visible = visible;
                                 this._updateVisibility();
                                 let nCandidates = lookupTable.get_number_of_candidates();
                                 let cursorPos = lookupTable.get_cursor_pos();
                                 let pageSize = lookupTable.get_page_size();
                                 let nPages = Math.ceil(nCandidates / pageSize);
                                 let page = ((cursorPos == 0) ? 0 : Math.floor(cursorPos / pageSize));
                                 let startIndex = page * pageSize;
                                 let endIndex = Math.min((page + 1) * pageSize, nCandidates);
                                 let indexes = [];
                                 let indexLabel;
                                 for (let i = 0; indexLabel = lookupTable.get_label(i); ++i)
                                      indexes.push(indexLabel.get_text());
                                 let candidates = [];
                                 for (let i = startIndex; i < endIndex; ++i)
                                     candidates.push(lookupTable.get_candidate(i).get_text());
                                 this._candidateArea.setCandidates(indexes,
                                                                   candidates,
                                                                   cursorPos % pageSize,
                                                                   lookupTable.is_cursor_visible());
                                 this._candidateArea.setOrientation(lookupTable.get_orientation());
                                 this._candidateArea.updateButtons(lookupTable.is_round(), page, nPages);
                             }));
        panelService.connect('show-lookup-table',
                             Lang.bind(this, function(ps) {
                                 this._candidateArea.actor.show();
                                 this._updateVisibility();
                             }));
        panelService.connect('hide-lookup-table',
                             Lang.bind(this, function(ps) {
                                 this._candidateArea.actor.hide();
                                 this._updateVisibility();
                             }));
        panelService.connect('focus-out',
                             Lang.bind(this, function(ps) {
                                 this._boxPointer.hide(BoxPointer.PopupAnimation.NONE);
                             }));
    },
    _setDummyCursorGeometry: function(x, y, w, h) {
        Main.layoutManager.setDummyCursorGeometry(x, y, w, h);
        if (this._boxPointer.actor.visible)
            this._boxPointer.setPosition(Main.layoutManager.dummyCursor, 0);
    },
    _updateVisibility: function() {
        let isVisible = (this._preeditText.visible ||
                         this._auxText.visible ||
                         this._candidateArea.actor.visible);
        if (isVisible) {
            this._boxPointer.setPosition(Main.layoutManager.dummyCursor, 0);
            this._boxPointer.show(BoxPointer.PopupAnimation.NONE);
            this._boxPointer.actor.raise_top();
        } else {
            this._boxPointer.hide(BoxPointer.PopupAnimation.NONE);
        }
    },
    _setTextAttributes: function(clutterText, ibusAttrList) {
        let attr;
        for (let i = 0; attr = ibusAttrList.get(i); ++i)
            if (attr.get_attr_type() == IBus.AttrType.BACKGROUND)
                clutterText.set_selection(attr.get_start_index(), attr.get_end_index());
    }
(uuay)polkitAgent.js
// -*- mode: js; js-indent-level: 4; indent-tabs-mode: nil -*-
const Lang = imports.lang;
const Signals = imports.signals;
const Shell = imports.gi.Shell;
const AccountsService = imports.gi.AccountsService;
const Clutter = imports.gi.Clutter;
const St = imports.gi.St;
const Pango = imports.gi.Pango;
const GLib = imports.gi.GLib;
const Gio = imports.gi.Gio;
const Mainloop = imports.mainloop;
const Polkit = imports.gi.Polkit;
const PolkitAgent = imports.gi.PolkitAgent;
const Animation = imports.ui.animation;
const Components = imports.ui.components;
const ModalDialog = imports.ui.modalDialog;
const ShellEntry = imports.ui.shellEntry;
const UserWidget = imports.ui.userWidget;
const Tweener = imports.ui.tweener;
const DIALOG_ICON_SIZE = 48;
const WORK_SPINNER_ICON_SIZE = 16;
const WORK_SPINNER_ANIMATION_DELAY = 1.0;
const WORK_SPINNER_ANIMATION_TIME = 0.3;
const AuthenticationDialog = new Lang.Class({
    Name: 'AuthenticationDialog',
    Extends: ModalDialog.ModalDialog,
    _init: function(actionId, message, cookie, userNames) {
        this.parent({ styleClass: 'prompt-dialog' });
        this.actionId = actionId;
        this.message = message;
        this.userNames = userNames;
        this._wasDismissed = false;
        let mainContentBox = new St.BoxLayout({ style_class: 'prompt-dialog-main-layout',
                                                vertical: false });
        this.contentLayout.add(mainContentBox,
                               { x_fill: true,
                                 y_fill: true });
        let icon = new St.Icon({ icon_name: 'dialog-password-symbolic' });
        mainContentBox.add(icon,
                           { x_fill:  true,
                             y_fill:  false,
                             x_align: St.Align.END,
                             y_align: St.Align.START });
        let messageBox = new St.BoxLayout({ style_class: 'prompt-dialog-message-layout',
                                            vertical: true });
        mainContentBox.add(messageBox,
                           { expand: true, y_align: St.Align.START });
        this._subjectLabel = new St.Label({ style_class: 'prompt-dialog-headline headline',
                                            text: _("Authentication Required") });
        messageBox.add(this._subjectLabel,
                       { x_fill: false,
                         y_fill:  false,
                         x_align: St.Align.START,
                         y_align: St.Align.START });
        this._descriptionLabel = new St.Label({ style_class: 'prompt-dialog-description',
                                                text: message });
        this._descriptionLabel.clutter_text.ellipsize = Pango.EllipsizeMode.NONE;
        this._descriptionLabel.clutter_text.line_wrap = true;
        messageBox.add(this._descriptionLabel,
                       { x_fill: false,
                         y_fill:  true,
                         x_align: St.Align.START,
                         y_align: St.Align.START });
        if (userNames.length > 1) {
            log('polkitAuthenticationAgent: Received ' + userNames.length +
                ' identities that can be used for authentication. Only ' +
                'considering one.');
        }
        let userName = GLib.get_user_name();
        if (userNames.indexOf(userName) < 0)
            userName = 'root';
        if (userNames.indexOf(userName) < 0)
            userName = userNames[0];
        this._user = AccountsService.UserManager.get_default().get_user(userName);
        let userRealName = this._user.get_real_name()
        this._userLoadedId = this._user.connect('notify::is_loaded',
                                                Lang.bind(this, this._onUserChanged));
        this._userChangedId = this._user.connect('changed',
                                                 Lang.bind(this, this._onUserChanged));
        // Special case 'root'
        let userIsRoot = false;
        if (userName == 'root') {
            userIsRoot = true;
            userRealName = _("Administrator");
        }
        if (userIsRoot) {
            let userLabel = new St.Label(({ style_class: 'polkit-dialog-user-root-label',
                                            text: userRealName }));
            messageBox.add(userLabel, { x_fill: false,
                                        x_align: St.Align.START });
        } else {
            let userBox = new St.BoxLayout({ style_class: 'polkit-dialog-user-layout',
                                             vertical: false });
            messageBox.add(userBox);
            this._userAvatar = new UserWidget.Avatar(this._user,
                                                     { iconSize: DIALOG_ICON_SIZE,
                                                       styleClass: 'polkit-dialog-user-icon' });
            this._userAvatar.actor.hide();
            userBox.add(this._userAvatar.actor,
                        { x_fill:  true,
                          y_fill:  false,
                          x_align: St.Align.END,
                          y_align: St.Align.START });
            let userLabel = new St.Label(({ style_class: 'polkit-dialog-user-label',
                                            text: userRealName }));
            userBox.add(userLabel,
                        { x_fill:  true,
                          y_fill:  false,
                          x_align: St.Align.END,
                          y_align: St.Align.MIDDLE });
        }
        this._onUserChanged();
        this._passwordBox = new St.BoxLayout({ vertical: false, style_class: 'prompt-dialog-password-box' });
        messageBox.add(this._passwordBox);
        this._passwordLabel = new St.Label(({ style_class: 'prompt-dialog-password-label' }));
        this._passwordBox.add(this._passwordLabel, { y_fill: false, y_align: St.Align.MIDDLE });
        this._passwordEntry = new St.Entry({ style_class: 'prompt-dialog-password-entry',
                                             text: "",
                                             can_focus: true});
        ShellEntry.addContextMenu(this._passwordEntry, { isPassword: true });
        this._passwordEntry.clutter_text.connect('activate', Lang.bind(this, this._onEntryActivate));
        this._passwordBox.add(this._passwordEntry,
                              { expand: true });
        let spinnerIcon = Gio.File.new_for_uri('resource:///org/gnome/shell/theme/process-working.svg');
        this._workSpinner = new Animation.AnimatedIcon(spinnerIcon, WORK_SPINNER_ICON_SIZE);
        this._workSpinner.actor.opacity = 0;
        this._passwordBox.add(this._workSpinner.actor);
        this.setInitialKeyFocus(this._passwordEntry);
        this._passwordBox.hide();
        this._errorMessageLabel = new St.Label({ style_class: 'prompt-dialog-error-label' });
        this._errorMessageLabel.clutter_text.ellipsize = Pango.EllipsizeMode.NONE;
        this._errorMessageLabel.clutter_text.line_wrap = true;
        messageBox.add(this._errorMessageLabel, { x_fill: false, x_align: St.Align.START });
        this._errorMessageLabel.hide();
        this._infoMessageLabel = new St.Label({ style_class: 'prompt-dialog-info-label' });
        this._infoMessageLabel.clutter_text.ellipsize = Pango.EllipsizeMode.NONE;
        this._infoMessageLabel.clutter_text.line_wrap = true;
        messageBox.add(this._infoMessageLabel);
        this._infoMessageLabel.hide();
        /* text is intentionally non-blank otherwise the height is not the same as for
         * infoMessage and errorMessageLabel - but it is still invisible because
         * gnome-shell.css sets the color to be transparent
         */
        this._nullMessageLabel = new St.Label({ style_class: 'prompt-dialog-null-label',
                                                text: 'abc'});
        this._nullMessageLabel.add_style_class_name('hidden');
        this._nullMessageLabel.clutter_text.ellipsize = Pango.EllipsizeMode.NONE;
        this._nullMessageLabel.clutter_text.line_wrap = true;
        messageBox.add(this._nullMessageLabel);
        this._nullMessageLabel.show();
        this._cancelButton = this.addButton({ label: _("Cancel"),
                                              action: Lang.bind(this, this.cancel),
                                              key: Clutter.Escape });
        this._okButton = this.addButton({ label:  _("Authenticate"),
                                          action: Lang.bind(this, this._onAuthenticateButtonPressed),
                                          default: true });
        this._doneEmitted = false;
        this._identityToAuth = Polkit.UnixUser.new_for_name(userName);
        this._cookie = cookie;
    },
    _setWorking: function(working) {
        Tweener.removeTweens(this._workSpinner.actor);
        if (working) {
            this._workSpinner.play();
            Tweener.addTween(this._workSpinner.actor,
                             { opacity: 255,
                               delay: WORK_SPINNER_ANIMATION_DELAY,
                               time: WORK_SPINNER_ANIMATION_TIME,
                               transition: 'linear'
                             });
        } else {
            Tweener.addTween(this._workSpinner.actor,
                             { opacity: 0,
                               time: WORK_SPINNER_ANIMATION_TIME,
                               transition: 'linear',
                               onCompleteScope: this,
                               onComplete: function() {
                                   if (this._workSpinner)
                                       this._workSpinner.stop();
                               }
                             });
        }
    },
    performAuthentication: function() {
        this.destroySession();
        this._session = new PolkitAgent.Session({ identity: this._identityToAuth,
                                                  cookie: this._cookie });
        this._session.connect('completed', Lang.bind(this, this._onSessionCompleted));
        this._session.connect('request', Lang.bind(this, this._onSessionRequest));
        this._session.connect('show-error', Lang.bind(this, this._onSessionShowError));
        this._session.connect('show-info', Lang.bind(this, this._onSessionShowInfo));
        this._session.initiate();
    },
    _ensureOpen: function() {
        // NOTE: ModalDialog.open() is safe to call if the dialog is
        // already open - it just returns true without side-effects
        if (!this.open(global.get_current_time())) {
            // This can fail if e.g. unable to get input grab
            //
            // In an ideal world this wouldn't happen (because the
            // Shell is in complete control of the session) but that's
            // just not how things work right now.
            //
            // One way to make this happen is by running 'sleep 3;
            // pkexec bash' and then opening a popup menu.
            //
            // We could add retrying if this turns out to be a problem
            log('polkitAuthenticationAgent: Failed to show modal dialog.' +
                ' Dismissing authentication request for action-id ' + this.actionId +
                ' cookie ' + this._cookie);
            this._emitDone(true);
        }
    },
    _emitDone: function(dismissed) {
        if (!this._doneEmitted) {
            this._doneEmitted = true;
            this.emit('done', dismissed);
        }
    },
    _updateSensitivity: function(sensitive) {
        this._passwordEntry.reactive = sensitive;
        this._passwordEntry.clutter_text.editable = sensitive;
        this._okButton.can_focus = sensitive;
        this._okButton.reactive = sensitive;
        this._setWorking(!sensitive);
    },
    _onEntryActivate: function() {
        let response = this._passwordEntry.get_text();
        this._updateSensitivity(false);
        this._session.response(response);
        // When the user responds, dismiss already shown info and
        // error texts (if any)
        this._errorMessageLabel.hide();
        this._infoMessageLabel.hide();
        this._nullMessageLabel.show();
    },
    _onAuthenticateButtonPressed: function() {
        this._onEntryActivate();
    },
    _onSessionCompleted: function(session, gainedAuthorization) {
        if (this._completed || this._doneEmitted)
            return;
        this._completed = true;
        /* Yay, all done */
        if (gainedAuthorization) {
            this._emitDone(false);
        } else {
            /* Unless we are showing an existing error message from the PAM
             * module (the PAM module could be reporting the authentication
             * error providing authentication-method specific information),
             * show "Sorry, that didn't work. Please try again."
             */
            if (!this._errorMessageLabel.visible && !this._wasDismissed) {
                /* Translators: "that didn't work" refers to the fact that the
                 * requested authentication was not gained; this can happen
                 * because of an authentication error (like invalid password),
                 * for instance. */
                this._errorMessageLabel.set_text(_("Sorry, that didn\'t work. Please try again."));
                this._errorMessageLabel.show();
                this._infoMessageLabel.hide();
                this._nullMessageLabel.hide();
            }
            /* Try and authenticate again */
            this.performAuthentication();
        }
    },
    _onSessionRequest: function(session, request, echo_on) {
        // Cheap localization trick
        if (request == 'Password:' || request == 'Password: ')
            this._passwordLabel.set_text(_("Password:"));
        else
            this._passwordLabel.set_text(request);
        if (echo_on)
            this._passwordEntry.clutter_text.set_password_char('');
        else
            this._passwordEntry.clutter_text.set_password_char('\u25cf'); // 
 U+25CF BLACK CIRCLE
        this._passwordBox.show();
        this._passwordEntry.set_text('');
        this._passwordEntry.grab_key_focus();
        this._updateSensitivity(true);
        this._ensureOpen();
    },
    _onSessionShowError: function(session, text) {
        this._passwordEntry.set_text('');
        this._errorMessageLabel.set_text(text);
        this._errorMessageLabel.show();
        this._infoMessageLabel.hide();
        this._nullMessageLabel.hide();
        this._ensureOpen();
    },
    _onSessionShowInfo: function(session, text) {
        this._passwordEntry.set_text('');
        this._infoMessageLabel.set_text(text);
        this._infoMessageLabel.show();
        this._errorMessageLabel.hide();
        this._nullMessageLabel.hide();
        this._ensureOpen();
    },
    destroySession: function() {
        if (this._session) {
            if (!this._completed)
                this._session.cancel();
            this._completed = false;
            this._session = null;
        }
    },
    _onUserChanged: function() {
        if (this._user.is_loaded && this._userAvatar) {
            this._userAvatar.update();
            this._userAvatar.actor.show();
        }
    },
    cancel: function() {
        this._wasDismissed = true;
        this.close(global.get_current_time());
        this._emitDone(true);
    },
Signals.addSignalMethods(AuthenticationDialog.prototype);
const AuthenticationAgent = new Lang.Class({
    Name: 'AuthenticationAgent',
    _init: function() {
        this._currentDialog = null;
        this._handle = null;
        this._native = new Shell.PolkitAuthenticationAgent();
        this._native.connect('initiate', Lang.bind(this, this._onInitiate));
        this._native.connect('cancel', Lang.bind(this, this._onCancel));
    },
    enable: function() {
        try {
            this._native.register();
        } catch(e) {
            log('Failed to register AuthenticationAgent');
        }
    },
    disable: function() {
        try {
            this._native.unregister();
        } catch(e) {
            log('Failed to unregister AuthenticationAgent');
        }
    },
    _onInitiate: function(nativeAgent, actionId, message, iconName, cookie, userNames) {
        this._currentDialog = new AuthenticationDialog(actionId, message, cookie, userNames);
        // We actually don't want to open the dialog until we know for
        // sure that we're going to interact with the user. For
        // example, if the password for the identity to auth is blank
        // (which it will be on a live CD) then there will be no
        // conversation at all... of course, we don't *know* that
        // until we actually try it.
        //
        // See https://bugzilla.gnome.org/show_bug.cgi?id=643062 for more
        // discussion.
        this._currentDialog.connect('done', Lang.bind(this, this._onDialogDone));
        this._currentDialog.performAuthentication();
    },
    _onCancel: function(nativeAgent) {
        this._completeRequest(false);
    },
    _onDialogDone: function(dialog, dismissed) {
        this._completeRequest(dismissed);
    },
    _completeRequest: function(dismissed) {
        this._currentDialog.close();
        this._currentDialog.destroySession();
        this._currentDialog = null;
        this._native.complete(dismissed);
    },
const Component = AuthenticationAgent;
(uuay)magnifier.js
// -*- mode: js; js-indent-level: 4; indent-tabs-mode: nil -*-
const Atspi = imports.gi.Atspi;
const Clutter = imports.gi.Clutter;
const GDesktopEnums = imports.gi.GDesktopEnums;
const Gio = imports.gi.Gio;
const GLib = imports.gi.GLib;
const Shell = imports.gi.Shell;
const St = imports.gi.St;
const Lang = imports.lang;
const Mainloop = imports.mainloop;
const Meta = imports.gi.Meta;
const Signals = imports.signals;
const Background = imports.ui.background;
const FocusCaretTracker = imports.ui.focusCaretTracker;
const Main = imports.ui.main;
const MagnifierDBus = imports.ui.magnifierDBus;
const Params = imports.misc.params;
const PointerWatcher = imports.ui.pointerWatcher;
const MOUSE_POLL_FREQUENCY = 50;
const CROSSHAIRS_CLIP_SIZE = [100, 100];
const NO_CHANGE = 0.0;
const POINTER_REST_TIME = 1000; // milliseconds
// Settings
const APPLICATIONS_SCHEMA       = 'org.gnome.desktop.a11y.applications';
const SHOW_KEY                  = 'screen-magnifier-enabled';
const MAGNIFIER_SCHEMA          = 'org.gnome.desktop.a11y.magnifier';
const SCREEN_POSITION_KEY       = 'screen-position';
const MAG_FACTOR_KEY            = 'mag-factor';
const INVERT_LIGHTNESS_KEY      = 'invert-lightness';
const COLOR_SATURATION_KEY      = 'color-saturation';
const BRIGHT_RED_KEY            = 'brightness-red';
const BRIGHT_GREEN_KEY          = 'brightness-green';
const BRIGHT_BLUE_KEY           = 'brightness-blue';
const CONTRAST_RED_KEY          = 'contrast-red';
const CONTRAST_GREEN_KEY        = 'contrast-green';
const CONTRAST_BLUE_KEY         = 'contrast-blue';
const LENS_MODE_KEY             = 'lens-mode';
const CLAMP_MODE_KEY            = 'scroll-at-edges';
const MOUSE_TRACKING_KEY        = 'mouse-tracking';
const FOCUS_TRACKING_KEY        = 'focus-tracking';
const CARET_TRACKING_KEY        = 'caret-tracking';
const SHOW_CROSS_HAIRS_KEY      = 'show-cross-hairs';
const CROSS_HAIRS_THICKNESS_KEY = 'cross-hairs-thickness';
const CROSS_HAIRS_COLOR_KEY     = 'cross-hairs-color';
const CROSS_HAIRS_OPACITY_KEY   = 'cross-hairs-opacity';
const CROSS_HAIRS_LENGTH_KEY    = 'cross-hairs-length';
const CROSS_HAIRS_CLIP_KEY      = 'cross-hairs-clip';
let magDBusService = null;
const Magnifier = new Lang.Class({
    Name: 'Magnifier',
    _init: function() {
        // Magnifier is a manager of ZoomRegions.
        this._zoomRegions = [];
        // Create small clutter tree for the magnified mouse.
        let cursorTracker = Meta.CursorTracker.get_for_screen(global.screen);
        this._mouseSprite = new Clutter.Texture();
        Shell.util_cursor_tracker_to_clutter(cursorTracker, this._mouseSprite);
        this._cursorRoot = new Clutter.Actor();
        this._cursorRoot.add_actor(this._mouseSprite);
        // Create the first ZoomRegion and initialize it according to the
        // magnification settings.
        let mask;
        [this.xMouse, this.yMouse, mask] = global.get_pointer();
        let aZoomRegion = new ZoomRegion(this, this._cursorRoot);
        this._zoomRegions.push(aZoomRegion);
        let showAtLaunch = this._settingsInit(aZoomRegion);
        aZoomRegion.scrollContentsTo(this.xMouse, this.yMouse);
        cursorTracker.connect('cursor-changed', Lang.bind(this, this._updateMouseSprite));
        this._cursorTracker = cursorTracker;
        // Export to dbus.
        magDBusService = new MagnifierDBus.ShellMagnifier();
        this.setActive(showAtLaunch);
    },
    /**
     * showSystemCursor:
     * Show the system mouse pointer.
     */
    showSystemCursor: function() {
        this._cursorTracker.set_pointer_visible(true);
    },
    /**
     * hideSystemCursor:
     * Hide the system mouse pointer.
     */
    hideSystemCursor: function() {
        this._cursorTracker.set_pointer_visible(false);
    },
    /**
     * setActive:
     * Show/hide all the zoom regions.
     * @activate:   Boolean to activate or de-activate the magnifier.
     */
    setActive: function(activate) {
        let isActive = this.isActive();
        this._zoomRegions.forEach (function(zoomRegion, index, array) {
            zoomRegion.setActive(activate);
        });
        if (isActive != activate) {
            if (activate) {
                Meta.disable_unredirect_for_screen(global.screen);
                this.startTrackingMouse();
            } else {
                Meta.enable_unredirect_for_screen(global.screen);
                this.stopTrackingMouse();
            }
        }
        // Make sure system mouse pointer is shown when all zoom regions are
        // invisible.
        if (!activate)
            this._cursorTracker.set_pointer_visible(true);
        // Notify interested parties of this change
        this.emit('active-changed', activate);
    },
    /**
     * isActive:
     * @return  Whether the magnifier is active (boolean).
     */
    isActive: function() {
        // Sufficient to check one ZoomRegion since Magnifier's active
        // state applies to all of them.
        if (this._zoomRegions.length == 0)
            return false;
        else
            return this._zoomRegions[0].isActive();
    },
    /**
     * startTrackingMouse:
     * Turn on mouse tracking, if not already doing so.
     */
    startTrackingMouse: function() {
        if (!this._pointerWatch)
            this._pointerWatch = PointerWatcher.getPointerWatcher().addWatch(MOUSE_POLL_FREQUENCY, Lang.bind(this, this.scrollToMousePos));
    },
    /**
     * stopTrackingMouse:
     * Turn off mouse tracking, if not already doing so.
     */
    stopTrackingMouse: function() {
        if (this._pointerWatch)
            this._pointerWatch.remove();
        this._pointerWatch = null;
    },
    /**
     * isTrackingMouse:
     * Is the magnifier tracking the mouse currently?
     */
    isTrackingMouse: function() {
        return !!this._mouseTrackingId;
    },
    /**
     * scrollToMousePos:
     * Position all zoom regions' ROI relative to the current location of the
     * system pointer.
     * @return      true.
     */
    scrollToMousePos: function() {
        let [xMouse, yMouse, mask] = global.get_pointer();
        if (xMouse != this.xMouse || yMouse != this.yMouse) {
            this.xMouse = xMouse;
            this.yMouse = yMouse;
            let sysMouseOverAny = false;
            this._zoomRegions.forEach(function(zoomRegion, index, array) {
                if (zoomRegion.scrollToMousePos())
                    sysMouseOverAny = true;
            });
            if (sysMouseOverAny)
                this.hideSystemCursor();
            else
                this.showSystemCursor();
        }
        return true;
    },
    /**
     * createZoomRegion:
     * Create a ZoomRegion instance with the given properties.
     * @xMagFactor:     The power to set horizontal magnification of the
     *                  ZoomRegion.  A value of 1.0 means no magnification.  A
     *                  value of 2.0 doubles the size.
     * @yMagFactor:     The power to set the vertical magnification of the
     *                  ZoomRegion.
     * @roi             Object in the form { x, y, width, height } that
     *                  defines the region to magnify.  Given in unmagnified
     *                  coordinates.
     * @viewPort        Object in the form { x, y, width, height } that defines
     *                  the position of the ZoomRegion on screen.
     * @return          The newly created ZoomRegion.
     */
    createZoomRegion: function(xMagFactor, yMagFactor, roi, viewPort) {
        let zoomRegion = new ZoomRegion(this, this._cursorRoot);
        zoomRegion.setViewPort(viewPort);
        // We ignore the redundant width/height on the ROI
        let fixedROI = new Object(roi);
        fixedROI.width = viewPort.width / xMagFactor;
        fixedROI.height = viewPort.height / yMagFactor;
        zoomRegion.setROI(fixedROI);
        zoomRegion.addCrosshairs(this._crossHairs);
        return zoomRegion;
    },
    /**
     * addZoomRegion:
     * Append the given ZoomRegion to the list of currently defined ZoomRegions
     * for this Magnifier instance.
     * @zoomRegion:     The zoomRegion to add.
     */
    addZoomRegion: function(zoomRegion) {
        if(zoomRegion) {
            this._zoomRegions.push(zoomRegion);
            if (!this.isTrackingMouse())
                this.startTrackingMouse();
        }
    },
    /**
     * getZoomRegions:
     * Return a list of ZoomRegion's for this Magnifier.
     * @return:     The Magnifier's zoom region list (array).
     */
    getZoomRegions: function() {
        return this._zoomRegions;
    },
    /**
     * clearAllZoomRegions:
     * Remove all the zoom regions from this Magnfier's ZoomRegion list.
     */
    clearAllZoomRegions: function() {
        for (let i = 0; i < this._zoomRegions.length; i++)
            this._zoomRegions[i].setActive(false);
        this._zoomRegions.length = 0;
        this.stopTrackingMouse();
        this.showSystemCursor();
    },
    /**
     * addCrosshairs:
     * Add and show a cross hair centered on the magnified mouse.
     */
    addCrosshairs: function() {
        if (!this._crossHairs)
            this._crossHairs = new Crosshairs();
        let thickness = this._settings.get_int(CROSS_HAIRS_THICKNESS_KEY);
        let color = this._settings.get_string(CROSS_HAIRS_COLOR_KEY);
        let opacity = this._settings.get_double(CROSS_HAIRS_OPACITY_KEY);
        let length = this._settings.get_int(CROSS_HAIRS_LENGTH_KEY);
        let clip = this._settings.get_boolean(CROSS_HAIRS_CLIP_KEY);
        this.setCrosshairsThickness(thickness);
        this.setCrosshairsColor(color);
        this.setCrosshairsOpacity(opacity);
        this.setCrosshairsLength(length);
        this.setCrosshairsClip(clip);
        let theCrossHairs = this._crossHairs;
        this._zoomRegions.forEach (function(zoomRegion, index, array) {
            zoomRegion.addCrosshairs(theCrossHairs);
        });
    },
    /**
     * setCrosshairsVisible:
     * Show or hide the cross hair.
     * @visible    Flag that indicates show (true) or hide (false).
     */
    setCrosshairsVisible: function(visible) {
        if (visible) {
            if (!this._crossHairs)
                this.addCrosshairs();
            this._crossHairs.show();
        }
        else {
            if (this._crossHairs)
                this._crossHairs.hide();
        }
    },
    /**
     * setCrosshairsColor:
     * Set the color of the crosshairs for all ZoomRegions.
     * @color:  The color as a string, e.g. '#ff0000ff' or 'red'.
     */
    setCrosshairsColor: function(color) {
        if (this._crossHairs) {
            let [res, clutterColor] = Clutter.Color.from_string(color);
            this._crossHairs.setColor(clutterColor);
        }
    },
    /**
     * getCrosshairsColor:
     * Get the color of the crosshairs.
     * @return: The color as a string, e.g. '#0000ffff' or 'blue'.
     */
    getCrosshairsColor: function() {
        if (this._crossHairs) {
            let clutterColor = this._crossHairs.getColor();
            return clutterColor.to_string();
        }
        else
            return '#00000000';
    },
    /**
     * setCrosshairsThickness:
     * Set the crosshairs thickness for all ZoomRegions.
     * @thickness:  The width of the vertical and horizontal lines of the
     *              crosshairs.
     */
    setCrosshairsThickness: function(thickness) {
        if (this._crossHairs)
            this._crossHairs.setThickness(thickness);
    },
    /**
     * getCrosshairsThickness:
     * Get the crosshairs thickness.
     * @return: The width of the vertical and horizontal lines of the
     *          crosshairs.
     */
    getCrosshairsThickness: function() {
        if (this._crossHairs)
            return this._crossHairs.getThickness();
        else
            return 0;
    },
    /**
     * setCrosshairsOpacity:
     * @opacity:    Value between 0.0 (transparent) and 1.0 (fully opaque).
     */
    setCrosshairsOpacity: function(opacity) {
        if (this._crossHairs)
            this._crossHairs.setOpacity(opacity * 255);
    },
    /**
     * getCrosshairsOpacity:
     * @return:     Value between 0.0 (transparent) and 1.0 (fully opaque).
     */
    getCrosshairsOpacity: function() {
        if (this._crossHairs)
            return this._crossHairs.getOpacity() / 255.0;
        else
            return 0.0;
    },
    /**
     * setCrosshairsLength:
     * Set the crosshairs length for all ZoomRegions.
     * @length: The length of the vertical and horizontal lines making up the
     *          crosshairs.
     */
    setCrosshairsLength: function(length) {
        if (this._crossHairs)
            this._crossHairs.setLength(length);
    },
    /**
     * getCrosshairsLength:
     * Get the crosshairs length.
     * @return: The length of the vertical and horizontal lines making up the
     *          crosshairs.
     */
    getCrosshairsLength: function() {
        if (this._crossHairs)
            return this._crossHairs.getLength();
        else
            return 0;
    },
    /**
     * setCrosshairsClip:
     * Set whether the crosshairs are clipped at their intersection.
     * @clip:   Flag to indicate whether to clip the crosshairs.
     */
    setCrosshairsClip: function(clip) {
        if (clip) {
            if (this._crossHairs)
                this._crossHairs.setClip(CROSSHAIRS_CLIP_SIZE);
        }
        else {
            // Setting no clipping on crosshairs means a zero sized clip
            // rectangle.
            if (this._crossHairs)
                this._crossHairs.setClip([0, 0]);
        }
    },
    /**
     * getCrosshairsClip:
     * Get whether the crosshairs are clipped by the mouse image.
     * @return:   Whether the crosshairs are clipped.
     */
     getCrosshairsClip: function() {
        if (this._crossHairs) {
            let [clipWidth, clipHeight] = this._crossHairs.getClip();
            return (clipWidth > 0 && clipHeight > 0);
        }
        else
            return false;
     },
    //// Private methods ////
    _updateMouseSprite: function() {
        Shell.util_cursor_tracker_to_clutter(this._cursorTracker, this._mouseSprite);
        let [xHot, yHot] = this._cursorTracker.get_hot();
        this._mouseSprite.set_anchor_point(xHot, yHot);
    },
    _settingsInit: function(zoomRegion) {
        this._appSettings = new Gio.Settings({ schema_id: APPLICATIONS_SCHEMA });
        this._settings = new Gio.Settings({ schema_id: MAGNIFIER_SCHEMA });
        this._appSettings.connect('changed::' + SHOW_KEY,
                                  Lang.bind(this, function() {
            this.setActive(this._appSettings.get_boolean(SHOW_KEY));
        }));
        this._settings.connect('changed::' + SCREEN_POSITION_KEY,
                               Lang.bind(this, this._updateScreenPosition));
        this._settings.connect('changed::' + MAG_FACTOR_KEY,
                               Lang.bind(this, this._updateMagFactor));
        this._settings.connect('changed::' + LENS_MODE_KEY,
                               Lang.bind(this, this._updateLensMode));
        this._settings.connect('changed::' + CLAMP_MODE_KEY,
                               Lang.bind(this, this._updateClampMode));
        this._settings.connect('changed::' + MOUSE_TRACKING_KEY,
                               Lang.bind(this, this._updateMouseTrackingMode));
        this._settings.connect('changed::' + FOCUS_TRACKING_KEY,
                               Lang.bind(this, this._updateFocusTrackingMode));
        this._settings.connect('changed::' + CARET_TRACKING_KEY,
                               Lang.bind(this, this._updateCaretTrackingMode));
        this._settings.connect('changed::' + INVERT_LIGHTNESS_KEY,
                               Lang.bind(this, this._updateInvertLightness));
        this._settings.connect('changed::' + COLOR_SATURATION_KEY,
                               Lang.bind(this, this._updateColorSaturation));
        this._settings.connect('changed::' + BRIGHT_RED_KEY,
                               Lang.bind(this, this._updateBrightness));
        this._settings.connect('changed::' + BRIGHT_GREEN_KEY,
                               Lang.bind(this, this._updateBrightness));
        this._settings.connect('changed::' + BRIGHT_BLUE_KEY,
                               Lang.bind(this, this._updateBrightness));
        this._settings.connect('changed::' + CONTRAST_RED_KEY,
                               Lang.bind(this, this._updateContrast));
        this._settings.connect('changed::' + CONTRAST_GREEN_KEY,
                               Lang.bind(this, this._updateContrast));
        this._settings.connect('changed::' + CONTRAST_BLUE_KEY,
                               Lang.bind(this, this._updateContrast));
        this._settings.connect('changed::' + SHOW_CROSS_HAIRS_KEY,
                               Lang.bind(this, function() {
            this.setCrosshairsVisible(this._settings.get_boolean(SHOW_CROSS_HAIRS_KEY));
        }));
        this._settings.connect('changed::' + CROSS_HAIRS_THICKNESS_KEY,
                               Lang.bind(this, function() {
            this.setCrosshairsThickness(this._settings.get_int(CROSS_HAIRS_THICKNESS_KEY));
        }));
        this._settings.connect('changed::' + CROSS_HAIRS_COLOR_KEY,
                               Lang.bind(this, function() {
            this.setCrosshairsColor(this._settings.get_string(CROSS_HAIRS_COLOR_KEY));
        }));
        this._settings.connect('changed::' + CROSS_HAIRS_OPACITY_KEY,
                               Lang.bind(this, function() {
            this.setCrosshairsOpacity(this._settings.get_double(CROSS_HAIRS_OPACITY_KEY));
        }));
        this._settings.connect('changed::' + CROSS_HAIRS_LENGTH_KEY,
                               Lang.bind(this, function() {
            this.setCrosshairsLength(this._settings.get_int(CROSS_HAIRS_LENGTH_KEY));
        }));
        this._settings.connect('changed::' + CROSS_HAIRS_CLIP_KEY,
                               Lang.bind(this, function() {
            this.setCrosshairsClip(this._settings.get_boolean(CROSS_HAIRS_CLIP_KEY));
        }));
        if (zoomRegion) {
            // Mag factor is accurate to two decimal places.
            let aPref = parseFloat(this._settings.get_double(MAG_FACTOR_KEY).toFixed(2));
            if (aPref != 0.0)
                zoomRegion.setMagFactor(aPref, aPref);
            aPref = this._settings.get_enum(SCREEN_POSITION_KEY);
            if (aPref)
                zoomRegion.setScreenPosition(aPref);
            zoomRegion.setLensMode(this._settings.get_boolean(LENS_MODE_KEY));
            zoomRegion.setClampScrollingAtEdges(!this._settings.get_boolean(CLAMP_MODE_KEY));
            aPref = this._settings.get_enum(MOUSE_TRACKING_KEY);
            if (aPref)
                zoomRegion.setMouseTrackingMode(aPref);
            aPref = this._settings.get_enum(FOCUS_TRACKING_KEY);
            if (aPref)
                zoomRegion.setFocusTrackingMode(aPref);
            aPref = this._settings.get_enum(CARET_TRACKING_KEY);
            if (aPref)
                zoomRegion.setCaretTrackingMode(aPref);
            aPref = this._settings.get_boolean(INVERT_LIGHTNESS_KEY);
            if (aPref)
                zoomRegion.setInvertLightness(aPref);
            aPref = this._settings.get_double(COLOR_SATURATION_KEY);
            if (aPref)
                zoomRegion.setColorSaturation(aPref);
            let bc = {};
            bc.r = this._settings.get_double(BRIGHT_RED_KEY);
            bc.g = this._settings.get_double(BRIGHT_GREEN_KEY);
            bc.b = this._settings.get_double(BRIGHT_BLUE_KEY);
            zoomRegion.setBrightness(bc);
            bc.r = this._settings.get_double(CONTRAST_RED_KEY);
            bc.g = this._settings.get_double(CONTRAST_GREEN_KEY);
            bc.b = this._settings.get_double(CONTRAST_BLUE_KEY);
            zoomRegion.setContrast(bc);
        }
        let showCrosshairs = this._settings.get_boolean(SHOW_CROSS_HAIRS_KEY);
        this.addCrosshairs();
        this.setCrosshairsVisible(showCrosshairs);
        return this._appSettings.get_boolean(SHOW_KEY);
   },
    _updateScreenPosition: function() {
        // Applies only to the first zoom region.
        if (this._zoomRegions.length) {
            let position = this._settings.get_enum(SCREEN_POSITION_KEY);
            this._zoomRegions[0].setScreenPosition(position);
            if (position != GDesktopEnums.MagnifierScreenPosition.FULL_SCREEN)
                this._updateLensMode();
        }
    },
    _updateMagFactor: function() {
        // Applies only to the first zoom region.
        if (this._zoomRegions.length) {
            // Mag factor is accurate to two decimal places.
            let magFactor = parseFloat(this._settings.get_double(MAG_FACTOR_KEY).toFixed(2));
            this._zoomRegions[0].setMagFactor(magFactor, magFactor);
        }
    },
    _updateLensMode: function() {
        // Applies only to the first zoom region.
        if (this._zoomRegions.length) {
            this._zoomRegions[0].setLensMode(this._settings.get_boolean(LENS_MODE_KEY));
        }
    },
    _updateClampMode: function() {
        // Applies only to the first zoom region.
        if (this._zoomRegions.length) {
            this._zoomRegions[0].setClampScrollingAtEdges(
                !this._settings.get_boolean(CLAMP_MODE_KEY)
            );
        }
    },
    _updateMouseTrackingMode: function() {
        // Applies only to the first zoom region.
        if (this._zoomRegions.length) {
            this._zoomRegions[0].setMouseTrackingMode(
                this._settings.get_enum(MOUSE_TRACKING_KEY)
            );
        }
    },
    _updateFocusTrackingMode: function() {
        // Applies only to the first zoom region.
        if (this._zoomRegions.length) {
            this._zoomRegions[0].setFocusTrackingMode(
                this._settings.get_enum(FOCUS_TRACKING_KEY)
            );
        }
    },
    _updateCaretTrackingMode: function() {
        // Applies only to the first zoom region.
        if (this._zoomRegions.length) {
            this._zoomRegions[0].setCaretTrackingMode(
                this._settings.get_enum(CARET_TRACKING_KEY)
            );
        }
    },
    _updateInvertLightness: function() {
        // Applies only to the first zoom region.
        if (this._zoomRegions.length) {
            this._zoomRegions[0].setInvertLightness(
                this._settings.get_boolean(INVERT_LIGHTNESS_KEY)
            );
        }
    },
    _updateColorSaturation: function() {
        // Applies only to the first zoom region.
        if (this._zoomRegions.length) {
            this._zoomRegions[0].setColorSaturation(
                this._settings.get_double(COLOR_SATURATION_KEY)
            );
        }
    },
    _updateBrightness: function() {
        // Applies only to the first zoom region.
        if (this._zoomRegions.length) {
            let brightness = {};
            brightness.r = this._settings.get_double(BRIGHT_RED_KEY);
            brightness.g = this._settings.get_double(BRIGHT_GREEN_KEY);
            brightness.b = this._settings.get_double(BRIGHT_BLUE_KEY);
            this._zoomRegions[0].setBrightness(brightness);
        }
    },
    _updateContrast: function() {
        // Applies only to the first zoom region.
        if (this._zoomRegions.length) {
            let contrast = {};
            contrast.r = this._settings.get_double(CONTRAST_RED_KEY);
            contrast.g = this._settings.get_double(CONTRAST_GREEN_KEY);
            contrast.b = this._settings.get_double(CONTRAST_BLUE_KEY);
            this._zoomRegions[0].setContrast(contrast);
        }
    }
Signals.addSignalMethods(Magnifier.prototype);
const ZoomRegion = new Lang.Class({
    Name: 'ZoomRegion',
    _init: function(magnifier, mouseSourceActor) {
        this._magnifier = magnifier;
        this._focusCaretTracker = new FocusCaretTracker.FocusCaretTracker();
        this._mouseTrackingMode = GDesktopEnums.MagnifierMouseTrackingMode.NONE;
        this._focusTrackingMode = GDesktopEnums.MagnifierFocusTrackingMode.NONE;
        this._caretTrackingMode = GDesktopEnums.MagnifierCaretTrackingMode.NONE;
        this._clampScrollingAtEdges = false;
        this._lensMode = false;
        this._screenPosition = GDesktopEnums.MagnifierScreenPosition.FULL_SCREEN;
        this._invertLightness = false;
        this._colorSaturation = 1.0;
        this._brightness = { r: NO_CHANGE, g: NO_CHANGE, b: NO_CHANGE };
        this._contrast = { r: NO_CHANGE, g: NO_CHANGE, b: NO_CHANGE };
        this._magView = null;
        this._background = null;
        this._uiGroupClone = null;
        this._mouseSourceActor = mouseSourceActor;
        this._mouseActor  = null;
        this._crossHairs = null;
        this._crossHairsActor = null;
        this._viewPortX = 0;
        this._viewPortY = 0;
        this._viewPortWidth = global.screen_width;
        this._viewPortHeight = global.screen_height;
        this._xCenter = this._viewPortWidth / 2;
        this._yCenter = this._viewPortHeight / 2;
        this._xMagFactor = 1;
        this._yMagFactor = 1;
        this._followingCursor = false;
        this._xFocus = 0;
        this._yFocus = 0;
        this._xCaret = 0;
        this._yCaret = 0;
        this._pointerIdleMonitor = Meta.IdleMonitor.get_for_device(Meta.VIRTUAL_CORE_POINTER_ID);
        this._scrollContentsTimerId = 0;
        Main.layoutManager.connect('monitors-changed',
                                   Lang.bind(this, this._monitorsChanged));
        this._focusCaretTracker.connect('caret-moved',
                                    Lang.bind(this, this._updateCaret));
        this._focusCaretTracker.connect('focus-changed',
                                    Lang.bind(this, this._updateFocus));
    },
    _updateFocus: function(caller, event) {
        let component = event.source.get_component_iface();
        if (!component || event.detail1 != 1)
            return;
        let extents;
        try {
            extents = component.get_extents(Atspi.CoordType.SCREEN);
        } catch(e) {
            log('Failed to read extents of focused component: ' + e.message);
            return;
        }
        [this._xFocus, this._yFocus] = [extents.x + (extents.width / 2),
                                        extents.y + (extents.height / 2)];
        this._centerFromFocusPosition();
    },
    _updateCaret: function(caller, event) {
        let text = event.source.get_text_iface();
        if (!text)
            return;
        let extents;
        try {
            extents = text.get_character_extents(text.get_caret_offset(), 0);
        } catch(e) {
            log('Failed to read extents of text caret: ' + e.message);
            return;
        }
        [this._xCaret, this._yCaret] = [extents.x, extents.y];
        this._centerFromCaretPosition();
    },
    /**
     * setActive:
     * @activate:   Boolean to show/hide the ZoomRegion.
     */
    setActive: function(activate) {
        if (activate == this.isActive())
            return;
        if (activate) {
            this._createActors();
            if (this._isMouseOverRegion())
                this._magnifier.hideSystemCursor();
            this._updateMagViewGeometry();
            this._updateCloneGeometry();
            this._updateMousePosition();
        } else {
            this._destroyActors();
        }
        this._syncCaretTracking();
        this._syncFocusTracking();
    },
    /**
     * isActive:
     * @return  Whether this ZoomRegion is active (boolean).
     */
    isActive: function() {
        return this._magView != null;
    },
    /**
     * setMagFactor:
     * @xMagFactor:     The power to set the horizontal magnification factor to
     *                  of the magnified view.  A value of 1.0 means no
     *                  magnification.  A value of 2.0 doubles the size.
     * @yMagFactor:     The power to set the vertical magnification factor to
     *                  of the magnified view.
     */
    setMagFactor: function(xMagFactor, yMagFactor) {
        this._changeROI({ xMagFactor: xMagFactor,
                          yMagFactor: yMagFactor,
                          redoCursorTracking: this._followingCursor });
    },
    /**
     * getMagFactor:
     * @return  an array, [xMagFactor, yMagFactor], containing the horizontal
     *          and vertical magnification powers.  A value of 1.0 means no
     *          magnification.  A value of 2.0 means the contents are doubled
     *          in size, and so on.
     */
    getMagFactor: function() {
        return [this._xMagFactor, this._yMagFactor];
    },
    /**
     * setMouseTrackingMode
     * @mode:     One of the enum MouseTrackingMode values.
     */
    setMouseTrackingMode: function(mode) {
        if (mode >= GDesktopEnums.MagnifierMouseTrackingMode.NONE &&
            mode <= GDesktopEnums.MagnifierMouseTrackingMode.PUSH)
            this._mouseTrackingMode = mode;
    },
    /**
     * getMouseTrackingMode
     * @return:     One of the enum MouseTrackingMode values.
     */
    getMouseTrackingMode: function() {
        return this._mouseTrackingMode;
    },
    /**
     * setFocusTrackingMode
     * @mode:     One of the enum FocusTrackingMode values.
     */
    setFocusTrackingMode: function(mode) {
        this._focusTrackingMode = mode;
        this._syncFocusTracking();
    },
    /**
     * setCaretTrackingMode
     * @mode:     One of the enum CaretTrackingMode values.
     */
    setCaretTrackingMode: function(mode) {
        this._caretTrackingMode = mode;
        this._syncCaretTracking();
    },
    _syncFocusTracking: function() {
        let enabled = this._focusTrackingMode != GDesktopEnums.MagnifierFocusTrackingMode.NONE &&
            this.isActive();
        if (enabled)
            this._focusCaretTracker.registerFocusListener();
        else
            this._focusCaretTracker.deregisterFocusListener();
    },
    _syncCaretTracking: function() {
        let enabled = this._caretTrackingMode != GDesktopEnums.MagnifierCaretTrackingMode.NONE &&
            this.isActive();
        if (enabled)
            this._focusCaretTracker.registerCaretListener();
        else
            this._focusCaretTracker.deregisterCaretListener();
    },
    /**
     * setViewPort
     * Sets the position and size of the ZoomRegion on screen.
     * @viewPort:   Object defining the position and size of the view port.
     *              It has members x, y, width, height.  The values are in
     *              stage coordinate space.
     */
    setViewPort: function(viewPort) {
        this._setViewPort(viewPort);
        this._screenPosition = GDesktopEnums.MagnifierScreenPosition.NONE;
    },
    /**
     * setROI
     * Sets the "region of interest" that the ZoomRegion is magnifying.
     * @roi:    Object that defines the region of the screen to magnify.  It
     *          has members x, y, width, height.  The values are in
     *          screen (unmagnified) coordinate space.
     */
    setROI: function(roi) {
        if (roi.width <= 0 || roi.height <= 0)
            return;
        this._followingCursor = false;
        this._changeROI({ xMagFactor: this._viewPortWidth / roi.width,
                          yMagFactor: this._viewPortHeight / roi.height,
                          xCenter: roi.x + roi.width  / 2,
                          yCenter: roi.y + roi.height / 2 });
    },
    /**
     * getROI:
     * Retrieves the "region of interest" -- the rectangular bounds of that part
     * of the desktop that the magnified view is showing (x, y, width, height).
     * The bounds are given in non-magnified coordinates.
     * @return  an array, [x, y, width, height], representing the bounding
     *          rectangle of what is shown in the magnified view.
     */
    getROI: function() {
        let roiWidth = this._viewPortWidth / this._xMagFactor;
        let roiHeight = this._viewPortHeight / this._yMagFactor;
        return [this._xCenter - roiWidth / 2,
                this._yCenter - roiHeight / 2,
                roiWidth, roiHeight];
    },
    /**
     * setLensMode:
     * Turn lens mode on/off.  In full screen mode, lens mode does nothing since
     * a lens the size of the screen is pointless.
     * @lensMode:   A boolean to set the sense of lens mode.
     */
    setLensMode: function(lensMode) {
        this._lensMode = lensMode;
        if (!this._lensMode)
            this.setScreenPosition (this._screenPosition);
    },
    /**
     * isLensMode:
     * Is lens mode on or off?
     * @return  The lens mode state as a boolean.
     */
    isLensMode: function() {
        return this._lensMode;
    },
    /**
     * setClampScrollingAtEdges:
     * Stop vs. allow scrolling of the magnified contents when it scroll beyond
     * the edges of the screen.
     * @clamp:   Boolean to turn on/off clamping.
     */
    setClampScrollingAtEdges: function(clamp) {
        this._clampScrollingAtEdges = clamp;
        if (clamp)
            this._changeROI();
    },
    /**
     * setTopHalf:
     * Magnifier view occupies the top half of the screen.
     */
    setTopHalf: function() {
        let viewPort = {};
        viewPort.x = 0;
        viewPort.y = 0;
        viewPort.width = global.screen_width;
        viewPort.height = global.screen_height/2;
        this._setViewPort(viewPort);
        this._screenPosition = GDesktopEnums.MagnifierScreenPosition.TOP_HALF;
    },
    /**
     * setBottomHalf:
     * Magnifier view occupies the bottom half of the screen.
     */
    setBottomHalf: function() {
        let viewPort = {};
        viewPort.x = 0;
        viewPort.y = global.screen_height/2;
        viewPort.width = global.screen_width;
        viewPort.height = global.screen_height/2;
        this._setViewPort(viewPort);
        this._screenPosition = GDesktopEnums.MagnifierScreenPosition.BOTTOM_HALF;
    },
    /**
     * setLeftHalf:
     * Magnifier view occupies the left half of the screen.
     */
    setLeftHalf: function() {
        let viewPort = {};
        viewPort.x = 0;
        viewPort.y = 0;
        viewPort.width = global.screen_width/2;
        viewPort.height = global.screen_height;
        this._setViewPort(viewPort);
        this._screenPosition = GDesktopEnums.MagnifierScreenPosition.LEFT_HALF;
    },
    /**
     * setRightHalf:
     * Magnifier view occupies the right half of the screen.
     */
    setRightHalf: function() {
        let viewPort = {};
        viewPort.x = global.screen_width/2;
        viewPort.y = 0;
        viewPort.width = global.screen_width/2;
        viewPort.height = global.screen_height;
        this._setViewPort(viewPort);
        this._screenPosition = GDesktopEnums.MagnifierScreenPosition.RIGHT_HALF;
    },
    /**
     * setFullScreenMode:
     * Set the ZoomRegion to full-screen mode.
     * Note:  disallows lens mode.
     */
    setFullScreenMode: function() {
        let viewPort = {};
        viewPort.x = 0;
        viewPort.y = 0;
        viewPort.width = global.screen_width;
        viewPort.height = global.screen_height;
        this.setViewPort(viewPort);
        this._screenPosition = GDesktopEnums.MagnifierScreenPosition.FULL_SCREEN;
    },
    /**
     * setScreenPosition:
     * Positions the zoom region to one of the enumerated positions on the
     * screen.
     * @position:   one of Magnifier.FULL_SCREEN, Magnifier.TOP_HALF,
     *              Magnifier.BOTTOM_HALF,Magnifier.LEFT_HALF, or
     *              Magnifier.RIGHT_HALF.
     */
    setScreenPosition: function(inPosition) {
        switch (inPosition) {
            case GDesktopEnums.MagnifierScreenPosition.FULL_SCREEN:
                this.setFullScreenMode();
                break;
            case GDesktopEnums.MagnifierScreenPosition.TOP_HALF:
                this.setTopHalf();
                break;
            case GDesktopEnums.MagnifierScreenPosition.BOTTOM_HALF:
                this.setBottomHalf();
                break;
            case GDesktopEnums.MagnifierScreenPosition.LEFT_HALF:
                this.setLeftHalf();
                break;
            case GDesktopEnums.MagnifierScreenPosition.RIGHT_HALF:
                this.setRightHalf();
                break;
        }
    },
    /**
     * getScreenPosition:
     * Tell the outside world what the current mode is -- magnifiying the
     * top half, bottom half, etc.
     * @return:  the current mode.
     */
    getScreenPosition: function() {
        return this._screenPosition;
    },
    /**
     * scrollToMousePos:
     * Set the region of interest based on the position of the system pointer.
     * @return:     Whether the system mouse pointer is over the magnified view.
     */
    scrollToMousePos: function() {
        this._followingCursor = true;
        if (this._mouseTrackingMode != GDesktopEnums.MagnifierMouseTrackingMode.NONE)
            this._changeROI({ redoCursorTracking: true });
        else
            this._updateMousePosition();
        // Determine whether the system mouse pointer is over this zoom region.
        return this._isMouseOverRegion();
    },
    _clearScrollContentsTimer: function() {
        if (this._scrollContentsTimerId != 0) {
            Mainloop.source_remove(this._scrollContentsTimerId);
            this._scrollContentsTimerId = 0;
        }
    },
    _scrollContentsToDelayed: function(x, y) {
        if (this._pointerIdleMonitor.get_idletime() >= POINTER_REST_TIME) {
            this.scrollContentsTo(x, y);
            return;
        }
        this._clearScrollContentsTimer();
        this._scrollContentsTimerId = Mainloop.timeout_add(POINTER_REST_TIME, Lang.bind(this, function() {
            this._scrollContentsToDelayed(x, y);
            return GLib.SOURCE_REMOVE;
        }));
    },
    /**
     * scrollContentsTo:
     * Shift the contents of the magnified view such it is centered on the given
     * coordinate.
     * @x:      The x-coord of the point to center on.
     * @y:      The y-coord of the point to center on.
     */
    scrollContentsTo: function(x, y) {
        this._clearScrollContentsTimer();
        this._followingCursor = false;
        this._changeROI({ xCenter: x,
                          yCenter: y });
    },
    /**
     * addCrosshairs:
     * Add crosshairs centered on the magnified mouse.
     * @crossHairs: Crosshairs instance
     */
    addCrosshairs: function(crossHairs) {
        this._crossHairs = crossHairs;
        // If the crossHairs is not already within a larger container, add it
        // to this zoom region.  Otherwise, add a clone.
        if (crossHairs && this.isActive()) {
            this._crossHairsActor = crossHairs.addToZoomRegion(this, this._mouseActor);
        }
    },
    /**
     * setInvertLightness:
     * Set whether to invert the lightness of the magnified view.
     * @flag    Boolean to either invert brightness (true), or not (false).
     */
    setInvertLightness: function(flag) {
        this._invertLightness = flag;
        if (this._magShaderEffects)
            this._magShaderEffects.setInvertLightness(this._invertLightness);
    },
    /**
     * getInvertLightness:
     * Retrieve whether the lightness is inverted.
     * @return    Boolean indicating inversion (true), or not (false).
     */
    getInvertLightness: function() {
        return this._invertLightness;
    },
    /**
     * setColorSaturation:
     * Set the color saturation of the magnified view.
     * @sauration  A value from 0.0 to 1.0 that defines the color
     *             saturation, with 0.0 defining no color (grayscale),
     *             and 1.0 defining full color.
     */
    setColorSaturation: function(saturation) {
        this._colorSaturation = saturation;
        if (this._magShaderEffects)
            this._magShaderEffects.setColorSaturation(this._colorSaturation);
    },
    /**
     * getColorSaturation:
     * Retrieve the color saturation of the magnified view.
     */
    getColorSaturation: function() {
        return this._colorSaturation;
    },
    /**
     * setBrightness:
     * Alter the brightness of the magnified view.
     * @brightness  Object containing the contrast for the red, green,
     *              and blue channels.  Values of 0.0 represent "standard"
     *              brightness (no change), whereas values less or greater than
     *              0.0 indicate decreased or incresaed brightness, respectively.
     */
    setBrightness: function(brightness) {
        this._brightness.r = brightness.r;
        this._brightness.g = brightness.g;
        this._brightness.b = brightness.b;
        if (this._magShaderEffects)
            this._magShaderEffects.setBrightness(this._brightness);
    },
    /**
     * setContrast:
     * Alter the contrast of the magnified view.
     * @contrast    Object containing the contrast for the red, green,
     *              and blue channels.  Values of 0.0 represent "standard"
     *              contrast (no change), whereas values less or greater than
     *              0.0 indicate decreased or incresaed contrast, respectively.
     */
    setContrast: function(contrast) {
        this._contrast.r = contrast.r;
        this._contrast.g = contrast.g;
        this._contrast.b = contrast.b;
        if (this._magShaderEffects)
            this._magShaderEffects.setContrast(this._contrast);
    },
    /**
     * getContrast:
     * Retreive the contrast of the magnified view.
     * @return  Object containing the contrast for the red, green,
     *          and blue channels.
     */
    getContrast: function() {
        let contrast = {};
        contrast.r = this._contrast.r;
        contrast.g = this._contrast.g;
        contrast.b = this._contrast.b;
        return contrast;
    },
    //// Private methods ////
    _createActors: function() {
        // The root actor for the zoom region
        this._magView = new St.Bin({ style_class: 'magnifier-zoom-region', x_fill: true, y_fill: true });
        global.stage.add_actor(this._magView);
        // hide the magnified region from CLUTTER_PICK_ALL
        Shell.util_set_hidden_from_pick (this._magView, true);
        // Add a group to clip the contents of the magnified view.
        let mainGroup = new Clutter.Actor({ clip_to_allocation: true });
        this._magView.set_child(mainGroup);
        // Add a background for when the magnified uiGroup is scrolled
        // out of view (don't want to see desktop showing through).
        this._background = (new Background.SystemBackground()).actor;
        mainGroup.add_actor(this._background);
        // Clone the group that contains all of UI on the screen.  This is the
        // chrome, the windows, etc.
        this._uiGroupClone = new Clutter.Clone({ source: Main.uiGroup,
                                                 clip_to_allocation: true });
        mainGroup.add_actor(this._uiGroupClone);
        // Add either the given mouseSourceActor to the ZoomRegion, or a clone of
        // it.
        if (this._mouseSourceActor.get_parent() != null)
            this._mouseActor = new Clutter.Clone({ source: this._mouseSourceActor });
        else
            this._mouseActor = this._mouseSourceActor;
        mainGroup.add_actor(this._mouseActor);
        if (this._crossHairs)
            this._crossHairsActor = this._crossHairs.addToZoomRegion(this, this._mouseActor);
        else
            this._crossHairsActor = null;
        // Contrast and brightness effects.
        this._magShaderEffects = new MagShaderEffects(this._uiGroupClone);
        this._magShaderEffects.setColorSaturation(this._colorSaturation);
        this._magShaderEffects.setInvertLightness(this._invertLightness);
        this._magShaderEffects.setBrightness(this._brightness);
        this._magShaderEffects.setContrast(this._contrast);
    },
    _destroyActors: function() {
        if (this._mouseActor == this._mouseSourceActor)
            this._mouseActor.get_parent().remove_actor (this._mouseActor);
        if (this._crossHairs)
            this._crossHairs.removeFromParent(this._crossHairsActor);
        this._magShaderEffects.destroyEffects();
        this._magShaderEffects = null;
        this._magView.destroy();
        this._magView = null;
        this._background = null;
        this._uiGroupClone = null;
        this._mouseActor = null;
        this._crossHairsActor = null;
    },
    _setViewPort: function(viewPort, fromROIUpdate) {
        // Sets the position of the zoom region on the screen
        let width = Math.round(Math.min(viewPort.width, global.screen_width));
        let height = Math.round(Math.min(viewPort.height, global.screen_height));
        let x = Math.max(viewPort.x, 0);
        let y = Math.max(viewPort.y, 0);
        x = Math.round(Math.min(x, global.screen_width - width));
        y = Math.round(Math.min(y, global.screen_height - height));
        this._viewPortX = x;
        this._viewPortY = y;
        this._viewPortWidth = width;
        this._viewPortHeight = height;
        this._updateMagViewGeometry();
        if (!fromROIUpdate)
            this._changeROI({ redoCursorTracking: this._followingCursor }); // will update mouse
        if (this.isActive() && this._isMouseOverRegion())
            this._magnifier.hideSystemCursor();
    },
    _changeROI: function(params) {
        // Updates the area we are viewing; the magnification factors
        // and center can be set explicitly, or we can recompute
        // the position based on the mouse cursor position
        params = Params.parse(params, { xMagFactor: this._xMagFactor,
                                        yMagFactor: this._yMagFactor,
                                        xCenter: this._xCenter,
                                        yCenter: this._yCenter,
                                        redoCursorTracking: false });
        if (params.xMagFactor <= 0)
            params.xMagFactor = this._xMagFactor;
        if (params.yMagFactor <= 0)
            params.yMagFactor = this._yMagFactor;
        this._xMagFactor = params.xMagFactor;
        this._yMagFactor = params.yMagFactor;
        if (params.redoCursorTracking &&
            this._mouseTrackingMode != GDesktopEnums.MagnifierMouseTrackingMode.NONE) {
            // This depends on this.xMagFactor/yMagFactor already being updated
            [params.xCenter, params.yCenter] = this._centerFromMousePosition();
        }
        if (this._clampScrollingAtEdges) {
            let roiWidth = this._viewPortWidth / this._xMagFactor;
            let roiHeight = this._viewPortHeight / this._yMagFactor;
            params.xCenter = Math.min(params.xCenter, global.screen_width - roiWidth / 2);
            params.xCenter = Math.max(params.xCenter, roiWidth / 2);
            params.yCenter = Math.min(params.yCenter, global.screen_height - roiHeight / 2);
            params.yCenter = Math.max(params.yCenter, roiHeight / 2);
        }
        this._xCenter = params.xCenter;
        this._yCenter = params.yCenter;
        // If in lens mode, move the magnified view such that it is centered
        // over the actual mouse. However, in full screen mode, the "lens" is
        // the size of the screen -- pointless to move such a large lens around.
        if (this._lensMode && !this._isFullScreen())
            this._setViewPort({ x: this._xCenter - this._viewPortWidth / 2,
                                y: this._yCenter - this._viewPortHeight / 2,
                                width: this._viewPortWidth,
                                height: this._viewPortHeight }, true);
        this._updateCloneGeometry();
        this._updateMousePosition();
    },
    _isMouseOverRegion: function() {
        // Return whether the system mouse sprite is over this ZoomRegion.  If the
        // mouse's position is not given, then it is fetched.
        let mouseIsOver = false;
        if (this.isActive()) {
            let xMouse = this._magnifier.xMouse;
            let yMouse = this._magnifier.yMouse;
            mouseIsOver = (
                xMouse >= this._viewPortX && xMouse < (this._viewPortX + this._viewPortWidth) &&
                yMouse >= this._viewPortY && yMouse < (this._viewPortY + this._viewPortHeight)
            );
        }
        return mouseIsOver;
    },
    _isFullScreen: function() {
        // Does the magnified view occupy the whole screen? Note that this
        // doesn't necessarily imply
        // this._screenPosition = GDesktopEnums.MagnifierScreenPosition.FULL_SCREEN;
        if (this._viewPortX != 0 || this._viewPortY != 0)
            return false;
        if (this._viewPortWidth != global.screen_width ||
            this._viewPortHeight != global.screen_height)
            return false;
        return true;
    },
    _centerFromMousePosition: function() {
        // Determines where the center should be given the current cursor
        // position and mouse tracking mode
        let xMouse = this._magnifier.xMouse;
        let yMouse = this._magnifier.yMouse;
        if (this._mouseTrackingMode == GDesktopEnums.MagnifierMouseTrackingMode.PROPORTIONAL) {
            return this._centerFromPointProportional(xMouse, yMouse);
        }
        else if (this._mouseTrackingMode == GDesktopEnums.MagnifierMouseTrackingMode.PUSH) {
            return this._centerFromPointPush(xMouse, yMouse);
        }
        else if (this._mouseTrackingMode == GDesktopEnums.MagnifierMouseTrackingMode.CENTERED) {
            return this._centerFromPointCentered(xMouse, yMouse);
        }
        return null; // Should never be hit
    },
    _centerFromCaretPosition: function() {
        let xCaret = this._xCaret;
        let yCaret = this._yCaret;
        if (this._caretTrackingMode == GDesktopEnums.MagnifierCaretTrackingMode.PROPORTIONAL)
            [xCaret, yCaret] = this._centerFromPointProportional(xCaret, yCaret);
        else if (this._caretTrackingMode == GDesktopEnums.MagnifierCaretTrackingMode.PUSH)
            [xCaret, yCaret] = this._centerFromPointPush(xCaret, yCaret);
        else if (this._caretTrackingMode == GDesktopEnums.MagnifierCaretTrackingMode.CENTERED)
            [xCaret, yCaret] = this._centerFromPointCentered(xCaret, yCaret);
        this._scrollContentsToDelayed(xCaret, yCaret);
    },
    _centerFromFocusPosition: function() {
        let xFocus = this._xFocus;
        let yFocus = this._yFocus;
        if (this._focusTrackingMode == GDesktopEnums.MagnifierFocusTrackingMode.PROPORTIONAL)
            [xFocus, yFocus] = this._centerFromPointProportional(xFocus, yFocus);
        else if (this._focusTrackingMode == GDesktopEnums.MagnifierFocusTrackingMode.PUSH)
            [xFocus, yFocus] = this._centerFromPointPush(xFocus, yFocus);
        else if (this._focusTrackingMode == GDesktopEnums.MagnifierFocusTrackingMode.CENTERED)
            [xFocus, yFocus] = this._centerFromPointCentered(xFocus, yFocus);
        this._scrollContentsToDelayed(xFocus, yFocus);
    },
    _centerFromPointPush: function(xPoint, yPoint) {
        let [xRoi, yRoi, widthRoi, heightRoi] = this.getROI();
        let [cursorWidth, cursorHeight] = this._mouseSourceActor.get_size();
        let xPos = xRoi + widthRoi / 2;
        let yPos = yRoi + heightRoi / 2;
        let xRoiRight = xRoi + widthRoi - cursorWidth;
        let yRoiBottom = yRoi + heightRoi - cursorHeight;
        if (xPoint < xRoi)
            xPos -= (xRoi - xPoint);
        else if (xPoint > xRoiRight)
            xPos += (xPoint - xRoiRight);
        if (yPoint < yRoi)
            yPos -= (yRoi - yPoint);
        else if (yPoint > yRoiBottom)
            yPos += (yPoint - yRoiBottom);
        return [xPos, yPos];
    },
    _centerFromPointProportional: function(xPoint, yPoint) {
        let [xRoi, yRoi, widthRoi, heightRoi] = this.getROI();
        let halfScreenWidth = global.screen_width / 2;
        let halfScreenHeight = global.screen_height / 2;
        // We want to pad with a constant distance after zooming, so divide
        // by the magnification factor.
        let unscaledPadding = Math.min(this._viewPortWidth, this._viewPortHeight) / 5;
        let xPadding = unscaledPadding / this._xMagFactor;
        let yPadding = unscaledPadding / this._yMagFactor;
        let xProportion = (xPoint - halfScreenWidth) / halfScreenWidth;   // -1 ... 1
        let yProportion = (yPoint - halfScreenHeight) / halfScreenHeight; // -1 ... 1
        let xPos = xPoint - xProportion * (widthRoi / 2 - xPadding);
        let yPos = yPoint - yProportion * (heightRoi /2 - yPadding);
        return [xPos, yPos];
    },
    _centerFromPointCentered: function(xPoint, yPoint) {
        return [xPoint, yPoint];
    },
    _screenToViewPort: function(screenX, screenY) {
        // Converts coordinates relative to the (unmagnified) screen to coordinates
        // relative to the origin of this._magView
        return [this._viewPortWidth / 2 + (screenX - this._xCenter) * this._xMagFactor,
                this._viewPortHeight / 2 + (screenY - this._yCenter) * this._yMagFactor];
    },
    _updateMagViewGeometry: function() {
        if (!this.isActive())
            return;
        if (this._isFullScreen())
            this._magView.add_style_class_name('full-screen');
        else
            this._magView.remove_style_class_name('full-screen');
        this._magView.set_size(this._viewPortWidth, this._viewPortHeight);
        this._magView.set_position(this._viewPortX, this._viewPortY);
    },
    _updateCloneGeometry: function() {
        if (!this.isActive())
            return;
        this._uiGroupClone.set_scale(this._xMagFactor, this._yMagFactor);
        this._mouseActor.set_scale(this._xMagFactor, this._yMagFactor);
        let [x, y] = this._screenToViewPort(0, 0);
        this._uiGroupClone.set_position(Math.round(x), Math.round(y));
        this._updateMousePosition();
    },
    _updateMousePosition: function() {
        if (!this.isActive())
            return;
        let [xMagMouse, yMagMouse] = this._screenToViewPort(this._magnifier.xMouse,
                                                            this._magnifier.yMouse);
        xMagMouse = Math.round(xMagMouse);
        yMagMouse = Math.round(yMagMouse);
        this._mouseActor.set_position(xMagMouse, yMagMouse);
        if (this._crossHairsActor) {
            let [groupWidth, groupHeight] = this._crossHairsActor.get_size();
            this._crossHairsActor.set_position(xMagMouse - groupWidth / 2,
                                               yMagMouse - groupHeight / 2);
        }
    },
    _monitorsChanged: function() {
        if (!this.isActive())
            return;
        this._background.set_size(global.screen_width, global.screen_height);
        if (this._screenPosition == GDesktopEnums.MagnifierScreenPosition.NONE)
            this._setViewPort({ x: this._viewPortX,
                                y: this._viewPortY,
                                width: this._viewPortWidth,
                                height: this._viewPortHeight });
        else
            this.setScreenPosition(this._screenPosition);
    }
const Crosshairs = new Lang.Class({
    Name: 'Crosshairs',
    _init: function() {
        // Set the group containing the crosshairs to three times the desktop
        // size in case the crosshairs need to appear to be infinite in
        // length (i.e., extend beyond the edges of the view they appear in).
        let groupWidth = global.screen_width * 3;
        let groupHeight = global.screen_height * 3;
        this._actor = new Clutter.Actor({
            clip_to_allocation: false,
            width: groupWidth,
            height: groupHeight
        });
        this._horizLeftHair = new Clutter.Actor();
        this._horizRightHair = new Clutter.Actor();
        this._vertTopHair = new Clutter.Actor();
        this._vertBottomHair = new Clutter.Actor();
        this._actor.add_actor(this._horizLeftHair);
        this._actor.add_actor(this._horizRightHair);
        this._actor.add_actor(this._vertTopHair);
        this._actor.add_actor(this._vertBottomHair);
        this._clipSize = [0, 0];
        this._clones = [];
        this.reCenter();
        Main.layoutManager.connect('monitors-changed',
                                   Lang.bind(this, this._monitorsChanged));
    },
    _monitorsChanged: function() {
        this._actor.set_size(global.screen_width * 3, global.screen_height * 3);
        this.reCenter();
    },
   /**
    * addToZoomRegion
    * Either add the crosshairs actor to the given ZoomRegion, or, if it is
    * already part of some other ZoomRegion, create a clone of the crosshairs
    * actor, and add the clone instead.  Returns either the original or the
    * clone.
    * @zoomRegion:      The container to add the crosshairs group to.
    * @magnifiedMouse:  The mouse actor for the zoom region -- used to
    *                   position the crosshairs and properly layer them below
    *                   the mouse.
    * @return           The crosshairs actor, or its clone.
    */
    addToZoomRegion: function(zoomRegion, magnifiedMouse) {
        let crosshairsActor = null;
        if (zoomRegion && magnifiedMouse) {
            let container = magnifiedMouse.get_parent();
            if (container) {
                crosshairsActor = this._actor;
                if (this._actor.get_parent() != null) {
                    crosshairsActor = new Clutter.Clone({ source: this._actor });
                    this._clones.push(crosshairsActor);
                }
                crosshairsActor.visible = this._actor.visible;
                container.add_actor(crosshairsActor);
                container.raise_child(magnifiedMouse, crosshairsActor);
                let [xMouse, yMouse] = magnifiedMouse.get_position();
                let [crosshairsWidth, crosshairsHeight] = crosshairsActor.get_size();
                crosshairsActor.set_position(xMouse - crosshairsWidth / 2 , yMouse - crosshairsHeight / 2);
            }
        }
        return crosshairsActor;
    },
    /**
     * removeFromParent:
     * @childActor: the actor returned from addToZoomRegion
     * Remove the crosshairs actor from its parent container, or destroy the
     * child actor if it was just a clone of the crosshairs actor.
     */
    removeFromParent: function(childActor) {
        if (childActor == this._actor)
            childActor.get_parent().remove_actor(childActor);
        else
            childActor.destroy();
    },
    /**
     * setColor:
     * Set the color of the crosshairs.
     * @clutterColor:   The color as a Clutter.Color.
     */
    setColor: function(clutterColor) {
        this._horizLeftHair.background_color = clutterColor;
        this._horizRightHair.background_color = clutterColor;
        this._vertTopHair.background_color = clutterColor;
        this._vertBottomHair.background_color = clutterColor;
    },
    /**
     * getColor:
     * Get the color of the crosshairs.
     * @color:  The color as a Clutter.Color.
     */
    getColor: function() {
        return this._horizLeftHair.get_color();
    },
    /**
     * setThickness:
     * Set the width of the vertical and horizontal lines of the crosshairs.
     * @thickness
     */
    setThickness: function(thickness) {
        this._horizLeftHair.set_height(thickness);
        this._horizRightHair.set_height(thickness);
        this._vertTopHair.set_width(thickness);
        this._vertBottomHair.set_width(thickness);
        this.reCenter();
    },
    /**
     * getThickness:
     * Get the width of the vertical and horizontal lines of the crosshairs.
     * @return:     The thickness of the crosshairs.
     */
    getThickness: function() {
        return this._horizLeftHair.get_height();
    },
    /**
     * setOpacity:
     * Set how opaque the crosshairs are.
     * @opacity:    Value between 0 (fully transparent) and 255 (full opaque).
     */
    setOpacity: function(opacity) {
        // set_opacity() throws an exception for values outside the range
        // [0, 255].
        if (opacity < 0)
            opacity = 0;
        else if (opacity > 255)
            opacity = 255;
        this._horizLeftHair.set_opacity(opacity);
        this._horizRightHair.set_opacity(opacity);
        this._vertTopHair.set_opacity(opacity);
        this._vertBottomHair.set_opacity(opacity);
    },
    /**
     * setLength:
     * Set the length of the vertical and horizontal lines in the crosshairs.
     * @length: The length of the crosshairs.
     */
    setLength: function(length) {
        this._horizLeftHair.set_width(length);
        this._horizRightHair.set_width(length);
        this._vertTopHair.set_height(length);
        this._vertBottomHair.set_height(length);
        this.reCenter();
    },
    /**
     * getLength:
     * Get the length of the vertical and horizontal lines in the crosshairs.
     * @return: The length of the crosshairs.
     */
    getLength: function() {
        return this._horizLeftHair.get_width();
    },
    /**
     * setClip:
     * Set the width and height of the rectangle that clips the crosshairs at
     * their intersection
     * @size:   Array of [width, height] defining the size of the clip
     *          rectangle.
     */
    setClip: function(size) {
        if (size) {
            // Take a chunk out of the crosshairs where it intersects the
            // mouse.
            this._clipSize = size;
            this.reCenter();
        }
        else {
            // Restore the missing chunk.
            this._clipSize = [0, 0];
            this.reCenter();
        }
     },
    /**
     * show:
     * Show the crosshairs.
     */
    show: function() {
        this._actor.show();
        // Clones don't share visibility.
        for (let i = 0; i < this._clones.length; i++)
            this._clones[i].show();
    },
    /**
     * hide:
     * Hide the crosshairs.
     */
    hide: function() {
        this._actor.hide();
        // Clones don't share visibility.
        for (let i = 0; i < this._clones.length; i++)
            this._clones[i].hide();
    },
    /**
     * reCenter:
     * Reposition the horizontal and vertical hairs such that they cross at
     * the center of crosshairs group.  If called with the dimensions of
     * the clip rectangle, these are used to update the size of the clip.
     * @clipSize:  Optional.  If present, an array of the form [width, height].
     */
    reCenter: function(clipSize) {
        let [groupWidth, groupHeight] = this._actor.get_size();
        let leftLength = this._horizLeftHair.get_width();
        let rightLength = this._horizRightHair.get_width();
        let topLength = this._vertTopHair.get_height();
        let bottomLength = this._vertBottomHair.get_height();
        let thickness = this._horizLeftHair.get_height();
        // Deal with clip rectangle.
        if (clipSize)
            this._clipSize = clipSize;
        let clipWidth = this._clipSize[0];
        let clipHeight = this._clipSize[1];
        // Note that clip, if present, is not centred on the cross hair
        // intersection, but biased towards the top left.
        let left = groupWidth / 2 - clipWidth * 0.25 - leftLength;
        let right = groupWidth / 2 + clipWidth * 0.75;
        let top = groupHeight / 2 - clipHeight * 0.25 - topLength - thickness / 2;
        let bottom = groupHeight / 2 + clipHeight * 0.75 + thickness / 2;
        this._horizLeftHair.set_position(left, (groupHeight - thickness) / 2);
        this._horizRightHair.set_position(right, (groupHeight - thickness) / 2);
        this._vertTopHair.set_position((groupWidth - thickness) / 2, top);
        this._vertBottomHair.set_position((groupWidth - thickness) / 2, bottom);
    }
const MagShaderEffects = new Lang.Class({
    Name: 'MagShaderEffects',
    _init: function(uiGroupClone) {
        this._inverse = new Shell.InvertLightnessEffect();
        this._brightnessContrast = new Clutter.BrightnessContrastEffect();
        this._colorDesaturation = new Clutter.DesaturateEffect();
        this._inverse.set_enabled(false);
        this._brightnessContrast.set_enabled(false);
        this._magView = uiGroupClone;
        this._magView.add_effect(this._inverse);
        this._magView.add_effect(this._brightnessContrast);
        this._magView.add_effect(this._colorDesaturation);
    },
    /**
     * destroyEffects:
     * Remove contrast and brightness effects from the magnified view, and
     * lose the reference to the actor they were applied to.  Don't use this
     * object after calling this.
     */
    destroyEffects: function() {
        this._magView.clear_effects();
        this._colorDesaturation = null;
        this._brightnessContrast = null;
        this._inverse = null;
        this._magView = null;
    },
    /**
     * setInvertLightness:
     * Enable/disable invert lightness effect.
     * @invertFlag:     Enabled flag.
     */
    setInvertLightness: function(invertFlag) {
        this._inverse.set_enabled(invertFlag);
    },
    setColorSaturation: function(factor) {
        this._colorDesaturation.set_factor(1.0 - factor);
    },
    /**
     * setBrightness:
     * Set the brightness of the magnified view.
     * @brightness: Object containing the brightness for the red, green,
     *              and blue channels.  Values of 0.0 represent "standard"
     *              brightness (no change), whereas values less or greater than
     *              0.0 indicate decreased or incresaed brightness,
     *              respectively.
     */
    setBrightness: function(brightness) {
        let bRed = brightness.r;
        let bGreen = brightness.g;
        let bBlue = brightness.b;
        this._brightnessContrast.set_brightness_full(bRed, bGreen, bBlue);
        // Enable the effect if the brightness OR contrast change are such that
        // it modifies the brightness and/or contrast.
        let [cRed, cGreen, cBlue] = this._brightnessContrast.get_contrast();
        this._brightnessContrast.set_enabled(
            (bRed != NO_CHANGE || bGreen != NO_CHANGE || bBlue != NO_CHANGE ||
             cRed != NO_CHANGE || cGreen != NO_CHANGE || cBlue != NO_CHANGE)
        );
    },
    /**
     * Set the contrast of the magnified view.
     * @contrast:   Object containing the contrast for the red, green,
     *              and blue channels.  Values of 0.0 represent "standard"
     *              contrast (no change), whereas values less or greater than
     *              0.0 indicate decreased or incresaed contrast, respectively.
     */
    setContrast: function(contrast) {
        let cRed = contrast.r;
        let cGreen = contrast.g;
        let cBlue = contrast.b;
        this._brightnessContrast.set_contrast_full(cRed, cGreen, cBlue);
        // Enable the effect if the contrast OR brightness change are such that
        // it modifies the brightness and/or contrast.
        // should be able to use Clutter.color_equal(), but that complains of
        // a null first argument.
        let [bRed, bGreen, bBlue] = this._brightnessContrast.get_brightness();
        this._brightnessContrast.set_enabled(
             cRed != NO_CHANGE || cGreen != NO_CHANGE || cBlue != NO_CHANGE ||
             bRed != NO_CHANGE || bGreen != NO_CHANGE || bBlue != NO_CHANGE
        );
    },
(uuay)magnifierDBus.js
// -*- mode: js; js-indent-level: 4; indent-tabs-mode: nil -*-
const Gio = imports.gi.Gio;
const Lang = imports.lang;
const Main = imports.ui.main;
const MAG_SERVICE_PATH = '/org/gnome/Magnifier';
const ZOOM_SERVICE_PATH = '/org/gnome/Magnifier/ZoomRegion';
// Subset of gnome-mag's Magnifier dbus interface -- to be expanded.  See:
// http://git.gnome.org/browse/gnome-mag/tree/xml/...Magnifier.xml
const MagnifierIface = '<node> \
<interface name="org.gnome.Magnifier"> \
<method name="setActive"> \
    <arg type="b" direction="in" /> \
</method> \
<method name="isActive"> \
    <arg type="b" direction="out" /> \
</method> \
<method name="showCursor" /> \
<method name="hideCursor" /> \
<method name="createZoomRegion"> \
    <arg type="d" direction="in" /> \
    <arg type="d" direction="in" /> \
    <arg type="ai" direction="in" /> \
    <arg type="ai" direction="in" /> \
    <arg type="o" direction="out" /> \
</method> \
<method name="addZoomRegion"> \
    <arg type="o" direction="in" /> \
    <arg type="b" direction="out" /> \
</method> \
<method name="getZoomRegions"> \
    <arg type="ao" direction="out" /> \
</method> \
<method name="clearAllZoomRegions" /> \
<method name="fullScreenCapable"> \
    <arg type="b" direction="out" /> \
</method> \
<method name="setCrosswireSize"> \
    <arg type="i" direction="in" /> \
</method> \
<method name="getCrosswireSize"> \
    <arg type="i" direction="out" /> \
</method> \
<method name="setCrosswireLength"> \
    <arg type="i" direction="in" /> \
</method> \
<method name="getCrosswireLength"> \
    <arg type="i" direction="out" /> \
</method> \
<method name="setCrosswireClip"> \
    <arg type="b" direction="in" /> \
</method> \
<method name="getCrosswireClip"> \
    <arg type="b" direction="out" /> \
</method> \
<method name="setCrosswireColor"> \
    <arg type="u" direction="in" /> \
</method> \
<method name="getCrosswireColor"> \
    <arg type="u" direction="out" /> \
</method> \
</interface> \
</node>';
// Subset of gnome-mag's ZoomRegion dbus interface -- to be expanded.  See:
// http://git.gnome.org/browse/gnome-mag/tree/xml/...ZoomRegion.xml
const ZoomRegionIface = '<node> \
<interface name="org.gnome.Magnifier.ZoomRegion"> \
<method name="setMagFactor"> \
    <arg type="d" direction="in" /> \
    <arg type="d" direction="in" /> \
</method> \
<method name="getMagFactor"> \
    <arg type="d" direction="out" /> \
    <arg type="d" direction="out" /> \
</method> \
<method name="setRoi"> \
    <arg type="ai" direction="in" /> \
</method> \
<method name="getRoi"> \
    <arg type="ai" direction="out" /> \
</method> \
<method name="shiftContentsTo"> \
    <arg type="i" direction="in" /> \
    <arg type="i" direction="in" /> \
    <arg type="b" direction="out" /> \
</method> \
<method name="moveResize"> \
    <arg type="ai" direction="in" /> \
</method> \
</interface> \
</node>';
// For making unique ZoomRegion DBus proxy object paths of the form:
// '/org/gnome/Magnifier/ZoomRegion/zoomer0',
// '/org/gnome/Magnifier/ZoomRegion/zoomer1', etc.
let _zoomRegionInstanceCount = 0;
const ShellMagnifier = new Lang.Class({
    Name: 'ShellMagnifier',
    _init: function() {
        this._zoomers = {};
        this._dbusImpl = Gio.DBusExportedObject.wrapJSObject(MagnifierIface, this);
        this._dbusImpl.export(Gio.DBus.session, MAG_SERVICE_PATH);
    },
    /**
     * setActive:
     * @activate:   Boolean to activate or de-activate the magnifier.
     */
    setActive: function(activate) {
        Main.magnifier.setActive(activate);
    },
    /**
     * isActive:
     * @return  Whether the magnifier is active (boolean).
     */
    isActive: function() {
        return Main.magnifier.isActive();
    },
    /**
     * showCursor:
     * Show the system mouse pointer.
     */
    showCursor: function() {
        Main.magnifier.showSystemCursor();
    },
    /**
     * hideCursor:
     * Hide the system mouse pointer.
     */
    hideCursor: function() {
        Main.magnifier.hideSystemCursor();
    },
    /**
     * createZoomRegion:
     * Create a new ZoomRegion and return its object path.
     * @xMagFactor:     The power to set horizontal magnification of the
     *                  ZoomRegion.  A value of 1.0 means no magnification.  A
     *                  value of 2.0 doubles the size.
     * @yMagFactor:     The power to set the vertical magnification of the
     *                  ZoomRegion.
     * @roi             Array of integers defining the region of the
     *                  screen/desktop to magnify.  The array has the form
     *                  [left, top, right, bottom].
     * @viewPort        Array of integers, [left, top, right, bottom] that defines
     *                  the position of the ZoomRegion on screen.
     *
     * FIXME: The arguments here are redundant, since the width and height of
     *   the ROI are determined by the viewport and magnification factors.
     *   We ignore the passed in width and height.
     *
     * @return          The newly created ZoomRegion.
     */
    createZoomRegion: function(xMagFactor, yMagFactor, roi, viewPort) {
        let ROI = { x: roi[0], y: roi[1], width: roi[2] - roi[0], height: roi[3] - roi[1] };
        let viewBox = { x: viewPort[0], y: viewPort[1], width: viewPort[2] - viewPort[0], height: viewPort[3] - viewPort[1] };
        let realZoomRegion = Main.magnifier.createZoomRegion(xMagFactor, yMagFactor, ROI, viewBox);
        let objectPath = ZOOM_SERVICE_PATH + '/zoomer' + _zoomRegionInstanceCount;
        _zoomRegionInstanceCount++;
        let zoomRegionProxy = new ShellMagnifierZoomRegion(objectPath, realZoomRegion);
        let proxyAndZoomRegion = {};
        proxyAndZoomRegion.proxy = zoomRegionProxy;
        proxyAndZoomRegion.zoomRegion = realZoomRegion;
        this._zoomers[objectPath] = proxyAndZoomRegion;
        return objectPath;
    },
    /**
     * addZoomRegion:
     * Append the given ZoomRegion to the magnifier's list of ZoomRegions.
     * @zoomerObjectPath:   The object path for the zoom region proxy.
     */
    addZoomRegion: function(zoomerObjectPath) {
        let proxyAndZoomRegion = this._zoomers[zoomerObjectPath];
        if (proxyAndZoomRegion && proxyAndZoomRegion.zoomRegion) {
            Main.magnifier.addZoomRegion(proxyAndZoomRegion.zoomRegion);
            return true;
        }
        else
            return false;
    },
    /**
     * getZoomRegions:
     * Return a list of ZoomRegion object paths for this Magnifier.
     * @return:     The Magnifier's zoom region list as an array of DBus object
     *              paths.
     */
    getZoomRegions: function() {
        // There may be more ZoomRegions in the magnifier itself than have
        // been added through dbus.  Make sure all of them are associated with
        // an object path and proxy.
        let zoomRegions = Main.magnifier.getZoomRegions();
        let objectPaths = [];
        let thoseZoomers = this._zoomers;
        zoomRegions.forEach (function(aZoomRegion, index, array) {
            let found = false;
            for (let objectPath in thoseZoomers) {
                let proxyAndZoomRegion = thoseZoomers[objectPath];
                if (proxyAndZoomRegion.zoomRegion === aZoomRegion) {
                    objectPaths.push(objectPath);
                    found = true;
                    break;
                }
            }
            if (!found) {
                // Got a ZoomRegion with no DBus proxy, make one.
                let newPath =  ZOOM_SERVICE_PATH + '/zoomer' + _zoomRegionInstanceCount;
                _zoomRegionInstanceCount++;
                let zoomRegionProxy = new ShellMagnifierZoomRegion(newPath, aZoomRegion);
                let proxyAndZoomer = {};
                proxyAndZoomer.proxy = zoomRegionProxy;
                proxyAndZoomer.zoomRegion = aZoomRegion;
                thoseZoomers[newPath] = proxyAndZoomer;
                objectPaths.push(newPath);
            }
        });
        return objectPaths;
    },
    /**
     * clearAllZoomRegions:
     * Remove all the zoom regions from this Magnfier's ZoomRegion list.
     */
    clearAllZoomRegions: function() {
        Main.magnifier.clearAllZoomRegions();
        for (let objectPath in this._zoomers) {
            let proxyAndZoomer = this._zoomers[objectPath];
            proxyAndZoomer.proxy.destroy();
            proxyAndZoomer.proxy = null;
            proxyAndZoomer.zoomRegion = null;
            delete this._zoomers[objectPath];
        }
        this._zoomers = {};
    },
    /**
     * fullScreenCapable:
     * Consult if the Magnifier can magnify in full-screen mode.
     * @return  Always return true.
     */
    fullScreenCapable: function() {
        return true;
    },
    /**
     * setCrosswireSize:
     * Set the crosswire size of all ZoomRegions.
     * @size:   The thickness of each line in the cross wire.
     */
     setCrosswireSize: function(size) {
        Main.magnifier.setCrosshairsThickness(size);
     },
    /**
     * getCrosswireSize:
     * Get the crosswire size of all ZoomRegions.
     * @return:   The thickness of each line in the cross wire.
     */
     getCrosswireSize: function() {
        return Main.magnifier.getCrosshairsThickness();
     },
    /**
     * setCrosswireLength:
     * Set the crosswire length of all zoom-regions..
     * @size:   The length of each line in the cross wire.
     */
     setCrosswireLength: function(length) {
        Main.magnifier.setCrosshairsLength(length);
     },
    /**
     * setCrosswireSize:
     * Set the crosswire size of all zoom-regions.
     * @size:   The thickness of each line in the cross wire.
     */
     getCrosswireLength: function() {
        return Main.magnifier.getCrosshairsLength();
     },
    /**
     * setCrosswireClip:
     * Set if the crosswire will be clipped by the cursor image..
     * @clip:   Flag to indicate whether to clip the crosswire.
     */
     setCrosswireClip: function(clip) {
        Main.magnifier.setCrosshairsClip(clip);
     },
    /**
     * getCrosswireClip:
     * Get the crosswire clip value.
     * @return:   Whether the crosswire is clipped by the cursor image.
     */
     getCrosswireClip: function() {
        return Main.magnifier.getCrosshairsClip();
     },
    /**
     * setCrosswireColor:
     * Set the crosswire color of all ZoomRegions.
     * @color:   Unsigned int of the form rrggbbaa.
     */
     setCrosswireColor: function(color) {
        Main.magnifier.setCrosshairsColor('#%08x'.format(color));
     },
    /**
     * getCrosswireClip:
     * Get the crosswire color of all ZoomRegions.
     * @return:   The crosswire color as an unsigned int in the form rrggbbaa.
     */
     getCrosswireColor: function() {
        let colorString = Main.magnifier.getCrosshairsColor();
        // Drop the leading '#'.
        return parseInt(colorString.slice(1), 16);
     }
 * ShellMagnifierZoomRegion:
 * Object that implements the DBus ZoomRegion interface.
 * @zoomerObjectPath:   String that is the path to a DBus ZoomRegion.
 * @zoomRegion:         The actual zoom region associated with the object path.
const ShellMagnifierZoomRegion = new Lang.Class({
    Name: 'ShellMagnifierZoomRegion',
    _init: function(zoomerObjectPath, zoomRegion) {
        this._zoomRegion = zoomRegion;
        this._dbusImpl = Gio.DBusExportedObject.wrapJSObject(ZoomRegionIface, this);
        this._dbusImpl.export(Gio.DBus.session, zoomerObjectPath);
    },
    /**
     * setMagFactor:
     * @xMagFactor:     The power to set the horizontal magnification factor to
     *                  of the magnified view.  A value of 1.0 means no
     *                  magnification.  A value of 2.0 doubles the size.
     * @yMagFactor:     The power to set the vertical magnification factor to
     *                  of the magnified view.
     */
    setMagFactor: function(xMagFactor, yMagFactor) {
        this._zoomRegion.setMagFactor(xMagFactor, yMagFactor);
    },
    /**
     * getMagFactor:
     * @return  an array, [xMagFactor, yMagFactor], containing the horizontal
     *          and vertical magnification powers.  A value of 1.0 means no
     *          magnification.  A value of 2.0 means the contents are doubled
     *          in size, and so on.
     */
    getMagFactor: function() {
        return this._zoomRegion.getMagFactor();
    },
    /**
     * setRoi:
     * Sets the "region of interest" that the ZoomRegion is magnifying.
     * @roi     Array, [left, top, right, bottom], defining the region of the
     *          screen to magnify. The values are in screen (unmagnified)
     *          coordinate space.
     */
    setRoi: function(roi) {
        let roiObject = { x: roi[0], y: roi[1], width: roi[2] - roi[0], height: roi[3] - roi[1] };
        this._zoomRegion.setROI(roiObject);
    },
    /**
     * getRoi:
     * Retrieves the "region of interest" -- the rectangular bounds of that part
     * of the desktop that the magnified view is showing (x, y, width, height).
     * The bounds are given in non-magnified coordinates.
     * @return  an array, [left, top, right, bottom], representing the bounding
     *          rectangle of what is shown in the magnified view.
     */
    getRoi: function() {
        let roi = this._zoomRegion.getROI();
        roi[2] += roi[0];
        roi[3] += roi[1];
        return roi;
    },
    /**
     * Set the "region of interest" by centering the given screen coordinate
     * within the zoom region.
     * @x       The x-coord of the point to place at the center of the zoom region.
     * @y       The y-coord.
     * @return  Whether the shift was successful (for GS-mag, this is always
     *          true).
     */
    shiftContentsTo: function(x, y) {
        this._zoomRegion.scrollContentsTo(x, y);
        return true;
    },
    /**
     * moveResize
     * Sets the position and size of the ZoomRegion on screen.
     * @viewPort    Array, [left, top, right, bottom], defining the position and
     *              size on screen to place the zoom region.
     */
    moveResize: function(viewPort) {
        let viewRect = { x: viewPort[0], y: viewPort[1], width: viewPort[2] - viewPort[0], height: viewPort[3] - viewPort[1] };
        this._zoomRegion.setViewPort(viewRect);
    },
    destroy: function() {
        this._dbusImpl.unexport();
    }
(uuay)fileUtils.js
// -*- mode: js; js-indent-level: 4; indent-tabs-mode: nil -*-
const Gio = imports.gi.Gio;
const GLib = imports.gi.GLib;
const Lang = imports.lang;
const Params = imports.misc.params;
function collectFromDatadirs(subdir, includeUserDir, processFile) {
    let dataDirs = GLib.get_system_data_dirs();
    if (includeUserDir)
        dataDirs.unshift(GLib.get_user_data_dir());
    for (let i = 0; i < dataDirs.length; i++) {
        let path = GLib.build_filenamev([dataDirs[i], 'gnome-shell', subdir]);
        let dir = Gio.File.new_for_path(path);
        let fileEnum;
        try {
            fileEnum = dir.enumerate_children('standard::name,standard::type',
                                              Gio.FileQueryInfoFlags.NONE, null);
        } catch (e) {
            fileEnum = null;
        }
        if (fileEnum != null) {
            let info;
            while ((info = fileEnum.next_file(null)))
                processFile(fileEnum.get_child(info), info);
        }
    }
function deleteGFile(file) {
    // Work around 'delete' being a keyword in JS.
    return file['delete'](null);
function recursivelyDeleteDir(dir, deleteParent) {
    let children = dir.enumerate_children('standard::name,standard::type',
                                          Gio.FileQueryInfoFlags.NONE, null);
    let info, child;
    while ((info = children.next_file(null)) != null) {
        let type = info.get_file_type();
        let child = dir.get_child(info.get_name());
        if (type == Gio.FileType.REGULAR)
            deleteGFile(child);
        else if (type == Gio.FileType.DIRECTORY)
            recursivelyDeleteDir(child, true);
    }
    if (deleteParent)
        deleteGFile(dir);
function recursivelyMoveDir(srcDir, destDir) {
    let children = srcDir.enumerate_children('standard::name,standard::type',
                                             Gio.FileQueryInfoFlags.NONE, null);
    if (!destDir.query_exists(null))
        destDir.make_directory_with_parents(null);
    let info, child;
    while ((info = children.next_file(null)) != null) {
        let type = info.get_file_type();
        let srcChild = srcDir.get_child(info.get_name());
        let destChild = destDir.get_child(info.get_name());
        if (type == Gio.FileType.REGULAR)
            srcChild.move(destChild, Gio.FileCopyFlags.NONE, null, null);
        else if (type == Gio.FileType.DIRECTORY)
            recursivelyMoveDir(srcChild, destChild);
    }
(uuay)authPrompt.js
// -*- mode: js; js-indent-level: 4; indent-tabs-mode: nil -*-
const Clutter = imports.gi.Clutter;
const Gio = imports.gi.Gio;
const Lang = imports.lang;
const Signals = imports.signals;
const St = imports.gi.St;
const Animation = imports.ui.animation;
const Batch = imports.gdm.batch;
const GdmUtil = imports.gdm.util;
const Params = imports.misc.params;
const ShellEntry = imports.ui.shellEntry;
const Tweener = imports.ui.tweener;
const UserWidget = imports.ui.userWidget;
const DEFAULT_BUTTON_WELL_ICON_SIZE = 16;
const DEFAULT_BUTTON_WELL_ANIMATION_DELAY = 1.0;
const DEFAULT_BUTTON_WELL_ANIMATION_TIME = 0.3;
const MESSAGE_FADE_OUT_ANIMATION_TIME = 0.5;
const AuthPromptMode = {
    UNLOCK_ONLY: 0,
    UNLOCK_OR_LOG_IN: 1
const AuthPromptStatus = {
    NOT_VERIFYING: 0,
    VERIFYING: 1,
    VERIFICATION_FAILED: 2,
    VERIFICATION_SUCCEEDED: 3
const BeginRequestType = {
    PROVIDE_USERNAME: 0,
    DONT_PROVIDE_USERNAME: 1
const AuthPrompt = new Lang.Class({
    Name: 'AuthPrompt',
    _init: function(gdmClient, mode) {
        this.verificationStatus = AuthPromptStatus.NOT_VERIFYING;
        this._gdmClient = gdmClient;
        this._mode = mode;
        let reauthenticationOnly;
        if (this._mode == AuthPromptMode.UNLOCK_ONLY)
            reauthenticationOnly = true;
        else if (this._mode == AuthPromptMode.UNLOCK_OR_LOG_IN)
            reauthenticationOnly = false;
        this._userVerifier = new GdmUtil.ShellUserVerifier(this._gdmClient, { reauthenticationOnly: reauthenticationOnly });
        this._userVerifier.connect('ask-question', Lang.bind(this, this._onAskQuestion));
        this._userVerifier.connect('show-message', Lang.bind(this, this._onShowMessage));
        this._userVerifier.connect('verification-failed', Lang.bind(this, this._onVerificationFailed));
        this._userVerifier.connect('verification-complete', Lang.bind(this, this._onVerificationComplete));
        this._userVerifier.connect('reset', Lang.bind(this, this._onReset));
        this._userVerifier.connect('smartcard-status-changed', Lang.bind(this, this._onSmartcardStatusChanged));
        this._userVerifier.connect('ovirt-user-authenticated', Lang.bind(this, this._onOVirtUserAuthenticated));
        this.smartcardDetected = this._userVerifier.smartcardDetected;
        this.connect('next', Lang.bind(this, function() {
                         this.updateSensitivity(false);
                         this.startSpinning();
                         if (this._queryingService) {
                             this._userVerifier.answerQuery(this._queryingService, this._entry.text);
                         } else {
                             this._preemptiveAnswer = this._entry.text;
                         }
                     }));
        this.actor = new St.BoxLayout({ style_class: 'login-dialog-prompt-layout',
                                        vertical: true });
        this.actor.connect('destroy', Lang.bind(this, this._onDestroy));
        this.actor.connect('key-press-event',
                           Lang.bind(this, function(actor, event) {
                               if (event.get_key_symbol() == Clutter.KEY_Escape) {
                                   this.cancel();
                               }
                               return Clutter.EVENT_PROPAGATE;
                           }));
        this._userWell = new St.Bin({ x_fill: true,
                                      x_align: St.Align.START });
        this.actor.add(this._userWell,
                       { x_align: St.Align.START,
                         x_fill: true,
                         y_fill: true,
                         expand: true });
        this._label = new St.Label({ style_class: 'login-dialog-prompt-label' });
        this.actor.add(this._label,
                       { expand: true,
                         x_fill: false,
                         y_fill: true,
                         x_align: St.Align.START });
        this._entry = new St.Entry({ style_class: 'login-dialog-prompt-entry',
                                     can_focus: true });
        ShellEntry.addContextMenu(this._entry, { isPassword: true });
        this.actor.add(this._entry,
                       { expand: true,
                         x_fill: true,
                         y_fill: false,
                         x_align: St.Align.START });
        this._entry.grab_key_focus();
        this._message = new St.Label({ opacity: 0,
                                       styleClass: 'login-dialog-message' });
        this._message.clutter_text.line_wrap = true;
        this.actor.add(this._message, { x_fill: false, x_align: St.Align.START, y_align: St.Align.START });
        this._buttonBox = new St.BoxLayout({ style_class: 'login-dialog-button-box',
                                             vertical: false });
        this.actor.add(this._buttonBox,
                       { expand:  true,
                         x_align: St.Align.MIDDLE,
                         y_align: St.Align.END });
        this._defaultButtonWell = new St.Widget({ layout_manager: new Clutter.BinLayout() });
        this._defaultButtonWellActor = null;
        this._initButtons();
        let spinnerIcon = Gio.File.new_for_uri('resource:///org/gnome/shell/theme/process-working.svg');
        this._spinner = new Animation.AnimatedIcon(spinnerIcon, DEFAULT_BUTTON_WELL_ICON_SIZE);
        this._spinner.actor.opacity = 0;
        this._spinner.actor.show();
        this._defaultButtonWell.add_child(this._spinner.actor);
    },
    _onDestroy: function() {
        this._userVerifier.destroy();
        this._userVerifier = null;
    },
    _initButtons: function() {
        this.cancelButton = new St.Button({ style_class: 'modal-dialog-button button',
                                            button_mask: St.ButtonMask.ONE | St.ButtonMask.THREE,
                                            reactive: true,
                                            can_focus: true,
                                            label: _("Cancel") });
        this.cancelButton.connect('clicked',
                                   Lang.bind(this, function() {
                                       this.cancel();
                                   }));
        this._buttonBox.add(this.cancelButton,
                            { expand: false,
                              x_fill: false,
                              y_fill: false,
                              x_align: St.Align.START,
                              y_align: St.Align.END });
        this._buttonBox.add(this._defaultButtonWell,
                            { expand: true,
                              x_fill: false,
                              y_fill: false,
                              x_align: St.Align.END,
                              y_align: St.Align.MIDDLE });
        this.nextButton = new St.Button({ style_class: 'modal-dialog-button button',
                                          button_mask: St.ButtonMask.ONE | St.ButtonMask.THREE,
                                          reactive: true,
                                          can_focus: true,
                                          label: _("Next") });
        this.nextButton.connect('clicked',
                                 Lang.bind(this, function() {
                                     this.emit('next');
                                 }));
        this.nextButton.add_style_pseudo_class('default');
        this._buttonBox.add(this.nextButton,
                            { expand: false,
                              x_fill: false,
                              y_fill: false,
                              x_align: St.Align.END,
                              y_align: St.Align.END });
        this._updateNextButtonSensitivity(this._entry.text.length > 0);
        this._entry.clutter_text.connect('text-changed',
                                         Lang.bind(this, function() {
                                             if (!this._userVerifier.hasPendingMessages)
                                                 this._fadeOutMessage();
                                             this._updateNextButtonSensitivity(this._entry.text.length > 0);
                                         }));
        this._entry.clutter_text.connect('activate', Lang.bind(this, function() {
            if (this.nextButton.reactive)
                this.emit('next');
        }));
    },
    _onAskQuestion: function(verifier, serviceName, question, passwordChar) {
        if (this._queryingService)
            this.clear();
        this._queryingService = serviceName;
        if (this._preemptiveAnswer) {
            this._userVerifier.answerQuery(this._queryingService, this._preemptiveAnswer);
            this._preemptiveAnswer = null;
            return;
        }
        this.setPasswordChar(passwordChar);
        this.setQuestion(question);
        if (passwordChar) {
            if (this._userVerifier.reauthenticating)
                this.nextButton.label = _("Unlock");
            else
                this.nextButton.label = C_("button", "Sign In");
        } else {
            this.nextButton.label = _("Next");
        }
        this.updateSensitivity(true);
        this.emit('prompted');
    },
    _onOVirtUserAuthenticated: function() {
        if (this.verificationStatus != AuthPromptStatus.VERIFICATION_SUCCEEDED)
            this.reset();
    },
    _onSmartcardStatusChanged: function() {
        this.smartcardDetected = this._userVerifier.smartcardDetected;
        // Most of the time we want to reset if the user inserts or removes
        // a smartcard. Smartcard insertion "preempts" what the user was
        // doing, and smartcard removal aborts the preemption.
        // The exceptions are: 1) Don't reset on smartcard insertion if we're already verifying
        //                        with a smartcard
        //                     2) Don't reset if we've already succeeded at verification and
        //                        the user is getting logged in.
        if (this._userVerifier.serviceIsDefault(GdmUtil.SMARTCARD_SERVICE_NAME) &&
            this.verificationStatus == AuthPromptStatus.VERIFYING &&
            this.smartcardDetected)
            return;
        if (this.verificationStatus != AuthPromptStatus.VERIFICATION_SUCCEEDED)
            this.reset();
    },
    _onShowMessage: function(userVerifier, message, type) {
        this.setMessage(message, type);
        this.emit('prompted');
    },
    _onVerificationFailed: function() {
        this._queryingService = null;
        this.clear();
        this.updateSensitivity(true);
        this.setActorInDefaultButtonWell(null);
        this.verificationStatus = AuthPromptStatus.VERIFICATION_FAILED;
    },
    _onVerificationComplete: function() {
        this.setActorInDefaultButtonWell(null);
        this.verificationStatus = AuthPromptStatus.VERIFICATION_SUCCEEDED;
	this.cancelButton.reactive = false;
    },
    _onReset: function() {
        this.verificationStatus = AuthPromptStatus.NOT_VERIFYING;
        this.reset();
    },
    addActorToDefaultButtonWell: function(actor) {
        this._defaultButtonWell.add_child(actor);
    },
    setActorInDefaultButtonWell: function(actor, animate) {
        if (!this._defaultButtonWellActor &&
            !actor)
            return;
        let oldActor = this._defaultButtonWellActor;
        if (oldActor)
            Tweener.removeTweens(oldActor);
        let wasSpinner;
        if (oldActor == this._spinner.actor)
            wasSpinner = true;
        else
            wasSpinner = false;
        let isSpinner;
        if (actor == this._spinner.actor)
            isSpinner = true;
        else
            isSpinner = false;
        if (this._defaultButtonWellActor != actor && oldActor) {
            if (!animate) {
                oldActor.opacity = 0;
                if (wasSpinner) {
                    if (this._spinner)
                        this._spinner.stop();
                }
            } else {
                Tweener.addTween(oldActor,
                                 { opacity: 0,
                                   time: DEFAULT_BUTTON_WELL_ANIMATION_TIME,
                                   delay: DEFAULT_BUTTON_WELL_ANIMATION_DELAY,
                                   transition: 'linear',
                                   onCompleteScope: this,
                                   onComplete: function() {
                                      if (wasSpinner) {
                                          if (this._spinner)
                                              this._spinner.stop();
                                      }
                                   }
                                 });
            }
        }
        if (actor) {
            if (isSpinner)
                this._spinner.play();
            if (!animate)
                actor.opacity = 255;
            else
                Tweener.addTween(actor,
                                 { opacity: 255,
                                   time: DEFAULT_BUTTON_WELL_ANIMATION_TIME,
                                   delay: DEFAULT_BUTTON_WELL_ANIMATION_DELAY,
                                   transition: 'linear' });
        }
        this._defaultButtonWellActor = actor;
    },
    startSpinning: function() {
        this.setActorInDefaultButtonWell(this._spinner.actor, true);
    },
    stopSpinning: function() {
        this.setActorInDefaultButtonWell(null, false);
    },
    clear: function() {
        this._entry.text = '';
        this.stopSpinning();
    },
    setPasswordChar: function(passwordChar) {
        this._entry.clutter_text.set_password_char(passwordChar);
        this._entry.menu.isPassword = passwordChar != '';
    },
    setQuestion: function(question) {
        this._label.set_text(question);
        this._label.show();
        this._entry.show();
        this._entry.grab_key_focus();
    },
    getAnswer: function() {
        let text;
        if (this._preemptiveAnswer) {
            text = this._preemptiveAnswer;
            this._preemptiveAnswer = null;
        } else {
            text = this._entry.get_text();
        }
        return text;
    },
    _fadeOutMessage: function() {
        if (this._message.opacity == 0)
            return;
        Tweener.removeTweens(this._message);
        Tweener.addTween(this._message,
                         { opacity: 0,
                           time: MESSAGE_FADE_OUT_ANIMATION_TIME,
                           transition: 'easeOutQuad'
                         });
    },
    setMessage: function(message, type) {
        if (type == GdmUtil.MessageType.ERROR)
            this._message.add_style_class_name('login-dialog-message-warning');
        else
            this._message.remove_style_class_name('login-dialog-message-warning');
        if (type == GdmUtil.MessageType.HINT)
            this._message.add_style_class_name('login-dialog-message-hint');
        else
            this._message.remove_style_class_name('login-dialog-message-hint');
        if (message) {
            Tweener.removeTweens(this._message);
            this._message.text = message;
            this._message.opacity = 255;
        } else {
            this._message.opacity = 0;
        }
    },
    _updateNextButtonSensitivity: function(sensitive) {
        this.nextButton.reactive = sensitive;
        this.nextButton.can_focus = sensitive;
    },
    updateSensitivity: function(sensitive) {
        this._updateNextButtonSensitivity(sensitive && this._entry.text.length > 0);
        this._entry.reactive = sensitive;
        this._entry.clutter_text.editable = sensitive;
    },
    hide: function() {
        this.setActorInDefaultButtonWell(null, true);
        this.actor.hide();
        this._message.opacity = 0;
        this.setUser(null);
        this.updateSensitivity(true);
        this._entry.set_text('');
    },
    setUser: function(user) {
        let oldChild = this._userWell.get_child();
        if (oldChild)
            oldChild.destroy();
        if (user) {
            let userWidget = new UserWidget.UserWidget(user);
            this._userWell.set_child(userWidget.actor);
        }
    },
    reset: function() {
        let oldStatus = this.verificationStatus;
        this.verificationStatus = AuthPromptStatus.NOT_VERIFYING;
        this.cancelButton.reactive = true;
        this.nextButton.label = _("Next");
        if (this._userVerifier)
            this._userVerifier.cancel();
        this._queryingService = null;
        this.clear();
        this._message.opacity = 0;
        this.setUser(null);
        this.stopSpinning();
        if (oldStatus == AuthPromptStatus.VERIFICATION_FAILED)
            this.emit('failed');
        let beginRequestType;
        if (this._mode == AuthPromptMode.UNLOCK_ONLY) {
            // The user is constant at the unlock screen, so it will immediately
            // respond to the request with the username
            beginRequestType = BeginRequestType.PROVIDE_USERNAME;
        } else if (this._userVerifier.serviceIsForeground(GdmUtil.OVIRT_SERVICE_NAME) ||
                   this._userVerifier.serviceIsForeground(GdmUtil.SMARTCARD_SERVICE_NAME)) {
            // We don't need to know the username if the user preempted the login screen
            // with a smartcard or with preauthenticated oVirt credentials
            beginRequestType = BeginRequestType.DONT_PROVIDE_USERNAME;
        } else {
            // In all other cases, we should get the username up front.
            beginRequestType = BeginRequestType.PROVIDE_USERNAME;
        }
        this.emit('reset', beginRequestType);
    },
    addCharacter: function(unichar) {
        if (!this._entry.visible)
            return;
        this._entry.grab_key_focus();
        this._entry.clutter_text.insert_unichar(unichar);
    },
    begin: function(params) {
        params = Params.parse(params, { userName: null,
                                        hold: null });
        this.updateSensitivity(false);
        let hold = params.hold;
        if (!hold)
            hold = new Batch.Hold();
        this._userVerifier.begin(params.userName, hold);
        this.verificationStatus = AuthPromptStatus.VERIFYING;
    },
    finish: function(onComplete) {
        if (!this._userVerifier.hasPendingMessages) {
            this._userVerifier.clear();
            onComplete();
            return;
        }
        let signalId = this._userVerifier.connect('no-more-messages',
                                                  Lang.bind(this, function() {
                                                      this._userVerifier.disconnect(signalId);
                                                      this._userVerifier.clear();
                                                      onComplete();
                                                  }));
    },
    cancel: function() {
        if (this.verificationStatus == AuthPromptStatus.VERIFICATION_SUCCEEDED) {
            return;
        }
        this.reset();
        this.emit('cancelled');
    }
Signals.addSignalMethods(AuthPrompt.prototype);
(uuay)automountManager.js
// -*- mode: js; js-indent-level: 4; indent-tabs-mode: nil -*-
const Lang = imports.lang;
const Mainloop = imports.mainloop;
const GLib = imports.gi.GLib;
const Gio = imports.gi.Gio;
const Params = imports.misc.params;
const Shell = imports.gi.Shell;
const GnomeSession = imports.misc.gnomeSession;
const Main = imports.ui.main;
const ShellMountOperation = imports.ui.shellMountOperation;
const GNOME_SESSION_AUTOMOUNT_INHIBIT = 16;
// GSettings keys
const SETTINGS_SCHEMA = 'org.gnome.desktop.media-handling';
const SETTING_ENABLE_AUTOMOUNT = 'automount';
const AUTORUN_EXPIRE_TIMEOUT_SECS = 10;
const AutomountManager = new Lang.Class({
    Name: 'AutomountManager',
    _init: function() {
        this._settings = new Gio.Settings({ schema_id: SETTINGS_SCHEMA });
        this._volumeQueue = [];
        this._session = new GnomeSession.SessionManager();
        this._session.connectSignal('InhibitorAdded',
                                    Lang.bind(this, this._InhibitorsChanged));
        this._session.connectSignal('InhibitorRemoved',
                                    Lang.bind(this, this._InhibitorsChanged));
        this._inhibited = false;
        this._volumeMonitor = Gio.VolumeMonitor.get();
    },
    enable: function() {
        this._volumeAddedId = this._volumeMonitor.connect('volume-added', Lang.bind(this, this._onVolumeAdded));
        this._volumeRemovedId = this._volumeMonitor.connect('volume-removed', Lang.bind(this, this._onVolumeRemoved));
        this._driveConnectedId = this._volumeMonitor.connect('drive-connected', Lang.bind(this, this._onDriveConnected));
        this._driveDisconnectedId = this._volumeMonitor.connect('drive-disconnected', Lang.bind(this, this._onDriveDisconnected));
        this._driveEjectButtonId = this._volumeMonitor.connect('drive-eject-button', Lang.bind(this, this._onDriveEjectButton));
        this._mountAllId = Mainloop.idle_add(Lang.bind(this, this._startupMountAll));
        GLib.Source.set_name_by_id(this._mountAllId, '[gnome-shell] this._startupMountAll');
    },
    disable: function() {
        this._volumeMonitor.disconnect(this._volumeAddedId);
        this._volumeMonitor.disconnect(this._volumeRemovedId);
        this._volumeMonitor.disconnect(this._driveConnectedId);
        this._volumeMonitor.disconnect(this._driveDisconnectedId);
        this._volumeMonitor.disconnect(this._driveEjectButtonId);
        if (this._mountAllId > 0) {
            Mainloop.source_remove(this._mountAllId);
            this._mountAllId = 0;
        }
    },
    _InhibitorsChanged: function(object, senderName, [inhibtor]) {
        this._session.IsInhibitedRemote(GNOME_SESSION_AUTOMOUNT_INHIBIT,
            Lang.bind(this,
                function(result, error) {
                    if (!error) {
                        this._inhibited = result[0];
                    }
                }));
    },
    _startupMountAll: function() {
        let volumes = this._volumeMonitor.get_volumes();
        volumes.forEach(Lang.bind(this, function(volume) {
            this._checkAndMountVolume(volume, { checkSession: false,
                                                useMountOp: false,
                                                allowAutorun: false });
        }));
        this._mountAllId = 0;
        return GLib.SOURCE_REMOVE;
    },
    _onDriveConnected: function() {
        // if we're not in the current ConsoleKit session,
        // or screensaver is active, don't play sounds
        if (!this._session.SessionIsActive)
            return;
        global.play_theme_sound(0, 'device-added-media',
                                _("External drive connected"),
                                null);
    },
    _onDriveDisconnected: function() {
        // if we're not in the current ConsoleKit session,
        // or screensaver is active, don't play sounds
        if (!this._session.SessionIsActive)
            return;
        global.play_theme_sound(0, 'device-removed-media',
                                _("External drive disconnected"),
                                null);
    },
    _onDriveEjectButton: function(monitor, drive) {
        // TODO: this code path is not tested, as the GVfs volume monitor
        // doesn't emit this signal just yet.
        if (!this._session.SessionIsActive)
            return;
        // we force stop/eject in this case, so we don't have to pass a
        // mount operation object
        if (drive.can_stop()) {
            drive.stop
                (Gio.MountUnmountFlags.FORCE, null, null,
                 Lang.bind(this, function(drive, res) {
                     try {
                         drive.stop_finish(res);
                     } catch (e) {
                         log("Unable to stop the drive after drive-eject-button " + e.toString());
                     }
                 }));
        } else if (drive.can_eject()) {
            drive.eject_with_operation 
                (Gio.MountUnmountFlags.FORCE, null, null,
                 Lang.bind(this, function(drive, res) {
                     try {
                         drive.eject_with_operation_finish(res);
                     } catch (e) {
                         log("Unable to eject the drive after drive-eject-button " + e.toString());
                     }
                 }));
        }
    },
    _onVolumeAdded: function(monitor, volume) {
        this._checkAndMountVolume(volume);
    },
    _checkAndMountVolume: function(volume, params) {
        params = Params.parse(params, { checkSession: true,
                                        useMountOp: true,
                                        allowAutorun: true });
        if (params.checkSession) {
            // if we're not in the current ConsoleKit session,
            // don't attempt automount
            if (!this._session.SessionIsActive)
                return;
        }
        if (this._inhibited)
            return;
        // Volume is already mounted, don't bother.
        if (volume.get_mount())
            return;
        if (!this._settings.get_boolean(SETTING_ENABLE_AUTOMOUNT) ||
            !volume.should_automount() ||
            !volume.can_mount()) {
            // allow the autorun to run anyway; this can happen if the
            // mount gets added programmatically later, even if 
            // should_automount() or can_mount() are false, like for
            // blank optical media.
            this._allowAutorun(volume);
            this._allowAutorunExpire(volume);
            return;
        }
        if (params.useMountOp) {
            let operation = new ShellMountOperation.ShellMountOperation(volume);
            this._mountVolume(volume, operation, params.allowAutorun);
        } else {
            this._mountVolume(volume, null, params.allowAutorun);
        }
    },
    _mountVolume: function(volume, operation, allowAutorun) {
        if (allowAutorun)
            this._allowAutorun(volume);
        let mountOp = operation ? operation.mountOp : null;
        volume._operation = operation;
        volume.mount(0, mountOp, null,
                     Lang.bind(this, this._onVolumeMounted));
    },
    _onVolumeMounted: function(volume, res) {
        this._allowAutorunExpire(volume);
        try {
            volume.mount_finish(res);
            this._closeOperation(volume);
        } catch (e) {
            // FIXME: we will always get G_IO_ERROR_FAILED from the gvfs udisks
            // backend in this case, see 
            // https://bugs.freedesktop.org/show_bug.cgi?id=51271
            if (e.message.indexOf('No key available with this passphrase') != -1) {
                this._reaskPassword(volume);
            } else {
                if (!e.matches(Gio.IOErrorEnum, Gio.IOErrorEnum.FAILED_HANDLED))
                    log('Unable to mount volume ' + volume.get_name() + ': ' + e.toString());
                this._closeOperation(volume);
            }
        }
    },
    _onVolumeRemoved: function(monitor, volume) {
        this._volumeQueue = 
            this._volumeQueue.filter(function(element) {
                return (element != volume);
            });
    },
    _reaskPassword: function(volume) {
        let existingDialog = volume._operation ? volume._operation.borrowDialog() : null;
        let operation = 
            new ShellMountOperation.ShellMountOperation(volume,
                                                        { existingDialog: existingDialog });
        this._mountVolume(volume, operation);
    },
    _closeOperation: function(volume) {
        if (volume._operation)
            volume._operation.close();
    },
    _allowAutorun: function(volume) {
        volume.allowAutorun = true;
    },
    _allowAutorunExpire: function(volume) {
        let id = Mainloop.timeout_add_seconds(AUTORUN_EXPIRE_TIMEOUT_SECS, function() {
            volume.allowAutorun = false;
            return GLib.SOURCE_REMOVE;
        });
        GLib.Source.set_name_by_id(id, '[gnome-shell] volume.allowAutorun');
    }
const Component = AutomountManager;
(uuay)iconGrid.js
// -*- mode: js; js-indent-level: 4; indent-tabs-mode: nil -*-
const Clutter = imports.gi.Clutter;
const Gtk = imports.gi.Gtk;
const Meta = imports.gi.Meta;
const Shell = imports.gi.Shell;
const Signals = imports.signals;
const St = imports.gi.St;
const Lang = imports.lang;
const Params = imports.misc.params;
const Tweener = imports.ui.tweener;
const Main = imports.ui.main;
const ICON_SIZE = 96;
const MIN_ICON_SIZE = 16;
const EXTRA_SPACE_ANIMATION_TIME = 0.25;
const ANIMATION_TIME_IN = 0.350;
const ANIMATION_TIME_OUT = 1/2 * ANIMATION_TIME_IN;
const ANIMATION_MAX_DELAY_FOR_ITEM = 2/3 * ANIMATION_TIME_IN;
const ANIMATION_BASE_DELAY_FOR_ITEM = 1/4 * ANIMATION_MAX_DELAY_FOR_ITEM;
const ANIMATION_MAX_DELAY_OUT_FOR_ITEM = 2/3 * ANIMATION_TIME_OUT;
const ANIMATION_FADE_IN_TIME_FOR_ITEM = 1/4 * ANIMATION_TIME_IN;
const ANIMATION_BOUNCE_ICON_SCALE = 1.1;
const AnimationDirection = {
    IN: 0,
    OUT: 1
const APPICON_ANIMATION_OUT_SCALE = 3;
const APPICON_ANIMATION_OUT_TIME = 0.25;
const BaseIcon = new Lang.Class({
    Name: 'BaseIcon',
    _init : function(label, params) {
        params = Params.parse(params, { createIcon: null,
                                        setSizeManually: false,
                                        showLabel: true });
        let styleClass = 'overview-icon';
        if (params.showLabel)
            styleClass += ' overview-icon-with-label';
        this.actor = new St.Bin({ style_class: styleClass,
                                  x_fill: true,
                                  y_fill: true });
        this.actor._delegate = this;
        this.actor.connect('style-changed',
                           Lang.bind(this, this._onStyleChanged));
        this.actor.connect('destroy',
                           Lang.bind(this, this._onDestroy));
        this._spacing = 0;
        let box = new Shell.GenericContainer();
        box.connect('allocate', Lang.bind(this, this._allocate));
        box.connect('get-preferred-width',
                    Lang.bind(this, this._getPreferredWidth));
        box.connect('get-preferred-height',
                    Lang.bind(this, this._getPreferredHeight));
        this.actor.set_child(box);
        this.iconSize = ICON_SIZE;
        this._iconBin = new St.Bin({ x_align: St.Align.MIDDLE,
                                     y_align: St.Align.MIDDLE });
        box.add_actor(this._iconBin);
        if (params.showLabel) {
            this.label = new St.Label({ text: label });
            box.add_actor(this.label);
        } else {
            this.label = null;
        }
        if (params.createIcon)
            this.createIcon = params.createIcon;
        this._setSizeManually = params.setSizeManually;
        this.icon = null;
        let cache = St.TextureCache.get_default();
        this._iconThemeChangedId = cache.connect('icon-theme-changed', Lang.bind(this, this._onIconThemeChanged));
    },
    _allocate: function(actor, box, flags) {
        let availWidth = box.x2 - box.x1;
        let availHeight = box.y2 - box.y1;
        let iconSize = availHeight;
        let [iconMinHeight, iconNatHeight] = this._iconBin.get_preferred_height(-1);
        let [iconMinWidth, iconNatWidth] = this._iconBin.get_preferred_width(-1);
        let preferredHeight = iconNatHeight;
        let childBox = new Clutter.ActorBox();
        if (this.label) {
            let [labelMinHeight, labelNatHeight] = this.label.get_preferred_height(-1);
            preferredHeight += this._spacing + labelNatHeight;
            let labelHeight = availHeight >= preferredHeight ? labelNatHeight
                                                             : labelMinHeight;
            iconSize -= this._spacing + labelHeight;
            childBox.x1 = 0;
            childBox.x2 = availWidth;
            childBox.y1 = iconSize + this._spacing;
            childBox.y2 = childBox.y1 + labelHeight;
            this.label.allocate(childBox, flags);
        }
        childBox.x1 = Math.floor((availWidth - iconNatWidth) / 2);
        childBox.y1 = Math.floor((iconSize - iconNatHeight) / 2);
        childBox.x2 = childBox.x1 + iconNatWidth;
        childBox.y2 = childBox.y1 + iconNatHeight;
        this._iconBin.allocate(childBox, flags);
    },
    _getPreferredWidth: function(actor, forHeight, alloc) {
        this._getPreferredHeight(actor, -1, alloc);
    },
    _getPreferredHeight: function(actor, forWidth, alloc) {
        let [iconMinHeight, iconNatHeight] = this._iconBin.get_preferred_height(forWidth);
        alloc.min_size = iconMinHeight;
        alloc.natural_size = iconNatHeight;
        if (this.label) {
            let [labelMinHeight, labelNatHeight] = this.label.get_preferred_height(forWidth);
            alloc.min_size += this._spacing + labelMinHeight;
            alloc.natural_size += this._spacing + labelNatHeight;
        }
    },
    // This can be overridden by a subclass, or by the createIcon
    // parameter to _init()
    createIcon: function(size) {
        throw new Error('no implementation of createIcon in ' + this);
    },
    setIconSize: function(size) {
        if (!this._setSizeManually)
            throw new Error('setSizeManually has to be set to use setIconsize');
        if (size == this.iconSize)
            return;
        this._createIconTexture(size);
    },
    _createIconTexture: function(size) {
        if (this.icon)
            this.icon.destroy();
        this.iconSize = size;
        this.icon = this.createIcon(this.iconSize);
        this._iconBin.child = this.icon;
    },
    _onStyleChanged: function() {
        let node = this.actor.get_theme_node();
        this._spacing = node.get_length('spacing');
        let size;
        if (this._setSizeManually) {
            size = this.iconSize;
        } else {
            let [found, len] = node.lookup_length('icon-size', false);
            size = found ? len : ICON_SIZE;
        }
        if (this.iconSize == size && this._iconBin.child)
            return;
        this._createIconTexture(size);
    },
    _onDestroy: function() {
        if (this._iconThemeChangedId > 0) {
            let cache = St.TextureCache.get_default();
            cache.disconnect(this._iconThemeChangedId);
            this._iconThemeChangedId = 0;
        }
    },
    _onIconThemeChanged: function() {
        this._createIconTexture(this.iconSize);
    },
    animateZoomOut: function() {
        // Animate only the child instead of the entire actor, so the
        // styles like hover and running are not applied while
        // animating.
        zoomOutActor(this.actor.child);
    }
function clamp(value, min, max) {
    return Math.max(Math.min(value, max), min);
function zoomOutActor(actor) {
    let actorClone = new Clutter.Clone({ source: actor,
                                         reactive: false });
    let [width, height] = actor.get_transformed_size();
    let [x, y] = actor.get_transformed_position();
    actorClone.set_size(width, height);
    actorClone.set_position(x, y);
    actorClone.opacity = 255;
    actorClone.set_pivot_point(0.5, 0.5);
    Main.uiGroup.add_actor(actorClone);
    // Avoid monitor edges to not zoom outside the current monitor
    let monitor = Main.layoutManager.findMonitorForActor(actor);
    let scaledWidth = width * APPICON_ANIMATION_OUT_SCALE;
    let scaledHeight = height * APPICON_ANIMATION_OUT_SCALE;
    let scaledX = x - (scaledWidth - width) / 2;
    let scaledY = y - (scaledHeight - height) / 2;
    let containedX = clamp(scaledX, monitor.x, monitor.x + monitor.width - scaledWidth);
    let containedY = clamp(scaledY, monitor.y, monitor.y + monitor.height - scaledHeight);
    Tweener.addTween(actorClone,
                     { time: APPICON_ANIMATION_OUT_TIME,
                       scale_x: APPICON_ANIMATION_OUT_SCALE,
                       scale_y: APPICON_ANIMATION_OUT_SCALE,
                       translation_x: containedX - scaledX,
                       translation_y: containedY - scaledY,
                       opacity: 0,
                       transition: 'easeOutQuad',
                       onComplete: function() {
                           actorClone.destroy();
                       }
                    });
const IconGrid = new Lang.Class({
    Name: 'IconGrid',
    _init: function(params) {
        params = Params.parse(params, { rowLimit: null,
                                        columnLimit: null,
                                        minRows: 1,
                                        minColumns: 1,
                                        fillParent: false,
                                        xAlign: St.Align.MIDDLE,
                                        padWithSpacing: false });
        this._rowLimit = params.rowLimit;
        this._colLimit = params.columnLimit;
        this._minRows = params.minRows;
        this._minColumns = params.minColumns;
        this._xAlign = params.xAlign;
        this._fillParent = params.fillParent;
        this._padWithSpacing = params.padWithSpacing;
        this.topPadding = 0;
        this.bottomPadding = 0;
        this.rightPadding = 0;
        this.leftPadding = 0;
        this.actor = new St.BoxLayout({ style_class: 'icon-grid',
                                        vertical: true });
        this._items = [];
        // Pulled from CSS, but hardcode some defaults here
        this._spacing = 0;
        this._hItemSize = this._vItemSize = ICON_SIZE;
        this._fixedHItemSize = this._fixedVItemSize = undefined;
        this._grid = new Shell.GenericContainer();
        this.actor.add(this._grid, { expand: true, y_align: St.Align.START });
        this.actor.connect('style-changed', Lang.bind(this, this._onStyleChanged));
        this._grid.connect('get-preferred-width', Lang.bind(this, this._getPreferredWidth));
        this._grid.connect('get-preferred-height', Lang.bind(this, this._getPreferredHeight));
        this._grid.connect('allocate', Lang.bind(this, this._allocate));
        this._grid.connect('actor-added', Lang.bind(this, this._childAdded));
        this._grid.connect('actor-removed', Lang.bind(this, this._childRemoved));
    },
    _keyFocusIn: function(actor) {
        this.emit('key-focus-in', actor);
    },
    _childAdded: function(grid, child) {
        child._iconGridKeyFocusInId = child.connect('key-focus-in', Lang.bind(this, this._keyFocusIn));
    },
    _childRemoved: function(grid, child) {
        child.disconnect(child._iconGridKeyFocusInId);
    },
    _getPreferredWidth: function (grid, forHeight, alloc) {
        if (this._fillParent)
            // Ignore all size requests of children and request a size of 0;
            // later we'll allocate as many children as fit the parent
            return;
        let nChildren = this._grid.get_n_children();
        let nColumns = this._colLimit ? Math.min(this._colLimit,
                                                 nChildren)
                                      : nChildren;
        let totalSpacing = Math.max(0, nColumns - 1) * this._getSpacing();
        // Kind of a lie, but not really an issue right now.  If
        // we wanted to support some sort of hidden/overflow that would
        // need higher level design
        alloc.min_size = this._getHItemSize() + this.leftPadding + this.rightPadding;
        alloc.natural_size = nColumns * this._getHItemSize() + totalSpacing + this.leftPadding + this.rightPadding;
    },
    _getVisibleChildren: function() {
        let children = this._grid.get_children();
        children = children.filter(function(actor) {
            return actor.visible;
        });
        return children;
    },
    _getPreferredHeight: function (grid, forWidth, alloc) {
        if (this._fillParent)
            // Ignore all size requests of children and request a size of 0;
            // later we'll allocate as many children as fit the parent
            return;
        let children = this._getVisibleChildren();
        let nColumns;
        if (forWidth < 0)
            nColumns = children.length;
        else
            [nColumns, ] = this._computeLayout(forWidth);
        let nRows;
        if (nColumns > 0)
            nRows = Math.ceil(children.length / nColumns);
        else
            nRows = 0;
        if (this._rowLimit)
            nRows = Math.min(nRows, this._rowLimit);
        let totalSpacing = Math.max(0, nRows - 1) * this._getSpacing();
        let height = nRows * this._getVItemSize() + totalSpacing + this.topPadding + this.bottomPadding;
        alloc.min_size = height;
        alloc.natural_size = height;
    },
    _allocate: function (grid, box, flags) {
        if (this._fillParent) {
            // Reset the passed in box to fill the parent
            let parentBox = this.actor.get_parent().allocation;
            let gridBox = this.actor.get_theme_node().get_content_box(parentBox);
            box = this._grid.get_theme_node().get_content_box(gridBox);
        }
        let children = this._getVisibleChildren();
        let availWidth = box.x2 - box.x1;
        let availHeight = box.y2 - box.y1;
        let spacing = this._getSpacing();
        let [nColumns, usedWidth] = this._computeLayout(availWidth);
        let leftEmptySpace;
        switch(this._xAlign) {
            case St.Align.START:
                leftEmptySpace = 0;
                break;
            case St.Align.MIDDLE:
                leftEmptySpace = Math.floor((availWidth - usedWidth) / 2);
                break;
            case St.Align.END:
                leftEmptySpace = availWidth - usedWidth;
        }
        let x = box.x1 + leftEmptySpace + this.leftPadding;
        let y = box.y1 + this.topPadding;
        let columnIndex = 0;
        let rowIndex = 0;
        for (let i = 0; i < children.length; i++) {
            let childBox = this._calculateChildBox(children[i], x, y, box);
            if (this._rowLimit && rowIndex >= this._rowLimit ||
                this._fillParent && childBox.y2 > availHeight - this.bottomPadding) {
                this._grid.set_skip_paint(children[i], true);
            } else {
                children[i].allocate(childBox, flags);
                this._grid.set_skip_paint(children[i], false);
            }
            columnIndex++;
            if (columnIndex == nColumns) {
                columnIndex = 0;
                rowIndex++;
            }
            if (columnIndex == 0) {
                y += this._getVItemSize() + spacing;
                x = box.x1 + leftEmptySpace + this.leftPadding;
            } else {
                x += this._getHItemSize() + spacing;
            }
        }
    },
    /**
     * Intended to be override by subclasses if they need a different
     * set of items to be animated.
     */
    _getChildrenToAnimate: function() {
        return this._getVisibleChildren();
    },
    _animationDone: function() {
        this._animating = false;
        this.emit('animation-done');
    },
    animatePulse: function(animationDirection) {
        if (animationDirection != AnimationDirection.IN)
            throw new Error("Pulse animation only implements 'in' animation direction");
        if (this._animating)
            return;
        this._animating = true;
        let actors = this._getChildrenToAnimate();
        if (actors.length == 0) {
            this._animationDone();
            return;
        }
        // For few items the animation can be slow, so use a smaller
        // delay when there are less than 4 items
        // (ANIMATION_BASE_DELAY_FOR_ITEM = 1/4 *
        // ANIMATION_MAX_DELAY_FOR_ITEM)
        let maxDelay = Math.min(ANIMATION_BASE_DELAY_FOR_ITEM * actors.length,
                                ANIMATION_MAX_DELAY_FOR_ITEM);
        for (let index = 0; index < actors.length; index++) {
            let actor = actors[index];
            actor.reactive = false;
            actor.set_scale(0, 0);
            actor.set_pivot_point(0.5, 0.5);
            let delay = index / actors.length * maxDelay;
            let bounceUpTime = ANIMATION_TIME_IN / 4;
            let isLastItem = index == actors.length - 1;
            Tweener.addTween(actor,
                            { time: bounceUpTime,
                              transition: 'easeInOutQuad',
                              delay: delay,
                              scale_x: ANIMATION_BOUNCE_ICON_SCALE,
                              scale_y: ANIMATION_BOUNCE_ICON_SCALE,
                              onComplete: Lang.bind(this, function() {
                                  Tweener.addTween(actor,
                                                   { time: ANIMATION_TIME_IN - bounceUpTime,
                                                     transition: 'easeInOutQuad',
                                                     scale_x: 1,
                                                     scale_y: 1,
                                                     onComplete: Lang.bind(this, function() {
                                                        if (isLastItem)
                                                            this._animationDone();
                                                        actor.reactive = true;
                                                    })
                                                   });
                              })
                            });
        }
    },
    animateSpring: function(animationDirection, sourceActor) {
        if (this._animating)
            return;
        this._animating = true;
        let actors = this._getChildrenToAnimate();
        if (actors.length == 0) {
            this._animationDone();
            return;
        }
        let [sourceX, sourceY] = sourceActor.get_transformed_position();
        let [sourceWidth, sourceHeight] = sourceActor.get_size();
        // Get the center
        let [sourceCenterX, sourceCenterY] = [sourceX + sourceWidth / 2, sourceY + sourceHeight / 2];
        // Design decision, 1/2 of the source actor size.
        let [sourceScaledWidth, sourceScaledHeight] = [sourceWidth / 2, sourceHeight / 2];
        actors.forEach(function(actor) {
            let [actorX, actorY] = actor._transformedPosition = actor.get_transformed_position();
            let [x, y] = [actorX - sourceX, actorY - sourceY];
            actor._distance = Math.sqrt(x * x + y * y);
        });
        let maxDist = actors.reduce(function(prev, cur) {
            return Math.max(prev, cur._distance);
        }, 0);
        let minDist = actors.reduce(function(prev, cur) {
            return Math.min(prev, cur._distance);
        }, Infinity);
        let normalization = maxDist - minDist;
        for (let index = 0; index < actors.length; index++) {
            let actor = actors[index];
            actor.opacity = 0;
            actor.reactive = false;
            let actorClone = new Clutter.Clone({ source: actor });
            Main.uiGroup.add_actor(actorClone);
            let [width, height,,] = this._getAllocatedChildSizeAndSpacing(actor);
            actorClone.set_size(width, height);
            let scaleX = sourceScaledWidth / width;
            let scaleY = sourceScaledHeight / height;
            let [adjustedSourcePositionX, adjustedSourcePositionY] = [sourceCenterX - sourceScaledWidth / 2, sourceCenterY - sourceScaledHeight / 2];
            let movementParams, fadeParams;
            if (animationDirection == AnimationDirection.IN) {
                let isLastItem = actor._distance == minDist;
                actorClone.opacity = 0;
                actorClone.set_scale(scaleX, scaleY);
                actorClone.set_position(adjustedSourcePositionX, adjustedSourcePositionY);
                let delay = (1 - (actor._distance - minDist) / normalization) * ANIMATION_MAX_DELAY_FOR_ITEM;
                let [finalX, finalY]  = actor._transformedPosition;
                movementParams = { time: ANIMATION_TIME_IN,
                                   transition: 'easeInOutQuad',
                                   delay: delay,
                                   x: finalX,
                                   y: finalY,
                                   scale_x: 1,
                                   scale_y: 1,
                                   onComplete: Lang.bind(this, function() {
                                       if (isLastItem)
                                           this._animationDone();
                                       actor.opacity = 255;
                                       actor.reactive = true;
                                       actorClone.destroy();
                                   })};
                fadeParams = { time: ANIMATION_FADE_IN_TIME_FOR_ITEM,
                               transition: 'easeInOutQuad',
                               delay: delay,
                               opacity: 255 };
            } else {
                let isLastItem = actor._distance == maxDist;
                let [startX, startY]  = actor._transformedPosition;
                actorClone.set_position(startX, startY);
                let delay = (actor._distance - minDist) / normalization * ANIMATION_MAX_DELAY_OUT_FOR_ITEM;
                movementParams = { time: ANIMATION_TIME_OUT,
                                   transition: 'easeInOutQuad',
                                   delay: delay,
                                   x: adjustedSourcePositionX,
                                   y: adjustedSourcePositionY,
                                   scale_x: scaleX,
                                   scale_y: scaleY,
                                   onComplete: Lang.bind(this, function() {
                                       if (isLastItem) {
                                           this._animationDone();
                                           this._restoreItemsOpacity();
                                       }
                                       actor.reactive = true;
                                       actorClone.destroy();
                                   })};
                fadeParams = { time: ANIMATION_FADE_IN_TIME_FOR_ITEM,
                               transition: 'easeInOutQuad',
                               delay: ANIMATION_TIME_OUT + delay - ANIMATION_FADE_IN_TIME_FOR_ITEM,
                               opacity: 0 };
            }
            Tweener.addTween(actorClone, movementParams);
            Tweener.addTween(actorClone, fadeParams);
        }
    },
    _restoreItemsOpacity: function() {
        for (let index = 0; index < this._items.length; index++) {
            this._items[index].actor.opacity = 255;
        }
    },
    _getAllocatedChildSizeAndSpacing: function(child) {
        let [,, natWidth, natHeight] = child.get_preferred_size();
        let width = Math.min(this._getHItemSize(), natWidth);
        let xSpacing = Math.max(0, width - natWidth) / 2;
        let height = Math.min(this._getVItemSize(), natHeight);
        let ySpacing = Math.max(0, height - natHeight) / 2;
        return [width, height, xSpacing, ySpacing];
    },
    _calculateChildBox: function(child, x, y, box) {
        /* Center the item in its allocation horizontally */
        let [width, height, childXSpacing, childYSpacing] =
            this._getAllocatedChildSizeAndSpacing(child);
        let childBox = new Clutter.ActorBox();
        if (Clutter.get_default_text_direction() == Clutter.TextDirection.RTL) {
            let _x = box.x2 - (x + width);
            childBox.x1 = Math.floor(_x - childXSpacing);
        } else {
            childBox.x1 = Math.floor(x + childXSpacing);
        }
        childBox.y1 = Math.floor(y + childYSpacing);
        childBox.x2 = childBox.x1 + width;
        childBox.y2 = childBox.y1 + height;
        return childBox;
    },
    columnsForWidth: function(rowWidth) {
        return this._computeLayout(rowWidth)[0];
    },
    getRowLimit: function() {
        return this._rowLimit;
    },
    _computeLayout: function (forWidth) {
        let nColumns = 0;
        let usedWidth = this.leftPadding + this.rightPadding;
        let spacing = this._getSpacing();
        while ((this._colLimit == null || nColumns < this._colLimit) &&
               (usedWidth + this._getHItemSize() <= forWidth)) {
            usedWidth += this._getHItemSize() + spacing;
            nColumns += 1;
        }
        if (nColumns > 0)
            usedWidth -= spacing;
        return [nColumns, usedWidth];
    },
    _onStyleChanged: function() {
        let themeNode = this.actor.get_theme_node();
        this._spacing = themeNode.get_length('spacing');
        this._hItemSize = themeNode.get_length('-shell-grid-horizontal-item-size') || ICON_SIZE;
        this._vItemSize = themeNode.get_length('-shell-grid-vertical-item-size') || ICON_SIZE;
        this._grid.queue_relayout();
    },
    nRows: function(forWidth) {
        let children = this._getVisibleChildren();
        let nColumns = (forWidth < 0) ? children.length : this._computeLayout(forWidth)[0];
        let nRows = (nColumns > 0) ? Math.ceil(children.length / nColumns) : 0;
        if (this._rowLimit)
            nRows = Math.min(nRows, this._rowLimit);
        return nRows;
    },
    rowsForHeight: function(forHeight) {
        return Math.floor((forHeight - (this.topPadding + this.bottomPadding) + this._getSpacing()) / (this._getVItemSize() + this._getSpacing()));
    },
    usedHeightForNRows: function(nRows) {
        return (this._getVItemSize() + this._getSpacing()) * nRows - this._getSpacing() + this.topPadding + this.bottomPadding;
    },
    usedWidth: function(forWidth) {
        return this.usedWidthForNColumns(this.columnsForWidth(forWidth));
    },
    usedWidthForNColumns: function(columns) {
        let usedWidth = columns  * (this._getHItemSize() + this._getSpacing());
        usedWidth -= this._getSpacing();
        return usedWidth + this.leftPadding + this.rightPadding;
    },
    removeAll: function() {
        this._items = [];
        this._grid.remove_all_children();
    },
    destroyAll: function() {
        this._items = [];
        this._grid.destroy_all_children();
    },
    addItem: function(item, index) {
        if (!item.icon instanceof BaseIcon)
            throw new Error('Only items with a BaseIcon icon property can be added to IconGrid');
        this._items.push(item);
        if (index !== undefined)
            this._grid.insert_child_at_index(item.actor, index);
        else
            this._grid.add_actor(item.actor);
    },
    removeItem: function(item) {
        this._grid.remove_child(item.actor);
    },
    getItemAtIndex: function(index) {
        return this._grid.get_child_at_index(index);
    },
    visibleItemsCount: function() {
        return this._grid.get_n_children() - this._grid.get_n_skip_paint();
    },
    setSpacing: function(spacing) {
        this._fixedSpacing = spacing;
    },
    _getSpacing: function() {
        return this._fixedSpacing ? this._fixedSpacing : this._spacing;
    },
    _getHItemSize: function() {
        return this._fixedHItemSize ? this._fixedHItemSize : this._hItemSize;
    },
    _getVItemSize: function() {
        return this._fixedVItemSize ? this._fixedVItemSize : this._vItemSize;
    },
    _updateSpacingForSize: function(availWidth, availHeight) {
        let maxEmptyVArea = availHeight - this._minRows * this._getVItemSize();
        let maxEmptyHArea = availWidth - this._minColumns * this._getHItemSize();
        let maxHSpacing, maxVSpacing;
        if (this._padWithSpacing) {
            // minRows + 1 because we want to put spacing before the first row, so it is like we have one more row
            // to divide the empty space
            maxVSpacing = Math.floor(maxEmptyVArea / (this._minRows +1));
            maxHSpacing = Math.floor(maxEmptyHArea / (this._minColumns +1));
        } else {
            if (this._minRows <=  1)
                maxVSpacing = maxEmptyVArea;
            else
                maxVSpacing = Math.floor(maxEmptyVArea / (this._minRows - 1));
            if (this._minColumns <=  1)
                maxHSpacing = maxEmptyHArea;
            else
                maxHSpacing = Math.floor(maxEmptyHArea / (this._minColumns - 1));
        }
        let maxSpacing = Math.min(maxHSpacing, maxVSpacing);
        // Limit spacing to the item size
        maxSpacing = Math.min(maxSpacing, Math.min(this._getVItemSize(), this._getHItemSize()));
        // The minimum spacing, regardless of whether it satisfies the row/columng minima,
        // is the spacing we get from CSS.
        let spacing = Math.max(this._spacing, maxSpacing);
        this.setSpacing(spacing);
        if (this._padWithSpacing)
            this.topPadding = this.rightPadding = this.bottomPadding = this.leftPadding = spacing;
    },
    /**
     * This function must to be called before iconGrid allocation,
     * to know how much spacing can the grid has
     */
    adaptToSize: function(availWidth, availHeight) {
        this._fixedHItemSize = this._hItemSize;
        this._fixedVItemSize = this._vItemSize;
        this._updateSpacingForSize(availWidth, availHeight);
        let spacing = this._getSpacing();
        if (this.columnsForWidth(availWidth) < this._minColumns || this.rowsForHeight(availHeight) < this._minRows) {
            let neededWidth = this.usedWidthForNColumns(this._minColumns) - availWidth ;
            let neededHeight = this.usedHeightForNRows(this._minRows) - availHeight ;
            let neededSpacePerItem = (neededWidth > neededHeight) ? Math.ceil(neededWidth / this._minColumns)
                                                                  : Math.ceil(neededHeight / this._minRows);
            this._fixedHItemSize = Math.max(this._hItemSize - neededSpacePerItem, MIN_ICON_SIZE);
            this._fixedVItemSize = Math.max(this._vItemSize - neededSpacePerItem, MIN_ICON_SIZE);
            this._updateSpacingForSize(availWidth, availHeight);
        }
        Meta.later_add(Meta.LaterType.BEFORE_REDRAW,
                       Lang.bind(this, this._updateIconSizes));
    },
    // Note that this is ICON_SIZE as used by BaseIcon, not elsewhere in IconGrid; it's a bit messed up
    _updateIconSizes: function() {
        let scale = Math.min(this._fixedHItemSize, this._fixedVItemSize) / Math.max(this._hItemSize, this._vItemSize);
        let newIconSize = Math.floor(ICON_SIZE * scale);
        for (let i in this._items) {
            this._items[i].icon.setIconSize(newIconSize);
        }
    }
Signals.addSignalMethods(IconGrid.prototype);
const PaginatedIconGrid = new Lang.Class({
    Name: 'PaginatedIconGrid',
    Extends: IconGrid,
    _init: function(params) {
        this.parent(params);
        this._nPages = 0;
        this.currentPage = 0;
        this._rowsPerPage = 0;
        this._spaceBetweenPages = 0;
        this._childrenPerPage = 0;
    },
    _getPreferredHeight: function (grid, forWidth, alloc) {
        alloc.min_size = (this._availableHeightPerPageForItems() + this.bottomPadding + this.topPadding) * this._nPages + this._spaceBetweenPages * this._nPages;
        alloc.natural_size = (this._availableHeightPerPageForItems() + this.bottomPadding + this.topPadding) * this._nPages + this._spaceBetweenPages * this._nPages;
    },
    _allocate: function (grid, box, flags) {
         if (this._childrenPerPage == 0)
            log('computePages() must be called before allocate(); pagination will not work.');
        if (this._fillParent) {
            // Reset the passed in box to fill the parent
            let parentBox = this.actor.get_parent().allocation;
            let gridBox = this.actor.get_theme_node().get_content_box(parentBox);
            box = this._grid.get_theme_node().get_content_box(gridBox);
        }
        let children = this._getVisibleChildren();
        let availWidth = box.x2 - box.x1;
        let availHeight = box.y2 - box.y1;
        let spacing = this._getSpacing();
        let [nColumns, usedWidth] = this._computeLayout(availWidth);
        let leftEmptySpace;
        switch(this._xAlign) {
            case St.Align.START:
                leftEmptySpace = 0;
                break;
            case St.Align.MIDDLE:
                leftEmptySpace = Math.floor((availWidth - usedWidth) / 2);
                break;
            case St.Align.END:
                leftEmptySpace = availWidth - usedWidth;
        }
        let x = box.x1 + leftEmptySpace + this.leftPadding;
        let y = box.y1 + this.topPadding;
        let columnIndex = 0;
        let rowIndex = 0;
        for (let i = 0; i < children.length; i++) {
            let childBox = this._calculateChildBox(children[i], x, y, box);
            children[i].allocate(childBox, flags);
            this._grid.set_skip_paint(children[i], false);
            columnIndex++;
            if (columnIndex == nColumns) {
                columnIndex = 0;
                rowIndex++;
            }
            if (columnIndex == 0) {
                y += this._getVItemSize() + spacing;
                if ((i + 1) % this._childrenPerPage == 0)
                    y +=  this._spaceBetweenPages - spacing + this.bottomPadding + this.topPadding;
                x = box.x1 + leftEmptySpace + this.leftPadding;
            } else
                x += this._getHItemSize() + spacing;
        }
    },
    // Overriden from IconGrid
    _getChildrenToAnimate: function() {
        let children = this._getVisibleChildren();
        let firstIndex = this._childrenPerPage * this.currentPage;
        let lastIndex = firstIndex + this._childrenPerPage;
        return children.slice(firstIndex, lastIndex);
    },
    _computePages: function (availWidthPerPage, availHeightPerPage) {
        let [nColumns, usedWidth] = this._computeLayout(availWidthPerPage);
        let nRows;
        let children = this._getVisibleChildren();
        if (nColumns > 0)
            nRows = Math.ceil(children.length / nColumns);
        else
            nRows = 0;
        if (this._rowLimit)
            nRows = Math.min(nRows, this._rowLimit);
        let spacing = this._getSpacing();
        // We want to contain the grid inside the parent box with padding
        this._rowsPerPage = this.rowsForHeight(availHeightPerPage);
        this._nPages = Math.ceil(nRows / this._rowsPerPage);
        this._spaceBetweenPages = availHeightPerPage - (this.topPadding + this.bottomPadding) - this._availableHeightPerPageForItems();
        this._childrenPerPage = nColumns * this._rowsPerPage;
    },
    adaptToSize: function(availWidth, availHeight) {
        this.parent(availWidth, availHeight);
        this._computePages(availWidth, availHeight);
    },
    _availableHeightPerPageForItems: function() {
        return this.usedHeightForNRows(this._rowsPerPage) - (this.topPadding + this.bottomPadding);
    },
    nPages: function() {
        return this._nPages;
    },
    getPageHeight: function() {
        return this._availableHeightPerPageForItems();
    },
    getPageY: function(pageNumber) {
        if (!this._nPages)
            return 0;
        let firstPageItem = pageNumber * this._childrenPerPage
        let childBox = this._getVisibleChildren()[firstPageItem].get_allocation_box();
        return childBox.y1 - this.topPadding;
    },
    getItemPage: function(item) {
        let children = this._getVisibleChildren();
        let index = children.indexOf(item);
        if (index == -1) {
            throw new Error('Item not found.');
            return 0;
        }
        return Math.floor(index / this._childrenPerPage);
    },
    /**
    * openExtraSpace:
    * @sourceItem: the item for which to create extra space
    * @side: where @sourceItem should be located relative to the created space
    * @nRows: the amount of space to create
    *
    * Pan view to create extra space for @nRows above or below @sourceItem.
    */
    openExtraSpace: function(sourceItem, side, nRows) {
        let children = this._getVisibleChildren();
        let index = children.indexOf(sourceItem.actor);
        if (index == -1) {
            throw new Error('Item not found.');
            return;
        }
        let pageIndex = Math.floor(index / this._childrenPerPage);
        let pageOffset = pageIndex * this._childrenPerPage;
        let childrenPerRow = this._childrenPerPage / this._rowsPerPage;
        let sourceRow = Math.floor((index - pageOffset) / childrenPerRow);
        let nRowsAbove = (side == St.Side.TOP) ? sourceRow + 1
                                               : sourceRow;
        let nRowsBelow = this._rowsPerPage - nRowsAbove;
        let nRowsUp, nRowsDown;
        if (side == St.Side.TOP) {
            nRowsDown = Math.min(nRowsBelow, nRows);
            nRowsUp = nRows - nRowsDown;
        } else {
            nRowsUp = Math.min(nRowsAbove, nRows);
            nRowsDown = nRows - nRowsUp;
        }
        let childrenDown = children.splice(pageOffset +
                                           nRowsAbove * childrenPerRow,
                                           nRowsBelow * childrenPerRow);
        let childrenUp = children.splice(pageOffset,
                                         nRowsAbove * childrenPerRow);
        // Special case: On the last row with no rows below the icon,
        // there's no need to move any rows either up or down
        if (childrenDown.length == 0 && nRowsUp == 0) {
            this._translatedChildren = [];
            this.emit('space-opened');
        } else {
            this._translateChildren(childrenUp, Gtk.DirectionType.UP, nRowsUp);
            this._translateChildren(childrenDown, Gtk.DirectionType.DOWN, nRowsDown);
            this._translatedChildren = childrenUp.concat(childrenDown);
        }
    },
    _translateChildren: function(children, direction, nRows) {
        let translationY = nRows * (this._getVItemSize() + this._getSpacing());
        if (translationY == 0)
            return;
        if (direction == Gtk.DirectionType.UP)
            translationY *= -1;
        for (let i = 0; i < children.length; i++) {
            children[i].translation_y = 0;
            let params = { translation_y: translationY,
                           time: EXTRA_SPACE_ANIMATION_TIME,
                           transition: 'easeInOutQuad'
                         };
            if (i == (children.length - 1))
                params.onComplete = Lang.bind(this,
                    function() {
                        this.emit('space-opened');
                    });
            Tweener.addTween(children[i], params);
        }
    },
    closeExtraSpace: function() {
        if (!this._translatedChildren || !this._translatedChildren.length) {
            this.emit('space-closed');
            return;
        }
        for (let i = 0; i < this._translatedChildren.length; i++) {
            if (!this._translatedChildren[i].translation_y)
                continue;
            Tweener.addTween(this._translatedChildren[i],
                             { translation_y: 0,
                               time: EXTRA_SPACE_ANIMATION_TIME,
                               transition: 'easeInOutQuad',
                               onComplete: Lang.bind(this,
                                   function() {
                                       this.emit('space-closed');
                                   })
                             });
        }
    }
Signals.addSignalMethods(PaginatedIconGrid.prototype);
(uuay)legacyTray.js
const Clutter = imports.gi.Clutter;
const GLib = imports.gi.GLib;
const GObject = imports.gi.GObject;
const Meta = imports.gi.Meta;
const Shell = imports.gi.Shell;
const St = imports.gi.St;
const CtrlAltTab = imports.ui.ctrlAltTab;
const Lang = imports.lang;
const Layout = imports.ui.layout;
const Main = imports.ui.main;
const Overview = imports.ui.overview;
const OverviewControls = imports.ui.overviewControls;
const Tweener = imports.ui.tweener;
const STANDARD_TRAY_ICON_IMPLEMENTATIONS = {
    'bluetooth-applet': 'bluetooth',
    'gnome-volume-control-applet': 'volume', // renamed to gnome-sound-applet
                                             // when moved to control center
    'gnome-sound-applet': 'volume',
    'nm-applet': 'network',
    'gnome-power-manager': 'battery',
    'keyboard': 'keyboard',
    'a11y-keyboard': 'a11y',
    'kbd-scrolllock': 'keyboard',
    'kbd-numlock': 'keyboard',
    'kbd-capslock': 'keyboard',
    'ibus-ui-gtk': 'keyboard'
// Offset of the original position from the bottom-right corner
const CONCEALED_WIDTH = 3;
const REVEAL_ANIMATION_TIME = 0.2;
const TEMP_REVEAL_TIME = 2;
const BARRIER_THRESHOLD = 70;
const BARRIER_TIMEOUT = 1000;
const LegacyTray = new Lang.Class({
    Name: 'LegacyTray',
    _init: function() {
        this.actor = new St.Widget({ clip_to_allocation: true,
                                     layout_manager: new Clutter.BinLayout() });
        let constraint = new Layout.MonitorConstraint({ primary: true,
                                                        work_area: true });
        this.actor.add_constraint(constraint);
        this._slideLayout = new OverviewControls.SlideLayout();
        this._slideLayout.translationX = 0;
        this._slideLayout.slideDirection = OverviewControls.SlideDirection.LEFT;
        this._slider = new St.Widget({ x_expand: true, y_expand: true,
                                       x_align: Clutter.ActorAlign.START,
                                       y_align: Clutter.ActorAlign.END,
                                       layout_manager: this._slideLayout });
        this.actor.add_actor(this._slider);
        this._slider.connect('notify::allocation', Lang.bind(this, this._syncBarrier));
        this._box = new St.BoxLayout({ style_class: 'legacy-tray' });
        this._slider.add_actor(this._box);
        this._concealHandle = new St.Button({ style_class: 'legacy-tray-handle',
                                              /* translators: 'Hide' is a verb */
                                              accessible_name: _("Hide tray"),
                                              can_focus: true });
        this._concealHandle.child = new St.Icon({ icon_name: 'go-previous-symbolic' });
        this._box.add_child(this._concealHandle);
        this._iconBox = new St.BoxLayout({ style_class: 'legacy-tray-icon-box' });
        this._box.add_actor(this._iconBox);
        this._revealHandle = new St.Button({ style_class: 'legacy-tray-handle' });
        this._revealHandle.child = new St.Icon({ icon_name: 'go-next-symbolic' });
        this._box.add_child(this._revealHandle);
        this._revealHandle.bind_property('visible',
                                         this._concealHandle, 'visible',
                                         GObject.BindingFlags.BIDIRECTIONAL |
                                         GObject.BindingFlags.INVERT_BOOLEAN);
        this._revealHandle.connect('notify::visible',
                                   Lang.bind(this, this._sync));
        this._revealHandle.connect('notify::hover',
                                   Lang.bind(this ,this._sync));
        this._revealHandle.connect('clicked', Lang.bind(this,
            function() {
                this._concealHandle.show();
            }));
        this._concealHandle.connect('clicked', Lang.bind(this,
            function() {
                this._revealHandle.show();
            }));
        this._horizontalBarrier = null;
        this._pressureBarrier = new Layout.PressureBarrier(BARRIER_THRESHOLD,
                                                           BARRIER_TIMEOUT,
                                                           Shell.ActionMode.NORMAL);
        this._pressureBarrier.connect('trigger', Lang.bind(this, function() {
            this._concealHandle.show();
        }));
        Main.layoutManager.addChrome(this.actor, { affectsInputRegion: false });
        Main.layoutManager.trackChrome(this._slider, { affectsInputRegion: true });
        Main.uiGroup.set_child_below_sibling(this.actor, Main.layoutManager.modalDialogGroup);
        Main.ctrlAltTabManager.addGroup(this.actor,
                                        _("Status Icons"), 'focus-legacy-systray-symbolic',
                                        { sortGroup: CtrlAltTab.SortGroup.BOTTOM });
        this._trayManager = new Shell.TrayManager();
        this._trayIconAddedId = this._trayManager.connect('tray-icon-added', Lang.bind(this, this._onTrayIconAdded));
        this._trayIconRemovedId = this._trayManager.connect('tray-icon-removed', Lang.bind(this, this._onTrayIconRemoved));
        this._trayManager.manage_screen(global.screen, this.actor);
        Main.overview.connect('showing', Lang.bind(this,
            function() {
                Tweener.removeTweens(this._slider);
                Tweener.addTween(this._slider, { opacity: 0,
                                                 time: Overview.ANIMATION_TIME,
                                                 transition: 'easeOutQuad' });
            }));
        Main.overview.connect('shown', Lang.bind(this, this._sync));
        Main.overview.connect('hiding', Lang.bind(this,
            function() {
                this._sync();
                Tweener.removeTweens(this._slider);
                Tweener.addTween(this._slider, { opacity: 255,
                                                 time: Overview.ANIMATION_TIME,
                                                 transition: 'easeOutQuad' });
            }));
        Main.layoutManager.connect('monitors-changed',
                                   Lang.bind(this, this._sync));
        global.screen.connect('in-fullscreen-changed',
                              Lang.bind(this, this._sync));
        Main.sessionMode.connect('updated', Lang.bind(this, this._sync));
        this._sync();
    },
    _onTrayIconAdded: function(tm, icon) {
        let wmClass = icon.wm_class ? icon.wm_class.toLowerCase() : '';
        if (STANDARD_TRAY_ICON_IMPLEMENTATIONS[wmClass] !== undefined)
            return;
        let button = new St.Button({ child: icon,
                                     style_class: 'legacy-tray-icon',
                                     button_mask: St.ButtonMask.ONE |
                                                  St.ButtonMask.TWO |
                                                  St.ButtonMask.THREE,
                                     can_focus: true,
                                     x_fill: true, y_fill: true });
        let app = Shell.WindowTracker.get_default().get_app_from_pid(icon.pid);
        if (!app)
            app = Shell.AppSystem.get_default().lookup_startup_wmclass(wmClass);
        if (!app)
            app = Shell.AppSystem.get_default().lookup_desktop_wmclass(wmClass);
        if (app)
            button.accessible_name = app.get_name();
        else
            button.accessible_name = icon.title;
        button.connect('clicked',
            function() {
                icon.click(Clutter.get_current_event());
            });
        button.connect('key-press-event',
            function() {
                icon.click(Clutter.get_current_event());
                return Clutter.EVENT_PROPAGATE;
            });
        button.connect('key-focus-in', Lang.bind(this,
            function() {
                this._concealHandle.show();
            }));
        this._iconBox.add_actor(button);
        if (!this._concealHandle.visible) {
            this._concealHandle.show();
            GLib.timeout_add_seconds(GLib.PRIORITY_DEFAULT, TEMP_REVEAL_TIME,
                Lang.bind(this, function() {
                    this._concealHandle.hide();
                    return GLib.SOURCE_REMOVE;
                }));
        }
    },
    _onTrayIconRemoved: function(tm, icon) {
        if (!this.actor.contains(icon))
            return;
        icon.get_parent().destroy();
        this._sync();
    },
    _syncBarrier: function() {
        let rtl = (this._slider.get_text_direction() == Clutter.TextDirection.RTL);
        let [x, y] = this._slider.get_transformed_position();
        let [w, h] = this._slider.get_transformed_size();
        let x1 = Math.round(x);
        if (rtl)
            x1 += Math.round(w);
        let x2 = x1;
        let y1 = Math.round(y);
        let y2 = y1 + Math.round(h);
        if (this._horizontalBarrier &&
            this._horizontalBarrier.x1 == x1 &&
            this._horizontalBarrier.y1 == y1 &&
            this._horizontalBarrier.x2 == x2 &&
            this._horizontalBarrier.y2 == y2)
            return;
        this._unsetBarrier();
        let directions = (rtl ? Meta.BarrierDirection.NEGATIVE_X : Meta.BarrierDirection.POSITIVE_X);
        this._horizontalBarrier = new Meta.Barrier({ display: global.display,
                                                     x1: x1, x2: x2,
                                                     y1: y1, y2: y2,
                                                     directions: directions });
        this._pressureBarrier.addBarrier(this._horizontalBarrier);
    },
    _unsetBarrier: function() {
        if (this._horizontalBarrier == null)
            return;
        this._pressureBarrier.removeBarrier(this._horizontalBarrier);
        this._horizontalBarrier.destroy();
        this._horizontalBarrier = null;
    },
    _sync: function() {
        // FIXME: we no longer treat tray icons as notifications
        let allowed = Main.sessionMode.hasNotifications;
        let hasIcons = this._iconBox.get_n_children() > 0;
        let inOverview = Main.overview.visible && !Main.overview.animationInProgress;
        let inFullscreen = Main.layoutManager.primaryMonitor.inFullscreen;
        this.actor.visible = allowed && hasIcons && !inOverview && !inFullscreen;
        if (!hasIcons)
            this._concealHandle.hide();
        let targetSlide;
        if (this._concealHandle.visible) {
            targetSlide = 1.0;
        } else if (!hasIcons) {
            targetSlide = 0.0;
        } else {
            let [, boxWidth] = this._box.get_preferred_width(-1);
            let [, handleWidth] = this._revealHandle.get_preferred_width(-1);
            if (this._revealHandle.hover)
                targetSlide = handleWidth / boxWidth;
            else
                targetSlide = CONCEALED_WIDTH / boxWidth;
        }
        if (this.actor.visible) {
            Tweener.addTween(this._slideLayout,
                             { slideX: targetSlide,
                               time: REVEAL_ANIMATION_TIME,
                               transition: 'easeOutQuad' });
        } else {
            this._slideLayout.slideX = targetSlide;
            this._unsetBarrier();
        }
    }
(uuay)workspace.js
// -*- mode: js; js-indent-level: 4; indent-tabs-mode: nil -*-
const Clutter = imports.gi.Clutter;
const GLib = imports.gi.GLib;
const Lang = imports.lang;
const Mainloop = imports.mainloop;
const Meta = imports.gi.Meta;
const Pango = imports.gi.Pango;
const Shell = imports.gi.Shell;
const St = imports.gi.St;
const Atk = imports.gi.Atk;
const Signals = imports.signals;
const DND = imports.ui.dnd;
const Main = imports.ui.main;
const Overview = imports.ui.overview;
const Tweener = imports.ui.tweener;
const WindowManager = imports.ui.windowManager;
const WINDOW_DND_SIZE = 256;
const WINDOW_CLONE_MAXIMUM_SCALE = 0.7;
const CLOSE_BUTTON_FADE_TIME = 0.1;
const DRAGGING_WINDOW_OPACITY = 100;
// When calculating a layout, we calculate the scale of windows and the percent
// of the available area the new layout uses. If the values for the new layout,
// when weighted with the values as below, are worse than the previous layout's,
// we stop looking for a new layout and use the previous layout.
// Otherwise, we keep looking for a new layout.
const LAYOUT_SCALE_WEIGHT = 1;
const LAYOUT_SPACE_WEIGHT = 0.1;
const WINDOW_ANIMATION_MAX_NUMBER_BLENDING = 3;
function _interpolate(start, end, step) {
    return start + (end - start) * step;
const WindowCloneLayout = new Lang.Class({
    Name: 'WindowCloneLayout',
    Extends: Clutter.LayoutManager,
    _init: function(boundingBox) {
        this.parent();
        this._boundingBox = boundingBox;
    },
    get boundingBox() {
        return this._boundingBox;
    },
    set boundingBox(b) {
        this._boundingBox = b;
        this.layout_changed();
    },
    _makeBoxForWindow: function(window) {
        // We need to adjust the position of the actor because of the
        // consequences of invisible borders -- in reality, the texture
        // has an extra set of "padding" around it that we need to trim
        // down.
        // The outer rect (from which we compute the bounding box)
        // paradoxically is the smaller rectangle, containing the positions
        // of the visible frame. The input rect contains everything,
        // including the invisible border padding.
        let inputRect = window.get_buffer_rect();
        let box = new Clutter.ActorBox();
        box.set_origin(inputRect.x - this._boundingBox.x,
                       inputRect.y - this._boundingBox.y);
        box.set_size(inputRect.width, inputRect.height);
        return box;
    },
    vfunc_get_preferred_height: function(container, forWidth) {
        return [this._boundingBox.height, this._boundingBox.height];
    },
    vfunc_get_preferred_width: function(container, forHeight) {
        return [this._boundingBox.width, this._boundingBox.width];
    },
    vfunc_allocate: function(container, box, flags) {
        container.get_children().forEach(Lang.bind(this, function (child) {
            let realWindow;
            if (child == container._delegate._windowClone)
                realWindow = container._delegate.realWindow;
            else
                realWindow = child.source;
            child.allocate(this._makeBoxForWindow(realWindow.meta_window),
                           flags);
        }));
    }
const WindowClone = new Lang.Class({
    Name: 'WindowClone',
    _init : function(realWindow, workspace) {
        this.realWindow = realWindow;
        this.metaWindow = realWindow.meta_window;
        this.metaWindow._delegate = this;
        this._workspace = workspace;
        this._windowClone = new Clutter.Clone({ source: realWindow.get_texture() });
        // We expect this.actor to be used for all interaction rather than
        // this._windowClone; as the former is reactive and the latter
        // is not, this just works for most cases. However, for DND all
        // actors are picked, so DND operations would operate on the clone.
        // To avoid this, we hide it from pick.
        Shell.util_set_hidden_from_pick(this._windowClone, true);
        // The MetaShapedTexture that we clone has a size that includes
        // the invisible border; this is inconvenient; rather than trying
        // to compensate all over the place we insert a ClutterActor into
        // the hierarchy that is sized to only the visible portion.
        this.actor = new St.Widget({ reactive: true,
                                     can_focus: true,
                                     accessible_role: Atk.Role.PUSH_BUTTON,
                                     layout_manager: new WindowCloneLayout() });
        this.actor.add_child(this._windowClone);
        this.actor._delegate = this;
        this._slot = [0, 0, 0, 0];
        this._dragSlot = [0, 0, 0, 0];
        this._stackAbove = null;
        this._windowClone._updateId = this.metaWindow.connect('size-changed',
            Lang.bind(this, this._onRealWindowSizeChanged));
        this._windowClone._destroyId = this.realWindow.connect('destroy', Lang.bind(this, function() {
            // First destroy the clone and then destroy everything
            // This will ensure that we never see it in the _disconnectSignals loop
            this._windowClone.destroy();
            this.destroy();
        }));
        this._updateAttachedDialogs();
        this._computeBoundingBox();
        this.actor.x = this._boundingBox.x;
        this.actor.y = this._boundingBox.y;
        let clickAction = new Clutter.ClickAction();
        clickAction.connect('clicked', Lang.bind(this, this._onClicked));
        clickAction.connect('long-press', Lang.bind(this, this._onLongPress));
        this.actor.add_action(clickAction);
        this.actor.connect('destroy', Lang.bind(this, this._onDestroy));
        this.actor.connect('key-press-event', Lang.bind(this, this._onKeyPress));
        this._draggable = DND.makeDraggable(this.actor,
                                            { restoreOnSuccess: true,
                                              manualMode: true,
                                              dragActorMaxSize: WINDOW_DND_SIZE,
                                              dragActorOpacity: DRAGGING_WINDOW_OPACITY });
        this._draggable.connect('drag-begin', Lang.bind(this, this._onDragBegin));
        this._draggable.connect('drag-cancelled', Lang.bind(this, this._onDragCancelled));
        this._draggable.connect('drag-end', Lang.bind(this, this._onDragEnd));
        this.inDrag = false;
        this._selected = false;
    },
    set slot(slot) {
        this._slot = slot;
    },
    get slot() {
        if (this.inDrag)
            return this._dragSlot;
        else
            return this._slot;
    },
    deleteAll: function() {
        // Delete all windows, starting from the bottom-most (most-modal) one
        let windows = this.actor.get_children();
        for (let i = windows.length - 1; i >= 1; i--) {
            let realWindow = windows[i].source;
            let metaWindow = realWindow.meta_window;
            metaWindow.delete(global.get_current_time());
        }
        this.metaWindow.delete(global.get_current_time());
    },
    addAttachedDialog: function(win) {
        this._doAddAttachedDialog(win, win.get_compositor_private());
        this._computeBoundingBox();
        this.emit('size-changed');
    },
    hasAttachedDialogs: function() {
        return this.actor.get_n_children() > 1;
    },
    _doAddAttachedDialog: function(metaWin, realWin) {
        let clone = new Clutter.Clone({ source: realWin });
        clone._updateId = metaWin.connect('size-changed', Lang.bind(this, function() {
            this._computeBoundingBox();
            this.emit('size-changed');
        }));
        clone._destroyId = realWin.connect('destroy', Lang.bind(this, function() {
            clone.destroy();
            this._computeBoundingBox();
            this.emit('size-changed');
        }));
        this.actor.add_child(clone);
    },
    _updateAttachedDialogs: function() {
        let iter = Lang.bind(this, function(win) {
            let actor = win.get_compositor_private();
            if (!actor)
                return false;
            if (!win.is_attached_dialog())
                return false;
            this._doAddAttachedDialog(win, actor);
            win.foreach_transient(iter);
            return true;
        });
        this.metaWindow.foreach_transient(iter);
    },
    get boundingBox() {
        return this._boundingBox;
    },
    get width() {
        return this._boundingBox.width;
    },
    get height() {
        return this._boundingBox.height;
    },
    getOriginalPosition: function() {
        return [this._boundingBox.x, this._boundingBox.y];
    },
    _computeBoundingBox: function() {
        let rect = this.metaWindow.get_frame_rect();
        this.actor.get_children().forEach(function (child) {
            let realWindow;
            if (child == this._windowClone)
                realWindow = this.realWindow;
            else
                realWindow = child.source;
            let metaWindow = realWindow.meta_window;
            rect = rect.union(metaWindow.get_frame_rect());
        }, this);
        // Convert from a MetaRectangle to a native JS object
        this._boundingBox = { x: rect.x, y: rect.y, width: rect.width, height: rect.height };
        this.actor.layout_manager.boundingBox = rect;
    },
    // Find the actor just below us, respecting reparenting done
    // by DND code
    getActualStackAbove: function() {
        if (this._stackAbove == null)
            return null;
        if (this.inDrag) {
            if (this._stackAbove._delegate)
                return this._stackAbove._delegate.getActualStackAbove();
            else
                return null;
        } else {
            return this._stackAbove;
        }
    },
    setStackAbove: function (actor) {
        this._stackAbove = actor;
        if (this.inDrag)
            // We'll fix up the stack after the drag
            return;
        let actualAbove = this.getActualStackAbove();
        if (actualAbove == null)
            this.actor.lower_bottom();
        else
            this.actor.raise(actualAbove);
    },
    destroy: function () {
        this.actor.destroy();
    },
    _disconnectSignals: function() {
        this.actor.get_children().forEach(Lang.bind(this, function (child) {
            let realWindow;
            if (child == this._windowClone)
                realWindow = this.realWindow;
            else
                realWindow = child.source;
            realWindow.meta_window.disconnect(child._updateId);
            realWindow.disconnect(child._destroyId);
        }));
    },
    _onRealWindowSizeChanged: function() {
        this._computeBoundingBox();
        this.emit('size-changed');
    },
    _onDestroy: function() {
        this._disconnectSignals();
        this.metaWindow._delegate = null;
        this.actor._delegate = null;
        if (this.inDrag) {
            this.emit('drag-end');
            this.inDrag = false;
        }
        this.disconnectAll();
    },
    _activate: function() {
        this._selected = true;
        this.emit('selected', global.get_current_time());
    },
    _onKeyPress: function(actor, event) {
        let symbol = event.get_key_symbol();
        let isEnter = (symbol == Clutter.KEY_Return || symbol == Clutter.KEY_KP_Enter);
        if (isEnter) {
            this._activate();
            return true;
        }
        return false;
    },
    _onClicked: function(action, actor) {
        this._activate();
    },
    _onLongPress: function(action, actor, state) {
        // Take advantage of the Clutter policy to consider
        // a long-press canceled when the pointer movement
        // exceeds dnd-drag-threshold to manually start the drag
        if (state == Clutter.LongPressState.CANCEL) {
            let event = Clutter.get_current_event();
            this._dragTouchSequence = event.get_event_sequence();
            // A click cancels a long-press before any click handler is
            // run - make sure to not start a drag in that case
            Meta.later_add(Meta.LaterType.BEFORE_REDRAW, Lang.bind(this,
                function() {
                    if (this._selected)
                        return;
                    let [x, y] = action.get_coords();
                    action.release();
                    this._draggable.startDrag(x, y, global.get_current_time(), this._dragTouchSequence);
                }));
        }
        return true;
    },
    _onDragBegin : function (draggable, time) {
        this._dragSlot = this._slot;
        [this.dragOrigX, this.dragOrigY] = this.actor.get_position();
        this.dragOrigScale = this.actor.scale_x;
        this.inDrag = true;
        this.emit('drag-begin');
    },
    handleDragOver : function(source, actor, x, y, time) {
        return this._workspace.handleDragOver(source, actor, x, y, time);
    },
    acceptDrop : function(source, actor, x, y, time) {
        this._workspace.acceptDrop(source, actor, x, y, time);
    },
    _onDragCancelled : function (draggable, time) {
        this.emit('drag-cancelled');
    },
    _onDragEnd : function (draggable, time, snapback) {
        this.inDrag = false;
        // We may not have a parent if DnD completed successfully, in
        // which case our clone will shortly be destroyed and replaced
        // with a new one on the target workspace.
        if (this.actor.get_parent() != null) {
            if (this._stackAbove == null)
                this.actor.lower_bottom();
            else
                this.actor.raise(this._stackAbove);
        }
        this.emit('drag-end');
    }
Signals.addSignalMethods(WindowClone.prototype);
 * @windowClone: Corresponding window clone
 * @parentActor: The actor which will be the parent of all overlay items
 *               such as app icon and window caption
const WindowOverlay = new Lang.Class({
    Name: 'WindowOverlay',
    _init : function(windowClone, parentActor) {
        let metaWindow = windowClone.metaWindow;
        this._windowClone = windowClone;
        this._parentActor = parentActor;
        this._hidden = false;
        this.borderSize = 0;
        this.border = new St.Bin({ style_class: 'window-clone-border' });
        let title = new St.Label({ style_class: 'window-caption',
                                   text: metaWindow.title });
        title.clutter_text.ellipsize = Pango.EllipsizeMode.END;
        title._spacing = 0;
        windowClone.actor.label_actor = title;
        this._updateCaptionId = metaWindow.connect('notify::title',
            Lang.bind(this, function(w) {
                this.title.text = w.title;
                this.relayout(false);
            }));
        let button = new St.Button({ style_class: 'window-close' });
        button._overlap = 0;
        this._idleToggleCloseId = 0;
        button.connect('clicked', Lang.bind(this, this._closeWindow));
        windowClone.actor.connect('destroy', Lang.bind(this, this._onDestroy));
        windowClone.actor.connect('enter-event',
                                  Lang.bind(this, this._onEnter));
        windowClone.actor.connect('leave-event',
                                  Lang.bind(this, this._onLeave));
        windowClone.actor.connect('key-focus-in',
                                  Lang.bind(this, this._onEnter));
        windowClone.actor.connect('key-focus-out',
                                  Lang.bind(this, this._onLeave));
        this._windowAddedId = 0;
        button.hide();
        this.title = title;
        this.closeButton = button;
        parentActor.add_actor(this.title);
        parentActor.add_actor(this.border);
        parentActor.add_actor(this.closeButton);
        title.connect('style-changed',
                      Lang.bind(this, this._onStyleChanged));
        button.connect('style-changed',
                       Lang.bind(this, this._onStyleChanged));
        this.border.connect('style-changed', Lang.bind(this, this._onStyleChanged));
        // force a style change if we are already on a stage - otherwise
        // the signal will be emitted normally when we are added
        if (parentActor.get_stage())
            this._onStyleChanged();
    },
    hide: function() {
        this._hidden = true;
        this.title.hide();
        this.hideCloseButton();
    },
    show: function() {
        this._hidden = false;
        this.title.show();
        if (this._windowClone.actor.has_pointer)
            this._animateVisible();
    },
    chromeHeights: function () {
        return [Math.max(this.borderSize, this.closeButton.height - this.closeButton._overlap),
                this.title.height + this.title._spacing];
    },
    chromeWidths: function () {
        return [this.borderSize,
                Math.max(this.borderSize, this.closeButton.width - this.closeButton._overlap)];
    },
    relayout: function(animate) {
        let button = this.closeButton;
        let title = this.title;
        let border = this.border;
        Tweener.removeTweens(button);
        Tweener.removeTweens(border);
        Tweener.removeTweens(title);
        let [cloneX, cloneY, cloneWidth, cloneHeight] = this._windowClone.slot;
        let layout = Meta.prefs_get_button_layout();
        let side = layout.left_buttons.indexOf(Meta.ButtonFunction.CLOSE) > -1 ? St.Side.LEFT : St.Side.RIGHT;
        let buttonX;
        let buttonY = cloneY - (button.height - button._overlap);
        if (side == St.Side.LEFT)
            buttonX = cloneX - (button.width - button._overlap);
        else
            buttonX = cloneX + (cloneWidth - button._overlap);
        if (animate)
            this._animateOverlayActor(button, Math.floor(buttonX), Math.floor(buttonY), button.width);
        else
            button.set_position(Math.floor(buttonX), Math.floor(buttonY));
        // Clutter.Actor.get_preferred_width() will return the fixed width if one
        // is set, so we need to reset the width by calling set_width(-1), to forward
        // the call down to StLabel.
        // We also need to save and restore the current width, otherwise the animation
        // starts from the wrong point.
        let prevTitleWidth = title.width;
        title.set_width(-1);
        let [titleMinWidth, titleNatWidth] = title.get_preferred_width(-1);
        let titleWidth = Math.max(titleMinWidth, Math.min(titleNatWidth, cloneWidth));
        title.width = prevTitleWidth;
        let titleX = cloneX + (cloneWidth - titleWidth) / 2;
        let titleY = cloneY + cloneHeight + title._spacing;
        if (animate)
            this._animateOverlayActor(title, Math.floor(titleX), Math.floor(titleY), titleWidth);
        else {
            title.width = titleWidth;
            title.set_position(Math.floor(titleX), Math.floor(titleY));
        }
        let borderX = cloneX - this.borderSize;
        let borderY = cloneY - this.borderSize;
        let borderWidth = cloneWidth + 2 * this.borderSize;
        let borderHeight = cloneHeight + 2 * this.borderSize;
        if (animate) {
            this._animateOverlayActor(this.border, borderX, borderY,
                                      borderWidth, borderHeight);
        } else {
            this.border.set_position(borderX, borderY);
            this.border.set_size(borderWidth, borderHeight);
        }
    },
    _animateOverlayActor: function(actor, x, y, width, height) {
        let params = { x: x,
                       y: y,
                       width: width,
                       time: Overview.ANIMATION_TIME,
                       transition: 'easeOutQuad' };
        if (height !== undefined)
            params.height = height;
        Tweener.addTween(actor, params);
    },
    _closeWindow: function(actor) {
        let metaWindow = this._windowClone.metaWindow;
        this._workspace = metaWindow.get_workspace();
        this._windowAddedId = this._workspace.connect('window-added',
                                                      Lang.bind(this,
                                                                this._onWindowAdded));
        this._windowClone.deleteAll();
    },
    _windowCanClose: function() {
        return this._windowClone.metaWindow.can_close() &&
               !this._windowClone.hasAttachedDialogs();
    },
    _onWindowAdded: function(workspace, win) {
        let metaWindow = this._windowClone.metaWindow;
        if (win.get_transient_for() == metaWindow) {
            workspace.disconnect(this._windowAddedId);
            this._windowAddedId = 0;
            // use an idle handler to avoid mapping problems -
            // see comment in Workspace._windowAdded
            let id = Mainloop.idle_add(Lang.bind(this,
                                            function() {
                                                this._windowClone.emit('selected');
                                                return GLib.SOURCE_REMOVE;
                                            }));
            GLib.Source.set_name_by_id(id, '[gnome-shell] this._windowClone.emit');
        }
    },
    _onDestroy: function() {
        if (this._windowAddedId > 0) {
            this._workspace.disconnect(this._windowAddedId);
            this._windowAddedId = 0;
        }
        if (this._idleToggleCloseId > 0) {
            Mainloop.source_remove(this._idleToggleCloseId);
            this._idleToggleCloseId = 0;
        }
        this._windowClone.metaWindow.disconnect(this._updateCaptionId);
        this.title.destroy();
        this.closeButton.destroy();
        this.border.destroy();
    },
    _animateVisible: function() {
        this._parentActor.raise_top();
        if (this._windowCanClose()) {
            this.closeButton.show();
            this.closeButton.opacity = 0;
            Tweener.addTween(this.closeButton,
                             { opacity: 255,
                               time: CLOSE_BUTTON_FADE_TIME,
                               transition: 'easeOutQuad' });
        }
        this.border.show();
        this.border.opacity = 0;
        Tweener.addTween(this.border,
                         { opacity: 255,
                           time: CLOSE_BUTTON_FADE_TIME,
                           transition: 'easeOutQuad' });
        this.title.add_style_pseudo_class('hover');
    },
    _animateInvisible: function() {
        this.closeButton.opacity = 255;
        Tweener.addTween(this.closeButton,
                         { opacity: 0,
                           time: CLOSE_BUTTON_FADE_TIME,
                           transition: 'easeInQuad' });
        this.border.opacity = 255;
        Tweener.addTween(this.border,
                         { opacity: 0,
                           time: CLOSE_BUTTON_FADE_TIME,
                           transition: 'easeInQuad' });
        this.title.remove_style_pseudo_class('hover');
    },
    _onEnter: function() {
        // We might get enter events on the clone while the overlay is
        // hidden, e.g. during animations, we ignore these events,
        // as the close button will be shown as needed when the overlays
        // are shown again
        if (this._hidden)
            return Clutter.EVENT_PROPAGATE;
        this._animateVisible();
        this.emit('show-close-button');
        return Clutter.EVENT_PROPAGATE;
    },
    _onLeave: function() {
        if (this._idleToggleCloseId == 0) {
            this._idleToggleCloseId = Mainloop.timeout_add(750, Lang.bind(this, this._idleToggleCloseButton));
            GLib.Source.set_name_by_id(this._idleToggleCloseId, '[gnome-shell] this._idleToggleCloseButton');
        }
        return Clutter.EVENT_PROPAGATE;
    },
    _idleToggleCloseButton: function() {
        this._idleToggleCloseId = 0;
        if (!this._windowClone.actor.has_pointer &&
            !this.closeButton.has_pointer)
            this._animateInvisible();
        return GLib.SOURCE_REMOVE;
    },
    hideCloseButton: function() {
        if (this._idleToggleCloseId > 0) {
            Mainloop.source_remove(this._idleToggleCloseId);
            this._idleToggleCloseId = 0;
        }
        this.closeButton.hide();
        this.border.hide();
        this.title.remove_style_pseudo_class('hover');
    },
    _onStyleChanged: function() {
        let titleNode = this.title.get_theme_node();
        this.title._spacing = titleNode.get_length('-shell-caption-spacing');
        let closeNode = this.closeButton.get_theme_node();
        this.closeButton._overlap = closeNode.get_length('-shell-close-overlap');
        let borderNode = this.border.get_theme_node();
        this.borderSize = borderNode.get_border_width(St.Side.TOP);
        this._parentActor.queue_relayout();
    }
Signals.addSignalMethods(WindowOverlay.prototype);
const WindowPositionFlags = {
    NONE: 0,
    INITIAL: 1 << 0,
    ANIMATE: 1 << 1
// Window Thumbnail Layout Algorithm
// =================================
// General overview
// ----------------
// The window thumbnail layout algorithm calculates some optimal layout
// by computing layouts with some number of rows, calculating how good
// each layout is, and stopping iterating when it finds one that is worse
// than the previous layout. A layout consists of which windows are in
// which rows, row sizes and other general state tracking that would make
// calculating window positions from this information fairly easy.
// We don't compute some global order of windows right now for optimal
// travel when animating into the overview; windows are assumed to be
// in some stable order.
// After a layout is computed that's considered the best layout, we
// compute the layout scale to fit it in the area, and then compute
// slots (sizes and positions) for each thumbnail.
// Layout generation
// -----------------
// Layout generation is naive and simple: we simply add windows to a row
// until we've added too many windows to a row, and then make a new row,
// until we have our required N rows. The potential issue with this strategy
// is that we may have too many windows at the bottom in some pathological
// cases, which tends to make the thumbnails have the shape of a pile of
// sand with a peak, with one window at the top.
// Scaling factors
// ---------------
// Thumbnail position is mostly straightforward -- the main issue is
// computing an optimal scale for each window that fits the constraints,
// and doesn't make the thumbnail too small to see. There are two factors
// involved in thumbnail scale to make sure that these two goals are met:
// the window scale (calculated by _computeWindowScale) and the layout
// scale (calculated by computeSizeAndScale).
// The calculation logic becomes slightly more complicated because row
// and column spacing are not scaled, they're constant, so we can't
// simply generate a bunch of window positions and then scale it. In
// practice, it's not too bad -- we can simply try to fit the layout
// in the input area minus whatever spacing we have, and then add
// it back afterwards.
// The window scale is constant for the window's size regardless of the
// input area or the layout scale or rows or anything else, and right
// now just enlarges the window if it's too small. The fact that this
// factor is stable makes it easy to calculate, so there's no sense
// in not applying it in most calculations.
// The layout scale depends on the input area, the rows, etc, but is the
// same for the entire layout, rather than being per-window. After
// generating the rows of windows, we basically do some basic math to
// fit the full, unscaled layout to the input area, as described above.
// With these two factors combined, the final scale of each thumbnail is
// simply windowScale * layoutScale... almost.
// There's one additional constraint: the thumbnail scale must never be
// larger than WINDOW_CLONE_MAXIMUM_SCALE, which means that the inequality:
//   windowScale * layoutScale <= WINDOW_CLONE_MAXIMUM_SCALE
// must always be true. This is for each individual window -- while we
// could adjust layoutScale to make the largest thumbnail smaller than
// WINDOW_CLONE_MAXIMUM_SCALE, it would shrink windows which are already
// under the inequality. To solve this, we simply cheat: we simply keep
// each window's "cell" area to be the same, but we shrink the thumbnail
// and center it horizontally, and align it to the bottom vertically.
const LayoutStrategy = new Lang.Class({
    Name: 'LayoutStrategy',
    Abstract: true,
    _init: function(monitor, rowSpacing, columnSpacing) {
        this._monitor = monitor;
        this._rowSpacing = rowSpacing;
        this._columnSpacing = columnSpacing;
    },
    _newRow: function() {
        // Row properties:
        //
        // * x, y are the position of row, relative to area
        //
        // * width, height are the scaled versions of fullWidth, fullHeight
        //
        // * width also has the spacing in between windows. It's not in
        //   fullWidth, as the spacing is constant, whereas fullWidth is
        //   meant to be scaled
        //
        // * neither height/fullHeight have any sort of spacing or padding
        return { x: 0, y: 0,
                 width: 0, height: 0,
                 fullWidth: 0, fullHeight: 0,
                 windows: [] };
    },
    // Computes and returns an individual scaling factor for @window,
    // to be applied in addition to the overal layout scale.
    _computeWindowScale: function(window) {
        // Since we align windows next to each other, the height of the
        // thumbnails is much more important to preserve than the width of
        // them, so two windows with equal height, but maybe differering
        // widths line up.
        let ratio = window.height / this._monitor.height;
        // The purpose of this manipulation here is to prevent windows
        // from getting too small. For something like a calculator window,
        // we need to bump up the size just a bit to make sure it looks
        // good. We'll use a multiplier of 1.5 for this.
        // Map from [0, 1] to [1.5, 1]
        return _interpolate(1.5, 1, ratio);
    },
    // Compute the size of each row, by assigning to the properties
    // row.width, row.height, row.fullWidth, row.fullHeight, and
    // (optionally) for each row in @layout.rows. This method is
    // intended to be called by subclasses.
    _computeRowSizes: function(layout) {
        throw new Error('_computeRowSizes not implemented');
    },
    // Compute strategy-specific window slots for each window in
    // @windows, given the @layout. The strategy may also use @layout
    // as strategy-specific storage.
    //
    // This must calculate:
    //  * maxColumns - The maximum number of columns used by the layout.
    //  * gridWidth - The total width used by the grid, unscaled, unspaced.
    //  * gridHeight - The totial height used by the grid, unscaled, unspaced.
    //  * rows - A list of rows, which should be instantiated by _newRow.
    computeLayout: function(windows, layout) {
        throw new Error('computeLayout not implemented');
    },
    // Given @layout, compute the overall scale and space of the layout.
    // The scale is the individual, non-fancy scale of each window, and
    // the space is the percentage of the available area eventually
    // used by the layout.
    // This method does not return anything, but instead installs
    // the properties "scale" and "space" on @layout directly.
    //
    // Make sure to call this methods before calling computeWindowSlots(),
    // as it depends on the scale property installed in @layout here.
    computeScaleAndSpace: function(layout) {
        let area = layout.area;
        let hspacing = (layout.maxColumns - 1) * this._columnSpacing;
        let vspacing = (layout.numRows - 1) * this._rowSpacing;
        let spacedWidth = area.width - hspacing;
        let spacedHeight = area.height - vspacing;
        let horizontalScale = spacedWidth / layout.gridWidth;
        let verticalScale = spacedHeight / layout.gridHeight;
        // Thumbnails should be less than 70% of the original size
        let scale = Math.min(horizontalScale, verticalScale, WINDOW_CLONE_MAXIMUM_SCALE);
        let scaledLayoutWidth = layout.gridWidth * scale + hspacing;
        let scaledLayoutHeight = layout.gridHeight * scale + vspacing;
        let space = (scaledLayoutWidth * scaledLayoutHeight) / (area.width * area.height);
        layout.scale = scale;
        layout.space = space;
    },
    computeWindowSlots: function(layout, area) {
        this._computeRowSizes(layout);
        let { rows: rows, scale: scale } = layout;
        let slots = [];
        // Do this in three parts.
        let heightWithoutSpacing = 0;
        for (let i = 0; i < rows.length; i++) {
            let row = rows[i];
            heightWithoutSpacing += row.height;
        }
        let verticalSpacing = (rows.length - 1) * this._rowSpacing;
        let additionalVerticalScale = Math.min(1, (area.height - verticalSpacing) / heightWithoutSpacing);
        // keep track how much smaller the grid becomes due to scaling
        // so it can be centered again
        let compensation = 0
        let y = 0;
        for (let i = 0; i < rows.length; i++) {
            let row = rows[i];
            // If this window layout row doesn't fit in the actual
            // geometry, then apply an additional scale to it.
            let horizontalSpacing = (row.windows.length - 1) * this._columnSpacing;
            let widthWithoutSpacing = row.width - horizontalSpacing;
            let additionalHorizontalScale = Math.min(1, (area.width - horizontalSpacing) / widthWithoutSpacing);
            if (additionalHorizontalScale < additionalVerticalScale) {
                row.additionalScale = additionalHorizontalScale;
                // Only consider the scaling in addition to the vertical scaling for centering.
                compensation += (additionalVerticalScale - additionalHorizontalScale) * row.height;
            } else {
                row.additionalScale = additionalVerticalScale;
                // No compensation when scaling vertically since centering based on a too large
                // height would undo what vertical scaling is trying to achieve.
            }
            row.x = area.x + (Math.max(area.width - (widthWithoutSpacing * row.additionalScale + horizontalSpacing), 0) / 2)
            row.y = area.y + (Math.max(area.height - (heightWithoutSpacing + verticalSpacing), 0) / 2) + y;
            y += row.height * row.additionalScale + this._rowSpacing;
        }
        compensation = compensation / 2;
        for (let i = 0; i < rows.length; i++) {
            let row = rows[i];
            let x = row.x;
            for (let j = 0; j < row.windows.length; j++) {
                let window = row.windows[j];
                let s = scale * this._computeWindowScale(window) * row.additionalScale;
                let cellWidth = window.width * s;
                let cellHeight = window.height * s;
                s = Math.min(s, WINDOW_CLONE_MAXIMUM_SCALE);
                let cloneWidth = window.width * s;
                let cloneX = x + (cellWidth - cloneWidth) / 2;
                let cloneY = row.y + row.height * row.additionalScale - cellHeight + compensation;
                slots.push([cloneX, cloneY, s, window]);
                x += cellWidth + this._columnSpacing;
            }
        }
        return slots;
    }
const UnalignedLayoutStrategy = new Lang.Class({
    Name: 'UnalignedLayoutStrategy',
    Extends: LayoutStrategy,
    _computeRowSizes: function(layout) {
        let { rows: rows, scale: scale } = layout;
        for (let i = 0; i < rows.length; i++) {
            let row = rows[i];
            row.width = row.fullWidth * scale + (row.windows.length - 1) * this._columnSpacing;
            row.height = row.fullHeight * scale;
        }
    },
    _keepSameRow: function(row, window, width, idealRowWidth) {
        if (row.fullWidth + width <= idealRowWidth)
            return true;
        let oldRatio = row.fullWidth / idealRowWidth;
        let newRatio = (row.fullWidth + width) / idealRowWidth;
        if (Math.abs(1 - newRatio) < Math.abs(1 - oldRatio))
            return true;
        return false;
    },
    _sortRow: function(row) {
        // Sort windows horizontally to minimize travel distance
        row.windows.sort(function(a, b) {
            return a.realWindow.x - b.realWindow.x;
        });
    },
    computeLayout: function(windows, layout) {
        let numRows = layout.numRows;
        let rows = [];
        let totalWidth = 0;
        for (let i = 0; i < windows.length; i++) {
            let window = windows[i];
            let s = this._computeWindowScale(window);
            totalWidth += window.width * s;
        }
        let idealRowWidth = totalWidth / numRows;
        let windowIdx = 0;
        for (let i = 0; i < numRows; i++) {
            let col = 0;
            let row = this._newRow();
            rows.push(row);
            for (; windowIdx < windows.length; windowIdx++) {
                let window = windows[windowIdx];
                let s = this._computeWindowScale(window);
                let width = window.width * s;
                let height = window.height * s;
                row.fullHeight = Math.max(row.fullHeight, height);
                // either new width is < idealWidth or new width is nearer from idealWidth then oldWidth
                if (this._keepSameRow(row, window, width, idealRowWidth) || (i == numRows - 1)) {
                    row.windows.push(window);
                    row.fullWidth += width;
                } else {
                    break;
                }
            }
        }
        let gridHeight = 0;
        let maxRow;
        for (let i = 0; i < numRows; i++) {
            let row = rows[i];
            this._sortRow(row);
            if (!maxRow || row.fullWidth > maxRow.fullWidth)
                maxRow = row;
            gridHeight += row.fullHeight;
        }
        layout.rows = rows;
        layout.maxColumns = maxRow.windows.length;
        layout.gridWidth = maxRow.fullWidth;
        layout.gridHeight = gridHeight;
    }
function padArea(area, padding) {
    return {
        x: area.x + padding.left,
        y: area.y + padding.top,
        width: area.width - padding.left - padding.right,
        height: area.height - padding.top - padding.bottom,
    };
function rectEqual(one, two) {
    if (one == two)
        return true;
    if (!one || !two)
        return false;
    return (one.x == two.x &&
            one.y == two.y &&
            one.width == two.width &&
            one.height == two.height);
 * @metaWorkspace: a #Meta.Workspace, or null
const Workspace = new Lang.Class({
    Name: 'Workspace',
    _init : function(metaWorkspace, monitorIndex) {
        // When dragging a window, we use this slot for reserve space.
        this._reservedSlot = null;
        this.metaWorkspace = metaWorkspace;
        // The full geometry is the geometry we should try and position
        // windows for. The actual geometry we allocate may be less than
        // this, like if the workspace switcher is slid out.
        this._fullGeometry = null;
        // The actual geometry is the geometry we need to arrange windows
        // in. If this is a smaller area than the full geometry, we'll
        // do some simple aspect ratio like math to fit the layout calculated
        // for the full geometry into this area.
        this._actualGeometry = null;
        this._currentLayout = null;
        this.monitorIndex = monitorIndex;
        this._monitor = Main.layoutManager.monitors[this.monitorIndex];
        this._windowOverlaysGroup = new Clutter.Actor();
        // Without this the drop area will be overlapped.
        this._windowOverlaysGroup.set_size(0, 0);
        this.actor = new St.Widget({ style_class: 'window-picker' });
        if (monitorIndex != Main.layoutManager.primaryIndex)
            this.actor.add_style_class_name('external-monitor');
        this.actor.set_size(0, 0);
        this._dropRect = new Clutter.Actor({ opacity: 0 });
        this._dropRect._delegate = this;
        this.actor.add_actor(this._dropRect);
        this.actor.add_actor(this._windowOverlaysGroup);
        this.actor.connect('destroy', Lang.bind(this, this._onDestroy));
        let windows = global.get_window_actors().filter(this._isMyWindow, this);
        // Create clones for windows that should be
        // visible in the Overview
        this._windows = [];
        this._windowOverlays = [];
        for (let i = 0; i < windows.length; i++) {
            if (this._isOverviewWindow(windows[i])) {
                this._addWindowClone(windows[i], true);
            }
        }
        // Track window changes
        if (this.metaWorkspace) {
            this._windowAddedId = this.metaWorkspace.connect('window-added',
                                                             Lang.bind(this, this._windowAdded));
            this._windowRemovedId = this.metaWorkspace.connect('window-removed',
                                                               Lang.bind(this, this._windowRemoved));
        }
        this._windowEnteredMonitorId = global.screen.connect('window-entered-monitor',
                                                             Lang.bind(this, this._windowEnteredMonitor));
        this._windowLeftMonitorId = global.screen.connect('window-left-monitor',
                                                          Lang.bind(this, this._windowLeftMonitor));
        this._repositionWindowsId = 0;
        this.leavingOverview = false;
        this._positionWindowsFlags = 0;
        this._positionWindowsId = 0;
        this.actor.connect('notify::mapped', Lang.bind(this, function() {
            if (this.actor.mapped)
                this._syncActualGeometry();
        }));
    },
    setFullGeometry: function(geom) {
        if (rectEqual(this._fullGeometry, geom))
            return;
        this._fullGeometry = geom;
        if (this.actor.mapped)
            this._recalculateWindowPositions(WindowPositionFlags.NONE);
    },
    setActualGeometry: function(geom) {
        if (rectEqual(this._actualGeometry, geom))
            return;
        this._actualGeometry = geom;
        this._actualGeometryDirty = true;
        if (this.actor.mapped)
            this._syncActualGeometry();
    },
    _syncActualGeometry: function() {
        if (this._actualGeometryLater || !this._actualGeometryDirty)
            return;
        if (!this._actualGeometry)
            return;
        this._actualGeometryLater = Meta.later_add(Meta.LaterType.BEFORE_REDRAW, Lang.bind(this, function() {
            this._actualGeometryLater = 0;
            if (!this.actor.mapped)
                return false;
            let geom = this._actualGeometry;
            this._dropRect.set_position(geom.x, geom.y);
            this._dropRect.set_size(geom.width, geom.height);
            this._updateWindowPositions(Main.overview.animationInProgress ? WindowPositionFlags.ANIMATE : WindowPositionFlags.NONE);
            return false;
        }));
    },
    _lookupIndex: function (metaWindow) {
        for (let i = 0; i < this._windows.length; i++) {
            if (this._windows[i].metaWindow == metaWindow) {
                return i;
            }
        }
        return -1;
    },
    containsMetaWindow: function (metaWindow) {
        return this._lookupIndex(metaWindow) >= 0;
    },
    isEmpty: function() {
        return this._windows.length == 0;
    },
    setReservedSlot: function(metaWindow) {
        if (this._reservedSlotWindow == metaWindow)
            return;
        if (!metaWindow || this.containsMetaWindow(metaWindow)) {
            this._reservedSlotWindow = null;
            this._reservedSlot = null;
        } else {
            this._reservedSlotWindow = metaWindow;
            this._reservedSlot = this._windows[this._lookupIndex(metaWindow)];
        }
        this._recalculateWindowPositions(WindowPositionFlags.ANIMATE);
    },
    _recalculateWindowPositions: function(flags) {
        this._positionWindowsFlags |= flags;
        if (this._positionWindowsId > 0)
            return;
        this._positionWindowsId = Meta.later_add(Meta.LaterType.BEFORE_REDRAW, Lang.bind(this, function() {
            this._realRecalculateWindowPositions(this._positionWindowsFlags);
            this._positionWindowsFlags = 0;
            this._positionWindowsId = 0;
            return false;
        }));
    },
    _realRecalculateWindowPositions: function(flags) {
        if (this._repositionWindowsId > 0) {
            Mainloop.source_remove(this._repositionWindowsId);
            this._repositionWindowsId = 0;
        }
        let clones = this._windows.slice();
        if (clones.length == 0)
            return;
        clones.sort(function(a, b) {
            return a.metaWindow.get_stable_sequence() - b.metaWindow.get_stable_sequence();
        });
        if (this._reservedSlot)
            clones.push(this._reservedSlot);
        this._currentLayout = this._computeLayout(clones);
        this._updateWindowPositions(flags);
    },
    _updateWindowPositions: function(flags) {
        if (this._currentLayout == null) {
            this._recalculateWindowPositions(flags);
            return;
        }
        // We will reposition windows anyway when enter again overview or when ending the windows
        // animations whith fade animation.
        // In this way we avoid unwanted animations of windows repositioning while
        // animating overview.
        if (this.leavingOverview || this._animatingWindowsFade)
            return;
        let initialPositioning = flags & WindowPositionFlags.INITIAL;
        let animate = flags & WindowPositionFlags.ANIMATE;
        let layout = this._currentLayout;
        let strategy = layout.strategy;
        let [, , padding] = this._getSpacingAndPadding();
        let area = padArea(this._actualGeometry, padding);
        let slots = strategy.computeWindowSlots(layout, area);
        let currentWorkspace = global.screen.get_active_workspace();
        let isOnCurrentWorkspace = this.metaWorkspace == null || this.metaWorkspace == currentWorkspace;
        for (let i = 0; i < slots.length; i++) {
            let slot = slots[i];
            let [x, y, scale, clone] = slot;
            let metaWindow = clone.metaWindow;
            let overlay = clone.overlay;
            clone.slotId = i;
            // Positioning a window currently being dragged must be avoided;
            // we'll just leave a blank spot in the layout for it.
            if (clone.inDrag)
                continue;
            let cloneWidth = clone.actor.width * scale;
            let cloneHeight = clone.actor.height * scale;
            clone.slot = [x, y, cloneWidth, cloneHeight];
            if (overlay && (initialPositioning || !clone.positioned))
                overlay.hide();
            if (!clone.positioned) {
                // This window appeared after the overview was already up
                // Grow the clone from the center of the slot
                clone.actor.x = x + cloneWidth / 2;
                clone.actor.y = y + cloneHeight / 2;
                clone.actor.scale_x = 0;
                clone.actor.scale_y = 0;
                clone.positioned = true;
            }
            if (animate && isOnCurrentWorkspace) {
                if (!metaWindow.showing_on_its_workspace()) {
                    /* Hidden windows should fade in and grow
                     * therefore we need to resize them now so they
                     * can be scaled up later */
                    if (initialPositioning) {
                        clone.actor.opacity = 0;
                        clone.actor.scale_x = 0;
                        clone.actor.scale_y = 0;
                        clone.actor.x = x;
                        clone.actor.y = y;
                    }
                    Tweener.addTween(clone.actor,
                                     { opacity: 255,
                                       time: Overview.ANIMATION_TIME,
                                       transition: 'easeInQuad'
                                     });
                }
                this._animateClone(clone, overlay, x, y, scale);
            } else {
                // cancel any active tweens (otherwise they might override our changes)
                Tweener.removeTweens(clone.actor);
                clone.actor.set_position(x, y);
                clone.actor.set_scale(scale, scale);
                clone.actor.set_opacity(255);
                clone.overlay.relayout(false);
                this._showWindowOverlay(clone, overlay);
            }
        }
    },
    syncStacking: function(stackIndices) {
        let clones = this._windows.slice();
        clones.sort(function (a, b) { return stackIndices[a.metaWindow.get_stable_sequence()] - stackIndices[b.metaWindow.get_stable_sequence()]; });
        for (let i = 0; i < clones.length; i++) {
            let clone = clones[i];
            let metaWindow = clone.metaWindow;
            if (i == 0) {
                clone.setStackAbove(this._dropRect);
            } else {
                let previousClone = clones[i - 1];
                clone.setStackAbove(previousClone.actor);
            }
        }
    },
    _animateClone: function(clone, overlay, x, y, scale) {
        Tweener.addTween(clone.actor,
                         { x: x,
                           y: y,
                           scale_x: scale,
                           scale_y: scale,
                           time: Overview.ANIMATION_TIME,
                           transition: 'easeOutQuad',
                           onComplete: Lang.bind(this, function() {
                               this._showWindowOverlay(clone, overlay);
                           })
                         });
        clone.overlay.relayout(true);
    },
    _showWindowOverlay: function(clone, overlay) {
        if (clone.inDrag)
            return;
        if (overlay && overlay._hidden)
                overlay.show();
    },
    _delayedWindowRepositioning: function() {
        let [x, y, mask] = global.get_pointer();
        let pointerHasMoved = (this._cursorX != x && this._cursorY != y);
        let inWorkspace = (this._fullGeometry.x < x && x < this._fullGeometry.x + this._fullGeometry.width &&
                           this._fullGeometry.y < y && y < this._fullGeometry.y + this._fullGeometry.height);
        if (pointerHasMoved && inWorkspace) {
            // store current cursor position
            this._cursorX = x;
            this._cursorY = y;
            return GLib.SOURCE_CONTINUE;
        }
        let actorUnderPointer = global.stage.get_actor_at_pos(Clutter.PickMode.REACTIVE, x, y);
        for (let i = 0; i < this._windows.length; i++) {
            if (this._windows[i].actor == actorUnderPointer)
                return GLib.SOURCE_CONTINUE;
        }
        this._recalculateWindowPositions(WindowPositionFlags.ANIMATE);
        this._repositionWindowsId = 0;
        return GLib.SOURCE_REMOVE;
    },
    _doRemoveWindow : function(metaWin) {
        let win = metaWin.get_compositor_private();
        // find the position of the window in our list
        let index = this._lookupIndex (metaWin);
        if (index == -1)
            return;
        let clone = this._windows[index];
        this._windows.splice(index, 1);
        this._windowOverlays.splice(index, 1);
        // If metaWin.get_compositor_private() returned non-NULL, that
        // means the window still exists (and is just being moved to
        // another workspace or something), so set its overviewHint
        // accordingly. (If it returned NULL, then the window is being
        // destroyed; we'd like to animate this, but it's too late at
        // this point.)
        if (win) {
            let [stageX, stageY] = clone.actor.get_transformed_position();
            let [stageWidth, stageHeight] = clone.actor.get_transformed_size();
            win._overviewHint = {
                x: stageX,
                y: stageY,
                scale: stageWidth / clone.actor.width
            };
        }
        clone.destroy();
        // We need to reposition the windows; to avoid shuffling windows
        // around while the user is interacting with the workspace, we delay
        // the positioning until the pointer remains still for at least 750 ms
        // or is moved outside the workspace
        // remove old handler
        if (this._repositionWindowsId > 0) {
            Mainloop.source_remove(this._repositionWindowsId);
            this._repositionWindowsId = 0;
        }
        // setup new handler
        let [x, y, mask] = global.get_pointer();
        this._cursorX = x;
        this._cursorY = y;
        this._currentLayout = null;
        this._repositionWindowsId = Mainloop.timeout_add(750,
            Lang.bind(this, this._delayedWindowRepositioning));
        GLib.Source.set_name_by_id(this._repositionWindowsId, '[gnome-shell] this._delayedWindowRepositioning');
    },
    _doAddWindow : function(metaWin) {
        if (this.leavingOverview)
            return;
        let win = metaWin.get_compositor_private();
        if (!win) {
            // Newly-created windows are added to a workspace before
            // the compositor finds out about them...
            let id = Mainloop.idle_add(Lang.bind(this,
                                            function () {
                                                if (this.actor &&
                                                    metaWin.get_compositor_private() &&
                                                    metaWin.get_workspace() == this.metaWorkspace)
                                                    this._doAddWindow(metaWin);
                                                return GLib.SOURCE_REMOVE;
                                            }));
            GLib.Source.set_name_by_id(id, '[gnome-shell] this._doAddWindow');
            return;
        }
        // We might have the window in our list already if it was on all workspaces and
        // now was moved to this workspace
        if (this._lookupIndex (metaWin) != -1)
            return;
        if (!this._isMyWindow(win))
            return;
        if (!this._isOverviewWindow(win)) {
            if (metaWin.is_attached_dialog()) {
                let parent = metaWin.get_transient_for();
                while (parent.is_attached_dialog())
                    parent = metaWin.get_transient_for();
                let idx = this._lookupIndex (parent);
                if (idx < 0) {
                    // parent was not created yet, it will take care
                    // of the dialog when created
                    return;
                }
                let clone = this._windows[idx];
                clone.addAttachedDialog(metaWin);
            }
            return;
        }
        let [clone, overlay] = this._addWindowClone(win, false);
        if (win._overviewHint) {
            let x = win._overviewHint.x - this.actor.x;
            let y = win._overviewHint.y - this.actor.y;
            let scale = win._overviewHint.scale;
            delete win._overviewHint;
            clone.slot = [x, y, clone.actor.width * scale, clone.actor.height * scale];
            clone.positioned = true;
            clone.actor.set_position (x, y);
            clone.actor.set_scale (scale, scale);
            clone.overlay.relayout(false);
        }
        this._currentLayout = null;
        this._recalculateWindowPositions(WindowPositionFlags.ANIMATE);
    },
    _windowAdded : function(metaWorkspace, metaWin) {
        this._doAddWindow(metaWin);
    },
    _windowRemoved : function(metaWorkspace, metaWin) {
        this._doRemoveWindow(metaWin);
    },
    _windowEnteredMonitor : function(metaScreen, monitorIndex, metaWin) {
        if (monitorIndex == this.monitorIndex) {
            this._doAddWindow(metaWin);
        }
    },
    _windowLeftMonitor : function(metaScreen, monitorIndex, metaWin) {
        if (monitorIndex == this.monitorIndex) {
            this._doRemoveWindow(metaWin);
        }
    },
    // check for maximized windows on the workspace
    hasMaximizedWindows: function() {
        for (let i = 0; i < this._windows.length; i++) {
            let metaWindow = this._windows[i].metaWindow;
            if (metaWindow.showing_on_its_workspace() &&
                metaWindow.maximized_horizontally &&
                metaWindow.maximized_vertically)
                return true;
        }
        return false;
    },
    fadeToOverview: function() {
        // We don't want to reposition windows while animating in this way.
        this._animatingWindowsFade = true;
        this._overviewShownId = Main.overview.connect('shown', Lang.bind(this,
                                                                         this._doneShowingOverview));
        if (this._windows.length == 0)
            return;
        if (this.metaWorkspace != null && this.metaWorkspace != global.screen.get_active_workspace())
            return;
        // Special case maximized windows, since it doesn't make sense
        // to animate windows below in the stack
        let topMaximizedWindow;
        // It is ok to treat the case where there is no maximized
        // window as if the bottom-most window was maximized given that
        // it won't affect the result of the animation
        for (topMaximizedWindow = this._windows.length - 1; topMaximizedWindow > 0; topMaximizedWindow--) {
            let metaWindow = this._windows[topMaximizedWindow].metaWindow;
            if (metaWindow.maximized_horizontally && metaWindow.maximized_vertically)
                break;
        }
        let nTimeSlots = Math.min(WINDOW_ANIMATION_MAX_NUMBER_BLENDING + 1, this._windows.length - topMaximizedWindow);
        let windowBaseTime = Overview.ANIMATION_TIME / nTimeSlots;
        let topIndex = this._windows.length - 1;
        for (let i = 0; i < this._windows.length; i++) {
            if (i < topMaximizedWindow) {
                // below top-most maximized window, don't animate
                let overlay = this._windowOverlays[i];
                if (overlay)
                    overlay.hide();
                this._windows[i].actor.opacity = 0;
            } else {
                let fromTop = topIndex - i;
                let time;
                if (fromTop < nTimeSlots) // animate top-most windows gradually
                    time = windowBaseTime * (nTimeSlots - fromTop);
                else
                    time = windowBaseTime;
                this._windows[i].actor.opacity = 255;
                this._fadeWindow(i, time, 0);
            }
        }
    },
    fadeFromOverview: function() {
        this.leavingOverview = true;
        this._overviewHiddenId = Main.overview.connect('hidden', Lang.bind(this,
                                                                           this._doneLeavingOverview));
        if (this._windows.length == 0)
            return;
        for (let i = 0; i < this._windows.length; i++) {
            let clone = this._windows[i];
            Tweener.removeTweens(clone.actor);
        }
        if (this._repositionWindowsId > 0) {
            Mainloop.source_remove(this._repositionWindowsId);
            this._repositionWindowsId = 0;
        }
        if (this.metaWorkspace != null && this.metaWorkspace != global.screen.get_active_workspace())
            return;
        // Special case maximized windows, since it doesn't make sense
        // to animate windows below in the stack
        let topMaximizedWindow;
        // It is ok to treat the case where there is no maximized
        // window as if the bottom-most window was maximized given that
        // it won't affect the result of the animation
        for (topMaximizedWindow = this._windows.length - 1; topMaximizedWindow > 0; topMaximizedWindow--) {
            let metaWindow = this._windows[topMaximizedWindow].metaWindow;
            if (metaWindow.maximized_horizontally && metaWindow.maximized_vertically)
                break;
        }
        let nTimeSlots = Math.min(WINDOW_ANIMATION_MAX_NUMBER_BLENDING + 1, this._windows.length - topMaximizedWindow);
        let windowBaseTime = Overview.ANIMATION_TIME / nTimeSlots;
        let topIndex = this._windows.length - 1;
        for (let i = 0; i < this._windows.length; i++) {
            if (i < topMaximizedWindow) {
                // below top-most maximized window, don't animate
                let overlay = this._windowOverlays[i];
                if (overlay)
                    overlay.hide();
                this._windows[i].actor.opacity = 0;
            } else {
                let fromTop = topIndex - i;
                let time;
                if (fromTop < nTimeSlots) // animate top-most windows gradually
                    time = windowBaseTime * (fromTop + 1);
                else
                    time = windowBaseTime * nTimeSlots;
                this._windows[i].actor.opacity = 0;
                this._fadeWindow(i, time, 255);
            }
        }
    },
    _fadeWindow: function(index, time, opacity) {
        let clone = this._windows[index];
        let overlay = this._windowOverlays[index];
        if (overlay)
            overlay.hide();
        if (clone.metaWindow.showing_on_its_workspace()) {
            let [origX, origY] = clone.getOriginalPosition();
            clone.actor.scale_x = 1;
            clone.actor.scale_y = 1;
            clone.actor.x = origX;
            clone.actor.y = origY;
            Tweener.addTween(clone.actor,
                             { time: time,
                               opacity: opacity,
                               transition: 'easeOutQuad'
                             });
        } else {
            // The window is hidden
            clone.actor.opacity = 0;
        }
    },
    zoomToOverview: function() {
        // Position and scale the windows.
        this._recalculateWindowPositions(WindowPositionFlags.ANIMATE | WindowPositionFlags.INITIAL);
    },
    zoomFromOverview: function() {
        let currentWorkspace = global.screen.get_active_workspace();
        this.leavingOverview = true;
        for (let i = 0; i < this._windows.length; i++) {
            let clone = this._windows[i];
            Tweener.removeTweens(clone.actor);
        }
        if (this._repositionWindowsId > 0) {
            Mainloop.source_remove(this._repositionWindowsId);
            this._repositionWindowsId = 0;
        }
        this._overviewHiddenId = Main.overview.connect('hidden', Lang.bind(this,
                                                                           this._doneLeavingOverview));
        if (this.metaWorkspace != null && this.metaWorkspace != currentWorkspace)
            return;
        // Position and scale the windows.
        for (let i = 0; i < this._windows.length; i++)
           this._zoomWindowFromOverview(i);
    },
    _zoomWindowFromOverview: function(index) {
        let clone = this._windows[index];
        let overlay = this._windowOverlays[index];
        if (overlay)
            overlay.hide();
        if (clone.metaWindow.showing_on_its_workspace()) {
            let [origX, origY] = clone.getOriginalPosition();
            Tweener.addTween(clone.actor,
                             { x: origX,
                               y: origY,
                               scale_x: 1.0,
                               scale_y: 1.0,
                               time: Overview.ANIMATION_TIME,
                               opacity: 255,
                               transition: 'easeOutQuad'
                             });
        } else {
            // The window is hidden, make it shrink and fade it out
            Tweener.addTween(clone.actor,
                             { scale_x: 0,
                               scale_y: 0,
                               opacity: 0,
                               time: Overview.ANIMATION_TIME,
                               transition: 'easeOutQuad'
                             });
        }
    },
    destroy : function() {
        this.actor.destroy();
    },
    _onDestroy: function(actor) {
        if (this._overviewHiddenId) {
            Main.overview.disconnect(this._overviewHiddenId);
            this._overviewHiddenId = 0;
        }
        Tweener.removeTweens(actor);
        if (this.metaWorkspace) {
            this.metaWorkspace.disconnect(this._windowAddedId);
            this.metaWorkspace.disconnect(this._windowRemovedId);
        }
        global.screen.disconnect(this._windowEnteredMonitorId);
        global.screen.disconnect(this._windowLeftMonitorId);
        if (this._repositionWindowsId > 0)
            Mainloop.source_remove(this._repositionWindowsId);
        if (this._positionWindowsId > 0)
            Meta.later_remove(this._positionWindowsId);
        if (this._actualGeometryLater > 0)
            Meta.later_remove(this._actualGeometryLater);
        this._windows = [];
    },
    // Sets this.leavingOverview flag to false.
    _doneLeavingOverview : function() {
        this.leavingOverview = false;
    },
    _doneShowingOverview: function() {
        this._animatingWindowsFade = false;
        this._recalculateWindowPositions(WindowPositionFlags.INITIAL);
    },
    // Tests if @actor belongs to this workspaces and monitor
    _isMyWindow : function (actor) {
        let win = actor.meta_window;
        return (this.metaWorkspace == null || win.located_on_workspace(this.metaWorkspace)) &&
            (win.get_monitor() == this.monitorIndex);
    },
    // Tests if @win should be shown in the Overview
    _isOverviewWindow : function (win) {
        return !win.get_meta_window().skip_taskbar;
    },
    // Create a clone of a (non-desktop) window and add it to the window list
    _addWindowClone : function(win, positioned) {
        let clone = new WindowClone(win, this);
        let overlay = new WindowOverlay(clone, this._windowOverlaysGroup);
        clone.overlay = overlay;
        clone.positioned = positioned;
        clone.connect('selected',
                      Lang.bind(this, this._onCloneSelected));
        clone.connect('drag-begin',
                      Lang.bind(this, function() {
                          Main.overview.beginWindowDrag(clone.metaWindow);
                          overlay.hide();
                      }));
        clone.connect('drag-cancelled',
                      Lang.bind(this, function() {
                          Main.overview.cancelledWindowDrag(clone.metaWindow);
                      }));
        clone.connect('drag-end',
                      Lang.bind(this, function() {
                          Main.overview.endWindowDrag(clone.metaWindow);
                          overlay.show();
                      }));
        clone.connect('size-changed',
                      Lang.bind(this, function() {
                          this._recalculateWindowPositions(WindowPositionFlags.NONE);
                      }));
        this.actor.add_actor(clone.actor);
        overlay.connect('show-close-button', Lang.bind(this, this._onShowOverlayClose));
        if (this._windows.length == 0)
            clone.setStackAbove(null);
        else
            clone.setStackAbove(this._windows[this._windows.length - 1].actor);
        this._windows.push(clone);
        this._windowOverlays.push(overlay);
        return [clone, overlay];
    },
    _onShowOverlayClose: function (windowOverlay) {
        for (let i = 0; i < this._windowOverlays.length; i++) {
            let overlay = this._windowOverlays[i];
            if (overlay == windowOverlay)
                continue;
            overlay.hideCloseButton();
        }
    },
    _isBetterLayout: function(oldLayout, newLayout) {
        if (oldLayout.scale === undefined)
            return true;
        let spacePower = (newLayout.space - oldLayout.space) * LAYOUT_SPACE_WEIGHT;
        let scalePower = (newLayout.scale - oldLayout.scale) * LAYOUT_SCALE_WEIGHT;
        if (newLayout.scale > oldLayout.scale && newLayout.space > oldLayout.space) {
            // Win win -- better scale and better space
            return true;
        } else if (newLayout.scale > oldLayout.scale && newLayout.space <= oldLayout.space) {
            // Keep new layout only if scale gain outweights aspect space loss
            return scalePower > spacePower;
        } else if (newLayout.scale <= oldLayout.scale && newLayout.space > oldLayout.space) {
            // Keep new layout only if aspect space gain outweights scale loss
            return spacePower > scalePower;
        } else {
            // Lose -- worse scale and space
            return false;
        }
    },
    _getBestLayout: function(windows, area, rowSpacing, columnSpacing) {
        // We look for the largest scale that allows us to fit the
        // largest row/tallest column on the workspace.
        let lastLayout = {};
        let strategy = new UnalignedLayoutStrategy(this._monitor, rowSpacing, columnSpacing);
        for (let numRows = 1; ; numRows++) {
            let numColumns = Math.ceil(windows.length / numRows);
            // If adding a new row does not change column count just stop
            // (for instance: 9 windows, with 3 rows -> 3 columns, 4 rows ->
            // 3 columns as well => just use 3 rows then)
            if (numColumns == lastLayout.numColumns)
                break;
            let layout = { area: area, strategy: strategy, numRows: numRows, numColumns: numColumns };
            strategy.computeLayout(windows, layout);
            strategy.computeScaleAndSpace(layout);
            if (!this._isBetterLayout(lastLayout, layout))
                break;
            lastLayout = layout;
        }
        return lastLayout;
    },
    _getSpacingAndPadding: function() {
        let node = this.actor.get_theme_node();
        // Window grid spacing
        let columnSpacing = node.get_length('-horizontal-spacing');
        let rowSpacing = node.get_length('-vertical-spacing');
        let padding = {
            left: node.get_padding(St.Side.LEFT),
            top: node.get_padding(St.Side.TOP),
            bottom: node.get_padding(St.Side.BOTTOM),
            right: node.get_padding(St.Side.RIGHT),
        };
        let closeButtonHeight, captionHeight;
        let leftBorder, rightBorder;
        // All of the overlays have the same chrome sizes,
        // so just pick the first one.
        let overlay = this._windowOverlays[0];
        [closeButtonHeight, captionHeight] = overlay.chromeHeights();
        [leftBorder, rightBorder] = overlay.chromeWidths();
        rowSpacing += captionHeight;
        columnSpacing += (rightBorder + leftBorder) / 2;
        padding.top += closeButtonHeight;
        padding.bottom += captionHeight;
        padding.left += leftBorder;
        padding.right += rightBorder;
        return [rowSpacing, columnSpacing, padding];
    },
    _computeLayout: function(windows) {
        let [rowSpacing, columnSpacing, padding] = this._getSpacingAndPadding();
        let area = padArea(this._fullGeometry, padding);
        return this._getBestLayout(windows, area, rowSpacing, columnSpacing);
    },
    _onCloneSelected : function (clone, time) {
        let wsIndex = undefined;
        if (this.metaWorkspace)
            wsIndex = this.metaWorkspace.index();
        Main.activateWindow(clone.metaWindow, time, wsIndex);
    },
    // Draggable target interface
    handleDragOver : function(source, actor, x, y, time) {
        if (source.realWindow && !this._isMyWindow(source.realWindow))
            return DND.DragMotionResult.MOVE_DROP;
        if (source.shellWorkspaceLaunch)
            return DND.DragMotionResult.COPY_DROP;
        return DND.DragMotionResult.CONTINUE;
    },
    acceptDrop : function(source, actor, x, y, time) {
        if (source.realWindow) {
            let win = source.realWindow;
            if (this._isMyWindow(win))
                return false;
            // Set a hint on the Mutter.Window so its initial position
            // in the new workspace will be correct
            win._overviewHint = {
                x: actor.x,
                y: actor.y,
                scale: actor.scale_x
            };
            let metaWindow = win.get_meta_window();
            // We need to move the window before changing the workspace, because
            // the move itself could cause a workspace change if the window enters
            // the primary monitor
            if (metaWindow.get_monitor() != this.monitorIndex)
                metaWindow.move_to_monitor(this.monitorIndex);
            let index = this.metaWorkspace ? this.metaWorkspace.index() : global.screen.get_active_workspace_index();
            metaWindow.change_workspace_by_index(index, false);
            return true;
        } else if (source.shellWorkspaceLaunch) {
            source.shellWorkspaceLaunch({ workspace: this.metaWorkspace ? this.metaWorkspace.index() : -1,
                                          timestamp: time });
            return true;
        }
        return false;
    }
Signals.addSignalMethods(Workspace.prototype);
(uuay)workspaceSwitcherPopup.js
// -*- mode: js; js-indent-level: 4; indent-tabs-mode: nil -*-
const Clutter = imports.gi.Clutter;
const GLib = imports.gi.GLib;
const Lang = imports.lang;
const Mainloop = imports.mainloop;
const Meta  = imports.gi.Meta;
const Shell = imports.gi.Shell;
const Signals = imports.signals;
const St = imports.gi.St;
const Main = imports.ui.main;
const Tweener = imports.ui.tweener;
const ANIMATION_TIME = 0.1;
const DISPLAY_TIMEOUT = 600;
const WorkspaceSwitcherPopup = new Lang.Class({
    Name: 'WorkspaceSwitcherPopup',
    _init : function() {
        this.actor = new St.Widget({ x: 0,
                                     y: 0,
                                     width: global.screen_width,
                                     height: global.screen_height,
                                     style_class: 'workspace-switcher-group' });
        Main.uiGroup.add_actor(this.actor);
        this._container = new St.BoxLayout({ style_class: 'workspace-switcher-container' });
        this._list = new Shell.GenericContainer({ style_class: 'workspace-switcher' });
        this._itemSpacing = 0;
        this._childHeight = 0;
        this._childWidth = 0;
        this._list.connect('style-changed', Lang.bind(this, function() {
                                                        this._itemSpacing = this._list.get_theme_node().get_length('spacing');
                                                     }));
        this._list.connect('get-preferred-width', Lang.bind(this, this._getPreferredWidth));
        this._list.connect('get-preferred-height', Lang.bind(this, this._getPreferredHeight));
        this._list.connect('allocate', Lang.bind(this, this._allocate));
        this._container.add(this._list);
        this.actor.add_actor(this._container);
        this._redisplay();
        this.actor.hide();
        this._globalSignals = [];
        this._globalSignals.push(global.screen.connect('workspace-added', Lang.bind(this, this._redisplay)));
        this._globalSignals.push(global.screen.connect('workspace-removed', Lang.bind(this, this._redisplay)));
        this._timeoutId = Mainloop.timeout_add(DISPLAY_TIMEOUT, Lang.bind(this, this._onTimeout));
        GLib.Source.set_name_by_id(this._timeoutId, '[gnome-shell] this._onTimeout');
    },
    _getPreferredHeight : function (actor, forWidth, alloc) {
        let children = this._list.get_children();
        let workArea = Main.layoutManager.getWorkAreaForMonitor(Main.layoutManager.primaryIndex);
        let availHeight = workArea.height;
        availHeight -= this.actor.get_theme_node().get_vertical_padding();
        availHeight -= this._container.get_theme_node().get_vertical_padding();
        availHeight -= this._list.get_theme_node().get_vertical_padding();
        let height = 0;
        for (let i = 0; i < children.length; i++) {
            let [childMinHeight, childNaturalHeight] = children[i].get_preferred_height(-1);
            let [childMinWidth, childNaturalWidth] = children[i].get_preferred_width(childNaturalHeight);
            height += childNaturalHeight * workArea.width / workArea.height;
        }
        let spacing = this._itemSpacing * (global.screen.n_workspaces - 1);
        height += spacing;
        height = Math.min(height, availHeight);
        this._childHeight = (height - spacing) / global.screen.n_workspaces;
        alloc.min_size = height;
        alloc.natural_size = height;
    },
    _getPreferredWidth : function (actor, forHeight, alloc) {
        let workArea = Main.layoutManager.getWorkAreaForMonitor(Main.layoutManager.primaryIndex);
        this._childWidth = Math.round(this._childHeight * workArea.width / workArea.height);
        alloc.min_size = this._childWidth;
        alloc.natural_size = this._childWidth;
    },
    _allocate : function (actor, box, flags) {
        let children = this._list.get_children();
        let childBox = new Clutter.ActorBox();
        let y = box.y1;
        let prevChildBoxY2 = box.y1 - this._itemSpacing;
        for (let i = 0; i < children.length; i++) {
            childBox.x1 = box.x1;
            childBox.x2 = box.x1 + this._childWidth;
            childBox.y1 = prevChildBoxY2 + this._itemSpacing;
            childBox.y2 = Math.round(y + this._childHeight);
            y += this._childHeight + this._itemSpacing;
            prevChildBoxY2 = childBox.y2;
            children[i].allocate(childBox, flags);
        }
    },
    _redisplay: function() {
        this._list.destroy_all_children();
        for (let i = 0; i < global.screen.n_workspaces; i++) {
            let indicator = null;
           if (i == this._activeWorkspaceIndex && this._direction == Meta.MotionDirection.UP)
               indicator = new St.Bin({ style_class: 'ws-switcher-active-up' });
           else if(i == this._activeWorkspaceIndex && this._direction == Meta.MotionDirection.DOWN)
               indicator = new St.Bin({ style_class: 'ws-switcher-active-down' });
           else
               indicator = new St.Bin({ style_class: 'ws-switcher-box' });
           this._list.add_actor(indicator);
        }
        let workArea = Main.layoutManager.getWorkAreaForMonitor(Main.layoutManager.primaryIndex);
        let [containerMinHeight, containerNatHeight] = this._container.get_preferred_height(global.screen_width);
        let [containerMinWidth, containerNatWidth] = this._container.get_preferred_width(containerNatHeight);
        this._container.x = workArea.x + Math.floor((workArea.width - containerNatWidth) / 2);
        this._container.y = workArea.y + Math.floor((workArea.height - containerNatHeight) / 2);
    },
    _show : function() {
        Tweener.addTween(this._container, { opacity: 255,
                                            time: ANIMATION_TIME,
                                            transition: 'easeOutQuad'
                                           });
        this.actor.show();
    },
    display : function(direction, activeWorkspaceIndex) {
        this._direction = direction;
        this._activeWorkspaceIndex = activeWorkspaceIndex;
        this._redisplay();
        if (this._timeoutId != 0)
            Mainloop.source_remove(this._timeoutId);
        this._timeoutId = Mainloop.timeout_add(DISPLAY_TIMEOUT, Lang.bind(this, this._onTimeout));
        GLib.Source.set_name_by_id(this._timeoutId, '[gnome-shell] this._onTimeout');
        this._show();
    },
    _onTimeout : function() {
        Mainloop.source_remove(this._timeoutId);
        this._timeoutId = 0;
        Tweener.addTween(this._container, { opacity: 0.0,
                                            time: ANIMATION_TIME,
                                            transition: 'easeOutQuad',
                                            onComplete: function() { this.destroy(); },
                                            onCompleteScope: this
                                           });
        return GLib.SOURCE_REMOVE;
    },
    destroy: function() {
        if (this._timeoutId)
            Mainloop.source_remove(this._timeoutId);
        this._timeoutId = 0;
        for (let i = 0; i < this._globalSignals.length; i++)
            global.screen.disconnect(this._globalSignals[i]);
        this.actor.destroy();
        this.emit('destroy');
    }
Signals.addSignalMethods(WorkspaceSwitcherPopup.prototype);
(uuay)slider.js
/* -*- mode: js2; js2-basic-offset: 4; indent-tabs-mode: nil -*- */
const Atk = imports.gi.Atk;
const Cairo = imports.cairo;
const Clutter = imports.gi.Clutter;
const Lang = imports.lang;
const St = imports.gi.St;
const Signals = imports.signals;
const SLIDER_SCROLL_STEP = 0.02; /* Slider scrolling step in % */
const Slider = new Lang.Class({
    Name: "Slider",
    _init: function(value) {
        if (isNaN(value))
            // Avoid spreading NaNs around
            throw TypeError('The slider value must be a number');
        this._value = Math.max(Math.min(value, 1), 0);
        this.actor = new St.DrawingArea({ style_class: 'slider',
                                          can_focus: true,
                                          reactive: true,
                                          accessible_role: Atk.Role.SLIDER });
        this.actor.connect('repaint', Lang.bind(this, this._sliderRepaint));
        this.actor.connect('button-press-event', Lang.bind(this, this._startDragging));
        this.actor.connect('touch-event', Lang.bind(this, this._touchDragging));
        this.actor.connect('scroll-event', Lang.bind(this, this._onScrollEvent));
        this.actor.connect('key-press-event', Lang.bind(this, this.onKeyPressEvent));
        this._releaseId = this._motionId = 0;
        this._dragging = false;
        this._customAccessible = St.GenericAccessible.new_for_actor(this.actor);
        this.actor.set_accessible(this._customAccessible);
        this._customAccessible.connect('get-current-value', Lang.bind(this, this._getCurrentValue));
        this._customAccessible.connect('get-minimum-value', Lang.bind(this, this._getMinimumValue));
        this._customAccessible.connect('get-maximum-value', Lang.bind(this, this._getMaximumValue));
        this._customAccessible.connect('get-minimum-increment', Lang.bind(this, this._getMinimumIncrement));
        this._customAccessible.connect('set-current-value', Lang.bind(this, this._setCurrentValue));
        this.connect('value-changed', Lang.bind(this, this._valueChanged));
    },
    setValue: function(value) {
        if (isNaN(value))
            throw TypeError('The slider value must be a number');
        this._value = Math.max(Math.min(value, 1), 0);
        this.actor.queue_repaint();
    },
    _sliderRepaint: function(area) {
        let cr = area.get_context();
        let themeNode = area.get_theme_node();
        let [width, height] = area.get_surface_size();
        let handleRadius = themeNode.get_length('-slider-handle-radius');
        let handleBorderWidth = themeNode.get_length('-slider-handle-border-width');
        let [hasHandleColor, handleBorderColor] =
            themeNode.lookup_color('-slider-handle-border-color', false);
        let sliderHeight = themeNode.get_length('-slider-height');
        let sliderBorderWidth = themeNode.get_length('-slider-border-width');
        let sliderBorderRadius = Math.min(width, sliderHeight) / 2;
        let sliderBorderColor = themeNode.get_color('-slider-border-color');
        let sliderColor = themeNode.get_color('-slider-background-color');
        let sliderActiveBorderColor = themeNode.get_color('-slider-active-border-color');
        let sliderActiveColor = themeNode.get_color('-slider-active-background-color');
        const TAU = Math.PI * 2;
        let handleX = handleRadius + (width - 2 * handleRadius) * this._value;
        cr.arc(sliderBorderRadius + sliderBorderWidth, height / 2, sliderBorderRadius, TAU * 1/4, TAU * 3/4);
        cr.lineTo(handleX, (height - sliderHeight) / 2);
        cr.lineTo(handleX, (height + sliderHeight) / 2);
        cr.lineTo(sliderBorderRadius + sliderBorderWidth, (height + sliderHeight) / 2);
        Clutter.cairo_set_source_color(cr, sliderActiveColor);
        cr.fillPreserve();
        Clutter.cairo_set_source_color(cr, sliderActiveBorderColor);
        cr.setLineWidth(sliderBorderWidth);
        cr.stroke();
        cr.arc(width - sliderBorderRadius - sliderBorderWidth, height / 2, sliderBorderRadius, TAU * 3/4, TAU * 1/4);
        cr.lineTo(handleX, (height + sliderHeight) / 2);
        cr.lineTo(handleX, (height - sliderHeight) / 2);
        cr.lineTo(width - sliderBorderRadius - sliderBorderWidth, (height - sliderHeight) / 2);
        Clutter.cairo_set_source_color(cr, sliderColor);
        cr.fillPreserve();
        Clutter.cairo_set_source_color(cr, sliderBorderColor);
        cr.setLineWidth(sliderBorderWidth);
        cr.stroke();
        let handleY = height / 2;
        let color = themeNode.get_foreground_color();
        Clutter.cairo_set_source_color(cr, color);
        cr.arc(handleX, handleY, handleRadius, 0, 2 * Math.PI);
        cr.fillPreserve();
        if (hasHandleColor && handleBorderWidth) {
            Clutter.cairo_set_source_color(cr, handleBorderColor);
            cr.setLineWidth(handleBorderWidth);
            cr.stroke();
        }
        cr.$dispose();
    },
    _startDragging: function(actor, event) {
        return this.startDragging(event);
    },
    startDragging: function(event) {
        if (this._dragging)
            return Clutter.EVENT_PROPAGATE;
        this._dragging = true;
        let device = event.get_device();
        let sequence = event.get_event_sequence();
        if (sequence != null)
            device.sequence_grab(sequence, this.actor);
        else
            device.grab(this.actor);
        this._grabbedDevice = device;
        this._grabbedSequence = sequence;
        if (sequence == null) {
            this._releaseId = this.actor.connect('button-release-event', Lang.bind(this, this._endDragging));
            this._motionId = this.actor.connect('motion-event', Lang.bind(this, this._motionEvent));
        }
        // We need to emit 'drag-begin' before moving the handle to make
        // sure that no 'value-changed' signal is emitted before this one.
        this.emit('drag-begin');
        let absX, absY;
        [absX, absY] = event.get_coords();
        this._moveHandle(absX, absY);
        return Clutter.EVENT_STOP;
    },
    _endDragging: function() {
        if (this._dragging) {
            if (this._releaseId)
                this.actor.disconnect(this._releaseId);
            if (this._motionId)
                this.actor.disconnect(this._motionId);
            if (this._grabbedSequence != null)
                this._grabbedDevice.sequence_ungrab(this._grabbedSequence);
            else
                this._grabbedDevice.ungrab();
            this._grabbedSequence = null;
            this._grabbedDevice = null;
            this._dragging = false;
            this.emit('drag-end');
        }
        return Clutter.EVENT_STOP;
    },
    _touchDragging: function(actor, event) {
        let device = event.get_device();
        let sequence = event.get_event_sequence();
        if (!this._dragging &&
            event.type() == Clutter.EventType.TOUCH_BEGIN) {
            this.startDragging(event);
            return Clutter.EVENT_STOP;
        } else if (device.sequence_get_grabbed_actor(sequence) == actor) {
            if (event.type() == Clutter.EventType.TOUCH_UPDATE)
                return this._motionEvent(actor, event);
            else if (event.type() == Clutter.EventType.TOUCH_END)
                return this._endDragging();
        }
        return Clutter.EVENT_PROPAGATE;
    },
    scroll: function(event) {
        let direction = event.get_scroll_direction();
        let delta;
        if (event.is_pointer_emulated())
            return Clutter.EVENT_PROPAGATE;
        if (direction == Clutter.ScrollDirection.DOWN) {
            delta = -SLIDER_SCROLL_STEP;
        } else if (direction == Clutter.ScrollDirection.UP) {
            delta = +SLIDER_SCROLL_STEP;
        } else if (direction == Clutter.ScrollDirection.SMOOTH) {
            let [dx, dy] = event.get_scroll_delta();
            // Even though the slider is horizontal, use dy to match
            // the UP/DOWN above.
            delta = -dy * SLIDER_SCROLL_STEP;
        }
        this._value = Math.min(Math.max(0, this._value + delta), 1);
        this.actor.queue_repaint();
        this.emit('value-changed', this._value);
        return Clutter.EVENT_STOP;
    },
    _onScrollEvent: function(actor, event) {
        return this.scroll(event);
    },
    _motionEvent: function(actor, event) {
        let absX, absY;
        [absX, absY] = event.get_coords();
        this._moveHandle(absX, absY);
        return Clutter.EVENT_STOP;
    },
    onKeyPressEvent: function (actor, event) {
        let key = event.get_key_symbol();
        if (key == Clutter.KEY_Right || key == Clutter.KEY_Left) {
            let delta = key == Clutter.KEY_Right ? 0.1 : -0.1;
            this._value = Math.max(0, Math.min(this._value + delta, 1));
            this.actor.queue_repaint();
            this.emit('drag-begin');
            this.emit('value-changed', this._value);
            this.emit('drag-end');
            return Clutter.EVENT_STOP;
        }
        return Clutter.EVENT_PROPAGATE;
    },
    _moveHandle: function(absX, absY) {
        let relX, relY, sliderX, sliderY;
        [sliderX, sliderY] = this.actor.get_transformed_position();
        relX = absX - sliderX;
        relY = absY - sliderY;
        let width = this.actor.width;
        let handleRadius = this.actor.get_theme_node().get_length('-slider-handle-radius');
        let newvalue;
        if (relX < handleRadius)
            newvalue = 0;
        else if (relX > width - handleRadius)
            newvalue = 1;
        else
            newvalue = (relX - handleRadius) / (width - 2 * handleRadius);
        this._value = newvalue;
        this.actor.queue_repaint();
        this.emit('value-changed', this._value);
    },
    _getCurrentValue: function (actor) {
        return this._value;
    },
    _getMinimumValue: function (actor) {
        return 0;
    },
    _getMaximumValue: function (actor) {
        return 1;
    },
    _getMinimumIncrement: function (actor) {
        return 0.1;
    },
    _setCurrentValue: function (actor, value) {
        this._value = value;
    },
    _valueChanged: function (slider, value, property) {
        this._customAccessible.notify ("accessible-value");
    },
    get value() {
        return this._value;
    }
Signals.addSignalMethods(Slider.prototype);
(uuay)location.js
// -*- mode: js; js-indent-level: 4; indent-tabs-mode: nil -*-
const Clutter = imports.gi.Clutter;
const GLib = imports.gi.GLib;
const Gio = imports.gi.Gio;
const Lang = imports.lang;
const Main = imports.ui.main;
const PanelMenu = imports.ui.panelMenu;
const PopupMenu = imports.ui.popupMenu;
const ModalDialog = imports.ui.modalDialog;
const Shell = imports.gi.Shell;
const Signals = imports.signals;
const St = imports.gi.St;
const LOCATION_SCHEMA = 'org.gnome.system.location';
const MAX_ACCURACY_LEVEL = 'max-accuracy-level';
const ENABLED = 'enabled';
const APP_PERMISSIONS_TABLE = 'gnome';
const APP_PERMISSIONS_ID = 'geolocation';
const GeoclueAccuracyLevel = {
    NONE: 0,
    COUNTRY: 1,
    CITY: 4,
    NEIGHBORHOOD: 5,
    STREET: 6,
    EXACT: 8
function accuracyLevelToString(accuracyLevel) {
    for (let key in GeoclueAccuracyLevel) {
        if (GeoclueAccuracyLevel[key] == accuracyLevel)
            return key;
    }
    return 'NONE';
var GeoclueIface = '<node> \
  <interface name="org.freedesktop.GeoClue2.Manager"> \
    <property name="InUse" type="b" access="read"/> \
    <property name="AvailableAccuracyLevel" type="u" access="read"/> \
    <method name="AddAgent"> \
      <arg name="id" type="s" direction="in"/> \
    </method> \
  </interface> \
</node>';
const GeoclueManager = Gio.DBusProxy.makeProxyWrapper(GeoclueIface);
var AgentIface = '<node> \
  <interface name="org.freedesktop.GeoClue2.Agent"> \
    <property name="MaxAccuracyLevel" type="u" access="read"/> \
    <method name="AuthorizeApp"> \
      <arg name="desktop_id" type="s" direction="in"/> \
      <arg name="req_accuracy_level" type="u" direction="in"/> \
      <arg name="authorized" type="b" direction="out"/> \
      <arg name="allowed_accuracy_level" type="u" direction="out"/> \
    </method> \
  </interface> \
</node>';
var PermissionStoreIface = '<node> \
  <interface name="org.freedesktop.impl.portal.PermissionStore"> \
    <method name="Lookup"> \
      <arg name="table" type="s" direction="in"/> \
      <arg name="id" type="s" direction="in"/> \
      <arg name="permissions" type="a{sas}" direction="out"/> \
      <arg name="data" type="v" direction="out"/> \
    </method> \
    <method name="Set"> \
      <arg name="table" type="s" direction="in"/> \
      <arg name="create" type="b" direction="in"/> \
      <arg name="id" type="s" direction="in"/> \
      <arg name="app_permissions" type="a{sas}" direction="in"/> \
      <arg name="data" type="v" direction="in"/> \
    </method> \
  </interface> \
</node>';
const PermissionStore = Gio.DBusProxy.makeProxyWrapper(PermissionStoreIface);
const Indicator = new Lang.Class({
    Name: 'LocationIndicator',
    Extends: PanelMenu.SystemIndicator,
    _init: function() {
        this.parent();
        this._settings = new Gio.Settings({ schema_id: LOCATION_SCHEMA });
        this._settings.connect('changed::' + ENABLED,
                               Lang.bind(this, this._onMaxAccuracyLevelChanged));
        this._settings.connect('changed::' + MAX_ACCURACY_LEVEL,
                               Lang.bind(this, this._onMaxAccuracyLevelChanged));
        this._indicator = this._addIndicator();
        this._indicator.icon_name = 'find-location-symbolic';
        this._item = new PopupMenu.PopupSubMenuMenuItem('', true);
        this._item.icon.icon_name = 'find-location-symbolic';
        this._agent = Gio.DBusExportedObject.wrapJSObject(AgentIface, this);
        this._agent.export(Gio.DBus.system, '/org/freedesktop/GeoClue2/Agent');
        this._item.label.text = _("Location Enabled");
        this._onOffAction = this._item.menu.addAction(_("Disable"), Lang.bind(this, this._onOnOffAction));
        this._item.menu.addSettingsAction(_("Privacy Settings"), 'gnome-privacy-panel.desktop');
        this.menu.addMenuItem(this._item);
        this._watchId = Gio.bus_watch_name(Gio.BusType.SYSTEM,
                                           'org.freedesktop.GeoClue2',
                                           0,
                                           Lang.bind(this, this._connectToGeoclue),
                                           Lang.bind(this, this._onGeoclueVanished));
        Main.sessionMode.connect('updated', Lang.bind(this, this._onSessionUpdated));
        this._onSessionUpdated();
        this._onMaxAccuracyLevelChanged();
        this._connectToGeoclue();
        this._connectToPermissionStore();
    },
    get MaxAccuracyLevel() {
        return this._getMaxAccuracyLevel();
    },
    AuthorizeAppAsync: function(params, invocation) {
        let [desktopId, reqAccuracyLevel] = params;
        let authorizer = new AppAuthorizer(desktopId,
                                           reqAccuracyLevel,
                                           this._permStoreProxy,
                                           this._getMaxAccuracyLevel());
        authorizer.authorize(Lang.bind(this, function(accuracyLevel) {
            let ret = (accuracyLevel != GeoclueAccuracyLevel.NONE);
            invocation.return_value(GLib.Variant.new('(bu)',
                                                     [ret, accuracyLevel]));
        }));
    },
    _syncIndicator: function() {
        if (this._managerProxy == null) {
            this._indicator.visible = false;
            this._item.actor.visible = false;
            return;
        }
        this._indicator.visible = this._managerProxy.InUse;
        this._item.actor.visible = this._indicator.visible;
        this._updateMenuLabels();
    },
    _connectToGeoclue: function() {
        if (this._managerProxy != null || this._connecting)
            return false;
        this._connecting = true;
        new GeoclueManager(Gio.DBus.system,
                           'org.freedesktop.GeoClue2',
                           '/org/freedesktop/GeoClue2/Manager',
                           Lang.bind(this, this._onManagerProxyReady));
        return true;
    },
    _onManagerProxyReady: function(proxy, error) {
        if (error != null) {
            log(error.message);
            this._connecting = false;
            return;
        }
        this._managerProxy = proxy;
        this._propertiesChangedId = this._managerProxy.connect('g-properties-changed',
                                                        Lang.bind(this, this._onGeocluePropsChanged));
        this._syncIndicator();
        this._managerProxy.AddAgentRemote('gnome-shell', Lang.bind(this, this._onAgentRegistered));
    },
    _onAgentRegistered: function(result, error) {
        this._connecting = false;
        this._notifyMaxAccuracyLevel();
        if (error != null)
            log(error.message);
    },
    _onGeoclueVanished: function() {
        if (this._propertiesChangedId) {
            this._managerProxy.disconnect(this._propertiesChangedId);
            this._propertiesChangedId = 0;
        }
        this._managerProxy = null;
        this._syncIndicator();
    },
    _onOnOffAction: function() {
        let enabled = this._settings.get_boolean(ENABLED);
        this._settings.set_boolean(ENABLED, !enabled);
    },
    _onSessionUpdated: function() {
        let sensitive = !Main.sessionMode.isLocked && !Main.sessionMode.isGreeter;
        this.menu.setSensitive(sensitive);
    },
    _updateMenuLabels: function() {
        if (this._settings.get_boolean(ENABLED)) {
            this._item.label.text = this._indicator.visible ? _("Location In Use")
                                                            : _("Location Enabled");
            this._onOffAction.label.text = _("Disable");
        } else {
            this._item.label.text = _("Location Disabled");
            this._onOffAction.label.text = _("Enable");
        }
    },
    _onMaxAccuracyLevelChanged: function() {
        this._updateMenuLabels();
        // Gotta ensure geoclue is up and we are registered as agent to it
        // before we emit the notify for this property change.
        if (!this._connectToGeoclue())
            this._notifyMaxAccuracyLevel();
    },
    _getMaxAccuracyLevel: function() {
        if (this._settings.get_boolean(ENABLED)) {
            let level = this._settings.get_string(MAX_ACCURACY_LEVEL);
            return GeoclueAccuracyLevel[level.toUpperCase()] ||
                   GeoclueAccuracyLevel.NONE;
        } else {
            return GeoclueAccuracyLevel.NONE;
        }
    },
    _notifyMaxAccuracyLevel: function() {
        let variant = new GLib.Variant('u', this._getMaxAccuracyLevel());
        this._agent.emit_property_changed('MaxAccuracyLevel', variant);
    },
    _onGeocluePropsChanged: function(proxy, properties) {
        let unpacked = properties.deep_unpack();
        if ("InUse" in unpacked)
            this._syncIndicator();
    },
    _connectToPermissionStore: function() {
        this._permStoreProxy = null;
        new PermissionStore(Gio.DBus.session,
                           'org.freedesktop.impl.portal.PermissionStore',
                           '/org/freedesktop/impl/portal/PermissionStore',
                           Lang.bind(this, this._onPermStoreProxyReady));
    },
    _onPermStoreProxyReady: function(proxy, error) {
        if (error != null) {
            log(error.message);
            return;
        }
        this._permStoreProxy = proxy;
    },
function clamp(value, min, max) {
    return Math.max(min, Math.min(max, value));
const AppAuthorizer = new Lang.Class({
    Name: 'LocationAppAuthorizer',
    _init: function(desktopId,
                    reqAccuracyLevel,
                    permStoreProxy,
                    maxAccuracyLevel) {
        this.desktopId = desktopId;
        this.reqAccuracyLevel = reqAccuracyLevel;
        this._permStoreProxy = permStoreProxy;
        this._maxAccuracyLevel = maxAccuracyLevel;
        this._accuracyLevel = GeoclueAccuracyLevel.NONE;
    },
    authorize: function(onAuthDone) {
        this._onAuthDone = onAuthDone;
        let appSystem = Shell.AppSystem.get_default();
        this._app = appSystem.lookup_app(this.desktopId + ".desktop");
        if (this._app == null || this._permStoreProxy == null) {
            this._completeAuth();
            return;
        }
        this._permStoreProxy.LookupRemote(APP_PERMISSIONS_TABLE,
                                          APP_PERMISSIONS_ID,
                                          Lang.bind(this,
                                                    this._onPermLookupDone));
    },
    _onPermLookupDone: function(result, error) {
        if (error != null) {
            if (error.domain == Gio.DBusError) {
                // Likely no xdg-app installed, just authorize the app
                this._accuracyLevel = this.reqAccuracyLevel;
                this._permStoreProxy = null;
                this._completeAuth();
            } else {
                // Currently xdg-app throws an error if we lookup for
                // unknown ID (which would be the case first time this code
                // runs) so we continue with user authorization as normal
                // and ID is added to the store if user says "yes".
                log(error.message);
                this._permissions = {};
                this._userAuthorizeApp();
            }
            return;
        }
        [this._permissions] = result;
        let permission = this._permissions[this.desktopId];
        if (permission == null) {
            this._userAuthorizeApp();
        } else {
            let [levelStr] = permission || ['NONE'];
            this._accuracyLevel = GeoclueAccuracyLevel[levelStr] ||
                                  GeoclueAccuracyLevel.NONE;
            this._completeAuth();
        }
    },
    _userAuthorizeApp: function() {
        let name = this._app.get_name();
        let appInfo = this._app.get_app_info();
        let reason = appInfo.get_string("X-Geoclue-Reason");
        this._showAppAuthDialog(name, reason);
    },
    _showAppAuthDialog: function(name, reason) {
        this._dialog = new GeolocationDialog(name,
                                             reason,
                                             this.reqAccuracyLevel);
        let responseId = this._dialog.connect('response', Lang.bind(this,
            function(dialog, level) {
                this._dialog.disconnect(responseId);
                this._accuracyLevel = level;
                this._completeAuth();
            }));
        this._dialog.open();
    },
    _completeAuth: function() {
        if (this._accuracyLevel != GeoclueAccuracyLevel.NONE) {
            this._accuracyLevel = clamp(this._accuracyLevel,
                                        0,
                                        this._maxAccuracyLevel);
        }
        this._saveToPermissionStore();
        this._onAuthDone(this._accuracyLevel);
    },
    _saveToPermissionStore: function() {
        if (this._permStoreProxy == null)
            return;
        let levelStr = accuracyLevelToString(this._accuracyLevel);
        let dateStr = Math.round(Date.now() / 1000).toString();
        this._permissions[this.desktopId] = [levelStr, dateStr];
        let data = GLib.Variant.new('av', {});
        this._permStoreProxy.SetRemote(APP_PERMISSIONS_TABLE,
                                       true,
                                       APP_PERMISSIONS_ID,
                                       this._permissions,
                                       data,
                                       function (result, error) {
            if (error != null)
                log(error.message);
        });
    },
const GeolocationDialog = new Lang.Class({
    Name: 'GeolocationDialog',
    Extends: ModalDialog.ModalDialog,
    _init: function(name, reason, reqAccuracyLevel) {
        this.parent({ styleClass: 'geolocation-dialog' });
        this.reqAccuracyLevel = reqAccuracyLevel;
        let mainContentBox = new St.BoxLayout({ style_class: 'geolocation-dialog-main-layout' });
        this.contentLayout.add_actor(mainContentBox);
        let icon = new St.Icon({ style_class: 'geolocation-dialog-icon',
                                 icon_name: 'find-location-symbolic',
                                 y_align: Clutter.ActorAlign.START });
        mainContentBox.add_actor(icon);
        let messageBox = new St.BoxLayout({ style_class: 'geolocation-dialog-content',
                                            vertical: true });
        mainContentBox.add_actor(messageBox);
        this._title = new St.Label({ style_class: 'geolocation-dialog-title headline' });
        messageBox.add_actor(this._title);
        this._reason = new St.Label({ style_class: 'geolocation-dialog-reason' });
        messageBox.add_actor(this._reason);
        this._privacyNote = new St.Label();
        messageBox.add_actor(this._privacyNote);
        let button = this.addButton({ label: _("Deny Access"),
                                      action: Lang.bind(this, this._onDenyClicked),
                                      key: Clutter.KEY_Escape });
        this.addButton({ label: _("Grant Access"),
                         action: Lang.bind(this, this._onGrantClicked) });
        this.setInitialKeyFocus(button);
        /* Translators: %s is an application name */
        this._title.text = _("Give %s access to your location?").format(name);
        this._privacyNote.text = _("Location access can be changed at any time from the privacy settings.");
        if (reason)
            this._reason.text = reason;
        this._reason.visible = (reason != null);
    },
    _onGrantClicked: function() {
        this.emit('response', this.reqAccuracyLevel);
        this.close();
    },
    _onDenyClicked: function() {
        this.emit('response', GeoclueAccuracyLevel.NONE);
        this.close();
    }
Signals.addSignalMethods(GeolocationDialog.prototype);
(uuay)bluetooth.js
// -*- mode: js; js-indent-level: 4; indent-tabs-mode: nil -*-
const Gio = imports.gi.Gio;
const GnomeBluetooth = imports.gi.GnomeBluetooth;
const Lang = imports.lang;
const Main = imports.ui.main;
const PanelMenu = imports.ui.panelMenu;
const PopupMenu = imports.ui.popupMenu;
const BUS_NAME = 'org.gnome.SettingsDaemon.Rfkill';
const OBJECT_PATH = '/org/gnome/SettingsDaemon/Rfkill';
const RfkillManagerInterface = '<node> \
<interface name="org.gnome.SettingsDaemon.Rfkill"> \
<property name="BluetoothAirplaneMode" type="b" access="readwrite" /> \
<property name="BluetoothHasAirplaneMode" type="b" access="read" /> \
</interface> \
</node>';
const RfkillManagerProxy = Gio.DBusProxy.makeProxyWrapper(RfkillManagerInterface);
const HAD_BLUETOOTH_DEVICES_SETUP = 'had-bluetooth-devices-setup';
const Indicator = new Lang.Class({
    Name: 'BTIndicator',
    Extends: PanelMenu.SystemIndicator,
    _init: function() {
        this.parent();
        this._indicator = this._addIndicator();
        this._indicator.icon_name = 'bluetooth-active-symbolic';
        this._hadSetupDevices = global.settings.get_boolean(HAD_BLUETOOTH_DEVICES_SETUP);
        this._proxy = new RfkillManagerProxy(Gio.DBus.session, BUS_NAME, OBJECT_PATH,
                                             Lang.bind(this, function(proxy, error) {
                                                 if (error) {
                                                     log(error.message);
                                                     return;
                                                 }
                                                 this._sync();
                                             }));
        this._proxy.connect('g-properties-changed', Lang.bind(this, this._sync));
        this._item = new PopupMenu.PopupSubMenuMenuItem(_("Bluetooth"), true);
        this._item.icon.icon_name = 'bluetooth-active-symbolic';
        this._toggleItem = new PopupMenu.PopupMenuItem('');
        this._toggleItem.connect('activate', Lang.bind(this, function() {
            this._proxy.BluetoothAirplaneMode = !this._proxy.BluetoothAirplaneMode;
        }));
        this._item.menu.addMenuItem(this._toggleItem);
        this._item.menu.addSettingsAction(_("Bluetooth Settings"), 'gnome-bluetooth-panel.desktop');
        this.menu.addMenuItem(this._item);
        this._client = new GnomeBluetooth.Client();
        this._model = this._client.get_model();
        this._model.connect('row-changed', Lang.bind(this, this._sync));
        this._model.connect('row-deleted', Lang.bind(this, this._sync));
        this._model.connect('row-inserted', Lang.bind(this, this._sync));
        Main.sessionMode.connect('updated', Lang.bind(this, this._sync));
        this._sync();
    },
    _getDefaultAdapter: function() {
        let [ret, iter] = this._model.get_iter_first();
        while (ret) {
            let isDefault = this._model.get_value(iter,
                                                  GnomeBluetooth.Column.DEFAULT);
            let isPowered = this._model.get_value(iter,
                                                  GnomeBluetooth.Column.POWERED);
            if (isDefault && isPowered)
                return iter;
            ret = this._model.iter_next(iter);
        }
        return null;
    },
    // nDevices is the number of devices setup for the current default
    // adapter if one exists and is powered. If unpowered or unavailable,
    // nDevice is "1" if it had setup devices associated to it the last
    // time it was seen, and "-1" if not.
    //
    // nConnectedDevices is the number of devices connected to the default
    // adapter if one exists and is powered, or -1 if it's not available.
    _getNDevices: function() {
        let adapter = this._getDefaultAdapter();
        if (!adapter)
            return [ this._hadSetupDevices ? 1 : -1, -1 ];
        let nConnectedDevices = 0;
        let nDevices = 0;
        let [ret, iter] = this._model.iter_children(adapter);
        while (ret) {
            let isConnected = this._model.get_value(iter,
                                                    GnomeBluetooth.Column.CONNECTED);
            if (isConnected)
                nConnectedDevices++;
            let isPaired = this._model.get_value(iter,
                                                 GnomeBluetooth.Column.PAIRED);
            let isTrusted = this._model.get_value(iter,
                                                  GnomeBluetooth.Column.TRUSTED);
            if (isPaired || isTrusted)
                nDevices++;
            ret = this._model.iter_next(iter);
        }
        if (this._hadSetupDevices != (nDevices > 0)) {
            this._hadSetupDevices = !this._hadSetupDevices;
            global.settings.set_boolean(HAD_BLUETOOTH_DEVICES_SETUP, this._hadSetupDevices);
        }
        return [ nDevices, nConnectedDevices];
    },
    _sync: function() {
        let [ nDevices, nConnectedDevices ] = this._getNDevices();
        let sensitive = !Main.sessionMode.isLocked && !Main.sessionMode.isGreeter;
        this.menu.setSensitive(sensitive);
        this._indicator.visible = nConnectedDevices > 0;
        // Remember if there were setup devices and show the menu
        // if we've seen setup devices and we're not hard blocked
        if (nDevices > 0)
            this._item.actor.visible = !this._proxy.BluetoothHardwareAirplaneMode;
        else
            this._item.actor.visible = this._proxy.BluetoothHasAirplaneMode && !this._proxy.BluetoothAirplaneMode;
        if (nConnectedDevices > 0)
            /* Translators: this is the number of connected bluetooth devices */
            this._item.label.text = ngettext("%d Connected", "%d Connected", nConnectedDevices).format(nConnectedDevices);
        else if (nConnectedDevices == -1)
            this._item.label.text = _("Off");
        else
            this._item.label.text = _("Not In Use");
        this._toggleItem.label.text = this._proxy.BluetoothAirplaneMode ? _("Turn On") : _("Turn Off");
    },
(uuay)appFavorites.js
// -*- mode: js; js-indent-level: 4; indent-tabs-mode: nil -*-
const Shell = imports.gi.Shell;
const Lang = imports.lang;
const Signals = imports.signals;
const Main = imports.ui.main;
const RENAMED_DESKTOP_IDS = {
    'baobab.desktop': 'org.gnome.baobab.desktop',
    'cheese.desktop': 'org.gnome.Cheese.desktop',
    'dconf-editor.desktop': 'ca.desrt.dconf-editor.desktop',
    'file-roller.desktop': 'org.gnome.FileRoller.desktop',
    'gcalctool.desktop': 'gnome-calculator.desktop',
    'gedit.desktop': 'org.gnome.gedit.desktop',
    'glchess.desktop': 'gnome-chess.desktop',
    'glines.desktop': 'five-or-more.desktop',
    'gnect.desktop': 'four-in-a-row.desktop',
    'gnibbles.desktop': 'org.gnome.Nibbles.desktop',
    'gnobots2.desktop': 'gnome-robots.desktop',
    'gnome-boxes.desktop': 'org.gnome.Boxes.desktop',
    'gnome-clocks.desktop': 'org.gnome.clocks.desktop',
    'gnome-contacts.desktop': 'org.gnome.Contacts.desktop',
    'gnome-documents.desktop': 'org.gnome.Documents.desktop',
    'gnome-font-viewer.desktop': 'org.gnome.font-viewer.desktop',
    'gnome-nibbles.desktop': 'org.gnome.Nibbles.desktop',
    'gnome-photos.desktop': 'org.gnome.Photos.desktop',
    'gnome-screenshot.desktop': 'org.gnome.Screenshot.desktop',
    'gnome-software.desktop': 'org.gnome.Software.desktop',
    'gnome-terminal.desktop': 'org.gnome.Terminal.desktop',
    'gnome-weather.desktop': 'org.gnome.Weather.Application.desktop',
    'gnomine.desktop': 'gnome-mines.desktop',
    'gnotravex.desktop': 'gnome-tetravex.desktop',
    'gnotski.desktop': 'gnome-klotski.desktop',
    'gtali.desktop': 'tali.desktop',
    'mozilla-firefox.desktop': 'firefox.desktop',
    'nautilus.desktop': 'org.gnome.Nautilus.desktop',
    'polari.desktop': 'org.gnome.Polari.desktop',
    'totem.desktop': 'org.gnome.Totem.desktop',
const AppFavorites = new Lang.Class({
    Name: 'AppFavorites',
    FAVORITE_APPS_KEY: 'favorite-apps',
    _init: function() {
        this._favorites = {};
        global.settings.connect('changed::' + this.FAVORITE_APPS_KEY, Lang.bind(this, this._onFavsChanged));
        this.reload();
    },
    _onFavsChanged: function() {
        this.reload();
        this.emit('changed');
    },
    reload: function() {
        let ids = global.settings.get_strv(this.FAVORITE_APPS_KEY);
        // Map old desktop file names to the current ones
        let updated = false;
        ids = ids.map(function (id) {
            let newId = RENAMED_DESKTOP_IDS[id];
            if (newId !== undefined) {
                updated = true;
                return newId;
            }
            return id;
        });
        // ... and write back the updated desktop file names
        if (updated)
            global.settings.set_strv(this.FAVORITE_APPS_KEY, ids);
        let appSys = Shell.AppSystem.get_default();
        let apps = ids.map(function (id) {
                return appSys.lookup_app(id);
            }).filter(function (app) {
                return app != null;
            });
        this._favorites = {};
        for (let i = 0; i < apps.length; i++) {
            let app = apps[i];
            this._favorites[app.get_id()] = app;
        }
    },
    _getIds: function() {
        let ret = [];
        for (let id in this._favorites)
            ret.push(id);
        return ret;
    },
    getFavoriteMap: function() {
        return this._favorites;
    },
    getFavorites: function() {
        let ret = [];
        for (let id in this._favorites)
            ret.push(this._favorites[id]);
        return ret;
    },
    isFavorite: function(appId) {
        return appId in this._favorites;
    },
    _addFavorite: function(appId, pos) {
        if (appId in this._favorites)
            return false;
        let app = Shell.AppSystem.get_default().lookup_app(appId);
        if (!app)
            return false;
        let ids = this._getIds();
        if (pos == -1)
            ids.push(appId);
        else
            ids.splice(pos, 0, appId);
        global.settings.set_strv(this.FAVORITE_APPS_KEY, ids);
        this._favorites[appId] = app;
        return true;
    },
    addFavoriteAtPos: function(appId, pos) {
        if (!this._addFavorite(appId, pos))
            return;
        let app = Shell.AppSystem.get_default().lookup_app(appId);
        Main.overview.setMessage(_("%s has been added to your favorites.").format(app.get_name()),
                                 { forFeedback: true,
                                   undoCallback: Lang.bind(this, function () {
                                                               this._removeFavorite(appId);
                                                           })
                                 });
    },
    addFavorite: function(appId) {
        this.addFavoriteAtPos(appId, -1);
    },
    moveFavoriteToPos: function(appId, pos) {
        this._removeFavorite(appId);
        this._addFavorite(appId, pos);
    },
    _removeFavorite: function(appId) {
        if (!appId in this._favorites)
            return false;
        let ids = this._getIds().filter(function (id) { return id != appId; });
        global.settings.set_strv(this.FAVORITE_APPS_KEY, ids);
        return true;
    },
    removeFavorite: function(appId) {
        let ids = this._getIds();
        let pos = ids.indexOf(appId);
        let app = this._favorites[appId];
        if (!this._removeFavorite(appId))
            return;
        Main.overview.setMessage(_("%s has been removed from your favorites.").format(app.get_name()),
                                 { forFeedback: true,
                                   undoCallback: Lang.bind(this, function () {
                                                               this._addFavorite(appId, pos);
                                                           })
                                 });
    }
Signals.addSignalMethods(AppFavorites.prototype);
var appFavoritesInstance = null;
function getAppFavorites() {
    if (appFavoritesInstance == null)
        appFavoritesInstance = new AppFavorites();
    return appFavoritesInstance;
(uuay)shellMountOperation.js
// -*- mode: js; js-indent-level: 4; indent-tabs-mode: nil -*-
const Clutter = imports.gi.Clutter;
const Lang = imports.lang;
const Signals = imports.signals;
const Gio = imports.gi.Gio;
const GLib = imports.gi.GLib;
const Gtk = imports.gi.Gtk;
const Pango = imports.gi.Pango;
const St = imports.gi.St;
const Shell = imports.gi.Shell;
const CheckBox = imports.ui.checkBox;
const Main = imports.ui.main;
const MessageTray = imports.ui.messageTray;
const ModalDialog = imports.ui.modalDialog;
const Params = imports.misc.params;
const ShellEntry = imports.ui.shellEntry;
const LIST_ITEM_ICON_SIZE = 48;
const REMEMBER_MOUNT_PASSWORD_KEY = 'remember-mount-password';
/* ------ Common Utils ------- */
function _setLabelText(label, text) {
    if (text) {
        label.set_text(text);
        label.show();
    } else {
        label.set_text('');
        label.hide();
    }
function _setButtonsForChoices(dialog, choices) {
    let buttons = [];
    for (let idx = 0; idx < choices.length; idx++) {
        let button = idx;
        buttons.unshift({ label: choices[idx],
                          action: Lang.bind(dialog, function() {
                              dialog.emit('response', button);
                          })});
    }
    dialog.setButtons(buttons);
function _setLabelsForMessage(dialog, message) {
    let labels = message.split('\n');
    _setLabelText(dialog.subjectLabel, labels.shift());
    if (labels.length > 0)
        _setLabelText(dialog.descriptionLabel, labels.join('\n'));
function _createIcon(gicon) {
    return new St.Icon({ gicon: gicon,
                         style_class: 'shell-mount-operation-icon' })
/* -------------------------------------------------------- */
const ListItem = new Lang.Class({
    Name: 'ListItem',
    _init: function(app) {
        this._app = app;
        let layout = new St.BoxLayout({ vertical: false});
        this.actor = new St.Button({ style_class: 'show-processes-dialog-app-list-item',
                                     can_focus: true,
                                     child: layout,
                                     reactive: true,
                                     x_align: St.Align.START,
                                     x_fill: true });
        this._icon = this._app.create_icon_texture(LIST_ITEM_ICON_SIZE);
        let iconBin = new St.Bin({ style_class: 'show-processes-dialog-app-list-item-icon',
                                   child: this._icon });
        layout.add(iconBin);
        this._nameLabel = new St.Label({ text: this._app.get_name(),
                                         style_class: 'show-processes-dialog-app-list-item-name' });
        let labelBin = new St.Bin({ y_align: St.Align.MIDDLE,
                                    child: this._nameLabel });
        layout.add(labelBin);
        this.actor.connect('clicked', Lang.bind(this, this._onClicked));
    },
    _onClicked: function() {
        this.emit('activate');
        this._app.activate();
    }
Signals.addSignalMethods(ListItem.prototype);
const ShellMountOperation = new Lang.Class({
    Name: 'ShellMountOperation',
    _init: function(source, params) {
        params = Params.parse(params, { existingDialog: null });
        this._dialog = null;
        this._dialogId = 0;
        this._existingDialog = params.existingDialog;
        this._processesDialog = null;
        this.mountOp = new Shell.MountOperation();
        this.mountOp.connect('ask-question',
                             Lang.bind(this, this._onAskQuestion));
        this.mountOp.connect('ask-password',
                             Lang.bind(this, this._onAskPassword));
        this.mountOp.connect('show-processes-2',
                             Lang.bind(this, this._onShowProcesses2));
        this.mountOp.connect('aborted',
                             Lang.bind(this, this.close));
        this.mountOp.connect('show-unmount-progress',
                             Lang.bind(this, this._onShowUnmountProgress));
        this._gicon = source.get_icon();
    },
    _closeExistingDialog: function() {
        if (!this._existingDialog)
            return;
        this._existingDialog.close();
        this._existingDialog = null;
    },
    _onAskQuestion: function(op, message, choices) {
        this._closeExistingDialog();
        this._dialog = new ShellMountQuestionDialog(this._gicon);
        this._dialogId = this._dialog.connect('response', Lang.bind(this,
            function(object, choice) {
                this.mountOp.set_choice(choice);
                this.mountOp.reply(Gio.MountOperationResult.HANDLED);
                this.close();
            }));
        this._dialog.update(message, choices);
        this._dialog.open();
    },
    _onAskPassword: function(op, message, defaultUser, defaultDomain, flags) {
        if (this._existingDialog) {
            this._dialog = this._existingDialog;
            this._dialog.reaskPassword();
        } else {
            this._dialog = new ShellMountPasswordDialog(message, this._gicon, flags);
        }
        this._dialogId = this._dialog.connect('response', Lang.bind(this,
            function(object, choice, password, remember) {
                if (choice == -1) {
                    this.mountOp.reply(Gio.MountOperationResult.ABORTED);
                } else {
                    if (remember)
                        this.mountOp.set_password_save(Gio.PasswordSave.PERMANENTLY);
                    else
                        this.mountOp.set_password_save(Gio.PasswordSave.NEVER);
                    this.mountOp.set_password(password);
                    this.mountOp.reply(Gio.MountOperationResult.HANDLED);
                }
            }));
        this._dialog.open();
    },
    close: function(op) {
        this._closeExistingDialog();
        this._processesDialog = null;
        if (this._dialog) {
            this._dialog.close();
            this._dialog = null;
        }
        if (this._notifier) {
            this._notifier.done();
            this._notifier = null;
        }
    },
    _onShowProcesses2: function(op) {
        this._closeExistingDialog();
        let processes = op.get_show_processes_pids();
        let choices = op.get_show_processes_choices();
        let message = op.get_show_processes_message();
        if (!this._processesDialog) {
            this._processesDialog = new ShellProcessesDialog(this._gicon);
            this._dialog = this._processesDialog;
            this._dialogId = this._processesDialog.connect('response', Lang.bind(this,
                function(object, choice) {
                    if (choice == -1) {
                        this.mountOp.reply(Gio.MountOperationResult.ABORTED);
                    } else {
                        this.mountOp.set_choice(choice);
                        this.mountOp.reply(Gio.MountOperationResult.HANDLED);
                    }
                    this.close();
                }));
            this._processesDialog.open();
        }
        this._processesDialog.update(message, processes, choices);
    },
    _onShowUnmountProgress: function(op, message, timeLeft, bytesLeft) {
        if (!this._notifier)
            this._notifier = new ShellUnmountNotifier();
            
        if (bytesLeft == 0)
            this._notifier.done(message);
        else
            this._notifier.show(message);
    },
    borrowDialog: function() {
        if (this._dialogId != 0) {
            this._dialog.disconnect(this._dialogId);
            this._dialogId = 0;
        }
        return this._dialog;
    }
const ShellUnmountNotifier = new Lang.Class({
    Name: 'ShellUnmountNotifier',
    Extends: MessageTray.Source,
    _init: function() {
        this.parent('', 'media-removable');
        this._notification = null;
        Main.messageTray.add(this);
    },
    show: function(message) {
        let [header, text] = message.split('\n', 2);
        if (!this._notification) {
            this._notification = new MessageTray.Notification(this, header, text);
            this._notification.setTransient(true);
            this._notification.setUrgency(MessageTray.Urgency.CRITICAL);
        } else {
            this._notification.update(header, text);
        }
        this.notify(this._notification);
    },
    done: function(message) {
        if (this._notification) {
            this._notification.destroy();
            this._notification = null;
        }
        if (message) {
            let notification = new MessageTray.Notification(this, message, null);
            notification.setTransient(true);
            this.notify(notification);
        }
    }
const ShellMountQuestionDialog = new Lang.Class({
    Name: 'ShellMountQuestionDialog',
    Extends: ModalDialog.ModalDialog,
    _init: function(gicon) {
        this.parent({ styleClass: 'mount-question-dialog' });
        let mainContentLayout = new St.BoxLayout();
        this.contentLayout.add(mainContentLayout, { x_fill: true,
                                                    y_fill: false });
        this._iconBin = new St.Bin({ child: _createIcon(gicon) });
        mainContentLayout.add(this._iconBin,
                              { x_fill:  true,
                                y_fill:  false,
                                x_align: St.Align.END,
                                y_align: St.Align.MIDDLE });
        let messageLayout = new St.BoxLayout({ vertical: true });
        mainContentLayout.add(messageLayout,
                              { y_align: St.Align.START });
        this.subjectLabel = new St.Label({ style_class: 'mount-question-dialog-subject' });
        this.subjectLabel.clutter_text.ellipsize = Pango.EllipsizeMode.NONE;
        this.subjectLabel.clutter_text.line_wrap = true;
        messageLayout.add(this.subjectLabel,
                          { y_fill:  false,
                            y_align: St.Align.START });
        this.descriptionLabel = new St.Label({ style_class: 'mount-question-dialog-description' });
        this.descriptionLabel.clutter_text.ellipsize = Pango.EllipsizeMode.NONE;
        this.descriptionLabel.clutter_text.line_wrap = true;
        messageLayout.add(this.descriptionLabel,
                          { y_fill:  true,
                            y_align: St.Align.START });
    },
    update: function(message, choices) {
        _setLabelsForMessage(this, message);
        _setButtonsForChoices(this, choices);
    }
Signals.addSignalMethods(ShellMountQuestionDialog.prototype);
const ShellMountPasswordDialog = new Lang.Class({
    Name: 'ShellMountPasswordDialog',
    Extends: ModalDialog.ModalDialog,
    _init: function(message, gicon, flags) {
        let strings = message.split('\n');
        this.parent({ styleClass: 'prompt-dialog' });
        let mainContentBox = new St.BoxLayout({ style_class: 'prompt-dialog-main-layout',
                                                vertical: false });
        this.contentLayout.add(mainContentBox);
        let icon = _createIcon(gicon);
        mainContentBox.add(icon,
                           { x_fill:  true,
                             y_fill:  false,
                             x_align: St.Align.END,
                             y_align: St.Align.START });
        this._messageBox = new St.BoxLayout({ style_class: 'prompt-dialog-message-layout',
                                              vertical: true });
        mainContentBox.add(this._messageBox,
                           { y_align: St.Align.START, expand: true, x_fill: true, y_fill: true });
        let subject = new St.Label({ style_class: 'prompt-dialog-headline headline' });
        this._messageBox.add(subject,
                             { y_fill:  false,
                               y_align: St.Align.START });
        if (strings[0])
            subject.set_text(strings[0]);
        let description = new St.Label({ style_class: 'prompt-dialog-description' });
        description.clutter_text.ellipsize = Pango.EllipsizeMode.NONE;
        description.clutter_text.line_wrap = true;
        this._messageBox.add(description,
                            { y_fill:  true,
                              y_align: St.Align.START });
        if (strings[1])
            description.set_text(strings[1]);
        this._passwordBox = new St.BoxLayout({ vertical: false, style_class: 'prompt-dialog-password-box' });
        this._messageBox.add(this._passwordBox);
        this._passwordLabel = new St.Label(({ style_class: 'prompt-dialog-password-label',
                                              text: _("Password") }));
        this._passwordBox.add(this._passwordLabel, { y_fill: false, y_align: St.Align.MIDDLE });
        this._passwordEntry = new St.Entry({ style_class: 'prompt-dialog-password-entry',
                                             text: "",
                                             can_focus: true});
        ShellEntry.addContextMenu(this._passwordEntry, { isPassword: true });
        this._passwordEntry.clutter_text.connect('activate', Lang.bind(this, this._onEntryActivate));
        this._passwordEntry.clutter_text.set_password_char('\u25cf'); // 
 U+25CF BLACK CIRCLE
        this._passwordBox.add(this._passwordEntry, {expand: true });
        this.setInitialKeyFocus(this._passwordEntry);
        this._errorMessageLabel = new St.Label({ style_class: 'prompt-dialog-error-label',
                                                 text: _("Sorry, that didn\'t work. Please try again.") });
        this._errorMessageLabel.clutter_text.ellipsize = Pango.EllipsizeMode.NONE;
        this._errorMessageLabel.clutter_text.line_wrap = true;
        this._errorMessageLabel.hide();
        this._messageBox.add(this._errorMessageLabel);
        if (flags & Gio.AskPasswordFlags.SAVING_SUPPORTED) {
            this._rememberChoice = new CheckBox.CheckBox();
            this._rememberChoice.getLabelActor().text = _("Remember Password");
            this._rememberChoice.actor.checked =
                global.settings.get_boolean(REMEMBER_MOUNT_PASSWORD_KEY);
            this._messageBox.add(this._rememberChoice.actor);
        } else {
            this._rememberChoice = null;
        }
        let buttons = [{ label: _("Cancel"),
                         action: Lang.bind(this, this._onCancelButton),
                         key:    Clutter.Escape
                       },
                       { label: _("Unlock"),
                         action: Lang.bind(this, this._onUnlockButton),
                         default: true
                       }];
        this.setButtons(buttons);
    },
    reaskPassword: function() {
        this._passwordEntry.set_text('');
        this._errorMessageLabel.show();
    },
    _onCancelButton: function() {
        this.emit('response', -1, '', false);
    },
    _onUnlockButton: function() {
        this._onEntryActivate();
    },
    _onEntryActivate: function() {
        global.settings.set_boolean(REMEMBER_MOUNT_PASSWORD_KEY,
            this._rememberChoice && this._rememberChoice.actor.checked);
        this.emit('response', 1,
            this._passwordEntry.get_text(),
            this._rememberChoice &&
            this._rememberChoice.actor.checked);
    }
const ShellProcessesDialog = new Lang.Class({
    Name: 'ShellProcessesDialog',
    Extends: ModalDialog.ModalDialog,
    _init: function(gicon) {
        this.parent({ styleClass: 'show-processes-dialog' });
        let mainContentLayout = new St.BoxLayout();
        this.contentLayout.add(mainContentLayout, { x_fill: true,
                                                    y_fill: false });
        this._iconBin = new St.Bin({ child: _createIcon(gicon) });
        mainContentLayout.add(this._iconBin,
                              { x_fill:  true,
                                y_fill:  false,
                                x_align: St.Align.END,
                                y_align: St.Align.MIDDLE });
        let messageLayout = new St.BoxLayout({ vertical: true });
        mainContentLayout.add(messageLayout,
                              { y_align: St.Align.START });
        this.subjectLabel = new St.Label({ style_class: 'show-processes-dialog-subject' });
        messageLayout.add(this.subjectLabel,
                          { y_fill:  false,
                            y_align: St.Align.START });
        this.descriptionLabel = new St.Label({ style_class: 'show-processes-dialog-description' });
        this.descriptionLabel.clutter_text.ellipsize = Pango.EllipsizeMode.NONE;
        this.descriptionLabel.clutter_text.line_wrap = true;
        messageLayout.add(this.descriptionLabel,
                          { y_fill:  true,
                            y_align: St.Align.START });
        let scrollView = new St.ScrollView({ style_class: 'show-processes-dialog-app-list'});
        scrollView.set_policy(Gtk.PolicyType.NEVER,
                              Gtk.PolicyType.AUTOMATIC);
        this.contentLayout.add(scrollView,
                               { x_fill: true,
                                 y_fill: true });
        scrollView.hide();
        this._applicationList = new St.BoxLayout({ vertical: true });
        scrollView.add_actor(this._applicationList);
        this._applicationList.connect('actor-added',
                                      Lang.bind(this, function() {
                                          if (this._applicationList.get_n_children() == 1)
                                              scrollView.show();
                                      }));
        this._applicationList.connect('actor-removed',
                                      Lang.bind(this, function() {
                                          if (this._applicationList.get_n_children() == 0)
                                              scrollView.hide();
                                      }));
    },
    _setAppsForPids: function(pids) {
        // remove all the items
        this._applicationList.destroy_all_children();
        pids.forEach(Lang.bind(this, function(pid) {
            let tracker = Shell.WindowTracker.get_default();
            let app = tracker.get_app_from_pid(pid);
            if (!app)
                return;
            let item = new ListItem(app);
            this._applicationList.add(item.actor, { x_fill: true });
            item.connect('activate',
                         Lang.bind(this, function() {
                             // use -1 to indicate Cancel
                             this.emit('response', -1);
                         }));
        }));
    },
    update: function(message, processes, choices) {
        this._setAppsForPids(processes);
        _setLabelsForMessage(this, message);
        _setButtonsForChoices(this, choices);
    }
Signals.addSignalMethods(ShellProcessesDialog.prototype);
const GnomeShellMountOpIface = '<node> \
<interface name="org.Gtk.MountOperationHandler"> \
<method name="AskPassword"> \
    <arg type="s" direction="in" name="object_id"/> \
    <arg type="s" direction="in" name="message"/> \
    <arg type="s" direction="in" name="icon_name"/> \
    <arg type="s" direction="in" name="default_user"/> \
    <arg type="s" direction="in" name="default_domain"/> \
    <arg type="u" direction="in" name="flags"/> \
    <arg type="u" direction="out" name="response"/> \
    <arg type="a{sv}" direction="out" name="response_details"/> \
</method> \
<method name="AskQuestion"> \
    <arg type="s" direction="in" name="object_id"/> \
    <arg type="s" direction="in" name="message"/> \
    <arg type="s" direction="in" name="icon_name"/> \
    <arg type="as" direction="in" name="choices"/> \
    <arg type="u" direction="out" name="response"/> \
    <arg type="a{sv}" direction="out" name="response_details"/> \
</method> \
<method name="ShowProcesses"> \
    <arg type="s" direction="in" name="object_id"/> \
    <arg type="s" direction="in" name="message"/> \
    <arg type="s" direction="in" name="icon_name"/> \
    <arg type="ai" direction="in" name="application_pids"/> \
    <arg type="as" direction="in" name="choices"/> \
    <arg type="u" direction="out" name="response"/> \
    <arg type="a{sv}" direction="out" name="response_details"/> \
</method> \
<method name="Close"/> \
</interface> \
</node>';
const ShellMountOperationType = {
    NONE: 0,
    ASK_PASSWORD: 1,
    ASK_QUESTION: 2,
    SHOW_PROCESSES: 3
const GnomeShellMountOpHandler = new Lang.Class({
    Name: 'GnomeShellMountOpHandler',
    _init: function() {
        this._dbusImpl = Gio.DBusExportedObject.wrapJSObject(GnomeShellMountOpIface, this);
        this._dbusImpl.export(Gio.DBus.session, '/org/gtk/MountOperationHandler');
        Gio.bus_own_name_on_connection(Gio.DBus.session, 'org.gtk.MountOperationHandler',
                                       Gio.BusNameOwnerFlags.REPLACE, null, null);
        this._dialog = null;
        this._volumeMonitor = Gio.VolumeMonitor.get();
        this._ensureEmptyRequest();
    },
    _ensureEmptyRequest: function() {
        this._currentId = null;
        this._currentInvocation = null;
        this._currentType = ShellMountOperationType.NONE;
    },
    _clearCurrentRequest: function(response, details) {
        if (this._currentInvocation) {
            this._currentInvocation.return_value(
                GLib.Variant.new('(ua{sv})', [response, details]));
        }
        this._ensureEmptyRequest();
    },
    _setCurrentRequest: function(invocation, id, type) {
        let oldId = this._currentId;
        let oldType = this._currentType;
        let requestId = id + '@' + invocation.get_sender();
        this._clearCurrentRequest(Gio.MountOperationResult.UNHANDLED, {});
        this._currentInvocation = invocation;
        this._currentId = requestId;
        this._currentType = type;
        if (this._dialog && (oldId == requestId) && (oldType == type))
            return true;
        return false;
    },
    _closeDialog: function() {
        if (this._dialog) {
            this._dialog.close();
            this._dialog = null;
        }
    },
    _createGIcon: function(iconName) {
        let realIconName = iconName ? iconName : 'drive-harddisk';
        return new Gio.ThemedIcon({ name: realIconName,
                                    use_default_fallbacks: true });
    },
    /**
     * AskPassword:
     * @id: an opaque ID identifying the object for which the operation is requested
     *      The ID must be unique in the context of the calling process.
     * @message: the message to display
     * @icon_name: the name of an icon to display
     * @default_user: the default username for display
     * @default_domain: the default domain for display
     * @flags: a set of GAskPasswordFlags
     * @response: a GMountOperationResult
     * @response_details: a dictionary containing the response details as
     * entered by the user. The dictionary MAY contain the following properties:
     *   - "password" -> (s): a password to be used to complete the mount operation
     *   - "password_save" -> (u): a GPasswordSave
     *
     * The dialog will stay visible until clients call the Close() method, or
     * another dialog becomes visible.
     * Calling AskPassword again for the same id will have the effect to clear
     * the existing dialog and update it with a message indicating the previous
     * attempt went wrong.
     */
    AskPasswordAsync: function(params, invocation) {
        let [id, message, iconName, defaultUser, defaultDomain, flags] = params;
        if (this._setCurrentRequest(invocation, id, ShellMountOperationType.ASK_PASSWORD)) {
            this._dialog.reaskPassword();
            return;
        }
        this._closeDialog();
        this._dialog = new ShellMountPasswordDialog(message, this._createGIcon(iconName), flags);
        this._dialog.connect('response', Lang.bind(this,
            function(object, choice, password, remember) {
                let details = {};
                let response;
                if (choice == -1) {
                    response = Gio.MountOperationResult.ABORTED;
                } else {
                    response = Gio.MountOperationResult.HANDLED;
                    let passSave = remember ? Gio.PasswordSave.PERMANENTLY : Gio.PasswordSave.NEVER;
                    details['password_save'] = GLib.Variant.new('u', passSave);
                    details['password'] = GLib.Variant.new('s', password);
                }
                this._clearCurrentRequest(response, details);
            }));
        this._dialog.open();
    },
    /**
     * AskQuestion:
     * @id: an opaque ID identifying the object for which the operation is requested
     *      The ID must be unique in the context of the calling process.
     * @message: the message to display
     * @icon_name: the name of an icon to display
     * @choices: an array of choice strings
     * GetResponse:
     * @response: a GMountOperationResult
     * @response_details: a dictionary containing the response details as
     * entered by the user. The dictionary MAY contain the following properties:
     *   - "choice" -> (i): the chosen answer among the array of strings passed in
     *
     * The dialog will stay visible until clients call the Close() method, or
     * another dialog becomes visible.
     * Calling AskQuestion again for the same id will have the effect to clear
     * update the dialog with the new question.
     */
    AskQuestionAsync: function(params, invocation) {
        let [id, message, iconName, choices] = params;
        if (this._setCurrentRequest(invocation, id, ShellMountOperationType.ASK_QUESTION)) {
            this._dialog.update(message, choices);
            return;
        }
        this._closeDialog();
        this._dialog = new ShellMountQuestionDialog(this._createGIcon(iconName), message);
        this._dialog.connect('response', Lang.bind(this,
            function(object, choice) {
                this._clearCurrentRequest(Gio.MountOperationResult.HANDLED,
                                          { choice: GLib.Variant.new('i', choice) });
            }));
        this._dialog.update(message, choices);
        this._dialog.open();
    },
    /**
     * ShowProcesses:
     * @id: an opaque ID identifying the object for which the operation is requested
     *      The ID must be unique in the context of the calling process.
     * @message: the message to display
     * @icon_name: the name of an icon to display
     * @application_pids: the PIDs of the applications to display
     * @choices: an array of choice strings
     * @response: a GMountOperationResult
     * @response_details: a dictionary containing the response details as
     * entered by the user. The dictionary MAY contain the following properties:
     *   - "choice" -> (i): the chosen answer among the array of strings passed in
     *
     * The dialog will stay visible until clients call the Close() method, or
     * another dialog becomes visible.
     * Calling ShowProcesses again for the same id will have the effect to clear
     * the existing dialog and update it with the new message and the new list
     * of processes.
     */
    ShowProcessesAsync: function(params, invocation) {
        let [id, message, iconName, applicationPids, choices] = params;
        if (this._setCurrentRequest(invocation, id, ShellMountOperationType.SHOW_PROCESSES)) {
            this._dialog.update(message, applicationPids, choices);
            return;
        }
        this._closeDialog();
        this._dialog = new ShellProcessesDialog(this._createGIcon(iconName));
        this._dialog.connect('response', Lang.bind(this,
            function(object, choice) {
                let response;
                let details = {};
                if (choice == -1) {
                    response = Gio.MountOperationResult.ABORTED;
                } else {
                    response = Gio.MountOperationResult.HANDLED;
                    details['choice'] = GLib.Variant.new('i', choice);
                }
                this._clearCurrentRequest(response, details);
            }));
        this._dialog.update(message, applicationPids, choices);
        this._dialog.open();
    },
    /**
     * Close:
     *
     * Closes a dialog previously opened by AskPassword, AskQuestion or ShowProcesses.
     * If no dialog is open, does nothing.
     */
    Close: function(params, invocation) {
        this._clearCurrentRequest(Gio.MountOperationResult.UNHANDLED, {});
        this._closeDialog();
    }
(uuay)status/
core.js
// -*- mode: js; js-indent-level: 4; indent-tabs-mode: nil -*-
const System = imports.system;
const Main = imports.ui.main;
const Scripting = imports.ui.scripting;
// This performance script measure the most important (core) performance
// metrics for the shell. By looking at the output metrics of this script
// someone should be able to get an idea of how well the shell is performing
// on a particular system.
let METRICS = {
    overviewLatencyFirst:
    { description: "Time to first frame after triggering overview, first time",
      units: "us" },
    overviewFpsFirst:
    { description: "Frame rate when going to the overview, first time",
      units: "frames / s" },
    overviewLatencySubsequent:
    { description: "Time to first frame after triggering overview, second time",
      units: "us"},
    overviewFpsSubsequent:
    { description: "Frames rate when going to the overview, second time",
      units: "frames / s" },
    overviewFps5Windows:
    { description: "Frames rate when going to the overview, 5 windows open",
      units: "frames / s" },
    overviewFps10Windows:
    { description: "Frames rate when going to the overview, 10 windows open",
      units: "frames / s" },
    overviewFps5Maximized:
    { description: "Frames rate when going to the overview, 5 maximized windows open",
      units: "frames / s" },
    overviewFps10Maximized:
    { description: "Frames rate when going to the overview, 10 maximized windows open",
      units: "frames / s" },
    overviewFps5Alpha:
    { description: "Frames rate when going to the overview, 5 alpha-transparent windows open",
      units: "frames / s" },
    overviewFps10Alpha:
    { description: "Frames rate when going to the overview, 10 alpha-transparent windows open",
      units: "frames / s" },
    usedAfterOverview:
    { description: "Malloc'ed bytes after the overview is shown once",
      units: "B" },
    leakedAfterOverview:
    { description: "Additional malloc'ed bytes the second time the overview is shown",
      units: "B" },
    applicationsShowTimeFirst:
    { description: "Time to switch to applications view, first time",
      units: "us" },
    applicationsShowTimeSubsequent:
    { description: "Time to switch to applications view, second time",
      units: "us"}
let WINDOW_CONFIGS = [
    { width: 640, height: 480, alpha: false, maximized: false, count: 1,  metric: 'overviewFpsSubsequent' },
    { width: 640, height: 480, alpha: false, maximized: false, count: 5,  metric: 'overviewFps5Windows'  },
    { width: 640, height: 480, alpha: false, maximized: false, count: 10, metric: 'overviewFps10Windows'  },
    { width: 640, height: 480, alpha: false, maximized: true,  count: 5,  metric: 'overviewFps5Maximized' },
    { width: 640, height: 480, alpha: false, maximized: true,  count: 10, metric: 'overviewFps10Maximized' },
    { width: 640, height: 480, alpha: true,  maximized: false, count: 5,  metric: 'overviewFps5Alpha' },
    { width: 640, height: 480, alpha: true,  maximized: false, count: 10, metric: 'overviewFps10Alpha' }
function run() {
    Scripting.defineScriptEvent("overviewShowStart", "Starting to show the overview");
    Scripting.defineScriptEvent("overviewShowDone", "Overview finished showing");
    Scripting.defineScriptEvent("afterShowHide", "After a show/hide cycle for the overview");
    Scripting.defineScriptEvent("applicationsShowStart", "Starting to switch to applications view");
    Scripting.defineScriptEvent("applicationsShowDone", "Done switching to applications view");
    // Enable recording of timestamps for different points in the frame cycle
    global.frame_timestamps = true;
    Main.overview.connect('shown', function() {
                              Scripting.scriptEvent('overviewShowDone');
                          });
    yield Scripting.sleep(1000);
    for (let i = 0; i < 2 * WINDOW_CONFIGS.length; i++) {
        // We go to the overview twice for each configuration; the first time
        // to calculate the mipmaps for the windows, the second time to get
        // a clean set of numbers.
        if ((i % 2) == 0) {
            let config = WINDOW_CONFIGS[i / 2];
            yield Scripting.destroyTestWindows();
            for (let k = 0; k < config.count; k++)
                yield Scripting.createTestWindow({ width: config.width,
                                                   height: config.height,
                                                   alpha: config.alpha,
                                                   maximized: config.maximized });
            yield Scripting.waitTestWindows();
            yield Scripting.sleep(1000);
            yield Scripting.waitLeisure();
        }
        Scripting.scriptEvent('overviewShowStart');
        Main.overview.show();
        yield Scripting.waitLeisure();
        Main.overview.hide();
        yield Scripting.waitLeisure();
        System.gc();
        yield Scripting.sleep(1000);
        Scripting.collectStatistics();
        Scripting.scriptEvent('afterShowHide');
    }
    yield Scripting.destroyTestWindows();
    yield Scripting.sleep(1000);
    Main.overview.show();
    yield Scripting.waitLeisure();
    for (let i = 0; i < 2; i++) {
        Scripting.scriptEvent('applicationsShowStart');
        Main.overview._dash.showAppsButton.checked = true;
        yield Scripting.waitLeisure();
        Scripting.scriptEvent('applicationsShowDone');
        Main.overview._dash.showAppsButton.checked = false;
        yield Scripting.waitLeisure();
    }
let showingOverview = false;
let finishedShowingOverview = false;
let overviewShowStart;
let overviewFrames;
let overviewLatency;
let mallocUsedSize = 0;
let overviewShowCount = 0;
let firstOverviewUsedSize;
let haveSwapComplete = false;
let applicationsShowStart;
let applicationsShowCount = 0;
function script_overviewShowStart(time) {
    showingOverview = true;
    finishedShowingOverview = false;
    overviewShowStart = time;
    overviewFrames = 0;
function script_overviewShowDone(time) {
    // We've set up the state at the end of the zoom out, but we
    // need to wait for one more frame to paint before we count
    // ourselves as done.
    finishedShowingOverview = true;
function script_applicationsShowStart(time) {
    applicationsShowStart = time;
function script_applicationsShowDone(time) {
    applicationsShowCount++;
    if (applicationsShowCount == 1)
        METRICS.applicationsShowTimeFirst.value = time - applicationsShowStart;
    else
        METRICS.applicationsShowTimeSubsequent.value = time - applicationsShowStart;
function script_afterShowHide(time) {
    if (overviewShowCount == 1) {
        METRICS.usedAfterOverview.value = mallocUsedSize;
    } else {
        METRICS.leakedAfterOverview.value = mallocUsedSize - METRICS.usedAfterOverview.value;
    }
function malloc_usedSize(time, bytes) {
    mallocUsedSize = bytes;
function _frameDone(time) {
    if (showingOverview) {
        if (overviewFrames == 0)
            overviewLatency = time - overviewShowStart;
        overviewFrames++;
    }
    if (finishedShowingOverview) {
        showingOverview = false;
        finishedShowingOverview = false;
        overviewShowCount++;
        let dt = (time - (overviewShowStart + overviewLatency)) / 1000000;
        // If we see a start frame and an end frame, that would
        // be 1 frame for a FPS computation, hence the '- 1'
        let fps = (overviewFrames - 1) / dt;
        if (overviewShowCount == 1) {
            METRICS.overviewLatencyFirst.value = overviewLatency;
            METRICS.overviewFpsFirst.value = fps;
        } else if (overviewShowCount == 2) {
            METRICS.overviewLatencySubsequent.value = overviewLatency;
        }
        // Other than overviewFpsFirst, we collect FPS metrics the second
        // we show each window configuration. overviewShowCount is 1,2,3...
        if (overviewShowCount % 2 == 0) {
            let config = WINDOW_CONFIGS[(overviewShowCount / 2) - 1];
            METRICS[config.metric].value = fps;
        }
    }
function glx_swapComplete(time, swapTime) {
    haveSwapComplete = true;
    _frameDone(swapTime);
function clutter_stagePaintDone(time) {
    // If we aren't receiving GLXBufferSwapComplete events, then we approximate
    // the time the user sees a frame with the time we finished doing drawing
    // commands for the frame. This doesn't take into account the time for
    // the GPU to finish painting, and the time for waiting for the buffer
    // swap, but if this are uniform - every frame takes the same time to draw -
    // then it won't upset our FPS calculation, though the latency value
    // will be slightly too low.
    if (!haveSwapComplete)
        _frameDone(time);
(uuay)extensionDownloader.js
// -*- mode: js; js-indent-level: 4; indent-tabs-mode: nil -*-
const Lang = imports.lang;
const Clutter = imports.gi.Clutter;
const GLib = imports.gi.GLib;
const Gio = imports.gi.Gio;
const Soup = imports.gi.Soup;
const St = imports.gi.St;
const Shell = imports.gi.Shell;
const Config = imports.misc.config;
const ExtensionUtils = imports.misc.extensionUtils;
const ExtensionSystem = imports.ui.extensionSystem;
const FileUtils = imports.misc.fileUtils;
const ModalDialog = imports.ui.modalDialog;
const _signals = ExtensionSystem._signals;
const REPOSITORY_URL_BASE = 'https://extensions.gnome.org';
const REPOSITORY_URL_DOWNLOAD = REPOSITORY_URL_BASE + '/download-extension/%s.shell-extension.zip';
const REPOSITORY_URL_INFO     = REPOSITORY_URL_BASE + '/extension-info/';
const REPOSITORY_URL_UPDATE   = REPOSITORY_URL_BASE + '/update-info/';
let _httpSession;
function installExtension(uuid, invocation) {
    let params = { uuid: uuid,
                   shell_version: Config.PACKAGE_VERSION };
    let message = Soup.form_request_new_from_hash('GET', REPOSITORY_URL_INFO, params);
    _httpSession.queue_message(message, function(session, message) {
        if (message.status_code != Soup.KnownStatusCode.OK) {
            ExtensionSystem.logExtensionError(uuid, 'downloading info: ' + message.status_code);
            invocation.return_dbus_error('org.gnome.Shell.DownloadInfoError', message.status_code.toString());
            return;
        }
        let info;
        try {
            info = JSON.parse(message.response_body.data);
        } catch (e) {
            ExtensionSystem.logExtensionError(uuid, 'parsing info: ' + e);
            invocation.return_dbus_error('org.gnome.Shell.ParseInfoError', e.toString());
            return;
        }
        let dialog = new InstallExtensionDialog(uuid, info, invocation);
        dialog.open(global.get_current_time());
    });
function uninstallExtension(uuid) {
    let extension = ExtensionUtils.extensions[uuid];
    if (!extension)
        return false;
    // Don't try to uninstall system extensions
    if (extension.type != ExtensionUtils.ExtensionType.PER_USER)
        return false;
    if (!ExtensionSystem.unloadExtension(extension))
        return false;
    FileUtils.recursivelyDeleteDir(extension.dir, true);
    return true;
function gotExtensionZipFile(session, message, uuid, dir, callback, errback) {
    if (message.status_code != Soup.KnownStatusCode.OK) {
        errback('DownloadExtensionError', message.status_code);
        return;
    }
    try {
        if (!dir.query_exists(null))
            dir.make_directory_with_parents(null);
    } catch (e) {
        errback('CreateExtensionDirectoryError', e);
        return;
    }
    let [file, stream] = Gio.File.new_tmp('XXXXXX.shell-extension.zip');
    let contents = message.response_body.flatten().get_as_bytes();
    stream.output_stream.write_bytes(contents, null);
    stream.close(null);
    let [success, pid] = GLib.spawn_async(null,
                                          ['unzip', '-uod', dir.get_path(), '--', file.get_path()],
                                          null,
                                          GLib.SpawnFlags.SEARCH_PATH | GLib.SpawnFlags.DO_NOT_REAP_CHILD,
                                          null);
    if (!success) {
        errback('ExtractExtensionError');
        return;
    }
    GLib.child_watch_add(GLib.PRIORITY_DEFAULT, pid, function(pid, status) {
        GLib.spawn_close_pid(pid);
        if (status != 0)
            errback('ExtractExtensionError');
        else
            callback();
    });
function updateExtension(uuid) {
    // This gets a bit tricky. We want the update to be seamless -
    // if we have any error during downloading or extracting, we
    // want to not unload the current version.
    let oldExtensionTmpDir = GLib.Dir.make_tmp('XXXXXX-shell-extension');
    let newExtensionTmpDir = GLib.Dir.make_tmp('XXXXXX-shell-extension');
    let params = { shell_version: Config.PACKAGE_VERSION };
    let url = REPOSITORY_URL_DOWNLOAD.format(uuid);
    let message = Soup.form_request_new_from_hash('GET', url, params);
    _httpSession.queue_message(message, Lang.bind(this, function(session, message) {
        gotExtensionZipFile(session, message, uuid, newExtensionTmpDir, function() {
            let oldExtension = ExtensionUtils.extensions[uuid];
            let extensionDir = oldExtension.dir;
            if (!ExtensionSystem.unloadExtension(oldExtension))
                return;
            FileUtils.recursivelyMoveDir(extensionDir, oldExtensionTmpDir);
            FileUtils.recursivelyMoveDir(newExtensionTmpDir, extensionDir);
            let extension = ExtensionUtils.createExtensionObject(uuid, extensionDir, ExtensionUtils.ExtensionType.PER_USER);
            try {
                ExtensionSystem.loadExtension(extension);
            } catch(e) {
                ExtensionSystem.unloadExtension(extension);
                logError(e, 'Error loading extension %s'.format(uuid));
                FileUtils.recursivelyDeleteDir(extensionDir, false);
                FileUtils.recursivelyMoveDir(oldExtensionTmpDir, extensionDir);
                // Restore what was there before. We can't do much if we
                // fail here.
                ExtensionSystem.loadExtension(oldExtension);
                return;
            }
            FileUtils.recursivelyDeleteDir(oldExtensionTmpDir, true);
        }, function(code, message) {
            log('Error while updating extension %s: %s (%s)'.format(uuid, code, message ? message : ''));
        });
    }));
function checkForUpdates() {
    let metadatas = {};
    for (let uuid in ExtensionUtils.extensions) {
        metadatas[uuid] = ExtensionUtils.extensions[uuid].metadata;
    }
    let params = { shell_version: Config.PACKAGE_VERSION,
                   installed: JSON.stringify(metadatas) };
    let url = REPOSITORY_URL_UPDATE;
    let message = Soup.form_request_new_from_hash('GET', url, params);
    _httpSession.queue_message(message, function(session, message) {
        if (message.status_code != Soup.KnownStatusCode.OK)
            return;
        let operations = JSON.parse(message.response_body.data);
        for (let uuid in operations) {
            let operation = operations[uuid];
            if (operation == 'blacklist')
                uninstallExtension(uuid);
            else if (operation == 'upgrade' || operation == 'downgrade')
                updateExtension(uuid);
        }
    });
const InstallExtensionDialog = new Lang.Class({
    Name: 'InstallExtensionDialog',
    Extends: ModalDialog.ModalDialog,
    _init: function(uuid, info, invocation) {
        this.parent({ styleClass: 'extension-dialog' });
        this._uuid = uuid;
        this._info = info;
        this._invocation = invocation;
        this.setButtons([{ label: _("Cancel"),
                           action: Lang.bind(this, this._onCancelButtonPressed),
                           key:    Clutter.Escape
                         },
                         { label:  _("Install"),
                           action: Lang.bind(this, this._onInstallButtonPressed),
                           default: true
                         }]);
        let message = _("Download and install 
 from extensions.gnome.org?").format(info.name);
        let box = new St.BoxLayout({ style_class: 'prompt-dialog-main-layout',
                                     vertical: false });
        this.contentLayout.add(box);
        let gicon = new Gio.FileIcon({ file: Gio.File.new_for_uri(REPOSITORY_URL_BASE + info.icon) })
        let icon = new St.Icon({ gicon: gicon });
        box.add(icon);
        let label = new St.Label({ style_class: 'prompt-dialog-headline headline',
                                   text: message });
        box.add(label);
    },
    _onCancelButtonPressed: function(button, event) {
        this.close();
        this._invocation.return_value(GLib.Variant.new('(s)', ['cancelled']));
    },
    _onInstallButtonPressed: function(button, event) {
        let params = { shell_version: Config.PACKAGE_VERSION };
        let url = REPOSITORY_URL_DOWNLOAD.format(this._uuid);
        let message = Soup.form_request_new_from_hash('GET', url, params);
        let uuid = this._uuid;
        let dir = Gio.File.new_for_path(GLib.build_filenamev([global.userdatadir, 'extensions', uuid]));
        let invocation = this._invocation;
        function errback(code, message) {
            invocation.return_dbus_error('org.gnome.Shell.' + code, message ? message.toString() : '');
        }
        function callback() {
            // Add extension to 'enabled-extensions' for the user, always...
            let enabledExtensions = global.settings.get_strv(ExtensionSystem.ENABLED_EXTENSIONS_KEY);
            if (enabledExtensions.indexOf(uuid) == -1) {
                enabledExtensions.push(uuid);
                global.settings.set_strv(ExtensionSystem.ENABLED_EXTENSIONS_KEY, enabledExtensions);
            }
            let extension = ExtensionUtils.createExtensionObject(uuid, dir, ExtensionUtils.ExtensionType.PER_USER);
            try {
                ExtensionSystem.loadExtension(extension);
            } catch(e) {
                uninstallExtension(uuid);
                errback('LoadExtensionError', e);
                return;
            }
            invocation.return_value(GLib.Variant.new('(s)', 'successful'));
        }
        _httpSession.queue_message(message, Lang.bind(this, function(session, message) {
            gotExtensionZipFile(session, message, uuid, dir, callback, errback);
        }));
        this.close();
    }
function init() {
    _httpSession = new Soup.SessionAsync({ ssl_use_system_ca_file: true });
    // See: https://bugzilla.gnome.org/show_bug.cgi?id=655189 for context.
    // _httpSession.add_feature(new Soup.ProxyResolverDefault());
    Soup.Session.prototype.add_feature.call(_httpSession, new Soup.ProxyResolverDefault());
(uuay)
;*3$"
libgnome-shell.so.debug
7zXZ
;{,{
&<y(HZ
KH*"
zqP1q
$8[{`GN
2}6N`
2Qp4
bSu;
{&y\
Xb}$V
m,yq
:;Ar
\mO^Xt
aMN,
ZN#TXF
RwcN
/^IZ
Yzu5c
D9m7
v]c:Kx
0.M_
_;|j
KDC.
7})I
`{K(Z8
yzg-
1'qn
r$-R.r'
@W45
x\Y^\
3%Z2
ChUcdB2
Aj2Ul!^m
;K44z
i'pO
=a&L
6QQ:
XyUH
wt(^/
7/h\[t;
YJxo-Azzo
E|GE
x.I0J
cr_i
m	:(
B,b2
m/NW
6w]Ox
RUjf
?pku
AQQ]
a1j`5
~} c
XR<C
~gMH
e$4y
LA|u5#
^\pSX
DYd]t
BZiF
]E.n
19M-A
(eLN
T%	;
?GBFP
Mob*"
^[jl
cKqN
|GOTZ
Z8C!7
DsX/M~?M}U
`I\D"
T(0/
8	b(
Ep6o*
[y7-
Jto~2
L/E/G
+\c.
qp8aM
+sQa
wNWXw
b.yfx:;
[hNN
=;5)1~g^f
6N?c
JwCXO
a+AMu@
cC0pc
.?tvM
#X}d
d5.:]
Qq%trs2M7P
LfWQ
?t9F
h2?\%
kHOHm
%@Uw
txt>
DJ~+
Sw CX
`=W)d
X~9o
7?f;
YeBZ
clClb^
ESq1w(
6pJX
u8r5
`gc"
,_Tk~
{1Gc
.shstrtab
.note.gnu.build-id
.gnu.hash
.dynsym
.dynstr
.gnu.version
.gnu.version_r
.rela.dyn
.init
.plt
.plt.got
.text
.fini
.rodata
.gresource.shell_js_resources
.eh_frame_hdr
.eh_frame
.init_array
.fini_array
.jcr
.data.rel.ro
.dynamic
.data
.bss
.gnu_debuglink
.gnu_debugdata
