>	(f>
&?3t
qIi/N
LJEc7
T88t%G
`S,Ga
ix6c
__gmon_start__
_fini
_ITM_deregisterTMCloneTable
_ITM_registerTMCloneTable
__cxa_finalize
_Jv_RegisterClasses
LLVMRustHasFeature
LLVMRustPrintPasses
LLVMSetDebug
_Unwind_Resume
_ZN100_$LT$rustc_mir..transform..dump_mir..Marker$LT$$u27$b$GT$$u20$as$u20$rustc..mir..transform..Pass$GT$4name17hbc7f964a0f395fabE
_ZN103_$LT$rustc_driver..pretty..IdentifiedAnnotation$LT$$u27$ast$GT$$u20$as$u20$rustc..hir..print..PpAnn$GT$3pre17h5cfddf79beb313fbE
_ZN103_$LT$rustc_driver..pretty..IdentifiedAnnotation$LT$$u27$ast$GT$$u20$as$u20$rustc..hir..print..PpAnn$GT$4post17hcb5b0b872ef8573bE
_ZN104_$LT$rustc_driver..pretty..HygieneAnnotation$LT$$u27$ast$GT$$u20$as$u20$syntax..print..pprust..PpAnn$GT$4post17h200bd48cc6c9b612E
_ZN105_$LT$syntax..codemap..Spanned$LT$syntax..ast..Attribute_$GT$$u20$as$u20$syntax..attr..AttrMetaMethods$GT$10check_name17hd1f4befb315cd9e7E
_ZN105_$LT$syntax..codemap..Spanned$LT$syntax..ast..Attribute_$GT$$u20$as$u20$syntax..attr..AttrMetaMethods$GT$9value_str17h6c9b23dcafcf7de0E
_ZN106_$LT$rustc..hir..print..State$LT$$u27$a$GT$$u20$as$u20$syntax..print..pprust..PrintState$LT$$u27$a$GT$$GT$6writer17h8e45258181f28974E
_ZN106_$LT$rustc_metadata..macro_import..MacroLoader$LT$$u27$a$GT$$u20$as$u20$syntax..ext..base..MacroLoader$GT$10load_crate17h522ede28e84e6c82E
_ZN107_$LT$rustc_driver..pretty..IdentifiedAnnotation$LT$$u27$ast$GT$$u20$as$u20$syntax..print..pprust..PpAnn$GT$3pre17h1c17b7808bf7fbbeE
_ZN107_$LT$rustc_driver..pretty..IdentifiedAnnotation$LT$$u27$ast$GT$$u20$as$u20$syntax..print..pprust..PpAnn$GT$4post17hc2ed9b8a52e91cbcE
_ZN108_$LT$rustc_driver..driver..assign_node_ids..NodeIdAssigner$LT$$u27$a$GT$$u20$as$u20$syntax..fold..Folder$GT$10fold_block17hcf9c8a5522ce3102E
_ZN108_$LT$rustc_driver..driver..assign_node_ids..NodeIdAssigner$LT$$u27$a$GT$$u20$as$u20$syntax..fold..Folder$GT$6new_id17h6e63058be9aeef27E
_ZN109_$LT$rustc..ty..context..TyCtxt$LT$$u27$a$C$$u20$$u27$gcx$C$$u20$$u27$tcx$GT$$u20$as$u20$core..ops..Deref$GT$5deref17h86b42bcbe9498c21E
_ZN109_$LT$rustc_mir..transform..simplify_cfg..SimplifyCfg$LT$$u27$l$GT$$u20$as$u20$rustc..mir..transform..Pass$GT$13disambiguator17h45029941e06672a1E
_ZN109_$LT$rustc_mir..transform..simplify_cfg..SimplifyCfg$LT$$u27$l$GT$$u20$as$u20$rustc..mir..transform..Pass$GT$4name17h58acbc7c3837e6afE
_ZN10rustc_back4sha26Sha2563new17hb2c0795b2b060c08E
_ZN10rustc_lint17register_builtins17h24bc2a3c3452f1baE
_ZN10syntax_ext17register_builtins17h842383d407f56a23E
_ZN10syntax_pos10SPAN_DEBUG17h96bb41e52dd37610E
_ZN10syntax_pos7FileMap11is_imported17hf15ed610102e309aE
_ZN10syntax_pos7FileMap12is_real_file17h700684fdf89233b2E
_ZN10syntax_pos9MultiSpan12primary_span17he54607dd4d928661E
_ZN10syntax_pos9MultiSpan3new17h2eabec81831967d7E
_ZN110_$LT$rustc_mir..transform..dump_mir..DumpMir$u20$as$u20$rustc..mir..transform..MirPassHook$LT$$u27$tcx$GT$$GT$11on_mir_pass17h1cd603e402d461fcE
_ZN110_$LT$rustc_mir..transform..type_check..TypeckMir$u20$as$u20$rustc..mir..transform..MirPass$LT$$u27$tcx$GT$$GT$8run_pass17h31d4990af26b9163E
_ZN110_$LT$syntax..print..pprust..State$LT$$u27$a$GT$$u20$as$u20$syntax..print..pprust..PrintState$LT$$u27$a$GT$$GT$6writer17h34497bf8f8dd2055E
_ZN112_$LT$rustc_driver..pretty..TypedAnnotation$LT$$u27$a$C$$u20$$u27$tcx$GT$$u20$as$u20$rustc..hir..print..PpAnn$GT$3pre17ha93f61f8fc56614dE
_ZN112_$LT$rustc_driver..pretty..TypedAnnotation$LT$$u27$a$C$$u20$$u27$tcx$GT$$u20$as$u20$rustc..hir..print..PpAnn$GT$4post17h971aa89891630dbeE
_ZN116_$LT$rustc..cfg..graphviz..LabelledCFG$LT$$u27$a$C$$u20$$u27$ast$GT$$u20$as$u20$graphviz..Labeller$LT$$u27$a$GT$$GT$10edge_label17h9d4326f7553e93b3E
_ZN116_$LT$rustc..cfg..graphviz..LabelledCFG$LT$$u27$a$C$$u20$$u27$ast$GT$$u20$as$u20$graphviz..Labeller$LT$$u27$a$GT$$GT$10node_label17h8b1b9b9cff539076E
_ZN116_$LT$rustc..cfg..graphviz..LabelledCFG$LT$$u27$a$C$$u20$$u27$ast$GT$$u20$as$u20$graphviz..Labeller$LT$$u27$a$GT$$GT$7node_id17h16f2bac499444a8eE
_ZN116_$LT$rustc..cfg..graphviz..LabelledCFG$LT$$u27$a$C$$u20$$u27$ast$GT$$u20$as$u20$graphviz..Labeller$LT$$u27$a$GT$$GT$8graph_id17h1b2ccd24f6de3b11E
_ZN116_$LT$rustc_driver..pretty..NoAnn$LT$$u27$ast$GT$$u20$as$u20$rustc_driver..pretty..PrinterSupport$LT$$u27$ast$GT$$GT$4sess17hb82c1693ca61ec94E
_ZN116_$LT$rustc_driver..pretty..NoAnn$LT$$u27$ast$GT$$u20$as$u20$rustc_driver..pretty..PrinterSupport$LT$$u27$ast$GT$$GT$6pp_ann17haede5b130071c4ffE
_ZN116_$LT$rustc_driver..pretty..NoAnn$LT$$u27$ast$GT$$u20$as$u20$rustc_driver..pretty..PrinterSupport$LT$$u27$ast$GT$$GT$7ast_map17h1636fb69aa690e86E
_ZN116_$LT$rustc_mir..transform..erase_regions..EraseRegions$u20$as$u20$rustc..mir..transform..MirPass$LT$$u27$tcx$GT$$GT$8run_pass17h9ef47ada483e247dE
_ZN117_$LT$rustc..cfg..graphviz..LabelledCFG$LT$$u27$a$C$$u20$$u27$ast$GT$$u20$as$u20$graphviz..GraphWalk$LT$$u27$a$GT$$GT$5edges17he079721be4a9b56fE
_ZN117_$LT$rustc..cfg..graphviz..LabelledCFG$LT$$u27$a$C$$u20$$u27$ast$GT$$u20$as$u20$graphviz..GraphWalk$LT$$u27$a$GT$$GT$5nodes17h2f5c0e09941f1e92E
_ZN117_$LT$rustc..cfg..graphviz..LabelledCFG$LT$$u27$a$C$$u20$$u27$ast$GT$$u20$as$u20$graphviz..GraphWalk$LT$$u27$a$GT$$GT$6source17h11a3dc5d35d2b725E
_ZN117_$LT$rustc..cfg..graphviz..LabelledCFG$LT$$u27$a$C$$u20$$u27$ast$GT$$u20$as$u20$graphviz..GraphWalk$LT$$u27$a$GT$$GT$6target17h2181d9411a094a0aE
_ZN117_$LT$rustc..hir..map..NodesMatchingSuffix$LT$$u27$a$C$$u20$$u27$ast$GT$$u20$as$u20$core..iter..iterator..Iterator$GT$4next17h4a88f59965f2be71E
_ZN119_$LT$rustc_driver..pretty..NoAnn$LT$$u27$ast$GT$$u20$as$u20$rustc_driver..pretty..HirPrinterSupport$LT$$u27$ast$GT$$GT$4sess17h1ba8906c4663fd5eE
_ZN119_$LT$rustc_driver..pretty..NoAnn$LT$$u27$ast$GT$$u20$as$u20$rustc_driver..pretty..HirPrinterSupport$LT$$u27$ast$GT$$GT$6pp_ann17h4c246b68b4721ad1E
_ZN119_$LT$rustc_driver..pretty..NoAnn$LT$$u27$ast$GT$$u20$as$u20$rustc_driver..pretty..HirPrinterSupport$LT$$u27$ast$GT$$GT$7ast_map17h02a82e33724bb0f2E
_ZN119_$LT$rustc_driver..pretty..NodesMatchingUII$LT$$u27$a$C$$u20$$u27$ast$GT$$u20$as$u20$core..iter..iterator..Iterator$GT$4next17h8bb0cbcffcfe6fa0E
_ZN119_$LT$rustc_mir..transform..add_call_guards..AddCallGuards$u20$as$u20$rustc..mir..transform..MirPass$LT$$u27$tcx$GT$$GT$8run_pass17h81912b5b50419e14E
_ZN119_$LT$rustc_mir..transform..dump_mir..Marker$LT$$u27$b$GT$$u20$as$u20$rustc..mir..transform..MirPass$LT$$u27$tcx$GT$$GT$8run_pass17h0ff24ae030439808E
_ZN119_$LT$rustc_mir..transform..no_landing_pads..NoLandingPads$u20$as$u20$rustc..mir..transform..MirPass$LT$$u27$tcx$GT$$GT$8run_pass17hc65090220f47ac6cE
_ZN119_$LT$rustc_mir..transform..simplify_branches..SimplifyBranches$LT$$u27$l$GT$$u20$as$u20$rustc..mir..transform..Pass$GT$13disambiguator17h776ebf09945aed44E
_ZN119_$LT$rustc_mir..transform..simplify_branches..SimplifyBranches$LT$$u27$l$GT$$u20$as$u20$rustc..mir..transform..Pass$GT$4name17h2b63d67d10631219E
_ZN11collections3fmt6format17heef9fbdee800343fE
_ZN11collections3str21_$LT$impl$u20$str$GT$12to_lowercase17h0b671f2e82e65b80E
_ZN11collections3str62_$LT$impl$u20$collections..borrow..ToOwned$u20$for$u20$str$GT$8to_owned17h9d4d32d44257786dE
_ZN11rustc_trans4back4link11link_binary17h769519adaed4b511E
_ZN11rustc_trans4back4link15find_crate_name17h271990e5d2f3fe9eE
_ZN11rustc_trans4back4link18filename_for_input17h4456a7c547a172caE
_ZN11rustc_trans4back4link25default_output_for_target17h0ed2ac1eeab67488E
_ZN11rustc_trans4back4link25invalid_output_for_target17h454c1510152a9454E
_ZN11rustc_trans4back5write10run_passes17h4610f818f672d1a8E
_ZN11rustc_trans4back5write12cleanup_llvm17h0566c6f68514f6f4E
_ZN11rustc_trans4back5write13run_assembler17hf99996e1cdfc3260E
_ZN11rustc_trans4back5write21create_target_machine17hc7157c8ee0b21b5fE
_ZN11rustc_trans4base11trans_crate17h75826f6271b49fafE
_ZN122_$LT$core..str..pattern..StrSearcher$LT$$u27$a$C$$u20$$u27$b$GT$$u20$as$u20$core..str..pattern..Searcher$LT$$u27$a$GT$$GT$8haystack17h347d3cc389a43c4cE
_ZN125_$LT$rustc_borrowck..graphviz..DataflowLabeller$LT$$u27$a$C$$u20$$u27$tcx$GT$$u20$as$u20$graphviz..Labeller$LT$$u27$a$GT$$GT$10edge_label17he5cf20b3f2654f06E
_ZN125_$LT$rustc_borrowck..graphviz..DataflowLabeller$LT$$u27$a$C$$u20$$u27$tcx$GT$$u20$as$u20$graphviz..Labeller$LT$$u27$a$GT$$GT$10node_label17h8c91665a7a1e40fdE
_ZN125_$LT$rustc_borrowck..graphviz..DataflowLabeller$LT$$u27$a$C$$u20$$u27$tcx$GT$$u20$as$u20$graphviz..Labeller$LT$$u27$a$GT$$GT$7node_id17hcd6ef46546ac914fE
_ZN125_$LT$rustc_borrowck..graphviz..DataflowLabeller$LT$$u27$a$C$$u20$$u27$tcx$GT$$u20$as$u20$graphviz..Labeller$LT$$u27$a$GT$$GT$8graph_id17h70d479114474e64fE
_ZN126_$LT$rustc_borrowck..graphviz..DataflowLabeller$LT$$u27$a$C$$u20$$u27$tcx$GT$$u20$as$u20$graphviz..GraphWalk$LT$$u27$a$GT$$GT$5edges17ha1f945570402ca2aE
_ZN126_$LT$rustc_borrowck..graphviz..DataflowLabeller$LT$$u27$a$C$$u20$$u27$tcx$GT$$u20$as$u20$graphviz..GraphWalk$LT$$u27$a$GT$$GT$5nodes17h26eda54e3d5c2ef5E
_ZN126_$LT$rustc_borrowck..graphviz..DataflowLabeller$LT$$u27$a$C$$u20$$u27$tcx$GT$$u20$as$u20$graphviz..GraphWalk$LT$$u27$a$GT$$GT$6source17hc013dafcbb6dd505E
_ZN126_$LT$rustc_borrowck..graphviz..DataflowLabeller$LT$$u27$a$C$$u20$$u27$tcx$GT$$u20$as$u20$graphviz..GraphWalk$LT$$u27$a$GT$$GT$6target17h8f94043bbbe400e3E
_ZN128_$LT$rustc_driver..pretty..HygieneAnnotation$LT$$u27$ast$GT$$u20$as$u20$rustc_driver..pretty..PrinterSupport$LT$$u27$ast$GT$$GT$4sess17h2b8d20a69133c4caE
_ZN128_$LT$rustc_driver..pretty..HygieneAnnotation$LT$$u27$ast$GT$$u20$as$u20$rustc_driver..pretty..PrinterSupport$LT$$u27$ast$GT$$GT$6pp_ann17h891aa9c1720f946eE
_ZN128_$LT$rustc_driver..pretty..HygieneAnnotation$LT$$u27$ast$GT$$u20$as$u20$rustc_driver..pretty..PrinterSupport$LT$$u27$ast$GT$$GT$7ast_map17h7d5b582bff857896E
_ZN128_$LT$rustc_mir..transform..simplify_cfg..SimplifyCfg$LT$$u27$l$GT$$u20$as$u20$rustc..mir..transform..MirPass$LT$$u27$tcx$GT$$GT$8run_pass17hf1af3533bf83257bE
_ZN129_$LT$rustc_borrowck..borrowck..mir..elaborate_drops..ElaborateDrops$u20$as$u20$rustc..mir..transform..MirPass$LT$$u27$tcx$GT$$GT$8run_pass17h85d010c2a4439b1cE
_ZN12rustc_driver10make_input17h1251492f589350aeE
_ZN12rustc_driver11exit_on_err17h08b4fd0e12d2fcccE
_ZN12rustc_driver11make_output17hcb9d8a06f32b3dfeE
_ZN12rustc_driver11release_str17h0bd75b79859154b3E
_ZN12rustc_driver12run_compiler17h581448fb74257353E
_ZN12rustc_driver14describe_lints17h97b68d28a552fed0E
_ZN12rustc_driver14handle_options17h45ad8ad9f45712b3E
_ZN12rustc_driver15commit_date_str17hae247101f61abdfeE
_ZN12rustc_driver15commit_hash_str17h81a56980f74bf09fE
_ZN12rustc_driver15target_features17add_configuration17h4da33791d4dd2b07E
_ZN12rustc_driver17RustcDefaultCalls13list_metadata17h0d6ad0737e75b830E
_ZN12rustc_driver20diagnostics_registry17h01985ec596cf0524E
_ZN12rustc_driver3run17h9e288bc61b29400bE
_ZN12rustc_driver4main17he36b317218bfa3dcE
_ZN12rustc_driver6driver11count_nodes17h618ff4e1e076c0a6E
_ZN12rustc_driver6driver11source_name17h9bd7155db5eb5260E
_ZN12rustc_driver6driver13compile_input17hdfe4405d66704c31E
_ZN12rustc_driver6driver15PhaseController5basic17h520a930b5155c6feE
_ZN12rustc_driver6driver15assign_node_ids17hee317cc695cb008cE
_ZN12rustc_driver6driver16keep_mtwt_tables17h30c04af7fb900fa0E
_ZN12rustc_driver6driver17CompileController5basic17ha48ee31a4f0f1868E
_ZN12rustc_driver6driver19collect_crate_types17h3eb9d30698cb3219E
_ZN12rustc_driver6driver19phase_1_parse_input17h689388e8aa89ade9E
_ZN12rustc_driver6driver19phase_6_link_output17h23c275fd970d4972E
_ZN12rustc_driver6driver22build_output_filenames17h0b932d02a8bbfd92E
_ZN12rustc_driver6driver23phase_5_run_llvm_passes17h283134306ba7308aE
_ZN12rustc_driver6driver25phase_4_translate_to_llvm17hbc7e9672529bb439E
_ZN12rustc_driver6driver27compute_crate_disambiguator17h169d32aa2b56c63fE
_ZN12rustc_driver6driver28phase_2_configure_and_expand15__STATIC_FMTSTR17he1b294076965fd17E
_ZN12rustc_driver6driver8anon_src17h1008a90bdc81af1eE
_ZN12rustc_driver6pretty10fold_crate17h4d6ed8b5af237060E
_ZN12rustc_driver6pretty12parse_pretty17h35b9bc39b44bc284E
_ZN12rustc_driver6pretty19print_after_parsing17hc9b6e6fb756a54e6E
_ZN12rustc_driver6pretty24print_after_hir_lowering17h82d7ae3037b3778eE
_ZN12rustc_driver6pretty6PpMode13needs_ast_map17h5a653290e91e9da2E
_ZN12rustc_driver6pretty6PpMode14needs_analysis17ha6642bfe48349d19E
_ZN12rustc_driver7monitor15__STATIC_FMTSTR17hbbb274392bbde299E
_ZN12rustc_driver7monitor15__STATIC_FMTSTR17hd42321d3d0df2bd3E
_ZN12rustc_driver7version17h4926fbf2f9864177E
_ZN12rustc_driver9abort_msg15__STATIC_FMTSTR17h48304914fdfa98f2E
_ZN12rustc_driver9abort_msg17h7f994a1875668ee8E
_ZN12rustc_errors10RenderSpan4span17hbc5e3328a7628bfeE
_ZN12rustc_errors15check_old_skool17haa51056c83d05710E
_ZN12rustc_errors17DiagnosticBuilder3new17h732ac0734f13ee2bE
_ZN12rustc_errors17DiagnosticBuilder4emit17hd9353bb8a0959ae4E
_ZN12rustc_errors17DiagnosticBuilder4note17h66c552b63ce73430E
_ZN12rustc_errors7Handler14bump_err_count17haab07ac5ad148f92E
_ZN12rustc_errors7Handler24set_continue_after_error17h471f1f39e565711cE
_ZN12rustc_errors7Handler25panic_if_treat_err_as_bug17hf74622afa14a5b77E
_ZN12rustc_errors7Handler4emit17h51ea5c3bc04363fbE
_ZN12rustc_errors7emitter12BasicEmitter6stderr17h8cf7d8d9588486a4E
_ZN12rustc_errors8registry8Registry16find_description17h7fb8a932030f1e3dE
_ZN12rustc_errors8registry8Registry3new17he0a748cfad3d0ffcE
_ZN12rustc_passes14ast_validation11check_crate17h315e03fde66ab9f2E
_ZN12rustc_passes16static_recursion11check_crate17hf966c0339a2b566cE
_ZN12rustc_passes5loops11check_crate17hf876a5153c0c562cE
_ZN12rustc_passes6consts11check_crate17hce492610a0565ed9E
_ZN12rustc_passes6no_asm11check_crate17h481eac28125ad857E
_ZN12rustc_passes7rvalues11check_crate17hc50145a7c37affa9E
_ZN12rustc_plugin4load12load_plugins17h789e89e0c697852cE
_ZN12rustc_plugin5build21find_plugin_registrar17h1d22b1f6589af9deE
_ZN12rustc_plugin8registry8Registry14register_macro17h8879bb8ffe884f80E
_ZN12rustc_plugin8registry8Registry3new17h43953301c0ecf545E
_ZN12rustc_typeck11check_crate17h1d947f5c8edea4a9E
_ZN131_$LT$rustc_driver..pretty..IdentifiedAnnotation$LT$$u27$ast$GT$$u20$as$u20$rustc_driver..pretty..PrinterSupport$LT$$u27$ast$GT$$GT$4sess17hc00ec09ec940dc1eE
_ZN131_$LT$rustc_driver..pretty..IdentifiedAnnotation$LT$$u27$ast$GT$$u20$as$u20$rustc_driver..pretty..PrinterSupport$LT$$u27$ast$GT$$GT$6pp_ann17h32c5593684bec498E
_ZN131_$LT$rustc_driver..pretty..IdentifiedAnnotation$LT$$u27$ast$GT$$u20$as$u20$rustc_driver..pretty..PrinterSupport$LT$$u27$ast$GT$$GT$7ast_map17h6d59503fcf8d1466E
_ZN134_$LT$rustc_driver..pretty..IdentifiedAnnotation$LT$$u27$ast$GT$$u20$as$u20$rustc_driver..pretty..HirPrinterSupport$LT$$u27$ast$GT$$GT$4sess17h441ef2067d810a83E
_ZN134_$LT$rustc_driver..pretty..IdentifiedAnnotation$LT$$u27$ast$GT$$u20$as$u20$rustc_driver..pretty..HirPrinterSupport$LT$$u27$ast$GT$$GT$6pp_ann17he533aa7173ef519bE
_ZN134_$LT$rustc_driver..pretty..IdentifiedAnnotation$LT$$u27$ast$GT$$u20$as$u20$rustc_driver..pretty..HirPrinterSupport$LT$$u27$ast$GT$$GT$7ast_map17h8b0d8ec0459172bdE
_ZN134_$LT$rustc_mir..transform..qualify_consts..QualifyAndPromoteConstants$u20$as$u20$rustc..mir..transform..MirMapPass$LT$$u27$tcx$GT$$GT$8run_pass17hd806701dc8b3d383E
_ZN138_$LT$rustc_mir..transform..simplify_branches..SimplifyBranches$LT$$u27$l$GT$$u20$as$u20$rustc..mir..transform..MirPass$LT$$u27$tcx$GT$$GT$8run_pass17hf54564596e24e1e7E
_ZN13rustc_privacy11check_crate17hcacca45d5dedbeedE
_ZN13rustc_resolve15resolve_imports55_$LT$impl$u20$rustc_resolve..Resolver$LT$$u27$a$GT$$GT$15resolve_imports17h6f8918135b93cd5dE
_ZN13rustc_resolve19build_reduced_graph55_$LT$impl$u20$rustc_resolve..Resolver$LT$$u27$b$GT$$GT$19build_reduced_graph17h067eead9aa4eef01E
_ZN13rustc_resolve8Resolver13resolve_crate17hcc7eca7cb7a5ac54E
_ZN13rustc_resolve8Resolver3new17h2a6cff56dd929241E
_ZN13rustc_resolve8Resolver6arenas17h084ade2312876008E
_ZN143_$LT$rustc_driver..pretty..TypedAnnotation$LT$$u27$b$C$$u20$$u27$tcx$GT$$u20$as$u20$rustc_driver..pretty..HirPrinterSupport$LT$$u27$tcx$GT$$GT$4sess17hcab359fba2765809E
_ZN143_$LT$rustc_driver..pretty..TypedAnnotation$LT$$u27$b$C$$u20$$u27$tcx$GT$$u20$as$u20$rustc_driver..pretty..HirPrinterSupport$LT$$u27$tcx$GT$$GT$6pp_ann17h9a5f2afa4e451845E
_ZN143_$LT$rustc_driver..pretty..TypedAnnotation$LT$$u27$b$C$$u20$$u27$tcx$GT$$u20$as$u20$rustc_driver..pretty..HirPrinterSupport$LT$$u27$tcx$GT$$GT$7ast_map17haa446d5fa35f1430E
_ZN143_$LT$rustc_driver..pretty..TypedAnnotation$LT$$u27$b$C$$u20$$u27$tcx$GT$$u20$as$u20$rustc_driver..pretty..HirPrinterSupport$LT$$u27$tcx$GT$$GT$9node_path17hcc3ae3f9cd8eb60fE
_ZN14rustc_borrowck8borrowck11check_crate17h1ca82f94d27b2a05E
_ZN14rustc_borrowck8borrowck35build_borrowck_dataflow_data_for_fn17hcc0f3fa9396ffac6E
_ZN14rustc_metadata12macro_import11MacroLoader3new17h334b08ced8772837E
_ZN14rustc_metadata6cstore6CStore3new17hc67c4d944130bc6fE
_ZN14rustc_metadata6loader18list_file_metadata17hcb05c18746655b3cE
_ZN14rustc_metadata7creader17read_local_crates17hc27cdab2344c80fbE
_ZN14rustc_metadata7csearch110_$LT$impl$u20$rustc..middle..cstore..CrateStore$LT$$u27$tcx$GT$$u20$for$u20$rustc_metadata..cstore..CStore$GT$10closure_ty17hdf8214f3d523ec04E
_ZN14rustc_metadata7csearch110_$LT$impl$u20$rustc..middle..cstore..CrateStore$LT$$u27$tcx$GT$$u20$for$u20$rustc_metadata..cstore..CStore$GT$10crate_hash17hb42a8f127ca0c74aE
_ZN14rustc_metadata7csearch110_$LT$impl$u20$rustc..middle..cstore..CrateStore$LT$$u27$tcx$GT$$u20$for$u20$rustc_metadata..cstore..CStore$GT$10crate_name17h7c6f55d02cd5c332E
_ZN14rustc_metadata7csearch110_$LT$impl$u20$rustc..middle..cstore..CrateStore$LT$$u27$tcx$GT$$u20$for$u20$rustc_metadata..cstore..CStore$GT$10impl_items17h7b9704c27cf63e53E
_ZN14rustc_metadata7csearch110_$LT$impl$u20$rustc..middle..cstore..CrateStore$LT$$u27$tcx$GT$$u20$for$u20$rustc_metadata..cstore..CStore$GT$10is_typedef17hfdeda65ff534e9adE
_ZN14rustc_metadata7csearch110_$LT$impl$u20$rustc..middle..cstore..CrateStore$LT$$u27$tcx$GT$$u20$for$u20$rustc_metadata..cstore..CStore$GT$10item_attrs17h3faa70b6c86ed122E
_ZN14rustc_metadata7csearch110_$LT$impl$u20$rustc..middle..cstore..CrateStore$LT$$u27$tcx$GT$$u20$for$u20$rustc_metadata..cstore..CStore$GT$10lang_items17he818f04e129c1592E
_ZN14rustc_metadata7csearch110_$LT$impl$u20$rustc..middle..cstore..CrateStore$LT$$u27$tcx$GT$$u20$for$u20$rustc_metadata..cstore..CStore$GT$10repr_attrs17h422d40d29ff11d6eE
_ZN14rustc_metadata7csearch110_$LT$impl$u20$rustc..middle..cstore..CrateStore$LT$$u27$tcx$GT$$u20$for$u20$rustc_metadata..cstore..CStore$GT$10visibility17h0d02344f19361dacE
_ZN14rustc_metadata7csearch110_$LT$impl$u20$rustc..middle..cstore..CrateStore$LT$$u27$tcx$GT$$u20$for$u20$rustc_metadata..cstore..CStore$GT$11crate_attrs17hf2a94efdfcd9824dE
_ZN14rustc_metadata7csearch110_$LT$impl$u20$rustc..middle..cstore..CrateStore$LT$$u27$tcx$GT$$u20$for$u20$rustc_metadata..cstore..CStore$GT$11deprecation17h00ccc19ce66cad7cE
_ZN14rustc_metadata7csearch110_$LT$impl$u20$rustc..middle..cstore..CrateStore$LT$$u27$tcx$GT$$u20$for$u20$rustc_metadata..cstore..CStore$GT$11encode_type17h8ee0e5721cbfdc9fE
_ZN14rustc_metadata7csearch110_$LT$impl$u20$rustc..middle..cstore..CrateStore$LT$$u27$tcx$GT$$u20$for$u20$rustc_metadata..cstore..CStore$GT$11impl_parent17h682834385c845d5eE
_ZN14rustc_metadata7csearch110_$LT$impl$u20$rustc..middle..cstore..CrateStore$LT$$u27$tcx$GT$$u20$for$u20$rustc_metadata..cstore..CStore$GT$11is_const_fn17hadead3118a7123edE
_ZN14rustc_metadata7csearch110_$LT$impl$u20$rustc..middle..cstore..CrateStore$LT$$u27$tcx$GT$$u20$for$u20$rustc_metadata..cstore..CStore$GT$11used_crates17he4d65482ff293d9aE
_ZN14rustc_metadata7csearch110_$LT$impl$u20$rustc..middle..cstore..CrateStore$LT$$u27$tcx$GT$$u20$for$u20$rustc_metadata..cstore..CStore$GT$12closure_kind17hcc9759768a9b7d0bE
_ZN14rustc_metadata7csearch110_$LT$impl$u20$rustc..middle..cstore..CrateStore$LT$$u27$tcx$GT$$u20$for$u20$rustc_metadata..cstore..CStore$GT$12extern_crate17h5ab7ba78036b4068E
_ZN14rustc_metadata7csearch110_$LT$impl$u20$rustc..middle..cstore..CrateStore$LT$$u27$tcx$GT$$u20$for$u20$rustc_metadata..cstore..CStore$GT$12is_allocator17hf9c0d67f830b86a9E
_ZN14rustc_metadata7csearch110_$LT$impl$u20$rustc..middle..cstore..CrateStore$LT$$u27$tcx$GT$$u20$for$u20$rustc_metadata..cstore..CStore$GT$12variant_kind17hff61fafcb788a2ecE
_ZN14rustc_metadata7csearch110_$LT$impl$u20$rustc..middle..cstore..CrateStore$LT$$u27$tcx$GT$$u20$for$u20$rustc_metadata..cstore..CStore$GT$13impl_polarity17h2375c54e83c17912E
_ZN14rustc_metadata7csearch110_$LT$impl$u20$rustc..middle..cstore..CrateStore$LT$$u27$tcx$GT$$u20$for$u20$rustc_metadata..cstore..CStore$GT$13is_staged_api17h09b83d9fffcc97daE
_ZN14rustc_metadata7csearch110_$LT$impl$u20$rustc..middle..cstore..CrateStore$LT$$u27$tcx$GT$$u20$for$u20$rustc_metadata..cstore..CStore$GT$13item_children17hff49d28921d3fa6aE
_ZN14rustc_metadata7csearch110_$LT$impl$u20$rustc..middle..cstore..CrateStore$LT$$u27$tcx$GT$$u20$for$u20$rustc_metadata..cstore..CStore$GT$13opt_item_name17h4a208acc85fa2b6bE
_ZN14rustc_metadata7csearch110_$LT$impl$u20$rustc..middle..cstore..CrateStore$LT$$u27$tcx$GT$$u20$for$u20$rustc_metadata..cstore..CStore$GT$13reachable_ids17h84e4a768709a4753E
_ZN14rustc_metadata7csearch110_$LT$impl$u20$rustc..middle..cstore..CrateStore$LT$$u27$tcx$GT$$u20$for$u20$rustc_metadata..cstore..CStore$GT$13trait_of_item17h477a0c4ba798d862E
_ZN14rustc_metadata7csearch110_$LT$impl$u20$rustc..middle..cstore..CrateStore$LT$$u27$tcx$GT$$u20$for$u20$rustc_metadata..cstore..CStore$GT$14impl_trait_ref17hcf0b72223780523cE
_ZN14rustc_metadata7csearch110_$LT$impl$u20$rustc..middle..cstore..CrateStore$LT$$u27$tcx$GT$$u20$for$u20$rustc_metadata..cstore..CStore$GT$14is_extern_item17h3360043f7a1de87eE
_ZN14rustc_metadata7csearch110_$LT$impl$u20$rustc..middle..cstore..CrateStore$LT$$u27$tcx$GT$$u20$for$u20$rustc_metadata..cstore..CStore$GT$14item_variances17h0b1961ec05eeb91fE
_ZN14rustc_metadata7csearch110_$LT$impl$u20$rustc..middle..cstore..CrateStore$LT$$u27$tcx$GT$$u20$for$u20$rustc_metadata..cstore..CStore$GT$14panic_strategy17hd029c9c069f7f36bE
_ZN14rustc_metadata7csearch110_$LT$impl$u20$rustc..middle..cstore..CrateStore$LT$$u27$tcx$GT$$u20$for$u20$rustc_metadata..cstore..CStore$GT$14used_libraries17h81a7a387b39a5590E
_ZN14rustc_metadata7csearch110_$LT$impl$u20$rustc..middle..cstore..CrateStore$LT$$u27$tcx$GT$$u20$for$u20$rustc_metadata..cstore..CStore$GT$14used_link_args17h161ad82d435c26c0E
_ZN14rustc_metadata7csearch110_$LT$impl$u20$rustc..middle..cstore..CrateStore$LT$$u27$tcx$GT$$u20$for$u20$rustc_metadata..cstore..CStore$GT$15encode_metadata17h7026a52fbe21139fE
_ZN14rustc_metadata7csearch110_$LT$impl$u20$rustc..middle..cstore..CrateStore$LT$$u27$tcx$GT$$u20$for$u20$rustc_metadata..cstore..CStore$GT$15is_default_impl17h3f79c9c51972e2a7E
_ZN14rustc_metadata7csearch110_$LT$impl$u20$rustc..middle..cstore..CrateStore$LT$$u27$tcx$GT$$u20$for$u20$rustc_metadata..cstore..CStore$GT$15is_foreign_item17h99c1bf12b3d7295eE
_ZN14rustc_metadata7csearch110_$LT$impl$u20$rustc..middle..cstore..CrateStore$LT$$u27$tcx$GT$$u20$for$u20$rustc_metadata..cstore..CStore$GT$15item_predicates17h625c691fc502b5c7E
_ZN14rustc_metadata7csearch110_$LT$impl$u20$rustc..middle..cstore..CrateStore$LT$$u27$tcx$GT$$u20$for$u20$rustc_metadata..cstore..CStore$GT$16is_panic_runtime17h68e2aac5959c38bcE
_ZN14rustc_metadata7csearch110_$LT$impl$u20$rustc..middle..cstore..CrateStore$LT$$u27$tcx$GT$$u20$for$u20$rustc_metadata..cstore..CStore$GT$16is_static_method17h0b28ba207d07ca70E
_ZN14rustc_metadata7csearch110_$LT$impl$u20$rustc..middle..cstore..CrateStore$LT$$u27$tcx$GT$$u20$for$u20$rustc_metadata..cstore..CStore$GT$16method_arg_names17hf159bd28b7001eedE
_ZN14rustc_metadata7csearch110_$LT$impl$u20$rustc..middle..cstore..CrateStore$LT$$u27$tcx$GT$$u20$for$u20$rustc_metadata..cstore..CStore$GT$16native_libraries17h1aa54995b3b72a59E
_ZN14rustc_metadata7csearch110_$LT$impl$u20$rustc..middle..cstore..CrateStore$LT$$u27$tcx$GT$$u20$for$u20$rustc_metadata..cstore..CStore$GT$17associated_consts17hef12162423c99a36E
_ZN14rustc_metadata7csearch110_$LT$impl$u20$rustc..middle..cstore..CrateStore$LT$$u27$tcx$GT$$u20$for$u20$rustc_metadata..cstore..CStore$GT$17metadata_filename17hba9a72ba7bdaa725E
_ZN14rustc_metadata7csearch110_$LT$impl$u20$rustc..middle..cstore..CrateStore$LT$$u27$tcx$GT$$u20$for$u20$rustc_metadata..cstore..CStore$GT$17relative_def_path17hb40afed9613dd9d6E
_ZN14rustc_metadata7csearch110_$LT$impl$u20$rustc..middle..cstore..CrateStore$LT$$u27$tcx$GT$$u20$for$u20$rustc_metadata..cstore..CStore$GT$17used_crate_source17he79dba27fd502f05E
_ZN14rustc_metadata7csearch110_$LT$impl$u20$rustc..middle..cstore..CrateStore$LT$$u27$tcx$GT$$u20$for$u20$rustc_metadata..cstore..CStore$GT$18impl_or_trait_item17h24c2d6ce870d48c1E
_ZN14rustc_metadata7csearch110_$LT$impl$u20$rustc..middle..cstore..CrateStore$LT$$u27$tcx$GT$$u20$for$u20$rustc_metadata..cstore..CStore$GT$18is_defaulted_trait17h568697e4a6318556E
_ZN14rustc_metadata7csearch110_$LT$impl$u20$rustc..middle..cstore..CrateStore$LT$$u27$tcx$GT$$u20$for$u20$rustc_metadata..cstore..CStore$GT$18maybe_get_item_ast17h454ce98f634754d5E
_ZN14rustc_metadata7csearch110_$LT$impl$u20$rustc..middle..cstore..CrateStore$LT$$u27$tcx$GT$$u20$for$u20$rustc_metadata..cstore..CStore$GT$18maybe_get_item_mir17h2c55108b1f252c0aE
_ZN14rustc_metadata7csearch110_$LT$impl$u20$rustc..middle..cstore..CrateStore$LT$$u27$tcx$GT$$u20$for$u20$rustc_metadata..cstore..CStore$GT$18missing_lang_items17h4ccc4b77ceed4b97E
_ZN14rustc_metadata7csearch110_$LT$impl$u20$rustc..middle..cstore..CrateStore$LT$$u27$tcx$GT$$u20$for$u20$rustc_metadata..cstore..CStore$GT$18struct_ctor_def_id17h0096fb9c8bc02305E
_ZN14rustc_metadata7csearch110_$LT$impl$u20$rustc..middle..cstore..CrateStore$LT$$u27$tcx$GT$$u20$for$u20$rustc_metadata..cstore..CStore$GT$18struct_field_names17h40a7c8494f4d5a4cE
_ZN14rustc_metadata7csearch110_$LT$impl$u20$rustc..middle..cstore..CrateStore$LT$$u27$tcx$GT$$u20$for$u20$rustc_metadata..cstore..CStore$GT$18trait_item_def_ids17h5b604c7b62b0cd4cE
_ZN14rustc_metadata7csearch110_$LT$impl$u20$rustc..middle..cstore..CrateStore$LT$$u27$tcx$GT$$u20$for$u20$rustc_metadata..cstore..CStore$GT$18visible_parent_map17h4ce62bcc920a1863E
_ZN14rustc_metadata7csearch110_$LT$impl$u20$rustc..middle..cstore..CrateStore$LT$$u27$tcx$GT$$u20$for$u20$rustc_metadata..cstore..CStore$GT$19crate_disambiguator17hc340f06444b590b8E
_ZN14rustc_metadata7csearch110_$LT$impl$u20$rustc..middle..cstore..CrateStore$LT$$u27$tcx$GT$$u20$for$u20$rustc_metadata..cstore..CStore$GT$19original_crate_name17hcb737f111aa8c28aE
_ZN14rustc_metadata7csearch110_$LT$impl$u20$rustc..middle..cstore..CrateStore$LT$$u27$tcx$GT$$u20$for$u20$rustc_metadata..cstore..CStore$GT$19plugin_registrar_fn17hdf2f271d3eb3528eE
_ZN14rustc_metadata7csearch110_$LT$impl$u20$rustc..middle..cstore..CrateStore$LT$$u27$tcx$GT$$u20$for$u20$rustc_metadata..cstore..CStore$GT$20extern_mod_stmt_cnum17h76e02c040774c411E
_ZN14rustc_metadata7csearch110_$LT$impl$u20$rustc..middle..cstore..CrateStore$LT$$u27$tcx$GT$$u20$for$u20$rustc_metadata..cstore..CStore$GT$20is_explicitly_linked17h339995f13ba5ec7aE
_ZN14rustc_metadata7csearch110_$LT$impl$u20$rustc..middle..cstore..CrateStore$LT$$u27$tcx$GT$$u20$for$u20$rustc_metadata..cstore..CStore$GT$21crate_top_level_items17h9b03c21406e9242eE
_ZN14rustc_metadata7csearch110_$LT$impl$u20$rustc..middle..cstore..CrateStore$LT$$u27$tcx$GT$$u20$for$u20$rustc_metadata..cstore..CStore$GT$21def_index_for_def_key17hc6f5f75e9c2efb08E
_ZN14rustc_metadata7csearch110_$LT$impl$u20$rustc..middle..cstore..CrateStore$LT$$u27$tcx$GT$$u20$for$u20$rustc_metadata..cstore..CStore$GT$21is_item_mir_available17h450701386ce81d23E
_ZN14rustc_metadata7csearch110_$LT$impl$u20$rustc..middle..cstore..CrateStore$LT$$u27$tcx$GT$$u20$for$u20$rustc_metadata..cstore..CStore$GT$21item_super_predicates17h4e20350a38202f69E
_ZN14rustc_metadata7csearch110_$LT$impl$u20$rustc..middle..cstore..CrateStore$LT$$u27$tcx$GT$$u20$for$u20$rustc_metadata..cstore..CStore$GT$21metadata_section_name17he7e74797045723d6E
_ZN14rustc_metadata7csearch110_$LT$impl$u20$rustc..middle..cstore..CrateStore$LT$$u27$tcx$GT$$u20$for$u20$rustc_metadata..cstore..CStore$GT$22provided_trait_methods17hbda70bb25294370dE
_ZN14rustc_metadata7csearch110_$LT$impl$u20$rustc..middle..cstore..CrateStore$LT$$u27$tcx$GT$$u20$for$u20$rustc_metadata..cstore..CStore$GT$24crate_struct_field_attrs17h87e734b4287f392bE
_ZN14rustc_metadata7csearch110_$LT$impl$u20$rustc..middle..cstore..CrateStore$LT$$u27$tcx$GT$$u20$for$u20$rustc_metadata..cstore..CStore$GT$24dylib_dependency_formats17he1d3aa6ee1150113E
_ZN14rustc_metadata7csearch110_$LT$impl$u20$rustc..middle..cstore..CrateStore$LT$$u27$tcx$GT$$u20$for$u20$rustc_metadata..cstore..CStore$GT$24implementations_of_trait17h33658006c4c9477eE
_ZN14rustc_metadata7csearch110_$LT$impl$u20$rustc..middle..cstore..CrateStore$LT$$u27$tcx$GT$$u20$for$u20$rustc_metadata..cstore..CStore$GT$25metadata_encoding_version17h6a417f086cfa8ae6E
_ZN14rustc_metadata7csearch110_$LT$impl$u20$rustc..middle..cstore..CrateStore$LT$$u27$tcx$GT$$u20$for$u20$rustc_metadata..cstore..CStore$GT$26custom_coerce_unsized_kind17hb3d5de6585a98188E
_ZN14rustc_metadata7csearch110_$LT$impl$u20$rustc..middle..cstore..CrateStore$LT$$u27$tcx$GT$$u20$for$u20$rustc_metadata..cstore..CStore$GT$31tuple_struct_definition_if_ctor17h3cd799fa3f51fb73E
_ZN14rustc_metadata7csearch110_$LT$impl$u20$rustc..middle..cstore..CrateStore$LT$$u27$tcx$GT$$u20$for$u20$rustc_metadata..cstore..CStore$GT$33inherent_implementations_for_type17hc0ca0752b1ed2cb9E
_ZN14rustc_metadata7csearch110_$LT$impl$u20$rustc..middle..cstore..CrateStore$LT$$u27$tcx$GT$$u20$for$u20$rustc_metadata..cstore..CStore$GT$35is_statically_included_foreign_item17h081954cb3659bb52E
_ZN14rustc_metadata7csearch110_$LT$impl$u20$rustc..middle..cstore..CrateStore$LT$$u27$tcx$GT$$u20$for$u20$rustc_metadata..cstore..CStore$GT$6crates17hfab308a035f9f52cE
_ZN14rustc_metadata7csearch110_$LT$impl$u20$rustc..middle..cstore..CrateStore$LT$$u27$tcx$GT$$u20$for$u20$rustc_metadata..cstore..CStore$GT$7adt_def17h8f68663b78fd11ecE
_ZN14rustc_metadata7csearch110_$LT$impl$u20$rustc..middle..cstore..CrateStore$LT$$u27$tcx$GT$$u20$for$u20$rustc_metadata..cstore..CStore$GT$7def_key17h4ae0ea6a1ec2caa9E
_ZN14rustc_metadata7csearch110_$LT$impl$u20$rustc..middle..cstore..CrateStore$LT$$u27$tcx$GT$$u20$for$u20$rustc_metadata..cstore..CStore$GT$7is_impl17ha0656b489f22ab13E
_ZN14rustc_metadata7csearch110_$LT$impl$u20$rustc..middle..cstore..CrateStore$LT$$u27$tcx$GT$$u20$for$u20$rustc_metadata..cstore..CStore$GT$9item_name17h0f98591c318ee43cE
_ZN14rustc_metadata7csearch110_$LT$impl$u20$rustc..middle..cstore..CrateStore$LT$$u27$tcx$GT$$u20$for$u20$rustc_metadata..cstore..CStore$GT$9item_type17h4e979e5bd3523990E
_ZN14rustc_metadata7csearch110_$LT$impl$u20$rustc..middle..cstore..CrateStore$LT$$u27$tcx$GT$$u20$for$u20$rustc_metadata..cstore..CStore$GT$9stability17h263e8a5cfd9a358eE
_ZN14rustc_metadata7csearch110_$LT$impl$u20$rustc..middle..cstore..CrateStore$LT$$u27$tcx$GT$$u20$for$u20$rustc_metadata..cstore..CStore$GT$9trait_def17he2d7cd6888903cd4E
_ZN153_$LT$Box$LT$std..error..Error$u20$$u2b$$u20$Send$u20$$u2b$$u20$Sync$u20$$u2b$$u20$$u27$a$GT$$u20$as$u20$core..convert..From$LT$$RF$$u27$b$u20$str$GT$$GT$4from17hc47b83173c791a1fE
_ZN16rustc_const_eval11check_match11check_crate17he267430bf5b2f67eE
_ZN16rustc_const_math3err12ConstMathErr11description17ha0ce407cd7669b23E
_ZN17rustc_incremental16assert_dep_graph16assert_dep_graph17hff0ab664ac25c8c1E
_ZN17rustc_incremental7persist4load14load_dep_graph17h476fd559fe2acf7bE
_ZN17rustc_incremental7persist4save14save_dep_graph17hbe24c44cc1a3e802E
_ZN19rustc_save_analysis13process_crate17h6932fb7e39cb6873E
_ZN37_$LT$core..cell..RefCell$LT$T$GT$$GT$10borrow_mut14_MSG_FILE_LINE17h87278f509fdec581E
_ZN37_$LT$core..cell..RefCell$LT$T$GT$$GT$6borrow14_MSG_FILE_LINE17hab2004ab00a9e645E
_ZN38_$LT$core..option..Option$LT$T$GT$$GT$6unwrap14_MSG_FILE_LINE17hc89d807017dd066bE
_ZN39_$LT$collections..vec..Vec$LT$T$GT$$GT$6insert14_MSG_FILE_LINE17ha52724705c5803beE
_ZN3log11mod_enabled17hc2921c11813d1db2E
_ZN3log9LOG_LEVEL17hdd2e55db11721c7bE
_ZN3std10sys_common11thread_info3set17hb481f6ad28178f4bE
_ZN3std10sys_common4util9min_stack17h21ed027aba95c79dE
_ZN3std11collections4hash3map11RandomState3new4KEYS17hb806d9bac9a41080E
_ZN3std11collections4hash3map19DefaultResizePolicy3new17hacb68a7d8ec45ed7E
_ZN3std11collections4hash5table20calculate_allocation17ha39b7c433e0246c0E
_ZN3std2fs11OpenOptions3new17hb9dd4f2b5085dfe3E
_ZN3std2fs11OpenOptions5_open17h48f22bcb850e1316E
_ZN3std2fs11OpenOptions5write17h8f305ae09b4b94b4E
_ZN3std2fs11OpenOptions6create17hdc046112eb3e8a89E
_ZN3std2fs11OpenOptions8truncate17h0981945c9da1bb29E
_ZN3std2io4util4sink17h6515f701a3d777b4E
_ZN3std2io5error5Error4_new17he2afc346a197e059E
_ZN3std2io5error5Error4kind17h547a8ffc0650e965E
_ZN3std2io5stdio5stdin17he605599371c42becE
_ZN3std2io5stdio6_print17h91aef6f665f00d62E
_ZN3std2io5stdio9set_panic17hce59db92e1093dbbE
_ZN3std3env4args17h1d5e2225a03539eaE
_ZN3std3env7_var_os17h1d65b7b1d882c170E
_ZN3std3ffi6os_str109_$LT$impl$u20$core..convert..AsRef$LT$std..ffi..os_str..OsStr$GT$$u20$for$u20$collections..string..String$GT$6as_ref17h8f564ee6947ee1baE
_ZN3std3ffi6os_str5OsStr12to_os_string17hf45562950df74d23E
_ZN3std3ffi6os_str5OsStr15to_string_lossy17h274486f6ad32dbcfE
_ZN3std3ffi6os_str5OsStr6to_str17h74320fa5f373cfe9E
_ZN3std3ffi6os_str85_$LT$impl$u20$core..convert..AsRef$LT$std..ffi..os_str..OsStr$GT$$u20$for$u20$str$GT$6as_ref17h55425cfe45cf9c6dE
_ZN3std3ffi6os_str8OsString3new17h92025d8196ab9237E
_ZN3std3sys2fs6unlink17h732522319989ce9fE
_ZN3std3sys6thread5guard7current17hcd5d60b5e2b58b9aE
_ZN3std3sys6thread6Thread3new17hf537d1b6a6336a9cE
_ZN3std3sys6thread6Thread4join17h44bd80eb68d3fdf8E
_ZN3std3sys6thread6Thread8set_name17hadc5b35cc48a8e81E
_ZN3std4path4Path11to_path_buf17h985066547625c67fE
_ZN3std4path4Path6parent17h374776c44372571cE
_ZN3std4path4Path6to_str17hfac2b934b221cb36E
_ZN3std4path4Path7display17hf7a27e966103727cE
_ZN3std4path4Path9file_name17h81f8398c47b19b61E
_ZN3std4path4Path9file_stem17h2a0b1111c7741e5fE
_ZN3std4path7PathBuf3new17heffc640d3fab61d9E
_ZN3std4sync4mpsc4sync5Queue7dequeue17h3481e530da869497E
_ZN3std4sync4mpsc8blocking11SignalToken6signal17hd418cce5bcce5bd4E
_ZN3std4time7Instant3now17h064a75a88048ba9cE
_ZN3std4time7Instant7elapsed17hef5bf5435111db4bE
_ZN3std6thread6Thread3new17h614f63e5c410cbd7E
_ZN3std6thread6Thread5cname17heb042ca436f69c04E
_ZN3std6thread7Builder10stack_size17h43bfdb14ff9f9859E
_ZN3std6thread7Builder3new17hfbbfd14f2bfb1066E
_ZN3std6thread7Builder4name17ha265d902a0b42422E
_ZN3std7process4exit17ha166726d64178fa8E
_ZN3std9panicking11PANIC_COUNT17h747ab620a51161d7E
_ZN3std9panicking15begin_panic_fmt17h30280d4dd3f149f5E
_ZN3std9panicking20rust_panic_with_hook17hd7b83626099d3416E
_ZN3std9panicking9panicking17h40050f9d942e3951E
_ZN40_$LT$alloc..raw_vec..RawVec$LT$T$GT$$GT$13shrink_to_fit14_MSG_FILE_LINE17h5a739bd229068998E
_ZN40_$LT$str$u20$as$u20$core..fmt..Debug$GT$3fmt17ha62a65defecc702aE
_ZN41_$LT$char$u20$as$u20$core..fmt..Debug$GT$3fmt17h138c18d02806d664E
_ZN42_$LT$f64$u20$as$u20$core..fmt..Display$GT$3fmt17hdb6898ed7bed02e2E
_ZN42_$LT$str$u20$as$u20$core..fmt..Display$GT$3fmt17h6429d240a434bda6E
_ZN47_$LT$std..sync..mpsc..sync..Packet$LT$T$GT$$GT$9drop_port10_FILE_LINE17h85e49696712dff59E
_ZN48_$LT$flate..Bytes$u20$as$u20$core..ops..Drop$GT$4drop17h1610160d07a25594E
_ZN48_$LT$std..fs..File$u20$as$u20$std..io..Write$GT$5write17h7f1a628bec36322bE
_ZN49_$LT$std..sync..mpsc..shared..Packet$LT$T$GT$$GT$12take_to_wake10_FILE_LINE17h00dec45e9641349fE
_ZN49_$LT$std..sync..mpsc..shared..Packet$LT$T$GT$$GT$9drop_chan10_FILE_LINE17h24dbf1392f2db351E
_ZN49_$LT$std..sync..mpsc..shared..Packet$LT$T$GT$$GT$9drop_chan10_FILE_LINE17hf00dfdcddc7f40efE
_ZN49_$LT$std..sync..mpsc..shared..Packet$LT$T$GT$$GT$9drop_chan15__STATIC_FMTSTR17h97ba8bbe309a8af6E
_ZN49_$LT$std..sync..mpsc..stream..Packet$LT$T$GT$$GT$12take_to_wake10_FILE_LINE17h421b4347643a2c0bE
_ZN49_$LT$std..sync..mpsc..stream..Packet$LT$T$GT$$GT$9drop_chan10_FILE_LINE17hf8e7b69e861afdcbE
_ZN4core3fmt10ArgumentV110from_usize17h0bc8a0d98a44e089E
_ZN4core3fmt3num50_$LT$impl$u20$core..fmt..Debug$u20$for$u20$u32$GT$3fmt17h240109c90cc42c13E
_ZN4core3fmt3num52_$LT$impl$u20$core..fmt..Debug$u20$for$u20$isize$GT$3fmt17h3098eccc987eb0bfE
_ZN4core3fmt3num52_$LT$impl$u20$core..fmt..Debug$u20$for$u20$usize$GT$3fmt17h684120258f68aadbE
_ZN4core3fmt3num52_$LT$impl$u20$core..fmt..Display$u20$for$u20$u32$GT$3fmt17h7a15be617911602eE
_ZN4core3fmt3num54_$LT$impl$u20$core..fmt..Display$u20$for$u20$isize$GT$3fmt17h2487ec65cea7fcfdE
_ZN4core3fmt3num54_$LT$impl$u20$core..fmt..Display$u20$for$u20$usize$GT$3fmt17hc8660a4d9676048eE
_ZN4core3fmt5write17hd4f1762ae678891eE
_ZN4core3fmt8builders10DebugTuple5field17h424806706c98545eE
_ZN4core3fmt8builders10DebugTuple6finish17hd2a922a74ff4be3fE
_ZN4core3fmt8builders14debug_list_new17h8c0ecf4888bdb622E
_ZN4core3fmt8builders15debug_tuple_new17h31b4b18cbbc3f2e8E
_ZN4core3fmt8builders9DebugList5entry17hb29a849b5a27872bE
_ZN4core3fmt8builders9DebugList6finish17hbb0a8d8bc593ae52E
_ZN4core3num52_$LT$impl$u20$core..str..FromStr$u20$for$u20$u32$GT$8from_str17h4591d218b0e44191E
_ZN4core3str16slice_error_fail17h52e7d9a886dfadadE
_ZN4core3str7pattern11StrSearcher3new17h664cf5f7535e55d0E
_ZN4core3str9from_utf817h2d534255874bbfc0E
_ZN4core4char10EncodeUtf88as_slice17h8a1a33d3a2f29176E
_ZN4core5slice20slice_index_len_fail17ha4faf37254d75f20E
_ZN4core5slice22slice_index_order_fail17h76eccc937f52ed9bE
_ZN4core5slice71_$LT$impl$u20$core..ops..Index$LT$usize$GT$$u20$for$u20$$u5b$T$u5d$$GT$5index14_MSG_FILE_LINE17he2abd1027910a30dE
_ZN4core6option13expect_failed17ha6269a58a5455f37E
_ZN4core6result13unwrap_failed10_FILE_LINE17h730ed9164be33e67E
_ZN4core6result13unwrap_failed15__STATIC_FMTSTR17hc6881a6734b604a6E
_ZN4core9panicking18panic_bounds_check17hcc71f10000bd8e6fE
_ZN4core9panicking5panic17heeca72c448510af4E
_ZN4core9panicking9panic_fmt17h2d3cc8234dde51b4E
_ZN50_$LT$std..sync..mpsc..oneshot..Packet$LT$T$GT$$GT$9drop_port10_FILE_LINE17h6edfddcae49721f2E
_ZN51_$LT$T$u20$as$u20$collections..string..ToString$GT$9to_string15__STATIC_FMTSTR17h648b05decd83c685E
_ZN52_$LT$getopts..Fail$u20$as$u20$core..fmt..Display$GT$3fmt17h39b9d492f4170c60E
_ZN52_$LT$std..sync..mpsc..mpsc_queue..Queue$LT$T$GT$$GT$3pop10_FILE_LINE17h3d22312955b479d9E
_ZN52_$LT$std..sync..mpsc..mpsc_queue..Queue$LT$T$GT$$GT$3pop10_FILE_LINE17h41a70704327eb46fE
_ZN52_$LT$std..sync..mpsc..spsc_queue..Queue$LT$T$GT$$GT$3pop10_FILE_LINE17h65937a4f38d9bb6aE
_ZN53_$LT$$u5b$T$u5d$$u20$as$u20$core..slice..SliceExt$GT$12split_at_mut14_MSG_FILE_LINE17h4e486ae8d041c7ffE
_ZN53_$LT$core..fmt..Error$u20$as$u20$core..fmt..Debug$GT$3fmt17h4020625e4c0268feE
_ZN54_$LT$$u5b$u8$u5d$$u20$as$u20$serialize..hex..ToHex$GT$6to_hex17ha88c08a0b8931b55E
_ZN54_$LT$std..io..util..Sink$u20$as$u20$std..io..Write$GT$5flush17h8a28c4d006012152E
_ZN54_$LT$std..io..util..Sink$u20$as$u20$std..io..Write$GT$5write17h81638d351ed3b5e0E
_ZN55_$LT$std..io..stdio..Stdin$u20$as$u20$std..io..Read$GT$14read_to_string17h6f4386d26edafd24E
_ZN55_$LT$std..path..PathBuf$u20$as$u20$core..ops..Deref$GT$5deref17h43a9d35e7c203347E
_ZN56_$LT$syntax..ast..Name$u20$as$u20$core..fmt..Display$GT$3fmt17h655116f022b11726E
_ZN57_$LT$core..str..Utf8Error$u20$as$u20$core..fmt..Debug$GT$3fmt17h4579d0c10def8db0E
_ZN57_$LT$syntax..util..small_vector..SmallVector$LT$T$GT$$GT$10expect_one10_FILE_LINE17h2859d3b893ba6a7aE
_ZN57_$LT$syntax..util..small_vector..SmallVector$LT$T$GT$$GT$10expect_one10_FILE_LINE17h38996ae1b98907ccE
_ZN57_$LT$syntax..util..small_vector..SmallVector$LT$T$GT$$GT$4push10_FILE_LINE17h716e7fccb45ec802E
_ZN58_$LT$std..io..error..Error$u20$as$u20$core..fmt..Debug$GT$3fmt17h9deb4a3697429d50E
_ZN58_$LT$std..sys..fd..FileDesc$u20$as$u20$core..ops..Drop$GT$4drop17he1b61f7bcd0a2158E
_ZN59_$LT$rustc_driver..Compilation$u20$as$u20$core..cmp..Eq$GT$27assert_receiver_is_total_eq17h468d5ce54f7c4a11E
_ZN5alloc3oom3oom17h8fced2f5f33bcdebE
_ZN5rustc2ty6layout16TargetDataLayout5parse17h10c957a3128eca4bE
_ZN5rustc2ty7context10CtxtArenas3new17hbabc42227a5db7d5E
_ZN5rustc2ty7context11CommonTypes3new17hdd6160f3edc5e47cE
_ZN5rustc2ty7context13CtxtInterners3new17he8f68191bb4b2176E
_ZN5rustc2ty7context3tls10span_debug17he30629f2fabe79ddE
_ZN5rustc2ty7context3tls7TLS_TCX17ha1f0bd9851af7f78E
_ZN5rustc2ty7context6Tables5empty17hc5dd181f5e853275E
_ZN5rustc2ty7context6TyCtxt17print_debug_stats17hfb842cb3b9b1711eE
_ZN5rustc2ty90_$LT$impl$u20$rustc..ty..context..TyCtxt$LT$$u27$a$C$$u20$$u27$gcx$C$$u20$$u27$tcx$GT$$GT$7expr_ty17h715d432b3c2bbe65E
_ZN5rustc2ty9item_path90_$LT$impl$u20$rustc..ty..context..TyCtxt$LT$$u27$a$C$$u20$$u27$gcx$C$$u20$$u27$tcx$GT$$GT$13node_path_str17he6979378a2d6797aE
_ZN5rustc3cfg3CFG3new17hf525fc1645d76386E
_ZN5rustc3hir10check_attr11check_crate17hdcafd3d541fbde4dE
_ZN5rustc3hir3map11definitions11DefPathData9to_string17hf94f43ec134b1156E
_ZN5rustc3hir3map11definitions11Definitions7collect17h19fb55c6f018f000E
_ZN5rustc3hir3map3Map12local_def_id17h941ffc179e4335b4E
_ZN5rustc3hir3map3Map16def_path_from_id17h8515b14697b6a0c5E
_ZN5rustc3hir3map3Map21nodes_matching_suffix17h33e43b1a01e4b204E
_ZN5rustc3hir3map3Map3get17h0abb606cdb7e0f33E
_ZN5rustc3hir3map3Map4find17h96e9d97c686f4a14E
_ZN5rustc3hir3map3Map5krate17hf5b7a2b73164c869E
_ZN5rustc3hir3map3Map8opt_span17h0c14fdb36b0e4cdfE
_ZN5rustc3hir3map6Forest3new17he903a1f5664e44b2E
_ZN5rustc3hir3map6Forest5krate17h89dbc9a8a88d846eE
_ZN5rustc3hir3map6blocks10FnLikeNode11to_fn_parts17hec6a4ebcf66d8a33E
_ZN5rustc3hir3map6blocks10FnLikeNode4body17hd376dc8204d03a7fE
_ZN5rustc3hir3map6blocks4Code2id17h81485b4c9cf93e1cE
_ZN5rustc3hir3map6blocks4Code9from_node17h1f248282731a51ccE
_ZN5rustc3hir3map9map_crate17hb120ddafe508b878E
_ZN5rustc3hir5print11print_crate17h91bda0654f7f367fE
_ZN5rustc3hir5print5State13synth_comment17h4863d33d7c0fb5d7E
_ZN5rustc3hir5print5State14new_from_input17h429bb0820f6447a7E
_ZN5rustc3hir8lowering11lower_crate17h24d2dd7eb56b0700E
_ZN5rustc3mir4repr10Terminator10successors17h54eb6a418d303f9dE
_ZN5rustc3mir4repr14BasicBlockData10terminator17h789ee96bedc5bcd2E
_ZN5rustc3mir4repr14TerminatorKind20fmt_successor_labels17hf28e04d4ae408480E
_ZN5rustc3mir4repr14TerminatorKind8fmt_head15__STATIC_FMTSTR17h009a3cf1421a45e7E
_ZN5rustc3mir4repr14TerminatorKind8fmt_head15__STATIC_FMTSTR17h0848a4577e692e4fE
_ZN5rustc3mir4repr14TerminatorKind8fmt_head15__STATIC_FMTSTR17h09a12203f0e244f3E
_ZN5rustc3mir4repr14TerminatorKind8fmt_head15__STATIC_FMTSTR17h43fc9f5278371477E
_ZN5rustc3mir4repr14TerminatorKind8fmt_head15__STATIC_FMTSTR17h46bd5dee40e10f33E
_ZN5rustc3mir4repr14TerminatorKind8fmt_head15__STATIC_FMTSTR17h4a1c6beb3e4b5845E
_ZN5rustc3mir4repr14TerminatorKind8fmt_head15__STATIC_FMTSTR17h4d72bbaa0a8a60b5E
_ZN5rustc3mir4repr14TerminatorKind8fmt_head15__STATIC_FMTSTR17h584478500ce35efdE
_ZN5rustc3mir4repr14TerminatorKind8fmt_head15__STATIC_FMTSTR17h64b687aecf2d5194E
_ZN5rustc3mir4repr14TerminatorKind8fmt_head15__STATIC_FMTSTR17h7106abf3cc80de7dE
_ZN5rustc3mir4repr14TerminatorKind8fmt_head15__STATIC_FMTSTR17h7f8a607215df59a4E
_ZN5rustc3mir4repr14TerminatorKind8fmt_head15__STATIC_FMTSTR17h88913e25459323bcE
_ZN5rustc3mir4repr14TerminatorKind8fmt_head15__STATIC_FMTSTR17ha2e373b5fb3fe60fE
_ZN5rustc3mir4repr14TerminatorKind8fmt_head15__STATIC_FMTSTR17habb694e3d39443a9E
_ZN5rustc3mir4repr14TerminatorKind8fmt_head15__STATIC_FMTSTR17hb1dfdbb5f9d9681aE
_ZN5rustc3mir4repr14TerminatorKind8fmt_head15__STATIC_FMTSTR17hd0f9eac9809d28dbE
_ZN5rustc3mir4repr14TerminatorKind8fmt_head15__STATIC_FMTSTR17he51f8d4d04250672E
_ZN5rustc3mir4repr14TerminatorKind8fmt_head15__STATIC_FMTSTR17hf33e0c707d444e62E
_ZN5rustc3mir4repr14TerminatorKind8fmt_head15__STATIC_FMTSTR17hf4bc80cac3d07dafE
_ZN5rustc3mir4repr14TerminatorKind8fmt_head15__STATIC_FMTSTR17hfc68e9b0dc17354fE
_ZN5rustc3mir9transform6Passes10run_passes17h78a0bc9140548fbaE
_ZN5rustc3mir9transform6Passes3new17h4fbc47262b9d631cE
_ZN5rustc3mir9transform6Passes9push_hook17h68a789d794eeb7c7E
_ZN5rustc3mir9transform6Passes9push_pass17h97e50485ad3074d7E
_ZN5rustc3mir9transform9MirSource9from_node17h8849583a1527be26E
_ZN5rustc4lint4Lint10name_lower17h8b8965f999f9d817E
_ZN5rustc4lint5Level6as_str17h1df921d00b456097E
_ZN5rustc4lint6LintId6as_str17h03eaef1eb8ff659aE
_ZN5rustc4lint7builtin19UNKNOWN_CRATE_TYPES17hd927a857a65aec41E
_ZN5rustc4lint7context11check_crate17he03096f72a330599E
_ZN5rustc4lint7context15check_ast_crate17h9105c0546a707089E
_ZN5rustc4lint7context9LintStore14register_group17hc29a3b326d9b4702E
_ZN5rustc4lint7context9LintStore15get_lint_groups17h69e71063510c16caE
_ZN5rustc4lint7context9LintStore18register_late_pass17h4b3e3fead864c3e1E
_ZN5rustc4lint7context9LintStore19register_early_pass17h631524b7348cbf6bE
_ZN5rustc4lint7context9LintStore20process_command_line17h293a28b3b0b6d0cfE
_ZN5rustc4lint7context9LintStore3new17hbe98ac5ccdea0070E
_ZN5rustc4lint7context9LintStore9get_lints17h831faf7839812353E
_ZN5rustc4util5ppaux77_$LT$impl$u20$core..fmt..Debug$u20$for$u20$rustc..ty..TyS$LT$$u27$tcx$GT$$GT$3fmt17h9ca12f152448e1c9E
_ZN5rustc4util5ppaux79_$LT$impl$u20$core..fmt..Display$u20$for$u20$rustc..ty..TyS$LT$$u27$tcx$GT$$GT$3fmt17h133db5e829fbf219E
_ZN5rustc4util6common12get_resident17h47c5ea77577cc844E
_ZN5rustc4util6common4time15__STATIC_FMTSTR17h7801b0c6119aad33E
_ZN5rustc4util6common4time15__STATIC_FMTSTR17hff38d53dd2b428c8E
_ZN5rustc4util6common4time16__STATIC_FMTARGS17h545ec1da1d5af3edE
_ZN5rustc4util6common4time5DEPTH17h6eb268ad83e9cdadE
_ZN5rustc4util7nodemap7NodeSet17h57314f213c2d8d06E
_ZN5rustc4util7nodemap8DefIdSet17h8dd205efd3e3bd07E
_ZN5rustc6middle10lang_items22collect_language_items17hb69ac8ba5d5bbc61E
_ZN5rustc6middle11intrinsicck11check_crate17h7a8a3fdfa9fc37f3E
_ZN5rustc6middle15recursion_limit22update_recursion_limit17hd956722eb469283cE
_ZN5rustc6middle16resolve_lifetime5krate17hff5a490666a62986E
_ZN5rustc6middle17dependency_format9calculate17h6640fd7b4e9778aeE
_ZN5rustc6middle4dead11check_crate17h6c78365803b55a50E
_ZN5rustc6middle5entry16find_entry_point17hb48ac22ee028e9e6E
_ZN5rustc6middle6effect11check_crate17h548572049ee9e9c4E
_ZN5rustc6middle6region13resolve_crate17h22307d1564f2103aE
_ZN5rustc6middle8liveness11check_crate17hb8f457098871ae02E
_ZN5rustc6middle9reachable14find_reachable17h2b1eacfaf448c924E
_ZN5rustc6middle9stability24check_unstable_api_usage17hbcf688819ecbb3adE
_ZN5rustc6middle9stability31check_unused_or_stable_features17he32b6c8050b27c87E
_ZN5rustc6middle9stability5Index3new17hdfb7bf0520572455E
_ZN5rustc6middle9stability5Index5build17hb62fb8840db0a066E
_ZN5rustc6traits10specialize16SpecializesCache3new17h71897f30238e3e20E
_ZN5rustc6traits6select14SelectionCache3new17h219158f6b535e8dfE
_ZN5rustc6traits6select15EvaluationCache3new17h7772256affd6b3eaE
_ZN5rustc6traits7fulfill25GlobalFulfilledPredicates3new17hc903c1b24cdad31dE
_ZN5rustc7session11early_error17h481739f30e0ec350E
_ZN5rustc7session13build_session17h76f88f61b4678445E
_ZN5rustc7session25split_msg_into_multilines17h7733ea03256be750E
_ZN5rustc7session26build_session_with_codemap17h2bd8a6052f570513E
_ZN5rustc7session29compile_result_from_err_count17hb7171b1d484c041fE
_ZN5rustc7session6config11host_triple17h25b9e50a33cc1ff5E
_ZN5rustc7session6config13RustcOptGroup9is_stable17h51a10ee4a0b3ade3E
_ZN5rustc7session6config15OutputFilenames4path17ha2de01958bc97ceeE
_ZN5rustc7session6config15OutputFilenames9temp_path17h162854069aac0110E
_ZN5rustc7session6config15nightly_options19is_unstable_enabled17h844d1e49ba9e46d4E
_ZN5rustc7session6config15nightly_options21check_nightly_options17hb5a511cef9c559deE
_ZN5rustc7session6config15rustc_optgroups17hc5d376e35361b79dE
_ZN5rustc7session6config18default_lib_output17hb8b45b408da9ad08E
_ZN5rustc7session6config19build_configuration17hbe710814c1fe2f1eE
_ZN5rustc7session6config21build_session_options17hd140a64bd4cddd13E
_ZN5rustc7session6config21rustc_short_optgroups17h7606084ad4deaf62E
_ZN5rustc7session6config29get_unstable_features_setting17h3f5a95216100f303E
_ZN5rustc7session6config5Input8filestem17h322da6c46391f9d4E
_ZN5rustc7session6config7Options15build_dep_graph17h5ec184ba93b36804E
_ZN5rustc7session6config9cgsetters10code_model17hf9c7918ced6a7fbbE
_ZN5rustc7session6config9cgsetters10no_redzone17h90344ff43dfc6527E
_ZN5rustc7session6config9cgsetters10save_temps17h7ff843a57e47ef2dE
_ZN5rustc7session6config9cgsetters10soft_float17h67824080bf0c7d15E
_ZN5rustc7session6config9cgsetters10target_cpu17h3f9cbfdead047c2eE
_ZN5rustc7session6config9cgsetters13codegen_units17h5d267624ecf5a864E
_ZN5rustc7session6config9cgsetters14extra_filename17h6df2080dfcd14399E
_ZN5rustc7session6config9cgsetters14link_dead_code17h78b0a1880f7e9304E
_ZN5rustc7session6config9cgsetters14no_stack_check17h4e795ffd7b2ae237E
_ZN5rustc7session6config9cgsetters14prefer_dynamic17hde6480ac03dec48fE
_ZN5rustc7session6config9cgsetters14target_feature17h505fae15c4c151f4E
_ZN5rustc7session6config9cgsetters16debug_assertions17h8e70ba586d800128E
_ZN5rustc7session6config9cgsetters16inline_threshold17hf4eaab76b947a9f5E
_ZN5rustc7session6config9cgsetters16no_integrated_as17h5ab201ef71710c68E
_ZN5rustc7session6config9cgsetters16no_vectorize_slp17h538923769aa4f4e9E
_ZN5rustc7session6config9cgsetters16relocation_model17h0616326cd96186b8E
_ZN5rustc7session6config9cgsetters18no_vectorize_loops17hf735640e82e9af6fE
_ZN5rustc7session6config9cgsetters21no_prepopulate_passes17hb1d09adca9775138E
_ZN5rustc7session6config9cgsetters2ar17h9622ab11f1677b1cE
_ZN5rustc7session6config9cgsetters3lto17h076475bf46bb5535E
_ZN5rustc7session6config9cgsetters5panic17h1ed3a7646aa4e46fE
_ZN5rustc7session6config9cgsetters5rpath17h53a3983cba2afdedE
_ZN5rustc7session6config9cgsetters6linker17h7248826ceabcfda6E
_ZN5rustc7session6config9cgsetters6passes17h9098f252ce63802fE
_ZN5rustc7session6config9cgsetters6remark17hf82e0108e74e6fa1E
_ZN5rustc7session6config9cgsetters8metadata17h62b4769264428e7cE
_ZN5rustc7session6config9cgsetters9debuginfo17hac3ca22e29a121f5E
_ZN5rustc7session6config9cgsetters9link_args17h8e0defdbe37dd3e5E
_ZN5rustc7session6config9cgsetters9llvm_args17h9f714a80264b7131E
_ZN5rustc7session6config9cgsetters9opt_level17hb6f98bcea6c9a809E
_ZN5rustc7session6config9dbsetters10debug_llvm17h25ed45a049194d12E
_ZN5rustc7session6config9dbsetters10meta_stats17hfa3ad397597877e3E
_ZN5rustc7session6config9dbsetters10parse_only17h3ef8228c70c6512bE
_ZN5rustc7session6config9dbsetters11incremental17h11bce4ff24decd1fE
_ZN5rustc7session6config9dbsetters11input_stats17h532c6f47823d3b30E
_ZN5rustc7session6config9dbsetters11no_analysis17hd566248802a04d00E
_ZN5rustc7session6config9dbsetters11time_passes17h17e4e22080f887f3E
_ZN5rustc7session6config9dbsetters11trans_stats17h993ee9b8a35e703fE
_ZN5rustc7session6config9dbsetters12asm_comments17hdc9f7c9c50a042e2E
_ZN5rustc7session6config9dbsetters12trace_macros17h0d61fffa8e8f553cE
_ZN5rustc7session6config9dbsetters13extra_plugins17h0c71c4a3a36bb9cfE
_ZN5rustc7session6config9dbsetters13mir_opt_level17h50ecb545ca19a72bE
_ZN5rustc7session6config9dbsetters13save_analysis17h577ccbd48810461eE
_ZN5rustc7session6config9dbsetters14borrowck_stats17h9f7a2fdb3ff912dfE
_ZN5rustc7session6config9dbsetters14dump_dep_graph17h03739145a4de2ba7E
_ZN5rustc7session6config9dbsetters15no_landing_pads17ha5e435a5381d5735E
_ZN5rustc7session6config9dbsetters15print_link_args17h5106356e90928ea1E
_ZN5rustc7session6config9dbsetters15query_dep_graph17h37e4d1156bc02f48E
_ZN5rustc7session6config9dbsetters16count_llvm_insns17h847871fbdc6b9c04E
_ZN5rustc7session6config9dbsetters16keep_mtwt_tables17h4a701ed85ed7eb46E
_ZN5rustc7session6config9dbsetters16print_enum_sizes17h9ba260cdcede3210E
_ZN5rustc7session6config9dbsetters16time_llvm_passes17h9c9dec17c0175ee6E
_ZN5rustc7session6config9dbsetters16treat_err_as_bug17he054014961940471E
_ZN5rustc7session6config9dbsetters16unstable_options17hc87300f76dee83e9E
_ZN5rustc7session6config9dbsetters17ast_json_noexpand17h9881667afc963290E
_ZN5rustc7session6config9dbsetters17print_llvm_passes17h5a98df36239e39e9E
_ZN5rustc7session6config9dbsetters17print_trans_items17h06659befb510e2cdE
_ZN5rustc7session6config9dbsetters17save_analysis_csv17hf6eadb42ee6a1920E
_ZN5rustc7session6config9dbsetters18print_region_graph17h554db3be36aa6baeE
_ZN5rustc7session6config9dbsetters19flowgraph_print_all17h1d340fb534dfcdb3E
_ZN5rustc7session6config9dbsetters20print_move_fragments17h9b211cf17ff87fa8E
_ZN5rustc7session6config9dbsetters21flowgraph_print_loans17hf4ca22ea6518eaa8E
_ZN5rustc7session6config9dbsetters21flowgraph_print_moves17h9d5f8d84b11bf163E
_ZN5rustc7session6config9dbsetters21force_dropflag_checks17h8ebfe1d989c100ecE
_ZN5rustc7session6config9dbsetters21force_overflow_checks17h3b8d0ddd3ff967f5E
_ZN5rustc7session6config9dbsetters23flowgraph_print_assigns17h37e89b96b04e901fE
_ZN5rustc7session6config9dbsetters26continue_parse_after_error17h4a0593a64aa00e64E
_ZN5rustc7session6config9dbsetters28enable_nonzeroing_move_hints17hc39914073400f915E
_ZN5rustc7session6config9dbsetters2ls17hd190428b1dd9f76fE
_ZN5rustc7session6config9dbsetters5orbit17hc49ed80bc22ab889E
_ZN5rustc7session6config9dbsetters7verbose17h5f2fdd7378f2d29eE
_ZN5rustc7session6config9dbsetters8ast_json17ha0de81a66089d01cE
_ZN5rustc7session6config9dbsetters8dump_mir17hf0efa80037f01992E
_ZN5rustc7session6config9dbsetters8keep_ast17h05e4da923fa34debE
_ZN5rustc7session6config9dbsetters8no_trans17h5a59469718162a0dE
_ZN5rustc7session6config9dbsetters9no_verify17h038405d494535d61E
_ZN5rustc7session6config9dbsetters9show_span17h4dcb9f630843803aE
_ZN5rustc7session7Session10diagnostic17h897519c8331a8680E
_ZN5rustc7session7Session10span_fatal10_FILE_LINE17h74e0d7a524c4327dE
_ZN5rustc7session7Session11time_passes17h2ca4bb58e43f82a8E
_ZN5rustc7session7Session12next_node_id17hd76a14ccd68c4311E
_ZN5rustc7session7Session16unstable_options17h3fa5037479321cc5E
_ZN5rustc7session7Session3err17had56f600ee84eb54E
_ZN5rustc7session7Session4warn17h729c0f1734c8024bE
_ZN5rustc7session7Session5fatal17hf94af56928fed274E
_ZN5rustc7session7Session7codemap17h2b2b135b405c8d89E
_ZN5rustc7session7Session7sysroot17h287d13676eacdd61E
_ZN5rustc7session7Session8add_lint17h06be3f18c22e00c5E
_ZN5rustc7session7Session9err_count17h150b7a231c9793b0E
_ZN5rustc9dep_graph5graph8DepGraph3new17h6e76f47d725c941eE
_ZN5rustc9dep_graph5graph8DepGraph7in_task17hd90c5c33db9522f9E
_ZN5rustc9dep_graph5graph8DepGraph9in_ignore17h0be6953c6d2a810aE
_ZN60_$LT$std..io..error..Error$u20$as$u20$core..fmt..Display$GT$3fmt17h121aef892e56c71aE
_ZN60_$LT$std..sys..thread..Thread$u20$as$u20$core..ops..Drop$GT$4drop17h4339c7ef97a80341E
_ZN62_$LT$rustc_driver..Compilation$u20$as$u20$core..fmt..Debug$GT$3fmt17h1893f41561ade6dcE
_ZN62_$LT$rustc_driver..monitor..Sink$u20$as$u20$std..io..Write$GT$5flush17h2d003278f74c6abcE
_ZN62_$LT$rustc_driver..monitor..Sink$u20$as$u20$std..io..Write$GT$5write17h38e8570d4a069e59E
_ZN63_$LT$std..sync..condvar..Condvar$u20$as$u20$core..ops..Drop$GT$4drop17h812151cb364a835cE
_ZN64_$LT$rustc_driver..Compilation$u20$as$u20$core..clone..Clone$GT$5clone17h83cba0e420afc21fE
_ZN65_$LT$rustc_driver..pretty..PpMode$u20$as$u20$core..fmt..Debug$GT$3fmt17h4b1d2193c16e4f5fE
_ZN65_$LT$std..env..Args$u20$as$u20$core..iter..iterator..Iterator$GT$4next17hdfb289f4bc5c8f20E
_ZN65_$LT$std..env..Args$u20$as$u20$core..iter..iterator..Iterator$GT$9size_hint17h4f17fd5881a0450dE
_ZN66_$LT$collections..string..String$u20$as$u20$core..clone..Clone$GT$5clone17hc12b0857b2f2f7d4E
_ZN66_$LT$rustc_driver..Compilation$u20$as$u20$core..cmp..PartialEq$GT$2eq17h961c365bb6014d47E
_ZN66_$LT$std..collections..hash..table..RawTable$LT$K$C$$u20$V$GT$$GT$17new_uninitialized10_FILE_LINE17h4b02367b4f417223E
_ZN66_$LT$std..collections..hash..table..RawTable$LT$K$C$$u20$V$GT$$GT$17new_uninitialized10_FILE_LINE17ha4a342e6c8b02c32E
_ZN66_$LT$syntax..util..interner..RcStr$u20$as$u20$core..ops..Deref$GT$5deref17hb434bcd42f7cbcdbE
_ZN67_$LT$rustc_driver..pretty..PpMode$u20$as$u20$core..clone..Clone$GT$5clone17h104a629cecfd2f37E
_ZN68_$LT$std..sync..mpsc..Sender$LT$T$GT$$u20$as$u20$core..ops..Drop$GT$4drop10_FILE_LINE17h86ea717848895efaE
_ZN69_$LT$rustc_back..sha2..Sha256$u20$as$u20$rustc_back..sha2..Digest$GT$11output_bits17h4a050dd5ce2da96dE
_ZN69_$LT$rustc_back..sha2..Sha256$u20$as$u20$rustc_back..sha2..Digest$GT$5input17hdf706ea37e48478aE
_ZN69_$LT$rustc_back..sha2..Sha256$u20$as$u20$rustc_back..sha2..Digest$GT$6result17h232c3c264ddd9f52E
_ZN69_$LT$rustc_driver..pretty..PpMode$u20$as$u20$core..cmp..PartialEq$GT$2eq17hc8b79703ea89b0adE
_ZN69_$LT$rustc_driver..pretty..PpMode$u20$as$u20$core..cmp..PartialEq$GT$2ne17h61fbfc11d4912d40E
_ZN69_$LT$rustc_llvm..archive_ro..ArchiveRO$u20$as$u20$core..ops..Drop$GT$4drop17h5d8a464f7a34b2baE
_ZN6syntax10std_inject23maybe_inject_crates_ref17h95aa9be24196cd1aE
_ZN6syntax11diagnostics6plugin22expand_diagnostic_used17hb416db9057603c27E
_ZN6syntax11diagnostics6plugin26expand_register_diagnostic17h71ad43ea032f323cE
_ZN6syntax11diagnostics6plugin29expand_build_diagnostic_array17hc32cb1045e60669cE
_ZN6syntax12feature_gate11check_crate17h28f2e9ec5e7621b8E
_ZN6syntax12feature_gate8GatedCfg4gate17hec9f0a02b03fe683E
_ZN6syntax3ast4Name6as_str17he5418ed3ebf9210dE
_ZN6syntax3ext4base7ExtCtxt3new17h00715a4c0b7b03c1E
_ZN6syntax3ext4mtwt12clear_tables17h805e8474fe0f7ae9E
_ZN6syntax3ext4mtwt12reset_tables17h05f76e7f893a910fE
_ZN6syntax3ext6expand12expand_crate17h943e1e51f06dd940E
_ZN6syntax4attr15find_crate_name17h032b31fd6ae2d4edE
_ZN6syntax4attr22mk_name_value_item_str17h27d5d51c6cfa58cfE
_ZN6syntax4fold15noop_fold_crate10_FILE_LINE17h9d9251792164714eE
_ZN6syntax4fold15noop_fold_crate28_$u7b$$u7b$closure$u7d$$u7d$10_FILE_LINE17h05ce1300af032218E
_ZN6syntax4fold6Folder8fold_mac10_FILE_LINE17hfdb99711bd4b134fE
_ZN6syntax4json11JsonEmitter5basic17h13fa1dbe36e71bdeE
_ZN6syntax4test18modify_for_testing17h5fc993714180b953E
_ZN6syntax4util10node_count11NodeCounter3new17hc0ae8324fa5e7070E
_ZN6syntax4util8interner11StrInterner5clear17h25e2b56e14fe0ff1E
_ZN6syntax4util8interner11StrInterner6intern17ha59f13f5c090bd62E
_ZN6syntax4util8interner5RcStr3new17hff33be981b8a547fE
_ZN6syntax5parse21parse_crate_from_file17h826cf32cf8583ec8E
_ZN6syntax5parse27parse_crate_attrs_from_file17h8fb619021cb43088E
_ZN6syntax5parse27parse_crate_from_source_str17hd99fc89cc6074fc9E
_ZN6syntax5parse33parse_crate_attrs_from_source_str17hb1ea4429daded115E
_ZN6syntax5parse5token18get_ident_interner17h98600dba8ff8cb20E
_ZN6syntax5parse5token20reset_ident_interner17h7f5ba9fa5103d371E
_ZN6syntax5print2pp3eof17h1cc675c10daa75c2E
_ZN6syntax5print2pp4word17he5708487899d7423E
_ZN6syntax5print2pp5space17h4774756ff69886d5E
_ZN6syntax5print2pp9hardbreak17h73b04b01a644a0b2E
_ZN6syntax5print6pprust11print_crate17h0787437d9e7a7b96E
_ZN6syntax5print6pprust5State13synth_comment17h076a69ec3a5cef9dE
_ZN6syntax6config24strip_unconfigured_items17hfadc7d1b5dd94869E
_ZN6syntax7codemap7CodeMap11count_lines17h4f8a4909e7eed432E
_ZN6syntax7codemap7CodeMap11get_filemap17h61f20a866dd2da2eE
_ZN6syntax7codemap7CodeMap16with_file_loader17h19aa4b116f0c4207E
_ZN6syntax9show_span3run17heaf84009d0e37b39E
_ZN70_$LT$rustc_driver..RustcDefaultCalls$u20$as$u20$core..clone..Clone$GT$5clone17hc75155ecea878820E
_ZN71_$LT$collections..string..FromUtf8Error$u20$as$u20$core..fmt..Debug$GT$3fmt17hd6c86c460029c5d9E
_ZN71_$LT$rustc_driver..pretty..PpSourceMode$u20$as$u20$core..fmt..Debug$GT$3fmt17h64a327354f78b026E
_ZN71_$LT$std..path..Display$LT$$u27$a$GT$$u20$as$u20$core..fmt..Display$GT$3fmt17h2abad096a20daab1E
_ZN72_$LT$rustc..session..config..CrateType$u20$as$u20$core..fmt..Display$GT$3fmt17h7a1506f780a0ca76E
_ZN72_$LT$rustc_driver..driver..Resolutions$u20$as$u20$core..clone..Clone$GT$5clone17hfdc25bd74c773fffE
_ZN72_$LT$std..collections..hash..map..HashMap$LT$K$C$$u20$V$C$$u20$S$GT$$GT$21insert_hashed_nocheck10_FILE_LINE17h42b861ed0fc22b8eE
_ZN72_$LT$std..collections..hash..map..HashMap$LT$K$C$$u20$V$C$$u20$S$GT$$GT$21insert_hashed_ordered10_FILE_LINE17h89b9cef7d5eb8697E
_ZN72_$LT$std..collections..hash..map..HashMap$LT$K$C$$u20$V$C$$u20$S$GT$$GT$6resize10_FILE_LINE17h12d68e69dbc87478E
_ZN72_$LT$std..collections..hash..map..HashMap$LT$K$C$$u20$V$C$$u20$S$GT$$GT$6resize10_FILE_LINE17h1af84f43432ba17dE
_ZN72_$LT$std..collections..hash..map..HashMap$LT$K$C$$u20$V$C$$u20$S$GT$$GT$6resize10_FILE_LINE17h868ad50dd2d49cdaE
_ZN72_$LT$std..collections..hash..map..HashMap$LT$K$C$$u20$V$C$$u20$S$GT$$GT$6resize15__STATIC_FMTSTR17h44679a5d64ff705eE
_ZN72_$LT$std..collections..hash..map..HashMap$LT$K$C$$u20$V$C$$u20$S$GT$$GT$7reserve10_FILE_LINE17h4b5783883d0222beE
_ZN73_$LT$rustc_driver..pretty..PpSourceMode$u20$as$u20$core..clone..Clone$GT$5clone17h7c82ab6a9de35427E
_ZN73_$LT$syntax..parse..token..InternedString$u20$as$u20$core..ops..Deref$GT$5deref17hdaebdd62716d5b51E
_ZN74_$LT$rustc..hir..map..Node$LT$$u27$ast$GT$$u20$as$u20$core..fmt..Debug$GT$3fmt17hb9e0f263e3aca6dbE
_ZN74_$LT$rustc_driver..pretty..PpFlowGraphMode$u20$as$u20$core..fmt..Debug$GT$3fmt17h338382ef077c9c54E
_ZN74_$LT$std..sync..mpsc..sync..Packet$LT$T$GT$$u20$as$u20$core..ops..Drop$GT$4drop10_FILE_LINE17h82d051671a1d9b6cE
_ZN74_$LT$std..sync..mpsc..sync..Packet$LT$T$GT$$u20$as$u20$core..ops..Drop$GT$4drop10_FILE_LINE17hdf8d86750be8a45aE
_ZN74_$LT$std..sync..mpsc..sync..Packet$LT$T$GT$$u20$as$u20$core..ops..Drop$GT$4drop10_FILE_LINE17hef12d48a1d9450afE
_ZN74_$LT$std..sync..mpsc..sync..Packet$LT$T$GT$$u20$as$u20$core..ops..Drop$GT$4drop15__STATIC_FMTSTR17h0d9bc2c34ff4e2d5E
_ZN75_$LT$rustc_driver..pretty..PpSourceMode$u20$as$u20$core..cmp..PartialEq$GT$2eq17h9448808f803a23c5E
_ZN75_$LT$syntax..parse..token..InternedString$u20$as$u20$core..fmt..Display$GT$3fmt17he5cd384626531b6bE
_ZN76_$LT$rustc_driver..pretty..PpFlowGraphMode$u20$as$u20$core..clone..Clone$GT$5clone17h24a5055147930084E
_ZN76_$LT$std..sync..mpsc..shared..Packet$LT$T$GT$$u20$as$u20$core..ops..Drop$GT$4drop10_FILE_LINE17h0ed1fac3c11cb738E
_ZN76_$LT$std..sync..mpsc..shared..Packet$LT$T$GT$$u20$as$u20$core..ops..Drop$GT$4drop10_FILE_LINE17hb2c9236cf69f7ac7E
_ZN76_$LT$std..sync..mpsc..shared..Packet$LT$T$GT$$u20$as$u20$core..ops..Drop$GT$4drop10_FILE_LINE17hcc17147a3f20a501E
_ZN76_$LT$std..sync..mpsc..shared..Packet$LT$T$GT$$u20$as$u20$core..ops..Drop$GT$4drop15__STATIC_FMTSTR17h3b85a47cd71f3e75E
_ZN76_$LT$std..sync..mpsc..shared..Packet$LT$T$GT$$u20$as$u20$core..ops..Drop$GT$4drop15__STATIC_FMTSTR17h91e275503a22e21eE
_ZN76_$LT$std..sync..mpsc..shared..Packet$LT$T$GT$$u20$as$u20$core..ops..Drop$GT$4drop15__STATIC_FMTSTR17hbaef85b59cbc3951E
_ZN76_$LT$std..sync..mpsc..stream..Packet$LT$T$GT$$u20$as$u20$core..ops..Drop$GT$4drop10_FILE_LINE17h7cd2d14704c30f61E
_ZN76_$LT$std..sync..mpsc..stream..Packet$LT$T$GT$$u20$as$u20$core..ops..Drop$GT$4drop10_FILE_LINE17hb642e3fc102dca7fE
_ZN76_$LT$std..sync..mpsc..stream..Packet$LT$T$GT$$u20$as$u20$core..ops..Drop$GT$4drop15__STATIC_FMTSTR17h19b6680d615ba51aE
_ZN76_$LT$std..sync..mpsc..stream..Packet$LT$T$GT$$u20$as$u20$core..ops..Drop$GT$4drop15__STATIC_FMTSTR17hcf5453de7f7d56adE
_ZN76_$LT$syntax..json..JsonEmitter$u20$as$u20$rustc_errors..emitter..Emitter$GT$11emit_struct17h2fb19cf618703451E
_ZN76_$LT$syntax..json..JsonEmitter$u20$as$u20$rustc_errors..emitter..Emitter$GT$4emit17hd7b3cee9a2e40e72E
_ZN77_$LT$rustc..mir..repr..Lvalue$LT$$u27$tcx$GT$$u20$as$u20$core..fmt..Debug$GT$3fmt17hb8c83641827511cdE
_ZN77_$LT$rustc_driver..pretty..UserIdentifiedItem$u20$as$u20$core..fmt..Debug$GT$3fmt17hc9dd18e959264d16E
_ZN77_$LT$std..sync..mpsc..oneshot..Packet$LT$T$GT$$u20$as$u20$core..ops..Drop$GT$4drop10_FILE_LINE17hc19148c749576302E
_ZN77_$LT$std..sync..mpsc..oneshot..Packet$LT$T$GT$$u20$as$u20$core..ops..Drop$GT$4drop15__STATIC_FMTSTR17hac9b224a711efb6aE
_ZN78_$LT$rustc..mir..repr..Operand$LT$$u27$tcx$GT$$u20$as$u20$core..fmt..Debug$GT$3fmt17hd625dc876a8c111dE
_ZN78_$LT$rustc_driver..pretty..PpFlowGraphMode$u20$as$u20$core..cmp..PartialEq$GT$2eq17hfc956842f2eee41aE
_ZN78_$LT$std..ffi..os_str..OsString$u20$as$u20$core..cmp..PartialEq$LT$str$GT$$GT$2eq17h17a12c0b842fd232E
_ZN79_$LT$rustc_driver..pretty..UserIdentifiedItem$u20$as$u20$core..clone..Clone$GT$5clone17hbd09546352aad28fE
_ZN79_$LT$rustc_driver..pretty..UserIdentifiedItem$u20$as$u20$core..str..FromStr$GT$8from_str17h504cca204d101bd1E
_ZN79_$LT$std..path..Path$u20$as$u20$core..convert..AsRef$LT$std..path..Path$GT$$GT$6as_ref17hb4dc5ced7e496e99E
_ZN79_$LT$syntax..codemap..RealFileLoader$u20$as$u20$syntax..codemap..FileLoader$GT$11file_exists17hc708b0c712e19e38E
_ZN79_$LT$syntax..codemap..RealFileLoader$u20$as$u20$syntax..codemap..FileLoader$GT$8abs_path17h175e0ee01a03e6c1E
_ZN79_$LT$syntax..codemap..RealFileLoader$u20$as$u20$syntax..codemap..FileLoader$GT$9read_file17hd6c31b5701d524bdE
_ZN7getopts5usage17h10e82616febaeedcE
_ZN7getopts7Matches11opt_default17h7f9aeb8d6c3a2e9bE
_ZN7getopts7Matches11opt_present17h8dff241010396cdcE
_ZN7getopts7Matches7opt_str17h276e5f2682abfd26E
_ZN7getopts7Matches8opt_strs17h788d83249f52ade9E
_ZN7getopts7getopts17hc8e444cbc6c15112E
_ZN80_$LT$rustc..hir..map..MapEntry$LT$$u27$ast$GT$$u20$as$u20$core..clone..Clone$GT$5clone17h1784cb77d275d1b0E
_ZN80_$LT$rustc..mir..repr..Statement$LT$$u27$tcx$GT$$u20$as$u20$core..fmt..Debug$GT$3fmt17haf07aa30e8c04f42E
_ZN80_$LT$syntax..util..node_count..NodeCounter$u20$as$u20$syntax..visit..Visitor$GT$15visit_attribute17hac3e6663867046f9E
_ZN80_$LT$syntax..util..node_count..NodeCounter$u20$as$u20$syntax..visit..Visitor$GT$15visit_macro_def17h93dbf222e171a52eE
_ZN80_$LT$syntax..util..node_count..NodeCounter$u20$as$u20$syntax..visit..Visitor$GT$9visit_mod17h10c6f827ffd9a6fbE
_ZN81_$LT$rustc..mir..repr..Arg$u20$as$u20$rustc_data_structures..indexed_vec..Idx$GT$3new17h6299796b670c0a5bE
_ZN81_$LT$rustc..mir..repr..Var$u20$as$u20$rustc_data_structures..indexed_vec..Idx$GT$3new17ha0c9cef51cd3bdf2E
_ZN81_$LT$rustc_errors..DiagnosticBuilder$LT$$u27$a$GT$$u20$as$u20$core..ops..Drop$GT$4drop17h4f4b783b5a7a8e2bE
_ZN82_$LT$rustc..mir..repr..Temp$u20$as$u20$rustc_data_structures..indexed_vec..Idx$GT$3new17hefe78d91f4108ab5E
_ZN82_$LT$rustc..session..config..ErrorOutputType$u20$as$u20$core..default..Default$GT$7default17h592d92fccd85b1fbE
_ZN82_$LT$rustc_driver..pretty..ReplaceBodyWithLoop$u20$as$u20$syntax..fold..Folder$GT$10fold_block17hf50880fc28f89e3eE
_ZN82_$LT$rustc_driver..pretty..ReplaceBodyWithLoop$u20$as$u20$syntax..fold..Folder$GT$14fold_impl_item17h3a9c94cd284a729eE
_ZN82_$LT$rustc_driver..pretty..ReplaceBodyWithLoop$u20$as$u20$syntax..fold..Folder$GT$14fold_item_kind17h2c4684367850ca14E
_ZN82_$LT$rustc_driver..pretty..ReplaceBodyWithLoop$u20$as$u20$syntax..fold..Folder$GT$15fold_trait_item17h546dbcdfedc36066E
_ZN82_$LT$rustc_driver..pretty..ReplaceBodyWithLoop$u20$as$u20$syntax..fold..Folder$GT$8fold_mac17h74ba57a1f529d959E
_ZN82_$LT$std..io..append_to_string..Guard$LT$$u27$a$GT$$u20$as$u20$core..ops..Drop$GT$4drop17h403b74148e34b35aE
_ZN82_$LT$std..path..PathBuf$u20$as$u20$core..convert..AsRef$LT$std..path..Path$GT$$GT$6as_ref17h2f53d34fd165fe8aE
_ZN85_$LT$rustc..dep_graph..raii..DepTask$LT$$u27$graph$GT$$u20$as$u20$core..ops..Drop$GT$4drop17hd37e471fe8c8812aE
_ZN85_$LT$syntax_pos..MultiSpan$u20$as$u20$core..convert..From$LT$syntax_pos..Span$GT$$GT$4from17hccd0d2d7341e3be4E
_ZN86_$LT$rustc..mir..repr..Promoted$u20$as$u20$rustc_data_structures..indexed_vec..Idx$GT$3new17h86090b31dc32c008E
_ZN87_$LT$rustc..hir..print..State$LT$$u27$a$GT$$u20$as$u20$rustc..hir..map..NodePrinter$GT$10print_node17h167dbfc18a49ad80E
_ZN88_$LT$rustc..dep_graph..raii..IgnoreTask$LT$$u27$graph$GT$$u20$as$u20$core..ops..Drop$GT$4drop17hddb1cff06c4d0d6cE
_ZN88_$LT$rustc..mir..repr..BasicBlock$u20$as$u20$rustc_data_structures..indexed_vec..Idx$GT$3new17hb604996bf00e4fbcE
_ZN88_$LT$rustc..mir..repr..BasicBlock$u20$as$u20$rustc_data_structures..indexed_vec..Idx$GT$5index17h12e941d397cac7f7E
_ZN88_$LT$rustc_resolve..Resolver$LT$$u27$a$GT$$u20$as$u20$rustc..hir..lowering..Resolver$GT$11definitions17hc06464170c234f56E
_ZN88_$LT$rustc_resolve..Resolver$LT$$u27$a$GT$$u20$as$u20$rustc..hir..lowering..Resolver$GT$14get_resolution17hd37643909466a573E
_ZN88_$LT$rustc_resolve..Resolver$LT$$u27$a$GT$$u20$as$u20$rustc..hir..lowering..Resolver$GT$17record_resolution17h12c35ed6fcb3609cE
_ZN88_$LT$rustc_resolve..Resolver$LT$$u27$a$GT$$u20$as$u20$rustc..hir..lowering..Resolver$GT$29resolve_generated_global_path17h2ba384282ecff3e3E
_ZN88_$LT$serialize..json..Encoder$LT$$u27$a$GT$$u20$as$u20$serialize..serialize..Encoder$GT$11emit_struct15__STATIC_FMTSTR17h572c075c89d7504cE
_ZN88_$LT$serialize..json..Encoder$LT$$u27$a$GT$$u20$as$u20$serialize..serialize..Encoder$GT$11emit_struct15__STATIC_FMTSTR17h774ffad6f30de172E
_ZN88_$LT$serialize..json..Encoder$LT$$u27$a$GT$$u20$as$u20$serialize..serialize..Encoder$GT$12emit_seq_elt15__STATIC_FMTSTR17h5774d6f341e0ecb2E
_ZN88_$LT$serialize..json..Encoder$LT$$u27$a$GT$$u20$as$u20$serialize..serialize..Encoder$GT$16emit_option_none17h7d333c5da3eac9ceE
_ZN88_$LT$serialize..json..Encoder$LT$$u27$a$GT$$u20$as$u20$serialize..serialize..Encoder$GT$17emit_enum_variant15__STATIC_FMTSTR17h2aef92506feb276dE
_ZN88_$LT$serialize..json..Encoder$LT$$u27$a$GT$$u20$as$u20$serialize..serialize..Encoder$GT$17emit_enum_variant15__STATIC_FMTSTR17h70f64bc02162d29bE
_ZN88_$LT$serialize..json..Encoder$LT$$u27$a$GT$$u20$as$u20$serialize..serialize..Encoder$GT$17emit_enum_variant15__STATIC_FMTSTR17hcdd02c69cc1eec05E
_ZN88_$LT$serialize..json..Encoder$LT$$u27$a$GT$$u20$as$u20$serialize..serialize..Encoder$GT$17emit_struct_field15__STATIC_FMTSTR17hc3f6c38754118171E
_ZN88_$LT$serialize..json..Encoder$LT$$u27$a$GT$$u20$as$u20$serialize..serialize..Encoder$GT$17emit_struct_field15__STATIC_FMTSTR17hd82838eb62ae31a3E
_ZN88_$LT$serialize..json..Encoder$LT$$u27$a$GT$$u20$as$u20$serialize..serialize..Encoder$GT$21emit_enum_variant_arg15__STATIC_FMTSTR17h8647046a1a61877fE
_ZN88_$LT$serialize..json..Encoder$LT$$u27$a$GT$$u20$as$u20$serialize..serialize..Encoder$GT$7emit_u817h6dc5a1cf9e6a2705E
_ZN88_$LT$serialize..json..Encoder$LT$$u27$a$GT$$u20$as$u20$serialize..serialize..Encoder$GT$8emit_seq15__STATIC_FMTSTR17h8e93572fd6db7651E
_ZN88_$LT$serialize..json..Encoder$LT$$u27$a$GT$$u20$as$u20$serialize..serialize..Encoder$GT$8emit_seq15__STATIC_FMTSTR17h98f9e5dbd7417532E
_ZN88_$LT$serialize..json..Encoder$LT$$u27$a$GT$$u20$as$u20$serialize..serialize..Encoder$GT$8emit_str17h23ff690a076a1a49E
_ZN88_$LT$serialize..json..Encoder$LT$$u27$a$GT$$u20$as$u20$serialize..serialize..Encoder$GT$8emit_u3217h310e10bce47a4ad1E
_ZN88_$LT$serialize..json..Encoder$LT$$u27$a$GT$$u20$as$u20$serialize..serialize..Encoder$GT$8emit_u6417h295398c2fbdcd253E
_ZN88_$LT$serialize..json..Encoder$LT$$u27$a$GT$$u20$as$u20$serialize..serialize..Encoder$GT$9emit_bool17h0901589a116886b0E
_ZN88_$LT$serialize..json..Encoder$LT$$u27$a$GT$$u20$as$u20$serialize..serialize..Encoder$GT$9emit_char17h29dc15beea9f22e1E
_ZN88_$LT$serialize..json..Encoder$LT$$u27$a$GT$$u20$as$u20$serialize..serialize..Encoder$GT$9emit_uint17h3981603c90d986b9E
_ZN8graphviz11escape_html17h32510f80b027a8f2E
_ZN8graphviz11render_opts7writeln15__STATIC_FMTSTR17h3de19cccfa5212ddE
_ZN8graphviz2Id8as_slice17h00c437813a7e62f2E
_ZN8graphviz9LabelText13to_dot_string17h354d84f11fbebc8aE
_ZN90_$LT$rustc_errors..emitter..BasicEmitter$u20$as$u20$rustc_errors..emitter..CoreEmitter$GT$12emit_message17ha8fdc7c996f665b1E
_ZN91_$LT$rustc_mir..transform..type_check..TypeckMir$u20$as$u20$rustc..mir..transform..Pass$GT$8dep_node17h63ed37d19890e4ffE
_ZN92_$LT$serialize..json..FormatShim$LT$$u27$a$C$$u20$$u27$b$GT$$u20$as$u20$core..fmt..Write$GT$9write_str17h3c023b4f926232b4E
_ZN92_$LT$std..path..PathBuf$u20$as$u20$core..convert..From$LT$std..ffi..os_str..OsString$GT$$GT$4from17h95f3b152c10ab952E
_ZN93_$LT$collections..string..String$u20$as$u20$core..convert..From$LT$$RF$$u27$a$u20$str$GT$$GT$4from17h8047de97bc6239aaE
_ZN93_$LT$rustc_driver..RustcDefaultCalls$u20$as$u20$rustc_driver..CompilerCalls$LT$$u27$a$GT$$GT$13late_callback17h8ebb9579c945af7eE
_ZN93_$LT$rustc_driver..RustcDefaultCalls$u20$as$u20$rustc_driver..CompilerCalls$LT$$u27$a$GT$$GT$14early_callback17hce560891def99cc9E
_ZN93_$LT$rustc_driver..RustcDefaultCalls$u20$as$u20$rustc_driver..CompilerCalls$LT$$u27$a$GT$$GT$16build_controller17h6b6cd2703de49520E
_ZN93_$LT$rustc_driver..RustcDefaultCalls$u20$as$u20$rustc_driver..CompilerCalls$LT$$u27$a$GT$$GT$8no_input17hda1feff9c7bd5833E
_ZN93_$LT$serialize..json..EncoderError$u20$as$u20$core..convert..From$LT$core..fmt..Error$GT$$GT$4from17h35e58d267c78362dE
_ZN96_$LT$syntax..util..small_vector..IntoIter$LT$T$GT$$u20$as$u20$core..iter..iterator..Iterator$GT$4next10_FILE_LINE17heac6c04b85c57f53E
_ZN9rustc_mir6pretty12write_mir_fn17h5d315307d44d0faeE
_ZN9rustc_mir6pretty16write_mir_pretty15__STATIC_FMTSTR17h03307e267fe4444bE
_ZN9rustc_mir6pretty16write_mir_pretty15__STATIC_FMTSTR17h264c6742d7b21aeeE
_ZN9rustc_mir7mir_map19build_mir_for_crate17h3f2cba6d3f64cfd6E
_ZN9rustc_mir8graphviz10write_node15__STATIC_FMTSTR17h0826e0405ed722d7E
_ZN9rustc_mir8graphviz10write_node15__STATIC_FMTSTR17h113762a9010be509E
_ZN9rustc_mir8graphviz11write_edges15__STATIC_FMTSTR17h10da407e0b981b86E
_ZN9rustc_mir8graphviz16write_node_label15__STATIC_FMTSTR17h0d387272f19bf118E
_ZN9rustc_mir8graphviz16write_node_label15__STATIC_FMTSTR17h1cc5f177b7da24c2E
_ZN9rustc_mir8graphviz16write_node_label15__STATIC_FMTSTR17h231b230ffb59215eE
_ZN9rustc_mir8graphviz16write_node_label15__STATIC_FMTSTR17h335c9c8c63f0a0a2E
_ZN9rustc_mir8graphviz16write_node_label15__STATIC_FMTSTR17hb28c791176eb165fE
_ZN9rustc_mir8graphviz16write_node_label15__STATIC_FMTSTR17hb50391e81a5fd764E
_ZN9rustc_mir8graphviz16write_node_label15__STATIC_FMTSTR17hf93cc4a5b27daea3E
_ZN9rustc_mir8graphviz16write_node_label16__STATIC_FMTARGS17h23ca5e34bca3bcf5E
_ZN9rustc_mir8graphviz17write_graph_label15__STATIC_FMTSTR17h075f2dcfc50f2625E
_ZN9rustc_mir8graphviz17write_graph_label15__STATIC_FMTSTR17h0afa0c6762c77694E
_ZN9rustc_mir8graphviz17write_graph_label15__STATIC_FMTSTR17h2b173252a64d457dE
_ZN9rustc_mir8graphviz17write_graph_label15__STATIC_FMTSTR17h35b9eea98690e985E
_ZN9rustc_mir8graphviz17write_graph_label15__STATIC_FMTSTR17h5c46c113df9919d7E
_ZN9rustc_mir8graphviz17write_graph_label15__STATIC_FMTSTR17h80bcf6d6a8c9c213E
_ZN9rustc_mir8graphviz17write_graph_label15__STATIC_FMTSTR17h8b4c920e7f15e331E
_ZN9rustc_mir8graphviz17write_graph_label15__STATIC_FMTSTR17h9028dcfe5fa23490E
_ZN9rustc_mir8graphviz17write_graph_label15__STATIC_FMTSTR17h94d0a1ad46f5cf4eE
_ZN9rustc_mir8graphviz17write_graph_label15__STATIC_FMTSTR17hb5d1ee17df224a71E
_ZN9rustc_mir8graphviz17write_graph_label15__STATIC_FMTSTR17hbb070d72dcfa1b64E
_ZN9rustc_mir8graphviz17write_graph_label15__STATIC_FMTSTR17hd959a4606a806ed8E
_ZN9rustc_mir8graphviz18write_mir_graphviz15__STATIC_FMTSTR17h18e54a8ea97ac004E
_ZN9rustc_mir8graphviz18write_mir_graphviz15__STATIC_FMTSTR17h2cb2839c48cc6640E
_ZN9rustc_mir8graphviz18write_mir_graphviz15__STATIC_FMTSTR17hd8386d835bb2ef9cE
_ZN9rustc_mir8graphviz18write_mir_graphviz15__STATIC_FMTSTR17hea8e041be950746eE
_ZN9rustc_mir8graphviz18write_mir_graphviz15__STATIC_FMTSTR17hf3a8adf2e631c6d3E
_ZN9rustc_mir8graphviz4node17h44db798e1d4ae3c5E
_ZN9rustc_mir8graphviz6escape15__STATIC_FMTSTR17h6552efddfe708650E
_ZN9rustc_mir9transform12simplify_cfg11SimplifyCfg3new17hdbd0109c15cac501E
_ZN9rustc_mir9transform17simplify_branches16SimplifyBranches3new17h41bbd5612c6c4322E
_ZN9serialize4json10escape_str17h77b24fe78af321ecE
_ZN9serialize4json7Encoder3new17hf877e35e1bbda0daE
__rust_allocate
__rust_deallocate
__rust_maybe_catch_panic
__rust_reallocate
memcmp
memcpy
memmove
memset
pthread_mutex_destroy
pthread_mutex_init
pthread_mutex_lock
pthread_mutex_unlock
pthread_mutexattr_destroy
pthread_mutexattr_init
pthread_mutexattr_settype
round
rust_eh_personality
rust_metadata_rustc_driver_f8f3da30bfc715a6
libsyntax_ext-39b92f95.so
librustc_save_analysis-39b92f95.so
librustc_privacy-39b92f95.so
librustc_trans-39b92f95.so
librustc_passes-39b92f95.so
librustc_lint-39b92f95.so
librustc_incremental-39b92f95.so
librustc_typeck-39b92f95.so
librustc_borrowck-39b92f95.so
librustc_mir-39b92f95.so
librustc_const_eval-39b92f95.so
librustc_plugin-39b92f95.so
librustc_metadata-39b92f95.so
librustc_resolve-39b92f95.so
librustc-39b92f95.so
librustc_const_math-39b92f95.so
librustc_back-39b92f95.so
librustc_llvm-39b92f95.so
libgraphviz-39b92f95.so
libgetopts-39b92f95.so
libflate-39b92f95.so
libsyntax-39b92f95.so
librustc_errors-39b92f95.so
libsyntax_pos-39b92f95.so
libserialize-39b92f95.so
liblog-39b92f95.so
libstd-39b92f95.so
libpthread.so.0
libm.so.6
libstdc++.so.6
libgcc_s.so.1
libc.so.6
_edata
__bss_start
_end
GCC_3.0
GLIBC_2.2.5
GLIBC_2.14
%z'9
%r'9
%j'9
%b'9
%Z'9
%R'9
%J'9
%B'9
%:'9
%2'9
%*'9
%"'9
%z&9
%r&9
%j&9
%b&9
%Z&9
%R&9
%J&9
%B&9
%:&9
%2&9
%*&9
%"&9
%z%9
%r%9
%j%9
%b%9
%Z%9
%R%9
%J%9
%B%9
%:%9
%2%9
%*%9
%"%9
%z$9
%r$9
%j$9
%b$9
%Z$9
%R$9
%J$9
%B$9
%:$9
%2$9
%*$9
%"$9
%z#9
%r#9
%j#9
%b#9
%Z#9
%R#9
%J#9
%B#9
%:#9
%2#9
%*#9
%"#9
%z"9
%r"9
%j"9
%b"9
%Z"9
%R"9
%J"9
%B"9
%:"9
%2"9
%*"9
%""9
%z!9
%r!9
%j!9
%b!9
%Z!9
%R!9
%J!9
%B!9
%:!9
%2!9
%*!9
%"!9
%z 9
%r 9
%j 9
%b 9
%Z 9
%R 9
%J 9
%B 9
%: 9
%2 9
%* 9
%" 9
=h=<
AWAVAUATSH
fffff.
[A\A]A^A_]
tgM9
AVSI
[A^]
[A^]
AWAVSPI
[A^A_]
[A^A_]
AWAVATSI
{ L9
[A\A^A_]
[A\A^A_]
AWAVSPH
[A^A_]
[A^A_]
AWAVAUATSH
[A\A]A^A_]
AWAVATSI
G(L9
[A\A^A_]
[A\A^A_]
AWAVAUATSH
t"L9
t*M9
fff.
[A\A]A^A_]
AWAVAUATSH
fffff.
N(H9
8[A\A]A^A_]
AWAVAUATSH
(ffffff.
([A\A]A^A_]
AWAVATSH
P[A\A^A_]
AVSH
[A^]
[A^]
AWAVAUATSH
([A\A]A^A_]
5Fw8
AWAVSH
AVSH
[A^]
[A^]
AWAVAUATSH
x[A\A]A^A_]
AWAVAUATSH
X[A\A]A^A_]
ffff.
AWAVATSI
[A\A^A_]
[A\A^A_]
[A\A^A_]
AWAVATSI
ffff.
u	[A\A^A_]
[A\A^A_]
AVSH
AVSH
AWAVAUATSH
D$0H
[A\A]A^A_]
t>L9
t!L9
tRL9
tML9
AWAVAUATSH
-9_8
ffff.
|1ffff.
,6L9
fff.
`riH
ffffff.
-fX8
ffffff.
ffff.
[A\A]A^A_]
t!L9
=>T8
u!M9
AWAVSPI
[A^A_]
[A^A_]
AWAVAUATSH
[A\A]A^A_]
t%L9
fff.
t	L9
AWAVAUATSH
D$ H
l$ M
l$ M
[A\A]A^A_]
t%L9
AWAVAUATSH
fffff.
tDL9
H[A\A]A^A_]
H[A\A]A^A_]
AWAVATSH
HXH9
H(H9
`[A\A^A_]
AWAVAUATSPI
w7IcD
:u$H
[A\A]A^A_]
[A\A]A^A_]
AWAVAUATSH
[A\A]A^A_]
A(L9
GXL9
Fffffff.
D$(H
fff.
fffff.
D$ =
[A\A]A^A_]
t#L9
t#L9
AWAVSPI
AVSH
$[A^]
[A^]
AVSH
AVSH
[A^]
[A^]
AVSH
[A^]
[A^]
AVSH
p[A^]
AVSH
[A^]
[A^]
AWAVSH
[A^A_]
AWAVAUATSH
t@fffff.
~XL9
[A\A]A^A_]
5vT8
~XL9
AWAVAUATSH
[A\A]A^A_]
5zP8
AWAVATSI
F0L9
F@L9
u	[A\A^A_]
[A\A^A_]
AWAVAUATSH
[A\A]A^A_]
^(H9
_XH9
ffffff.
ffffff.
[A\A]A^A_]
t#L9
~-Lk
fff.
t#L9
~,Lk
='<8
t9M9
t4Ik
=+;8
AWAVAUATSH
:u'H
G L9
:u!H
([A\A]A^A_]
:u I
([A\A]A^A_]
AVSH
$[A^]
[A^]
AVSH
AVSH
[A^]
[A^]
AVSH
p[A^]
AVSH
[A^]
[A^]
AWAVSH
[A^A_]
AWAVSH
[A^A_]
5;28
AWAVATSI
~HL9
[A\A^A_]
[A\A^A_]
AWAVAUATSH
[A\A]A^A_]
AWAVATSI
F0L9
F@L9
^8Lk
u	[A\A^A_]
[A\A^A_]
AWAVATSI
u	[A\A^A_]
[A\A^A_]
AWAVATSI
w(L9
wpL9
fff.
u	[A\A^A_]
[A\A^A_]
AWAVAUATSH
([A\A]A^A_]
([A\A]A^A_]
AWAVAUATSH
[A\A]A^A_]
[A\A]A^A_]
AWAVATSI
G8L9
ffff.
u	[A\A^A_]
[A\A^A_]
AWAVAUATSH
H[A\A]A^A_]
t%H9
fffff.
t'H9
H[A\A]A^A_]
AWAVATSI
fffff.
^@L9
[A\A^A_]
[A\A^A_]
AWAVATSI
tSM9
t	[A\A^A_]
[A\A^A_]
AWAVAUATSH
ffffff.
t/H9
H[A\A]A^A_]
H[A\A]A^A_]
AWAVAUATSPI
[A\A]A^A_]
[A\A]A^A_]
AWAVAUATSPI
[A\A]A^A_]
[A\A]A^A_]
AWAVAUATSPI
w L9
[A\A]A^A_]
AWAVAUATSPI
[A\A]A^A_]
[A\A]A^A_]
AWAVAUATSPI
[A\A]A^A_]
[A\A]A^A_]
AWAVAUATSH
[A\A]A^A_]
9help
9help
fffff.
r-H9
fffff.
r*H9
ffffff.
r,H9
ffff.
r,H9
ffff.
t!L9
t!L9
t!L9
t!L9
t!L9
t:L9
AWAVAUATSPI
D$ L9
L$(H
D$ H
D$8L9
L$@H
\$0H
fff.
D$8H
[A\A]A^A_]
[A\A]A^A_]
AWAVAUATSPI
[A\A]A^A_]
[A\A]A^A_]
AVSH
 [A^]
AVSH
[A^]
AWAVAUATSH
x[A\A]A^A_]
AWAVAUATSH
tAL9
GXL9
wxL9
tDL9
H[A\A]A^A_]
H[A\A]A^A_]
AWAVAUATSPI
D$PH
D$h=
D$`=
[A\A]A^A_]
[A\A]A^A_]
AWAVAUATSH
8[A\A]A^A_]
8[A\A]A^A_]
AWAVAUATSPI
[A\A]A^A_]
[A\A]A^A_]
AWAVAUATSH
fffff.
vPH9
8[A\A]A^A_]
8[A\A]A^A_]
AWAVAUATSH
ffff.
$u7I
[A\A]A^A_]
AWAVAUATSH
8[A\A]A^A_]
AVSH
4	L9
[A^]
AWAVAUATSH
tML9
tDL9
|0H9
tML9
D$8H
D$0H
D$(H
D$ H
tML9
tML9
tML9
[A\A]A^A_]
fff.
tML9
t~M9
fffff.
tTL9
t1L9
t1L9
=!c7
t1L9
tGL9
tGL9
tGL9
t)L9
t!L9
t1L9
tML9
AWAVSPH
s M9
s8M9
sPM9
shM9
[A^A_]
[A^A_]
AWAVSPI
{ L9
[A^A_]
[A^A_]
AWAVAUATSH
u@E1
expandedI9
[A\A]A^A_]
=bN7
AWAVAUATSH
l$hI
T$(L
T$ I
L$XH
|$PH
\$8I
D$HH
fff.
sWM9
<1L9
L$XI
L$XI
L$XL
l$hI
fffff.
D$HI
T$8I
ffffff.
T$8E
L$HH
D$PM
\$8I
D$HH
fffff.
L$XI
L$XA
T$XI
T$XI
8[A\A]A^A_]
=UH7
=2H7
AVSH
46L9
[A^]
AWAVAUATSH
[A\A]A^A_]
AWAVATSH
tAL9
w8M9
0[A\A^A_]
0[A\A^A_]
AWAVAUATSH
ffffff.
r,L9
u5L9
2ff.
r,H9
fff.
r-L9
ffffff.
$6L9
r-L9
ffffff.
y(E1
r,L9
u5L9
2ff.
w(E1
r,H9
r-L9
ffffff.
<6L9
r-L9
ffffff.
,6L9
r-H9
ffffff.
,6L9
[A\A]A^A_]
AWAVAUATSH
fff.
x[A\A]A^A_]
AWAVSH
([A^A_]
AWAVAUATSH
[A\A]A^A_]
AWAVSH
[A^A_]
AWAVATSH
[A\A^A_]
AWAVAUATSH
fff.
fff.
#fffff.
uJI9
<6L9
(fff.
fffff.
`rhH
[A\A]A^A_]
tuL9
AWAVAUATSH
I;\$
[A\A]A^A_]
AWAVAUATSH
[A\A]A^A_]
AWAVAUATSH
ffff.
tUH9
[A\A]A^A_]
AWAVAUATSPI
[A\A]A^A_]
[A\A]A^A_]
AWAVAUATSH
[A\A]A^A_]
[A\A]A^A_]
AWAVAUATSH
[A\A]A^A_]
s M9
_`L9
[A\A]A^A_]
fffff.
t$ H
[A\A]A^A_]
t*L9
ffffff.
GhL9
ffffff.
[A\A]A^A_]
G8L9
_0Li
!uCH
t'L9
t"Hi
fffff.
[A\A]A^A_]
[A\A]A^A_]
t~L9
t<L9
t7Hi
AVSH
=[A^]
t&L9
[A^]
AWAVAUATSH
}(L9
}8L9
t L9
[A\A]A^A_]
[A\A]A^A_]
AWAVAUATSH
^ L9
^ L9
{ M9
[A\A]A^A_]
t#L9
[A\A]A^A_]
ffff.
ffffff.
t'L9
fff.
ffffff.
t'L9
fff.
F8L9
^0Li
!uCH
t'L9
t"Hi
fffff.
[A\A]A^A_]
[A\A]A^A_]
t<L9
t7Hi
AWAVATSI
^ L9
[A\A^A_]
[A\A^A_]
[A\A^A_]
{ M9
tNL9
t#L9
[A\A^A_]
F(L9
ffffff.
v@L9
fffff.
[A\A^A_]
F8L9
^0Li
!uCH
t'L9
t"Hi
fffff.
t7L9
t2Hi
u	[A\A^A_]
[A\A^A_]
tzL9
t<L9
t7Hi
AWAVAUATSPI
[A\A]A^A_]
[A\A]A^A_]
AWAVAUATSPI
fff.
[A\A]A^A_]
[A\A]A^A_]
AVSH
[A^]
[A^]
AWAVAUATSH
tQM9
G0L9
_(Li
!uZH
Offffff.
t Hi
fff.
(L;e
[A\A]A^A_]
[A\A]A^A_]
tAHi
AWAVATSI
t#L9
tNM9
[A\A^A_]
[A\A^A_]
AWAVAUATSPI
[A\A]A^A_]
w8L9
t#L9
[A\A]A^A_]
ffffff.
t#L9
w0L9
G8L9
_0Li
 fff.
fff.
!uDH
[A\A]A^A_]
[A\A]A^A_]
tzL9
t<L9
t7Hi
AWAVAUATSPI
[A\A]A^A_]
[A\A]A^A_]
AWAVAUATSPI
fff.
[A\A]A^A_]
[A\A]A^A_]
AVSH
[A^]
[A^]
t%UH
AVSH
!uCH
[A^]
AWAVAUATSPH
[A\A]A^A_]
[A\A]A^A_]
[A\A]A^A_]
[A\A]A^A_]
[A\A]A^A_]
[A\A]A^A_]
!uYH
!u5H
F(L9
^ Li
!u[H
F0L9
^(Li
!u|H
!u5H
t<L9
t7Hi
AWAVAUATSPI
v L9
tNL9
^8L9
[A\A]A^A_]
[A\A]A^A_]
AVSH
[A^]
[A^]
AWAVATSI
{ M9
^`L9
[A\A^A_]
F8L9
^0Li
fff.
!uDH
u	[A\A^A_]
t<L9
t7Hi
AWAVAUATSPI
[A\A]A^A_]
[A\A]A^A_]
AWAVAUATSH
fff.
t*L9
ffffff.
t#M9
C Hk
([A\A]A^A_]
AWAVATSI
u	[A\A^A_]
[A\A^A_]
AWAVAUATSH
w@M9
G L9
w0M9
ffffff.
t*L9
ffffff.
[A\A]A^A_]
[A\A]A^A_]
AWAVAUATSH
{ M9
ffff.
t*L9
ffffff.
[A\A]A^A_]
F8L9
^0Li
fff.
!uDH
[A\A]A^A_]
t<L9
t7Hi
AWAVSPH
[A^A_]
[A^A_]
AWAVAUATSH
t$ L9
D$(H
t$ L
t&L9
fffff.
|$0M
tKM9
\$8L9
[A\A]A^A_]
[A\A]A^A_]
t$ H
AWAVATSI
u	[A\A^A_]
[A\A^A_]
AWAVSPH
[A^A_]
[A^A_]
AWAVATSI
fff.
u	[A\A^A_]
[A\A^A_]
AWAVSPH
[A^A_]
[A^A_]
AWAVAUATSPI
[A\A]A^A_]
[A\A]A^A_]
AWAVAUATSPI
[A\A]A^A_]
[A\A]A^A_]
AWAVAUATSPI
@ffff.
[A\A]A^A_]
[A\A]A^A_]
AWAVATSI
u	[A\A^A_]
[A\A^A_]
AWAVAUATSPI
[A\A]A^A_]
[A\A]A^A_]
AWAVAUATSH
_@Li
ffff.
} Li
fffff.
!uZH
Offffff.
t Hi
fff.
t!Hi
fff.
_ Li
!uZH
Offffff.
t Hi
fff.
t!Hi
fff.
fffff.
ffffff.
tPHi
fffff.
t!Hi
fff.
_ Li
!uZH
Offffff.
t Hi
fff.
t!Hi
fff.
t$Hi
ffffff.
k Hi
} Li
fffff.
!uZH
Offffff.
t Hi
fff.
t!Hi
fff.
_ Li
!uZH
Offffff.
t Hi
fff.
t!Hi
fff.
fffff.
fff.
tpHi
t!Hi
fff.
_ Li
!uZH
Offffff.
t Hi
fff.
t!Hi
fff.
t$Hi
ffffff.
t$Hi
ffffff.
8[A\A]A^A_]
8[A\A]A^A_]
tGHi
tzHi
tGHi
AWAVAUATSH
[A\A]A^A_]
AWAVAUATSH
D$(H
D$ L
[A\A]A^A_]
=]k6
AWAVAUATSH
fffff.
ffff.
=jb6
D$8H
D$0H
D$(H
D$ H
D$8H
D$0H
D$(H
D$ H
t%L9
D$8H
D$0H
D$(H
D$ H
fffff.
[A\A]A^A_]
tKL9
tKL9
tKL9
t5L9
t5L9
t5L9
AWAVATSI
u	[A\A^A_]
[A\A^A_]
AWAVAUATSPH
{ M9
ffffff.
[A\A]A^A_]
k M9
AWAVAUATSH
[A\A]A^A_]
AWAVAUATSH
[A\A]A^A_]
AWAVAUATSH
[A\A]A^A_]
AWAVAUATSH
`rgH
H[A\A]A^A_]
AWAVATSI
ffff.
[A\A^A_]
AWAVATSI
ffff.
rzI)
ffff.
[A\A^A_]
AWAVATSH
P[A\A^A_]
AVSH
[A^]
[A^]
AWAVSPI
rzI)
ffff.
[A^A_]
AWAVSH
rzI)
ffff.
[A^A_]
AWAVSPI
fffff.
rzI)
ffff.
[A^A_]
AWAVSH
rzI)
ffff.
[A^A_]
AWAVATSI
_pLi
u	[A\A^A_]
[A\A^A_]
AWAVAUATSH
t7L9
fff.
[A\A]A^A_]
AWAVAUATSH
$6L9
 wlA
,"L9
t.L9
fffff.
4$L9
[A\A]A^A_]
AWAVAUATSPI
ffff.
[A\A]A^A_]
[A\A]A^A_]
AWAVAUATSH
x[A\A]A^A_]
AWAVAUATSH
ffff.
[A\A]A^A_]
AWAVAUATSH
t'H9
t%I9
[A\A]A^A_]
[A\A]A^A_]
AWAVAUATSH
ffff.
[A\A]A^A_]
AWAVATSI
u	[A\A^A_]
[A\A^A_]
AVSH
4	L9
[A^]
AWAVATSI
u	[A\A^A_]
[A\A^A_]
AWAVAUATSH
fff.
ufH)
ffffff.
x[A\A]A^A_]
AWAVAUATSH
$?M9
H[A\A]A^A_]
AWAVAUATSH
fff.
4?L9
!ff.
tBf.
%fffff.
,$M9
ffff.
fffff.
ffffff.
tuH;]
(L;u
[A\A]A^A_]
AWAVAUATSH
fffff.
r,H9
4$L9
`riL
[A\A]A^A_]
AWAVAUATSH
sEM9
qff.
ffffff.
=1_5
fffff.
t&L9
rBE1
fff.
ffffff.
fffff.
{ff.
=W\5
,6L9
fff.
pffffff.
`rwH
pfffff.
fff.
ffffff.
`rkH
|8pL
fffff.
[A\A]A^A_]
AWAVAUATSH
t5L9
r,H9
ffff.
`rhL
[A\A]A^A_]
fffff.
t)L9
AWAVAUATSH
fffff.
ffff.
`rgH
fffff.
fff.
`riH
h[A\A]A^A_]
AWAVSPI
rzI)
ffff.
[A^A_]
AWAVATSH
I;D$
[A\A^A_]
AVSH
[A^]
5[	5
AWAVAUATSH
(ffffff.
([A\A]A^A_]
AWAVATSH
P[A\A^A_]
AVSH
[A^]
[A^]
AWAVAUATSH
([A\A]A^A_]
AWAVATSI
$6L9
[A\A^A_]
AWAVAUATSH
tDfff.
AWAVAUATSH
ffff.
fffff.
fff.
fff.
D$ H
\$0H
T$@H
fffff.
[A\A]A^A_]
AWAVAUATSH
([A\A]A^A_]
fffff.
([A\A]A^A_]
AWAVAUATSH
([A\A]A^A_]
fffff.
([A\A]A^A_]
AWAVAUATSH
fffff.
([A\A]A^A_]
AWAVAUATSH
_8fA
W(fA
[A\A]A^A_]
t1L9
AWAVAUATSH
fffff.
~)Lk
[A\A]A^A_]
\$8A
T$(A
fffff.
t5L9
fff.
~)Lk
ffff.
~%Mk
AWAVAUATSH
[A\A]A^A_]
AWAVAUATSH
!ff.
 ff.
ffff.
t3M9
fffff.
t[L9
t0L9
$6M9
-exeM
[A\A]A^A_]
AWAVATSI
u	[A\A^A_]
[A\A^A_]
AWAVAUATSH
[A\A]A^A_]
AWAVATSH
D$ =
I;D$
I;D$
@[A\A^A_]
@[A\A^A_]
AWAVATSI
fff.
u	[A\A^A_]
[A\A^A_]
AWAVATSI
u	[A\A^A_]
[A\A^A_]
AVSH
[A^]
[A^]
AWAVAUATSH
8[A\A]A^A_]
8[A\A]A^A_]
AWAVATSI
ffffff.
[A\A^A_]
AWAVATSI
[A\A^A_]
[A\A^A_]
AWAVATSI
[A\A^A_]
[A\A^A_]
AWAVAUATSH
tML9
[A\A]A^A_]
tGM9
AWAVAUATSH
t!H9
8[A\A]A^A_]
8[A\A]A^A_]
AWAVAUATSH
t!L9
t$L9
tJL9
h[A\A]A^A_]
AWAVATSH
^hLk
 [A\A^A_]
AWAVAUATSH
[A\A]A^A_]
t1L9
AWAVAUATSH
s L9
fffff.
{XM)
t!L9
ffff.
t!L9
ffff.
sxL9
ffff.
PrSM
fffff.
fff.
8rYM
fffff.
(fff.
([A\A]A^A_]
([A\A]A^A_]
s L9
=|N4
uxL9
=`M4
AWAVATSH
ffffff.
t;L9
0[A\A^A_]
AWAVAUATSH
8[A\A]A^A_]
8[A\A]A^A_]
AWAVAUATSPI
[A\A]A^A_]
[A\A]A^A_]
AWAVAUATSH
fffff.
tHL9
([A\A]A^A_]
([A\A]A^A_]
AWAVAUATSH
([A\A]A^A_]
fffff.
([A\A]A^A_]
AWAVAUATSH
8[A\A]A^A_]
8[A\A]A^A_]
AWAVAUATSH
[A\A]A^A_]
AWAVAUATSH
[A\A]A^A_]
[A\A]A^A_]
=m:4
AWAVAUATSH
|$0H
ffff.
fffff.
ffffff.
!uWH
Lfff.
t Hi
fff.
t!Hi
fff.
^ Li
fffff.
!usH
t!Hi
fff.
u Li
fffff.
^ Li
fffff.
!usH
ffffff.
tPHi
fffff.
t!Hi
fff.
t!Hi
fff.
t#Hi
fffff.
k Hi
fffff.
^ Li
fffff.
!utH
!u#H
ffffff.
ffff.
ffffff.
tPHi
fffff.
t!Hi
fff.
t!Hi
fff.
} Li
fffff.
!upH
t Hi
fff.
t!Hi
fff.
_ Li
t Hi
t!Hi
fff.
t!Hi
fff.
t#Hi
fffff.
_ Li
fffff.
t Hi
!upH
t Hi
fff.
t!Hi
fff.
^ Li
fff.
tpHi
t!Hi
fff.
t!Hi
fff.
u Li
fffff.
^ Li
!uZH
Offffff.
t Hi
fff.
ffffff.
fff.
tpHi
t!Hi
fff.
t!Hi
fff.
t#Hi
fffff.
k Hi
fffff.
!uZH
Offffff.
t Hi
fff.
t!Hi
fff.
^ Li
fff.
tpHi
t!Hi
fff.
t!Hi
fff.
u Li
fffff.
fff.
tpHi
t!Hi
fff.
^ Li
!uZH
Offffff.
t Hi
fff.
t!Hi
fff.
t!Hi
fff.
t#Hi
fffff.
fffff.
!uZH
Offffff.
t Hi
fff.
t!Hi
fff.
^ Li
fff.
tpHi
t!Hi
fff.
t!Hi
fff.
u Li
fffff.
fff.
tpHi
t!Hi
fff.
^ Li
fffff.
!utH
!u#H
ffffff.
t!Hi
fff.
t#Hi
fffff.
k Hi
fffff.
ffffff.
tPHi
fffff.
t!Hi
fff.
^ Li
fffff.
!usH
t!Hi
fff.
u Li
fffff.
ffffff.
tPHi
fffff.
t!Hi
fff.
^ Li
fffff.
!utH
!u#H
ffffff.
t!Hi
fff.
t#Hi
fffff.
^ Li
fffff.
ffffff.
!uWH
Lfff.
t Hi
fff.
t!Hi
fff.
^ Li
fffff.
!usH
t!Hi
fff.
u Li
fffff.
ffffff.
tPHi
fffff.
t!Hi
fff.
^ Li
fffff.
!utH
!u#H
ffffff.
t!Hi
fff.
t#Hi
fffff.
k Hi
fffff.
ffffff.
tPHi
fffff.
t!Hi
fff.
^ Li
fffff.
!utH
!u#H
ffffff.
t!Hi
fff.
u Li
fffff.
ffffff.
!uWH
Lfff.
t Hi
fff.
t!Hi
fff.
^ Li
fffff.
!usH
t!Hi
fff.
t#Hi
fffff.
t'Hi
fff.
fffff.
rIff.
[A\A]A^A_]
t=Hi
t=Hi
t=Hi
t=Hi
t=Hi
t=Hi
t=Hi
t=Hi
t=Hi
t=Hi
t=Hi
t=Hi
t=Hi
tjHi
t<Hi
t<Hi
t<Hi
AWAVSH
[A^A_]
AWAVAUATSH
rKffff.
[A\A]A^A_]
AWAVAUATSH
s(M9
{8L9
s0M9
fff.
spM9
~(L9
8[A\A]A^A_]
8[A\A]A^A_]
AWAVAUATSH
o I9
o0I9
fffff.
o I9
[A\A]A^A_]
[A\A]A^A_]
AWAVAUATSH
[A\A]A^A_]
[A\A]A^A_]
AWAVAUATSH
([A\A]A^A_]
ffff.
fff.
0L;u
([A\A]A^A_]
D$8H
D$8H
AWAVAUATSH
fff.
t$L9
[A\A]A^A_]
[A\A]A^A_]
AWAVAUATSPI
[A\A]A^A_]
w0M9
fffff.
w0M9
w(M9
fff.
[A\A]A^A_]
AWAVATSH
[A\A^A_]
[A\A^A_]
AWAVAUATSPI
ffff.
[A\A]A^A_]
AWAVAUATSPI
ffff.
[A\A]A^A_]
[A\A]A^A_]
AWAVATSI
ffffff.
u	[A\A^A_]
[A\A^A_]
AWAVAUATSH
D$ H
[A\A]A^A_]
[A\A]A^A_]
AWAVAUATSH
ffffff.
fffff.
fff.
~(L9
[A\A]A^A_]
[A\A]A^A_]
AWAVAUATSH
[xL9
[A\A]A^A_]
[A\A]A^A_]
AWAVAUATSH
fff.
ffff.
([A\A]A^A_]H
AWAVAUATSH
[A\A]A^A_]
[A\A]A^A_]
[A\A]A^A_]
[A\A]A^A_]
AWAVAUATSH
{(M9
[A\A]A^A_]
[A\A]A^A_]
[A\A]A^A_]
[A\A]A^A_]
AWAVAUATSPI
fffff.
[A\A]A^A_]
AWAVAUATSH
D$0=
t$(H
t$(I
t$HH
t$(H
fff.
t$ L9
t$(M
t$ H
D$h=
l$`M
l$`I
L$PL
D$8L)
fffff.
L$PM
l$`M
t$8L
fff.
t$XL9
t$`M
\$PI
ffffff.
t$XH
D$pL)
t$pL
@fff.
ffffff.
0rSI
fff.
fff.
ffffff.
fff.
t)L9
ffff.
t*L9
ffffff.
h[A\A]A^A_]
h[A\A]A^A_]
u L9
uXL9
AWAVAUATSPI
fff.
[A\A]A^A_]
AWAVAUATSPI
ffffff.
tZL9
[A\A]A^A_]
AWAVAUATSH
[A\A]A^A_]
AWAVATSI
ffff.
u	[A\A^A_]
[A\A^A_]
AWAVAUATSH
([A\A]A^A_]
([A\A]A^A_]
AWAVAUATSH
8[A\A]A^A_]
AWAVAUATSH
D$ H
d$(H
5-Y3
[A\A]A^A_]
tEM9
t?L9
tEM9
tDM9
tKL9
tLL9
tDM9
t@L9
t?L9
t?L9
tDL9
tDL9
tDL9
t?L9
tIL9
tDLk
t?L9
tDL9
tDL9
tDL9
t?L9
t?L9
tDM9
tEL9
tDM9
AWAVAUATSH
fff.
X[A\A]A^A_]
X[A\A]A^A_]
AVSH
[A^]
[A^]
AWAVAUATSH
=^?3
= 63
=i-3
=#&3
[A\A]A^A_]
AWAVATSI
FhL9
u	[A\A^A_]
[A\A^A_]
AWAVSH
tDLk
([A^A_]
([A^A_]
AWAVAUATSH
H[A\A]A^A_]
\$ M
|$@M
l$HH
t1H9
t)H9
t%I9
H[A\A]A^A_]
AWAVAUATSH
tALk
([A\A]A^A_]
([A\A]A^A_]
AWAVAUATSH
H[A\A]A^A_]
fff.
H[A\A]A^A_]
AWAVAUATSPI
^xLk
[A\A]A^A_]
[A\A]A^A_]
AWAVAUATSH
8[A\A]A^A_]
ffffff.
8[A\A]A^A_]
AWAVAUATSH
H[A\A]A^A_]
fff.
H[A\A]A^A_]
AWAVAUATSPI
[A\A]A^A_]
[A\A]A^A_]
AWAVAUATSH
H[A\A]A^A_]
~&Lk
H[A\A]A^A_]
AWAVAUATSH
H[A\A]A^A_]
fff.
t!H9
t!H9
t!H9
H[A\A]A^A_]
AWAVAUATSH
H[A\A]A^A_]
fff.
H[A\A]A^A_]
AWAVSPH
[A^A_]
[A^A_]
AWAVAUATSH
8[A\A]A^A_]
ffffff.
8[A\A]A^A_]
AWAVAUATSH
([A\A]A^A_]
([A\A]A^A_]
AWAVAUATSH
8[A\A]A^A_]
ffffff.
8[A\A]A^A_]
AWAVAUATSH
([A\A]A^A_]
([A\A]A^A_]
AWAVAUATSH
[A\A]A^A_]
AWAVAUATSH
[A\A]A^A_]
AWAVAUATSH
fff.
,$Li
EXL9
t"L9
t"L9
t$XH
t$XL9
|$`M
\$PI
fff.
t$XL
t$pH
G8L9
_0Li
[A\A]A^A_]
[A\A]A^A_]
AVSH
s0I9
[A^]
[A^]
[A^]
AWAVAUATSH
[A\A]A^A_]
AVSH
's"H
[A^]
AWAVSH
[A^A_]
AWAVAUATSH
C8H9
s}L9
8[A\A]A^A_]
AWAVAUATSH
tlff.
y0Hi
tlffff.
[A\A]A^A_]
AVSH
[A^]
[A^]
:u*H
AVSH
@u"H
[A^]
AWAVAUATSH
y0Hi
tlffff.
[A\A]A^A_]
AVSH
+s"H
[A^]
AWAVAUATSH
tlff.
y0Hi
tlffff.
[A\A]A^A_]
AWAVAUATSH
H[A\A]A^A_]
t-H9
t`H9
	uVH
t)H9
H[A\A]A^A_]
AWAVAUATSH
[A\A]A^A_]
t1L9
t1L9
t1L9
t1L9
t*L9
t1L9
AWAVAUATSH
57{2
-ffffff.
;ffff.
ffffff.
|aH9
[A\A]A^A_]
AWAVAUATSH
[A\A]A^A_]
t5L9
=;`2
AWAVAUATSH
H[A\A]A^A_]
AWAVAUATSH
IkFxXH
[A\A]A^A_]
56<2
AWAVAUATSH
u%fA
X[A\A]A^A_]
AWAVAUATSH
H[A\A]A^A_]
AWAVAUATSH
57E2
[A\A]A^A_]
AWAVAUATSH
<@E1
ffffff.
x[A\A]A^A_]
AWAVAUATSH
x[A\A]A^A_]
AWAVATSH
p[A\A^A_]
AWAVAUATSH
H[A\A]A^A_]
AWAVAUATSH
[A\A]A^A_]
AWAVSH
h[A^A_]
h[A^A_]
AWAVATSH
[A\A^A_]
[A\A^A_]
AWAVAUATSH
u(fA
[A\A]A^A_]
AWAVAUATSH
H[A\A]A^A_]
AWAVAUATSH
8[A\A]A^A_]
AWAVAUATSH
x[A\A]A^A_]
AWAVAUATSH
H[A\A]A^A_]
AWAVATSH
#w-H
p[A\A^A_]
AWAVAUATSH
H[A\A]A^A_]
AWAVAUATSH
H[A\A]A^A_]
AWAVAUATSH
H[A\A]A^A_]
AWAVAUATSH
H[A\A]A^A_]
AWAVAUATSH
[A\A]A^A_]
AWAVAUATSH
x[A\A]A^A_]
AWAVAUATSH
8[A\A]A^A_]
AWAVAUATSH
[A\A]A^A_]
[A\A]A^A_]
AWAVAUATSH
H[A\A]A^A_]
AWAVAUATSH
8[A\A]A^A_]
8[A\A]A^A_]
AWAVAUATSH
u%fA
h[A\A]A^A_]
AWAVAUATSH
H[A\A]A^A_]
AWAVSH
x[A^A_]
AWAVAUATSH
[A\A]A^A_]
-qk1
[A\A]A^A_]
AWAVAUATSH
8[A\A]A^A_]
AWAVAUATSH
x[A\A]A^A_]
AWAVSH
[A^A_]
[A^A_]
AWAVAUATSH
X[A\A]A^A_]
AWAVATSH
P[A\A^A_]
AWAVSH
8[A^A_]
AWAVAUATSH
$@E1
h[A\A]A^A_]
AWAVAUATSH
8[A\A]A^A_]
AWAVSH
8[A^A_]
AWAVATSH
@[A\A^A_]
AWAVATSH
@[A\A^A_]
AWAVSH
h[A^A_]
AWAVSH
h[A^A_]
AWAVAUATSH
8[A\A]A^A_]
AWAVAUATSH
$@E1
x[A\A]A^A_]
AWAVATSH
@[A\A^A_]
AWAVAUATSH
x[A\A]A^A_]
AWAVAUATSH
t#H9
X[A\A]A^A_]
AWAVATSH
@[A\A^A_]
AWAVAUATSH
fff.
H[A\A]A^A_]
AWAVSH
x[A^A_]
AWAVATSH
[A\A^A_]
AWAVAUATSH
8[A\A]A^A_]
AWAVATSH
P[A\A^A_]
AWAVAUATSH
8[A\A]A^A_]
AWAVSH
X[A^A_]
AWAVATSH
@[A\A^A_]
AWAVATSH
P[A\A^A_]
AWAVAUATSH
8[A\A]A^A_]
AWAVATSH
@[A\A^A_]
AWAVAUATSH
H[A\A]A^A_]
AWAVAUATSH
h[A\A]A^A_]
AWAVSH
[A^A_]
AWAVAUATSH
H[A\A]A^A_]
AWAVATSH
@[A\A^A_]
AWAVATSH
@[A\A^A_]
AWAVSH
[A^A_]
AWAVAUATSH
H[A\A]A^A_]
AWAVATSH
P[A\A^A_]
AWAVATSH
@[A\A^A_]
AWAVSH
h[A^A_]
AWAVSH
x[A^A_]
AWAVSH
[A^A_]
AWAVAUATSH
H[A\A]A^A_]
AWAVATSH
@[A\A^A_]
AWAVATSH
p[A\A^A_]
AWAVATSH
p[A\A^A_]
AWAVATSH
p[A\A^A_]
AWAVSH
x[A^A_]
AWAVSH
[A^A_]
AWAVSH
x[A^A_]
AWAVSH
[A^A_]
AWAVATSH
[A\A^A_]
AWAVAUATSH
H[A\A]A^A_]
AWAVATSH
@[A\A^A_]
AWAVATSH
[A\A^A_]
AWAVAUATSH
H[A\A]A^A_]
AWAVSH
8[A^A_]
AWAVATSH
@[A\A^A_]
AWAVATSH
@[A\A^A_]
AWAVSH
h[A^A_]
AWAVSH
h[A^A_]
AWAVSH
h[A^A_]
AWAVSH
[A^A_]
AWAVAUATSH
h[A\A]A^A_]
AWAVAUATSH
h[A\A]A^A_]
AWAVAUATSH
h[A\A]A^A_]
AWAVAUATSH
h[A\A]A^A_]
AWAVAUATSH
h[A\A]A^A_]
AWAVATSH
p[A\A^A_]
AWAVATSH
p[A\A^A_]
AWAVAUATSH
H[A\A]A^A_]
AWAVAUATSH
x[A\A]A^A_]
AWAVSH
h[A^A_]
AWAVATSH
p[A\A^A_]
AWAVAUATSH
h[A\A]A^A_]
AWAVATSH
p[A\A^A_]
AWAVAUATSH
h[A\A]A^A_]
AWAVATSH
p[A\A^A_]
AWAVAUATSH
h[A\A]A^A_]
AWAVATSH
[A\A^A_]
AWAVATSH
p[A\A^A_]
AWAVSH
h[A^A_]
AWAVSH
[A^A_]
AWAVAUATSH
=Zd0
x[A\A]A^A_]
AWAVATSH
@[A\A^A_]
AWAVAUATSH
$@E1
x[A\A]A^A_]
AWAVAUATSH
H[A\A]A^A_]
AWAVATSH
@[A\A^A_]
AWAVATSH
@[A\A^A_]
AWAVAUATSH
fff.
X[A\A]A^A_]
AWAVAUATSH
X[A\A]A^A_]
AWAVSH
x[A^A_]
AWAVAUATSH
-zQ0
x[A\A]A^A_]
AWAVAUATSH
$@E1
h[A\A]A^A_]
AWAVAUATSH
8[A\A]A^A_]
AWAVATSH
@[A\A^A_]
AWAVATSH
p[A\A^A_]
AWAVSH
h[A^A_]
AWAVSH
h[A^A_]
AWAVSH
x[A^A_]
AWAVAUATSH
8[A\A]A^A_]
AWAVSH
8[A^A_]
AWAVATSH
[A\A^A_]
AWAVSH
[A^A_]
AWAVAUATSH
%=80
H[A\A]A^A_]
AWAVATSH
@[A\A^A_]
AWAVSH
h[A^A_]
AWAVATSH
[A\A^A_]
AWAVATSH
p[A\A^A_]
AWAVSH
h[A^A_]
AWAVSH
h[A^A_]
AWAVSH
h[A^A_]
AWAVSH
x[A^A_]
AWAVAUATSH
x[A\A]A^A_]
AWAVAUATSH
H[A\A]A^A_]
AWAVATSH
@[A\A^A_]
AWAVSH
[A^A_]
AWAVAUATSH
8[A\A]A^A_]
AWAVATSH
@[A\A^A_]
AWAVATSH
@[A\A^A_]
AWAVSH
[A^A_]
AWAVAUATSH
[A\A]A^A_]
AWAVATSH
[A\A^A_]
[A\A^A_]
AWAVAUATSH
h[A\A]A^A_]
AWAVATSH
p[A\A^A_]
AWAVAUATSH
[A\A]A^A_]
AWAVSH
x[A^A_]
AWAVSH
x[A^A_]
AWAVAUATSH
8[A\A]A^A_]
AWAVATSH
@[A\A^A_]
AWAVAUATSH
[A\A]A^A_]
AWAVAUATSH
t#H9
X[A\A]A^A_]
AWAVATSH
P[A\A^A_]
AWAVATSH
[A\A^A_]
AWAVATSH
p[A\A^A_]
AWAVATSH
@[A\A^A_]
AWAVATSH
[A\A^A_]
AWAVATSH
[A\A^A_]
AWAVATSH
@[A\A^A_]
AWAVSH
8[A^A_]
AWAVAUATSH
$@E1
h[A\A]A^A_]
AWAVAUATSH
8[A\A]A^A_]
AWAVSH
X[A^A_]
AWAVAUATSH
t#H9
H[A\A]A^A_]
AWAVATSH
@[A\A^A_]
AWAVSH
x[A^A_]
AWAVATSH
p[A\A^A_]
AWAVAUATSH
fff.
[A\A]A^A_]
AWAVAUATSH
X[A\A]A^A_]
AWAVATSH
@[A\A^A_]
AWAVATSH
@[A\A^A_]
AWAVATSH
p[A\A^A_]
AWAVATSH
@[A\A^A_]
AWAVATSH
[A\A^A_]
AWAVAUATSH
[A\A]A^A_]
AWAVAUATSH
x[A\A]A^A_]
AWAVATSH
[A\A^A_]
AWAVAUATSH
[A\A]A^A_]
AWAVAUATSH
,@E1
H[A\A]A^A_]
AWAVSH
x[A^A_]
AWAVAUATSH
tUH9
t]M9
[A\A]A^A_]
AWAVSPH
[A^A_]
[A^A_]
AWAVAUATSPH
rDM;o
[A\A]A^A_]
AVSH
[A^]
AWAVAUATSH
T$ A
l$HM
l$@M
l$8M
l$0M
l$(M
l$ M
\$0A
T$ A
[A\A]A^A_]
AWAVAUATSH
ffff.
tML9
3ffff.
([A\A]A^A_]
AWAVAUATSH
[A\A]A^A_]
AWAVSPH
[A^A_]
[A^A_]
[A^A_]
AWAVATSI
u	[A\A^A_]
[A\A^A_]
AWAVAUATSH
[A\A]A^A_]
5*u/
AWAVAUATSH
L5$H
D5$H
ffff.
ffff.
s M9
tKM9
ffffff.
k(M9
u M9
s(M9
tDL9
[A\A]A^A_]
t#L9
fff.
t*L9
ffffff.
t,L9
k(M9
u M9
s(M9
t^L9
t+L9
tKM9
~ M9
s M9
!u|H
!u5H
tML9
tHHi
t+L9
t&Hi
!u|H
!u5H
t<L9
t7Hi
AWAVAUATSH
fffff.
r}L;
ffffff.
ffff.
t L9
t L9
t L9
fff.
t L9
[A\A]A^A_]
fffff.
fff.
fffff.
AWAVAUATSPI
[A\A]A^A_]
[A\A]A^A_]
AWAVAUATSH
[A\A]A^A_]
[A\A]A^A_]
AVSH
[A^]
AWAVAUATSH
[A\A]A^A_]
AVSH
[A^]
AWAVATSH
tKL9
P[A\A^A_]
AVSH
[A^]
AWAVAUATSH
fffff.
t#L9
t#L9
t M9
t M9
[A\A]A^A_]
t)L9
\$ H
t M9
!u}I
!u5I
tDL9
t?Hi
t"L9
t%L9
!u}I
taL9
t\Hi
!u	I
tDL9
t?Hi
t#L9
AVSH
[A^]
AWAVAUATSH
T? I
fffff.
tZL9
[A\A]A^A_]
AWAVAUATSH
X[A\A]A^A_]
AVSH
[A^]
AWAVAUATSH
\$(I
\$ I
T$ A
[A\A]A^A_]
AWAVAUATSH
[A\A]A^A_]
AVSH
[A^]
AWAVAUATSH
h[A\A]A^A_]
AWAVSH
[A^A_]
AWAVAUATSH
t#M9
t#M9
l$ M
t=M9
D$ H
l$ M
t#M9
l$ M
[A\A]A^A_]
l$ M
tkL9
t#L9
t#L9
t#L9
!u|H
!u5H
t<L9
t7Hi
t%L9
!u|H
t`L9
t[Hi
!u	H
l$HM
l$@M
l$8M
l$0M
l$(M
l$ M
t<L9
t7Hi
AWAVATSH
[A\A^A_]
AWAVAUATSH
c M9
tNL9
ffffff.
ffffff.
[A\A]A^A_]
t L9
t#L9
c M9
c M9
tNL9
t#L9
!u|H
!u5H
tDL9
t?Hi
t"L9
t%L9
!u|H
t`L9
t[Hi
!u	H
t$HM
t$@M
t$8M
t$0M
t$(M
t$ M
tDL9
t?Hi
t#L9
AWAVAUATSH
tgE1
t@H9
2fff.
([A\A]A^A_]
AWAVAUATSPH
rGM;l$
[A\A]A^A_]
AVSH
[A^]
AWAVAUATSH
tpI9
rWH;M
8[A\A]A^A_]
AWAVSH
[A^A_]
AWAVAUATSH
ffffff.
\00B
T0 B
[A\A]A^A_]
AWAVAUATSH
|=@H
\=0C
T= C
[A\A]A^A_]
AVSH
[A^]
AWAVAUATSH
[A\A]A^A_]
t"L9
AWAVAUATSH
ffffff.
fffff.
[A\A]A^A_]
AWAVSPH
[A^A_]
[A^A_]
AWAVAUATSH
x[A\A]A^A_]
=Bj.
AVSH
[A^]
AWAVAUATSH
tpI9
rWH;M
=nf.
8[A\A]A^A_]
AVSH
[A^]
AVSH
[A^]
AWAVAUATSH
[A\A]A^A_]
fff.
AWAVAUATSH
8[A\A]A^A_]
AVSH
[A^]
AWAVATSH
 [A\A^A_]
AWAVAUATSH
ffffff.
[A\A]A^A_]
ffffff.
t9M9
AWAVAUATSH
X[A\A]A^A_]
AVSH
[A^]
AWAVATSH
 [A\A^A_]
AWAVAUATSH
[A\A]A^A_]
AWAVAUATSH
M;|$
h[A\A]A^A_]
=>S.
AVSH
[A^]
AVSH
[A^]
AWAVAUATSH
tpI9
rWH;M
=NO.
8[A\A]A^A_]
AWAVAUATSH
[A\A]A^A_]
AWAVAUATSH
rzM;|$
H[A\A]A^A_]
=TJ.
AVSH
[A^]
AWAVAUATSH
tpI9
rWH;M
8[A\A]A^A_]
AWAVAUATSH
tpI9
rWH;M
8[A\A]A^A_]
AWAVAUATSH
tpI9
rWH;M
=~E.
8[A\A]A^A_]
AWAVAUATSH
tpI9
rWH;M
8[A\A]A^A_]
AVSH
[A^]
AWAVAUATSH
\80B
T8 B
[A\A]A^A_]
AWAVATSH
tGL9
tBHk
P[A\A^A_]
AWAVAUATSPI
t*L9
ffffff.
[A\A]A^A_]
[A\A]A^A_]
AWAVATSI
t	[A\A^A_]
[A\A^A_]
AWAVAUATSH
[A\A]A^A_]
AVSH
[A^]
AWAVAUATSH
[A\A]A^A_]
5;".
AWAVAUATSH
D$PH
D$HH
[A\A]A^A_]
AWAVSH
[A^A_]
AWAVAUATSH
\80B
T8 B
[A\A]A^A_]
AWAVAUATSH
[A\A]A^A_]
AWAVAUATSH
tQM9
[A\A]A^A_]
(L;e
AWAVAUATSH
rqM;|$
X[A\A]A^A_]
=u!.
AVSH
[A^]
AWAVATSH
[A\A^A_]
AWAVAUATSH
[A\A]A^A_]
t M9
AWAVAUATSH
tpI9
rWH;M
8[A\A]A^A_]
AVSH
[A^]
AWAVAUATSH
[A\A]A^A_]
F Hk
t#L9
AWAVAUATSH
[A\A]A^A_]
AWAVATSH
tGL9
tBHk
P[A\A^A_]
AWAVAUATSH
t*H9
ffffff.
t M9
([A\A]A^A_]
([A\A]A^A_]
AWAVAUATSH
t*L9
ffffff.
[A\A]A^A_]
[A\A]A^A_]
AWAVAUATSH
x[A\A]A^A_]
t%L9m
AVSH
[A^]
AWAVAUATSH
[A\A]A^A_]
t L9
AWAVAUATSH
[A\A]A^A_]
ffffff.
AWAVAUATSH
\ 0B
T  B
[A\A]A^A_]
ffff.
t8M9
AWAVAUATSH
[A\A]A^A_]
AVSH
[A^]
AWAVAUATSH
ffff.
t'L9
fff.
tGL9
[A\A]A^A_]
~ M9
t*L9
ffffff.
AWAVAUATSH
\80B
T8 B
[A\A]A^A_]
AWAVAUATSH
tMM9
[A\A]A^A_]
AWAVAUATSPH
rGM;l$
[A\A]A^A_]
AVSH
[A^]
AWAVAUATSH
[A\A]A^A_]
ffff.
](L9
c M9
](L9
tCL9
AWAVAUATSH
[A\A]A^A_]
~ M9
AWAVATSH
s(M9
~ M9
s(M9
[A\A^A_]
[A\A^A_]
AWAVAUATSH
[A\A]A^A_]
AVSH
[A^]
AWAVATSH
[A\A^A_]
AWAVAUATSH
f I9
[A\A]A^A_]
](L9
s M9
n I9
s M9
s M9
](L9
AWAVAUATSH
[A\A]A^A_]
AWAVAUATSH
yfffff.
[A\A]A^A_]
X(f.
tMM9
tCL9
AWAVATSH
[A\A^A_]
tOI9
AWAVSPH
[A^A_]
[A^A_]
AWAVAUATSH
[A\A]A^A_]
AVSH
[A^]
AWAVAUATSH
[A\A]A^A_]
tNL9
AWAVAUATSH
[A\A]A^A_]
AWAVAUATSH
ffff.
off.
[A\A]A^A_]
AWAVATSH
[A\A^A_]
AWAVATSH
{ M9
s8M9
[A\A^A_]
[A\A^A_]
AWAVAUATSH
[A\A]A^A_]
AVSH
[A^]
AWAVAUATSH
[A\A]A^A_]
$$M9
[ L9
AWAVAUATSH
ffff.
off.
[A\A]A^A_]
AWAVAUATSH
\$0A
T$ A
[A\A]A^A_]
fff.
t#L9
AWAVSPI
fffff.
[A^A_]
AWAVAUATSH
t&f.
[A\A]A^A_]
AWAVAUATSH
[A\A]A^A_]
{ M9
AWAVSH
[A^A_]
AWAVAUATSH
[A\A]A^A_]
s M9
AWAVAUATSH
t3E1
[A\A]A^A_]
AVSH
`[A^]
AWAVAUATSH
X[A\A]A^A_]
AVSH
4	L9
[A^]
AWAVAUATSH
_(E1
D$ L
[A\A]A^A_]
L$ H
!u|H
!u5H
D$(L9
L$0H
\$ Li
!u|H
!u5H
D$(H
t!L9
@(L9
` Hi
L$ H
!u|H
!u5H
D$(L9
L$0H
\$ Li
!u|H
t`L9
t[Hi
!u	H
D$(H
t!L9
t%L9
t$L9
t;L9
t6Hi
D$(H
t;L9
t6Hi
D$(H
t!L9
AWAVAUATSH
fff.
[A\A]A^A_]
AWAVAUATSH
[A\A]A^A_]
AWAVAUATSH
ffffff.
T% H
t%0H
t% K
T%0H
[A\A]A^A_]
ffff.
{ff.
tXL9
tSHi
;ff.
h ffff.
!u@I
t$L9
tKL9
tFHi
t)L9
t$Hi
AWAVAUATSH
[A\A]A^A_]
l$(L
t$@I
D$HI
l$(H
D$8I
|$@H
D$ I
D$0H
t#L9
D$0Hk
L$ H
t!L9
AWAVATSH
[A\A^A_]
AWAVAUATSH
D$ M
D$0A
D$*I
|$0H
t$HH
D$XI
|$`H
D$8L
D$@H
D$<M
t$@L
|$XH
D$xA
D$)M
t$0L
t$HH
D$XI
|$`H
|$xH
t$0I
D$8A
D$:M
t$@L
t$XH
D$hI
|$pH
t$0H
|$HH
t$`H
D$pI
|$xH
t$0I
D$8H
D$@A
D$0I
|$8H
T$,A
D$0M
t$8L
t$PH
D$`I
|$hH
D$)H
D$<I
D$XA
D$8H
D$PA
D$8H
D$PA
t$XL
t$pH
[A\A]A^A_]
D$PH
t L9
D$PHk
D$PH
D$PHk
D$`H
D$`Hk
D$hH
D$hHk
D$XH
D$XHk
D$xH
t L9
D$xHk
D$8L9
L$@H
\$0L
D$8H
D$8H
L$@H
\$0L
D$8H
D$HH
L$PH
\$@L
D$HH
s I9
D$PH
L$XH
\$HL
D$PH
D$@H
L$HH
\$8L
fffff.
D$@H
D$`L9
L$hH
\$XL
D$`H
t!L9
D$8H
L$@H
\$0L
D$8H
AWAVAUATSH
fff.
0L9m
([A\A]A^A_]
AWAVAUATSH
ffffff.
-ffffff.
[A\A]A^A_]
AWAVATSH
[A\A^A_]
AWAVAUATSH
$	L9
ffffff.
([A\A]A^A_]
AWAVAUATSH
H[A\A]A^A_]
ffffff.
AWAVAUATSH
$	L9
ffff.
|> I
[A\A]A^A_]
t)L9
ffff.
AWAVAUATSH
$6L9
\,0C
T, C
x[A\A]A^A_]
AWAVAUATSH
t#(H
fff.
t#(H
\%0C
T% C
[A\A]A^A_]
AWAVAUATSH
D$(H
|$(L
|$0H
H[A\A]A^A_]
D$ H
AWAVAUATSH
$6L9
[A\A]A^A_]
AWAVAUATSH
tsE1
[A\A]A^A_]
D$ H
\$(L9
s M9
\$(L9
AWAVAUATSH
x[A\A]A^A_]
EPHk
fffff.
c I9
](L9
c M9
](L9
AVSH
[A^]
AWAVAUATSH
fffff.
t'8L
t'(H
t'8L
t'(H
t'HH
D'XH
\ 0B
T  B
[A\A]A^A_]
X(ff.
tMM9
t!L9
AWAVAUATSH
$	L9
&fff.
]fff.
,ff.
\70C
T7 C
[A\A]A^A_]
AWAVAUATSH
$	L9
fffff.
[A\A]A^A_]
AWAVAUATSH
|$0H
D$PI
l$0H
D$@I
|$HH
D$`I
[A\A]A^A_]
c M9
D$8H
t L9
D$8Hk
D$ L9
L$(H
D$ H
t!L9
s M9
AWAVAUATSH
$	L9
4@E1
Xfff.
*fffff.
[A\A]A^A_]
AWAVAUATSH
[A\A]A^A_]
c M9
t L9
E8Hk
E L9
ffff.
t!L9
c M9
AWAVAUATSH
x[A\A]A^A_]
C0L9
h(Hi
E(L9
} Hi
G(L9
_ Li
!u|H
t`L9
t[Hi
!u	H
!u|H
t`L9
t[Hi
!u	H
!u	I
G(L9
_ Li
!u|H
t`L9
t[Hi
!u	H
!u|H
t`L9
t[Hi
!u	H
!u	I
!u	I
t!L9
tqL9
tlHi
t#L9
tbL9
t]Hi
t|Hi
t_L9
tZHi
t!L9
AWAVAUATSH
[A\A]A^A_]
!u|H
t`L9
t[Hi
!u	H
F(L9
n Hi
E(L9
] Li
!u|H
t`L9
t[Hi
!u	H
!u|H
t`L9
t[Hi
!u	H
!u	I
E(L9
] Li
!u|H
t`L9
t[Hi
!u	H
!uYH
t=L9
t8Hi
!u	H
!u	I
!u	I
t%L9
F(L9
n Hi
E(L9
] Li
!u[H
!u	H
!u|H
t`L9
t[Hi
!u	H
!u	I
E(L9
] Li
!u|H
t`L9
t[Hi
!u	H
!u|H
t`L9
t[Hi
!u	H
!u	I
!u	I
tSL9
tNHi
tRL9
tMHi
t>L9
t9Hi
t_L9
tZHi
AWAVATSH
[A\A^A_]
AWAVSH
[A^A_]
AWAVAUATSH
[A\A]A^A_]
tnL9
tiHi
fffff.
t<L9
t7Hi
AWAVAUATSH
$6L9
ffff.
\>0C
T> C
[A\A]A^A_]
AWAVAUATSH
[A\A]A^A_]
AWAVAUATSH
tKE1
8[A\A]A^A_]
AWAVSH
[A^A_]
AWAVAUATSH
$	L9
[A\A]A^A_]
AWAVAUATSH
t~E1
T= H
T> I
8[A\A]A^A_]
AWAVAUATSH
[A\A]A^A_]
AVSH
[A^]
[A^]
[A^]
AWAVAUATSH
[A\A]A^A_]
AWAVAUATSH
[A\A]A^A_]
AWAVATSH
H;s tKH
[A\A^A_]
AWAVAUATSH
[A\A]A^A_]
AVSH
[A^]
AWAVAUATSH
{ M9
l$PM
l$HM
l$@M
l$8M
l$0M
l$(M
l$ M
[A\A]A^A_]
C L9
C L9
l$PM
l$HM
l$@M
l$8M
l$0M
l$(M
l$ M
!u|H
!u5H
t<L9
t7Hi
t%L9
!u|H
t`L9
t[Hi
!u	H
t<L9
t7Hi
AWAVAUATSH
[A\A]A^A_]
c M9
AWAVAUATSH
[A\A]A^A_]
AWAVAUATSH
[A\A]A^A_]
AWAVATSH
H;s tKH
[A\A^A_]
AWAVAUATSH
[A\A]A^A_]
AVSH
[A^]
AWAVAUATSH
tNL9
ffffff.
t)L9
ffff.
t#L9
s M9
l$PM
l$HM
l$@M
l$8M
l$0M
l$(M
l$ M
[A\A]A^A_]
5.h,
tNL9
ffffff.
t*L9
ffffff.
t#L9
{ M9
{ M9
l$PM
l$HM
l$@M
l$8M
l$0M
l$(M
l$ M
!u|H
!u5H
tDL9
t?Hi
t"L9
!u|H
t`L9
t[Hi
!u	H
tDL9
t?Hi
t#L9
AWAVAUATSH
[A\A]A^A_]
[A\A]A^A_]
AWAVAUATSH
t~L9
t1L9
G0L9
t L9
!u]I
t'L9
t"Hi
t!L9
t1L9
tPM9
F0L9
^(Li
!u|H
!u5H
F0L9
^(Li
fff.
toL9
tjHi
t<L9
t7Hi
tSM9
C0L9
!u|H
!u5H
G(L9
_ Li
!u|H
!u5H
F(L9
!u|H
!u5H
G(L9
_ Li
!u|H
!u5H
G(L9
w Hi
!u|H
!u5H
G(L9
_ Hi
!u[H
F(L9
~ Hi
!u|H
!u5H
G(L9
_ Li
!u|H
!u5H
tSM9
F0L9
~(Hi
!u|H
!u5H
G(L9
_ Li
!u|H
!u5H
C(L9
{ Hi
!u|H
!u5H
G(L9
_ Li
!u|H
!u5H
G(L9
G Hi
!u|H
!u5H
G(L9
_ Li
!u|H
!u5H
t.L9
t)Hi
A(L9
!u|H
!u5H
G(L9
_ Li
!u|H
!u5H
t.L9
t)Hi
tSM9
F0L9
^(Li
!uYH
!u5H
G(L9
_ Li
!u[H
F(L9
~ Hi
!uYH
!u5H
G(L9
_ Li
!u[H
C(L9
s Hi
!u|H
!u5H
G(L9
_ Li
!u|H
!u5H
F(L9
~ Hi
!uYH
!u5H
G(L9
_ Li
!u[H
F0L9
^(Li
!u|H
!u5H
F0L9
^(Li
!u|H
!u5H
[A\A]A^A_]
t<L9
t7Hi
tTL9
tOHi
t,L9
t'Hi
tML9
tHHi
t!L9
tML9
tHHi
t!L9
tML9
tHHi
t!L9
t#L9
F0L9
^(Li
!u|H
!u5H
t<L9
t7Hi
AWAVAUATSH
D$ =
I;D$
{(Li
!uZH
Offffff.
t Hi
fff.
t!Hi
fff.
_ Li
!uZH
Offffff.
t Hi
fff.
t!Hi
fff.
I;D$
8[A\A]A^A_]
8[A\A]A^A_]
trHi
tiHi
tAHi
t=Hi
AVSH
`[A^]
AWAVAUATSH
H;F t
h[A\A]A^A_]
G0L9
_(Li
!u|H
t`L9
t[Hi
!u	H
t<L9
t7Hi
AWAVAUATSH
rvM;w
X[A\A]A^A_]
G0L9
_(Li
tnL9
tiHi
fffff.
t<L9
t7Hi
AVSH
[A^]
AWAVAUATSH
F0L9
^(Li
!uCH
t'L9
t"Hi
fffff.
[A\A]A^A_]
t<L9
t7Hi
AWAVAUATSH
tsL9
[A\A]A^A_]
F0L9
^(Li
C(L9
s Hi
F(L9
^ Li
!u|H
t`L9
t[Hi
!u	H
!u|H
t`L9
t[Hi
!u	H
!u	I
F(L9
^ Li
!u|H
t`L9
t[Hi
!u	H
!u|H
t`L9
t[Hi
!u	H
!u	I
!u	H
tSM9
F0L9
^(Li
fff.
toL9
tjHi
t<L9
t7Hi
tRL9
tMHi
t2L9
t-Hi
t?L9
t:Hi
!u~I
!u6I
t!L9
@(L9
h Hi
!u~I
!u6I
t!L9
t!L9
@(L9
!u~I
!u6I
t!L9
@(L9
h Hi
!u~I
!u6I
t!L9
t!L9
tEL9
t@Hi
tEL9
t@Hi
t!L9
tEL9
t@Hi
tEL9
t@Hi
t!L9
t!L9
t%L9
F0L9
n(Hi
!u}I
!u5I
E(L9
} Hi
!u}I
!u5I
toL9
tjHi
tfL9
taHi
tDL9
t?Hi
tEL9
t@Hi
t#L9
AWAVAUATSH
[A\A]A^A_]
AWAVAUATSH
L$ H
l$ M
G0L9
_(Li
tnL9
tiHi
fffff.
l$ M
G0L9
_(Li
!u|H
t`L9
t[Hi
!u	H
G0L9
_(Li
!u|H
t`L9
t[Hi
!u	H
[A\A]A^A_]
G0L9
_(Li
!u|H
!u5H
l$ M
G0L9
_(Li
!u|H
!u5H
G0L9
_(Li
 ffffff.
tnL9
tiHi
fffff.
tRL9
tMHi
t1L9
t,Hi
AWAVAUATSH
L$ H
!uZH
Offffff.
t Hi
fff.
D$(H
L$0H
\$ Li
!uZH
Offffff.
t Hi
fff.
D$(L
([A\A]A^A_]
([A\A]A^A_]
trHi
tkHi
tCHi
t@Hi
D$(H
AWAVAUATSH
X[A\A]A^A_]
G0L9
_(Li
tnL9
tiHi
fffff.
t<L9
t7Hi
AWAVSH
X[A^A_]
AWAVAUATSH
tlff.
y0Hi
tlffff.
[A\A]A^A_]
AVSH
4s"H
[A^]
AWAVAUATSH
tlff.
y0Hi
tlffff.
[A\A]A^A_]
AVSH
1s"H
[A^]
AWAVAUATSH
tlff.
y0Hi
tlffff.
[A\A]A^A_]
AVSH
4s"H
[A^]
AWAVAUATSH
tlff.
y0Hi
tlffff.
[A\A]A^A_]
AVSH
[A^]
AWAVAUATSH
tlff.
y0Hi
tlffff.
[A\A]A^A_]
uespemosL1
modnarodH1
arenegylL1
setybdetI1
AVSH
[A^]
AWAVATSH
P[A\A^A_]
AVSH
[A^]
[A^]
AWAVAUATSH
([A\A]A^A_]
AWAVAUATSH
(ffffff.
([A\A]A^A_]
AWAVAUATSH
<$M;|$
ffff.
8rlib
<$M;|$
[A\A]A^A_]
AWAVAUATSH
T$ A
[A\A]A^A_]
AVSH
[A^]
AWAVAUATSH
I;D$
\$(H
I;D$
x[A\A]A^A_]
AVSH
@[A^]
AWAVATSH
N8ffff.
F(9N
[A\A^A_]
AWAVAUATSH
6fff.
[A\A]A^A_]
AWAVATSH
5$@+
5Q?+
[A\A^A_]
=.p+
AWAVATSH
5-5+
[A\A^A_]
AWAVATSH
5	/+
[A\A^A_]
=Ta+
AWAVAUATSH
t,L9
[A\A]A^A_]
=:\+
AVSH
[A^]
AVSH
0[A^]
AWAVAUATSH
[A\A]A^A_]
AWAVSH
AWAVATSH
[A\A^A_]
AWAVAUATSH
D$PH
T$ A
|$PM
|$HM
|$@M
|$8M
|$0M
|$(M
|$ M
fffff.
L,$H
ffff.
D,$H
fff.
fff.
tnL9
tiHi
fffff.
|$HM
|$@M
|$8M
|$0M
|$(M
D$`A
s M9
(fffff.
tKM9
k(M9
u M9
s(M9
|$ M
tDL9
\$0A
T$ A
[A\A]A^A_]
t*L9
ffffff.
t*L9
ffffff.
tHL9
tCHi
t+L9
t&Hi
!u|H
t`L9
t[Hi
!u	H
|$HM
|$@M
|$8M
|$0M
k(M9
u M9
s(M9
\$ H
t^L9
t+L9
D$`I
tKM9
|$ M
4$M9
f M9
s M9
t,L9
t5L9
AWAVAUATSH
fffff.
r}L;
ffffff.
ffff.
t L9
t L9
t L9
fff.
t L9
[A\A]A^A_]
fffff.
fff.
fffff.
AWAVAUATSH
x[A\A]A^A_]
AWAVAUATSH
T$ A
l$hM
l$`M
l$XM
l$PM
l$HM
l$@M
l$8M
l$0M
l$(M
l$ M
tnL9
tiHi
fffff.
~ I9
ffffff.
t&L9
t&L9
t L9
t L9
\$0A
T$ A
[A\A]A^A_]
tDL9
t?Hi
t#L9
!u|H
t`L9
t[Hi
!u	H
t)L9
t-L9
t L9
AVSH
[A^]
AWAVAUATSH
T< M
[A\A]A^A_]
ffffff.
D$ H
AWAVAUATSH
Nffffff.
[A\A]A^A_]
AWAVAUATSPI
[A\A]A^A_]
AWAVAUATSH
t L9
l$ M
t L9
t L9
fff.
!uDH
[A\A]A^A_]
tDL9
t?Hi
t#L9
l$ M
t L9
t L9
!u|H
!u5H
t L9
t L9
AWAVATSH
[A\A^A_]
AWAVAUATSH
 fff.
tnL9
tiHi
fffff.
k M9
ffffff.
tNL9
[A\A]A^A_]
t L9
t#L9
tDL9
t?Hi
t#L9
!u|H
t`L9
t[Hi
!u	H
{ M9
{ M9
tNL9
t#L9
AWAVAUATSH
tgE1
t@H9
2fff.
([A\A]A^A_]
AWAVAUATSH
tpI9
rWH;M
8[A\A]A^A_]
AWAVATSH
[A\A^A_]
AWAVAUATSH
ffffff.
\00B
T0 B
[A\A]A^A_]
AWAVAUATSH
[A\A]A^A_]
t"L9
AWAVAUATSH
ffffff.
fffff.
[A\A]A^A_]
AWAVAUATSH
T$ A
l$HM
l$@M
l$8M
l$0M
l$(M
l$ M
\$0A
T$ A
[A\A]A^A_]
AWAVAUATSH
ffff.
tML9
3ffff.
([A\A]A^A_]
AWAVAUATSH
tpI9
rWH;M
=nG*
8[A\A]A^A_]
AVSH
[A^]
AWAVAUATSH
[A\A]A^A_]
fff.
AWAVATSH
 [A\A^A_]
AWAVAUATSH
ffffff.
[A\A]A^A_]
ffffff.
t9M9
AWAVATSH
 [A\A^A_]
AWAVAUATSH
[A\A]A^A_]
fff.
!uDH
tDL9
t?Hi
t"L9
AWAVAUATSH
[A\A]A^A_]
AWAVAUATSH
tpI9
rWH;M
8[A\A]A^A_]
AVSI
[A^]
AWAVAUATSH
[A\A]A^A_]
AWAVAUATSH
tpI9
rWH;M
=N,*
8[A\A]A^A_]
AWAVAUATSH
tpI9
rWH;M
8[A\A]A^A_]
AWAVAUATSH
tpI9
rWH;M
=.)*
8[A\A]A^A_]
AWAVAUATSH
tpI9
rWH;M
8[A\A]A^A_]
AVSH
[A^]
AWAVAUATSH
\80B
T8 B
[A\A]A^A_]
AWAVAUATSH
[A\A]A^A_]
AWAVAUATSH
D$PH
D$HH
[A\A]A^A_]
AVSH
[A^]
AWAVAUATSH
\80B
T8 B
[A\A]A^A_]
AWAVAUATSH
[A\A]A^A_]
AVSI
[A^]
AWAVAUATSH
[A\A]A^A_]
t M9
AWAVAUATSH
tpI9
rWH;M
8[A\A]A^A_]
AWAVAUATSH
[A\A]A^A_]
F Hk
t#L9
AWAVAUATSH
[A\A]A^A_]
AWAVAUATSH
H[A\A]A^A_]
D$ H
t(L9
ffff.
AWAVAUATSH
\ 0B
T  B
[A\A]A^A_]
ffff.
t8M9
AWAVAUATSH
fff.
fffff.
ffff.
t'L9
fff.
tEL9
[A\A]A^A_]
` M9
t*L9
ffffff.
AWAVAUATSH
\80B
T8 B
[A\A]A^A_]
AWAVAUATSH
tMM9
[A\A]A^A_]
AWAVAUATSH
[A\A]A^A_]
AWAVAUATSH
[A\A]A^A_]
AWAVAUATSH
[A\A]A^A_]
ffff.
](L9
c M9
](L9
tCL9
AWAVATSH
[A\A^A_]
AWAVAUATSH
D$@H
T$ A
\$@I
\$8I
\$0I
\$(I
\$ I
\$@I
\$8I
\$0I
\$(I
\$ I
[A\A]A^A_]
](L9
{ M9
~ I9
t$@M
t$8M
t$0M
t$(M
t$ M
{ M9
{ M9
](L9
AWAVAUATSH
yfffff.
[A\A]A^A_]
X(f.
tMM9
tCL9
AWAVAUATSH
[A\A]A^A_]
tNL9
AWAVATSH
[A\A^A_]
AWAVAUATSH
ffff.
off.
[A\A]A^A_]
AWAVAUATSH
[A\A]A^A_]
$$M9
[ L9
AWAVAUATSH
ffff.
off.
[A\A]A^A_]
AWAVAUATSH
[A\A]A^A_]
AWAVAUATSH
[A\A]A^A_]
AWAVATSH
[A\A^A_]
AWAVAUATSH
fff.
!uDH
c M9
t#L9
t#L9
tNL9
[A\A]A^A_]
tDL9
t?Hi
t#L9
!u|H
!u5H
c M9
c M9
ffff.
t#L9
tNL9
tDL9
t?Hi
t"L9
AWAVAUATSH
[A\A]A^A_]
c M9
AWAVAUATSH
 ff.
fff.
!uDH
c M9
[A\A]A^A_]
tDL9
t?Hi
t#L9
!u|H
!u5H
s M9
s M9
AWAVAUATSH
tsL9
fff.
[A\A]A^A_]
A0L9
C(L9
{ Hi
G(L9
w Hi
F(L9
^ Li
fff.
toL9
tjHi
fff.
toL9
tjHi
t)L9
t$Hi
ffffff.
F(L9
^ Li
fff.
toL9
tjHi
fff.
toL9
tjHi
t)L9
t$Hi
ffffff.
t L9
G(L9
w Hi
F(L9
^ Li
fff.
toL9
tjHi
fff.
toL9
tjHi
t)L9
t$Hi
ffffff.
F(L9
^ Li
fff.
toL9
tjHi
fff.
toL9
tjHi
t)L9
t$Hi
ffffff.
t L9
t)L9
t$Hi
ffffff.
t L9
t+L9
t~Hi
t L9
t L9
t L9
t L9
t L9
@0H9
p(Hi
!u|H
!u5H
G(L9
_ Li
!u|H
!u5H
F(L9
~ Hi
!u|H
!u5H
G(L9
_ Li
!u|H
!u5H
t!L9
tPM9
t8L9
t3Hi
tyL9
ttHi
t8L9
t3Hi
tYH9
AWAVATSH
[A\A^A_]
AWAVAUATSH
t-M9
A0L9
!u}I
!u5I
t L9
t-M9
fffff.
[A\A]A^A_]
G0L9
_(Li
fff.
toL9
tjHi
t<L9
t7Hi
t<L9
t7Hi
AWAVAUATSH
ffff.
[A\A]A^A_]
k(Hi
ffff.
} Li
fffff.
_ Li
fff.
tpHi
ffffff.
fff.
tpHi
t!Hi
fff.
ffffff.
fffff.
_ Li
fff.
tpHi
ffffff.
fff.
tpHi
t!Hi
fff.
t!Hi
fff.
twHi
G0L9
_(Li
 ff.
tnL9
tiHi
fffff.
tDL9
t?Hi
t#L9
AWAVAUATSH
[A\A]A^A_]
AWAVAUATSH
\$PM
D$XH
[A\A]A^A_]
t$0M9
D$8H
L$(H
fff.
!uDH
tCM9
t>Ii
tDL9
t?Hi
t"L9
AWAVAUATSH
ffff.
E(L9
] Li
!usH
fff.
toL9
tjHi
E(L9
] Li
fff.
toL9
tjHi
 ffff.
!urH
tOL9
tJHi
fffff.
t)L9
t$Hi
ffffff.
fffff.
!upI
^ ffff.
!urH
tOL9
tJHi
fffff.
fffff.
!usH
!urH
tOL9
tJHi
fffff.
[A\A]A^A_]
t.L9
t)Hi
tpL9
tkHi
t#L9
t7M9
t2Ii
ffff.
!usH
X ff.
!urH
tOL9
tJHi
fffff.
!usH
^ fff.
!urH
tOL9
tJHi
fffff.
!urH
tOL9
tJHi
fffff.
!uYH
t=L9
t8Hi
!u	H
E(L9
] Li
!u|H
!u5H
!u|H
!u5H
E(L9
] Li
!u[H
tpL9
tkHi
t#L9
t<L9
t7Hi
t2M9
t-Ii
AWAVAUATSPI
fffff.
ffffff.
!uWH
Lfff.
t Hi
fff.
t!Hi
fff.
] Li
!uZH
Offffff.
t Hi
fff.
t!Hi
fff.
[A\A]A^A_]
o(Li
fffff.
!uZH
Offffff.
t Hi
fff.
t!Hi
fff.
] Li
fffff.
!utH
!u#H
ffffff.
[A\A]A^A_]
[A\A]A^A_]
tjHi
AVSH
t!Hi
[A^]
AWAVAUATSH
 ff.
!urH
!uGH
<fff.
!ulH
!urH
!uGH
<fff.
!ulH
[A\A]A^A_]
tAL9
t<Hi
!urH
tOL9
tJHi
fffff.
ffff.
!usH
tAL9
t<Hi
!uYH
!u5H
!u[H
AWAVAUATSH
D$@H
D$8A
!usH
!ugH
\$XA
T$HA
L$8A
D$(A
!urH
tOL9
tJHi
fffff.
!usH
!urH
tOL9
tJHi
fffff.
[A\A]A^A_]
!u[H
!uYH
!u5H
!ubH
tFL9
tAHi
ffff.
!ucH
AWAVSH
[A^A_]
AWAVAUATSH
F(L9
^ Li
!u[H
!u	H
!uYH
t=L9
t8Hi
!u	H
!u	I
F0L9
!u|H
t`L9
t[Hi
!u	H
[A\A]A^A_]
!uYH
!u5H
F(L9
^ Li
!u[H
!uYH
t=L9
t8Hi
!u	H
F(L9
^ Li
!u[H
!u	H
tPM9
@0L9
`(Li
!u8I
t!L9
D$0L9
L$8H
\$(Li
!u|H
t`L9
t[Hi
!u	H
D$0H
\$XH
t<L9
t7Hi
D$0H
t?L9
t:Hi
AWAVAUATSH
[A\A]A^A_]
tUI9
@0H9
h(Hi
!u|H
!u5H
E(L9
] Li
!u|H
!u5H
t!L9
t%M9
t|Hi
tcL9
t^Hi
tZL9
tUHi
t<L9
t7Hi
t=L9
t8Hi
tGL9
tBHi
F0L9
^(Li
fff.
toL9
tjHi
t<L9
t7Hi
AWAVAUATSH
!urH
!uGH
<fff.
!ulH
!urH
!uGH
<fff.
!ulH
[A\A]A^A_]
tAL9
t<Hi
!urH
tOL9
tJHi
fffff.
ffff.
!usH
tAL9
t<Hi
!uYH
!u5H
!u[H
AWAVAUATSH
[A\A]A^A_]
AWAVAUATSH
[A\A]A^A_]
AWAVAUATSPH
[A\A]A^A_]
C0L9
fff.
!uDH
E(L9
] Li
fff.
!uDH
t L9
[A\A]A^A_]
[A\A]A^A_]
t|Hi
t<L9
t7Hi
t8L9
t3Hi
AWAVAUATSH
x[A\A]A^A_]
AWAVAUATSH
X E1
([A\A]A^A_]
AWAVAUATSH
[A\A]A^A_]
AWAVAUATSH
D#	J
ffffff.
[A\A]A^A_]
AWAVAUATSH
([A\A]A^A_]
AWAVAUATSH
$	L9
([A\A]A^A_]
AWAVAUATSH
t)H9
T$ H
[A\A]A^A_]
AWAVAUATSPH
[A\A]A^A_]
AWAVAUATSH
ffff.
([A\A]A^A_]
AWAVSH
X[A^A_]
AWAVATSI
[A\A^A_]
AWAVAUATSH
5j@(
t)H9
T$ H
[A\A]A^A_]
AWAVAUATSH
t)H9
D$(H
T$ H
[A\A]A^A_]
==p(
AWAVAUATSH
0fff.
fff.
[A\A]A^A_]
tDM9
AWAVATSI
u	[A\A^A_]
[A\A^A_]
AWAVSH
([A^A_]
AWAVAUATSH
0fff.
fff.
[A\A]A^A_]
tDM9
AWAVSH
([A^A_]
AWAVSH
h[A^A_]
AWAVAUATSH
8[A\A]A^A_]
AWAVAUATSH
D$@H
T$ A
5?@(
[A\A]A^A_]
tNM9
tHL9
tNM9
tMM9
tTL9
tUL9
tMM9
tIL9
tHL9
tHL9
tML9
tML9
tML9
tHL9
tRL9
tMLk
tHL9
tML9
tML9
tML9
tHL9
tHL9
tMM9
tNL9
tMM9
AWAVAUATSH
-p%(
[A\A]A^A_]
AWAVAUATSH
[A\A]A^A_]
AWAVAUATSH
[A\A]A^A_]
AWAVAUATSH
ffffff.
Vffff.
fffff.
fff.
[A\A]A^A_]
AWAVAUATSH
t)H9
D$(L
uwM9
fff.
fff.
[A\A]A^A_]
t'L9
AWAVAUATSH
8[A\A]A^A_]
AWAVAUATSH
[A\A]A^A_]
tEM9
t?L9
tEM9
tDM9
tKL9
tLL9
tDM9
t@L9
t?L9
t?L9
tDL9
tDL9
tDL9
t?L9
tIL9
tDLk
t?L9
tDL9
tDL9
tDL9
t?L9
t?L9
tDM9
tEL9
tDM9
AWAVATSI
u	[A\A^A_]
[A\A^A_]
AWAVAUATSH
tKM9
tJL9
fff.
[A\A]A^A_]
t1L9
t1L9
t1L9
t1L9
t1L9
t1L9
t1L9
t1L9
t1L9
t1L9
t1L9
t1L9
=J2'
t1L9
t1L9
t1L9
t1L9
t*L9
AWAVAUATSH
[A\A]A^A_]
t(M9
k M9
AWAVAUATSH
[A\A]A^A_]
=9)'
AWAVAUATSPI
GHL9
fff.
t!L9
fffff.
fff.
ffffff.
fffff.
[A\A]A^A_]
[A\A]A^A_]
=8$'
='$'
AWAVAUATSH
8[A\A]A^A_]
AWAVAUATSH
[A\A]A^A_]
tEM9
t?L9
tEM9
tDM9
tKL9
tLL9
tDM9
t@L9
t?L9
t?L9
tDL9
tDL9
tDL9
t?L9
tIL9
tDLk
t?L9
tDL9
tDL9
tDL9
t?L9
t?L9
tDM9
tEL9
tDM9
AWAVAUATSH
[A\A]A^A_]
AWAVAUATSH
t&H;M
|8L9
u	D; 
tKLi
ffff.
m0Li
tGHi
[A\A]A^A_]
AWAVAUATSH
[A\A]A^A_]
AWAVAUATSH
D$xH
L$hH
fff.
D$HH
L$`L
[A\A]A^A_]
AVSH
`[A^]
AWAVAUATSH
[A\A]A^A_]
5/2&
5S0&
5w/&
5+.&
\$`H
5,-&
5q+&
D$pH
t$`H
5'*&
D$pI
AWAVAUATSH
ffff.
d$ H
fff.
t%L9
[A\A]A^A_]
t%L9
ffffff.
t%L9
t!L9
fffff.
AWAVAUATSH
ffff.
rzI)
ffff.
ffffff.
rxI)
t)L9
ffff.
rxI)
t L9
ryI)
fff.
fff.
rxI)
t)L9
ffff.
D$ I
T$(L
fffff.
rxI)
[A\A]A^A_]
AWAVATSI
F8L9
^0Lk
FPL9
t!L9
u	[A\A^A_]
[A\A^A_]
AVSH
[A^]
AWAVAUATSH
w L9
ffff.
t&L9
ffffff.
tDL9
H[A\A]A^A_]
H[A\A]A^A_]
tAL9
t<L9
AVSH
[A^]
[A^]
AWAVAUATSH
([A\A]A^A_]
fffff.
([A\A]A^A_]
AVSH
0[A^]
aborting with no errors (maybe a bug?)
aborting due to previous erroraborting due to  previous errors
rustcRUST_MIN_STACK
cannot access a TLS value during or after it is destroyed
failed to write whole buffer
formatter error
called `Result::unwrap()` on an `Err` value
capacity overflowunexpected panic
the compiler unexpectedly panicked. this is a bug.
https://github.com/rust-lang/rust/blob/master/CONTRIBUTING.md#bug-reports
RUST_BACKTRACE0
run with `RUST_BACKTRACE=1` for a backtrace
PoisonError { inner: .. }
internal error: entered unreachable code
assertion failed: (*next).value.is_some()
assertion failed: (*tail).value.is_none()
assertion failed: guard.queue.dequeue().is_none()
assertion failed: guard.canceled.is_none()
assertion failed: ptr != 0
assertion failed: n >= 0
out-diro
src/librustc_driver/lib.rs-
prettynormalunprettyStopContinueE
src/libcore/str/pattern.rs
no extended information for 
invalid predicate in --cfg command line argument: ``explain
no input filename given
make_input should have provided valid inputs
multiple input filenames provided
  save analysisZls
cannot list metadata for stdin
x86_64-unknown-linux-gnu
i686-unknown-linux-gnu
i586-unknown-linux-gnu
mips-unknown-linux-gnu
mipsel-unknown-linux-gnu
powerpc-unknown-linux-gnu
powerpc64-unknown-linux-gnu
powerpc64le-unknown-linux-gnu
arm-unknown-linux-gnueabi
arm-unknown-linux-gnueabihf
armv7-unknown-linux-gnueabihf
aarch64-unknown-linux-gnu
x86_64-unknown-linux-musl
i686-unknown-linux-musl
mips-unknown-linux-musl
mipsel-unknown-linux-musl
i686-linux-android
arm-linux-androideabi
armv7-linux-androideabi
aarch64-linux-android
i686-unknown-freebsd
x86_64-unknown-freebsd
i686-unknown-dragonfly
x86_64-unknown-dragonfly
x86_64-unknown-bitrig
x86_64-unknown-openbsd
x86_64-unknown-netbsd
x86_64-rumprun-netbsd
x86_64-apple-darwin
i686-apple-darwini386-apple-iosx86_64-apple-ios
aarch64-apple-iosarmv7-apple-iosarmv7s-apple-iosx86_64-sun-solaris
x86_64-pc-windows-gnu
i686-pc-windows-gnu
x86_64-pc-windows-msvc
i686-pc-windows-msvc
i586-pc-windows-msvc
le32-unknown-nacl
asmjs-unknown-emscriptenoverflow in sum
no input file provided
MetaItemKind::List encountered in default cfg=""
1.11.0verbose unknownbinary: commit-hash: commit-date: host: release: 
src/libcollections/vec.rs
    --help -v           Print the full set of options rustc accepts
Usage: rustc [OPTIONS] INPUT
Additional help:
    -C help             Print codegen options
    -W help             Print 'lint' options and default settings
    -Z help             Print internal options for debugging rustc
namedefaultmeaning-----------_warningssub-lints---------all built-in lints, 
didn't load lint plugins but got them anyway!
Available lint options:
    -W <foo>           Warn about <foo>
    -A <foo>           Allow <foo>
    -D <foo>           Deny <foo>
    -F <foo>           Forbid <foo> (deny, and deny all overrides)
Lint checks provided by rustc:
    
Lint groups provided by rustc:
Compiler plugins can provide additional lints and lint groups. To see a listing of these, re-run `rustc -W help` with a crate filename.
This crate does not load any lint plugins or lint groups.
Lint checks provided by plugins loaded by this crate:
Lint groups provided by plugins loaded by this crate:
=val-Z
in general, enable more debug printoutstime_passes
measure time of each rustc passcount_llvm_insns
count where LLVM instrs originatetime_llvm_passes
measure time of each LLVM passinput_stats
gather statistics about the inputtrans_stats
gather trans statisticsasm_comments
generate comments into the assembly (may change behavior)no_verify
skip LLVM verificationborrowck_stats
gather borrowck statisticsno_landing_pads
omit landing pads for unwindingdebug_llvm
enable debug output from LLVMmeta_stats
gather metadata statisticsprint_link_args
print the arguments passed to the linker
print_llvm_passes
prints the llvm optimization passes being runast_json
print the AST as JSON and halt
ast_json_noexpand
print the pre-expansion AST as JSON and halt
list the symbols defined by a library cratesave_analysis
write syntax and type analysis (in JSON format) information in addition to normal output
save_analysis_csv
write syntax and type analysis (in CSV format) information in addition to normal output
print_move_fragments
print out move-fragment data for every fn
flowgraph_print_loans
include loan analysis data in --unpretty flowgraph output
flowgraph_print_moves
include move analysis data in --unpretty flowgraph output
flowgraph_print_assigns
include assignment analysis data in --unpretty flowgraph output
flowgraph_print_all
include all dataflow analysis data in --unpretty flowgraph output
print_region_graph
prints region inference graph. Use with RUST_REGION_GRAPH=help for more infoparse_only
parse only; do not compile, assemble, or linkno_trans
run all passes except translation; no outputtreat_err_as_bug
treat all errors that occur as bugs
continue_parse_after_error
attempt to recover from parse errors (experimental)incrementala string
enable incremental compilation (experimental)dump_dep_graph
dump the dependency graph to $RUST_DEP_GRAPH (default: /tmp/dep_graph.gv)query_dep_graph
enable queries of the dependency graph for regression testingno_analysis
parse and expand the source, but run no analysisextra_plugins
a space-separated list of strings
load extra pluginsunstable_options
adds unstable command line options to rustc interfaceprint_enum_sizes
print the size of enums and their variants
force_overflow_checks
one of: `y`, `yes`, `on`, `n`, `no`, or `off`
force overflow checks on or off
force_dropflag_checks
force drop flag checks on or offtrace_macros
for every macro invocation, print its name and arguments
enable_nonzeroing_move_hints
force nonzeroing move optimization onkeep_mtwt_tables
don't clear the resolution tables after analysiskeep_ast
keep the AST after lowering it to HIRshow_span
show spans for compiler debugging (expr|pat|ty)
print_trans_items
print the result of the translation item collection passmir_opt_levela number
set the MIR optimization level (0-3)dump_mir
dump MIR state at various points in translationorbit
get MIR where it belongs - everywhere; most importantly, in orbit
Available debug options:
-Car
tool to assemble archives withlinker
system linker to link outputs withlink_args
extra arguments to pass to the linker (space separated)link_dead_code
don't let linker strip dead code (turning it on can be used for code coverage)lto
perform LLVM link-time optimizationstarget_cpu
select target processor (llc -mcpu=help for details)target_feature
target specific attributes (llc -mattr=help for details)passes
a list of extra LLVM passes to run (space separated)llvm_args
a list of arguments to pass to llvm (space separated)save_temps
save all temporary output files during compilationrpath
set rpath values in libs/exes
no_prepopulate_passes
don't pre-populate the pass manager with a list of passes
no_vectorize_loops
don't run the loop vectorization optimization passesno_vectorize_slp
don't run LLVM's SLP vectorization passsoft_float
generate software floating point library callsprefer_dynamic
prefer dynamic linking to static linkingno_integrated_as
use an external assembler rather than LLVM's integrated oneno_redzone
disable the use of the redzonerelocation_model
choose the relocation model to use (llc -relocation-model for details)code_modelchoose the code model to use (llc -code-model for details)metadata
metadata to mangle symbol names withextra_filename
extra data to put in each output filenamecodegen_units
divide crate into N units to optimize in parallelremark
a space-separated list of passes, or `all`
print remarks for these optimization passes (space separated, or "all")no_stack_check
disable checks for stack exhaustion (a memory-safety hazard!)debuginfo
debug info emission level, 0 = no debug info, 1 = line tables only, 2 = full debug info with variable and type informationopt_level
optimize with possible levels 0-3, s, or zdebug_assertions
explicitly enable the cfg(debug_assertions) directiveinline_threshold
set the inlining threshold forpanic
either `panic` or `abort`
panic strategy to compile crate with
Available codegen options:
 -- 
hhelpCpasses=listversionwe would appreciate a bug report: explicit panicE0020
This error indicates that an attempt was made to divide by zero (or take the
remainder of a zero divisor) in a static or constant expression. Erroneous
code example:
```compile_fail
#[deny(const_err)]
const X: i32 = 42 / 0;
// error: attempted to divide by zero in a constant expression
E0038
Trait objects like `Box<Trait>` can only be constructed when certain
requirements are satisfied by the trait in question.
Trait objects are a form of dynamic dispatch and use a dynamically sized type
for the inner type. So, for a given trait `Trait`, when `Trait` is treated as a
type, as in `Box<Trait>`, the inner type is 'unsized'. In such cases the boxed
pointer is a 'fat pointer' that contains an extra pointer to a table of methods
(among other things) for dynamic dispatch. This design mandates some
restrictions on the types of traits that are allowed to be used in trait
objects, which are collectively termed as 'object safety' rules.
Attempting to create a trait object for a non object-safe trait will trigger
this error.
There are various rules:
### The trait cannot require `Self: Sized`
When `Trait` is treated as a type, the type does not implement the special
`Sized` trait, because the type does not have a known size at compile time and
can only be accessed behind a pointer. Thus, if we have a trait like the
following:
trait Foo where Self: Sized {
We cannot create an object of type `Box<Foo>` or `&Foo` since in this case
`Self` would not be `Sized`.
Generally, `Self : Sized` is used to indicate that the trait should not be used
as a trait object. If the trait comes from your own crate, consider removing
this restriction.
### Method references the `Self` type in its arguments or return type
This happens when a trait has a method like the following:
trait Trait {
    fn foo(&self) -> Self;
impl Trait for String {
    fn foo(&self) -> Self {
        "hi".to_owned()
    }
impl Trait for u8 {
    fn foo(&self) -> Self {
        1
    }
(Note that `&self` and `&mut self` are okay, it's additional `Self` types which
cause this problem.)
In such a case, the compiler cannot predict the return type of `foo()` in a
situation like the following:
```compile_fail
trait Trait {
    fn foo(&self) -> Self;
fn call_foo(x: Box<Trait>) {
    let y = x.foo(); // What type is y?
    // ...
If only some methods aren't object-safe, you can add a `where Self: Sized` bound
on them to mark them as explicitly unavailable to trait objects. The
functionality will still be available to all other implementers, including
`Box<Trait>` which is itself sized (assuming you `impl Trait for Box<Trait>`).
trait Trait {
    fn foo(&self) -> Self where Self: Sized;
    // more functions
Now, `foo()` can no longer be called on a trait object, but you will now be
allowed to make a trait object, and that will be able to call any object-safe
methods. With such a bound, one can still call `foo()` on types implementing
that trait that aren't behind trait objects.
### Method has generic type parameters
As mentioned before, trait objects contain pointers to method tables. So, if we
have:
trait Trait {
    fn foo(&self);
impl Trait for String {
    fn foo(&self) {
        // implementation 1
    }
impl Trait for u8 {
    fn foo(&self) {
        // implementation 2
    }
// ...
At compile time each implementation of `Trait` will produce a table containing
the various methods (and other items) related to the implementation.
This works fine, but when the method gains generic parameters, we can have a
problem.
Usually, generic parameters get _monomorphized_. For example, if I have
fn foo<T>(x: T) {
    // ...
The machine code for `foo::<u8>()`, `foo::<bool>()`, `foo::<String>()`, or any
other type substitution is different. Hence the compiler generates the
implementation on-demand. If you call `foo()` with a `bool` parameter, the
compiler will only generate code for `foo::<bool>()`. When we have additional
type parameters, the number of monomorphized implementations the compiler
generates does not grow drastically, since the compiler will only generate an
implementation if the function is called with unparametrized substitutions
(i.e., substitutions where none of the substituted types are themselves
parametrized).
However, with trait objects we have to make a table containing _every_ object
that implements the trait. Now, if it has type parameters, we need to add
implementations for every type that implements the trait, and there could
theoretically be an infinite number of types.
For example, with:
trait Trait {
    fn foo<T>(&self, on: T);
    // more methods
impl Trait for String {
    fn foo<T>(&self, on: T) {
        // implementation 1
    }
impl Trait for u8 {
    fn foo<T>(&self, on: T) {
        // implementation 2
    }
// 8 more implementations
Now, if we have the following code:
```ignore
fn call_foo(thing: Box<Trait>) {
    thing.foo(true); // this could be any one of the 8 types above
    thing.foo(1);
    thing.foo("hello");
We don't just need to create a table of all implementations of all methods of
`Trait`, we need to create such a table, for each different type fed to
`foo()`. In this case this turns out to be (10 types implementing `Trait`)*(3
types being fed to `foo()`) = 30 implementations!
With real world traits these numbers can grow drastically.
To fix this, it is suggested to use a `where Self: Sized` bound similar to the
fix for the sub-error above if you do not intend to call the method with type
parameters:
trait Trait {
    fn foo<T>(&self, on: T) where Self: Sized;
    // more methods
If this is not an option, consider replacing the type parameter with another
trait object (e.g. if `T: OtherTrait`, use `on: Box<OtherTrait>`). If the number
of types you intend to feed to this method is limited, consider manually listing
out the methods of different types.
### Method has no receiver
Methods that do not take a `self` parameter can't be called since there won't be
a way to get a pointer to the method table for them.
trait Foo {
    fn foo() -> u8;
This could be called as `<Foo as Foo>::foo()`, which would not be able to pick
an implementation.
Adding a `Self: Sized` bound to these methods will generally make this compile.
trait Foo {
    fn foo() -> u8 where Self: Sized;
### The trait cannot use `Self` as a type parameter in the supertrait listing
This is similar to the second sub-error, but subtler. It happens in situations
like the following:
```compile_fail
trait Super<A> {}
trait Trait: Super<Self> {
struct Foo;
impl Super<Foo> for Foo{}
impl Trait for Foo {}
Here, the supertrait might have methods as follows:
trait Super<A> {
    fn get_a(&self) -> A; // note that this is object safe!
If the trait `Foo` was deriving from something like `Super<String>` or
`Super<T>` (where `Foo` itself is `Foo<T>`), this is okay, because given a type
`get_a()` will definitely return an object of that type.
However, if it derives from `Super<Self>`, even though `Super` is object safe,
the method `get_a()` would return an object of unknown type when called on the
function. `Self` type parameters let us make object safe traits no longer safe,
so they are forbidden when specifying supertraits.
There's no easy fix for this, generally code will need to be refactored so that
you no longer need to derive from `Super<Self>`.
E0072
When defining a recursive struct or enum, any use of the type being defined
from inside the definition must occur behind a pointer (like `Box` or `&`).
This is because structs and enums must have a well-defined size, and without
the pointer, the size of the type would need to be unbounded.
Consider the following erroneous definition of a type for a list of bytes:
```compile_fail,E0072
// error, invalid recursive struct type
struct ListNode {
    head: u8,
    tail: Option<ListNode>,
This type cannot have a well-defined size, because it needs to be arbitrarily
large (since we would be able to nest `ListNode`s to any depth). Specifically,
```plain
size of `ListNode` = 1 byte for `head`
                   + 1 byte for the discriminant of the `Option`
                   + size of `ListNode`
One way to fix this is by wrapping `ListNode` in a `Box`, like so:
struct ListNode {
    head: u8,
    tail: Option<Box<ListNode>>,
This works because `Box` is a pointer, so its size is well-known.
E0109
You tried to give a type parameter to a type which doesn't need it. Erroneous
code example:
```compile_fail,E0109
type X = u32<i32>; // error: type parameters are not allowed on this type
Please check that you used the correct type and recheck its definition. Perhaps
it doesn't need the type parameter.
Example:
type X = u32; // this compiles
Note that type parameters for enum-variant constructors go after the variant,
not after the enum (Option::None::<u32>, not Option::<u32>::None).
E0110
You tried to give a lifetime parameter to a type which doesn't need it.
Erroneous code example:
```compile_fail,E0110
type X = u32<'static>; // error: lifetime parameters are not allowed on
                       //        this type
Please check that the correct type was used and recheck its definition; perhaps
it doesn't need the lifetime parameter. Example:
type X = u32; // ok!
E0133
Unsafe code was used outside of an unsafe function or block.
Erroneous code example:
```compile_fail,E0133
unsafe fn f() { return; } // This is the unsafe code
fn main() {
    f(); // error: call to unsafe function requires unsafe function or block
Using unsafe functionality is potentially dangerous and disallowed by safety
checks. Examples:
* Dereferencing raw pointers
* Calling functions via FFI
* Calling functions marked unsafe
These safety checks can be relaxed for a section of the code by wrapping the
unsafe instructions with an `unsafe` block. For instance:
unsafe fn f() { return; }
fn main() {
    unsafe { f(); } // ok!
See also https://doc.rust-lang.org/book/unsafe.html
E0136
A binary can only have one entry point, and by default that entry point is the
function `main()`. If there are multiple such functions, please rename one.
E0137
More than one function was declared with the `#[main]` attribute.
Erroneous code example:
```compile_fail,E0137
#![feature(main)]
#[main]
fn foo() {}
#[main]
fn f() {} // error: multiple functions with a #[main] attribute
This error indicates that the compiler found multiple functions with the
`#[main]` attribute. This is an error because there must be a unique entry
point into a Rust program. Example:
#![feature(main)]
#[main]
fn f() {} // ok!
E0138
More than one function was declared with the `#[start]` attribute.
Erroneous code example:
```compile_fail,E0138
#![feature(start)]
#[start]
fn foo(argc: isize, argv: *const *const u8) -> isize {}
#[start]
fn f(argc: isize, argv: *const *const u8) -> isize {}
// error: multiple 'start' functions
This error indicates that the compiler found multiple functions with the
`#[start]` attribute. This is an error because there must be a unique entry
point into a Rust program. Example:
#![feature(start)]
#[start]
fn foo(argc: isize, argv: *const *const u8) -> isize { 0 } // ok!
E0139
There are various restrictions on transmuting between types in Rust; for example
types being transmuted must have the same size. To apply all these restrictions,
the compiler must know the exact types that may be transmuted. When type
parameters are involved, this cannot always be done.
So, for example, the following is not allowed:
use std::mem::transmute;
struct Foo<T>(Vec<T>);
fn foo<T>(x: Vec<T>) {
    // we are transmuting between Vec<T> and Foo<F> here
    let y: Foo<T> = unsafe { transmute(x) };
    // do something with y
In this specific case there's a good chance that the transmute is harmless (but
this is not guaranteed by Rust). However, when alignment and enum optimizations
come into the picture, it's quite likely that the sizes may or may not match
with different type parameter substitutions. It's not possible to check this for
_all_ possible types, so `transmute()` simply only accepts types without any
unsubstituted type parameters.
If you need this, there's a good chance you're doing something wrong. Keep in
mind that Rust doesn't guarantee much about the layout of different structs
(even two structs with identical declarations may have different layouts). If
there is a solution that avoids the transmute entirely, try it instead.
If it's possible, hand-monomorphize the code by writing the function for each
possible type substitution. It's possible to use traits to do this cleanly,
for example:
```ignore
struct Foo<T>(Vec<T>);
trait MyTransmutableType {
    fn transmute(Vec<Self>) -> Foo<Self>;
impl MyTransmutableType for u8 {
    fn transmute(x: Foo<u8>) -> Vec<u8> {
        transmute(x)
    }
impl MyTransmutableType for String {
    fn transmute(x: Foo<String>) -> Vec<String> {
        transmute(x)
    }
// ... more impls for the types you intend to transmute
fn foo<T: MyTransmutableType>(x: Vec<T>) {
    let y: Foo<T> = <T as MyTransmutableType>::transmute(x);
    // do something with y
Each impl will be checked for a size match in the transmute as usual, and since
there are no unbound type parameters involved, this should compile unless there
is a size mismatch in one of the impls.
It is also possible to manually transmute:
```ignore
ptr::read(&v as *const _ as *const SomeType) // `v` transmuted to `SomeType`
Note that this does not move `v` (unlike `transmute`), and may need a
call to `mem::forget(v)` in case you want to avoid destructors being called.
E0152
A lang item was redefined.
Erroneous code example:
```compile_fail,E0152
#![feature(lang_items)]
#[lang = "panic_fmt"]
struct Foo; // error: duplicate lang item found: `panic_fmt`
Lang items are already implemented in the standard library. Unless you are
writing a free-standing application (e.g. a kernel), you do not need to provide
them yourself.
You can build a free-standing crate by adding `#![no_std]` to the crate
attributes:
#![no_std]
See also https://doc.rust-lang.org/book/no-stdlib.html
E0229
An associated type binding was done outside of the type parameter declaration
and `where` clause. Erroneous code example:
```compile_fail,E0229
pub trait Foo {
    type A;
    fn boo(&self) -> <Self as Foo>::A;
struct Bar;
impl Foo for isize {
    type A = usize;
    fn boo(&self) -> usize { 42 }
fn baz<I>(x: &<I as Foo<A=Bar>>::A) {}
// error: associated type bindings are not allowed here
To solve this error, please move the type bindings in the type parameter
declaration:
```ignore
fn baz<I: Foo<A=Bar>>(x: &<I as Foo>::A) {} // ok!
Or in the `where` clause:
```ignore
fn baz<I>(x: &<I as Foo>::A) where I: Foo<A=Bar> {}
E0261
When using a lifetime like `'a` in a type, it must be declared before being
used.
These two examples illustrate the problem:
```compile_fail,E0261
// error, use of undeclared lifetime name `'a`
fn foo(x: &'a str) { }
struct Foo {
    // error, use of undeclared lifetime name `'a`
    x: &'a str,
These can be fixed by declaring lifetime parameters:
fn foo<'a>(x: &'a str) {}
struct Foo<'a> {
    x: &'a str,
E0262
Declaring certain lifetime names in parameters is disallowed. For example,
because the `'static` lifetime is a special built-in lifetime name denoting
the lifetime of the entire program, this is an error:
```compile_fail,E0262
// error, invalid lifetime parameter name `'static`
fn foo<'static>(x: &'static str) { }
E0263
A lifetime name cannot be declared more than once in the same scope. For
example:
```compile_fail,E0263
// error, lifetime name `'a` declared twice in the same scope
fn foo<'a, 'b, 'a>(x: &'a str, y: &'b str) { }
E0264
An unknown external lang item was used. Erroneous code example:
```compile_fail,E0264
#![feature(lang_items)]
extern "C" {
    #[lang = "cake"] // error: unknown external lang item: `cake`
    fn cake();
A list of available external lang items is available in
`src/librustc/middle/weak_lang_items.rs`. Example:
#![feature(lang_items)]
extern "C" {
    #[lang = "panic_fmt"] // ok!
    fn cake();
E0269
A returned value was expected but not all control paths return one.
Erroneous code example:
```compile_fail,E0269
fn abracada_FAIL() -> String {
    "this won't work".to_string();
    // error: not all control paths return a value
In the previous code, the function is supposed to return a `String`, however,
the code returns nothing (because of the ';'). Another erroneous code would be:
```compile_fail
fn abracada_FAIL(b: bool) -> u32 {
    if b {
        0
    } else {
        "a" // It fails because an `u32` was expected and something else is
            // returned.
    }
It is advisable to find out what the unhandled cases are and check for them,
returning an appropriate value or panicking if necessary. Check if you need
to remove a semicolon from the last expression, like in the first erroneous
code example.
E0270
Rust lets you define functions which are known to never return, i.e. are
'diverging', by marking its return type as `!`.
For example, the following functions never return:
```no_run
fn foo() -> ! {
    loop {}
fn bar() -> ! {
    foo() // foo() is diverging, so this will diverge too
fn baz() -> ! {
    panic!(); // this macro internally expands to a call to a diverging function
Such functions can be used in a place where a value is expected without
returning a value of that type, for instance:
```no_run
fn foo() -> ! {
    loop {}
let x = 3;
let y = match x {
    1 => 1,
    2 => 4,
    _ => foo() // diverging function called here
println!("{}", y)
If the third arm of the match block is reached, since `foo()` doesn't ever
return control to the match block, it is fine to use it in a place where an
integer was expected. The `match` block will never finish executing, and any
point where `y` (like the print statement) is needed will not be reached.
However, if we had a diverging function that actually does finish execution:
```ignore
fn foo() -> ! {
    loop {break;}
Then we would have an unknown value for `y` in the following code:
```no_run
fn foo() -> ! {
    loop {}
let x = 3;
let y = match x {
    1 => 1,
    2 => 4,
    _ => foo()
println!("{}", y);
In the previous example, the print statement was never reached when the
wildcard match arm was hit, so we were okay with `foo()` not returning an
integer that we could set to `y`. But in this example, `foo()` actually does
return control, so the print statement will be executed with an uninitialized
value.
Obviously we cannot have functions which are allowed to be used in such
positions and yet can return control. So, if you are defining a function that
returns `!`, make sure that there is no way for it to actually finish
executing.
E0271
This is because of a type mismatch between the associated type of some
trait (e.g. `T::Bar`, where `T` implements `trait Quux { type Bar; }`)
and another type `U` that is required to be equal to `T::Bar`, but is not.
Examples follow.
Here is a basic example:
```compile_fail,E0271
trait Trait { type AssociatedType; }
fn foo<T>(t: T) where T: Trait<AssociatedType=u32> {
    println!("in foo");
impl Trait for i8 { type AssociatedType = &'static str; }
foo(3_i8);
Here is that same example again, with some explanatory comments:
```ignore
trait Trait { type AssociatedType; }
fn foo<T>(t: T) where T: Trait<AssociatedType=u32> {
//                    ~~~~~~~~ ~~~~~~~~~~~~~~~~~~
//                        |            |
//         This says `foo` can         |
//           only be used with         |
//              some type that         |
//         implements `Trait`.         |
//                                     |
//                             This says not only must
//                             `T` be an impl of `Trait`
//                             but also that the impl
//                             must assign the type `u32`
//                             to the associated type.
    println!("in foo");
impl Trait for i8 { type AssociatedType = &'static str; }
~~~~~~~~~~~~~~~~~   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//      |                             |
// `i8` does have                     |
// implementation                     |
// of `Trait`...                      |
//                     ... but it is an implementation
//                     that assigns `&'static str` to
//                     the associated type.
foo(3_i8);
// Here, we invoke `foo` with an `i8`, which does not satisfy
// the constraint `<i8 as Trait>::AssociatedType=u32`, and
// therefore the type-checker complains with this error code.
Here is a more subtle instance of the same problem, that can
arise with for-loops in Rust:
```compile_fail
let vs: Vec<i32> = vec![1, 2, 3, 4];
for v in &vs {
    match v {
        1 => {},
        _ => {},
    }
The above fails because of an analogous type mismatch,
though may be harder to see. Again, here are some
explanatory comments for the same example:
```ignore
    let vs = vec![1, 2, 3, 4];
    // `for`-loops use a protocol based on the `Iterator`
    // trait. Each item yielded in a `for` loop has the
    // type `Iterator::Item` -- that is, `Item` is the
    // associated type of the concrete iterator impl.
    for v in &vs {
//      ~    ~~~
//      |     |
//      |    We borrow `vs`, iterating over a sequence of
//      |    *references* of type `&Elem` (where `Elem` is
//      |    vector's element type). Thus, the associated
//      |    type `Item` must be a reference `&`-type ...
//      |
//  ... and `v` has the type `Iterator::Item`, as dictated by
//  the `for`-loop protocol ...
        match v {
            1 => {}
//          ~
//          |
// ... but *here*, `v` is forced to have some integral type;
// only types like `u8`,`i8`,`u16`,`i16`, et cetera can
// match the pattern `1` ...
            _ => {}
        }
// ... therefore, the compiler complains, because it sees
// an attempt to solve the equations
// `some integral-type` = type-of-`v`
//                      = `Iterator::Item`
//                      = `&Elem` (i.e. `some reference type`)
// which cannot possibly all be true.
    }
To avoid those issues, you have to make the types match correctly.
So we can fix the previous examples like this:
// Basic Example:
trait Trait { type AssociatedType; }
fn foo<T>(t: T) where T: Trait<AssociatedType = &'static str> {
    println!("in foo");
impl Trait for i8 { type AssociatedType = &'static str; }
foo(3_i8);
// For-Loop Example:
let vs = vec![1, 2, 3, 4];
for v in &vs {
    match v {
        &1 => {}
        _ => {}
    }
E0272
The `#[rustc_on_unimplemented]` attribute lets you specify a custom error
message for when a particular trait isn't implemented on a type placed in a
position that needs that trait. For example, when the following code is
compiled:
```compile_fail
#![feature(on_unimplemented)]
fn foo<T: Index<u8>>(x: T){}
#[rustc_on_unimplemented = "the type `{Self}` cannot be indexed by `{Idx}`"]
trait Index<Idx> { /* ... */ }
foo(true); // `bool` does not implement `Index<u8>`
There will be an error about `bool` not implementing `Index<u8>`, followed by a
note saying "the type `bool` cannot be indexed by `u8`".
As you can see, you can specify type parameters in curly braces for
substitution with the actual types (using the regular format string syntax) in
a given situation. Furthermore, `{Self}` will substitute to the type (in this
case, `bool`) that we tried to use.
This error appears when the curly braces contain an identifier which doesn't
match with any of the type parameters or the string `Self`. This might happen
if you misspelled a type parameter, or if you intended to use literal curly
braces. If it is the latter, escape the curly braces with a second curly brace
of the same type; e.g. a literal `{` is `{{`.
E0273
The `#[rustc_on_unimplemented]` attribute lets you specify a custom error
message for when a particular trait isn't implemented on a type placed in a
position that needs that trait. For example, when the following code is
compiled:
```compile_fail
#![feature(on_unimplemented)]
fn foo<T: Index<u8>>(x: T){}
#[rustc_on_unimplemented = "the type `{Self}` cannot be indexed by `{Idx}`"]
trait Index<Idx> { /* ... */ }
foo(true); // `bool` does not implement `Index<u8>`
there will be an error about `bool` not implementing `Index<u8>`, followed by a
note saying "the type `bool` cannot be indexed by `u8`".
As you can see, you can specify type parameters in curly braces for
substitution with the actual types (using the regular format string syntax) in
a given situation. Furthermore, `{Self}` will substitute to the type (in this
case, `bool`) that we tried to use.
This error appears when the curly braces do not contain an identifier. Please
add one of the same name as a type parameter. If you intended to use literal
braces, use `{{` and `}}` to escape them.
E0274
The `#[rustc_on_unimplemented]` attribute lets you specify a custom error
message for when a particular trait isn't implemented on a type placed in a
position that needs that trait. For example, when the following code is
compiled:
```compile_fail
#![feature(on_unimplemented)]
fn foo<T: Index<u8>>(x: T){}
#[rustc_on_unimplemented = "the type `{Self}` cannot be indexed by `{Idx}`"]
trait Index<Idx> { /* ... */ }
foo(true); // `bool` does not implement `Index<u8>`
there will be an error about `bool` not implementing `Index<u8>`, followed by a
note saying "the type `bool` cannot be indexed by `u8`".
For this to work, some note must be specified. An empty attribute will not do
anything, please remove the attribute or add some helpful note for users of the
trait.
E0275
This error occurs when there was a recursive trait requirement that overflowed
before it could be evaluated. Often this means that there is unbounded
recursion in resolving some type bounds.
For example, in the following code:
```compile_fail,E0275
trait Foo {}
struct Bar<T>(T);
impl<T> Foo for T where Bar<T>: Foo {}
To determine if a `T` is `Foo`, we need to check if `Bar<T>` is `Foo`. However,
to do this check, we need to determine that `Bar<Bar<T>>` is `Foo`. To
determine this, we check if `Bar<Bar<Bar<T>>>` is `Foo`, and so on. This is
clearly a recursive requirement that can't be resolved directly.
Consider changing your trait bounds so that they're less self-referential.
E0276
This error occurs when a bound in an implementation of a trait does not match
the bounds specified in the original trait. For example:
```compile_fail,E0276
trait Foo {
    fn foo<T>(x: T);
impl Foo for bool {
    fn foo<T>(x: T) where T: Copy {}
Here, all types implementing `Foo` must have a method `foo<T>(x: T)` which can
take any type `T`. However, in the `impl` for `bool`, we have added an extra
bound that `T` is `Copy`, which isn't compatible with the original trait.
Consider removing the bound from the method or adding the bound to the original
method definition in the trait.
E0277
You tried to use a type which doesn't implement some trait in a place which
expected that trait. Erroneous code example:
```compile_fail,E0277
// here we declare the Foo trait with a bar method
trait Foo {
    fn bar(&self);
// we now declare a function which takes an object implementing the Foo trait
fn some_func<T: Foo>(foo: T) {
    foo.bar();
fn main() {
    // we now call the method with the i32 type, which doesn't implement
    // the Foo trait
    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied
In order to fix this error, verify that the type you're using does implement
the trait. Example:
trait Foo {
    fn bar(&self);
fn some_func<T: Foo>(foo: T) {
    foo.bar(); // we can now use this method since i32 implements the
               // Foo trait
// we implement the trait on the i32 type
impl Foo for i32 {
    fn bar(&self) {}
fn main() {
    some_func(5i32); // ok!
Or in a generic context, an erroneous code example would look like:
```compile_fail,E0277
fn some_func<T>(foo: T) {
    println!("{:?}", foo); // error: the trait `core::fmt::Debug` is not
                           //        implemented for the type `T`
fn main() {
    // We now call the method with the i32 type,
    // which *does* implement the Debug trait.
    some_func(5i32);
Note that the error here is in the definition of the generic function: Although
we only call it with a parameter that does implement `Debug`, the compiler
still rejects the function: It must work with all possible input types. In
order to make this example compile, we need to restrict the generic type we're
accepting:
use std::fmt;
// Restrict the input type to types that implement Debug.
fn some_func<T: fmt::Debug>(foo: T) {
    println!("{:?}", foo);
fn main() {
    // Calling the method is still fine, as i32 implements Debug.
    some_func(5i32);
    // This would fail to compile now:
    // struct WithoutDebug;
    // some_func(WithoutDebug);
Rust only looks at the signature of the called function, as such it must
already specify all requirements that will be used for every type parameter.
E0281
You tried to supply a type which doesn't implement some trait in a location
which expected that trait. This error typically occurs when working with
`Fn`-based types. Erroneous code example:
```compile_fail,E0281
fn foo<F: Fn()>(x: F) { }
fn main() {
    // type mismatch: the type ... implements the trait `core::ops::Fn<(_,)>`,
    // but the trait `core::ops::Fn<()>` is required (expected (), found tuple
    // [E0281]
    foo(|y| { });
The issue in this case is that `foo` is defined as accepting a `Fn` with no
arguments, but the closure we attempted to pass to it requires one argument.
E0282
This error indicates that type inference did not result in one unique possible
type, and extra information is required. In most cases this can be provided
by adding a type annotation. Sometimes you need to specify a generic type
parameter manually.
A common example is the `collect` method on `Iterator`. It has a generic type
parameter with a `FromIterator` bound, which for a `char` iterator is
implemented by `Vec` and `String` among others. Consider the following snippet
that reverses the characters of a string:
```compile_fail,E0282
let x = "hello".chars().rev().collect();
In this case, the compiler cannot infer what the type of `x` should be:
`Vec<char>` and `String` are both suitable candidates. To specify which type to
use, you can use a type annotation on `x`:
let x: Vec<char> = "hello".chars().rev().collect();
It is not necessary to annotate the full type. Once the ambiguity is resolved,
the compiler can infer the rest:
let x: Vec<_> = "hello".chars().rev().collect();
Another way to provide the compiler with enough information, is to specify the
generic type parameter:
let x = "hello".chars().rev().collect::<Vec<char>>();
Again, you need not specify the full type if the compiler can infer it:
let x = "hello".chars().rev().collect::<Vec<_>>();
Apart from a method or function with a generic type parameter, this error can
occur when a type parameter of a struct or trait cannot be inferred. In that
case it is not always possible to use a type annotation, because all candidates
have the same return type. For instance:
```compile_fail,E0282
struct Foo<T> {
    num: T,
impl<T> Foo<T> {
    fn bar() -> i32 {
        0
    }
    fn baz() {
        let number = Foo::bar();
    }
This will fail because the compiler does not know which instance of `Foo` to
call `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.
E0283
This error occurs when the compiler doesn't have enough information
to unambiguously choose an implementation.
For example:
```compile_fail,E0283
trait Generator {
    fn create() -> u32;
struct Impl;
impl Generator for Impl {
    fn create() -> u32 { 1 }
struct AnotherImpl;
impl Generator for AnotherImpl {
    fn create() -> u32 { 2 }
fn main() {
    let cont: u32 = Generator::create();
    // error, impossible to choose one of Generator trait implementation
    // Impl or AnotherImpl? Maybe anything else?
To resolve this error use the concrete type:
trait Generator {
    fn create() -> u32;
struct AnotherImpl;
impl Generator for AnotherImpl {
    fn create() -> u32 { 2 }
fn main() {
    let gen1 = AnotherImpl::create();
    // if there are multiple methods with same name (different traits)
    let gen2 = <AnotherImpl as Generator>::create();
E0296
This error indicates that the given recursion limit could not be parsed. Ensure
that the value provided is a positive integer between quotes.
Erroneous code example:
```compile_fail,E0296
#![recursion_limit]
fn main() {}
And a working example:
#![recursion_limit="1000"]
fn main() {}
E0308
This error occurs when the compiler was unable to infer the concrete type of a
variable. It can occur for several cases, the most common of which is a
mismatch in the expected type that the compiler inferred for a variable's
initializing expression, and the actual type explicitly assigned to the
variable.
For example:
```compile_fail,E0308
let x: i32 = "I am not a number!";
//     ~~~   ~~~~~~~~~~~~~~~~~~~~
//      |             |
//      |    initializing expression;
//      |    compiler infers type `&str`
//      |
//    type `i32` assigned to variable `x`
Another situation in which this occurs is when you attempt to use the `try!`
macro inside a function that does not return a `Result<T, E>`:
```compile_fail,E0308
use std::fs::File;
fn main() {
    let mut f = try!(File::create("foo.txt"));
This code gives an error like this:
```text
<std macros>:5:8: 6:42 error: mismatched types:
 expected `()`,
     found `core::result::Result<_, _>`
 (expected (),
     found enum `core::result::Result`) [E0308]
`try!` returns a `Result<T, E>`, and so the function must. But `main()` has
`()` as its return type, hence the error.
E0309
Types in type definitions have lifetimes associated with them that represent
how long the data stored within them is guaranteed to be live. This lifetime
must be as long as the data needs to be alive, and missing the constraint that
denotes this will cause this error.
```compile_fail,E0309
// This won't compile because T is not constrained, meaning the data
// stored in it is not guaranteed to last as long as the reference
struct Foo<'a, T> {
    foo: &'a T
This will compile, because it has the constraint on the type parameter:
struct Foo<'a, T: 'a> {
    foo: &'a T
E0310
Types in type definitions have lifetimes associated with them that represent
how long the data stored within them is guaranteed to be live. This lifetime
must be as long as the data needs to be alive, and missing the constraint that
denotes this will cause this error.
```compile_fail,E0310
// This won't compile because T is not constrained to the static lifetime
// the reference needs
struct Foo<T> {
    foo: &'static T
This will compile, because it has the constraint on the type parameter:
struct Foo<T: 'static> {
    foo: &'static T
E0398
In Rust 1.3, the default object lifetime bounds are expected to change, as
described in RFC #1156 [1]. You are getting a warning because the compiler
thinks it is possible that this change will cause a compilation error in your
code. It is possible, though unlikely, that this is a false alarm.
The heart of the change is that where `&'a Box<SomeTrait>` used to default to
`&'a Box<SomeTrait+'a>`, it now defaults to `&'a Box<SomeTrait+'static>` (here,
`SomeTrait` is the name of some trait type). Note that the only types which are
affected are references to boxes, like `&Box<SomeTrait>` or
`&[Box<SomeTrait>]`. More common types like `&SomeTrait` or `Box<SomeTrait>`
are unaffected.
To silence this warning, edit your code to use an explicit bound. Most of the
time, this means that you will want to change the signature of a function that
you are calling. For example, if the error is reported on a call like `foo(x)`,
and `foo` is defined as follows:
```ignore
fn foo(arg: &Box<SomeTrait>) { ... }
You might change it to:
```ignore
fn foo<'a>(arg: &Box<SomeTrait+'a>) { ... }
This explicitly states that you expect the trait object `SomeTrait` to contain
references (with a maximum lifetime of `'a`).
[1]: https://github.com/rust-lang/rfcs/pull/1156
E0452
An invalid lint attribute has been given. Erroneous code example:
```compile_fail,E0452
#![allow(foo = "")] // error: malformed lint attribute
Lint attributes only accept a list of identifiers (where each identifier is a
lint name). Ensure the attribute is of this form:
#![allow(foo)] // ok!
// or:
#![allow(foo, foo2)] // ok!
E0453
A lint check attribute was overruled by a `forbid` directive set as an
attribute on an enclosing scope, or on the command line with the `-F` option.
Example of erroneous code:
```compile_fail,E0453
#![forbid(non_snake_case)]
#[allow(non_snake_case)]
fn main() {
    let MyNumber = 2; // error: allow(non_snake_case) overruled by outer
                      //        forbid(non_snake_case)
The `forbid` lint setting, like `deny`, turns the corresponding compiler
warning into a hard error. Unlike `deny`, `forbid` prevents itself from being
overridden by inner attributes.
If you're sure you want to override the lint check, you can change `forbid` to
`deny` (or use `-D` instead of `-F` if the `forbid` setting was given as a
command-line option) to allow the inner lint check attribute:
#![deny(non_snake_case)]
#[allow(non_snake_case)]
fn main() {
    let MyNumber = 2; // ok!
Otherwise, edit the code to pass the lint check, and remove the overruled
attribute:
#![forbid(non_snake_case)]
fn main() {
    let my_number = 2;
E0496
A lifetime name is shadowing another lifetime name. Erroneous code example:
```compile_fail,E0496
struct Foo<'a> {
    a: &'a i32,
impl<'a> Foo<'a> {
    fn f<'a>(x: &'a i32) { // error: lifetime name `'a` shadows a lifetime
                           //        name that is already in scope
    }
Please change the name of one of the lifetimes to remove this error. Example:
struct Foo<'a> {
    a: &'a i32,
impl<'a> Foo<'a> {
    fn f<'b>(x: &'b i32) { // ok!
    }
fn main() {
E0497
A stability attribute was used outside of the standard library. Erroneous code
example:
```compile_fail
#[stable] // error: stability attributes may not be used outside of the
          //        standard library
fn foo() {}
It is not possible to use stability attributes outside of the standard library.
Also, for now, it is not possible to write deprecation messages either.
E0512
Transmute with two differently sized types was attempted. Erroneous code
example:
```compile_fail,E0512
fn takes_u8(_: u8) {}
fn main() {
    unsafe { takes_u8(::std::mem::transmute(0u16)); }
    // error: transmute called with differently sized types
Please use types with same size or use the expected type directly. Example:
fn takes_u8(_: u8) {}
fn main() {
    unsafe { takes_u8(::std::mem::transmute(0i8)); } // ok!
    // or:
    unsafe { takes_u8(0u8); } // ok!
E0517
This error indicates that a `#[repr(..)]` attribute was placed on an
unsupported item.
Examples of erroneous code:
```compile_fail,E0517
#[repr(C)]
type Foo = u8;
#[repr(packed)]
enum Foo {Bar, Baz}
#[repr(u8)]
struct Foo {bar: bool, baz: bool}
#[repr(C)]
impl Foo {
    // ...
* The `#[repr(C)]` attribute can only be placed on structs and enums.
* The `#[repr(packed)]` and `#[repr(simd)]` attributes only work on structs.
* The `#[repr(u8)]`, `#[repr(i16)]`, etc attributes only work on enums.
These attributes do not work on typedefs, since typedefs are just aliases.
Representations like `#[repr(u8)]`, `#[repr(i64)]` are for selecting the
discriminant size for C-like enums (when there is no associated data, e.g.
`enum Color {Red, Blue, Green}`), effectively setting the size of the enum to
the size of the provided type. Such an enum can be cast to a value of the same
type as well. In short, `#[repr(u8)]` makes the enum behave like an integer
with a constrained set of allowed values.
Only C-like enums can be cast to numerical primitives, so this attribute will
not apply to structs.
`#[repr(packed)]` reduces padding to make the struct size smaller. The
representation of enums isn't strictly defined in Rust, and this attribute
won't work on enums.
`#[repr(simd)]` will give a struct consisting of a homogenous series of machine
types (i.e. `u8`, `i32`, etc) a representation that permits vectorization via
SIMD. This doesn't make much sense for enums since they don't consist of a
single list of data.
E0518
This error indicates that an `#[inline(..)]` attribute was incorrectly placed
on something other than a function or method.
Examples of erroneous code:
```compile_fail,E0518
#[inline(always)]
struct Foo;
#[inline(never)]
impl Foo {
    // ...
`#[inline]` hints the compiler whether or not to attempt to inline a method or
function. By default, the compiler does a pretty good job of figuring this out
itself, but if you feel the need for annotations, `#[inline(always)]` and
`#[inline(never)]` can override or force the compiler's decision.
If you wish to apply this attribute to all methods in an impl, manually annotate
each method; it is not possible to annotate the entire impl with an `#[inline]`
attribute.
E0522
The lang attribute is intended for marking special items that are built-in to
Rust itself. This includes special traits (like `Copy` and `Sized`) that affect
how the compiler behaves, as well as special functions that may be automatically
invoked (such as the handler for out-of-bounds accesses when indexing a slice).
Erroneous code example:
```compile_fail,E0522
#![feature(lang_items)]
#[lang = "cookie"]
fn cookie() -> ! { // error: definition of an unknown language item: `cookie`
    loop {}
E0045
Rust only supports variadic parameters for interoperability with C code in its
FFI. As such, variadic parameters can only be used with functions which are
using the C ABI. Examples of erroneous code:
```compile_fail
extern "rust-call" { fn foo(x: u8, ...); }
// or
fn foo(x: u8, ...) {}
To fix such code, put them in an extern "C" block:
```ignore
extern "C" fn foo(x: u8, ...);
extern "C" {
    fn foo (x: u8, ...);
E0211
You used a function or type which doesn't fit the requirements for where it was
used. Erroneous code examples:
```compile_fail
#![feature(intrinsics)]
extern "rust-intrinsic" {
    fn size_of<T>(); // error: intrinsic has wrong type
// or:
fn main() -> i32 { 0 }
// error: main function expects type: `fn() {main}`: expected (), found i32
// or:
let x = 1u8;
match x {
    0u8...3i8 => (),
    // error: mismatched types in range: expected u8, found i8
    _ => ()
// or:
use std::rc::Rc;
struct Foo;
impl Foo {
    fn x(self: Rc<Foo>) {}
    // error: mismatched self type: expected `Foo`: expected struct
    //        `Foo`, found struct `alloc::rc::Rc`
For the first code example, please check the function definition. Example:
#![feature(intrinsics)]
extern "rust-intrinsic" {
    fn size_of<T>() -> usize; // ok!
The second case example is a bit particular : the main function must always
have this definition:
```compile_fail
fn main();
They never take parameters and never return types.
For the third example, when you match, all patterns must have the same type
as the type you're matching on. Example:
let x = 1u8;
match x {
    0u8...3u8 => (), // ok!
    _ => ()
And finally, for the last example, only `Box<Self>`, `&Self`, `Self`,
or `&mut Self` work as explicit self parameters. Example:
struct Foo;
impl Foo {
    fn x(self: Box<Foo>) {} // ok!
E0131
It is not possible to define `main` with type parameters, or even with function
parameters. When `main` is present, it must take no arguments and return `()`.
Erroneous code example:
```compile_fail
fn main<T>() { // error: main function is not allowed to have type parameters
E0132
A function with the `start` attribute was declared with type parameters.
Erroneous code example:
```compile_fail
#![feature(start)]
#[start]
fn f<T>() {}
It is not possible to declare type parameters on a function that has the `start`
attribute. Such a function must have the following type signature (for more
information: http://doc.rust-lang.org/stable/book/no-stdlib.html):
```ignore
fn(isize, *const *const u8) -> isize;
Example:
#![feature(start)]
#[start]
fn my_start(argc: isize, argv: *const *const u8) -> isize {
    0
E0023
A pattern used to match against an enum variant must provide a sub-pattern for
each field of the enum variant. This error indicates that a pattern attempted to
extract an incorrect number of fields from a variant.
enum Fruit {
    Apple(String, String),
    Pear(u32),
Here the `Apple` variant has two fields, and should be matched against like so:
enum Fruit {
    Apple(String, String),
    Pear(u32),
let x = Fruit::Apple(String::new(), String::new());
// Correct.
match x {
    Fruit::Apple(a, b) => {},
    _ => {}
Matching with the wrong number of fields has no sensible interpretation:
```compile_fail
enum Fruit {
    Apple(String, String),
    Pear(u32),
let x = Fruit::Apple(String::new(), String::new());
// Incorrect.
match x {
    Fruit::Apple(a) => {},
    Fruit::Apple(a, b, c) => {},
Check how many fields the enum was declared with and ensure that your pattern
uses the same number.
E0025
Each field of a struct can only be bound once in a pattern. Erroneous code
example:
```compile_fail
struct Foo {
    a: u8,
    b: u8,
fn main(){
    let x = Foo { a:1, b:2 };
    let Foo { a: x, a: y } = x;
    // error: field `a` bound multiple times in the pattern
Each occurrence of a field name binds the value of that field, so to fix this
error you will have to remove or alter the duplicate uses of the field name.
Perhaps you misspelled another field name? Example:
struct Foo {
    a: u8,
    b: u8,
fn main(){
    let x = Foo { a:1, b:2 };
    let Foo { a: x, b: y } = x; // ok!
E0026
This error indicates that a struct pattern attempted to extract a non-existent
field from a struct. Struct fields are identified by the name used before the
colon `:` so struct patterns should resemble the declaration of the struct type
being matched.
// Correct matching.
struct Thing {
    x: u32,
    y: u32
let thing = Thing { x: 1, y: 2 };
match thing {
    Thing { x: xfield, y: yfield } => {}
If you are using shorthand field patterns but want to refer to the struct field
by a different name, you should rename it explicitly.
Change this:
```compile_fail
struct Thing {
    x: u32,
    y: u32
let thing = Thing { x: 0, y: 0 };
match thing {
    Thing { x, z } => {}
To this:
struct Thing {
    x: u32,
    y: u32
let thing = Thing { x: 0, y: 0 };
match thing {
    Thing { x, y: z } => {}
E0027
This error indicates that a pattern for a struct fails to specify a sub-pattern
for every one of the struct's fields. Ensure that each field from the struct's
definition is mentioned in the pattern, or use `..` to ignore unwanted fields.
For example:
```compile_fail
struct Dog {
    name: String,
    age: u32,
let d = Dog { name: "Rusty".to_string(), age: 8 };
// This is incorrect.
match d {
    Dog { age: x } => {}
This is correct (explicit):
struct Dog {
    name: String,
    age: u32,
let d = Dog { name: "Rusty".to_string(), age: 8 };
match d {
    Dog { name: ref n, age: x } => {}
// This is also correct (ignore unused fields).
match d {
    Dog { age: x, .. } => {}
E0029
In a match expression, only numbers and characters can be matched against a
range. This is because the compiler checks that the range is non-empty at
compile-time, and is unable to evaluate arbitrary comparison functions. If you
want to capture values of an orderable type between two end-points, you can use
a guard.
```compile_fail
// The ordering relation for strings can't be evaluated at compile time,
// so this doesn't work:
match string {
    "hello" ... "world" => {}
    _ => {}
// This is a more general version, using a guard:
match string {
    s if s >= "hello" && s <= "world" => {}
    _ => {}
E0033
This error indicates that a pointer to a trait type cannot be implicitly
dereferenced by a pattern. Every trait defines a type, but because the
size of trait implementors isn't fixed, this type has no compile-time size.
Therefore, all accesses to trait types must be through pointers. If you
encounter this error you should try to avoid dereferencing the pointer.
```ignore
let trait_obj: &SomeTrait = ...;
// This tries to implicitly dereference to create an unsized local variable.
let &invalid = trait_obj;
// You can call methods without binding to the value being pointed at.
trait_obj.method_one();
trait_obj.method_two();
You can read more about trait objects in the Trait Object section of the
Reference:
https://doc.rust-lang.org/reference.html#trait-objects
E0034
The compiler doesn't know what method to call because more than one method
has the same prototype. Erroneous code example:
```compile_fail
struct Test;
trait Trait1 {
    fn foo();
trait Trait2 {
    fn foo();
impl Trait1 for Test { fn foo() {} }
impl Trait2 for Test { fn foo() {} }
fn main() {
    Test::foo() // error, which foo() to call?
To avoid this error, you have to keep only one of them and remove the others.
So let's take our example and fix it:
struct Test;
trait Trait1 {
    fn foo();
impl Trait1 for Test { fn foo() {} }
fn main() {
    Test::foo() // and now that's good!
However, a better solution would be using fully explicit naming of type and
trait:
struct Test;
trait Trait1 {
    fn foo();
trait Trait2 {
    fn foo();
impl Trait1 for Test { fn foo() {} }
impl Trait2 for Test { fn foo() {} }
fn main() {
    <Test as Trait1>::foo()
One last example:
trait F {
    fn m(&self);
trait G {
    fn m(&self);
struct X;
impl F for X { fn m(&self) { println!("I am F"); } }
impl G for X { fn m(&self) { println!("I am G"); } }
fn main() {
    let f = X;
    F::m(&f); // it displays "I am F"
    G::m(&f); // it displays "I am G"
E0035
You tried to give a type parameter where it wasn't needed. Erroneous code
example:
```compile_fail
struct Test;
impl Test {
    fn method(&self) {}
fn main() {
    let x = Test;
    x.method::<i32>(); // Error: Test::method doesn't need type parameter!
To fix this error, just remove the type parameter:
struct Test;
impl Test {
    fn method(&self) {}
fn main() {
    let x = Test;
    x.method(); // OK, we're good!
E0036
This error occurrs when you pass too many or not enough type parameters to
a method. Erroneous code example:
```compile_fail
struct Test;
impl Test {
    fn method<T>(&self, v: &[T]) -> usize {
        v.len()
    }
fn main() {
    let x = Test;
    let v = &[0];
    x.method::<i32, i32>(v); // error: only one type parameter is expected!
To fix it, just specify a correct number of type parameters:
struct Test;
impl Test {
    fn method<T>(&self, v: &[T]) -> usize {
        v.len()
    }
fn main() {
    let x = Test;
    let v = &[0];
    x.method::<i32>(v); // OK, we're good!
Please note on the last example that we could have called `method` like this:
```ignore
x.method(v);
E0040
It is not allowed to manually call destructors in Rust. It is also not
necessary to do this since `drop` is called automatically whenever a value goes
out of scope.
Here's an example of this error:
```compile_fail
struct Foo {
    x: i32,
impl Drop for Foo {
    fn drop(&mut self) {
        println!("kaboom");
    }
fn main() {
    let mut x = Foo { x: -7 };
    x.drop(); // error: explicit use of destructor method
E0044
You can't use type parameters on foreign items. Example of erroneous code:
```compile_fail
extern { fn some_func<T>(x: T); }
To fix this, replace the type parameter with the specializations that you
need:
extern { fn some_func_i32(x: i32); }
extern { fn some_func_i64(x: i64); }
E0046
Items are missing in a trait implementation. Erroneous code example:
```compile_fail
trait Foo {
    fn foo();
struct Bar;
impl Foo for Bar {}
// error: not all trait items implemented, missing: `foo`
When trying to make some type implement a trait `Foo`, you must, at minimum,
provide implementations for all of `Foo`'s required methods (meaning the
methods that do not have default implementations), as well as any required
trait items like associated types or constants. Example:
trait Foo {
    fn foo();
struct Bar;
impl Foo for Bar {
    fn foo() {} // ok!
E0049
This error indicates that an attempted implementation of a trait method
has the wrong number of type parameters.
For example, the trait below has a method `foo` with a type parameter `T`,
but the implementation of `foo` for the type `Bar` is missing this parameter:
```compile_fail
trait Foo {
    fn foo<T: Default>(x: T) -> Self;
struct Bar;
// error: method `foo` has 0 type parameters but its trait declaration has 1
// type parameter
impl Foo for Bar {
    fn foo(x: bool) -> Self { Bar }
E0050
This error indicates that an attempted implementation of a trait method
has the wrong number of function parameters.
For example, the trait below has a method `foo` with two function parameters
(`&self` and `u8`), but the implementation of `foo` for the type `Bar` omits
the `u8` parameter:
```compile_fail
trait Foo {
    fn foo(&self, x: u8) -> bool;
struct Bar;
// error: method `foo` has 1 parameter but the declaration in trait `Foo::foo`
// has 2
impl Foo for Bar {
    fn foo(&self) -> bool { true }
E0053
The parameters of any trait method must match between a trait implementation
and the trait definition.
Here are a couple examples of this error:
```compile_fail
trait Foo {
    fn foo(x: u16);
    fn bar(&self);
struct Bar;
impl Foo for Bar {
    // error, expected u16, found i16
    fn foo(x: i16) { }
    // error, values differ in mutability
    fn bar(&mut self) { }
E0054
It is not allowed to cast to a bool. If you are trying to cast a numeric type
to a bool, you can compare it with zero instead:
```compile_fail
let x = 5;
// Not allowed, won't compile
let x_is_nonzero = x as bool;
let x = 5;
// Ok
let x_is_nonzero = x != 0;
E0055
During a method call, a value is automatically dereferenced as many times as
needed to make the value's type match the method's receiver. The catch is that
the compiler will only attempt to dereference a number of times up to the
recursion limit (which can be set via the `recursion_limit` attribute).
For a somewhat artificial example:
```compile_fail,ignore
#![recursion_limit="2"]
struct Foo;
impl Foo {
    fn foo(&self) {}
fn main() {
    let foo = Foo;
    let ref_foo = &&Foo;
    // error, reached the recursion limit while auto-dereferencing &&Foo
    ref_foo.foo();
One fix may be to increase the recursion limit. Note that it is possible to
create an infinite recursion of dereferencing, in which case the only fix is to
somehow break the recursion.
E0057
When invoking closures or other implementations of the function traits `Fn`,
`FnMut` or `FnOnce` using call notation, the number of parameters passed to the
function must match its definition.
An example using a closure:
```compile_fail
let f = |x| x * 3;
let a = f();        // invalid, too few parameters
let b = f(4);       // this works!
let c = f(2, 3);    // invalid, too many parameters
A generic function must be treated similarly:
fn foo<F: Fn()>(f: F) {
    f(); // this is valid, but f(3) would not work
E0059
The built-in function traits are generic over a tuple of the function arguments.
If one uses angle-bracket notation (`Fn<(T,), Output=U>`) instead of parentheses
(`Fn(T) -> U`) to denote the function trait, the type parameter should be a
tuple. Otherwise function call notation cannot be used and the trait will not be
implemented by closures.
The most likely source of this error is using angle-bracket notation without
wrapping the function argument type into a tuple, for example:
```compile_fail
fn foo<F: Fn<i32>>(f: F) -> F::Output { f(3) }
It can be fixed by adjusting the trait bound like this:
```ignore
fn foo<F: Fn<(i32,)>>(f: F) -> F::Output { f(3) }
Note that `(T,)` always denotes the type of a 1-tuple containing an element of
type `T`. The comma is necessary for syntactic disambiguation.
E0060
External C functions are allowed to be variadic. However, a variadic function
takes a minimum number of arguments. For example, consider C's variadic `printf`
function:
```ignore
extern crate libc;
use libc::{ c_char, c_int };
extern "C" {
    fn printf(_: *const c_char, ...) -> c_int;
Using this declaration, it must be called with at least one argument, so
simply calling `printf()` is invalid. But the following uses are allowed:
```ignore
unsafe {
    use std::ffi::CString;
    printf(CString::new("test\n").unwrap().as_ptr());
    printf(CString::new("number = %d\n").unwrap().as_ptr(), 3);
    printf(CString::new("%d, %d\n").unwrap().as_ptr(), 10, 5);
E0061
The number of arguments passed to a function must match the number of arguments
specified in the function signature.
For example, a function like:
fn f(a: u16, b: &str) {}
Must always be called with exactly two arguments, e.g. `f(2, "test")`.
Note that Rust does not have a notion of optional function arguments or
variadic functions (except for its C-FFI).
E0062
This error indicates that during an attempt to build a struct or struct-like
enum variant, one of the fields was specified more than once. Erroneous code
example:
```compile_fail
struct Foo {
    x: i32
fn main() {
    let x = Foo {
                x: 0,
                x: 0, // error: field `x` specified more than once
            };
Each field should be specified exactly one time. Example:
struct Foo {
    x: i32
fn main() {
    let x = Foo { x: 0 }; // ok!
E0063
This error indicates that during an attempt to build a struct or struct-like
enum variant, one of the fields was not provided. Erroneous code example:
```compile_fail
struct Foo {
    x: i32,
    y: i32
fn main() {
    let x = Foo { x: 0 }; // error: missing field: `y`
Each field should be specified exactly once. Example:
struct Foo {
    x: i32,
    y: i32
fn main() {
    let x = Foo { x: 0, y: 0 }; // ok!
E0066
Box placement expressions (like C++'s "placement new") do not yet support any
place expression except the exchange heap (i.e. `std::boxed::HEAP`).
Furthermore, the syntax is changing to use `in` instead of `box`. See [RFC 470]
and [RFC 809] for more details.
[RFC 470]: https://github.com/rust-lang/rfcs/pull/470
[RFC 809]: https://github.com/rust-lang/rfcs/pull/809
E0067
The left-hand side of a compound assignment expression must be an lvalue
expression. An lvalue expression represents a memory location and includes
item paths (ie, namespaced variables), dereferences, indexing expressions,
and field references.
Let's start with some erroneous code examples:
```compile_fail
use std::collections::LinkedList;
// Bad: assignment to non-lvalue expression
LinkedList::new() += 1;
// ...
fn some_func(i: &mut i32) {
    i += 12; // Error : '+=' operation cannot be applied on a reference !
And now some working examples:
let mut i : i32 = 0;
i += 12; // Good !
// ...
fn some_func(i: &mut i32) {
    *i += 12; // Good !
E0069
The compiler found a function whose body contains a `return;` statement but
whose return type is not `()`. An example of this is:
```compile_fail
// error
fn foo() -> u8 {
    return;
Since `return;` is just like `return ();`, there is a mismatch between the
function's return type and the value being returned.
E0070
The left-hand side of an assignment operator must be an lvalue expression. An
lvalue expression represents a memory location and can be a variable (with
optional namespacing), a dereference, an indexing expression or a field
reference.
More details can be found here:
https://doc.rust-lang.org/reference.html#lvalues-rvalues-and-temporaries
Now, we can go further. Here are some erroneous code examples:
```compile_fail
struct SomeStruct {
    x: i32,
    y: i32
const SOME_CONST : i32 = 12;
fn some_other_func() {}
fn some_function() {
    SOME_CONST = 14; // error : a constant value cannot be changed!
    1 = 3; // error : 1 isn't a valid lvalue!
    some_other_func() = 4; // error : we can't assign value to a function!
    SomeStruct.x = 12; // error : SomeStruct a structure name but it is used
                       // like a variable!
And now let's give working examples:
struct SomeStruct {
    x: i32,
    y: i32
let mut s = SomeStruct {x: 0, y: 0};
s.x = 3; // that's good !
// ...
fn some_func(x: &mut i32) {
    *x = 12; // that's good !
E0071
You tried to use structure-literal syntax to create an item that is
not a struct-style structure or enum variant.
Example of erroneous code:
```compile_fail
enum Foo { FirstValue(i32) };
let u = Foo::FirstValue { value: 0 }; // error: Foo::FirstValue
                                         // isn't a structure!
// or even simpler, if the name doesn't refer to a structure at all.
let t = u32 { value: 4 }; // error: `u32` does not name a structure.
To fix this, ensure that the name was correctly spelled, and that
the correct form of initializer was used.
For example, the code above can be fixed to:
enum Foo {
    FirstValue(i32)
fn main() {
    let u = Foo::FirstValue(0i32);
    let t = 4;
E0073
You cannot define a struct (or enum) `Foo` that requires an instance of `Foo`
in order to make a new `Foo` value. This is because there would be no way a
first instance of `Foo` could be made to initialize another instance!
Here's an example of a struct that has this problem:
```ignore
struct Foo { x: Box<Foo> } // error
One fix is to use `Option`, like so:
struct Foo { x: Option<Box<Foo>> }
Now it's possible to create at least one instance of `Foo`: `Foo { x: None }`.
E0074
When using the `#[simd]` attribute on a tuple struct, the components of the
tuple struct must all be of a concrete, nongeneric type so the compiler can
reason about how to use SIMD with them. This error will occur if the types
are generic.
This will cause an error:
```ignore
#![feature(repr_simd)]
#[repr(simd)]
struct Bad<T>(T, T, T);
This will not:
#![feature(repr_simd)]
#[repr(simd)]
struct Good(u32, u32, u32);
E0075
The `#[simd]` attribute can only be applied to non empty tuple structs, because
it doesn't make sense to try to use SIMD operations when there are no values to
operate on.
This will cause an error:
```compile_fail
#![feature(repr_simd)]
#[repr(simd)]
struct Bad;
This will not:
#![feature(repr_simd)]
#[repr(simd)]
struct Good(u32);
E0076
When using the `#[simd]` attribute to automatically use SIMD operations in tuple
struct, the types in the struct must all be of the same type, or the compiler
will trigger this error.
This will cause an error:
```compile_fail
#![feature(repr_simd)]
#[repr(simd)]
struct Bad(u16, u32, u32);
This will not:
#![feature(repr_simd)]
#[repr(simd)]
struct Good(u32, u32, u32);
E0077
When using the `#[simd]` attribute on a tuple struct, the elements in the tuple
must be machine types so SIMD operations can be applied to them.
This will cause an error:
```compile_fail
#![feature(repr_simd)]
#[repr(simd)]
struct Bad(String);
This will not:
#![feature(repr_simd)]
#[repr(simd)]
struct Good(u32, u32, u32);
E0079
Enum variants which contain no data can be given a custom integer
representation. This error indicates that the value provided is not an integer
literal and is therefore invalid.
For example, in the following code:
```compile_fail
enum Foo {
    Q = "32"
We try to set the representation to a string.
There's no general fix for this; if you can work with an integer then just set
it to one:
enum Foo {
    Q = 32
However if you actually wanted a mapping between variants and non-integer
objects, it may be preferable to use a method with a match instead:
enum Foo { Q }
impl Foo {
    fn get_str(&self) -> &'static str {
        match *self {
            Foo::Q => "32",
        }
    }
E0080
This error indicates that the compiler was unable to sensibly evaluate an
integer expression provided as an enum discriminant. Attempting to divide by 0
or causing integer overflow are two ways to induce this error. For example:
```compile_fail
enum Enum {
    X = (1 << 500),
    Y = (1 / 0)
Ensure that the expressions given can be evaluated as the desired integer type.
See the FFI section of the Reference for more information about using a custom
integer type:
https://doc.rust-lang.org/reference.html#ffi-attributes
E0081
Enum discriminants are used to differentiate enum variants stored in memory.
This error indicates that the same value was used for two or more variants,
making them impossible to tell apart.
```compile_fail
// Bad.
enum Enum {
    P = 3,
    X = 3,
    Y = 5
// Good.
enum Enum {
    P,
    X = 3,
    Y = 5
Note that variants without a manually specified discriminant are numbered from
top to bottom starting from 0, so clashes can occur with seemingly unrelated
variants.
```compile_fail
enum Bad {
    X,
    Y = 0
Here `X` will have already been specified the discriminant 0 by the time `Y` is
encountered, so a conflict occurs.
E0082
When you specify enum discriminants with `=`, the compiler expects `isize`
values by default. Or you can add the `repr` attibute to the enum declaration
for an explicit choice of the discriminant type. In either cases, the
discriminant values must fall within a valid range for the expected type;
otherwise this error is raised. For example:
```ignore
#[repr(u8)]
enum Thing {
    A = 1024,
    B = 5
Here, 1024 lies outside the valid range for `u8`, so the discriminant for `A` is
invalid. Here is another, more subtle example which depends on target word size:
```ignore
enum DependsOnPointerSize {
    A = 1 << 32
Here, `1 << 32` is interpreted as an `isize` value. So it is invalid for 32 bit
target (`target_pointer_width = "32"`) but valid for 64 bit target.
You may want to change representation types to fix this, or else change invalid
discriminant values so that they fit within the existing type.
E0084
An unsupported representation was attempted on a zero-variant enum.
Erroneous code example:
```compile_fail
#[repr(i32)]
enum NightsWatch {} // error: unsupported representation for zero-variant enum
It is impossible to define an integer type to be used to represent zero-variant
enum values because there are no zero-variant enum values. There is no way to
construct an instance of the following type using only safe code. So you have
two solutions. Either you add variants in your enum:
#[repr(i32)]
enum NightsWatch {
    JonSnow,
    Commander,
or you remove the integer represention of your enum:
enum NightsWatch {}
E0087
Too many type parameters were supplied for a function. For example:
```compile_fail
fn foo<T>() {}
fn main() {
    foo::<f64, bool>(); // error, expected 1 parameter, found 2 parameters
The number of supplied parameters must exactly match the number of defined type
parameters.
E0088
You gave too many lifetime parameters. Erroneous code example:
```compile_fail
fn f() {}
fn main() {
    f::<'static>() // error: too many lifetime parameters provided
Please check you give the right number of lifetime parameters. Example:
fn f() {}
fn main() {
    f() // ok!
It's also important to note that the Rust compiler can generally
determine the lifetime by itself. Example:
struct Foo {
    value: String
impl Foo {
    // it can be written like this
    fn get_value<'a>(&'a self) -> &'a str { &self.value }
    // but the compiler works fine with this too:
    fn without_lifetime(&self) -> &str { &self.value }
fn main() {
    let f = Foo { value: "hello".to_owned() };
    println!("{}", f.get_value());
    println!("{}", f.without_lifetime());
E0089
Not enough type parameters were supplied for a function. For example:
```compile_fail
fn foo<T, U>() {}
fn main() {
    foo::<f64>(); // error, expected 2 parameters, found 1 parameter
Note that if a function takes multiple type parameters but you want the compiler
to infer some of them, you can use type placeholders:
```compile_fail
fn foo<T, U>(x: T) {}
fn main() {
    let x: bool = true;
    foo::<f64>(x);    // error, expected 2 parameters, found 1 parameter
    foo::<_, f64>(x); // same as `foo::<bool, f64>(x)`
E0091
You gave an unnecessary type parameter in a type alias. Erroneous code
example:
```compile_fail
type Foo<T> = u32; // error: type parameter `T` is unused
// or:
type Foo<A,B> = Box<A>; // error: type parameter `B` is unused
Please check you didn't write too many type parameters. Example:
type Foo = u32; // ok!
type Foo2<A> = Box<A>; // ok!
E0092
You tried to declare an undefined atomic operation function.
Erroneous code example:
```compile_fail
#![feature(intrinsics)]
extern "rust-intrinsic" {
    fn atomic_foo(); // error: unrecognized atomic operation
                     //        function
Please check you didn't make a mistake in the function's name. All intrinsic
functions are defined in librustc_trans/trans/intrinsic.rs and in
libcore/intrinsics.rs in the Rust source code. Example:
#![feature(intrinsics)]
extern "rust-intrinsic" {
    fn atomic_fence(); // ok!
E0093
You declared an unknown intrinsic function. Erroneous code example:
```compile_fail
#![feature(intrinsics)]
extern "rust-intrinsic" {
    fn foo(); // error: unrecognized intrinsic function: `foo`
fn main() {
    unsafe {
        foo();
    }
Please check you didn't make a mistake in the function's name. All intrinsic
functions are defined in librustc_trans/trans/intrinsic.rs and in
libcore/intrinsics.rs in the Rust source code. Example:
#![feature(intrinsics)]
extern "rust-intrinsic" {
    fn atomic_fence(); // ok!
fn main() {
    unsafe {
        atomic_fence();
    }
E0094
You gave an invalid number of type parameters to an intrinsic function.
Erroneous code example:
```compile_fail
#![feature(intrinsics)]
extern "rust-intrinsic" {
    fn size_of<T, U>() -> usize; // error: intrinsic has wrong number
                                 //        of type parameters
Please check that you provided the right number of lifetime parameters
and verify with the function declaration in the Rust source code.
Example:
#![feature(intrinsics)]
extern "rust-intrinsic" {
    fn size_of<T>() -> usize; // ok!
E0101
You hit this error because the compiler lacks the information to
determine a type for this expression. Erroneous code example:
```compile_fail
fn main() {
    let x = |_| {}; // error: cannot determine a type for this expression
You have two possibilities to solve this situation:
 * Give an explicit definition of the expression
 * Infer the expression
Examples:
fn main() {
    let x = |_ : u32| {}; // ok!
    // or:
    let x = |_| {};
    x(0u32);
E0102
You hit this error because the compiler lacks the information to
determine the type of this variable. Erroneous code example:
```compile_fail
fn main() {
    // could be an array of anything
    let x = []; // error: cannot determine a type for this local variable
To solve this situation, constrain the type of the variable.
Examples:
#![allow(unused_variables)]
fn main() {
    let x: [u8; 0] = [];
E0106
This error indicates that a lifetime is missing from a type. If it is an error
inside a function signature, the problem may be with failing to adhere to the
lifetime elision rules (see below).
Here are some simple examples of where you'll run into this error:
```compile_fail
struct Foo { x: &bool }        // error
struct Foo<'a> { x: &'a bool } // correct
enum Bar { A(u8), B(&bool), }        // error
enum Bar<'a> { A(u8), B(&'a bool), } // correct
type MyStr = &str;        // error
type MyStr<'a> = &'a str; // correct
Lifetime elision is a special, limited kind of inference for lifetimes in
function signatures which allows you to leave out lifetimes in certain cases.
For more background on lifetime elision see [the book][book-le].
The lifetime elision rules require that any function signature with an elided
output lifetime must either have
 - exactly one input lifetime
 - or, multiple input lifetimes, but the function must also be a method with a
   `&self` or `&mut self` receiver
In the first case, the output lifetime is inferred to be the same as the unique
input lifetime. In the second case, the lifetime is instead inferred to be the
same as the lifetime on `&self` or `&mut self`.
Here are some examples of elision errors:
```compile_fail
// error, no input lifetimes
fn foo() -> &str { }
// error, `x` and `y` have distinct lifetimes inferred
fn bar(x: &str, y: &str) -> &str { }
// error, `y`'s lifetime is inferred to be distinct from `x`'s
fn baz<'a>(x: &'a str, y: &str) -> &str { }
[book-le]: https://doc.rust-lang.org/nightly/book/lifetimes.html#lifetime-elision
E0107
This error means that an incorrect number of lifetime parameters were provided
for a type (like a struct or enum) or trait.
Some basic examples include:
```compile_fail
struct Foo<'a>(&'a str);
enum Bar { A, B, C }
struct Baz<'a> {
    foo: Foo,     // error: expected 1, found 0
    bar: Bar<'a>, // error: expected 0, found 1
Here's an example that is currently an error, but may work in a future version
of Rust:
```compile_fail
struct Foo<'a>(&'a str);
trait Quux { }
impl Quux for Foo { } // error: expected 1, found 0
Lifetime elision in implementation headers was part of the lifetime elision
RFC. It is, however, [currently unimplemented][iss15872].
[iss15872]: https://github.com/rust-lang/rust/issues/15872
E0116
You can only define an inherent implementation for a type in the same crate
where the type was defined. For example, an `impl` block as below is not allowed
since `Vec` is defined in the standard library:
```compile_fail
impl Vec<u8> { } // error
To fix this problem, you can do either of these things:
 - define a trait that has the desired associated functions/types/constants and
   implement the trait for the type in question
 - define a new type wrapping the type and define an implementation on the new
   type
Note that using the `type` keyword does not work here because `type` only
introduces a type alias:
```compile_fail
type Bytes = Vec<u8>;
impl Bytes { } // error, same as above
E0117
This error indicates a violation of one of Rust's orphan rules for trait
implementations. The rule prohibits any implementation of a foreign trait (a
trait defined in another crate) where
 - the type that is implementing the trait is foreign
 - all of the parameters being passed to the trait (if there are any) are also
   foreign.
Here's one example of this error:
```compile_fail
impl Drop for u32 {}
To avoid this kind of error, ensure that at least one local type is referenced
by the `impl`:
```ignore
pub struct Foo; // you define your type in your crate
impl Drop for Foo { // and you can implement the trait on it!
    // code of trait implementation here
impl From<Foo> for i32 { // or you use a type from your crate as
                         // a type parameter
    fn from(i: Foo) -> i32 {
        0
    }
Alternatively, define a trait locally and implement that instead:
trait Bar {
    fn get(&self) -> usize;
impl Bar for u32 {
    fn get(&self) -> usize { 0 }
For information on the design of the orphan rules, see [RFC 1023].
[RFC 1023]: https://github.com/rust-lang/rfcs/pull/1023
E0118
You're trying to write an inherent implementation for something which isn't a
struct nor an enum. Erroneous code example:
```compile_fail
impl (u8, u8) { // error: no base type found for inherent implementation
    fn get_state(&self) -> String {
        // ...
    }
To fix this error, please implement a trait on the type or wrap it in a struct.
Example:
// we create a trait here
trait LiveLongAndProsper {
    fn get_state(&self) -> String;
// and now you can implement it on (u8, u8)
impl LiveLongAndProsper for (u8, u8) {
    fn get_state(&self) -> String {
        "He's dead, Jim!".to_owned()
    }
Alternatively, you can create a newtype. A newtype is a wrapping tuple-struct.
For example, `NewType` is a newtype over `Foo` in `struct NewType(Foo)`.
Example:
struct TypeWrapper((u8, u8));
impl TypeWrapper {
    fn get_state(&self) -> String {
        "Fascinating!".to_owned()
    }
E0119
There are conflicting trait implementations for the same type.
Example of erroneous code:
```compile_fail
trait MyTrait {
    fn get(&self) -> usize;
impl<T> MyTrait for T {
    fn get(&self) -> usize { 0 }
struct Foo {
    value: usize
impl MyTrait for Foo { // error: conflicting implementations of trait
                       //        `MyTrait` for type `Foo`
    fn get(&self) -> usize { self.value }
When looking for the implementation for the trait, the compiler finds
both the `impl<T> MyTrait for T` where T is all types and the `impl
MyTrait for Foo`. Since a trait cannot be implemented multiple times,
this is an error. So, when you write:
trait MyTrait {
    fn get(&self) -> usize;
impl<T> MyTrait for T {
    fn get(&self) -> usize { 0 }
This makes the trait implemented on all types in the scope. So if you
try to implement it on another one after that, the implementations will
conflict. Example:
trait MyTrait {
    fn get(&self) -> usize;
impl<T> MyTrait for T {
    fn get(&self) -> usize { 0 }
struct Foo;
fn main() {
    let f = Foo;
    f.get(); // the trait is implemented so we can use it
E0120
An attempt was made to implement Drop on a trait, which is not allowed: only
structs and enums can implement Drop. An example causing this error:
```compile_fail
trait MyTrait {}
impl Drop for MyTrait {
    fn drop(&mut self) {}
A workaround for this problem is to wrap the trait up in a struct, and implement
Drop on that. An example is shown below:
trait MyTrait {}
struct MyWrapper<T: MyTrait> { foo: T }
impl <T: MyTrait> Drop for MyWrapper<T> {
    fn drop(&mut self) {}
Alternatively, wrapping trait objects requires something like the following:
trait MyTrait {}
//or Box<MyTrait>, if you wanted an owned trait object
struct MyWrapper<'a> { foo: &'a MyTrait }
impl <'a> Drop for MyWrapper<'a> {
    fn drop(&mut self) {}
E0121
In order to be consistent with Rust's lack of global type inference, type
placeholders are disallowed by design in item signatures.
Examples of this error include:
```compile_fail
fn foo() -> _ { 5 } // error, explicitly write out the return type instead
static BAR: _ = "test"; // error, explicitly write out the type instead
E0122
An attempt was made to add a generic constraint to a type alias. While Rust will
allow this with a warning, it will not currently enforce the constraint.
Consider the example below:
trait Foo{}
type MyType<R: Foo> = (R, ());
fn main() {
    let t: MyType<u32>;
We're able to declare a variable of type `MyType<u32>`, despite the fact that
`u32` does not implement `Foo`. As a result, one should avoid using generic
constraints in concert with type aliases.
E0124
You declared two fields of a struct with the same name. Erroneous code
example:
```compile_fail
struct Foo {
    field1: i32,
    field1: i32, // error: field is already declared
Please verify that the field names have been correctly spelled. Example:
struct Foo {
    field1: i32,
    field2: i32, // ok!
E0128
Type parameter defaults can only use parameters that occur before them.
Erroneous code example:
```compile_fail
struct Foo<T=U, U=()> {
    field1: T,
    filed2: U,
// error: type parameters with a default cannot use forward declared
// identifiers
Since type parameters are evaluated in-order, you may be able to fix this issue
by doing:
struct Foo<U=(), T=U> {
    field1: T,
    filed2: U,
Please also verify that this wasn't because of a name-clash and rename the type
parameter if so.
E0130
You declared a pattern as an argument in a foreign function declaration.
Erroneous code example:
```compile_fail
extern {
    fn foo((a, b): (u32, u32)); // error: patterns aren't allowed in foreign
                                //        function declarations
Please replace the pattern argument with a regular one. Example:
struct SomeStruct {
    a: u32,
    b: u32,
extern {
    fn foo(s: SomeStruct); // ok!
extern {
    fn foo(a: (u32, u32)); // ok!
E0163
This error means that an attempt was made to match an enum variant as a
struct type when the variant isn't a struct type:
```compile_fail
enum Foo { B(u32) }
fn bar(foo: Foo) -> u32 {
    match foo {
        B{i} => i, // error E0163
    }
Try using `()` instead:
enum Foo { B(u32) }
fn bar(foo: Foo) -> u32 {
    match foo {
        Foo::B(i) => i,
    }
E0164
This error means that an attempt was made to match a struct type enum
variant as a non-struct type:
```compile_fail
enum Foo { B { i: u32 } }
fn bar(foo: Foo) -> u32 {
    match foo {
        Foo::B(i) => i, // error E0164
    }
Try using `{}` instead:
enum Foo { B { i: u32 } }
fn bar(foo: Foo) -> u32 {
    match foo {
        Foo::B{i} => i,
    }
E0166
This error means that the compiler found a return expression in a function
marked as diverging. A function diverges if it has `!` in the place of the
return type in its signature. For example:
```compile_fail
fn foo() -> ! { return; } // error
For a function that diverges, every control path in the function must never
return, for example with a `loop` that never breaks or a call to another
diverging function (such as `panic!()`).
E0172
This error means that an attempt was made to specify the type of a variable with
a combination of a concrete type and a trait. Consider the following example:
```compile_fail
fn foo(bar: i32+std::fmt::Display) {}
The code is trying to specify that we want to receive a signed 32-bit integer
which also implements `Display`. This doesn't make sense: when we pass `i32`, a
concrete type, it implicitly includes all of the traits that it implements.
This includes `Display`, `Debug`, `Clone`, and a host of others.
If `i32` implements the trait we desire, there's no need to specify the trait
separately. If it does not, then we need to `impl` the trait for `i32` before
passing it into `foo`. Either way, a fixed definition for `foo` will look like
the following:
fn foo(bar: i32) {}
To learn more about traits, take a look at the Book:
https://doc.rust-lang.org/book/traits.html
E0174
This error occurs because of the explicit use of unboxed closure methods
that are an experimental feature in current Rust version.
Example of erroneous code:
```compile_fail
fn foo<F: Fn(&str)>(mut f: F) {
    f.call(("call",));
    // error: explicit use of unboxed closure method `call`
    f.call_mut(("call_mut",));
    // error: explicit use of unboxed closure method `call_mut`
    f.call_once(("call_once",));
    // error: explicit use of unboxed closure method `call_once`
fn bar(text: &str) {
    println!("Calling {} it works!", text);
fn main() {
    foo(bar);
Rust's implementation of closures is a bit different than other languages.
They are effectively syntax sugar for traits `Fn`, `FnMut` and `FnOnce`.
To understand better how the closures are implemented see here:
https://doc.rust-lang.org/book/closures.html#closure-implementation
To fix this you can call them using parenthesis, like this: `foo()`.
When you execute the closure with parenthesis, under the hood you are executing
the method `call`, `call_mut` or `call_once`. However, using them explicitly is
currently an experimental feature.
Example of an implicit call:
fn foo<F: Fn(&str)>(f: F) {
    f("using ()"); // Calling using () it works!
fn bar(text: &str) {
    println!("Calling {} it works!", text);
fn main() {
    foo(bar);
To enable the explicit calls you need to add `#![feature(unboxed_closures)]`.
This feature is still unstable so you will also need to add
`#![feature(fn_traits)]`.
More details about this issue here:
https://github.com/rust-lang/rust/issues/29625
Example of use:
#![feature(fn_traits)]
#![feature(unboxed_closures)]
fn foo<F: Fn(&str)>(mut f: F) {
    f.call(("call",)); // Calling 'call' it works!
    f.call_mut(("call_mut",)); // Calling 'call_mut' it works!
    f.call_once(("call_once",)); // Calling 'call_once' it works!
fn bar(text: &str) {
    println!("Calling '{}' it works!", text);
fn main() {
    foo(bar);
To see more about closures take a look here:
https://doc.rust-lang.org/book/closures.html`
E0178
In types, the `+` type operator has low precedence, so it is often necessary
to use parentheses.
For example:
```compile_fail
trait Foo {}
struct Bar<'a> {
    w: &'a Foo + Copy,   // error, use &'a (Foo + Copy)
    x: &'a Foo + 'a,     // error, use &'a (Foo + 'a)
    y: &'a mut Foo + 'a, // error, use &'a mut (Foo + 'a)
    z: fn() -> Foo + 'a, // error, use fn() -> (Foo + 'a)
More details can be found in [RFC 438].
[RFC 438]: https://github.com/rust-lang/rfcs/pull/438
E0184
Explicitly implementing both Drop and Copy for a type is currently disallowed.
This feature can make some sense in theory, but the current implementation is
incorrect and can lead to memory unsafety (see [issue #20126][iss20126]), so
it has been disabled for now.
[iss20126]: https://github.com/rust-lang/rust/issues/20126
E0185
An associated function for a trait was defined to be static, but an
implementation of the trait declared the same function to be a method (i.e. to
take a `self` parameter).
Here's an example of this error:
```compile_fail
trait Foo {
    fn foo();
struct Bar;
impl Foo for Bar {
    // error, method `foo` has a `&self` declaration in the impl, but not in
    // the trait
    fn foo(&self) {}
E0186
An associated function for a trait was defined to be a method (i.e. to take a
`self` parameter), but an implementation of the trait declared the same function
to be static.
Here's an example of this error:
```compile_fail
trait Foo {
    fn foo(&self);
struct Bar;
impl Foo for Bar {
    // error, method `foo` has a `&self` declaration in the trait, but not in
    // the impl
    fn foo() {}
E0191
Trait objects need to have all associated types specified. Erroneous code
example:
```compile_fail
trait Trait {
    type Bar;
type Foo = Trait; // error: the value of the associated type `Bar` (from
                  //        the trait `Trait`) must be specified
Please verify you specified all associated types of the trait and that you
used the right trait. Example:
trait Trait {
    type Bar;
type Foo = Trait<Bar=i32>; // ok!
E0192
Negative impls are only allowed for traits with default impls. For more
information see the [opt-in builtin traits RFC](https://github.com/rust-lang/
rfcs/blob/master/text/0019-opt-in-builtin-traits.md).
E0193
`where` clauses must use generic type parameters: it does not make sense to use
them otherwise. An example causing this error:
```ignore
trait Foo {
    fn bar(&self);
#[derive(Copy,Clone)]
struct Wrapper<T> {
    Wrapped: T
impl Foo for Wrapper<u32> where Wrapper<u32>: Clone {
    fn bar(&self) { }
This use of a `where` clause is strange - a more common usage would look
something like the following:
trait Foo {
    fn bar(&self);
#[derive(Copy,Clone)]
struct Wrapper<T> {
    Wrapped: T
impl <T> Foo for Wrapper<T> where Wrapper<T>: Clone {
    fn bar(&self) { }
Here, we're saying that the implementation exists on Wrapper only when the
wrapped type `T` implements `Clone`. The `where` clause is important because
some types will not implement `Clone`, and thus will not get this method.
In our erroneous example, however, we're referencing a single concrete type.
Since we know for certain that `Wrapper<u32>` implements `Clone`, there's no
reason to also specify it in a `where` clause.
E0194
A type parameter was declared which shadows an existing one. An example of this
error:
```compile_fail
trait Foo<T> {
    fn do_something(&self) -> T;
    fn do_something_else<T: Clone>(&self, bar: T);
In this example, the trait `Foo` and the trait method `do_something_else` both
define a type parameter `T`. This is not allowed: if the method wishes to
define a type parameter, it must use a different name for it.
E0195
Your method's lifetime parameters do not match the trait declaration.
Erroneous code example:
```compile_fail
trait Trait {
    fn bar<'a,'b:'a>(x: &'a str, y: &'b str);
struct Foo;
impl Trait for Foo {
    fn bar<'a,'b>(x: &'a str, y: &'b str) {
    // error: lifetime parameters or bounds on method `bar`
    // do not match the trait declaration
    }
The lifetime constraint `'b` for bar() implementation does not match the
trait declaration. Ensure lifetime declarations match exactly in both trait
declaration and implementation. Example:
trait Trait {
    fn t<'a,'b:'a>(x: &'a str, y: &'b str);
struct Foo;
impl Trait for Foo {
    fn t<'a,'b:'a>(x: &'a str, y: &'b str) { // ok!
    }
E0197
Inherent implementations (one that do not implement a trait but provide
methods associated with a type) are always safe because they are not
implementing an unsafe trait. Removing the `unsafe` keyword from the inherent
implementation will resolve this error.
```compile_fail
struct Foo;
// this will cause this error
unsafe impl Foo { }
// converting it to this will fix it
impl Foo { }
E0198
A negative implementation is one that excludes a type from implementing a
particular trait. Not being able to use a trait is always a safe operation,
so negative implementations are always safe and never need to be marked as
unsafe.
```compile_fail
#![feature(optin_builtin_traits)]
struct Foo;
// unsafe is unnecessary
unsafe impl !Clone for Foo { }
This will compile:
#![feature(optin_builtin_traits)]
struct Foo;
trait Enterprise {}
impl Enterprise for .. { }
impl !Enterprise for Foo { }
Please note that negative impls are only allowed for traits with default impls.
E0199
Safe traits should not have unsafe implementations, therefore marking an
implementation for a safe trait unsafe will cause a compiler error. Removing
the unsafe marker on the trait noted in the error will resolve this problem.
```compile_fail
struct Foo;
trait Bar { }
// this won't compile because Bar is safe
unsafe impl Bar for Foo { }
// this will compile
impl Bar for Foo { }
E0200
Unsafe traits must have unsafe implementations. This error occurs when an
implementation for an unsafe trait isn't marked as unsafe. This may be resolved
by marking the unsafe implementation as unsafe.
```compile_fail
struct Foo;
unsafe trait Bar { }
// this won't compile because Bar is unsafe and impl isn't unsafe
impl Bar for Foo { }
// this will compile
unsafe impl Bar for Foo { }
E0201
It is an error to define two associated items (like methods, associated types,
associated functions, etc.) with the same identifier.
For example:
```compile_fail
struct Foo(u8);
impl Foo {
    fn bar(&self) -> bool { self.0 > 5 }
    fn bar() {} // error: duplicate associated function
trait Baz {
    type Quux;
    fn baz(&self) -> bool;
impl Baz for Foo {
    type Quux = u32;
    fn baz(&self) -> bool { true }
    // error: duplicate method
    fn baz(&self) -> bool { self.0 > 5 }
    // error: duplicate associated type
    type Quux = u32;
Note, however, that items with the same name are allowed for inherent `impl`
blocks that don't overlap:
struct Foo<T>(T);
impl Foo<u8> {
    fn bar(&self) -> bool { self.0 > 5 }
impl Foo<bool> {
    fn bar(&self) -> bool { self.0 }
E0202
Inherent associated types were part of [RFC 195] but are not yet implemented.
See [the tracking issue][iss8995] for the status of this implementation.
[RFC 195]: https://github.com/rust-lang/rfcs/pull/195
[iss8995]: https://github.com/rust-lang/rust/issues/8995
E0204
An attempt to implement the `Copy` trait for a struct failed because one of the
fields does not implement `Copy`. To fix this, you must implement `Copy` for the
mentioned field. Note that this may not be possible, as in the example of
```compile_fail
struct Foo {
    foo : Vec<u32>,
impl Copy for Foo { }
This fails because `Vec<T>` does not implement `Copy` for any `T`.
Here's another example that will fail:
```compile_fail
#[derive(Copy)]
struct Foo<'a> {
    ty: &'a mut bool,
This fails because `&mut T` is not `Copy`, even when `T` is `Copy` (this
differs from the behavior for `&T`, which is always `Copy`).
E0205
An attempt to implement the `Copy` trait for an enum failed because one of the
variants does not implement `Copy`. To fix this, you must implement `Copy` for
the mentioned variant. Note that this may not be possible, as in the example of
```compile_fail
enum Foo {
    Bar(Vec<u32>),
    Baz,
impl Copy for Foo { }
This fails because `Vec<T>` does not implement `Copy` for any `T`.
Here's another example that will fail:
```compile_fail
#[derive(Copy)]
enum Foo<'a> {
    Bar(&'a mut bool),
    Baz
This fails because `&mut T` is not `Copy`, even when `T` is `Copy` (this
differs from the behavior for `&T`, which is always `Copy`).
E0206
You can only implement `Copy` for a struct or enum. Both of the following
examples will fail, because neither `i32` (primitive type) nor `&'static Bar`
(reference to `Bar`) is a struct or enum:
```compile_fail
type Foo = i32;
impl Copy for Foo { } // error
#[derive(Copy, Clone)]
struct Bar;
impl Copy for &'static Bar { } // error
E0207
Any type parameter or lifetime parameter of an `impl` must meet at least one of
the following criteria:
 - it appears in the self type of the impl
 - for a trait impl, it appears in the trait reference
 - it is bound as an associated type
### Error example 1
Suppose we have a struct `Foo` and we would like to define some methods for it.
The following definition leads to a compiler error:
```compile_fail
struct Foo;
impl<T: Default> Foo {
// error: the type parameter `T` is not constrained by the impl trait, self
// type, or predicates [E0207]
    fn get(&self) -> T {
        <T as Default>::default()
    }
The problem is that the parameter `T` does not appear in the self type (`Foo`)
of the impl. In this case, we can fix the error by moving the type parameter
from the `impl` to the method `get`:
struct Foo;
// Move the type parameter from the impl to the method
impl Foo {
    fn get<T: Default>(&self) -> T {
        <T as Default>::default()
    }
### Error example 2
As another example, suppose we have a `Maker` trait and want to establish a
type `FooMaker` that makes `Foo`s:
```compile_fail
trait Maker {
    type Item;
    fn make(&mut self) -> Self::Item;
struct Foo<T> {
    foo: T
struct FooMaker;
impl<T: Default> Maker for FooMaker {
// error: the type parameter `T` is not constrained by the impl trait, self
// type, or predicates [E0207]
    type Item = Foo<T>;
    fn make(&mut self) -> Foo<T> {
        Foo { foo: <T as Default>::default() }
    }
This fails to compile because `T` does not appear in the trait or in the
implementing type.
One way to work around this is to introduce a phantom type parameter into
`FooMaker`, like so:
use std::marker::PhantomData;
trait Maker {
    type Item;
    fn make(&mut self) -> Self::Item;
struct Foo<T> {
    foo: T
// Add a type parameter to `FooMaker`
struct FooMaker<T> {
    phantom: PhantomData<T>,
impl<T: Default> Maker for FooMaker<T> {
    type Item = Foo<T>;
    fn make(&mut self) -> Foo<T> {
        Foo {
            foo: <T as Default>::default(),
        }
    }
Another way is to do away with the associated type in `Maker` and use an input
type parameter instead:
// Use a type parameter instead of an associated type here
trait Maker<Item> {
    fn make(&mut self) -> Item;
struct Foo<T> {
    foo: T
struct FooMaker;
impl<T: Default> Maker<Foo<T>> for FooMaker {
    fn make(&mut self) -> Foo<T> {
        Foo { foo: <T as Default>::default() }
    }
### Additional information
For more information, please see [RFC 447].
[RFC 447]: https://github.com/rust-lang/rfcs/blob/master/text/0447-no-unused-impl-parameters.md
E0210
This error indicates a violation of one of Rust's orphan rules for trait
implementations. The rule concerns the use of type parameters in an
implementation of a foreign trait (a trait defined in another crate), and
states that type parameters must be "covered" by a local type. To understand
what this means, it is perhaps easiest to consider a few examples.
If `ForeignTrait` is a trait defined in some external crate `foo`, then the
following trait `impl` is an error:
```compile_fail
extern crate foo;
use foo::ForeignTrait;
impl<T> ForeignTrait for T { } // error
To work around this, it can be covered with a local type, `MyType`:
```ignore
struct MyType<T>(T);
impl<T> ForeignTrait for MyType<T> { } // Ok
Please note that a type alias is not sufficient.
For another example of an error, suppose there's another trait defined in `foo`
named `ForeignTrait2` that takes two type parameters. Then this `impl` results
in the same rule violation:
```compile_fail
struct MyType2;
impl<T> ForeignTrait2<T, MyType<T>> for MyType2 { } // error
The reason for this is that there are two appearances of type parameter `T` in
the `impl` header, both as parameters for `ForeignTrait2`. The first appearance
is uncovered, and so runs afoul of the orphan rule.
Consider one more example:
```ignore
impl<T> ForeignTrait2<MyType<T>, T> for MyType2 { } // Ok
This only differs from the previous `impl` in that the parameters `T` and
`MyType<T>` for `ForeignTrait2` have been swapped. This example does *not*
violate the orphan rule; it is permitted.
To see why that last example was allowed, you need to understand the general
rule. Unfortunately this rule is a bit tricky to state. Consider an `impl`:
```ignore
impl<P1, ..., Pm> ForeignTrait<T1, ..., Tn> for T0 { ... }
where `P1, ..., Pm` are the type parameters of the `impl` and `T0, ..., Tn`
are types. One of the types `T0, ..., Tn` must be a local type (this is another
orphan rule, see the explanation for E0117). Let `i` be the smallest integer
such that `Ti` is a local type. Then no type parameter can appear in any of the
`Tj` for `j < i`.
For information on the design of the orphan rules, see [RFC 1023].
[RFC 1023]: https://github.com/rust-lang/rfcs/pull/1023
E0214
A generic type was described using parentheses rather than angle brackets. For
example:
```compile_fail
fn main() {
    let v: Vec(&str) = vec!["foo"];
This is not currently supported: `v` should be defined as `Vec<&str>`.
Parentheses are currently only used with generic types when defining parameters
for `Fn`-family traits.
E0220
You used an associated type which isn't defined in the trait.
Erroneous code example:
```compile_fail
trait T1 {
    type Bar;
type Foo = T1<F=i32>; // error: associated type `F` not found for `T1`
// or:
trait T2 {
    type Bar;
    // error: Baz is used but not declared
    fn return_bool(&self, &Self::Bar, &Self::Baz) -> bool;
Make sure that you have defined the associated type in the trait body.
Also, verify that you used the right trait or you didn't misspell the
associated type name. Example:
trait T1 {
    type Bar;
type Foo = T1<Bar=i32>; // ok!
// or:
trait T2 {
    type Bar;
    type Baz; // we declare `Baz` in our trait.
    // and now we can use it here:
    fn return_bool(&self, &Self::Bar, &Self::Baz) -> bool;
E0221
An attempt was made to retrieve an associated type, but the type was ambiguous.
For example:
```compile_fail
trait T1 {}
trait T2 {}
trait Foo {
    type A: T1;
trait Bar : Foo {
    type A: T2;
    fn do_something() {
        let _: Self::A;
    }
In this example, `Foo` defines an associated type `A`. `Bar` inherits that type
from `Foo`, and defines another associated type of the same name. As a result,
when we attempt to use `Self::A`, it's ambiguous whether we mean the `A` defined
by `Foo` or the one defined by `Bar`.
There are two options to work around this issue. The first is simply to rename
one of the types. Alternatively, one can specify the intended type using the
following syntax:
trait T1 {}
trait T2 {}
trait Foo {
    type A: T1;
trait Bar : Foo {
    type A: T2;
    fn do_something() {
        let _: <Self as Bar>::A;
    }
E0223
An attempt was made to retrieve an associated type, but the type was ambiguous.
For example:
```compile_fail
trait MyTrait {type X; }
fn main() {
    let foo: MyTrait::X;
The problem here is that we're attempting to take the type of X from MyTrait.
Unfortunately, the type of X is not defined, because it's only made concrete in
implementations of the trait. A working version of this code might look like:
trait MyTrait {type X; }
struct MyStruct;
impl MyTrait for MyStruct {
    type X = u32;
fn main() {
    let foo: <MyStruct as MyTrait>::X;
This syntax specifies that we want the X type from MyTrait, as made concrete in
MyStruct. The reason that we cannot simply use `MyStruct::X` is that MyStruct
might implement two different traits with identically-named associated types.
This syntax allows disambiguation between the two.
E0225
You attempted to use multiple types as bounds for a closure or trait object.
Rust does not currently support this. A simple example that causes this error:
```compile_fail
fn main() {
    let _: Box<std::io::Read + std::io::Write>;
Builtin traits are an exception to this rule: it's possible to have bounds of
one non-builtin type, plus any number of builtin types. For example, the
following compiles correctly:
fn main() {
    let _: Box<std::io::Read + Send + Sync>;
E0232
The attribute must have a value. Erroneous code example:
```compile_fail
#![feature(on_unimplemented)]
#[rustc_on_unimplemented] // error: this attribute must have a value
trait Bar {}
Please supply the missing value of the attribute. Example:
#![feature(on_unimplemented)]
#[rustc_on_unimplemented = "foo"] // ok!
trait Bar {}
E0243
This error indicates that not enough type parameters were found in a type or
trait.
For example, the `Foo` struct below is defined to be generic in `T`, but the
type parameter is missing in the definition of `Bar`:
```compile_fail
struct Foo<T> { x: T }
struct Bar { x: Foo }
E0244
This error indicates that too many type parameters were found in a type or
trait.
For example, the `Foo` struct below has no type parameters, but is supplied
with two in the definition of `Bar`:
```compile_fail
struct Foo { x: bool }
struct Bar<S, T> { x: Foo<S, T> }
E0248
This error indicates an attempt to use a value where a type is expected. For
example:
```compile_fail
enum Foo {
    Bar(u32)
fn do_something(x: Foo::Bar) { }
In this example, we're attempting to take a type of `Foo::Bar` in the
do_something function. This is not legal: `Foo::Bar` is a value of type `Foo`,
not a distinct static type. Likewise, it's not legal to attempt to
`impl Foo::Bar`: instead, you must `impl Foo` and then pattern match to specify
behavior for specific enum variants.
E0249
This error indicates a constant expression for the array length was found, but
it was not an integer (signed or unsigned) expression.
Some examples of code that produces this error are:
```compile_fail
const A: [u32; "hello"] = []; // error
const B: [u32; true] = []; // error
const C: [u32; 0.0] = []; // error
E0250
There was an error while evaluating the expression for the length of a fixed-
size array type.
Some examples of this error are:
```compile_fail
// divide by zero in the length expression
const A: [u32; 1/0] = [];
// Rust currently will not evaluate the function `foo` at compile time
fn foo() -> usize { 12 }
const B: [u32; foo()] = [];
// it is an error to try to add `u8` and `f64`
use std::{f64, u8};
const C: [u32; u8::MAX + f64::EPSILON] = [];
E0318
Default impls for a trait must be located in the same crate where the trait was
defined. For more information see the [opt-in builtin traits RFC](https://github
.com/rust-lang/rfcs/blob/master/text/0019-opt-in-builtin-traits.md).
E0321
A cross-crate opt-out trait was implemented on something which wasn't a struct
or enum type. Erroneous code example:
```compile_fail
#![feature(optin_builtin_traits)]
struct Foo;
impl !Sync for Foo {}
unsafe impl Send for &'static Foo {
// error: cross-crate traits with a default impl, like `core::marker::Send`,
//        can only be implemented for a struct/enum type, not
//        `&'static Foo`
Only structs and enums are permitted to impl Send, Sync, and other opt-out
trait, and the struct or enum must be local to the current crate. So, for
example, `unsafe impl Send for Rc<Foo>` is not allowed.
E0322
The `Sized` trait is a special trait built-in to the compiler for types with a
constant size known at compile-time. This trait is automatically implemented
for types as needed by the compiler, and it is currently disallowed to
explicitly implement it for a type.
E0323
An associated const was implemented when another trait item was expected.
Erroneous code example:
```compile_fail
#![feature(associated_consts)]
trait Foo {
    type N;
struct Bar;
impl Foo for Bar {
    const N : u32 = 0;
    // error: item `N` is an associated const, which doesn't match its
    //        trait `<Bar as Foo>`
Please verify that the associated const wasn't misspelled and the correct trait
was implemented. Example:
struct Bar;
trait Foo {
    type N;
impl Foo for Bar {
    type N = u32; // ok!
#![feature(associated_consts)]
struct Bar;
trait Foo {
    const N : u32;
impl Foo for Bar {
    const N : u32 = 0; // ok!
E0324
A method was implemented when another trait item was expected. Erroneous
code example:
```compile_fail
struct Bar;
trait Foo {
    const N : u32;
    fn M();
impl Foo for Bar {
    fn N() {}
    // error: item `N` is an associated method, which doesn't match its
    //        trait `<Bar as Foo>`
To fix this error, please verify that the method name wasn't misspelled and
verify that you are indeed implementing the correct trait items. Example:
#![feature(associated_consts)]
struct Bar;
trait Foo {
    const N : u32;
    fn M();
impl Foo for Bar {
    const N : u32 = 0;
    fn M() {} // ok!
E0325
An associated type was implemented when another trait item was expected.
Erroneous code example:
```compile_fail
struct Bar;
trait Foo {
    const N : u32;
impl Foo for Bar {
    type N = u32;
    // error: item `N` is an associated type, which doesn't match its
    //        trait `<Bar as Foo>`
Please verify that the associated type name wasn't misspelled and your
implementation corresponds to the trait definition. Example:
struct Bar;
trait Foo {
    type N;
impl Foo for Bar {
    type N = u32; // ok!
#![feature(associated_consts)]
struct Bar;
trait Foo {
    const N : u32;
impl Foo for Bar {
    const N : u32 = 0; // ok!
E0326
The types of any associated constants in a trait implementation must match the
types in the trait definition. This error indicates that there was a mismatch.
Here's an example of this error:
```compile_fail
trait Foo {
    const BAR: bool;
struct Bar;
impl Foo for Bar {
    const BAR: u32 = 5; // error, expected bool, found u32
E0327
You cannot use associated items other than constant items as patterns. This
includes method items. Example of erroneous code:
```compile_fail
enum B {}
impl B {
    fn bb() -> i32 { 0 }
fn main() {
    match 0 {
        B::bb => {} // error: associated items in match patterns must
                    // be constants
    }
Please check that you're not using a method as a pattern. Example:
enum B {
    ba,
    bb
fn main() {
    match B::ba {
        B::bb => {} // ok!
        _ => {}
    }
E0329
An attempt was made to access an associated constant through either a generic
type parameter or `Self`. This is not supported yet. An example causing this
error is shown below:
```ignore
#![feature(associated_consts)]
trait Foo {
    const BAR: f64;
struct MyStruct;
impl Foo for MyStruct {
    const BAR: f64 = 0f64;
fn get_bar_bad<F: Foo>(t: F) -> f64 {
    F::BAR
Currently, the value of `BAR` for a particular type can only be accessed
through a concrete type, as shown below:
```ignore
#![feature(associated_consts)]
trait Foo {
    const BAR: f64;
struct MyStruct;
fn get_bar_good() -> f64 {
    <MyStruct as Foo>::BAR
E0366
An attempt was made to implement `Drop` on a concrete specialization of a
generic type. An example is shown below:
```compile_fail
struct Foo<T> {
    t: T
impl Drop for Foo<u32> {
    fn drop(&mut self) {}
This code is not legal: it is not possible to specialize `Drop` to a subset of
implementations of a generic type. One workaround for this is to wrap the
generic type, as shown below:
struct Foo<T> {
    t: T
struct Bar {
    t: Foo<u32>
impl Drop for Bar {
    fn drop(&mut self) {}
E0367
An attempt was made to implement `Drop` on a specialization of a generic type.
An example is shown below:
```compile_fail
trait Foo{}
struct MyStruct<T> {
    t: T
impl<T: Foo> Drop for MyStruct<T> {
    fn drop(&mut self) {}
This code is not legal: it is not possible to specialize `Drop` to a subset of
implementations of a generic type. In order for this code to work, `MyStruct`
must also require that `T` implements `Foo`. Alternatively, another option is
to wrap the generic type in another that specializes appropriately:
trait Foo{}
struct MyStruct<T> {
    t: T
struct MyStructWrapper<T: Foo> {
    t: MyStruct<T>
impl <T: Foo> Drop for MyStructWrapper<T> {
    fn drop(&mut self) {}
E0368
This error indicates that a binary assignment operator like `+=` or `^=` was
applied to a type that doesn't support it. For example:
```compile_fail
let mut x = 12f32; // error: binary operation `<<` cannot be applied to
                   //        type `f32`
x <<= 2;
To fix this error, please check that this type implements this binary
operation. Example:
let mut x = 12u32; // the `u32` type does implement the `ShlAssign` trait
x <<= 2; // ok!
It is also possible to overload most operators for your own type by
implementing the `[OP]Assign` traits from `std::ops`.
Another problem you might be facing is this: suppose you've overloaded the `+`
operator for some type `Foo` by implementing the `std::ops::Add` trait for
`Foo`, but you find that using `+=` does not work, as in this example:
```compile_fail
use std::ops::Add;
struct Foo(u32);
impl Add for Foo {
    type Output = Foo;
    fn add(self, rhs: Foo) -> Foo {
        Foo(self.0 + rhs.0)
    }
fn main() {
    let mut x: Foo = Foo(5);
    x += Foo(7); // error, `+= cannot be applied to the type `Foo`
This is because `AddAssign` is not automatically implemented, so you need to
manually implement it for your type.
E0369
A binary operation was attempted on a type which doesn't support it.
Erroneous code example:
```compile_fail
let x = 12f32; // error: binary operation `<<` cannot be applied to
               //        type `f32`
x << 2;
To fix this error, please check that this type implements this binary
operation. Example:
let x = 12u32; // the `u32` type does implement it:
               // https://doc.rust-lang.org/stable/std/ops/trait.Shl.html
x << 2; // ok!
It is also possible to overload most operators for your own type by
implementing traits from `std::ops`.
E0370
The maximum value of an enum was reached, so it cannot be automatically
set in the next enum value. Erroneous code example:
```compile_fail
#[deny(overflowing_literals)]
enum Foo {
    X = 0x7fffffffffffffff,
    Y, // error: enum discriminant overflowed on value after
       //        9223372036854775807: i64; set explicitly via
       //        Y = -9223372036854775808 if that is desired outcome
To fix this, please set manually the next enum value or put the enum variant
with the maximum value at the end of the enum. Examples:
enum Foo {
    X = 0x7fffffffffffffff,
    Y = 0, // ok!
enum Foo {
    Y = 0, // ok!
    X = 0x7fffffffffffffff,
E0371
When `Trait2` is a subtrait of `Trait1` (for example, when `Trait2` has a
definition like `trait Trait2: Trait1 { ... }`), it is not allowed to implement
`Trait1` for `Trait2`. This is because `Trait2` already implements `Trait1` by
definition, so it is not useful to do this.
Example:
```compile_fail
trait Foo { fn foo(&self) { } }
trait Bar: Foo { }
trait Baz: Bar { }
impl Bar for Baz { } // error, `Baz` implements `Bar` by definition
impl Foo for Baz { } // error, `Baz` implements `Bar` which implements `Foo`
impl Baz for Baz { } // error, `Baz` (trivially) implements `Baz`
impl Baz for Bar { } // Note: This is OK
E0374
A struct without a field containing an unsized type cannot implement
`CoerceUnsized`. An
[unsized type](https://doc.rust-lang.org/book/unsized-types.html)
is any type that the compiler doesn't know the length or alignment of at
compile time. Any struct containing an unsized type is also unsized.
Example of erroneous code:
```compile_fail
#![feature(coerce_unsized)]
use std::ops::CoerceUnsized;
struct Foo<T: ?Sized> {
    a: i32,
// error: Struct `Foo` has no unsized fields that need `CoerceUnsized`.
impl<T, U> CoerceUnsized<Foo<U>> for Foo<T>
    where T: CoerceUnsized<U> {}
`CoerceUnsized` is used to coerce one struct containing an unsized type
into another struct containing a different unsized type. If the struct
doesn't have any fields of unsized types then you don't need explicit
coercion to get the types you want. To fix this you can either
not try to implement `CoerceUnsized` or you can add a field that is
unsized to the struct.
Example:
#![feature(coerce_unsized)]
use std::ops::CoerceUnsized;
// We don't need to impl `CoerceUnsized` here.
struct Foo {
    a: i32,
// We add the unsized type field to the struct.
struct Bar<T: ?Sized> {
    a: i32,
    b: T,
// The struct has an unsized field so we can implement
// `CoerceUnsized` for it.
impl<T, U> CoerceUnsized<Bar<U>> for Bar<T>
    where T: CoerceUnsized<U> {}
Note that `CoerceUnsized` is mainly used by smart pointers like `Box`, `Rc`
and `Arc` to be able to mark that they can coerce unsized types that they
are pointing at.
E0375
A struct with more than one field containing an unsized type cannot implement
`CoerceUnsized`. This only occurs when you are trying to coerce one of the
types in your struct to another type in the struct. In this case we try to
impl `CoerceUnsized` from `T` to `U` which are both types that the struct
takes. An [unsized type](https://doc.rust-lang.org/book/unsized-types.html)
is any type that the compiler doesn't know the length or alignment of at
compile time. Any struct containing an unsized type is also unsized.
Example of erroneous code:
```compile_fail
#![feature(coerce_unsized)]
use std::ops::CoerceUnsized;
struct Foo<T: ?Sized, U: ?Sized> {
    a: i32,
    b: T,
    c: U,
// error: Struct `Foo` has more than one unsized field.
impl<T, U> CoerceUnsized<Foo<U, T>> for Foo<T, U> {}
`CoerceUnsized` only allows for coercion from a structure with a single
unsized type field to another struct with a single unsized type field.
In fact Rust only allows for a struct to have one unsized type in a struct
and that unsized type must be the last field in the struct. So having two
unsized types in a single struct is not allowed by the compiler. To fix this
use only one field containing an unsized type in the struct and then use
multiple structs to manage each unsized type field you need.
Example:
#![feature(coerce_unsized)]
use std::ops::CoerceUnsized;
struct Foo<T: ?Sized> {
    a: i32,
    b: T,
impl <T, U> CoerceUnsized<Foo<U>> for Foo<T>
    where T: CoerceUnsized<U> {}
fn coerce_foo<T: CoerceUnsized<U>, U>(t: T) -> Foo<U> {
    Foo { a: 12i32, b: t } // we use coercion to get the `Foo<U>` type we need
E0376
The type you are trying to impl `CoerceUnsized` for is not a struct.
`CoerceUnsized` can only be implemented for a struct. Unsized types are
already able to be coerced without an implementation of `CoerceUnsized`
whereas a struct containing an unsized type needs to know the unsized type
field it's containing is able to be coerced. An
[unsized type](https://doc.rust-lang.org/book/unsized-types.html)
is any type that the compiler doesn't know the length or alignment of at
compile time. Any struct containing an unsized type is also unsized.
Example of erroneous code:
```compile_fail
#![feature(coerce_unsized)]
use std::ops::CoerceUnsized;
struct Foo<T: ?Sized> {
    a: T,
// error: The type `U` is not a struct
impl<T, U> CoerceUnsized<U> for Foo<T> {}
The `CoerceUnsized` trait takes a struct type. Make sure the type you are
providing to `CoerceUnsized` is a struct with only the last field containing an
unsized type.
Example:
#![feature(coerce_unsized)]
use std::ops::CoerceUnsized;
struct Foo<T> {
    a: T,
// The `Foo<U>` is a struct so `CoerceUnsized` can be implemented
impl<T, U> CoerceUnsized<Foo<U>> for Foo<T> where T: CoerceUnsized<U> {}
Note that in Rust, structs can only contain an unsized type if the field
containing the unsized type is the last and only unsized type field in the
struct.
E0379
Trait methods cannot be declared `const` by design. For more information, see
[RFC 911].
[RFC 911]: https://github.com/rust-lang/rfcs/pull/911
E0380
Default impls are only allowed for traits with no methods or associated items.
For more information see the [opt-in builtin traits RFC](https://github.com/rust
-lang/rfcs/blob/master/text/0019-opt-in-builtin-traits.md).
E0390
You tried to implement methods for a primitive type. Erroneous code example:
```compile_fail
struct Foo {
    x: i32
impl *mut Foo {}
// error: only a single inherent implementation marked with
//        `#[lang = "mut_ptr"]` is allowed for the `*mut T` primitive
This isn't allowed, but using a trait to implement a method is a good solution.
Example:
struct Foo {
    x: i32
trait Bar {
    fn bar();
impl Bar for *mut Foo {
    fn bar() {} // ok!
E0391
This error indicates that some types or traits depend on each other
and therefore cannot be constructed.
The following example contains a circular dependency between two traits:
```compile_fail
trait FirstTrait : SecondTrait {
trait SecondTrait : FirstTrait {
E0392
This error indicates that a type or lifetime parameter has been declared
but not actually used. Here is an example that demonstrates the error:
```compile_fail
enum Foo<T> {
    Bar
If the type parameter was included by mistake, this error can be fixed
by simply removing the type parameter, as shown below:
enum Foo {
    Bar
Alternatively, if the type parameter was intentionally inserted, it must be
used. A simple fix is shown below:
enum Foo<T> {
    Bar(T)
This error may also commonly be found when working with unsafe code. For
example, when using raw pointers one may wish to specify the lifetime for
which the pointed-at data is valid. An initial attempt (below) causes this
error:
```compile_fail
struct Foo<'a, T> {
    x: *const T
We want to express the constraint that Foo should not outlive `'a`, because
the data pointed to by `T` is only valid for that lifetime. The problem is
that there are no actual uses of `'a`. It's possible to work around this
by adding a PhantomData type to the struct, using it to tell the compiler
to act as if the struct contained a borrowed reference `&'a T`:
use std::marker::PhantomData;
struct Foo<'a, T: 'a> {
    x: *const T,
    phantom: PhantomData<&'a T>
PhantomData can also be used to express information about unused type
parameters. You can read more about it in the API documentation:
https://doc.rust-lang.org/std/marker/struct.PhantomData.html
E0393
A type parameter which references `Self` in its default value was not specified.
Example of erroneous code:
```compile_fail
trait A<T=Self> {}
fn together_we_will_rule_the_galaxy(son: &A) {}
// error: the type parameter `T` must be explicitly specified in an
//        object type because its default value `Self` references the
//        type `Self`
A trait object is defined over a single, fully-defined trait. With a regular
default parameter, this parameter can just be substituted in. However, if the
default parameter is `Self`, the trait changes for each concrete type; i.e.
`i32` will be expected to implement `A<i32>`, `bool` will be expected to
implement `A<bool>`, etc... These types will not share an implementation of a
fully-defined trait; instead they share implementations of a trait with
different parameters substituted in for each implementation. This is
irreconcilable with what we need to make a trait object work, and is thus
disallowed. Making the trait concrete by explicitly specifying the value of the
defaulted parameter will fix this issue. Fixed example:
trait A<T=Self> {}
fn together_we_will_rule_the_galaxy(son: &A<i32>) {} // Ok!
E0439
The length of the platform-intrinsic function `simd_shuffle`
wasn't specified. Erroneous code example:
```compile_fail
#![feature(platform_intrinsics)]
extern "platform-intrinsic" {
    fn simd_shuffle<A,B>(a: A, b: A, c: [u32; 8]) -> B;
    // error: invalid `simd_shuffle`, needs length: `simd_shuffle`
The `simd_shuffle` function needs the length of the array passed as
last parameter in its name. Example:
#![feature(platform_intrinsics)]
extern "platform-intrinsic" {
    fn simd_shuffle8<A,B>(a: A, b: A, c: [u32; 8]) -> B;
E0440
A platform-specific intrinsic function has the wrong number of type
parameters. Erroneous code example:
```compile_fail
#![feature(repr_simd)]
#![feature(platform_intrinsics)]
#[repr(simd)]
struct f64x2(f64, f64);
extern "platform-intrinsic" {
    fn x86_mm_movemask_pd<T>(x: f64x2) -> i32;
    // error: platform-specific intrinsic has wrong number of type
    //        parameters
Please refer to the function declaration to see if it corresponds
with yours. Example:
#![feature(repr_simd)]
#![feature(platform_intrinsics)]
#[repr(simd)]
struct f64x2(f64, f64);
extern "platform-intrinsic" {
    fn x86_mm_movemask_pd(x: f64x2) -> i32;
E0441
An unknown platform-specific intrinsic function was used. Erroneous
code example:
```compile_fail
#![feature(repr_simd)]
#![feature(platform_intrinsics)]
#[repr(simd)]
struct i16x8(i16, i16, i16, i16, i16, i16, i16, i16);
extern "platform-intrinsic" {
    fn x86_mm_adds_ep16(x: i16x8, y: i16x8) -> i16x8;
    // error: unrecognized platform-specific intrinsic function
Please verify that the function name wasn't misspelled, and ensure
that it is declared in the rust source code (in the file
src/librustc_platform_intrinsics/x86.rs). Example:
#![feature(repr_simd)]
#![feature(platform_intrinsics)]
#[repr(simd)]
struct i16x8(i16, i16, i16, i16, i16, i16, i16, i16);
extern "platform-intrinsic" {
    fn x86_mm_adds_epi16(x: i16x8, y: i16x8) -> i16x8; // ok!
E0442
Intrinsic argument(s) and/or return value have the wrong type.
Erroneous code example:
```compile_fail
#![feature(repr_simd)]
#![feature(platform_intrinsics)]
#[repr(simd)]
struct i8x16(i8, i8, i8, i8, i8, i8, i8, i8,
             i8, i8, i8, i8, i8, i8, i8, i8);
#[repr(simd)]
struct i32x4(i32, i32, i32, i32);
#[repr(simd)]
struct i64x2(i64, i64);
extern "platform-intrinsic" {
    fn x86_mm_adds_epi16(x: i8x16, y: i32x4) -> i64x2;
    // error: intrinsic arguments/return value have wrong type
To fix this error, please refer to the function declaration to give
it the awaited types. Example:
#![feature(repr_simd)]
#![feature(platform_intrinsics)]
#[repr(simd)]
struct i16x8(i16, i16, i16, i16, i16, i16, i16, i16);
extern "platform-intrinsic" {
    fn x86_mm_adds_epi16(x: i16x8, y: i16x8) -> i16x8; // ok!
E0443
Intrinsic argument(s) and/or return value have the wrong type.
Erroneous code example:
```compile_fail
#![feature(repr_simd)]
#![feature(platform_intrinsics)]
#[repr(simd)]
struct i16x8(i16, i16, i16, i16, i16, i16, i16, i16);
#[repr(simd)]
struct i64x8(i64, i64, i64, i64, i64, i64, i64, i64);
extern "platform-intrinsic" {
    fn x86_mm_adds_epi16(x: i16x8, y: i16x8) -> i64x8;
    // error: intrinsic argument/return value has wrong type
To fix this error, please refer to the function declaration to give
it the awaited types. Example:
#![feature(repr_simd)]
#![feature(platform_intrinsics)]
#[repr(simd)]
struct i16x8(i16, i16, i16, i16, i16, i16, i16, i16);
extern "platform-intrinsic" {
    fn x86_mm_adds_epi16(x: i16x8, y: i16x8) -> i16x8; // ok!
E0444
A platform-specific intrinsic function has wrong number of arguments.
Erroneous code example:
```compile_fail
#![feature(repr_simd)]
#![feature(platform_intrinsics)]
#[repr(simd)]
struct f64x2(f64, f64);
extern "platform-intrinsic" {
    fn x86_mm_movemask_pd(x: f64x2, y: f64x2, z: f64x2) -> i32;
    // error: platform-specific intrinsic has invalid number of arguments
Please refer to the function declaration to see if it corresponds
with yours. Example:
#![feature(repr_simd)]
#![feature(platform_intrinsics)]
#[repr(simd)]
struct f64x2(f64, f64);
extern "platform-intrinsic" {
    fn x86_mm_movemask_pd(x: f64x2) -> i32; // ok!
E0516
The `typeof` keyword is currently reserved but unimplemented.
Erroneous code example:
```compile_fail
fn main() {
    let x: typeof(92) = 92;
Try using type inference instead. Example:
fn main() {
    let x = 92;
E0520
A non-default implementation was already made on this type so it cannot be
specialized further. Erroneous code example:
```compile_fail
#![feature(specialization)]
trait SpaceLlama {
    fn fly(&self);
// applies to all T
impl<T> SpaceLlama for T {
    default fn fly(&self) {}
// non-default impl
// applies to all `Clone` T and overrides the previous impl
impl<T: Clone> SpaceLlama for T {
    fn fly(&self) {}
// since `i32` is clone, this conflicts with the previous implementation
impl SpaceLlama for i32 {
    default fn fly(&self) {}
    // error: item `fly` is provided by an `impl` that specializes
    //        another, but the item in the parent `impl` is not marked
    //        `default` and so it cannot be specialized.
Specialization only allows you to override `default` functions in
implementations.
To fix this error, you need to mark all the parent implementations as default.
Example:
#![feature(specialization)]
trait SpaceLlama {
    fn fly(&self);
// applies to all T
impl<T> SpaceLlama for T {
    default fn fly(&self) {} // This is a parent implementation.
// applies to all `Clone` T; overrides the previous impl
impl<T: Clone> SpaceLlama for T {
    default fn fly(&self) {} // This is a parent implementation but was
                             // previously not a default one, causing the error
// applies to i32, overrides the previous two impls
impl SpaceLlama for i32 {
    fn fly(&self) {} // And now that's ok!
E0373
This error occurs when an attempt is made to use data captured by a closure,
when that data may no longer exist. It's most commonly seen when attempting to
return a closure:
```compile_fail
fn foo() -> Box<Fn(u32) -> u32> {
    let x = 0u32;
    Box::new(|y| x + y)
Notice that `x` is stack-allocated by `foo()`. By default, Rust captures
closed-over data by reference. This means that once `foo()` returns, `x` no
longer exists. An attempt to access `x` within the closure would thus be
unsafe.
Another situation where this might be encountered is when spawning threads:
```compile_fail
fn foo() {
    let x = 0u32;
    let y = 1u32;
    let thr = std::thread::spawn(|| {
        x + y
    });
Since our new thread runs in parallel, the stack frame containing `x` and `y`
may well have disappeared by the time we try to use them. Even if we call
`thr.join()` within foo (which blocks until `thr` has completed, ensuring the
stack frame won't disappear), we will not succeed: the compiler cannot prove
that this behaviour is safe, and so won't let us do it.
The solution to this problem is usually to switch to using a `move` closure.
This approach moves (or copies, where possible) data into the closure, rather
than taking references to it. For example:
fn foo() -> Box<Fn(u32) -> u32> {
    let x = 0u32;
    Box::new(move |y| x + y)
Now that the closure has its own copy of the data, there's no need to worry
about safety.
E0381
It is not allowed to use or capture an uninitialized variable. For example:
```compile_fail
fn main() {
    let x: i32;
    let y = x; // error, use of possibly uninitialized variable
To fix this, ensure that any declared variables are initialized before being
used. Example:
fn main() {
    let x: i32 = 0;
    let y = x; // ok!
E0382
This error occurs when an attempt is made to use a variable after its contents
have been moved elsewhere. For example:
```compile_fail
struct MyStruct { s: u32 }
fn main() {
    let mut x = MyStruct{ s: 5u32 };
    let y = x;
    x.s = 6;
    println!("{}", x.s);
Since `MyStruct` is a type that is not marked `Copy`, the data gets moved out
of `x` when we set `y`. This is fundamental to Rust's ownership system: outside
of workarounds like `Rc`, a value cannot be owned by more than one variable.
If we own the type, the easiest way to address this problem is to implement
`Copy` and `Clone` on it, as shown below. This allows `y` to copy the
information in `x`, while leaving the original version owned by `x`. Subsequent
changes to `x` will not be reflected when accessing `y`.
#[derive(Copy, Clone)]
struct MyStruct { s: u32 }
fn main() {
    let mut x = MyStruct{ s: 5u32 };
    let y = x;
    x.s = 6;
    println!("{}", x.s);
Alternatively, if we don't control the struct's definition, or mutable shared
ownership is truly required, we can use `Rc` and `RefCell`:
use std::cell::RefCell;
use std::rc::Rc;
struct MyStruct { s: u32 }
fn main() {
    let mut x = Rc::new(RefCell::new(MyStruct{ s: 5u32 }));
    let y = x.clone();
    x.borrow_mut().s = 6;
    println!("{}", x.borrow().s);
With this approach, x and y share ownership of the data via the `Rc` (reference
count type). `RefCell` essentially performs runtime borrow checking: ensuring
that at most one writer or multiple readers can access the data at any one time.
If you wish to learn more about ownership in Rust, start with the chapter in the
Book:
https://doc.rust-lang.org/book/ownership.html
E0383
This error occurs when an attempt is made to partially reinitialize a
structure that is currently uninitialized.
For example, this can happen when a drop has taken place:
```ignore
struct Foo {
    a: u32,
let mut x = Foo { a: 1 };
drop(x); // `x` is now uninitialized
x.a = 2; // error, partial reinitialization of uninitialized structure `t`
This error can be fixed by fully reinitializing the structure in question:
struct Foo {
    a: u32,
let mut x = Foo { a: 1 };
drop(x);
x = Foo { a: 2 };
E0384
This error occurs when an attempt is made to reassign an immutable variable.
For example:
```compile_fail
fn main(){
    let x = 3;
    x = 5; // error, reassignment of immutable variable
By default, variables in Rust are immutable. To fix this error, add the keyword
`mut` after the keyword `let` when declaring the variable. For example:
fn main(){
    let mut x = 3;
    x = 5;
E0386
This error occurs when an attempt is made to mutate the target of a mutable
reference stored inside an immutable container.
For example, this can happen when storing a `&mut` inside an immutable `Box`:
```compile_fail
let mut x: i64 = 1;
let y: Box<_> = Box::new(&mut x);
**y = 2; // error, cannot assign to data in an immutable container
This error can be fixed by making the container mutable:
let mut x: i64 = 1;
let mut y: Box<_> = Box::new(&mut x);
**y = 2;
It can also be fixed by using a type with interior mutability, such as `Cell`
or `RefCell`:
use std::cell::Cell;
let x: i64 = 1;
let y: Box<Cell<_>> = Box::new(Cell::new(x));
y.set(2);
E0387
This error occurs when an attempt is made to mutate or mutably reference data
that a closure has captured immutably. Examples of this error are shown below:
```compile_fail
// Accepts a function or a closure that captures its environment immutably.
// Closures passed to foo will not be able to mutate their closed-over state.
fn foo<F: Fn()>(f: F) { }
// Attempts to mutate closed-over data. Error message reads:
// `cannot assign to data in a captured outer variable...`
fn mutable() {
    let mut x = 0u32;
    foo(|| x = 2);
// Attempts to take a mutable reference to closed-over data.  Error message
// reads: `cannot borrow data mutably in a captured outer variable...`
fn mut_addr() {
    let mut x = 0u32;
    foo(|| { let y = &mut x; });
The problem here is that foo is defined as accepting a parameter of type `Fn`.
Closures passed into foo will thus be inferred to be of type `Fn`, meaning that
they capture their context immutably.
If the definition of `foo` is under your control, the simplest solution is to
capture the data mutably. This can be done by defining `foo` to take FnMut
rather than Fn:
fn foo<F: FnMut()>(f: F) { }
Alternatively, we can consider using the `Cell` and `RefCell` types to achieve
interior mutability through a shared reference. Our example's `mutable`
function could be redefined as below:
use std::cell::Cell;
fn foo<F: Fn()>(f: F) { }
fn mutable() {
    let x = Cell::new(0u32);
    foo(|| x.set(2));
You can read more about cell types in the API documentation:
https://doc.rust-lang.org/std/cell/
E0389
An attempt was made to mutate data using a non-mutable reference. This
commonly occurs when attempting to assign to a non-mutable reference of a
mutable reference (`&(&mut T)`).
Example of erroneous code:
```compile_fail
struct FancyNum {
    num: u8
fn main() {
    let mut fancy = FancyNum{ num: 5 };
    let fancy_ref = &(&mut fancy);
    fancy_ref.num = 6; // error: cannot assign to data in a `&` reference
    println!("{}", fancy_ref.num);
Here, `&mut fancy` is mutable, but `&(&mut fancy)` is not. Creating an
immutable reference to a value borrows it immutably. There can be multiple
references of type `&(&mut T)` that point to the same value, so they must be
immutable to prevent multiple mutable references to the same value.
To fix this, either remove the outer reference:
struct FancyNum {
    num: u8
fn main() {
    let mut fancy = FancyNum{ num: 5 };
    let fancy_ref = &mut fancy;
    // `fancy_ref` is now &mut FancyNum, rather than &(&mut FancyNum)
    fancy_ref.num = 6; // No error!
    println!("{}", fancy_ref.num);
Or make the outer reference mutable:
struct FancyNum {
    num: u8
fn main() {
    let mut fancy = FancyNum{ num: 5 };
    let fancy_ref = &mut (&mut fancy);
    // `fancy_ref` is now &mut(&mut FancyNum), rather than &(&mut FancyNum)
    fancy_ref.num = 6; // No error!
    println!("{}", fancy_ref.num);
E0499
A variable was borrowed as mutable more than once. Erroneous code example:
```compile_fail
let mut i = 0;
let mut x = &mut i;
let mut a = &mut i;
// error: cannot borrow `i` as mutable more than once at a time
Please note that in rust, you can either have many immutable references, or one
mutable reference. Take a look at
https://doc.rust-lang.org/stable/book/references-and-borrowing.html for more
information. Example:
let mut i = 0;
let mut x = &mut i; // ok!
// or:
let mut i = 0;
let a = &i; // ok!
let b = &i; // still ok!
let c = &i; // still ok!
E0500
A borrowed variable was used in another closure. Example of erroneous code:
```compile_fail
fn you_know_nothing(jon_snow: &mut i32) {
    let nights_watch = || {
        *jon_snow = 2;
    };
    let starks = || {
        *jon_snow = 3; // error: closure requires unique access to `jon_snow`
                       //        but it is already borrowed
    };
In here, `jon_snow` is already borrowed by the `nights_watch` closure, so it
cannot be borrowed by the `starks` closure at the same time. To fix this issue,
you can put the closure in its own scope:
fn you_know_nothing(jon_snow: &mut i32) {
    {
        let nights_watch = || {
            *jon_snow = 2;
        };
    } // At this point, `jon_snow` is free.
    let starks = || {
        *jon_snow = 3;
    };
Or, if the type implements the `Clone` trait, you can clone it between
closures:
fn you_know_nothing(jon_snow: &mut i32) {
    let mut jon_copy = jon_snow.clone();
    let nights_watch = || {
        jon_copy = 2;
    };
    let starks = || {
        *jon_snow = 3;
    };
E0501
This error indicates that a mutable variable is being used while it is still
captured by a closure. Because the closure has borrowed the variable, it is not
available for use until the closure goes out of scope.
Note that a capture will either move or borrow a variable, but in this
situation, the closure is borrowing the variable. Take a look at
http://rustbyexample.com/fn/closures/capture.html for more information about
capturing.
Example of erroneous code:
```compile_fail
fn inside_closure(x: &mut i32) {
    // Actions which require unique access
fn outside_closure(x: &mut i32) {
    // Actions which require unique access
fn foo(a: &mut i32) {
    let bar = || {
        inside_closure(a)
    };
    outside_closure(a); // error: cannot borrow `*a` as mutable because previous
                        //        closure requires unique access.
To fix this error, you can place the closure in its own scope:
fn inside_closure(x: &mut i32) {}
fn outside_closure(x: &mut i32) {}
fn foo(a: &mut i32) {
    {
        let bar = || {
            inside_closure(a)
        };
    } // borrow on `a` ends.
    outside_closure(a); // ok!
Or you can pass the variable as a parameter to the closure:
fn inside_closure(x: &mut i32) {}
fn outside_closure(x: &mut i32) {}
fn foo(a: &mut i32) {
    let bar = |s: &mut i32| {
        inside_closure(s)
    };
    outside_closure(a);
    bar(a);
It may be possible to define the closure later:
fn inside_closure(x: &mut i32) {}
fn outside_closure(x: &mut i32) {}
fn foo(a: &mut i32) {
    outside_closure(a);
    let bar = || {
        inside_closure(a)
    };
E0502
This error indicates that you are trying to borrow a variable as mutable when it
has already been borrowed as immutable.
Example of erroneous code:
```compile_fail
fn bar(x: &mut i32) {}
fn foo(a: &mut i32) {
    let ref y = a; // a is borrowed as immutable.
    bar(a); // error: cannot borrow `*a` as mutable because `a` is also borrowed
            //        as immutable
To fix this error, ensure that you don't have any other references to the
variable before trying to access it mutably:
fn bar(x: &mut i32) {}
fn foo(a: &mut i32) {
    bar(a);
    let ref y = a; // ok!
For more information on the rust ownership system, take a look at
https://doc.rust-lang.org/stable/book/references-and-borrowing.html.
E0503
A value was used after it was mutably borrowed.
Example of erroneous code:
```compile_fail
fn main() {
    let mut value = 3;
    // Create a mutable borrow of `value`. This borrow
    // lives until the end of this function.
    let _borrow = &mut value;
    let _sum = value + 1; // error: cannot use `value` because
                          //        it was mutably borrowed
In this example, `value` is mutably borrowed by `borrow` and cannot be
used to calculate `sum`. This is not possible because this would violate
Rust's mutability rules.
You can fix this error by limiting the scope of the borrow:
fn main() {
    let mut value = 3;
    // By creating a new block, you can limit the scope
    // of the reference.
    {
        let _borrow = &mut value; // Use `_borrow` inside this block.
    }
    // The block has ended and with it the borrow.
    // You can now use `value` again.
    let _sum = value + 1;
Or by cloning `value` before borrowing it:
fn main() {
    let mut value = 3;
    // We clone `value`, creating a copy.
    let value_cloned = value.clone();
    // The mutable borrow is a reference to `value` and
    // not to `value_cloned`...
    let _borrow = &mut value;
    // ... which means we can still use `value_cloned`,
    let _sum = value_cloned + 1;
    // even though the borrow only ends here.
You can find more information about borrowing in the rust-book:
http://doc.rust-lang.org/stable/book/references-and-borrowing.html
E0504
This error occurs when an attempt is made to move a borrowed variable into a
closure.
Example of erroneous code:
```compile_fail
struct FancyNum {
    num: u8
fn main() {
    let fancy_num = FancyNum { num: 5 };
    let fancy_ref = &fancy_num;
    let x = move || {
        println!("child function: {}", fancy_num.num);
        // error: cannot move `fancy_num` into closure because it is borrowed
    };
    x();
    println!("main function: {}", fancy_ref.num);
Here, `fancy_num` is borrowed by `fancy_ref` and so cannot be moved into
the closure `x`. There is no way to move a value into a closure while it is
borrowed, as that would invalidate the borrow.
If the closure can't outlive the value being moved, try using a reference
rather than moving:
struct FancyNum {
    num: u8
fn main() {
    let fancy_num = FancyNum { num: 5 };
    let fancy_ref = &fancy_num;
    let x = move || {
        // fancy_ref is usable here because it doesn't move `fancy_num`
        println!("child function: {}", fancy_ref.num);
    };
    x();
    println!("main function: {}", fancy_num.num);
If the value has to be borrowed and then moved, try limiting the lifetime of
the borrow using a scoped block:
struct FancyNum {
    num: u8
fn main() {
    let fancy_num = FancyNum { num: 5 };
    {
        let fancy_ref = &fancy_num;
        println!("main function: {}", fancy_ref.num);
        // `fancy_ref` goes out of scope here
    }
    let x = move || {
        // `fancy_num` can be moved now (no more references exist)
        println!("child function: {}", fancy_num.num);
    };
    x();
If the lifetime of a reference isn't enough, such as in the case of threading,
consider using an `Arc` to create a reference-counted value:
use std::sync::Arc;
use std::thread;
struct FancyNum {
    num: u8
fn main() {
    let fancy_ref1 = Arc::new(FancyNum { num: 5 });
    let fancy_ref2 = fancy_ref1.clone();
    let x = thread::spawn(move || {
        // `fancy_ref1` can be moved and has a `'static` lifetime
        println!("child thread: {}", fancy_ref1.num);
    });
    x.join().expect("child thread should finish");
    println!("main thread: {}", fancy_ref2.num);
E0506
This error occurs when an attempt is made to assign to a borrowed value.
Example of erroneous code:
```compile_fail
struct FancyNum {
    num: u8
fn main() {
    let mut fancy_num = FancyNum { num: 5 };
    let fancy_ref = &fancy_num;
    fancy_num = FancyNum { num: 6 };
    // error: cannot assign to `fancy_num` because it is borrowed
    println!("Num: {}, Ref: {}", fancy_num.num, fancy_ref.num);
Because `fancy_ref` still holds a reference to `fancy_num`, `fancy_num` can't
be assigned to a new value as it would invalidate the reference.
Alternatively, we can move out of `fancy_num` into a second `fancy_num`:
struct FancyNum {
    num: u8
fn main() {
    let mut fancy_num = FancyNum { num: 5 };
    let moved_num = fancy_num;
    fancy_num = FancyNum { num: 6 };
    println!("Num: {}, Moved num: {}", fancy_num.num, moved_num.num);
If the value has to be borrowed, try limiting the lifetime of the borrow using
a scoped block:
struct FancyNum {
    num: u8
fn main() {
    let mut fancy_num = FancyNum { num: 5 };
    {
        let fancy_ref = &fancy_num;
        println!("Ref: {}", fancy_ref.num);
    }
    // Works because `fancy_ref` is no longer in scope
    fancy_num = FancyNum { num: 6 };
    println!("Num: {}", fancy_num.num);
Or by moving the reference into a function:
struct FancyNum {
    num: u8
fn main() {
    let mut fancy_num = FancyNum { num: 5 };
    print_fancy_ref(&fancy_num);
    // Works because function borrow has ended
    fancy_num = FancyNum { num: 6 };
    println!("Num: {}", fancy_num.num);
fn print_fancy_ref(fancy_ref: &FancyNum){
    println!("Ref: {}", fancy_ref.num);
E0505
A value was moved out while it was still borrowed.
Erroneous code example:
```compile_fail
struct Value {}
fn eat(val: Value) {}
fn main() {
    let x = Value{};
    {
        let _ref_to_val: &Value = &x;
        eat(x);
    }
Here, the function `eat` takes the ownership of `x`. However,
`x` cannot be moved because it was borrowed to `_ref_to_val`.
To fix that you can do few different things:
* Try to avoid moving the variable.
* Release borrow before move.
* Implement the `Copy` trait on the type.
Examples:
struct Value {}
fn eat(val: &Value) {}
fn main() {
    let x = Value{};
    {
        let _ref_to_val: &Value = &x;
        eat(&x); // pass by reference, if it's possible
    }
struct Value {}
fn eat(val: Value) {}
fn main() {
    let x = Value{};
    {
        let _ref_to_val: &Value = &x;
    }
    eat(x); // release borrow and then move it.
#[derive(Clone, Copy)] // implement Copy trait
struct Value {}
fn eat(val: Value) {}
fn main() {
    let x = Value{};
    {
        let _ref_to_val: &Value = &x;
        eat(x); // it will be copied here.
    }
You can find more information about borrowing in the rust-book:
http://doc.rust-lang.org/stable/book/references-and-borrowing.html
E0507
You tried to move out of a value which was borrowed. Erroneous code example:
```compile_fail
use std::cell::RefCell;
struct TheDarkKnight;
impl TheDarkKnight {
    fn nothing_is_true(self) {}
fn main() {
    let x = RefCell::new(TheDarkKnight);
    x.borrow().nothing_is_true(); // error: cannot move out of borrowed content
Here, the `nothing_is_true` method takes the ownership of `self`. However,
`self` cannot be moved because `.borrow()` only provides an `&TheDarkKnight`,
which is a borrow of the content owned by the `RefCell`. To fix this error,
you have three choices:
* Try to avoid moving the variable.
* Somehow reclaim the ownership.
* Implement the `Copy` trait on the type.
Examples:
use std::cell::RefCell;
struct TheDarkKnight;
impl TheDarkKnight {
    fn nothing_is_true(&self) {} // First case, we don't take ownership
fn main() {
    let x = RefCell::new(TheDarkKnight);
    x.borrow().nothing_is_true(); // ok!
use std::cell::RefCell;
struct TheDarkKnight;
impl TheDarkKnight {
    fn nothing_is_true(self) {}
fn main() {
    let x = RefCell::new(TheDarkKnight);
    let x = x.into_inner(); // we get back ownership
    x.nothing_is_true(); // ok!
use std::cell::RefCell;
#[derive(Clone, Copy)] // we implement the Copy trait
struct TheDarkKnight;
impl TheDarkKnight {
    fn nothing_is_true(self) {}
fn main() {
    let x = RefCell::new(TheDarkKnight);
    x.borrow().nothing_is_true(); // ok!
Moving out of a member of a mutably borrowed struct is fine if you put something
back. `mem::replace` can be used for that:
```ignore
struct TheDarkKnight;
impl TheDarkKnight {
    fn nothing_is_true(self) {}
struct Batcave {
    knight: TheDarkKnight
fn main() {
    use std::mem;
    let mut cave = Batcave {
        knight: TheDarkKnight
    };
    let borrowed = &mut cave;
    borrowed.knight.nothing_is_true(); // E0507
    mem::replace(&mut borrowed.knight, TheDarkKnight).nothing_is_true(); // ok!
You can find more information about borrowing in the rust-book:
http://doc.rust-lang.org/stable/book/references-and-borrowing.html
E0508
A value was moved out of a non-copy fixed-size array.
Example of erroneous code:
```compile_fail
struct NonCopy;
fn main() {
    let array = [NonCopy; 1];
    let _value = array[0]; // error: cannot move out of type `[NonCopy; 1]`,
                           //        a non-copy fixed-size array
The first element was moved out of the array, but this is not
possible because `NonCopy` does not implement the `Copy` trait.
Consider borrowing the element instead of moving it:
struct NonCopy;
fn main() {
    let array = [NonCopy; 1];
    let _value = &array[0]; // Borrowing is allowed, unlike moving.
Alternatively, if your type implements `Clone` and you need to own the value,
consider borrowing and then cloning:
#[derive(Clone)]
struct NonCopy;
fn main() {
    let array = [NonCopy; 1];
    // Now you can clone the array element.
    let _value = array[0].clone();
E0509
This error occurs when an attempt is made to move out of a value whose type
implements the `Drop` trait.
Example of erroneous code:
```compile_fail
struct FancyNum {
    num: usize
struct DropStruct {
    fancy: FancyNum
impl Drop for DropStruct {
    fn drop(&mut self) {
        // Destruct DropStruct, possibly using FancyNum
    }
fn main() {
    let drop_struct = DropStruct{fancy: FancyNum{num: 5}};
    let fancy_field = drop_struct.fancy; // Error E0509
    println!("Fancy: {}", fancy_field.num);
    // implicit call to `drop_struct.drop()` as drop_struct goes out of scope
Here, we tried to move a field out of a struct of type `DropStruct` which
implements the `Drop` trait. However, a struct cannot be dropped if one or
more of its fields have been moved.
Structs implementing the `Drop` trait have an implicit destructor that gets
called when they go out of scope. This destructor may use the fields of the
struct, so moving out of the struct could make it impossible to run the
destructor. Therefore, we must think of all values whose type implements the
`Drop` trait as single units whose fields cannot be moved.
This error can be fixed by creating a reference to the fields of a struct,
enum, or tuple using the `ref` keyword:
struct FancyNum {
    num: usize
struct DropStruct {
    fancy: FancyNum
impl Drop for DropStruct {
    fn drop(&mut self) {
        // Destruct DropStruct, possibly using FancyNum
    }
fn main() {
    let drop_struct = DropStruct{fancy: FancyNum{num: 5}};
    let ref fancy_field = drop_struct.fancy; // No more errors!
    println!("Fancy: {}", fancy_field.num);
    // implicit call to `drop_struct.drop()` as drop_struct goes out of scope
Note that this technique can also be used in the arms of a match expression:
struct FancyNum {
    num: usize
enum DropEnum {
    Fancy(FancyNum)
impl Drop for DropEnum {
    fn drop(&mut self) {
        // Destruct DropEnum, possibly using FancyNum
    }
fn main() {
    // Creates and enum of type `DropEnum`, which implements `Drop`
    let drop_enum = DropEnum::Fancy(FancyNum{num: 10});
    match drop_enum {
        // Creates a reference to the inside of `DropEnum::Fancy`
        DropEnum::Fancy(ref fancy_field) => // No error!
            println!("It was fancy-- {}!", fancy_field.num),
    }
    // implicit call to `drop_enum.drop()` as drop_enum goes out of scope
E0401
Inner items do not inherit type parameters from the functions they are embedded
Erroneous code example:
```compile_fail,E0401
fn foo<T>(x: T) {
    fn bar(y: T) { // T is defined in the "outer" function
        // ..
    }
    bar(x);
Nor will this:
```compile_fail,E0401
fn foo<T>(x: T) {
    type MaybeT = Option<T>;
    // ...
Or this:
```compile_fail,E0401
fn foo<T>(x: T) {
    struct Foo {
        x: T,
    }
    // ...
Items inside functions are basically just like top-level items, except
that they can only be used from the function they are in.
There are a couple of solutions for this.
If the item is a function, you may use a closure:
fn foo<T>(x: T) {
    let bar = |y: T| { // explicit type annotation may not be necessary
        // ..
    };
    bar(x);
For a generic item, you can copy over the parameters:
fn foo<T>(x: T) {
    fn bar<T>(y: T) {
        // ..
    }
    bar(x);
fn foo<T>(x: T) {
    type MaybeT<T> = Option<T>;
Be sure to copy over any bounds as well:
fn foo<T: Copy>(x: T) {
    fn bar<T: Copy>(y: T) {
        // ..
    }
    bar(x);
fn foo<T: Copy>(x: T) {
    struct Foo<T: Copy> {
        x: T,
    }
This may require additional type hints in the function body.
In case the item is a function inside an `impl`, defining a private helper
function might be easier:
```ignore
impl<T> Foo<T> {
    pub fn foo(&self, x: T) {
        self.bar(x);
    }
    fn bar(&self, y: T) {
        // ..
    }
For default impls in traits, the private helper solution won't work, however
closures or copying the parameters should still work.
E0403
Some type parameters have the same name.
Erroneous code example:
```compile_fail,E0403
fn foo<T, T>(s: T, u: T) {} // error: the name `T` is already used for a type
                            //        parameter in this type parameter list
Please verify that none of the type parameterss are misspelled, and rename any
clashing parameters. Example:
fn foo<T, Y>(s: T, u: Y) {} // ok!
E0404
You tried to implement something which was not a trait on an object.
Erroneous code example:
```compile_fail,E0404
struct Foo;
struct Bar;
impl Foo for Bar {} // error: `Foo` is not a trait
Please verify that you didn't misspell the trait's name or otherwise use the
wrong identifier. Example:
trait Foo {
    // some functions
struct Bar;
impl Foo for Bar { // ok!
    // functions implementation
E0405
The code refers to a trait that is not in scope.
Erroneous code example:
```compile_fail,E0405
struct Foo;
impl SomeTrait for Foo {} // error: trait `SomeTrait` is not in scope
Please verify that the name of the trait wasn't misspelled and ensure that it
was imported. Example:
```ignore
// solution 1:
use some_file::SomeTrait;
// solution 2:
trait SomeTrait {
    // some functions
struct Foo;
impl SomeTrait for Foo { // ok!
    // implements functions
E0407
A definition of a method not in the implemented trait was given in a trait
implementation.
Erroneous code example:
```compile_fail,E0407
trait Foo {
    fn a();
struct Bar;
impl Foo for Bar {
    fn a() {}
    fn b() {} // error: method `b` is not a member of trait `Foo`
Please verify you didn't misspell the method name and you used the correct
trait. First example:
trait Foo {
    fn a();
    fn b();
struct Bar;
impl Foo for Bar {
    fn a() {}
    fn b() {} // ok!
Second example:
trait Foo {
    fn a();
struct Bar;
impl Foo for Bar {
    fn a() {}
impl Bar {
    fn b() {}
E0437
Trait implementations can only implement associated types that are members of
the trait in question. This error indicates that you attempted to implement
an associated type whose name does not match the name of any associated type
in the trait.
Erroneous code example:
```compile_fail,E0437
trait Foo {}
impl Foo for i32 {
    type Bar = bool;
The solution to this problem is to remove the extraneous associated type:
trait Foo {}
impl Foo for i32 {}
E0438
Trait implementations can only implement associated constants that are
members of the trait in question. This error indicates that you
attempted to implement an associated constant whose name does not
match the name of any associated constant in the trait.
Erroneous code example:
```compile_fail,E0438
#![feature(associated_consts)]
trait Foo {}
impl Foo for i32 {
    const BAR: bool = true;
The solution to this problem is to remove the extraneous associated constant:
trait Foo {}
impl Foo for i32 {}
E0408
An "or" pattern was used where the variable bindings are not consistently bound
across patterns.
Erroneous code example:
```compile_fail,E0408
match x {
    Some(y) | None => { /* use y */ } // error: variable `y` from pattern #1 is
                                      //        not bound in pattern #2
    _ => ()
Here, `y` is bound to the contents of the `Some` and can be used within the
block corresponding to the match arm. However, in case `x` is `None`, we have
not specified what `y` is, and the block will use a nonexistent variable.
To fix this error, either split into multiple match arms:
let x = Some(1);
match x {
    Some(y) => { /* use y */ }
    None => { /* ... */ }
or, bind the variable to a field of the same type in all sub-patterns of the
or pattern:
let x = (0, 2);
match x {
    (0, y) | (y, 0) => { /* use y */}
    _ => {}
In this example, if `x` matches the pattern `(0, _)`, the second field is set
to `y`. If it matches `(_, 0)`, the first field is set to `y`; so in all
cases `y` is set to some value.
E0409
An "or" pattern was used where the variable bindings are not consistently bound
across patterns.
Erroneous code example:
```compile_fail,E0409
let x = (0, 2);
match x {
    (0, ref y) | (y, 0) => { /* use y */} // error: variable `y` is bound with
                                          //        different mode in pattern #2
                                          //        than in pattern #1
    _ => ()
Here, `y` is bound by-value in one case and by-reference in the other.
To fix this error, just use the same mode in both cases.
Generally using `ref` or `ref mut` where not already used will fix this:
```ignore
let x = (0, 2);
match x {
    (0, ref y) | (ref y, 0) => { /* use y */}
    _ => ()
Alternatively, split the pattern:
let x = (0, 2);
match x {
    (y, 0) => { /* use y */ }
    (0, ref y) => { /* use y */}
    _ => ()
E0411
The `Self` keyword was used outside an impl or a trait.
Erroneous code example:
```compile_fail,E0411
<Self>::foo; // error: use of `Self` outside of an impl or trait
The `Self` keyword represents the current type, which explains why it can only
be used inside an impl or a trait. It gives access to the associated items of a
type:
trait Foo {
    type Bar;
trait Baz : Foo {
    fn bar() -> Self::Bar; // like this
However, be careful when two types have a common associated type:
```compile_fail
trait Foo {
    type Bar;
trait Foo2 {
    type Bar;
trait Baz : Foo + Foo2 {
    fn bar() -> Self::Bar;
    // error: ambiguous associated type `Bar` in bounds of `Self`
This problem can be solved by specifying from which trait we want to use the
`Bar` type:
trait Foo {
    type Bar;
trait Foo2 {
    type Bar;
trait Baz : Foo + Foo2 {
    fn bar() -> <Self as Foo>::Bar; // ok!
E0412
The type name used is not in scope.
Erroneous code examples:
```compile_fail,E0412
impl Something {} // error: type name `Something` is not in scope
// or:
trait Foo {
    fn bar(N); // error: type name `N` is not in scope
// or:
fn foo(x: T) {} // type name `T` is not in scope
To fix this error, please verify you didn't misspell the type name, you did
declare it or imported it into the scope. Examples:
struct Something;
impl Something {} // ok!
// or:
trait Foo {
    type N;
    fn bar(Self::N); // ok!
// or:
fn foo<T>(x: T) {} // ok!
E0415
More than one function parameter have the same name.
Erroneous code example:
```compile_fail,E0415
fn foo(f: i32, f: i32) {} // error: identifier `f` is bound more than
                          //        once in this parameter list
Please verify you didn't misspell parameters' name. Example:
fn foo(f: i32, g: i32) {} // ok!
E0416
An identifier is bound more than once in a pattern.
Erroneous code example:
```compile_fail,E0416
match (1, 2) {
    (x, x) => {} // error: identifier `x` is bound more than once in the
                 //        same pattern
Please verify you didn't misspell identifiers' name. Example:
match (1, 2) {
    (x, y) => {} // ok!
Or maybe did you mean to unify? Consider using a guard:
```ignore
match (A, B, C) {
    (x, x2, see) if x == x2 => { /* A and B are equal, do one thing */ }
    (y, z, see) => { /* A and B unequal; do another thing */ }
E0422
You are trying to use an identifier that is either undefined or not a struct.
Erroneous code example:
``` compile_fail,E0422
fn main () {
    let x = Foo { x: 1, y: 2 };
In this case, `Foo` is undefined, so it inherently isn't anything, and
definitely not a struct.
```compile_fail,E0422
fn main () {
    let foo = 1;
    let x = foo { x: 1, y: 2 };
In this case, `foo` is defined, but is not a struct, so Rust can't use it as
one.
E0423
A `struct` variant name was used like a function name.
Erroneous code example:
```compile_fail,E0423
struct Foo { a: bool};
let f = Foo();
// error: `Foo` is a struct variant name, but this expression uses
//        it like a function name
Please verify you didn't misspell the name of what you actually wanted to use
here. Example:
fn Foo() -> u32 { 0 }
let f = Foo(); // ok!
E0424
The `self` keyword was used in a static method.
Erroneous code example:
```compile_fail,E0424
struct Foo;
impl Foo {
    fn bar(self) {}
    fn foo() {
        self.bar(); // error: `self` is not available in a static method.
    }
Please check if the method's argument list should have contained `self`,
`&self`, or `&mut self` (in case you didn't want to create a static
method), and add it if so. Example:
struct Foo;
impl Foo {
    fn bar(self) {}
    fn foo(self) {
        self.bar(); // ok!
    }
E0425
An unresolved name was used.
Erroneous code examples:
```compile_fail,E0425
something_that_doesnt_exist::foo;
// error: unresolved name `something_that_doesnt_exist::foo`
// or:
trait Foo {
    fn bar() {
        Self; // error: unresolved name `Self`
    }
// or:
let x = unknown_variable;  // error: unresolved name `unknown_variable`
Please verify that the name wasn't misspelled and ensure that the
identifier being referred to is valid for the given situation. Example:
enum something_that_does_exist {
    Foo,
mod something_that_does_exist {
    pub static foo : i32 = 0i32;
something_that_does_exist::foo; // ok!
let unknown_variable = 12u32;
let x = unknown_variable; // ok!
If the item is not defined in the current module, it must be imported using a
`use` statement, like so:
```ignore
use foo::bar;
bar();
If the item you are importing is not defined in some super-module of the
current module, then it must also be declared as public (e.g., `pub fn`).
E0426
An undeclared label was used.
Erroneous code example:
```compile_fail,E0426
loop {
    break 'a; // error: use of undeclared label `'a`
Please verify you spelt or declare the label correctly. Example:
'a: loop {
    break 'a; // ok!
E0429
The `self` keyword cannot appear alone as the last segment in a `use`
declaration.
Erroneous code example:
```compile_fail,E0429
use std::fmt::self; // error: `self` imports are only allowed within a { } list
To use a namespace itself in addition to some of its members, `self` may appear
as part of a brace-enclosed list of imports:
use std::fmt::{self, Debug};
If you only want to import the namespace, do so directly:
use std::fmt;
E0430
The `self` import appears more than once in the list.
Erroneous code example:
```compile_fail,E0430
use something::{self, self}; // error: `self` import can only appear once in
                             //        the list
Please verify you didn't misspell the import name or remove the duplicated
`self` import. Example:
```ignore
use something::self; // ok!
E0431
An invalid `self` import was made.
Erroneous code example:
```compile_fail,E0431
use {self}; // error: `self` import can only appear in an import list with a
            //        non-empty prefix
You cannot import the current module into itself, please remove this import
or verify you didn't misspell it.
E0432
An import was unresolved.
Erroneous code example:
```compile_fail,E0432
use something::Foo; // error: unresolved import `something::Foo`.
Paths in `use` statements are relative to the crate root. To import items
relative to the current and parent modules, use the `self::` and `super::`
prefixes, respectively. Also verify that you didn't misspell the import
name and that the import exists in the module from where you tried to
import it. Example:
```ignore
use self::something::Foo; // ok!
mod something {
    pub struct Foo;
Or, if you tried to use a module from an external crate, you may have missed
the `extern crate` declaration (which is usually placed in the crate root):
```ignore
extern crate homura; // Required to use the `homura` crate
use homura::Madoka;
E0433
An undeclared type or module was used.
Erroneous code example:
```compile_fail,E0433
let map = HashMap::new();
// error: failed to resolve. Use of undeclared type or module `HashMap`
Please verify you didn't misspell the type/module's name or that you didn't
forgot to import it:
use std::collections::HashMap; // HashMap has been imported.
let map: HashMap<u32, u32> = HashMap::new(); // So it can be used!
E0434
This error indicates that a variable usage inside an inner function is invalid
because the variable comes from a dynamic environment. Inner functions do not
have access to their containing environment.
Erroneous code example:
```compile_fail,E0434
fn foo() {
    let y = 5;
    fn bar() -> u32 {
        y // error: can't capture dynamic environment in a fn item; use the
          //        || { ... } closure form instead.
    }
Functions do not capture local variables. To fix this error, you can replace the
function with a closure:
fn foo() {
    let y = 5;
    let bar = || {
        y
    };
or replace the captured variable with a constant or a static item:
fn foo() {
    static mut X: u32 = 4;
    const Y: u32 = 5;
    fn bar() -> u32 {
        unsafe {
            X = 3;
        }
        Y
    }
E0435
A non-constant value was used to initialise a constant.
Erroneous code example:
```compile_fail,E0435
let foo = 42u32;
const FOO : u32 = foo; // error: attempt to use a non-constant value in a
                       //        constant
To fix this error, please replace the value with a constant. Example:
const FOO : u32 = 42u32; // ok!
const OTHER_FOO : u32 = 42u32;
const FOO : u32 = OTHER_FOO; // ok!
E0259
The name chosen for an external crate conflicts with another external crate
that has been imported into the current module.
Erroneous code example:
```compile_fail,E0259
extern crate std;
extern crate libc as std;
fn main() {}
The solution is to choose a different name that doesn't conflict with any
external crate imported into the current module.
Correct example:
```ignore
extern crate std;
extern crate libc as other_name;
E0260
The name for an item declaration conflicts with an external crate's name.
Erroneous code example:
```ignore,E0260
extern crate abc;
struct abc;
There are two possible solutions:
Solution #1: Rename the item.
```ignore
extern crate abc;
struct xyz;
Solution #2: Import the crate with a different name.
```ignore
extern crate abc as xyz;
struct abc;
See the Declaration Statements section of the reference for more information
about what constitutes an Item declaration and what does not:
https://doc.rust-lang.org/reference.html#statements
E0428
A type or module has been defined more than once.
Erroneous code example:
```compile_fail,E0428
struct Bar;
struct Bar; // error: duplicate definition of value `Bar`
Please verify you didn't misspell the type/module's name or remove/rename the
duplicated one. Example:
struct Bar;
struct Bar2; // ok!
E0252
Two items of the same name cannot be imported without rebinding one of the
items under a new local name.
Erroneous code example:
```compile_fail,E0252
use foo::baz;
use bar::baz; // error, do `use bar::baz as quux` instead
fn main() {}
mod foo {
    pub struct baz;
mod bar {
    pub mod baz {}
You can use aliases in order to fix this error. Example:
use foo::baz as foo_baz;
use bar::baz; // ok!
fn main() {}
mod foo {
    pub struct baz;
mod bar {
    pub mod baz {}
Or you can reference the item with its parent:
use bar::baz;
fn main() {
    let x = foo::baz; // ok!
mod foo {
    pub struct baz;
mod bar {
    pub mod baz {}
E0255
You can't import a value whose name is the same as another value defined in the
module.
Erroneous code example:
```compile_fail,E0255
use bar::foo; // error: an item named `foo` is already in scope
fn foo() {}
mod bar {
     pub fn foo() {}
fn main() {}
You can use aliases in order to fix this error. Example:
use bar::foo as bar_foo; // ok!
fn foo() {}
mod bar {
     pub fn foo() {}
fn main() {}
Or you can reference the item with its parent:
fn foo() {}
mod bar {
     pub fn foo() {}
fn main() {
    bar::foo(); // we get the item by referring to its parent
E0154
## Note: this error code is no longer emitted by the compiler.
Imports (`use` statements) are not allowed after non-item statements, such as
variable declarations and expression statements.
Here is an example that demonstrates the error:
```ignore
fn f() {
    // Variable declaration before import
    let x = 0;
    use std::io::Read;
    // ...
The solution is to declare the imports at the top of the block, function, or
file.
Here is the previous example again, with the correct order:
fn f() {
    use std::io::Read;
    let x = 0;
    // ...
See the Declaration Statements section of the reference for more information
about what constitutes an Item declaration and what does not:
https://doc.rust-lang.org/reference.html#statements
E0251
## Note: this error code is no longer emitted by the compiler.
Two items of the same name cannot be imported without rebinding one of the
items under a new local name.
An example of this error:
```compile_fail
use foo::baz;
use bar::*; // error, do `use foo::baz as quux` instead on the previous line
fn main() {}
mod foo {
    pub struct baz;
mod bar {
    pub mod baz {}
E0253
Attempt was made to import an unimportable value. This can happen when trying
to import a method from a trait.
Erroneous code example:
```compile_fail,E0253
mod foo {
    pub trait MyTrait {
        fn do_something();
    }
use foo::MyTrait::do_something;
fn main() {}
It's invalid to directly import methods belonging to a trait or concrete type.
E0256
## Note: this error code is no longer emitted by the compiler.
You can't import a type or module when the name of the item being imported is
the same as another type or submodule defined in the module.
An example of this error:
```compile_fail
use foo::Bar; // error
type Bar = u32;
mod foo {
    pub mod Bar { }
fn main() {}
E0364
Private items cannot be publicly re-exported. This error indicates that you
attempted to `pub use` a type or value that was not itself public.
Erroneous code example:
```compile_fail
mod foo {
    const X: u32 = 1;
pub use foo::X;
fn main() {}
The solution to this problem is to ensure that the items that you are
re-exporting are themselves marked with `pub`:
mod foo {
    pub const X: u32 = 1;
pub use foo::X;
fn main() {}
See the 'Use Declarations' section of the reference for more information on
this topic:
https://doc.rust-lang.org/reference.html#use-declarations
E0365
Private modules cannot be publicly re-exported. This error indicates that you
attempted to `pub use` a module that was not itself public.
Erroneous code example:
```compile_fail,E0365
mod foo {
    pub const X: u32 = 1;
pub use foo as foo2;
fn main() {}
The solution to this problem is to ensure that the module that you are
re-exporting is itself marked with `pub`:
pub mod foo {
    pub const X: u32 = 1;
pub use foo as foo2;
fn main() {}
See the 'Use Declarations' section of the reference for more information
on this topic:
https://doc.rust-lang.org/reference.html#use-declarations
E0451
A struct constructor with private fields was invoked. Erroneous code example:
```compile_fail,E0451
mod Bar {
    pub struct Foo {
        pub a: isize,
        b: isize,
    }
let f = Bar::Foo{ a: 0, b: 0 }; // error: field `b` of struct `Bar::Foo`
                                //        is private
To fix this error, please ensure that all the fields of the struct are public,
or implement a function for easy instantiation. Examples:
mod Bar {
    pub struct Foo {
        pub a: isize,
        pub b: isize, // we set `b` field public
    }
let f = Bar::Foo{ a: 0, b: 0 }; // ok!
mod Bar {
    pub struct Foo {
        pub a: isize,
        b: isize, // still private
    }
    impl Foo {
        pub fn new() -> Foo { // we create a method to instantiate `Foo`
            Foo { a: 0, b: 0 }
        }
    }
let f = Bar::Foo::new(); // ok!
E0450
A tuple constructor was invoked while some of its fields are private. Erroneous
code example:
```compile_fail,E0450
mod Bar {
    pub struct Foo(isize);
let f = Bar::Foo(0); // error: cannot invoke tuple struct constructor with
                     //        private fields
To solve this issue, please ensure that all of the fields of the tuple struct
are public. Alternatively, provide a `new()` method to the tuple struct to
construct it from a given inner value. Example:
mod Bar {
    pub struct Foo(pub isize); // we set its field to public
let f = Bar::Foo(0); // ok!
// or:
mod bar {
    pub struct Foo(isize);
    impl Foo {
        pub fn new(x: isize) -> Foo {
            Foo(x)
        }
    }
let f = bar::Foo::new(1);
E0446
A private type was used in a public type signature. Erroneous code example:
```compile_fail,E0446
#![deny(private_in_public)]
mod Foo {
    struct Bar(u32);
    pub fn bar() -> Bar { // error: private type in public interface
        Bar(0)
    }
To solve this error, please ensure that the type is also public. The type
can be made inaccessible if necessary by placing it into a private inner
module, but it still has to be marked with `pub`.
Example:
mod Foo {
    pub struct Bar(u32); // we set the Bar type public
    pub fn bar() -> Bar { // ok!
        Bar(0)
    }
E0445
A private trait was used on a public type parameter bound. Erroneous code
examples:
```compile_fail,E0445
#![deny(private_in_public)]
trait Foo {
    fn dummy(&self) { }
pub trait Bar : Foo {} // error: private trait in public interface
pub struct Bar2<T: Foo>(pub T); // same error
pub fn foo<T: Foo> (t: T) {} // same error
To solve this error, please ensure that the trait is also public. The trait
can be made inaccessible if necessary by placing it into a private inner
module, but it still has to be marked with `pub`. Example:
```ignore
pub trait Foo { // we set the Foo trait public
    fn dummy(&self) { }
pub trait Bar : Foo {} // ok!
pub struct Bar2<T: Foo>(pub T); // ok!
pub fn foo<T: Foo> (t: T) {} // ok!
E0447
The `pub` keyword was used inside a function. Erroneous code example:
```ignore
fn foo() {
    pub struct Bar; // error: visibility has no effect inside functions
Since we cannot access items defined inside a function, the visibility of its
items does not impact outer code. So using the `pub` keyword in this context
is invalid.
E0448
The `pub` keyword was used inside a public enum. Erroneous code example:
```compile_fail
pub enum Foo {
    pub Bar, // error: unnecessary `pub` visibility
Since the enum is already public, adding `pub` on one its elements is
unnecessary. Example:
```compile_fail,
enum Foo {
    pub Bar, // not ok!
This is the correct syntax:
```ignore
pub enum Foo {
    Bar, // ok!
E0510
`return_address` was used in an invalid context. Erroneous code example:
```ignore
#![feature(intrinsics)]
extern "rust-intrinsic" {
    fn return_address() -> *const u8;
unsafe fn by_value() -> i32 {
    let _ = return_address();
    // error: invalid use of `return_address` intrinsic: function does
    //        not use out pointer
    0
Return values may be stored in a return register(s) or written into a so-called
out pointer. In case the returned value is too big (this is
target-ABI-dependent and generally not portable or future proof) to fit into
the return register(s), the compiler will return the value by writing it into
space allocated in the caller's stack frame. Example:
#![feature(intrinsics)]
extern "rust-intrinsic" {
    fn return_address() -> *const u8;
unsafe fn by_pointer() -> String {
    let _ = return_address();
    String::new() // ok!
E0511
Invalid monomorphization of an intrinsic function was used. Erroneous code
example:
```ignore
#![feature(platform_intrinsics)]
extern "platform-intrinsic" {
    fn simd_add<T>(a: T, b: T) -> T;
unsafe { simd_add(0, 1); }
// error: invalid monomorphization of `simd_add` intrinsic
The generic type has to be a SIMD type. Example:
#![feature(repr_simd)]
#![feature(platform_intrinsics)]
#[repr(simd)]
#[derive(Copy, Clone)]
struct i32x1(i32);
extern "platform-intrinsic" {
    fn simd_add<T>(a: T, b: T) -> T;
unsafe { simd_add(i32x1(0), i32x1(1)); } // ok!
E0001
This error suggests that the expression arm corresponding to the noted pattern
will never be reached as for all possible values of the expression being
matched, one of the preceding patterns will match.
This means that perhaps some of the preceding patterns are too general, this
one is too specific or the ordering is incorrect.
For example, the following `match` block has too many arms:
```compile_fail
match foo {
    Some(bar) => {/* ... */}
    None => {/* ... */}
    _ => {/* ... */} // All possible cases have already been handled
`match` blocks have their patterns matched in order, so, for example, putting
a wildcard arm above a more specific arm will make the latter arm irrelevant.
Ensure the ordering of the match arm is correct and remove any superfluous
arms.
E0002
This error indicates that an empty match expression is invalid because the type
it is matching on is non-empty (there exist values of this type). In safe code
it is impossible to create an instance of an empty type, so empty match
expressions are almost never desired. This error is typically fixed by adding
one or more cases to the match expression.
An example of an empty type is `enum Empty { }`. So, the following will work:
enum Empty {}
fn foo(x: Empty) {
    match x {
        // empty
    }
However, this won't:
```compile_fail
fn foo(x: Option<String>) {
    match x {
        // empty
    }
E0003
Not-a-Number (NaN) values cannot be compared for equality and hence can never
match the input to a match expression. So, the following will not compile:
```compile_fail
#![deny(illegal_floating_point_constant_pattern)]
const NAN: f32 = 0.0 / 0.0;
let number = 0.1f32;
match number {
    NAN => { /* ... */ },
    _ => {}
To match against NaN values, you should instead use the `is_nan()` method in a
guard, like so:
let number = 0.1f32;
match number {
    x if x.is_nan() => { /* ... */ }
    _ => {}
E0004
This error indicates that the compiler cannot guarantee a matching pattern for
one or more possible inputs to a match expression. Guaranteed matches are
required in order to assign values to match expressions, or alternatively,
determine the flow of execution. Erroneous code example:
```compile_fail
enum Terminator {
    HastaLaVistaBaby,
    TalkToMyHand,
let x = Terminator::HastaLaVistaBaby;
match x { // error: non-exhaustive patterns: `HastaLaVistaBaby` not covered
    Terminator::TalkToMyHand => {}
If you encounter this error you must alter your patterns so that every possible
value of the input type is matched. For types with a small number of variants
(like enums) you should probably cover all cases explicitly. Alternatively, the
underscore `_` wildcard pattern can be added after all other patterns to match
"anything else". Example:
enum Terminator {
    HastaLaVistaBaby,
    TalkToMyHand,
let x = Terminator::HastaLaVistaBaby;
match x {
    Terminator::TalkToMyHand => {}
    Terminator::HastaLaVistaBaby => {}
// or:
match x {
    Terminator::TalkToMyHand => {}
    _ => {}
E0005
Patterns used to bind names must be irrefutable, that is, they must guarantee
that a name will be extracted in all cases. Erroneous code example:
```compile_fail
let x = Some(1);
let Some(y) = x;
// error: refutable pattern in local binding: `None` not covered
If you encounter this error you probably need to use a `match` or `if let` to
deal with the possibility of failure. Example:
let x = Some(1);
match x {
    Some(y) => {
        // do something
    },
    None => {}
// or:
if let Some(y) = x {
    // do something
E0007
This error indicates that the bindings in a match arm would require a value to
be moved into more than one location, thus violating unique ownership. Code
like the following is invalid as it requires the entire `Option<String>` to be
moved into a variable called `op_string` while simultaneously requiring the
inner `String` to be moved into a variable called `s`.
```compile_fail
let x = Some("s".to_string());
match x {
    op_string @ Some(s) => {}, // error: cannot bind by-move with sub-bindings
    None => {},
See also the error E0303.
E0008
Names bound in match arms retain their type in pattern guards. As such, if a
name is bound by move in a pattern, it should also be moved to wherever it is
referenced in the pattern guard code. Doing so however would prevent the name
from being available in the body of the match arm. Consider the following:
```compile_fail
match Some("hi".to_string()) {
    Some(s) if s.len() == 0 => {}, // use s.
    _ => {},
The variable `s` has type `String`, and its use in the guard is as a variable of
type `String`. The guard code effectively executes in a separate scope to the
body of the arm, so the value would be moved into this anonymous scope and
therefore becomes unavailable in the body of the arm.
The problem above can be solved by using the `ref` keyword.
match Some("hi".to_string()) {
    Some(ref s) if s.len() == 0 => {},
    _ => {},
Though this example seems innocuous and easy to solve, the problem becomes clear
when it encounters functions which consume the value:
```compile_fail
struct A{}
impl A {
    fn consume(self) -> usize {
        0
    }
fn main() {
    let a = Some(A{});
    match a {
        Some(y) if y.consume() > 0 => {}
        _ => {}
    }
In this situation, even the `ref` keyword cannot solve it, since borrowed
content cannot be moved. This problem cannot be solved generally. If the value
can be cloned, here is a not-so-specific solution:
#[derive(Clone)]
struct A{}
impl A {
    fn consume(self) -> usize {
        0
    }
fn main() {
    let a = Some(A{});
    match a{
        Some(ref y) if y.clone().consume() > 0 => {}
        _ => {}
    }
If the value will be consumed in the pattern guard, using its clone will not
move its ownership, so the code works.
E0009
In a pattern, all values that don't implement the `Copy` trait have to be bound
the same way. The goal here is to avoid binding simultaneously by-move and
by-ref.
This limitation may be removed in a future version of Rust.
Erroneous code example:
```compile_fail
struct X { x: (), }
let x = Some((X { x: () }, X { x: () }));
match x {
    Some((y, ref z)) => {}, // error: cannot bind by-move and by-ref in the
                            //        same pattern
    None => panic!()
You have two solutions:
Solution #1: Bind the pattern's values the same way.
struct X { x: (), }
let x = Some((X { x: () }, X { x: () }));
match x {
    Some((ref y, ref z)) => {},
    // or Some((y, z)) => {}
    None => panic!()
Solution #2: Implement the `Copy` trait for the `X` structure.
However, please keep in mind that the first solution should be preferred.
#[derive(Clone, Copy)]
struct X { x: (), }
let x = Some((X { x: () }, X { x: () }));
match x {
    Some((y, ref z)) => {},
    None => panic!()
E0158
`const` and `static` mean different things. A `const` is a compile-time
constant, an alias for a literal value. This property means you can match it
directly within a pattern.
The `static` keyword, on the other hand, guarantees a fixed location in memory.
This does not always mean that the value is constant. For example, a global
mutex can be declared `static` as well.
If you want to match against a `static`, consider using a guard instead:
static FORTY_TWO: i32 = 42;
match Some(42) {
    Some(x) if x == FORTY_TWO => {}
    _ => {}
E0162
An if-let pattern attempts to match the pattern, and enters the body if the
match was successful. If the match is irrefutable (when it cannot fail to
match), use a regular `let`-binding instead. For instance:
```compile_fail
struct Irrefutable(i32);
let irr = Irrefutable(0);
// This fails to compile because the match is irrefutable.
if let Irrefutable(x) = irr {
    // This body will always be executed.
    foo(x);
Try this instead:
```ignore
struct Irrefutable(i32);
let irr = Irrefutable(0);
let Irrefutable(x) = irr;
foo(x);
E0165
A while-let pattern attempts to match the pattern, and enters the body if the
match was successful. If the match is irrefutable (when it cannot fail to
match), use a regular `let`-binding inside a `loop` instead. For instance:
```compile_fail
struct Irrefutable(i32);
let irr = Irrefutable(0);
// This fails to compile because the match is irrefutable.
while let Irrefutable(x) = irr {
    // ...
Try this instead:
```no_run
struct Irrefutable(i32);
let irr = Irrefutable(0);
loop {
    let Irrefutable(x) = irr;
    // ...
E0170
Enum variants are qualified by default. For example, given this type:
enum Method {
    GET,
    POST,
You would match it using:
enum Method {
    GET,
    POST,
let m = Method::GET;
match m {
    Method::GET => {},
    Method::POST => {},
If you don't qualify the names, the code will bind new variables named "GET" and
"POST" instead. This behavior is likely not what you want, so `rustc` warns when
that happens.
Qualified names are good practice, and most code works well with them. But if
you prefer them unqualified, you can import the variants into scope:
```ignore
use Method::*;
enum Method { GET, POST }
If you want others to be able to import variants from your module directly, use
`pub use`:
```ignore
pub use Method::*;
enum Method { GET, POST }
E0297
Patterns used to bind names must be irrefutable. That is, they must guarantee
that a name will be extracted in all cases. Instead of pattern matching the
loop variable, consider using a `match` or `if let` inside the loop body. For
instance:
```compile_fail
let xs : Vec<Option<i32>> = vec!(Some(1), None);
// This fails because `None` is not covered.
for Some(x) in xs {
    // ...
Match inside the loop instead:
let xs : Vec<Option<i32>> = vec!(Some(1), None);
for item in xs {
    match item {
        Some(x) => {},
        None => {},
    }
Or use `if let`:
let xs : Vec<Option<i32>> = vec!(Some(1), None);
for item in xs {
    if let Some(x) = item {
        // ...
    }
E0301
Mutable borrows are not allowed in pattern guards, because matching cannot have
side effects. Side effects could alter the matched object or the environment
on which the match depends in such a way, that the match would not be
exhaustive. For instance, the following would not match any arm if mutable
borrows were allowed:
```compile_fail
match Some(()) {
    None => { },
    option if option.take().is_none() => {
        /* impossible, option is `Some` */
    },
    Some(_) => { } // When the previous match failed, the option became `None`.
E0302
Assignments are not allowed in pattern guards, because matching cannot have
side effects. Side effects could alter the matched object or the environment
on which the match depends in such a way, that the match would not be
exhaustive. For instance, the following would not match any arm if assignments
were allowed:
```compile_fail
match Some(()) {
    None => { },
    option if { option = None; false } { },
    Some(_) => { } // When the previous match failed, the option became `None`.
E0303
In certain cases it is possible for sub-bindings to violate memory safety.
Updates to the borrow checker in a future version of Rust may remove this
restriction, but for now patterns must be rewritten without sub-bindings.
```ignore
// Before.
match Some("hi".to_string()) {
    ref op_string_ref @ Some(s) => {},
    None => {},
// After.
match Some("hi".to_string()) {
    Some(ref s) => {
        let op_string_ref = &Some(s);
        // ...
    },
    None => {},
The `op_string_ref` binding has type `&Option<&String>` in both cases.
See also https://github.com/rust-lang/rust/issues/14587
E0306
In an array literal `[x; N]`, `N` is the number of elements in the array. This
must be an unsigned integer. Erroneous code example:
```compile_fail
let x = [0i32; true]; // error: expected positive integer for repeat count,
                      //        found boolean
Working example:
let x = [0i32; 2];
E0307
The length of an array is part of its type. For this reason, this length must
be a compile-time constant. Erroneous code example:
```compile_fail
    let len = 10;
    let x = [0i32; len]; // error: expected constant integer for repeat count,
                         //        found variable
Working example:
let x = [0i32; 10];
configurationrecursion limitcrate injectionplugin loading
plugin registration
__diagnostic_used
__register_diagnostic
__build_diagnostic_array
expansion
maybe building test harness
checking for inline asm in case the target doesn't support it
complete gated feature checkingcollecting defs
external crate/lib resolution
early lint checksAST validationname resolution
lowering ast -> hirindexing hir
attribute checking
language item collection
lifetime resolution
looking for entry point
looking for plugin registrar
region resolutionloop checking
static item recursion checkingload_dep_graphconst checkingprivacy checkingstability index
intrinsic checkingeffect checkingmatch checking
liveness checkingrvalue checkingMIR dumpMIR passes
rustc_mir::transform::dump_mir::DumpMir:initial
rustc_mir::transform::qualify_consts::QualifyAndPromoteConstantsrustc_mir::transform::type_check::TypeckMirqualify-constsborrow checking
reachability checkingdeath checking
stability checking
unused lib feature checkinglint checking
rustc_driver::driverPre-trans
Post-trans
<anon>parsingCratemoduleModinnerlohiitemsItemidentattrsnodeid_field0styleOuterInnervalueWordListNameValueStrCookedRawByteStrByteCharIntSignedIsI8I16I32I64UnsignedUsU8U16U32U64UnsuffixedFloatF32F64FloatUnsuffixedBoolspanis_sugared_docExternCrateUseViewPathSimplePathglobalsegmentsidentifierparametersAngleBracketedlifetimesLifetimetypesTyVecFixedLengthVecExprBoxInPlaceCallMethodCallTupBinaryAddSubMulDivRemAndOrBitXorBitAndBitOrShlShrEqLtLeNeGeGtUnaryDerefNotNegLitCastTypeIfBlockstmtsLocalpatWildIdentByRefMutableImmutableByValueStructis_shorthandTupleStructtypositionTupleRefRangeMacpathttsTokenEqEqAndAndOrOrTildeBinOpPlusMinusStarSlashPercentCaretBinOpEqAtDotDotDotDotDotDotCommaSemiColonModSepRArrowLArrowFatArrowPoundDollarQuestionOpenDelimParenBracketBraceCloseDelimLiteralIntegerStr_StrRawByteStrRawUnderscoreInterpolatedNtItemNtBlockNtStmtNtPatNtExprNtTyNtIdentNtMetaNtPathNtTTNtArmpatsguardbodyNtImplItemvisPublicRestrictedInheriteddefaultnessDefaultFinalConstMethodunsafetyUnsafeNormalconstnessNotConstabiCdeclStdcallFastcallVectorcallAapcsWin64RustSystemRustIntrinsicRustCall
PlatformIntrinsicdeclinputsoutputNonevariadicgenericslifetimeboundsty_params
TraitTyParamBoundPolyTraitRefbound_lifetimestrait_refref_idMaybeRegionTyParamBoundwhere_clausepredicatesBoundPredicatebounded_tyRegionPredicateEqPredicateMacroNtTraitItemNtGenericsNtWhereClauseNtArgDocCommentMatchNtSubstNtSpecialVarNtCrateMacroVarWhitespaceCommentShebangEofDelimiteddelimopen_spanclose_spanSequenceseparatoropZeroOrMoreOneOrMorenum_capturesinitSemicolonBracesNoBracesrules
CompilerGeneratedUserProvidedIfLetWhileWhileLetForLoopLoopMatchClosureValueAssignAssignOpFieldTupFieldIndexHalfOpenClosedAddrOfBreakRetInlineAsmasmasm_str_styleoutputsconstraintexpris_rwis_indirectclobbersvolatilealignstackdialectAttIntelexpn_idRepeatTryPtrmutblRptrBareFnObjectSumTypeofInferImplicitSelfbindingsParenthesizedViewPathGlobViewPathListStaticFnForeignModEnumvariantsdataUnitdisr_exprTraitDefaultImplImplPositiveNegativeconfigexported_macrosimported_fromexportuse_locally
allow_internal_unstable
Lines of code:             
Pre-expansion node count:  
Post-expansion node count: 
assigning node ids
fold_mac disabled by default
a crate cannot expand to more than one item
fold converted a module to not a module
assertion failed: `(left == right)` (left: ``, right: ``)
src/librustc_driver/driver.rs
resolving dependency formats
Prepare MIR codegen passes
rustc_mir::transform::no_landing_pads::NoLandingPadsno-landing-pads
rustc_mir::transform::erase_regions::EraseRegions
rustc_mir::transform::add_call_guards::AddCallGuards
rustc_borrowck::ElaborateDropselaborate-dropsPreTranstranslationassert dep graphserialize dep graph
assertion failed: new_size <= min_cap
assertion failed: self.table.size() <= new_capacity
assertion failed: new_capacity.is_power_of_two() || new_capacity == 0
Internal HashMap error: Out of space.LLVM passeslinking\ : :
error writing dependencies to ``: crate_typerlibdylibcdyliblibstaticlibbin
invalid `crate_type` value
`crate_type` requires a value
for example: `#![crate_type="lib"]`
dropping unsupported crate type `` for target `
ignoring specified output filename because multiple outputs were requested
ignoring --out-dir flag due to -o flag.PpmNormalPpmEveryBodyLoopsPpmExpandedPpmIdentified
PpmExpandedIdentified
PpmExpandedHygienePpmTypedUnlabelledEdgesPpmSourcePpmHirPpmFlowGraphPpmMirPpmMirCFGinvalid statesrc/librustc_driver/pretty.rsSomeidentifiedeverybody_loopsexpanded
expanded,identifiedexpanded,hygienehirhir,identifiedhir,typedmirmir-cfgflowgraphflowgraph,unlabelled
argument to `unpretty` must be one of `normal`, `expanded`, `flowgraph[,unlabelled]=<nodeid>`, `identified`, `expanded,identified`, `everybody_loops`, `hir`, `hir,identified`, `hir,typed`, or `mir`; got 
argument to `pretty` must be one of `normal`, `expanded`, `identified`, or `expanded,identified`; got ()block pat #asItemViaNodeItemViaPath::
does not resolve uniquely
does not resolve to any item
assertion failed: seen == 1
 needs NodeId (int) or unique path suffix (b::c::d); got , which 
expected fold to produce exactly one item
expected fold to produce exactly one statementnode_
graphviz::render failed: 
print-print failed to open  due to 
Should use call_with_pp_support_hir
stream did not contain valid UTF-8
failed to fill whole buffer
Should use call_with_pp_support
--unpretty missing HIR map
--unpretty missing node paths--unpretty
bgcolor="gray" align="center"
index out of bounds: the len is {} but the index is {}
`pretty flowgraph=..` needs NodeId (int) or unique path suffix (b::c::d)[label=]; -> 
--pretty flowgraph with -Z flowgraph-print annotations requires fn-like node id.no MIR map entry for node 
--pretty flowgraph couldn't find id: 
--pretty=flowgraph needs block, fn, or method; got armx86x86_64neon
vfp2
vfp3
vfp4
avx2
sse2
sse3
sse4.1
sse4.2
ssse3
src/librustc_driver/target_features.rs
;*3$"
zPLR
rust
fwfw
3>"-6-6
Gj\J|tdTddw{T\LDJdj\
"R{FF
(8/3'7%5#-8%
GpN^
>=bx
>:bPzNN^Z
 {\|
iOPh
++9/;#r
!b,%
->]fz
2sS>D
+3+'7
"Lv"
RC.9qCwl
j[2a
S:!pR
:Dq?
5V"xj,TJvzJF
egge
Igzb
>%vh
Wr97={
-]TjJ
5+v,
dr=i
/szfn
GqCww
dVF_
;M)YJn
HnvzfNzw
g3Ox
A()c
2	'1Q
]%84
bpxD
V.6,
NHKJ
9*X$i
2>^>2
<^M.W
`-W@
T0vj
_iQ6
.iR%:
}bB+
JBkuz
jUBM
uH<d
st=?@
Frp5
|tXTTx
%MJ7
C	)[
{G-RG
SGkS
Y7a+
4>;l
jehn
]RdhT]R
Kw*o
4L m
S7Z$
LB#b
alx-
kyvi
%	%a
i&-Cj
U+W9
=lv@
#B*4
_10	
fhM_
-}H-R
[hx\
7~%.2"R.
VpB@M
kAMI
OC]>q
%UoY
Q5bC
FFu|
FV(e-
^71,
J=bcH
scR	
<~biH
k[M$
5#a)
+{$5
 	.#
H+'x
1\W=Z
R~k%
~<7d
8ozB
2|<6
qdra5
S22>J
y9i=
NK,}
e24bpzfFzfZ'?
(d~M$
{+ o!Aj
@rDr
%7;%
wxAO
N-)+
d/)E
EmfQ';
=*1:
x"F;
]JK<
aD9@
59|O
8!lMu+
@4|,H
F)20j
6#Q0ZD!O
~%B3
|qw.4b
SSS9
>l27xz
*\&W 
#>y4w
Yu>g
?8mX
('ev
/3xT
bTB|
idb\TL
;i|L
#J61*
F|*+f
Om_}j
vF|"
3!4&!
joU+(
Ne_;
DeE_
L1OK
WDED
-)/G
Ir0X(+
*$Qt	
Rp|b
4<6 /#
36Q0G
P2X2
<k<z
66:6J
j\\L
@l3'
YT<c
F.5R
,yR?v
)b#\
+.EZ!
9KST
g<FC
P{`5
vj!A}
f~:M
nRC6 T
20][
	hx^
PZJ6
8ECQ
\_\h
h"rD
Ty~(4
~@w4j
=+_]
vxD?
c	DX
5TGL(
R0OK:
xRer
D-QOM9
_>4nxh4
KK1!Qi
!h0T
1.V1
rsmR
vBp$
ROoC&o
FV>6~M
+0_"'
J/Ad
,n Q%J
su D
#>aK
!-;[
SS;d
DFG:
\a0n
_Tv!
3x0{
9xLrr
Z&TA-
dfe&
dw/$
`|e=
gVvpNV^v
.-|T	F
-ROM
88%;5
[Cgh
X!a?
!,@v^&V
)t 9
O)E)
&CEa
7!xDJ
ni2=x<
_DI}^
6@ja
&YXE#
{C$/
$o]W$
@<;@d+
=Yi:E
=/pR'f
?SSr
O.&C<
[%+c
dPGz
MXb^
(/>F
%oT~
u1jh
Q?Nwl
AJ6$bI
'K&nJ
4h2f
'3-}
f1d C
Hw1#
P ;x*Fh
f4d3
J{)R
tzL&
I~;Uz2UR
Ne3]
H=e. 
H"O	
'P),
>QZf
PjUHP*R
w]qbCu
9B{3
:.<}
_G\G
`j_}
uKz>
O 9"
BN	) "
%I9*2
_dTL
Rf>A
_dtL
bf>A
=.f<
prF=5
`Q f
	V<5_
"l+.
X]lU
JJS.J
;+	j
x]?\&
9sUz
tc?M\\v d<
UA	LP
wTeL
zi61
BlD	
Ww(@
xC`~4
tQ`t
Ws(/
;orf
6x0JMb
 }qT:x
q??&m<
9&]8&i.
K4C_
.W9{
72:6
7rd*s
09r*
%*TF
w]+.
4Qe&n
y)N^@
3Fd1hx
?.Kx
dTTT\
{37f*
OdRe"
]9pU
-N^k
NN[{
!yZ:
(WT~
X<kCcyW
6tSzef
;JTD
W]mL+U
VPrrvZ
2%;;
L)RL`x
c8"N
RTRJ
Z6}@
'$k[
(P|y
  _,<
|d1[
f!P5
K&:'
d$RV
t0?RP
DyJp
[%RQe
_R(-+
djP2
Pz@q
A	Lj
6l+8
?NF=
JF*|
5*!:
yJ$V
:PLU
+9Sn
Tr:Mg
,5j\
'n&&
U'H&A
-#~0
'hGC
Cbu|f
7qN[e
p	TY
s"en
45#^
`!GQy
*[lP,
QrFzfn2
}{+1
Q%#P2h
~x$]
3s6;
	gP&
PY-@
:Pk'
V(P\|
i53?f
j7DN
FL}u3
`MYR
FAU]V
y9|F
^:P^E
@y+DZ
@IU@
H$^PA
2t\Bl
;{u;!>
!_G/
F$$D
(P\R
<p0,Z6
WB8Oh
zR"W
0?S-
2sS>LN
07G`-
h T(,
}cu7{Q1
7R^4
hT\1K}_
O^HU
>u9R
_VX6J>4
AdbLd
bFVR}
$?V$
,}5F
b,ei
caD5S/
%%iN
a1X%
1@/p
$k81
vg6Q1L
=^bp
2_,@!_
_=E^?
>/)L
	/rlc
G&T(
z2OK
DEi>
@	q5
!-;[
&IM5
YJ)=
^:[^9
h5Fd1`DW
 ]?9w
")5bV,_
V%{r
eZvb0
)&%#
OvVw
1Hc8
*<OCL
?NH+OJ
=	sz
^9-];
B4sv
q^:r^bO
6,~)
g1s.
ged@
g,8w
Y;i%3Z
XI1X
j(A/Q
N?q;03
TQq4gq
|vM:tC
*DEg
;zh:
"/A1$
88+Y
utW?
gs}Eq
uGZ\
ns]	
_<sG
LS1m
]i;$`
=W_a
 7v[
vx {By
C(jr
gj;6
g|A	)m
b`^i
=?GP
sv#X
vS(],
ZdSkC
.OOV
BM)P
K9y}X/
YOz$M{
Uk)6>
<8@#
E}mV
XbOaj
KvZ=&[M&a
ACZf_Z}}S
x9?=
T*x&
aPq~
_fOa;T
P	}N
.+sa
WH@5
r ;.
>;^_
<@>`e.XO
SSrhN
B!v_
6L^0
uHR7
5=JO
8pn1g
py%F
/?]wN
l%|d
-#eqs
%unJ6
6QUX6J^FO
(gf%
vOAY
~1Z^5Z+G
3f]7
=N^N
^fN.
=[I|NM
#d8$
<a(68P
o$zY
]:wy
NOfV
s*Fd
IZqq
WE|i';3%#
09P+
$yU s
]R`#?
Xia+
z@2{
>Hsz
Y3"f
]=U^;U+7
;U.DRE
;hY`G*
axx0/
b x&c
0K~8KfOa
LrKZ
1kgW
|=K>;[
u)Jg
^M(J{
1riJ
\8_fO
[(O_(
$3L>
g0u4}
.<<7
;B	i
Qi"s
6+p 1
V|TL?
(|a]
*L!K
BxWvYZ
L;/Q
1	Qv
7!uyN%
7_E%$
F@|f&>
eDbLT1
l|)3
})sRbI
8"5^f
c,:C
D#sA
"4&&
LmC<
O1HaH
0A54H1
\Fm9eibu
YsY6AL f
T*Q+"uZQ
\Y7C%
e(_e
H7***
 Q6`f
TIE0Rl
$hk A
kG!V
Q:ex:?Wt
4w)r
N8nS"
Iv,a
UU'^S
=NTtB
Om7?
N!<^	#
i'#m
NRCE_B`
g	[^X0m[
t	g+a
Pyc@
28wmw
CN&Ngu
o[rCF
X-^F
 1C_
qDb/m>
X>^$
;*g\
hGBcTI
p)hwmA
	DF'
Jx[[	o
QB-dtdq
yF-Q
8M+\
M}.={t
d(12
"E%D+
Y%XD
;|\t
FN8j
pC;D
xbb"
|cR/
	e,N(
d;=N
UKXr@
jHW2>ON
-}%[
v	/q
>x?4
KnN:
~hcI
k~`F
_"UTn
mH@e
l?/S
3J/v
9g%5
x$W[
zG]Z
%'U8??
	p=?
dA@vi
q4F1
y^cf
pQ_-
+/eia
_bz{
$G9#
'9oo
x:kQt
]*`y
]T5o
s {||
b1PK
ZTd$?#
OAm|D
h	ri
k)gs-
Apy:S
~B}u
qPE;
7X,anz
%IE0
j6?U
sN&gL
_UWO
wp}]
?S&r
H	H;%
, 2y
|bZ`
KYQ1/u
FKQW
e1o"
&*09)T
zfKt]
6~ij
U_O5
.Y~P
1Wd=
rvv0
Z*H+-3
6}3_
%9qV
%Y|[W
w-:S
tpQ=
W]}ya
09{6
&W8Dv{>
ZRmdY
lya	U
9%a8
2MmbIw
&^aAGl
C$t)
F%%yM
t>mk>
,(pBt
-'Dw
<!k~K
x_Ze
H}.u
(K+,K+
,)id
9pw8
\R/;
eXRO
"=Q-
-o*oZV	
^T(Q/*(
#%PJO
hc6O73
@\h]
Yv:}
_E1=
?Y/*2
.*jW
M,BQ
X'm^S
|`q)
KIM/
sB``	>S.
j#N"
T#)z[
:ERK)q
rcHE
Jhd 
8no=cHOn
n=N%
SxJh
Q;}Mh
v{J_
G!,}
!]"y\u
;VnGc
4Vn_
'jOc
ceLk
6 `P
91h0
w)QE
= ^Fx
H:Qw
DCm%
-fNwC
))=p
EJrRbZ
wzbj
sdnO
=P\M
mp2	
I@@udI
r.s-
J%^AJ
q3|6
*.~=
3L/p1
+FsM
X%-%
tM9dja
j,Zw
Y#M_r
j,Vw-
+c+\Y
rj7,(
PQ[z
9C_(
;gh-E
:g(>E
=06z
|HsI
1MW$
\F"-
\A@$
3WPy(
,>a@
V[6"
hJPuG
 b_i
CwM/
$lP[>
A`E{
tAyA`RG
ivy!
c|mr
zz{_
<qv@
Bm\7
y7Tn
o_e0
wJw>
m%Q#p
\l'z
pT9/
X	q)
<{]!$T]
8VMHty/
H/~Y
Ph3!
gK'q
sFo>Gp
	C>0g
0M{@
UH%^r
HS]_
HhRzX
m)ED
<$k=
Lb&7
_sv7
W[7(
gO3Q
} R$
~A%,
{|#lD
{5DnII
g|p~
 <0f
,	nT
H	^we
_[mA.
-k}[
Q9N;+
sM]p
ATAs
v72>
|bKRM
0#HS
E"nK
(VZl
OP7H
1S~W
	 d	E0
t5,lX
,Q=e
lh@]C
<h;Vt
z,_?
%U_9
.BEi
~n")
 DsK<
TSPN5
9n4>>
1V$Z
"'Vts
D~p"
%WP<
vq<o+be
D>U|
$t!-:$
Z4csFz
AaQ<	
W:.X
 ,)#
#rg 
"bNj
d[rn
BYVj
&ged
xQLFS
VX$e
,+*x
JJ	}
Ql=B
.[mF
_,+k
rbFj
1l.]
i-[,
VZXq
KG"R
^yjP
@:Yk)
;=Kg
kE]jFg
l.0Kz
xAI1
<Sg?
z>`=J
4(`bH
 D)C`
w#? @
$w]~
14N)Q
c9Pj
B	a>
	d"p;E
v,,/
"*WB
eqc*
3X]W\
?H3{/_"P
0a@j
5LXI
3	SL
iJ04
2%t&{
8`YMZc
\#C-
7~-n
8HX!
f{23
Y5|:h
i%K9
8\RJJ
\/lA4
,8-9)U>
UkiW
Ysp(*
:~E@c`zC
+afRc
:>S`
{Pw5
1%ge
yvCC
aQQes
V^.$
f>M@
]B)JB
f~r3J
v	!$
PB76
hy^n
2JS2z
UAB[
BH(	
YB#w
PEXH(
"8lT
4Fa!4
2f7w
0Yu(
},@Z
.c%(
)x=0
x4fs
b95X@
:BB5
vjR@
wG,W
AOVLW
+Y C
DpDha
sVvF0=
B{Lw
Q>Y@
>a3<
Cd?a
MgJL
"TFMm
Y.z=Tn
_K|xW|
Lbw`
mfAi
a~MC~R
*/OlV
+WNx
>$)H^
hMEZ
)H0v]
T~u*
r:[a
QVBeC
0sAE#m
E!~|
zb&?)
)qkHp
y|,~4s
_mDL)P
1z?HBo
h.^/
;F['n
eX"h
2`$n
s|>?=
[l%ZPh
Sv* 
kwGW
aYW[
W[&4
"~RHai
{'zg
U1eWB&
	*Om
2|Ma
nB@H
3124l
>}AN
I,Jj
5p;F
j**NB
bp#}P
q5?)~
}5?(0
g@,n
X+nW
BpS!
Y{ Y
7:\o
 )ct
xGgC
~7IK
@^#@
z~}=
vK&a
qz[ E
X'H#
/_jQ
fxNl1
,$|,
B]H o,
\.`	
M&Oi
QqPp
)0z'
/k~	
	"oRX&
#ws}
F/ghk
zB"T
}\?	.	
\>@@7
///%1&
] %]
K3}t
1zjA
!04^
&d\>
]^"o<
O 8h
$n	p
%|m<
U1_\"
H@`2~8^?
&o	<
'^;&n	
yyHx
#s[@L
L^!&
*2Z+
'CXJ
WbfD7}
 5)%
S6RC<
s ,1
YdEDy_
?h}T
mlIJ
X%1?
`b M
:fe 
R> )
=29B=
{yFe@T\k"%
H:Fy
)mt_
15q)wI2
Dj`+
-co`
]J5P
a5gP
qx>8
G{cc
2MJO
Milu;
/M{D
!,1>U
u,*Q
B``!
B40+D
b=U-
Iw6x
1SE>
*eid3
Qhu"-
6q6?
C!0PRM
HY|k
.)6V
/*	-
	D)>x
BYSR
+8Kf
ImGZ4_
;;L$w
hTi"U
bdwB
Mx?:
a'v_B
	.$-
"lPq
P[c1
Q^&#
Av#m
?Q/f
(3 zG
?d0@u
DDj	
%[+)
: L5W
L72Z
Jrrj
kzZj
Rds@j.
E6=\fV
w/6J
w=5^
1u-V9u-
jd=L
mMi0
Iw8F%
DnSz
fzM)
:)}T
,)}D(
B3SI3
gWx_
0J][
DnSz
Chf:i
XqJKM
DmSv
!'eG
$g->
??K-N
M$IbW
A=m[i
2[T:
0W{J
3mhY
#.2>l0
GqyQ
9SS2
eiLL
85+]
qjbrc
DYP1
BU'O
\IJ^n
S(-sL
FIZF
<C[h
d]jGS
3MU&
ef49
C*0NED
]jDQ
Y3:Pk
mmQ%
h3BMG
hsTS
VvCjU
jIbm
!,xs
gt6W~g
PMH'
x2^.<
awLc
1%7C
L9RY]
(?}\
Trmi
M4{m
P'M.-
wi!i
U^WVy
GhMG
t~i.
OshZ
6bzL^v
~^^N
=C#L
%Vfn
e4]Q
e^Ae6
FuptB
=XOL
TfC:
PHQC
MhP?7
= @Z
h1_+
a6w1_
	qB-A
BNO`
V'moG
Nph4n
av~)_
9=TX
6x9?!@U
2~r9
 7]1]
wp:F
j@lh
+a0m
4OY<
>[L+i-
.R!0
%Uk$
2-"A
XEcb?b
s5p}
K3+5
Oa1CQ:
'hR 
lA)Fw-@N
OX9U
[_AJ0
6![}
6lUq
< hR 
]C@R
),j0
r>!Z
x^3w
(,:,
^[fP
`A^5)
ArA$
;ihV
waejFe
;4qh{
^%%%d
awYnq
,EO)
u{4y
}SVysb
q]VPH(
nQNA
	0TJ0
oC`Su
3G|b
*v{S
>z10
{	]_V
D4y0
^ut\
ORqW
LrzF
HX(cr
JkJ+
mBvAQn
aQv-2
hM$qa
]%jZ
@qu`
}]em"
Qki|
:Pt4I
KMNv
(|]'
9B?t
V-7$h
( /:
t];z
1O7-9
R%%)-#
E24WtQR
.1'J
80i|rb2@
>vpb
E$0s+
I"C 
	}V^
o+C ?
'zh2
RNcg
edI+k
fwBtp
X7~As
& Pb
9mqw
`O*90
E9UR
2pw8
 aI?
f&N[
0Kcl
FI0P
.x{JQJc
f*8a
]IId
\Z&*
:Lf{CW
/Gwb
mPX`I0
"V6E
t	vKO
eWBH
G=a,
Y](E
rC.Z
d4'	
Py7~
m!Cc<
/dxm
pSo'
f&2A
D~H&
'O_5
d&_Y
%Yjx
8[".Pm
Z;[qthql3
c=*A
C{E[
($Jror
yiyz
fHQ~
HaN1
Ljn$*?Y
c$)?YI
C3Cqi
5-37
C n#
qYkA*;x
Pk-(N`
 J	$
63sB
Wdj;
Q}TN
o@aEiY
Iue1
	,&v
)+qw6
{,pn
wqYMu)
yc!k
>|sYa
\hT7yb
yVV\:
U@1i
C+"t
fUj7
FB23%
6@:zie
vy3%o/R
E2>Q
mt46(
Z?su
Cc//
_qIaIE
flhr
ufzp
{\rDC
Zv^v
x=/^
'-	3y
\Yi&
/XMD
hg4L
@b#U
ScBk
M,hM
6G`,-"
 cE<K
U).'
/XT /
In4>
?jHS	
<$i5
 dfedf_
mE2Mm
4mI2
3C96
.N@W
0<NX
OkTh
%332
vyGXz?
#~L&
1m`^0
ym""
/Ax0
7%yb)
xLbL
>N9B
R\3UyL
prka
K tk	
$IpD
Z f9gQn
6rvk
/;pl
#'='+0
,Q{{
lmFx
m$7R
;lDw
MT\8
"DN*
zqyR
,	$/
"Hp@	
m-~%
CmaT~
Yrlu
-Nit
]hk\
xhJD
OMJDC
	Y<l
os@,
zz) 
 Ar.
{/{q
*qid%
J_p\
cF54
D]EL
:$cm
#erOBX`
X,nN]
Uo|i
3J,t
S6AlQR
yeUyR
C}P'y
e~vH
8\v[S
)?J1>
Dq*<?
]D$}
T~JW8
Er|mu
ti6oZ
 ,0>!
mdOH
/AX`
IU/~
Z?By
'1;|O
6on	}\J
XX^^TVQPV
*YYAqy
u?_F
Kj;Hj
skx.
]@ag
IG<g
y4Q<
CFu>
"b+5
oK2m
:(Vl7
,s\2
wcEyf
<Nv;
X2)P
QP1tU
"z9b#
&Mha5_T
3PCS
Y|/<b
3",&
i4mEf
D~YV
|x(p
nGY[
|tIQQ
1++3[
+1OY9
Heq]
HKgt
}|i=`
/,+/*
fHIa
%/'l
UH@L
3N0V
`e?=
d^),
&C9b
\gaf
!qye
M	0m
Vpkh!
WRZV
Oh&^;
q4nLB
!k ~
pZe#
(O*L
o*O*
N?/e
"]O7x
Ig}S
g}3@\7
Col1|
,'K7v
4xlM
gXK>J
_B-9
]Hmy
|Si\
/B*c
'C&'A
E}6.
C;_1.
I|~C}FF
CQBn
Q2|W5
?/L7
#|@1d
5FCF
6okmQ
8~#W
'.l~
/U;B
uiG@
r1!,R<I)
-I?^
j7(7
u/#_
aF5@a
Y+HST
qGmB@
64*R
0um[
{>t[
"%W'
EJa$
5TR$D\
*rPS
TmTA\z<
Q7V<Rq}YQIa9
]i{ 
u{!a
xq8_
E@j1|
||!.
pZ3v
!sxz
9<>O
1V"^
/,/*
?"je
G5`N
cX{hl
M["5
{%=h7
==5mf{~
lI{}.
-n/Z
fmR{
n?!S
ocjp
]}FF
vidw
xjT<e
|"tL
*?/o
S[fL
[QEu
Si?jS
_Fi?
Jf%N
3u/I
>\{=
P=I=D"
x5KX
:qUpV
Iy%e
L<3:2o
B>#H>
wRge
(>OS
5/`_
K,#?7
3e:`
?b:;
0&999
f:@"
5yg`8
U;R7
tWh{7(_'!
0kbC
X},6
jM=B
sI}b
TeP*
uHB53
.L<o
Ba!Q
?kl8wW
YzrS
Bf(PW-l
Jd$R
P6-[
EEiah;
c{9^h
/tQr
'='/w`I
w#3_
H*)}8
+AFz
@5`r
l/-s,
jX\!/
dQY*
vnF^
2{P)t
86W\
zq.N
"8Cw
`a@*05+
O"k?
q2Hz
@"(`^
4|Bj
*A)V
?Fk^
;HvVz
uBAq
3"L$
fdryz
giqI
CLsCz
:BSl
{5/;1
,&i=
.jF=
giOFsg-
5sI32
$:hw*&
Q%^%
dAG 
-*%uP
o)u03b
2|Bx
^59q.%
\t6b5`
#"<4
Es9bz
xDg$p
:KF3!
|WuY
Z:{=
Uy.0
\W2[x2]/!
gUj7
n2p;
MG1:
DN1X
Iw/t
{,M6
l4V"
,5>\J
2@/,5
/+z<$k
dN]c
boPqn
klm=
VRc/
K*#+
_K2y\2
u{KN
V@|~
<z_qQI
t,DKGw
O6K3
+d`U
hY(o`
(4J[b
'O;3
	=FQ
\*s-#
05mC
PaYqaIE91
d@yQ
Yy9V
f#!Y
|}y~
nAt}H
K6Y}N
a[AV[@V
	`+h
^W*^
z2fTC
z6p.@
?#V.
/I!}
}\A)	Yo
yX*n
m#E&
81n/
":BTw
Lpo@WJe:
uQ}x(
zri,
!;#k
ZqsE
gjKgt
12skB`
@~"v
fJ.D
&Uu)+
P/{[F
1jY\
*F#|
OM3n-
/#:j
V';TyG
k/!Z
r_uI
{!+ay
V'0L
)9Pa&
,N%f
>v8!
7?Gc8
Q=T=
ty!	U
%MaT
WT^^x_
/cI'
awi	
%8 Y
 iDA
}i4s
r/Y+V
bmmQ
1#7#
\+5S
RFfV
"rr?
g$/3+
4@bc
7pW6\
*Cof
l1&iz
dDMu
{O]T
YZVV
+;Ae6
QeZO
YYcj
=5m=f
1_G(
<7vj
o.^:
n'/{
%s{W
wQEaq_
I}JR
IBsvRq
<Vwn
QaIa
}<|:8
hsDgzB;
g{%>
]cYk&v
[ ,bGP
~9k}e
 n#n)Pc]
`*Mw
k(sm]*_[U
 ,jO*
bvE9g
c,ZgP
F]*(
wRy|
y.J=O)uQ
s/.#
[^zV
Hy.PU
;uF8n@
_dbwAX`
rHG2QL
C1	H
n}ovg
TO{,L
*%5S
13]LTE*T5
}T)_
X3_C
 b	J
1c]"`
zY)8
:`r]:
X,Ne
/Te\
n6C4
~=O#7#=7Pe3
<W}F.
,j!3]4
4lq`
fk1ek
K}Zd
~2u,
 vNfC
Bc7j
HAop
Z']&
xiq=
L}kH
)n51
H9	W
(]lC
eb/N
5F;&
k!hd
%TkB
i{|)y
fhKD
j m#
??SW
;41	
D{yi
OQ0R
J?J$
2DiQ
|o<*i
Z+8	[
]W8b*
j5Lg=
XFF~
|5[f
0FMU
3sb?
q_QEAy
:NH>|
<:g;
>tN>3
QV[@
aFV]
#xd(
BG~K
x{ni
<jD<j
 (N>
h/+x
C~zm
'i@'
[7QG
>VC"0V[
K`@$
BVK_
Lot!
g(Pw
^K}iK_
./=?
A@Spux
,zW!I.
ZoFxy
g[s~
7n6wo
%b9t
I;8`D
6a+.
k:V:
rL]?T
[>Vv
A`xq%
~kuQ
9g'n
9!hkZ
4\ws
=_Be1f
?k.'B
_r$a
{AI&
fMSI6
7n1_
jK`_
x35O
[@cN|
,37+
xCHi
AI&:
YsK@
 -w/
zix^
0LFxB
TT>v
\V.B{
Z#/s`
#mZe".
"7';
>\TV
`sUh
4?+?
.?#?
<]//
8ZjJ'R
1>@}
d46_b
a 3Q
+>q4_
fT{%
$<^:i
qq	zHo
()+*
 gHR
W>0=
!I!P
FW^>
;nR%
5bc<}
B-:1
LS,8
~s./R
O8%/[
LODV
oe^Q
$#-I
;LU5
V}iG_
KJAM#
WiK:
?6'}
3,Mz
B(Bz
+*(>!
fQ^q
iXT`7
q:X:
t6\c
2\/Q
\Z)ka
O	30
hPQ:
h>y2(]
ZH3O
<x}t
L9(rF^^z
GJF^_T
S'tqo
8`[)
3[O0
a`i!j 2
ezL}
WLBx
ew'(
<+1|
)[<2
zw1|
g%#@I
t|n	
!T8P
=zD<c
"ZE4h
3'7"=
"rzF
ieDDv
<f"&
oF.f
wf~F
wfvF3
b7ZG)
tLM{
W(bGE
?'k,
{NAv
VcpM!
Jo~lGO
_iWU^n
gqbd
necp_a-T6[
rmT._s.
]rr\
0ohZ
x^ST
Ii$R
2`3?
$g(~
FYUM!T
 \/	
ouS0jPv
Qk\mh7
q2q'H
XZ{Q
_\''&
FjC`
`N5k
jdi5
6mhT
#9:*
FalaW
6_LLl
|_.Aco
ph, 
`&%J
e`*aRX
|\ba
uWcaF
0@WQ
`B!ks.uT
'|XX
0Lgs
u,TL
[A^Q
-}Q&sQF
UXsVa
7i}r
-H=8%H
@c$$:
dpSA?rAJ
3R\K
_!^C
{n&Ke
W+ =
#[X)Q
->ma
#3wG
fE	9
37#cm
0/za
U9&fV
=1{c 
/1b;
~+fT
{^~Nn
V,~1
8A?rA
a,>F
]T`{
-G@(
H8,iT
$`lR
lvx%n
K~3Y
-|Pt-
irt/
s>x+y|
V#Ev~nN
m)\g
oLRW
u`p+
@?P<
i~jh
CBsX
A$TM
uS](
61q-c
C`_[
<$LiCCwB
5nne2_
Vt~d
L?1a
bj>2
(vUS
l}_eE}
Z9cS+gt
?C=R0am
#Tc(@9
e$}!-
4oCs
U,FsB
Rde?-
AT6ua
e|\R
D%&V
V|mS
Ta#i
vPdC
G&%X{dd
{d#?=
YzdS?
wj#Y
ia&.:
XI;VY`+
|LwN
'8'^
/^K{
hf	s(
0Wd/
!aPt|W
Nt`!
aB	k
ced^
!_?B
 wKh
\%rb<
CJtF$
#)f0
JtXd
%z8*
f4PV
\[T?_
?F(TPyY(
:ZU@
D0z?
>JHt.
>,[\
D} }u
~G]!
\tsU
"%AA
5QvH
~ZAA
=nyN
"VRA
@gc@
GE;R4Pv
c9xx
yETtI
SJt4
Zy^P
TVy*
!*:H
DGq N
`6>g
f<aPW}
ybkx_
Lv,^-w
9@X0
P%9o
gCq;E
CGKc
LsbM
i<kf
U;"5
@czS.
5SgszC
*;"5
L8w)
g?L%
S1sS
2he,@
[fK"
Z8+3l
@W@E
xx*$
[}Y}
d/,U
Zmn%
6:bb
z`C 
iH,D
eVsw
[S{ 
ayeM
Hw-|(
!ZAvA^F
w;/'
sI98L
3uz!
Ph&L
>EEpI5
W,7;z
^?Becr\cd
?E>R
S+]t
(iX(`
ez+,!*
[+,SWXo[
\/0W
/zQ^$
('6/
&%L*a
|rL's>
qFw2
NAbb
&XM)
 ^'k
R@#X
~I,R
GIu8
igg8
-Fo#
8_v2
@K'F
ngq~
yo0J c
bf`Q
`PCb
l|H6>
Nv~f6
CJ1L
{gdO
l|\6
EN1Da
<!fg<
=C~H
d'J#6
m/=,.u
i/\r
2)P0
Lbh0
"c82
"S82
|a&L{
l|K6
0*5H
~M{a
+(#77'
PCr3ze
B'KS
ThaE
pQIJ
uE/?
B	1_$4|
F*5h
W@34
N%KP!f
uwQX
Ha5.
5M%>
c3+B
0&/'K}
x8S>
4iS|+
?}\|
U3'E%
a2gxhi]
hebL
1^[?|
z	aN
OnyR
~{rt
+O^}rW
O-}r
x]HO
#M9&
?9>8
@GMxb7:*!~P
4B>_
Nbq<
{'BS
nwS[
^FLLK
;,/$
JZ^I
&n$.
X1]46
46.e
@2+@z
:L.%R
:MLL
c>P2
5ioU
|$ibz
##b.
4'h#
,<Ec
"$TJ
",/C
/OBP
.$YD
B=tc
7znn
YX2>a
~T*.(
\9Vih
J kd
]nQe
q:[)
?#"=;
0!aP
Y,+X
AAHlrNA
wl'O
xU;q
wDz^D
>}":=
Rr:y
o'~g
!a2%h
!Y=3
vj,[
_q,s
b|oT
ZQwz
el\3
_51!
R;;V#
,~IE
	CUqH
@:45
~[ oo
yJ~1
0kjV8
aF|v!$
>-;=+#
9&_:
7N]Z!CZ
U||B	
4:F$
Oe7V
6tg%
LDA*(t
d	Rj
GY)2
@q3x
	ED/
xFn>
J,;KO
-q__
X4pr
fFa}
Z_S0[
43g^HS<
|C+5
-</_;
<}^-
qXi7
kQC+C
vE;5
%vF^T
m*Am
rD&P
7	TMH
d7XV
N/RU(t
e;x'
pZX5d>`
~u`3X3
,XfM
S!x=
xA%.
hp0X
d]6M(b
wiST
&+]g
:q+\
:1@<
c0EZ^~Nn
zezO
p	m'
=C%Y
=jAq
?sJ+
Uu#G
cQ\1~
]UX|
6%`f
],-Zw
Q81:
%@8uC
gaS/
ev<W
1,[Bg
)'+C
Rvp@
}N6%Q
{NAv
6N"`
,4ne
;7Ks
 Xh,
i4$S
B*~=
0c.48
9;ciW
m\*=g
d`@)
.D?c
>M&\
*Z_E
@8sYOD(.
3[\$
eJ$n
aZPX
7-5	
QUDb
CB|RL
^DQD
=K`;t9
`;Um
VGUpB
suEU
m#eC3
AQ]Aq
@XQh
ebKj
:3|-
i-64
TQ]q
<R&>
HML3i~
9[7}N
IYl2
8A.z
nx%0"<
7WQo[
YEqV
frl5
ZC+KkH
M{	EW"L
,z,	
QRaI
<~IM
y#B%
	F?X
zxJx
`;<2
MC!a"
jN	U
*P0]
-ZDt
}.3/C
,rD&2
$+'7
{zvD
yN6de
i"zf
M`6:
_Af.
ufV'
&7#+=3
TnNN>v
ff{5P&
,T$P
MdBH
[&''
tZz~~
j*h,
d.g8WChg
WvN^~f
ai,b@fF
$]@R
O.3.,C%
p9	%3
0pgg,Yn
rc1a
A SV
 ecpn
QdHO
bX.:
w^F~
U\YI
ex@)
Oym`
&*mk.
|	+#
qy`yC.
x{5:o
Q-&Q-Zk,Yk
Jh#X
ExAv
3^Yg
+I($`z
Ch.?^
zc?R)w
R{37
aH~(
/wGXM
qh`53
**/X
q%<.
Fc#R
o!tn
 gCpV
IHbZ
n6Fb|*
yN#A
|f~ZNv
etTT
A)DG
Ig1^
[&]G
+4@@
PcT'
3xTMv
-*cy
u?F<
*tv_Sv
U	"V&
}>&G
Ccmr
JV>)
t2#5
zA:Q
}/gzeR
4YNn
S4EU
)<~tpx7K&'
Ey7KH,
z.Oi
.N9Dy
~J{T
BX5?
Amk<e
4#=n
Ygg2
gsr@SR
*G[G#
86@W
H4A0,
m]EK*
ZIK*:
z]Y[%
h{vn
A\?|
{z.y*
Gdu:
W0EQ
|Wg_q
~VgQA
`v+a
q8LX
w|h,
eY7v,o
UH7:
Y4;R
QB)XRs
K$;'	r
(W'x
|wG}
Hc(F
Z0o2JhPst7
k(/;nY
b')\
,PiBE
2\{A
 KH.
D@Dv
TuuwU
]F%DL
&W+a
Kj%I1
'/&Na
\9:-e(c
9&qB*8
''*H
yz,'x
EO~^
rke {
0T~h
b}Z&
CxSW
FO56
~R^2
c*2Ee
wAeU
kJfy
R$YC
$#,gF|
fU2Z
3f/X
"s8;
%ihp
;i~K
3EZ&
jbnv2
P`+<
?B$JA
IYNe
I%6&
q13*
93=)
)QODsak
YYQ2
eBQ}
0<;M 
?gPZy
S>yHf
?)j:g~
<HpM
y>@1
jxJR
vOoP6
=+p[
7~&x
A]Z	
FpA<
kzJx
Qwkm
zk~[u
4';}
8vG_
Pvy|uY/_
ey8_
xB_Y~
6Zb5
w< a!h%*
/~vp
8w81M1
(S| 
ejiBMG
t[FS
/Uk1
e	GJ8J
b	wHX"
S"rX
m:C[
librustc_driver-39b92f95.so.debug
.data
.rodata
.shstrtab
.dynamic
.note.rustc
.note.gnu.build-id
.gcc_except_table
.eh_frame
.gnu.hash
.fini
.gnu_debuglink
.dynsym
.gnu.version
.rela.dyn
.data.rel.ro
.gnu.version_r
.jcr
.eh_frame_hdr
.dynstr
.bss
.init
.rela.plt
.got.plt
.plt.got
.text
.fini_array
.init_array
