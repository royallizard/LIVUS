/lib64/ld-linux-x86-64.so.2
libsmi.so.2
_ITM_deregisterTMCloneTable
__gmon_start__
_Jv_RegisterClasses
_ITM_registerTMCloneTable
smiSetFlags
smiGetNextImport
smiAsprintf
smiGetRelatedNode
smiGetFirstIdentity
smiGetNodeLine
smiGetElementNode
smiGetNextClass
_init
smiGetAttributeParentClass
smiGetFirstNamedNumber
smiGetFirstUniqueAttribute
smiGetFirstMacro
smiGetAttributeParentType
smiGetNextRefinement
smiGetNodeModule
smiGetFirstEvent
smiGetFirstImport
smiGetFirstAttribute
smiGetFlags
smiGetNodeType
smiGetNextChildNode
smiGetFirstRevision
smiLoadModule
smiGetNextNamedNumber
smiGetRefinementWriteType
smiGetRefinementType
smiGetOptionNode
smiGetNextMacro
smiGetNextEvent
smiGetMaxSize
smiGetParentType
smiGetFirstType
smiGetType
smiGetFirstChildNode
smiIsClassScalar
smiExit
smiGetNextAttribute
smiGetRefinementNode
smiGetParentIdentity
smiGetFirstUniquenessElement
smiRenderValue
smiGetFirstElement
smiGetFirstRange
smiVasprintf
smiGetParentNode
smiGetFirstNode
smiGetNextOption
smiGetFirstRefinement
smiGetNode
smiGetNodeByOID
smiReadConfig
smiGetModuleIdentityNode
smiGetNextIdentity
smiRenderType
smiGetAttributeNextNamedNumber
smiGetNextType
smiGetAttributeNextRange
smiGetModule
smiGetAttributeFirstRange
smiGetParentClass
smiIsImported
smiGetNextRange
smiGetFirstOption
smiSetErrorHandler
smiGetTypeLine
smiGetNextUniqueAttribute
smiGetMinMaxRange
smiGetNextElement
smiGetFirstClass
smiGetTypeModule
smiSetErrorLevel
smiGetNextRevision
smiGetMinSize
smiInit
smiGetAttributeFirstNamedNumber
smiGetNextNode
_fini
libm.so.6
sqrtf
atan2
libc.so.6
fflush
strcpy
__printf_chk
exit
_IO_putc
fopen
strncmp
strrchr
regexec
__strdup
perror
strncpy
regfree
__stack_chk_fail
putchar
realloc
gmtime
strtol
calloc
strlen
memset
strstr
__errno_location
memcmp
__fprintf_chk
stdout
fputc
fputs
regerror
fclose
rand
__vsnprintf_chk
strtoul
malloc
strcat
strcasecmp
__ctype_b_loc
regcomp
stderr
fwrite
strchr
__vfprintf_chk
qsort
__ctype_toupper_loc
__strcpy_chk
__ctype_tolower_loc
__cxa_finalize
__sprintf_chk
access
__strcat_chk
strcmp
__libc_start_main
ferror
stpcpy
_edata
__bss_start
_end
GLIBC_2.2.5
GLIBC_2.4
GLIBC_2.3.4
GLIBC_2.3
AVAUI
ATUSH
Hc|$
D9d$
D9d$
[]A\A]A^
fffff.
fffff.
fffff.
AWAVH
AUATUSH
~x[]A\
ffff.
AWAVAUATUSH
T$ H
u Hc
[]A\A]A^A_
t$(H
T$0H
L$8L
D$@L
L$Ht7
)D$P
)L$`
)T$p
fffff.
AVAUATUSH
[]A\A]A^
AWAVI
AUATUSH
9\$(
HcD$(H
D$ H
T$,E
t	@8
9\$(H
9\$(
8[]A\A]A^A_
|$(9
|$(H
8[]A\A]A^A_
9\$(
D$(D
L$(9
AUATUS
]A\A]A^
[]A\A]A^
AVE1
x1t?
[]A\A]A^
[]A\A]A^
[]A\A]A^
\$ L
AUATA
[]A\A]
fffff.
ATUH
@v7H
[]A\1
fff.
AWAVAUATUSH
dH34%(
([]A\A]A^A_
p H9s
H9p 
AXAY
H9h u
H9h 
AWAVI
AUATI
D$h1
D$hdH3
x[]A\A]A^A_
AUATUSH
dH34%(
[]A\A]
ATUI
[]A\
fffff.
AWAVH
AUAT
L$(dH
t$PH
D$ H
D$HH
D$0H
$txL
t$81
H;D$ 
[]A\A]A^A_
L$(H
AWAVA
AUATUSH
tIE1
[]A\A]A^A_
[]A\A]A^A_
[]A\A]A^A_
[]A\A]A^A_
ffffff.
AVAUL
x9tG
[]A\A]A^
[]A\A]A^
[]A\A]A^
ffffff.
xt t
fff.
T$@H
L$HL
D$PL
L$Xt:
)D$`
)L$p
D$(1
D$(dH3
fff.
AUATA
HvEH
[]A\A]H
ffffff.
AVAUL
]A\A]A^
AVAUL
]A\A]A^
AWAVAUATUSH
p H9s
H9H 
dH34%(
([]A\A]A^A_
L9` u
L9` t
fff.
AUATH
USLc
[]A\A]
]A\A]
ffffff.
AWAVI
AUATI
[]A\A]A^A_
AVAUI
ATUH
]A\A]A^
AUATUSH
dH34%(
[]A\A]
ffff.
AWAVE1
AUATUSH
[]A\A]A^A_
AWAVI
AUATA
|$(D
tRI9
D$(H
tVE1
D$0H
D$8H
D$@H
D$HH
D$PH
D$XH
D$`H
D$hH
D$pH
D$$H
D$$E1
\$$E1
|$$E1
|$0H
\$$H
\$(L
[]A\A]A^A_
RowStatuH
D$$1
H9D$(t
\$(H
L$(H
L$(H
-MIB
-Xw%
L$(H
fff.
AWAV
AUAT
[]A\A]A^A_
[]A\A]A^A_
=un%
fffff.
]A\A]A^
[]A\A]A^
=rm%
=9T%
ATUH
D$h1
D$ H
D$(H
D$0H
D$8H
D$@H
D$hdH3
[]A\
tCE1
t-<-u
T$hdH3
p[]A\
ffffff.
ATUS
%-v%
[]A\
[]A\
[]A\
t[ATUH
[]A\
fffff.
t[ATUH
[]A\
fffff.
fff.
AWAVAUATA
[]A\A]A^A_1
fffff.
AWAVA
AUATI
[]A\A]A^A_
[]A\A]A^A_
[]A\A]A^A_
AVAUI
ATUS
[]A\A]A^H
[]A\A]A^
ffffff.
AVAUA
ATUI
5qT%
5TT%
[]A\A]A^1
AVAUI
ATUH
[]A\A]A^
AWAVAUATUSH
D$(1
=6i%
=$i%
H9h u
H;h 
5qh%
t$(dH34%(
8[]A\A]A^A_
p H9s
H9p 
=4g%
=If%
-ye%
AWAVAUATI
[]A\A]A^A_
AWAVA
AUATA
5hI%
5JI%
55I%
[]A\A]A^A_H
5zH%
ATUH
[]A\
AWAV
AUATUSH
D$X1
l$ H
D$0H
D$PH
D$8H
D$ H
5q'%
=8[%
D$ 1
5r@%
5_?%
5B>%
D$(L
D$@H
5y:%
5W:%
\$(L
5;:%
5&:%
d$(H
l$@f
T$(A
D$ H;D$0
D$XdH3
h[]A\A]A^A_
L$HH
=Y4%
AWAVAUATI
T$ t^L
L$ H
[]A\A]A^A_
D;d$
D9d$
l$(H
AWAVA
AUATI
[]A\A]A^A_
-i=%
[]A\A]A^A_
=T=%
ffff.
=9/%
[]A\
ffffff.
AUATI
[]A\A]
[]A\A]
H;+u
ffff.
ATUI
[]A\
[]A\
[]A\H
fff.
AWAVAUATUSH
D$(1
H9h u
H;h 
=SC%
5!C%
t$(dH34%(
8[]A\A]A^A_
p H9s
H9p 
=[B%
%2A%
-!A%
=Y@%
AWAVAUATI
D$`D
d$0H
L$,E
L$ L
\$ M
[]A\A]A^A_
D$$L
L$ 1
AWAVAUATA
D$ D
D$(D
D$,D
L;d$ 
=t:%
[]A\A]A^A_
=<*%
8[]A\A]A^A_
ATUS
AVAUI
ATUH
]A\A]A^H
[]A\A]A^
StjD
AWAVAUATI
L$ H
([]A\A]A^A_
L$ H
L$ H
HcD$
L$ H
E9l$
HcD$
HcD$
AUATUI
t%[H
]A\A]A^1
[]A\A]A^
AWAVA
AUATI
[]A\A]A^A_
[]A\A]A^A_
ffff.
AVAUA
ATUH
=1/%
=p.%
dH34%(
[]A\A]A^
AVAUH
ATUH
]A\A]A^
fff.
tfvL
AWAVAUATA
AXAYH
H9D$
[]A\A]A^A_
8[]A\A]A^A_
L$(H
ffff.
ATUI
ATUH
[]A\
t\ATI
[]A\
fff.
AWAVI
AUATUSH
|$ H
u)AUH
l$(H
L$ I
[]A\A]A^A_
AUATI
x9tG
[]A\A]
[]A\A]
ATUI
[]A\
[]A\
AUATI
[]A\A]
fff.
T$@H
L$HL
D$PL
L$Xt:
)D$`
)L$p
D$(1
D$(dH3
fff.
ATUH
[]A\H
fffff.
AVAUI
ATUH
]A\A]A^
fff.
AWAVAUATUSH
dH34%(
([]A\A]A^A_
H H9K
H9p 
L9` u
L;` t
fff.
AVAUI
ATUH
[]A\A]A^
AUATUSH
]A\A]
[]A\A]
ffff.
AWAVAUATUSH
D$X1
D$(H
D$PH
D$0H
D$LH
D$8f
T$ H
GtHcD
H;D$(
D$XdH3
h[]A\A]A^A_
t$ H
T$ H
AUATUSH
[]A\A]
AUATUSH
[]A\A]
ATUH
[]A\
AWAVAUATUSH
L$ H
D$8H
D$ H
\$(H
$H;D$8
X[]A\A]A^A_
D9t$@
t$@I
A[A\L
A_XH
-mgr-stuA
-agt-stuA
-agt
L$(L
D$(A
_AXH
\$0H
\$0H
\$@A
T$(L
D$@L
L$(H
D$HM
D$H9D$@t
L$(H
QAUI
AUATI
tBA9
[]A\A]
[]A\A]
fffff.
ATUH
[]A\
AWAVAUATUSH
D$X1
D$@null
E;l$
l$@fD
new byteH
D$H[0]
H9D$
D$XdH3
h[]A\A]A^A_
new AgenH
l$@H
D$@H
tXOID()
D$ null
l$@M
t$ f
ntYH
new byteL
D$([0]
=1b$
new AgenL
t$ H
D$ H
tXOID()
=W_$
=?_$
=/^$
=P]$
=9]$
t$ M
T$@H
L$HL
D$PL
L$Xt:
)D$`
)L$p
D$(1
D$(dH3
fff.
AWAVL
ATUSH
<tv@
[]A\A]A^A_
tkATL
[]A\H
fffff.
tkATL
[]A\H
fffff.
tKUSL
fffff.
tKUSL
fffff.
AWAVA
AUATI
[]A\A]A^A_
fffff.
AWAVAUATUSH
D$(1
H9h u
H9h 
t$(dH34%(
8[]A\A]A^A_
p H9s
H9p 
[]A\
AWAVL
AUATA
T$@D
T$PD
T$XD
[]A\A]A^A_L
T$ L
ffff.
ffff.
AUATUI
]A\A]A^
AWAVH
AUATUSH
L$0dH
L$H1
D$ H
D$@H
D$(H
D$@t
_AXH
L$8t
L$8I
L$8I
H9D$ 
D$HdH3
X[]A\A]A^A_
L$0H
ffff.
=iX$
AUATUSI
[]A\A]
AWAVAUATL
L9t$
[]A\A]A^A_
AWAVAUATUSH
%-y$
[]A\A]A^A_
([]A\A]A^A_
=RZ$
t7v%
fff.
AUATI
[]A\A]
t6USH
w\rJH
ATUH
[]A\
[]A\
St4H
[]A\A]A^
AUATI
D$81
D$8dH3
H[]A\A]
ffff.
AUATI
D$81
D$8dH3
H[]A\A]
ffff.
AUATI
[]A\A]
=di$
[]A\A]
=%i$
=	i$
[]A\A]
AWAV1
AUATUSH
=RX$
=sV$
=GV$
AXAYE
=ST$
='T$
=mS$
=BR$
=VP$
[]A\A]A^A_
AUATI
[]A\A]
[]A\A]
AWAVAUATUSH
D$81
D$ H
D$(H
D$4H
HcL$4H
L$4H
HcL$4H
D$8dH3
H[]A\A]A^A_
=))$
fff.
AWAVA
AUATE
D$0L
=7E$
[]A\A]A^A_
AWAVAUATUSH
[]A\A]A^A_
AWAVI
AUATA
l$ E1
[]A\A]A^A_
L;|$
fffff.
=rM$
="M$
fffff.
fff.
fffff.
ATUSH
[]A\H
ffff.
AUATUSH
[]A\A]
fff.
[]A\
t1H;X
=q<$
AWAVAUATA
CPff&@
ConceptuH
al model
 of H
- generaH
ted by s
.4.8H
midump 0
=B3$
XT$(
=;2$
_D$ 
D$ r
XD$(
\$(f
\$(H
[]A\A]A^A_
ConceptuH
al model
 of H
AUATA
=W*$
5T)$
=&)$
[]A\A]
=`($
T$@H
L$HL
D$PL
L$Xt:
)D$`
)L$p
D$(1
D$(dH3
fff.
ffff.
tSATL
[]A\
tSATL
[]A\
tKUSL
fffff.
tKUSL
fffff.
AWAVAUATUSH
D$(1
H9h u
H9h 
t$(dH34%(
8[]A\A]A^A_
p H9s
H9p 
[]A\
AWAVA
AUATL
D$X1
l$0L
T$@D
T$PD
T$XD
D$XdH3
h[]A\A]A^A_
D$HH
T$ L
ffff.
AUATUH
[]A\A]A^
AUATI
[]A\A]H
ffffff.
ffff.
AUATUI
]A\A]A^
AWAVH
AUAT
L$(dH
L$81
D$0H
8u;H
H9D$
D$8dH3
H[]A\A]A^A_
L$(H
fffff.
T$@H
L$HL
D$PL
L$Xt:
)D$`
)L$p
D$(1
D$(dH3
fff.
'tV@
\txH
tSATL
[]A\
tSATL
[]A\
tKUSL
fffff.
tKUSL
fffff.
AWAVAUATUSH
D$(1
H9h u
H9h 
t$(dH34%(
8[]A\A]A^A_
p H9s
H9p 
[]A\
AVAUI
ATUH
[]A\A]A^
AUATL
[]A\A]H
ffffff.
ffff.
AWAVA
AUATL
D$X1
l$0L
T$@D
T$PD
T$XD
D$XdH3
h[]A\A]A^A_
D$HH
T$ L
AUATUI
]A\A]A^
AWAVH
AUATI
L$(dH
L$81
D$0H
D$ H
H;D$
D$8dH3
H[]A\A]A^A_
L$(H
AUATUSH
[]A\A]
AUATUSH
[]A\A]
fffff.
ATUH
[]A\
ATUH
[]A\
ffffff.
AVAUI
ATUI
[]A\A]A^
[]A\A]A^
[]A\A]A^
[]A\A]A^
AVAUI
ATUH
]A\A]A^
[]A\A]A^
AVAUI
ATUH
[]A\A]A^
]A\A]A^
]A\A]A^
]A\A]A^
]A\A]A^
]A\A]A^
]A\A]A^
ffffff.
AWAVAUATI
[]A\A]A^A_
[]A\A]A^A_
tpE1
tKE1
AWAVAUATUSH
PAW1
[]A\A]A^A_
[]A\A]A^A_
fffff.
AWAVAUATUSH
[]A\A]A^A_
[]A\A]A^A_
ffffff.
AUATI
[]A\A]
[]A\A]
ffff.
AWAVAUATI
HcL$
[]A\A]A^A_
Hc\$
HcT$
HcL$
D;L$
HcL$
AUATM
[]A\A]H
[]A\A]
AWAVI
AUATUSH
[]A\A]A^A_
AWAVAUATI
[]A\A]A^A_
[]A\A]A^A_
AVAUI
ATUI
]A\A]A^
]A\A]A^
]A\A]A^
ffff.
AVAUI
ATUI
]A\A]A^
]A\A]A^
]A\A]A^
AWAVI
AUATI
[]A\A]A^A_
[]A\A]A^A_
[]A\A]A^A_
AVAUI
ATUH
tJ[1
]A\A]A^
]A\A]A^
[]A\A]A^
[]A\A]A^
[]A\A]A^
AWAVAUATUSH
|$0I
D$,H
D$8I
D$,H
l$ H
t$(L
L$ 1
[]A\A]A^A_
[]A\A]A^A_
fffff.
AWAVAUATI
D$(I
PAV1
|$ H
|$0H
APAV
APAV
|$0H
|$(H
8[]A\A]A^A_
AWAVAUATI
L$@H
d$ I
D$@H
D$(H
D$ H
|$(H
H9D$
D$ H;D$`
[]A\A]A^A_
L$0H
D$ L
|$(H
H9D$
H9D$
tZL9
D$0H
L$0H
PPAUPH
D$0H
AWAWM
AWSM
t4f.
_AXH
AYAZH
D$8I
D$8H
L$0H
D$HH
t$XL
t$XL
H9D$
L9|$
D$8I
\$XL
|$HH
_AXL
|$HH
\$Xt
AZA[H
L$HE
t&SSH
_AXSSH
t/f.
L$0H
t9H9
D$HH
L$HL
l$8L
l$8L
D$0H
L$@I
|$HI
A[A_H
AYAZH
D$0H
L$0H
D$PM
L$0H
L$0H
L$HL
D$PH
D$8M
D$89D$X
D$HH
t4f.
A[A]H
AXAY
L$XH
t$8H
l$pL
|$xf
|$PL
AUAUI
D$ H
D$(@
L$HL
|$81
L$HE
|$8H
|$8H
t$8H
l$pL
|$xH
|$8H
L$XH
|$8H
|$8H
D$PD
L$HL
|$8H
L$XH
\$8H
L$HH
L$HH
D$HH
L$HL
=,}#
D$HI
D$8H
t$hL
t$XL
D$HL
t$pH
t$pH
D$`1
53y#
=`y#
5'y#
fff.
fff.
ATUI
L$8L
D$@L
L$Ht7
)D$P
)L$`
)T$p
[]A\
AUATH
-{)#
<<th<>
<&tt
[]A\A]
fffff.
AUATH
[]A\A]
tLUSH
fff.
fffff.
ATUI
[]A\
[]A\
ffff.
AUATI
[]A\A]
[]A\A]
AVAUATUI
]A\A]A^
$u'H
AWAV1
AUATI
L9l$
[]A\A]A^A_
AWAVAUATI
[]A\A]A^A_
fffff.
AVAUH
ATUH
[]A\A]A^
P0H9
[]A\A]A^
[]A\A]A^
]A\A]A^
fff.
ATUH
[]A\1
AWAVAUATI
t$PH
[]A\A]A^A_
[]A\A]A^A_
AVAUATUI
[]A\A]A^1
[]A\A]A^
[]A\A]A^
[]A\A]A^
[]A\A]A^H
AWAVAUATI
t$ H
=;V#
H9D$ 
|$ H
T$ H
D$ H
8[]A\A]A^A_
AWAVAUATUS
L;l$
([]A\A]A^A_
=e #
AUATUS
t@[L
]A\A]A^
[]A\A]A^
]A\A]A^
AVE1
-xJ#
xAtO
[]A\A]A^
[]A\A]A^
[]A\A]A^
fff.
T$@H
L$HL
D$PL
L$Xt:
)D$`
)L$p
D$(1
D$(dH3
fff.
AUATA
HvEH
[]A\A]H
ffffff.
AVAUL
]A\A]A^
ffffff.
AWAVAUATUSH
5!A#
dH34%(
([]A\A]A^A_
H H9K
H9p 
=[@#
L;` u
L;` t
%d>#
%	>#
AUATH
USLc
[]A\A]
]A\A]
ffffff.
AWAVI
AUATI
[]A\A]A^A_
AUATUSH
=9<#
=p;#
dH34%(
[]A\A]
=";#
AWAVAUATUSH
t$ L
[]A\A]A^A_
MIBtoPIBI
Complianf
MIBtoPIB
ModuleCo
MIBtoPIBH
GrouH
InstanceH
Instance
N6fA
AWAV
AUATI
D$0H
t0I9
\$ A
InstanceI
T$ H
InstanceA
H9D$0
[]A\A]A^A_
|$ A
t	E9
|$ H
\$ f
H[]A\A]A^A_
L$8H
fff.
H3P0H)
fff.
ffff.
AWAVAUATA
GtdH
t$ H
[]A\A]A^A_
t$ H
AWAVAUATUSH
([]A\A]A^A_
RAVH
D$(H
|$ E
|$ H
AWAVI
AUATUSH
1t!H
D$(H
|$ H
8[]A\A]A^A_
AWAVAUATUSH
t$(H
D$$f
|$ L
D$8H
AYAZE
8[]A\A]A^A_
|$ H
_AX~
AQAQH
|$ H
AWAV
AUAT
[]A\A]A^A_
([]A\A]A^A_
L9t$
txHc
tP<'
ffff.
ATUSH
[]A\
ffffff.
xt t
AWAVAUATUSH
d$ H
H;D$
[]A\A]A^A_
fff.
ffff.
AWAVI
AUATA
([]A\A]A^A_
ffff.
ffff.
AWAVI
AUAT1
([]A\A]A^A_
L;(u
L;(u
L;(u
ffffff.
AWAVI
AUATM
T$8A
t$LH
D$0dH
D$$<
D$(Hc
L$8H
D$hH
L$0H
L$pH
D$@H
L$XH9
L$LE
D$8H
D$8H
L$PH
T$$H
T$$H
T$$H
|$$u
d$(H
D$hH
T$$H
D$$(
L$HE
D$LH
l$8L
d$PE
|$ H
D$HE
|$ H
|$ H
D$0H
\$`L
|$@H
\$`A
|$ H
|$ H
D$0L
l$@H
\$`L
\$`H
|$HE
|$ H
D$0L
|$@H
\$`L
t$@L
D$0H
L;(u
|$@L
D$0H
L;(u
t$@L
l$`f
D$0H
L;(u
[]A\A]A^A_
AWAVAUATUSH
[]A\A]A^A_
[]A\A]A^A_
 is defi
ned in mf
odul
:\n\
This is H
a basety
AWAVA
AUATI
cHtmH
L;j(
([]A\A]A^A_
AWAVAUATUSH
D$81
XH$H
ZSLf
\n-- -- L
--\n
t$(L
D$8dH3
H[]A\A]A^A_
D$4H
D$0H
l$0H
D$4M
D$ u'
t$ H
AXAY
|$4L
tAH;X
A[XH
L$4H
XD$4
D$4H
L$ D
L$4H
XD$4
fffff.
AWAVAUATUSHc
\$$dH
D$HH
t$ 1
t$xf
T$ A
.D$0v
t$ H
t$ H
D$$M
_l$ H
l$(E1
|$hL
D$0I
D$PL
l$0v
T$ A
d$X1
|$$L
\$0f.
d$`1
|$$L
l$@f.
l$HD
|$$H
\$0H
t$h1
|$PL
D$X1
L$`I
\$ f
L$@A
ConceptuI
al modelA
 of I
- generaL
ted by s
.4.8H
midump 0
Z4$f
Z\$x
ZT$ f
5Bf"
ZD$ SSSS
D$hf
PPPh
l$$L
t$@H
H9h(
d$0M
L$HH
t$@H
l$@H
T$$H
Z]Pf
XULf
t7D;e
L$4M
A[XH
D$ Hc|$0
\D$p
L$hH
t$P1
|$XL
D$`1
L$HD
T$$1
T$|1
T$|E
D$0f
T$|E
[]A\A]A^A_
T$0H
D$8H
T$8H
D$0H
l$@L
l$pH
L;d$
L$0H
d$8I
L;d$
d$@L
H;l$
l$0H
l$8H
L$0H
t$@L
|$0H
D$pH
L;l$p
5)}"
tv9X u
H;l$8
L;l$p
T$(H
T$(H
l$8H
tKH9C
AYAZH
=}u"
l$@H
D$pH
|$(D
|$0L
t$0H
H;l$p
D$HA
=Jr"
tf9X u
L$HL
D$8H
t$DH
5:q"
L9d$8
H;l$p
H;\$
l$8I
H;l$
t$(L
t-f.
ConceptuI
al modelA
 of I
l$ E1
ffffff.
AWAVH
AUATA
D$(1
http://wI
ww.ibr.c
s.tu-bs.fA
de/projeI
cts/libsA
G8gi?
mi/svg/mL
ib2svg.cA
G;widtI
&amp;heiH
ght=H
&amp;depI
robs=obsA
oletI
=qj"
="j"
&amp;depH
robs=depH
recated
=9i"
D$(dH3
8[]A\A]A^A_
=I;"
AUATL
C$IcD
C Ic
[]A\A]
fff.
AVAUI
ATUH
a$w H
[]A\A]A^
[]A\A]A^
fff.
AUATUSH
]A\A]
[]A\A]
AWAVAUATI
[]A\A]A^A_
ATUI
St5I
[]A\A]A^
[]A\A]A^
=z_"
t{USH
fffff.
t_USH
ATUI
[]A\
fff.
fff.
AWAVI
AUATUSH
[]A\A]A^A_
ffffff.
fff.
AWAVAUATUSH
l$hH
[]A\A]A^A_
[]A\A]A^A_
ffffff.
AWAVAUATUSH
=#T"
[]A\A]A^A_
[]A\A]A^A_
ffff.
AWAVAUATUSH
=-S"
[]A\A]A^A_
u,A9
=-O"
t0;k
[]A\A]A^A_
ffffff.
AWAVAUATUSH
=*J"
[]A\A]A^A_
[]A\A]A^A_
ffff.
AWAVAUATUSH
[]A\A]A^A_
[]A\A]A^A_
AWAVAUATI
([]A\A]A^A_
([]A\A]A^A_
ARAQI
ASAP1
|$0A
ffffff.
AWAVI
AUATI
([]A\A]A^A_
AWAVI
AUATA
T$(1
l$$L
d$ I
L9t$
D$(dH3
8[]A\A]A^A_
AWAVAUATI
[]A\A]A^A_
[]A\A]A^A_
AWAVI
AUATUSH
[]A\A]A^A_
[]A\A]A^A_
ATUI
[]A\
fffff.
t#SH
ATUSH
[]A\
fff.
AUATUSH
[]A\A]
t$(H
T$0H
L$8L
D$@L
L$HtcH
|$`H
|$ H
dH3<%(
AWAVAUATUSH
D$(1
L$(dH3
8[]A\A]A^A_
T$0H
L$8L
D$@L
L$Ht7
)D$P
)L$`
)T$p
ffffff.
AWAVI
AUATI
([]A\A]A^A_
ffffff.
T$0H
L$8L
D$@L
L$Ht7
)D$P
)L$`
)T$p
ffffff.
t	Hc
AVAUATUSH
[]A\A]A^
tIE9
[]A\A]A^
atl@
AWAVH
AUATH
|$H1
t$ H
D$0H
|$@H
\$HdH3
X[]A\A]A^A_
t$(E
t$(H
L$ 1
T$0H
T$0I
T$0H
T$0I
T$0H
D9|$(
T$0H
T$0H
T$0H
T$0I
T$01
T$0H
T$0I
T$0H
T$@M
T$0H
T$0H
T$0H
T$0L
T$0H
T$0H
T$0H
T$0H
D$ H
d$0L
T$0H
T$0H
T$0H
|$@H
|$@H
D$ L
l$@L
d$8E1
T$8H
L$@H
D;t$
T$8s+H
d$8H
T$0H
D$ H
T$0H
L$01
to<(t]<)u\
tl<(tZ<)uY
T$0H
|$@H
D$ E1
l$@L
d$8L
T$8H
L$@H
D9t$
T$8w
AVAUI
ATUStjH
[]A\A]A^
T$@H
L$HL
D$PL
L$Xt:
)D$`
)L$p
D$(1
D$(dH3
fff.
AUATI
USHc
[]A\A]
]A\A]
ffffff.
ATUH
[]A\1
AUATA
[]A\A]
AWAVA
AUATL
[]A\A]A^A_
  %-14s: %s
none
Supported formats are:
  --%s-%s%s%s%n
%*s%s
%s:%d: 
[%d] 
{%s} 
warning: 
info: 
smidump
smidump 0.4.8
%s-%s
--config
help
version
level
preload
quiet
error-names
severity
unified
keep-going
Usage: smidump [options] [module or path ...]
  -V, --version        show version and license information
  -h, --help           show usage information
  -q, --quiet          do not generate any comments
  -c, --config=file    load a specific configuration file
  -p, --preload=module preload <module>
  -l, --level=level    set maximum level of errors and warnings
  -m, --error-names    print the name of errors in braces
  -s, --severity       print the severity of errors in brackets
  -f, --format=format  use <format> when dumping (default %s)
  -o, --output=name    use <name> when creating names for output files
  -u, --unified        print a single unified output of all modules
  -k, --keep-going     continue after serious parse errors
Specific option for the "%s" format:
smidump: invalid dump format `%s' - supported formats are:
smidump: malloc failed - running out of memory
smidump: realloc failed - running out of memory
smidump: calloc failed - running out of memory
smidump: strdup failed - running out of memory
smidump: no dump formats registered
smidump: %s format does not support united output: ignoring -u
smidump: %s format does not support output option: ignoring -o %s
smidump: module `%s' contains errors, expect flawed output
smidump: cannot locate module `%s'
smidump: aborting due to severe parsing errors
smidump: use the -k option to force continuation
invalid number `%s'
unrecognized option `%s'
unrecognized option `-%c'
number `%s' to `%s' out of range
option `%s' requires an argument
option `%s' doesn't allow an argument
Enumeration
Bits
Unsigned32
<unknown>
Float128
Float64
Float32
Integer32
MODULE-IDENTITY
SNMPv2-SMI
current
%llu
%lld
0x%*s
%02x
%s(%s)
..%s
.%u%s
ObjectSyntax
scalar
node
column
noaccess
notifyonly
readwrite
readonly
module %s 
SNMPv2-TC
import %-*s (
     %-*s  
organization
contact
description
reference
revision {
date
%04d-%02d-%02d %02d:%02d
identity
extension %s {
status
abnf
identity %s {
parent
RFC1155-SMI
// TYPE DEFINITIONS
typedef %s {
units
// CLASS DEFINITIONS
class %s {
extends
attribute %s {
readonly;
readwrite;
eventonly;
unique
, %s
event %s {
// OBJECT DEFINITIONS
%s %s {
index implied
index
reorders %s
sparse
expands %s
notification %s {
objects
// GROUP DEFINITIONS
group %s {
members
}; // end of module %s.
compliance %s {
mandatory
optional %s {
refine %s {
writetype
smidump: write error
sming
SMIng
OBJECT-IDENTITY
OBJECT-TYPE
NOTIFICATION-TYPE
ObjectName
NotificationName
SimpleSyntax
ApplicationSyntax
IpAddress
IRTF-NMRG-SMING
Counter32
TimeTicks
Opaque
Counter64
Gauge32
mib-2
IRTF-NMRG-SMING-SNMP
TimeStamp
TimeInterval
DateAndTime
TruthValue
PhysAddress
MacAddress
DisplayString
DisplayString255
TestAndIncr
AutonomousType
VariablePointer
RowPointer
RowStatus
StorageType
TDomain
TAddress
TEXTUAL-CONVENTION
IRTF-NMRG-SMING-TYPES
SNMPv2-CONF
OBJECT-GROUP
NOTIFICATION-GROUP
MODULE-COMPLIANCE
AGENT-CAPABILITIES
Gauge
Counter
NetworkAddress
RFC1158-MIB
RFC-1212
RFC1213-MIB
system
SNMPv2-MIB
interfaces
IF-MIB
IP-MIB
icmp
TCP-MIB
UDP-MIB
transmission
sysDescr
sysObjectID
sysUpTime
ifIndex
RFC-1215
TRAP-TYPE
OCTET STRING
OBJECT IDENTIFIER
smidump: cannot open %s for writing: 
// This module has been generated by smidump 0.4.8. Do not edit.
// MODULE META INFORMATION
// EXTENSION DEFINITIONS
// IDENTITY DEFINITIONS
-- This has been an SMIv2 AGENT-CAPABILITIES node:
// NOTIFICATION DEFINITIONS
// COMPLIANCE DEFINITIONS
BITS
%04d%02d%02d%02d%02dZ
-- %*c%s
optional
not-accessible
read-create
read-write
accessible-for-notify
read-only
'%*s'H
  { 
 (SIZE(
IMPLIED 
 %u%s
 %s(%u)%s
%s OBJECT IDENTIFIER
::= 
{ %s }
-- %s MODULE-COMPLIANCE
STATUS
DESCRIPTION
REFERENCE
MODULE
-- -- this module
MANDATORY-GROUPS
OBJECT
WRITE-SYNTAX
+%s+
SMIv1
SMIv2
ibrpibtomib
TUBS-SMI
IBRUnsigned64
IBRInteger64
-PIB
zeroDotZero
-- Expect flawed output.
%s%s DEFINITIONS ::= BEGIN
IMPORTS
FROM %s
FROM %s;
-- %s MODULE-IDENTITY
LAST-UPDATED
"197001010000Z"
ORGANIZATION
CONTACT-INFO
REVISION
{ ibrpibtomib %d }
-- %s ::=
-- %s ::= TEXTUAL-CONVENTION
DISPLAY-HINT
%s OBJECT-IDENTITY
-- %s OBJECT-TYPE
SEQUENCE OF 
<unknown>
UNITS
MAX-ACCESS
read-create
AUGMENTS
{ %s }
DEFVAL
{ %s }
%s ::= SEQUENCE {
RowStatus
RowStatus
current
{ %s %d }
%s TRAP-TYPE
ENTERPRISE
%s NOTIFICATION-TYPE
VARIABLES
OBJECTS
-- %s %s
NOTIFICATIONS
END -- end of module %s%s.
smiv2
smiv1
InstancePointer
internet
directory
mgmt
experimental
private
enterprises
 -- commented out by smidump
-- This %s module has been generated by smidump 0.4.8. Do not edit.
-- WARNING: SPPI to SMIv1 conversion is not explicitly supported.
-- WARNING: this output may be incorrect due to significant parse errors
[Revision added by libsmi due to a LAST-UPDATED clause.]
Added by smidump for automatic PIB to MIB conversion.
SMIv2 (RFC 2578, RFC 2579, RFC 2580)
SMIv1 (RFC 1155, RFC 1212, RFC 1215)
yang-smi
yang-types
inet-types
inet
ieee-types
ieee
smi:display-hint
 "%s";
config true;
config false;
smi:oid
%s%d
binary
/%s:%s
leaf 
type keyref {
path "
enum
value
position
%s %-*s { %s %s; }
length "
range "
pattern "
smi:default
object-identifier
 *      smidump -f yang
 --yang-smi-extensions
 --yang-no-notifications
module %s {
namespace 
"%s%s";
prefix 
"%s";
/*** META INFORMATION ***/
revision 
%04d-%02d-%02d
"%s" {
/*** TYPE DEFINITIONS ***/
list
key "
augment
} /* end of module %s */
notification
container 
%s-%s-%d {
%s-%s {
import
 %-*s { prefix "%s"; }
container
generate smi extensions
do not generate notifications
indent
indentation (default 2)
YANG format
snmpTraps
uint32
uint64
enumeration
bits
counter32
counter64
gauge32
timeticks
ipv4-address
phys-address
mac-address
timestamp
Automagically generated keyref leaf.
 * This module has been generated by smidump 0.4.8:
 * Do not edit. Edit the source file instead!
/*** NAMESPACE / PREFIX DEFINITION ***/
urn:ietf:params:xml:ns:yang:smiv2:
/*** LINKAGE (IMPORTS / INCLUDES) ***/
/* XXX table comments here XXX */
%s  (recursion - aborted)
%s  |
%s  +--%s [%d identifier%s]
%s   
recursive list of all imports
# %s imports tree (generated by smidump 0.4.8)
# WARNING: this output may be incorrect due to significant parse errors
%s  %c-- %s %-*s
%s  %c--%-*s
%s%s(%ld)
	"%s"
xxxx
no-implicit
# %s type derivation tree (generated by smidump 0.4.8)
# united type derivation tree (generated by smidump 0.4.8)
ignore implicit type definitions
recursive list of all derived types
%s%s%s
%s-- %s %-*s %s(%u)
%s--%s(%u) [
%s--%s(%u)
%s--%s(
%s%u
%s--%s(?)
no-conformance
do not show conformance nodes
no-leafs
do not show leaf nodes
full-root
compact
structure of the OID tree
# united registration tree (generated by smidump 0.4.8)
# %s registration tree (generated by smidump 0.4.8)
generate the full path to the root
generate a more compact representation
%%%-19s %-16s "
Aggregate
object-group
notification-group
%-20s %s
%%n0 %-16s module-identity
%%n0 %-16s object-id
%%%-19s %-16s %-15s "%s"
%%%-19s %-16s %-15s %s
%-20s %-16s 
%-15s %-15s %s
%%%-19s %-16s %s
%%%-19s %-16s %-15s 
%%n0 %-16s notification
%%n0 %-16s %s
%%n0 %-16s module-compliance
mosy
-- automatically generated by smidump %s, do not edit!
-- object definitions compiled from %s
-- WARNING: this output may be incorrect due to significant parse errors
intermediate format generated by the mosy compiler
ASN1_Null
ASN1_Integer
ASN1_OctetString
ASN1_ObjectIdentifier
ASN1_Unsigned
ASN1_Integer64
ASN1_Unsigned64
ASN1_Real
smidump: %s already exists
 *   
abstract
%sType
%sVBType
REFERENCE:
UNITS:
::%s::%s::%s 
DISPLAY-HINT:
typedef 
%s %s; 
const string 
%s_NameNumberList = "
const 
%s %s_%s = %s;
%s (%s)
readonly attribute
.idl
 *   smidump -f corba %s
 * Derived from %s:
 * $Id$
 * Revision %s:
#ifndef _%s_IDL_
#define _%s_IDL_
#include <ASN1Types.idl>
#include <SNMPMgmt.idl>
module %s {
#include <%s.idl>
%s::%s %s;
LAST-UPDATED:
ORGANIZATION:
CONTACT-INFO:
REVISION:
REVISION-DESCRIPTION:
interface
 %s : SNMPMgmt::SmiEntry {
SNMPMgmt::SmiTableIterator
 get_%s();
 %s : %s::%s {
string IndexVarList = "
struct 
string var_name;
string var_index;
interface Notifications : 
SNMPMgmt::Notifications {
void 
%s notification_info
pull_%s (
out 
boolean 
try_%s (
%s create_%s (
%s %s
) raises (
SNMPMgmt::AlreadyExists,
/* pseudo */
interface DefaultValues {
/* DEFVAL: 
%s %s();
#endif /* !_%s_IDL_ */
.oid
Group not-accessible
Table not-accessible
TableEntry not-accessible
Notification not-accessible
197001010000Z
corba
boolean
case
const
context
custom
double
exception
factory
FALSE
fixed
float
inout
long
module
native
object
octet
oneway
public
raises
sequence
short
struct
supports
switch
TRUE
truncatable
unsigned
union
valuebase
valuetype
void
wchar
wstring
smidump: `%s' (%s%s%s) collides with IDL keyword `%s'
smidump: `%s' (%s%s%s) collides with `%s' (%s%s%s)
/*							-- DO NOT EDIT --
 * Generated by smidump version 0.4.8:
string moduleIdentity = "%s";
ASN1_ObjectIdentifier %s = "::%s::%s";
/* typed push event communication */
in CosNaming::Name src_entry_name,
in CORBA::ScopedName event_type,
in ASN1_GeneralizedTime event_time
/* typed pull event communication */
interface PullNotifications : 
SNMPMgmt::PullNotifications {
out CosNaming::Name src_entry_name,
out CORBA::ScopedName event_type,
out ASN1_GeneralizedTime event_time
interface SmiEntryFactory : SNMPMgmt::GenericFactory {
CosLifeCycle::InvalidCriteria,
CosLifeCycle::CannotMeetCriteria
interface TextualConventions {
string %sToString (in %s Value);
%s %sFromString (in string str);
ASN1_ObjectIdentifier not-accessible
corba IDL interface and OID definitions (JIDM)
RWRITE
RONLY
ASN_NULL
ASN_INTEGER
ASN_OCTET_STR
ASN_OBJECT_ID
ASN_Real
#ifndef _%s_H_
#define _%s_H_
#include <stdlib.h>
typedef struct %s {
    uint32_t  *%s;
    size_t    _%sLength;
    u_char    *%s;
    int32_t   *%s;
    int64_t   *%s; 
    uint64_t  *%s; 
    /* ?? */  __%s; 
} %s_t;
    uint32_t  __%s[%u];
    u_char    __%s[%u];
    int32_t   __%s;
    uint32_t  __%s;
    int64_t   __%s; 
    uint64_t  __%s; 
    %s_t	*%s;
    %s_t	%s;
void %s_agt_init(void);
#endif /* _%s_H_ */
#define %-32s %d
static oid %s_base[] = {
int register_%s()
    static %s_t %s;
    case %s:
void init_%s(void)
static oid %s[] = {
    }
        }
no-mgr-stubs
no-agt-stubs
netsnmp
 * This C header file has been generated by smidump 0.4.8.
 * It is intended to be used with the NET-SNMP package.
 * This header is derived from the %s module.
 * $Id$
#ifdef HAVE_STDINT_H
#include <stdint.h>
#endif
 * C type definitions for %s::%s.
    void      *_clientData;		/* pointer to client data structure */
    struct %s *_nextPtr;	/* pointer to next table entry */
    /* private space to hold actual values */
 * C manager interface stubs for %s::%s.
extern int
%s_mgr_get_%s(struct snmp_session *s, %s_t **%s);
 * C agent interface stubs for %s::%s.
extern int
%s_agt_read_%s(%s_t *%s);
extern int
%s_agt_register_%s();
 * Initialization function:
 * This C file has been generated by smidump 0.4.8.
 * It is intended to be used with the NET-SNMP agent library.
 * This C file is derived from the %s module.
 * $Id$
#include <stdio.h>
#include <string.h>
#include <malloc.h>
#include "%s.h"
#include <ucd-snmp/asn1.h>
#include <ucd-snmp/snmp.h>
#include <ucd-snmp/snmp_api.h>
#include <ucd-snmp/snmp_impl.h>
#include <ucd-snmp/snmp_vars.h>
 * Forward declaration of read methods for groups of scalars and tables:
static unsigned char *
read_%s_stub(struct variable *, oid *, size_t *, int, size_t *, WriteMethod **);
 * Forward declaration of write methods for writable objects:
static int
write_%s_stub(int, u_char *, u_char, int, u_char *, oid *, int);
 * Definitions of tags that are used internally to read/write
 * the selected object type. These tags should be unique.
struct variable %s_variables[] = {
    { %s, %s, %s, read_%s_stub, %d, {%d} },
 * Registration functions for the various MIB groups.
    return register_mib("%s",
         %s_variables,
         sizeof(struct variable),
         sizeof(%s_variables)/sizeof(struct variable),
         %s_base,
         sizeof(%s_base)/sizeof(oid));
 * Read methods for groups of scalars and tables:
static unsigned char *
read_%s_stub(struct variable *vp,
    oid     *name,
    size_t  *length,
    int     exact,
    size_t  *var_len,
    WriteMethod **write_method)
    /* check whether the instance identifier is valid */
    if (header_generic(vp, name, length, exact, var_len,
                       write_method) == MATCH_FAILED) {
        return NULL;
    }
    /* call the user supplied function to retrieve values */
    read_%s(&%s);
    /* return the current value of the variable */
    switch (vp->magic) {
    default:
         ERROR_MSG("");
    }
    return NULL;
        *var_len = %s._%sLength;
        return (unsigned char *) %s.%s;
        return (unsigned char *) &%s.%s;
        /* add code to return the value here */
static int
write_%s_stub(int action,
    u_char   *var_val,
    u_char   var_val_type,
    int      var_val_len,
    u_char   *statP,
    oid      *name,
    int      name_len)
    return SNMP_ERR_NOERROR;
static oid %s_caps[] = {0,0};
void deinit_%s()
    unregister_sysORTable(%s_caps, sizeof(%s_caps));
int term_%s()
    deinit_%s();
    return 0;
 * This C file has been generated by smidump 0.4.8.
 * It is intended to be used with the NET-SNMP library.
 * This C file is derived from the %s module.
 * $Id$
#include <stdlib.h>
#include <ucd-snmp/asn1.h>
#include <ucd-snmp/snmp.h>
#include <ucd-snmp/snmp_api.h>
#include <ucd-snmp/snmp_client.h>
#include "%s.h"
int %s_mgr_get_%s(struct snmp_session *s, %s_t **%s)
    struct snmp_session *peer;
    struct snmp_pdu *request, *response;
    struct variable_list *vars;
    int status;
    request = snmp_pdu_create(SNMP_MSG_GETNEXT);
    peer = snmp_open(s);
    if (!peer) {
        snmp_free_pdu(request);
        return -1;
    }
    status = snmp_synch_response(peer, request, &response);
    if (status != STAT_SUCCESS) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -2;
    }
    *%s = (%s_t *) malloc(sizeof(%s_t));
    if (! *%s) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -4;
    }
    for (vars = response->variables; vars; vars = vars->next_variable) {
    snmp_add_null_var(request, %s, sizeof(%s)/sizeof(oid));
    if (response) snmp_free_pdu(response);
    if (snmp_close(peer) == 0) {
        return -5;
    }
    return 0;
        if (vars->name_length > sizeof(%s)/sizeof(oid)
            && memcmp(vars->name, %s, sizeof(%s)) == 0) {
            (*%s)->__%s = *vars->val.integer;
            (*%s)->%s = &((*%s)->__%s);
            memcpy((*%s)->__%s, vars->val.string, vars->val_len);
            (*%s)->_%sLength = vars->val_len;
            (*%s)->%s = (*%s)->__%s;
do not generate manager stub code
do not generate agent stub code
ANSI C code for the NET-SNMP package
<UNKNOWN>
byte[]
bytes
columnar
package %s;
        case %d: // %s
        {
new byte[%ld]
AgentXOID
    protected %s %s = %s;
    // foreign indices
    protected %s %s;
    {
        this.%s = %s;
        instance.append(%s);
            %s = value;
            undo_%s = null;
Impl.java
    {
        super(
    public %s(
%s %s_%d
        oid = %s_OID;
        oid.append(0);
package
TIMETICKS
COUNTER32
IPADDRESS
OCTETSTRING
OBJECTIDENTIFIER
GAUGE32
COUNTER64
 * This Java file has been generated by smidump 0.4.8. Do not edit!
 * It is intended to be used within a Java AgentX sub-agent environment.
 * $Id$
    This class represents a Java AgentX (JAX) implementation of
    the table %s defined in %s.
    @version 1
    @author  smidump 0.4.8
    @see     AgentXTable
import java.util.Vector;
import jax.AgentXOID;
import jax.AgentXVarBind;
import jax.AgentXResponsePDU;
import jax.AgentXSetPhase;
import jax.AgentXTable;
import jax.AgentXEntry;
public class %s extends AgentXTable
    // entry OID
    private final static long[] OID = {
    // constructors
    public %s()
    {
        oid = new AgentXOID(OID);
        // register implemented columns
    public %s(boolean shared)
    {
        super(shared);
        oid = new AgentXOID(OID);
        // register implemented columns
        columns.addElement(new Long(%d));
    public AgentXVarBind getVarBind(AgentXEntry entry, long column)
    {
        AgentXOID oid = new AgentXOID(getOID(), column, entry.getInstance());
        switch ((int)column) {
        }
        return null;
    }
    public int setEntry(AgentXSetPhase phase,
                        AgentXEntry entry,
                        long column,
                        AgentXVarBind vb)
    {
        switch ((int)column) {
            %s value = ((%s)entry).get_%s();
            return new AgentXVarBind(oid, AgentXVarBind.%s, value);
        }
        return AgentXResponsePDU.NOT_WRITABLE;
    }
            if (vb.getType() != AgentXVarBind.%s)
                return AgentXResponsePDU.WRONG_TYPE;
            else
                return ((%s)entry).set_%s(phase, vb.%sValue());
    This class represents a Java AgentX (JAX) implementation of
    the table row %s defined in %s.
    @version 1
    @author  smidump 0.4.8
    @see     AgentXTable, AgentXEntry
import jax.AgentXOID;
import jax.AgentXSetPhase;
import jax.AgentXResponsePDU;
import jax.AgentXEntry;
public class %s extends AgentXEntry
    protected %s undo_%s = %s;
        instance.appendImplied(%s);
        // [smidump: type of %s not supported]
    public %s get_%s()
    {
        return %s;
    }
    public int set_%s(AgentXSetPhase phase, %s value)
    {
        switch (phase.getPhase()) {
        case AgentXSetPhase.TEST_SET:
            break;
        case AgentXSetPhase.COMMIT:
            undo_%s = %s;
            %s = new byte[value.length];
            for(int i = 0; i < value.length; i++)
                %s[i] = value[i];
            break;
        case AgentXSetPhase.UNDO:
            %s = undo_%s;
            break;
        case AgentXSetPhase.CLEANUP:
            break;
        default:
            return AgentXResponsePDU.PROCESSING_ERROR;
        }
        return AgentXResponsePDU.NO_ERROR;
    }
 * This Java file has been generated by smidump 0.4.8. It
 * is intended to be edited by the application programmer and
 * to be used within a Java AgentX sub-agent environment.
 * $Id$
    This class extends the Java AgentX (JAX) implementation of
    the table row %s defined in %s.
public class %sImpl extends %s
    // constructor
    public %sImpl(
    This class extends the Java AgentX (JAX) implementation of
    the scalar group %s defined in %s.
import java.util.Vector;
import java.util.Enumeration;
import jax.AgentXOID;
import jax.AgentXSetPhase;
import jax.AgentXResponsePDU;
            undo_%s = -1; // TODO: better check!
            break;
        default:
            return AgentXResponsePDU.PROCESSING_ERROR;
        }
        return AgentXResponsePDU.NO_ERROR;
    }
    This class represents a Java AgentX (JAX) implementation of
    the scalar group %s defined in %s.
    @version 1
    @author  smidump 0.4.8
    @see     AgentXGroup, AgentXScalars
import java.util.Vector;
import java.util.Enumeration;
import jax.AgentXOID;
import jax.AgentXVarBind;
import jax.AgentXSetPhase;
import jax.AgentXResponsePDU;
import jax.AgentXScalars;
public class %s extends AgentXScalars
    private final static long[] %sOID = {
    protected AgentXOID %sOID;
    protected final static long[] %sName = {
    public %s()
    {
        oid = new AgentXOID(%sOID);
        data = new Vector();
        %sOID = new AgentXOID(%sName);
        data.addElement(%sOID);
    public AgentXVarBind getScalar(AgentXOID pos, AgentXOID oid)
    {
        if ((pos == null) || (pos.compareTo(oid) != 0))
            return new AgentXVarBind(oid, AgentXVarBind.NOSUCHOBJECT);
        else {
            if (pos == %sOID)
                return new AgentXVarBind(oid, AgentXVarBind.%s, 
                                         get_%s());
        }
        return new AgentXVarBind(oid, AgentXVarBind.NOSUCHOBJECT);
    }
    public int setScalar(AgentXSetPhase phase, AgentXOID pos,
                         AgentXVarBind inVb)
    {
        if ((pos == null) || (pos.compareTo(inVb.getOID()) != 0))
            return AgentXResponsePDU.INCONSISTENT_NAME;
        else {
            if (pos == %sOID)
                return set_%s(phase, inVb.%sValue());
        }
        return AgentXResponsePDU.NOT_WRITABLE;
    }
    public AgentXVarBind getNextScalar(AgentXOID pos, AgentXOID oid)
    {
        if ((pos == null) || (pos.compareTo(oid) <= 0))
            return new AgentXVarBind(oid, AgentXVarBind.ENDOFMIBVIEW);
        else {
            if (pos == %sOID)
                return new AgentXVarBind(pos, AgentXVarBind.%s, 
                                         get_%s());
        }
        return new AgentXVarBind(pos, AgentXVarBind.ENDOFMIBVIEW);
    }
import jax.AgentXOID;
import jax.AgentXVarBind;
import jax.AgentXNotification;
import java.util.Vector;
public class %s extends AgentXNotification
    private final static long[] %s_OID = {
    private static AgentXVarBind snmpTrapOID_VarBind =
        new AgentXVarBind(snmpTrapOID_OID,
                          AgentXVarBind.OBJECTIDENTIFIER,
                          new AgentXOID(%s_OID));
    private final static long[] OID%d = {
    private final AgentXOID %s_OID = new AgentXOID(OID%d
        AgentXOID oid;
        AgentXVarBind varBind;
        // add the snmpTrapOID object
        varBindList.addElement(snmpTrapOID_VarBind);
    public Vector getVarBindList() {
        return varBindList;
    }
        // add the %s %s object of %s_%d
        oid = %s_OID;
        oid.appendImplied(%s_%d.getInstance());
        varBind = new AgentXVarBind(oid,
                                    AgentXVarBind.%s,
                                    %s_%d.get_%s());
        varBindList.addElement(varBind);
        // the notification's object %s is not contained in this module.
make classes part of a given package
Java AgentX sub-agent classes in separate files
&lt;
<reference>
</reference>
<description>
</description>
<format>%s</format>
<units>%s</units>
<%s module="%s" name="%s"/>
</%s>
<default>
<typedef
 basetype="%s"
 status="%s"
<parent 
<range
 min="%s"
 max="%s"
<namednumber
 number="%s"
</typedef>
<access>%s</access>
<%s name="%s"
 oid="
 create="true"
<?xml version="1.0"?>
<smi>
<organization>
</organization>
<contact>
</contact>
<revision date="%s">
</revision>
<identity node="%s"/>
</module>
<imports>
</imports>
<typedefs>
</typedefs>
<nodes>
<syntax>
<type 
</syntax>
<linkage
 implied="true"
</linkage>
</nodes>
<notifications>
<objects>
</objects>
</notifications>
<groups>
<members>
member
</members>
</groups>
<compliances>
compliance
<requires>
</requires>
</option>
<refinements>
<refinement 
module="%s" name="%s">
<writesyntax>
</writesyntax>
</refinement>
</refinements>
</compliances>
</smi>
<module name="%s">
no-schema
no-doctype
&gt;
&amp;
<!DOCTYPE smi SYSTEM "http://www.ibr.cs.tu-bs.de/projects/nmrg/smi.dtd">
<!-- This module has been generated by smidump 0.4.8. Do not edit. -->
<smi xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
     xsi:noNamespaceSchemaLocation="http://www.ibr.cs.tu-bs.de/projects/nmrg/smi.xsd">
<import module="%s" name="%s"/>
<augments module="%s" name="%s"/>
<reorders module="%s" name="%s"/>
<sparse module="%s" name="%s"/>
<expands module="%s" name="%s"/>
<option module="%s" name="%s">
<module name="%s" language="%s">
disable XML Schema spec in the toplevel element
disable DOCTYPE spec in the XML prolog
intermediate SMI XML exchange format
 %*s
 %s TEXTUAL-CONVENTION
:%d:
 %*s %-12s
capabilities
<UNDEFINED>
 %s OBJECT-TYPE -- %s
 %*s %-12s 
lines
show line numbers
path
ctag
list of all identifiers
# united list of identifiers (generated by smidump 0.4.8)
# %s list of identifiers (generated by smidump 0.4.8)
show file path instead of module name
show symbols in [g]ctag format
total
average
TOTAL
CATEGORY
%-14s %8s %12s %10s %8s %8s
FORMAT
UNIT
%-10s %6s 
[%d]
 %5s
%-10s %6lu 
 %5lu
 %4.1f%%
CURRENT
%-14s %8s %8s %11s %9s
OBSOLETE
DEPRECATED
%-14s %8lu %8lu %11lu %9lu
READWRITE
%-14s %8s %10s %9s %7s %8s
NOACCES
NOTIFY
READONLY
EXPAND
SPARSE
REORDER
AUGMENT
Types:
Tables:
Columns:
Scalars:
Notifications:
Groups:
Compliances:
Summary:
%-14s %8s %8s %8s %8s
COMPLEXITY
WEIGHT
Scalars (ro):
%-14s %8lu %8lu
Scalars (rw):
Columns (ro):
Columns (rw):
Indexes:
%-*s %-*s   USAGE
%-*s %-*s 
%6.1f%%
%-*s %-*s EXT-USAGE
NODE
%-*s %-*s COMPLEXITY
**** GEEEEEE - ROWSTATUS
**** GEEEEEE - STORAGETYPE
   %3d    %s
%-*s %7s  
     -    ----------
   -
# smidump -u -f metrics
 --metrics-raw
# The following table shows the %s text length distribution (in
# bytes) of all definitions contained in the set of loaded MIB modules.
%-14s %8lu %12lu %10lu %8lu %8lu
%-14s %8lu %12.1f %10.1f %8.1f %8.1f
# The following table shows the text clause usage distribution of all
# definitions contained in the set of loaded MIB modules.
%-14s %8lu %11.1f%% %9.1f%% %7.1f%% %7.1f%%
# The following table shows the table index length distribution of
# table definitions contained in the set of loaded MIB modules.
# The following table shows the table length distribution of
# table definitions contained in the set of loaded MIB modules.
# The following table shows the status distribution of various
# definitions contained in the set of loaded MIB modules.
%-14s %8lu %7.1f%% %10.1f%% %8.1f%%
# The following table shows the access mode distribution of all scalar
# or column definitions contained in the set of loaded MIB modules.
%-14s %8lu %10lu %9lu %7lu %8lu
%-14s %8lu %9.1f%% %8.1f%% %6.1f%% %7.1f%%
# The following table shows the table index kind distribution of
# table definitions contained in the set of loaded MIB modules.
%-14s %8s %8s %8s %8s %8s %8s
%-14s %8lu %8lu %8lu %8lu %8lu %8lu
%-14s %8lu %7.1f%% %7.1f%% %7.1f%% %7.1f%% %7.1f%%
# The following table shows the basetype usage distribution in the
# set of loaded MIB modules.
%-10s Int32 Uns32 Int64 Uns64 OctSt ObjId Enums  Bits Flo32 Flo64 Flo128
%-10s %5lu %5lu %5lu %5lu %5lu %5lu %5lu %5lu %5lu %5lu %5lu
%-10s %4.1f%% %4.1f%% %4.1f%% %4.1f%% %4.1f%% %4.1f%% %4.1f%% %4.1f%% %4.1f%% %4.1f%% %4.1f%%
# The following table shows the complexity metrics of the set of loaded
# MIB modules.
# The following table shows the distribution of the number of references
# to defined types (including base types) in the set of loaded MIB
# modules.
# The following table shows the distribution of the number of references
# to externally defined types (excluding base types) in the set of loaded
# MIB modules.
# The following table shows the distribution of the number of references
# to externally defined nodes in the set of loaded MIB modules.
# The following table shows the distribution of the number of references
# to externally defined items (such as types or objects) accumulated by
# the defining MIB module in the set of loaded MIB modules.
# The following table shows the distribution of the index complexity
# in the set of loaded MIB modules.
smidump: index len overflow: %d
smidump: index complexity overflow: %d
smidump: table len overflow: %d
%-*s LANGUAGE SIZE REVISION DATE
# united module metrics [%d modules] (generated by smidump 0.4.8)
# %s module metrics (generated by smidump 0.4.8)
generate raw statistics (no percentages)
metrics characterizing MIB modules
Y@Conceptual model of: 
(generated by smidump 0.4.8)
          </attribute>
 {index}
            <string/>
            <enum val="1"/>
            <enum val="0"/>
        </composite>
    <connections>
    </connections>
      <attribute name="name">
       <string>#%s#</string>
sparses
      <attribute name="ends">
        <composite>
       <string># #</string>
       <string>#1#</string>
       <string>#0#</string>
       <string>#*#</string>
            <enum val="%d"/>
    </object>
       <real val="%.2f"/>
smi mib class
       <boolean val="false"/>
        <boolean val="true"/>
<?xml version="1.0"?>
  <diagramdata>
      <color val="#ffffff"/>
    <attribute name="paper">
         <real val="2.82"/>
         <real val="1"/>
  </diagramdata>
  <attribute name="obj_pos">
    <point val="%.2f,%.2f"/>
  <attribute name="obj_bb">
    <real val="1.7"/>
  <attribute name="text">
    <composite type="text">
      <attribute name="font">
        <real val="0.8"/>
      <attribute name="pos">
  </layer>
</diagram>
explain
        <composite type="umlattribute">
          <attribute name="name">
            <string>#%s#</string>
          <attribute name="type">
            <string>#%s%s#</string>
          <attribute name="value">
          <attribute name="visibility">
          <attribute name="abstract">
            <boolean val="false"/>
          <attribute name="class_scope">
            <boolean val="true"/>
      <attribute name="obj_pos">
        <point val="%.2f,%.2f"/>
      <attribute name="obj_bb">
       <rectangle val="%.2f,%.2f;%.2f,%.2f"/>
     <attribute name="orth_points">
       <point val="%.2f,%.2f"/>
      <connection handle="0" to="%s" connection="%d"/>
      <connection handle="1" to="%s" connection="%d"/>
    <object type="UML - Association" version="0" id="Assoc:%s:%s">
      <attribute name="orth_orient">
      <attribute name="direction">
          <attribute name="role">
          <attribute name="multiplicity">
          <attribute name="arrow">
          <attribute name="aggregate">
       <string>#0..1#</string>
    <object type="UML - Dependency" version="0" id="Depend:%s:%s">
     <attribute name="orth_orient">
    <attribute name="draw_arrow">
     <attribute name="stereotype">
    <object type="UML - Class" version="0" id="%s">
     <attribute name="obj_bb">
       <rectangle val="0.0,0.0;0.0,0.0"/>
     <attribute name="elem_corner">
     <attribute name="elem_width">
     <attribute name="elem_height">
        <string>#%s#</string>
     <attribute name="abstract">
     <attribute name="suppress_attributes">
        <boolean val="false"/>
      <attribute name="suppress_operations">
     <attribute name="visible_attributes">
     <attribute name="visible_operations">
     <attribute name="attributes">
     <attribute name="operations"/>
    <attribute name="template">
     <attribute name="templates"/>
<diagram xmlns:dia="http://www.lysator.liu.se/~alla/dia/">
    <attribute name="background">
      <composite type="paper">
        <attribute name="name">
          <string>#A4#</string>
        <attribute name="tmargin">
       <attribute name="bmargin">
       <attribute name="lmargin">
       <attribute name="rmargin">
       <attribute name="is_portrait">
         <boolean val="true"/>
      <attribute name="scaling">
      <attribute name="fitto">
  <layer name="Background" visible="true">
<object type="UML - Note" version="0" id="O0">
    <rectangle val="%.2f,%.2f;%.2f,%.2f"/>
  <attribute name="elem_corner">
  <attribute name="elem_width">
  <attribute name="elem_height">
      <attribute name="string">
        <font name="Courier"/>
      <attribute name="height">
      <attribute name="color">
        <color val="#000000"/>
      <attribute name="alignment">
         <string>#%s#</string>
--- First Phase - loading tables and scalars
explain what the algorithm does
reverse engineered conceptual model
 B"""
"reference>" :
"description" :
"format" : "%s",
"units" : "%s",
"default" : 
"%s" : 
"basetype" : "%s",
"status" : "%s",
"parent module" : {
"name" : "%s",
"type" : "%s",
"ranges" : [
"min" : "%s",
"max" : "%s"
"range" : {
"nodetype" : "namednumber",
"number" : "%s"
"access" : "%s",
"nodetype" : "%s",
"module" : "%s"
{ "%s" : {
"indexkind" : "%s",
"relatedNode" : "%s",
}, # %s
"moduleName" : "%s",
"oid" : "
"create" : "true"
"status" : "%s"
"implied" : "true"
#   smidump -f python %s
FILENAME = "%s"
MIB = {
"moduleName" : "%s",
"organization" :
"contact" :
"revisions" : (
"date" : "%s",
"identity node" : "%s",
"imports" : (
"typedefs" : {
}, # typedefs
"nodes" : {
"syntax" : {
"type" : 
"linkage" : [
}, # nodes
"notifications" : {
"objects" : {
}, # notifications
"groups" : {
"members" : {
}, # members
}, # groups
"compliances" : {
"requires" : {
}, # requires
"nodetype" : "optional",
"module" : "%s",
"refinements" : {
}, # syntax
"writesyntax" : {
}, # writesyntax
}, # refinements
}, # compliances
"nodetype" : "module",
"language" : "%s",
python
Python MIB dictionaries
# python version 1.0						DO NOT EDIT
# Generated by smidump version 0.4.8:
{"module" : "%s", "name" : "%s"},
{ "module" :"%s", "name" : "%s"},
"reference>" =>
"description" =>
"DISPLAY-HINT" => "%s",
"UNITS" => "%s",
"DEFVAL" => 
"access" => "%s",
"name" => "%s",
"type" => "%s",
"module" => "%s"
{ "module" => "%s", 
"name" => "%s" },
"%s" => {
"module" => "%s",
"%s" => 
"basetype" => "%s",
"status" => "%s",
"parent" => {
"ranges" => (
"min" => "%s",
"max" => "%s"
"range" => {
"oid" => "
"create" => "true"
"status" => "%s"
"implied" => "true"
#   smidump -f perl %s
"name" => "%s",
#    Compiler Info
"path" => "%s",
#    Module Identity
"organization" =>
"contact" =>
"revisions" => [
"date" => "%s",
"identity" => "%s",
#    Imports
"imports" => [
"names" => [
], # imports
#    Module Body
"typedefs" => {
"nodes" => [
"syntax" => {
"type" => 
"indeximplied" => "true",
"index" => [
], #index
], # nodes
"notifications" => [
"objects" => [
], # notifications
"groups" => [
"members" => [
], # members
], # groups
"compliances" => [
"requires" => [
], # requires
"type" => "optional",
"refinements" => {
"writesyntax" => {
], # compliances
  } # %s
"language" => "%s",
perl
Perl MIB dictionaries
# Perl version 5						DO NOT EDIT
# Generated by smidump 0.4.8:
{ "module" => "%s", "name" => "%s"},
auto
 *   smidump -f scli
 --scli-set
 --scli-create
 --scli-delete
 *     --scli-prefix='%s'
 *     --scli-include='%s'
 *     --scli-exclude='%s'
guint16 
gint32 
guint32 
, %s_%sLength
, %s%s
/* ?? %s */
guint32 *
guchar *
, %s->%s
, %s->_%sLength
, guint32 *%s
, guint16 _%sLength
, guchar *%s
, gint32 %s
, guint32 %s
, gint64 %s
, guint64 %s
 /* ?? */ _%s
    %s->%s = %s;
    /* ?? %s */
#define %s_%s_%-*s %d
    { 0, NULL }
    { %s_%s_%s,%*s "%s" },
 [%s]
    guint32  %s[%u];
%*s/* 
#define %s_%sLENGTH %u
#define %s_%sMINLENGTH %u
#define %s_%sMAXLENGTH %u
    guint16  _%sLength;
    guchar   %s[%u];
    gint32   %s%s;
    guint32  %s%s;
    gint64   *%s;
    guint64  *%s;
    /* ?? */  _%s; 
    guint32  *%s;
    guchar   *%s;
, %u, %u
, 0, 0};
, %ldL, %ldL
, %luUL, %luUL
GSNMP_ATTR_FLAG_WRITABLE
       %s_constraints,
       NULL,
      -1,
      %s },
GNET_SNMP_VARBIND_TYPE_OPAQUE
    guint16 i, len;
        && 
(%s->%s > %ld)
(%s->%s < %ld)
(%s->%s != %ld)
     if (
         && 
(%s->%s > %lu)
(%s->%s < %lu)
(%s->%s != %lu)
    len = %u;
    if (len < %u) return -1;
    if (len > %u) return -1;
    %s->_%sLength = len;
#define %s_%s	
#define %s_%-*s (1 << %d) 
typedef struct {
} %s_%s_t;
, gint64 mask);
#include "%s.h"
    { 0, 0, NULL }
    { 0, 0, 0, NULL }
    guint8 idx = %u;
    return idx;
    base[idx++] = %s;
    len = _%sLength;
    GList *row;
    int i;
    guint32 base[128];
%u, 
    len = pack_%s(base
    *%s = NULL;
    static guint32 base[] = {
0, 0};
void
%s_create_%s(GNetSnmp *s
    %s = %s_new_%s();
    %s->%s = &create;
void
%s_delete_%s(GNetSnmp *s
    %s_get_%s(s, &%s
    %s->%s = &destroy;
void
%s_set_%s(GNetSnmp *s
    %s_%s_t *%s;
    %s->%s = &%s;
    /* ?? */
prefix
include
exclude
restrict
break
extern
return
volatile
while
goto
sizeof
_Bool
continue
static
_Complex
inline
_Imaginary
else
register
    memcpy(%s->%s, %s, _%sLength * sizeof(guint32));
    memcpy(%s->%s, %s, _%sLength);
    memcpy(%s->%s, %s, %s_%sLENGTH);
extern GNetSnmpEnum const %s_enums_%s[];
GNetSnmpEnum const %s_enums_%s[] = {
static guint16 %s_constraints[] = {%uU, %uU
static gint32 %s_constraints[] = {%ldL, %ldL
static guint32 %s_constraints[] = {%luUL, %luUL
GNET_SNMP_VARBIND_TYPE_OBJECTID
GNET_SNMP_VARBIND_TYPE_OCTETSTRING
GNET_SNMP_VARBIND_TYPE_COUNTER64
GNET_SNMP_VARBIND_TYPE_UNSIGNED32
GNET_SNMP_VARBIND_TYPE_INTEGER32
    { %u, %s,
      %s_%s, "%s",
      G_STRUCT_OFFSET(%s_%s_t, %s),
      G_STRUCT_OFFSET(%s_%s_t, _%sLength)
GNET_SNMP_VARBIND_TYPE_COUNTER32
GNET_SNMP_VARBIND_TYPE_TIMETICKS
GNET_SNMP_VARBIND_TYPE_IPADDRESS
static inline int
unpack_%s(GNetSnmpVarBind *vb, %s_%s_t *%s)
    guint8 idx = %u;
    if (vb->oid_len > idx) return -1;
    return 0;
    if (vb->oid_len < idx) return -1;
    %s->%s = vb->oid[idx++];
(%s->%s < %ld || %s->%s > %ld)
         return -1;
    }
(%s->%s < %lu || %s->%s > %lu)
    if (vb->oid_len < idx + len) return -1;
    for (i = 0; i < len; i++) {
        %s->%s[i] = vb->oid[idx++];
    }
    if (vb->oid_len < idx) return -1;
    len = vb->oid_len - idx;
    if (vb->oid_len < idx) return -1;
    len = vb->oid[idx++];
    if (len < %u || len > %u) return -1;
    len = %u;
    if (vb->oid_len < idx + len) return -1;
    for (i = 0; i < len; i++) {
        %s->%s[i] = vb->oid[idx++];
    }
    if (vb->oid_len < idx) return -1;
    len = vb->oid[idx++];
    if (vb->oid_len < idx + len) return -1;
    /* XXX how to unpack %s->%s ? */
smidump: regular expression error: %s
#ifndef _%s_H_
#define _%s_H_
#include "gsnmp.h"
G_BEGIN_DECLS
 * Tables to map enumerations to strings and vice versa.
 * Tables to map identities to strings and vice versa.
extern GNetSnmpIdentity const %s_identities[];
 * Tables to map notifications to strings and vice versa.
extern GNetSnmpIdentity const %s_notifications[];
extern void
%s_get_%s(GNetSnmp *s, %s_%s_t ***%s, gint64 mask);
extern void
%s_free_%s(%s_%s_t **%s);
extern %s_%s_t *
%s_new_%s(void);
extern void
%s_get_%s(GNetSnmp *s, %s_%s_t **%s
extern void
%s_set_%s(GNetSnmp *s, %s_%s_t *%s, gint64 mask);
extern void
%s_free_%s(%s_%s_t *%s);
extern void
%s_create_%s(GNetSnmp *s
extern void
%s_delete_%s(GNetSnmp *s
extern void
%s_set_%s(GNetSnmp *s
G_END_DECLS
#endif /* _%s_H_ */
static guint32 const %s[]
	= { %s_%s };
GNetSnmpIdentity const %s_identities[] = {
    { %s,
      G_N_ELEMENTS(%s),
      "%s" },
GNetSnmpIdentity const %s_notifications[] = {
static guint32 const %s_oid[] = {
static GNetSnmpAttribute %s_attr[] = {
%s_%s_t *
%s_new_%s()
    %s_%s_t *%s;
    %s = (%s_%s_t *) g_malloc0(sizeof(%s_%s_t) + sizeof(gpointer));
    return %s;
    if (len != %u) return -1;
    len = _%sLength;
    base[idx++] = len;
    for (i = 0; i < len; i++) {
        base[idx++] = %s[i];
        if (idx >= 128) return -1;
    }
    /* XXX how to pack %s ? */
static inline %s_%s_t *
assign_%s(GList *vbl)
    %s_%s_t *%s;
    char *p;
    %s = %s_new_%s();
    p = (char *) %s + sizeof(%s_%s_t);
    * (GList **) p = vbl;
    if (unpack_%s((GNetSnmpVarBind *) vbl->data, %s) < 0) {
        g_warning("%%s: invalid instance identifier", "%s");
        g_free(%s);
        return NULL;
    }
    gnet_snmp_attr_assign(vbl, %s_oid, G_N_ELEMENTS(%s_oid),
                      %s_attr, %s);
    return %s;
void
%s_get_%s(GNetSnmp *s, %s_%s_t ***%s, gint64 mask)
    GList *in = NULL, *out = NULL;
    static guint32 const _base[] = {
    *%s = NULL;
    memcpy(base, _base, sizeof(_base));
    gnet_snmp_attr_get(s, &in, base, %u, %u, %s_attr, mask);
    out = gnet_snmp_sync_table(s, in);
    /* gnet_snmp_varbind_list_free(in); */
    if (out) {
        *%s = (%s_%s_t **) g_malloc0((g_list_length(out) + 1) * sizeof(%s_%s_t *));
        for (row = out, i = 0; row; row = g_list_next(row), i++) {
            (*%s)[i] = assign_%s(row->data);
        }
    }
void
%s_get_%s(GNetSnmp *s, %s_%s_t **%s
    guint32 base[128];
    gint8 len;
    memcpy(base, %s_oid, sizeof(%s_oid));
    if (len < 0) {
        g_warning("%%s: invalid index values", "%s");
        s->error_status = GNET_SNMP_PDU_ERR_INTERNAL;
        return;
    }
    gnet_snmp_attr_get(s, &in, base, len, %u, %s_attr, mask);
    out = gnet_snmp_sync_get(s, in);
    g_list_foreach(in, (GFunc) gnet_snmp_varbind_delete, NULL);
    g_list_free(in);
    if (out) {
        if (s->error_status != GNET_SNMP_PDU_ERR_NOERROR) {
            g_list_foreach(out, (GFunc) gnet_snmp_varbind_delete, NULL);
            g_list_free(out);
            return;
        }
        *%s = assign_%s(out);
    }
void
%s_set_%s(GNetSnmp *s, %s_%s_t *%s, gint64 mask)
    GList *in = NULL, *out = NULL;
    if (len < 0) {
        g_warning("%%s: invalid index values", "%s");
        s->error_status = GNET_SNMP_PDU_ERR_INTERNAL;
        return;
    }
    gnet_snmp_attr_set(s, &in, base, len, %u, %s_attr, mask, %s);
    out = gnet_snmp_sync_set(s, in);
    g_list_foreach(in, (GFunc) gnet_snmp_varbind_delete, NULL);
    g_list_free(in);
    if (out) {
        g_list_foreach(out, (GFunc) gnet_snmp_varbind_delete, NULL);
        g_list_free(out);
    }
void
%s_get_%s(GNetSnmp *s, %s_%s_t **%s, gint64 mask)
    GList *in = NULL, *out = NULL;
    static const guint32 _base[] = {
    out = gnet_snmp_sync_getnext(s, in);
    g_list_foreach(in, (GFunc) gnet_snmp_varbind_delete, NULL);
    g_list_free(in);
    if (out) {
        if (s->error_status != GNET_SNMP_PDU_ERR_NOERROR) {
            g_list_foreach(out, (GFunc) gnet_snmp_varbind_delete, NULL);
            g_list_free(out);
            return;
        }
        *%s = assign_%s(out);
    }
    gnet_snmp_attr_set(s, &in, base, %u, %u, %s_attr, mask, %s);
void
%s_free_%s(%s_%s_t *%s)
    GList *vbl;
    char *p;
    if (%s) {
        p = (char *) %s + sizeof(%s_%s_t);
        vbl = * (GList **) p;
        g_list_foreach(vbl, (GFunc) gnet_snmp_varbind_delete, NULL);
        g_list_free(vbl);
        g_free(%s);
    }
void
%s_free_%s(%s_%s_t **%s)
    int i;
    if (%s) {
        for (i = 0; %s[i]; i++) {
            %s_free_%s(%s[i]);
        }
        g_free(%s);
    }
    %s_%s_t *%s;
    gint32 create = 4; /* SNMPv2-TC::RowStatus createAndGo */
    %s_set_%s(s, %s, %s_%s);
    %s_free_%s(%s);
    %s_%s_t *%s;
    gint32 destroy = 6; /* SNMPv2-TC::RowStatus destroy */
, %s_%s);
    if (s->error_status || !%s) return;
    %s->_%sLength = _%sLength;
static inline gint8
pack_%s(guint32 *base
use prefix instead of module name in stubs
include stubs for groups matching a regex
exclude stubs for groups matching a regex
generate set stubs for writable objects
generate create stubs for tables using RowStatus
generate delete stubs for tables using RowStatus
ANSI C manager stubs for the gsnmp package
<xsd:complexType>
<xsd:sequence>
<xsd:documentation>
</xsd:documentation>
not-implemented
unknown
<xsd:annotation>
<xsd:appinfo>
<flags
 implied="yes"
 create="yes"
<maxAccess>%s</maxAccess>
<oid>
</oid>
<status>%s</status>
<default>%s</default>
</xsd:appinfo>
</xsd:annotation>
%s/%s
</xsd:sequence>
</xsd:complexType>
</xsd:element>
</xsd:element>
<xsd:key name="%sKey">
<xsd:selector 
xpath="%s"/>
</xsd:key>
<xsd:field 
xpath="@%s"/>
<xsd:keyref 
name="%sKeyRef" 
refer="%sKey">
</xsd:keyref>
<xsd:unique 
name="%sKeyRefUnique">
</xsd:unique>
<xsd:restriction base="%s">
</xsd:restriction>
<xsd:pattern value="%s"/>
<xsd:minLength value="%d"/>
<xsd:maxLength value="%d"/>
<xsd:enumeration value="%s">
<intVal>%d</intVal>
</xsd:enumeration>
<xsd:simpleType>
</xsd:simpleType>
<xsd:simpleType name="%s">
<lengths>
</lengths>
<length min="%u" max="%u"/>
<xsd:union>
</xsd:union>
<xsd:restriction>
<xsd:list>
</xsd:list>
<xsd:element name="%s">
<xsd:element name="%s"/>
      Nodekind: %#4x -->
use="required">
<augments>%s</augments>
</xsd:attribute>
%s%c
are subject to changes. -->
<xsd:schema 
targetNamespace="%s%s"
            xmlns:%s="%s%s"
<xsd:import 
</xsd:schema>
            xmlns="%s%s"
            xml:lang="en"
</xsd:annotation>
schema-url
generate a container schema
nest-augments
nest-subtables
XML schema definitions
<xsd:element name="snmp-data">
<xsd:element name="context" minOccurs="0" maxOccurs="unbounded">
<displayHint>%s</displayHint>
<xsd:attribute name="ipaddr" type="xsd:NMTOKEN" use="required"/>
<xsd:attribute name="hostname" type="xsd:NMTOKEN"/>
<xsd:attribute name="port" type="xsd:unsignedInt" use="required"/>
<xsd:attribute name="community" type="xsd:NMTOKEN" use="required"/>
<xsd:attribute name="caching" type="xsd:NMTOKEN"/>
<xsd:attribute name="time" type="xsd:dateTime" use="required"/>
<xsd:element name="%s" type="%s:%sType" minOccurs="0">
<xsd:element name="%s" type="%sType" minOccurs="0">
<xsd:element name="%s" type="%s:%sType" minOccurs="0" maxOccurs="unbounded">
<!-- Error: Unknown index type -->
<xsd:element name="%s" type="%sType" minOccurs="0" maxOccurs="unbounded">
<xsd:restriction base="%s:%s">
<xsd:restriction base="xsd:decimal">
<xsd:fractionDigits value="%d"/>
<xsd:minInclusive value="%d"/>
<xsd:maxInclusive value="%d"/>
<xsd:maxInclusive value="%d.%d"/>
<xsd:restriction base="xsd:string">
<!-- Warning: repeat in display hint. This feature is not supported. -->
<xsd:pattern value="(0|[1-9](([0-9]){0,2})).(0|[1-9](([0-9]){0,2})).(0|[1-9](([0-9]){0,2})).(0|[1-9](([0-9]){0,2}))"/>
<xsd:minInclusive value="%lu"/>
<xsd:maxInclusive value="%lu"/>
<xsd:minInclusive value="%u"/>
<xsd:maxInclusive value="%u"/>
<xsd:restriction base="xsd:NMTOKEN">
<xsd:restriction base="smi:ObjectIdentifier"/>
<xsd:minInclusive value="%d.%d"/>
<xsd:restriction base="%s:%s%s">
<xsd:restriction base="%s%s">
<xsd:element name="%s" minOccurs="0" maxOccurs="unbounded">
<xsd:element name="%s" minOccurs="0">
<xsd:element name="%s" type="%s:%s" minOccurs="0">
<xsd:element name="%s" type="%s" minOccurs="0">
<!-- Warning! Unhandled Element! No details available!
<xsd:complexType name="%sType">
<xsd:attribute name="%s" type="%s%s" use="required">
<xsd:attribute name="%s" use="required">
<xsd:attribute name="%s" type="%s:%s" use="required">
<xsd:attribute name="%s" type="%s" use="required">
<xsd:attribute name="%s" type="%s:%s" 
<xsd:attribute name="%s" type="%s" 
<!-- WARNING: files located at 
            xmlns:xsd="http://www.w3.org/2001/XMLSchema"
            xmlns:smi="%ssmi"
namespace="%s%s" schemaLocation="%s%s.xsd"/>
            elementFormDefault="qualified"
            attributeFormDefault="unqualified">
<xsd:import namespace="%ssmi" schemaLocation="%ssmi.xsd"/>
URI prefix for schema definitions and namespaces
Nest rows of augmented tables in the base tables
Nest subtables in the base tables
http://www.ibr.cs.tu-bs.de/projects/libsmi/xsd/
SnmpAdminString
install
install-notify
report-only
PIB-MIN-ACCESS
{ %s 1 }
%s OBJECT-GROUP
{ %s 2 }
ibrmibtopib
COPS-PR-SPPI
InstanceId
COPS-PR-SPPI-TC
SUBJECT-CATEGORIES
%s (%ld)%s
all } -- added by smidump
{ ibrmibtopib %d }
PIB-ACCESS
PIB-REFERENCES
TagReferenceId
PIB-TAG
INSTALL-ERRORS
PIB-INDEX
EXTENDS
-- unsupported indexing --
UNIQUENESS
InstanceId
InstanceId
END -- end of module %s.
sppi
SPPI (RFC 3159)
INET-ADDRESS-MIB
InetAddress
-- The following three items were added in order to create a RFC compliant
-- SPPI module. They do not provide any usable content.
-- %s
-- %s
-- %s
Added by smidump for automatic MIB to PIB conversion.
Added by smidump for automaticMIB to PIB conversion.
-- This SPPI module has been generated by smidump 0.4.8. Do not edit.
%s%s PIB-DEFINITIONS ::= BEGIN
%-23s %-23s 	%d	[%d..%d]
snmpTrapOID
# smidump -u -f sizes
variables
IANATn3270eTC-MIB
IANATn3270eAddress
# united module PDU sizes (generated by smidump 0.4.8)
# size of PDUs for groups and rows:
# %s module PDU sizes (generated by smidump 0.4.8)
# size of one-shot row creation PDUs including columns with default values:
# size of one-shot row creation PDUs excluding columns with default values:
# size of notification PDUs:
show detailed information the sizes of variables
RFC 3416 PDU sizes excluding message / transport headers
rgb(0%,0%,0%)
rgb(20%,20%,20%)
rgb(40%,40%,40%)
rgb(60%,60%,60%)
  <text id="%s"
 fill="%s"
 onmousemove="
ShowTooltipMZ(evt,'%s')
;colorText('%s','red')
HideTooltip(evt)
;colorText('%s',
  <text
 fill="rgb(40%%,40%%,40%%)"
 fill="rgb(60%%,60%%,60%%)"
 fill="rgb(0%%,0%%,0%%)"
 fill="rgb(20%%,20%%,20%%)"
   <tspan x="5"
  </text>
blue
   <tspan fill="%s" x="5">
&amp;mibs=%s">
</a>
   </tspan>
&amp;mibs=%s
    <tspan x="5">%s</tspan>
 fill="rgb(%i%%,%i%%,%i%%)"
>Mandatory Groups</text>
 <g id="MI%i" transform=
"translate(%.2f,%.2f)">
  <text id="group%s%s%s"
" onmouseout="
;colorText('%s','salmon')
>Group %s</text>
  <text id="object%s%s%s"
>Object %s</text>
 x="%.2f" y="%.2f">
<tspan x="%.2f"
&amp;mibs=%s">
        %s:
      </a></tspan>
>%s:</tspan>
    <tspan
>%s</tspan>
 fill="%s">
      <a xlink:href="%s
 marker-end="url(#arrowend)"
 <text text-anchor="middle">
 startOffset="10%%">
 startOffset="90%%">
       0
       1
</textPath>
       augments
       sparsly augments
       reorders
       expands
       *
       0..1
 <path id="%s-%s"
       stroke="black"
    <rect id="%s"
 rx="4" ry="4"
 onclick="ClickObj(evt)"
 onmousemove="MoveObj(evt)"
 onmouseup="OutOfObj(evt)"
 onmouseout="OutOfObj(evt)"/>
    <text x="0" y="%.2f"
         %s
  </g>
     version="1.1"
</style>
// ]]>
</script>
 <title>%s</title>
 <defs>
 fill="none" stroke="black"/>
   </marker>
 </defs>
   This module only contains
   textual conventions.
   This module doesn't
   contain any objects.
  <text>
colorText('%s','white')
  <text>1970-01-01</text>
>%s</text>
 width="100" height="16"/>
dyn. Text</text>
</svg>
width
height
show-deprecated
show deprecated items
show-depr-obsolete
static-output
SVG diagram
 <g id="MI%i" transform="translate
 onclick="setStatus(evt,'red','%s')
;changeColor(evt,'%s','red','%s')
   <tspan style="text-anchor:middle"
 onclick="collapse(evt)">--</tspan>
 onmousemove="ShowTooltipMZ(evt,'%s')
" onmouseout="HideTooltip(evt)"
  <text id="mandatorygroups%s%s"
" onclick="setStatus(evt,'salmon','%s')
;changeColor(evt,'%s','salmon','%s')
  <text fill="rgb(%i%%,%i%%,%i%%)">
    <tspan style="text-anchor:middle">-</tspan>
    <tspan style="text-anchor:middle">+</tspan>
 onmousemove="ShowTooltipMZ(evt,'%s')"
 onmouseout="HideTooltip(evt)"
 marker-start="url(#arrowstart)"
    <textPath xlink:href="#%s-%s"
    <textPath xlink:href="#%s-%s" startOffset="50%%">
       d="M %.2f %.2f %.2f %.2f"
  <g transform="translate(%.2f,%.2f)">
 x="%.2f" y="%.2f" width="%.2f" height="%.2f"
          fill="white" stroke="black"/>
    <rect x="%.2f" y="%.2f" width="16" height="16"
 stroke-width="3" stroke="gray" fill="white"
          onmousedown="ClickObj(evt)"
    <polygon points="%.2f %.2f %.2f %.2f"
          fill="none" stroke="black"/>
 style="text-anchor:middle; font-weight:bold"
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN"
  "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg preserveAspectRatio="xMinYMin meet"
     width="%i" height="%i" viewBox="%.2f %.2f %.2f %.2f"
     xmlns="http://www.w3.org/2000/svg"
     xmlns:xlink="http://www.w3.org/1999/xlink"
     onload="init(evt)" onzoom="ZoomControl()"
<style type="text/css">
<![CDATA[
text.tooltip {
    font-family: "Courier New", Courier, monospace;
<script type="text/ecmascript">
<![CDATA[
   <marker id="arrowstart" markerWidth="12"
 markerHeight="8" refX="0" refY="4" orient="auto">
     <line x1="12" y1="0" x2="0" y2="4"
     <line x1="0" y1="4" x2="12" y2="8"
   <marker id="arrowend" markerWidth="12"
 markerHeight="8" refX="12" refY="4" orient="auto">
     <line x1="0" y1="0" x2="12" y2="4"
     <line x1="12" y1="4" x2="0" y2="8"
 <rect x="10" y="10" width="150" height="40"
 fill="white" stroke="black"/>
  <text x="15" y="25" fill="black">
  <text x="15" y="40" fill="black">
 <rect x="10" y="10" width="120" height="40"
 style="text-anchor:middle; font-weight:bold">
 <g transform="translate(%.2f,%.2f) scale(%.2f)">
 <g id="MI%i" transform="translate(%.2f,%.2f)">
   <tspan x="5">Modules</tspan>
colorText('%s','blanchedalmond')
   <tspan x="5">Notifications</tspan>
   <tspan x="5">Object Groups</tspan>
   <tspan x="5">Notification Groups</tspan>
   <tspan x="5">Compliance Statements</tspan>
 <g id="tooltip" style="visibility: hidden">
   <rect id="ttr" x="0" y="0" rx="5" ry="5"
   <line id="ttl" x1="0" y1="0" x2="0" y2="0"/>
   <text class="tooltip" xml:space="preserve"
 id="ttt" x="0" y="0" style="visibility: hidden">
 x="-10" y="-10">dyn. Text</text>
       stroke-dasharray="10, 10" stroke="black"
 marker-end="url(#arrowend)"/>
 marker-start="url(#arrowstart)"/>
width of the svg output (default=1100)
height of the svg output (default=700)
show deprecated and obsolete items
disable all interactivity (e.g. for printing)
//The scripts for the tooltip and moveobj are based on work from
//SVG - Learning By Coding - http://www.datenverdrahten.de/svglbc/
//Author: Dr. Thomas Meinike 11/03 - thomas@handmadecode.de
var svgdoc,svgroot,paths,revert;
var collapsed = new Array(2);
var name = new Array(%i);
var clickStatus = new Array(%i);
var redCount = new Array(%i);
var salmonCount = new Array(%i);
var moveObj,rect,x,y,attr1,attr2,wert1,wert2,zoom=1,active=false;
function MoveObj(evt)
    if (active) {
	var roundx, roundy;
	var curtrans=svgroot.currentTranslate;
	var ctx=curtrans.x;
	var cty=curtrans.y;
	x=evt.clientX()
	y=evt.clientY()
	wert1=(x-ctx)*zoom*%.2f+%.2f+attr1-5;
	wert2=(y-cty)*zoom*%.2f+%.2f+attr2-5;
	roundx=Math.round(wert1*100)/100;
	roundy=Math.round(wert2*100)/100;
	moveObj.setAttribute("transform","translate("+roundx+","+roundy+")");
    }
function ClickObj(evt)
    rect=evt.target.parentNode.getElementsByTagName("rect").item(0);
    moveObj=evt.target.parentNode;
    attr1=rect.getAttribute("width")/2;
    attr2=rect.getAttribute("height")/2;
    active=true;
function OutOfObj(evt)
    if (active) {
	active=false;
	findAdjacentEdges();
    }
function findAdjacentEdges()
    var rectl, rectlid, i, nodenames;
    rectl = rect;
    rectlid = rectl.getAttribute("id");
    for (i=0; i<paths.length; i++) {
	nodenames = paths.item(i).getAttribute("id").split("-");
	if (nodenames[0] == rectlid || nodenames[1] == rectlid) {
	    repaintEdge(paths.item(i), nodenames, i);
    }
function repaintEdge(edge, nodenames, j)
    var startnode, endnode, attr, i, k, l, m, alpha, beta;
    var nodesx, nodesy, nodeex, nodeey, nodesw, nodesh, nodeew, nodeeh;
    var edgesx, edgesy, edgeex, edgeey, sx, sy, ex, ey;
    //extract node coordinates and dimensions
    startnode = svgdoc.getElementById(nodenames[0]);
    nodesw=startnode.getAttribute("width");
    nodesh=startnode.getAttribute("height");
    attr = startnode.parentNode.attributes;
    for (i=0;i<attr.length;i++) {
        if (attr.item(i).nodeName == "transform") {
	    k = attr.item(i).nodeValue.indexOf("(");
	    l = attr.item(i).nodeValue.indexOf(",");
	    m = attr.item(i).nodeValue.indexOf(")");
	    nodesx = parseFloat(attr.item(i).nodeValue.substring(k+1,l));
	    nodesy = parseFloat(attr.item(i).nodeValue.substring(l+1,m));
    }
    endnode = svgdoc.getElementById(nodenames[1]);
    nodeew=endnode.getAttribute("width");
    nodeeh=endnode.getAttribute("height");
    attr = endnode.parentNode.attributes;
    for (i=0;i<attr.length;i++) {
        if (attr.item(i).nodeName == "transform") {
	    k = attr.item(i).nodeValue.indexOf("(");
	    l = attr.item(i).nodeValue.indexOf(",");
	    m = attr.item(i).nodeValue.indexOf(")");
	    nodeex = parseFloat(attr.item(i).nodeValue.substring(k+1,l));
	    nodeey = parseFloat(attr.item(i).nodeValue.substring(l+1,m));
    }
    alpha = Math.atan((nodesy-nodeey)/(nodesx-nodeex));
    if (alpha < 0)
	alpha += Math.PI;
    //calculate intersection of edge and startNode
    beta = Math.atan(nodesh/nodesw);
    if (alpha < beta
	|| (alpha > Math.PI-beta && alpha < Math.PI+beta)
	|| alpha > 2*Math.PI-beta) {
	//intersection at left or right border
	if (nodesx < nodeex) {
	    edgesx = nodesx - 0 + nodesw/2;
	} else {
	    edgesx = nodesx - nodesw/2;
	if (nodesy < nodeey) {
	    edgesy = nodesy - 0 + Math.abs(nodesw*Math.tan(alpha)/2);
	} else {
	    edgesy = nodesy - Math.abs(nodesw*Math.tan(alpha)/2);
    } else {
	//intersection at top or bottom border
	if (nodesy < nodeey) {
	    edgesy = nodesy - 0 + nodesh/2;
	} else {
	    edgesy = nodesy - nodesh/2;
	if (nodesx < nodeex) {
	    edgesx = nodesx - 0 + Math.abs(nodesh/(2*Math.tan(alpha)));
	} else {
	    edgesx = nodesx - Math.abs(nodesh/(2*Math.tan(alpha)));
    }
    //calculate intersection of edge and endNode
    beta = Math.atan(nodeeh/nodeew);
    if (alpha < beta
	|| (alpha > Math.PI-beta && alpha < Math.PI+beta)
	|| alpha > 2*Math.PI-beta) {
	//intersection at left or right border
	if (nodesx > nodeex) {
	    edgeex = nodeex - 0 + nodeew/2;
	} else {
	    edgeex = nodeex - nodeew/2;
	if (nodesy > nodeey) {
	    edgeey = nodeey - 0 + Math.abs(nodeew*Math.tan(alpha)/2);
	} else {
	    edgeey = nodeey - Math.abs(nodeew*Math.tan(alpha)/2);
    } else {
	//intersection at top or bottom border
	if (nodesy > nodeey) {
	    edgeey = nodeey - 0 + nodeeh/2;
	} else {
	    edgeey = nodeey - nodeeh/2;
	if (nodesx > nodeex) {
	    edgeex = nodeex - 0 + Math.abs(nodeeh/(2*Math.tan(alpha)));
	} else {
	    edgeex = nodeex - Math.abs(nodeeh/(2*Math.tan(alpha)));
    }
    //set new edge coordinates
    sx=Math.round(edgesx*100)/100;
    ex=Math.round(edgeex*100)/100;
    sy=Math.round(edgesy*100)/100;
    ey=Math.round(edgeey*100)/100;
    if (sx < ex) {
	if (revert[j] == 1) {
	    revert[j] = 0;
	    flipEdgeMarks(edge);
	edge.setAttribute("d","M "+sx+" "+sy+" "+ex+" "+ey);
    } else {
	if (revert[j] == 0) {
	    revert[j] = 1;
	    flipEdgeMarks(edge);
	edge.setAttribute("d","M "+ex+" "+ey+" "+sx+" "+sy);
    }
function flipEdgeMarks(edge)
    var attr, i, j, done, textpaths, pathnamei, offset;
    //revert start- and end-markers
    attr = edge.attributes;
    done = 0;
    for (i=0;i<attr.length;i++) {
        if (attr.item(i).nodeName == "marker-start") {
	    for (j=i;j<attr.length;j++) {
		if (attr.item(j).nodeName == "marker-end") {
		    done = 1;
	    }
	    if (done == 0) {
		//start->end
		edge.removeAttribute("marker-start");
		edge.setAttribute("marker-end","url(#arrowend)");
		break;
	    }
        if (attr.item(i).nodeName == "marker-end") {
	    for (j=i;j<attr.length;j++) {
		if (attr.item(j).nodeName == "marker-start") {
		    done = 1;
	    }
	    if (done == 0) {
		//end->start
		edge.removeAttribute("marker-end");
		edge.setAttribute("marker-start","url(#arrowstart)");
		break;
	    }
    }
    //revert cardinalities
    textpaths = svgdoc.getElementsByTagName("textPath");
    for (i=0;i<textpaths.length;i++) {
	pathname = textpaths.item(i).getAttribute("xlink:href").replace(/#/,"");
	if (pathname == edge.getAttribute("id")) {
	    offset = textpaths.item(i).getAttribute("startOffset").substr(0,2);
	    textpaths.item(i).setAttribute("startOffset",100 - offset + "%")
    }
function getSVGDoc(load_evt)
    svgdoc=load_evt.target.ownerDocument;
    svgroot=svgdoc.documentElement;
    texte=svgdoc.getElementById("tooltip").getElementsByTagName("text");
    for (i=1; i<%i; i++) {
	textNode=texte.item(1).cloneNode("true");
	svgdoc.getElementById("tooltip").appendChild(textNode);
    }
    texte=svgdoc.getElementById("tooltip").getElementsByTagName("text");
function ShowTooltipMZ(mousemove_event,txt)
    var ttrelem,tttelem,ttline,posx,posy,curtrans,ctx,cty,txt;
    var maxbreite,tmp,i;
    ttrelem=svgdoc.getElementById("ttr");
    tttelem=svgdoc.getElementById("ttt");
    ttline=svgdoc.getElementById("ttl");
    posx=mousemove_event.clientX;
    posy=mousemove_event.clientY;
    for (i=1;i<=%i;i++)
	texte.item(i).firstChild.data="";
    tttelem.childNodes.item(0).data="";
    tmp=txt.split("\n");
    maxbreite=0;
    for (i=0;i<tmp.length;i++) {
	if (tmp[i]=="")
	    continue;
	tttelem.childNodes.item(0).data=tmp[i];
	if (maxbreite<tttelem.getComputedTextLength())
	    maxbreite=tttelem.getComputedTextLength();
    }
    curtrans=svgroot.currentTranslate;
    ctx=curtrans.x;
    cty=curtrans.y;
    ttrelem.setAttribute("x",posx-ctx+10);
    ttrelem.setAttribute("y",posy-cty-20+10);
    ttrelem.setAttribute("width",maxbreite*0.92+10);
    ttrelem.setAttribute("height",tmp.length*15+3);
    ttrelem.setAttribute("style",
			    "fill: #FFC; stroke: #000; stroke-width: 0.5px");
    for (i=1; i<=tmp.length; i++) {
	if (tmp[i-1]=="-- -- --") {
	    ttline.setAttribute("x1", posx-ctx+10);
	    ttline.setAttribute("y1", parseInt(i-1)*15+posy-cty);
	    ttline.setAttribute("x2", posx-ctx+10+maxbreite*0.92+10);
	    ttline.setAttribute("y2", parseInt(i-1)*15+posy-cty);
	    ttline.setAttribute("style", "stroke: #000; stroke-width: 0.5px");
	} else {
	    texte.item(i).firstChild.data=tmp[i-1];
	    texte.item(i).setAttribute("x",posx-ctx+15);
	    texte.item(i).setAttribute("y",parseInt(i-1)*15+posy-cty+3);
	    texte.item(i).setAttribute("style","fill: #00E; font-size: 11px");
    }
    svgdoc.getElementById("tooltip").style.setProperty("visibility","visible");
function HideTooltip()
    svgdoc.getElementById("ttl").style.setProperty("visibility","hidden");
    svgdoc.getElementById("tooltip").style.setProperty("visibility","hidden");
function ZoomControl()
    var curzoom;
    curzoom=svgroot.currentScale;
    svgdoc.getElementById("tooltip").setAttribute("transform",
							"scale("+1/curzoom+")");
    zoom=1/curzoom;
function collapse(evt)
    var i, k, l, m, svgdoc, obj, targetID, targetX, targetY, attr;
    obj = evt.getTarget();
    svgdoc = obj.ownerDocument;
    //extract coordinates and id of the clicked text
    attr = obj.parentNode.parentNode.attributes;
    for (i=0;i<attr.length;i++) {
        if (attr.item(i).nodeName == "transform") {
            k = attr.item(i).nodeValue.indexOf("(");
            l = attr.item(i).nodeValue.indexOf(",");
            m = attr.item(i).nodeValue.indexOf(")");
            targetX = attr.item(i).nodeValue.substring(k+1,l);
            targetY = attr.item(i).nodeValue.substring(l+1,m);
        }
        if (attr.item(i).nodeName == "id") {
            targetID = attr.item(i).nodeValue.substr(2);
        }
    }
    //decide if we are collapsing or uncollapsing
    if (collapsed[0][targetID] == 0) {
        hideInfos(evt, obj, svgdoc, targetX, targetY, targetID, attr);
        collapsed[0][targetID] = 1;
    } else {
        showHiddenInfos(evt, obj, svgdoc, targetX, targetY, targetID, attr);
        collapsed[0][targetID] = 0;
    }
function showHiddenInfos(evt, obj, svgdoc, targetX, targetY, targetID, attr)
    var i, k, l, m, nextObj, nextX, nextY, gapY=0, clickedID;
    //change clicked text
    obj.firstChild.data="--";
    targetID++;
    nextObj = svgdoc.getElementById("MI"+targetID);
    if (nextObj == null)
        return;
    //show child texts again
    for (;;) {
        attr = nextObj.attributes;
        for (i=0;i<attr.length;i++) {
            if (attr.item(i).nodeName == "transform") {
                k = attr.item(i).nodeValue.indexOf("(");
                l = attr.item(i).nodeValue.indexOf(",");
                m = attr.item(i).nodeValue.indexOf(")");
                nextX = attr.item(i).nodeValue.substring(k+1,l);
                nextY = attr.item(i).nodeValue.substring(l+1,m);
            }
        }
        if (nextX > targetX) {
            nextObj.style.setProperty("visibility","visible");
            gapY += 15;
            if (collapsed[0][targetID] == 1) {
                targetID = collapsed[1][targetID];
            } else {
                targetID++;
            }
            nextObj = svgdoc.getElementById("MI"+targetID);
            if (nextObj == null)
                break;
        } else {
            break;
        }
    }
    if (nextObj == null)
        return;
    //move following texts downwards
    while (nextObj != null) {
        attr = nextObj.attributes;
        for (i=0;i<attr.length;i++) {
            if (attr.item(i).nodeName == "transform") {
                k = attr.item(i).nodeValue.indexOf("(");
                l = attr.item(i).nodeValue.indexOf(",");
                m = attr.item(i).nodeValue.indexOf(")");
                nextX = attr.item(i).nodeValue.substring(k+1,l);
                nextY = attr.item(i).nodeValue.substring(l+1,m);
            }
        }
        nextY = nextY - 1 + gapY + 1;
        nextObj.setAttribute("transform","translate("+nextX+","+nextY+")");
        targetID++;
        nextObj = svgdoc.getElementById("MI"+targetID);
    }
function hideInfos(evt, obj, svgdoc, targetX, targetY, targetID, attr)
    var i, k, l, m, nextObj, nextX, nextY, gapY=0;
    clickedID = targetID;
    //change clicked text
    obj.firstChild.data="+";
    targetID++;
    nextObj = svgdoc.getElementById("MI"+targetID);
    if (nextObj == null)
        return;
    //wipe out child texts
    for (;;) {
        attr = nextObj.attributes;
        for (i=0;i<attr.length;i++) {
            if (attr.item(i).nodeName == "transform") {
                k = attr.item(i).nodeValue.indexOf("(");
                l = attr.item(i).nodeValue.indexOf(",");
                m = attr.item(i).nodeValue.indexOf(")");
                nextX = attr.item(i).nodeValue.substring(k+1,l);
                nextY = attr.item(i).nodeValue.substring(l+1,m);
            }
        }
        if (nextX > targetX) {
            nextObj.style.setProperty("visibility","hidden");
            gapY += 15;
            if (collapsed[0][targetID] == 1) {
                targetID = collapsed[1][targetID];
            } else {
                targetID++;
            }
            nextObj = svgdoc.getElementById("MI"+targetID);
            if (nextObj == null)
                break;
        } else {
            break;
        }
    }
    //save next uncollapsed element in array
    collapsed[1][clickedID] = targetID;
    if (nextObj == null)
        return;
    //move following texts upwards
    while (nextObj != null) {
        attr = nextObj.attributes;
        for (i=0;i<attr.length;i++) {
            if (attr.item(i).nodeName == "transform") {
                k = attr.item(i).nodeValue.indexOf("(");
                l = attr.item(i).nodeValue.indexOf(",");
                m = attr.item(i).nodeValue.indexOf(")");
                nextX = attr.item(i).nodeValue.substring(k+1,l);
                nextY = attr.item(i).nodeValue.substring(l+1,m);
            }
        }
        nextY -= gapY;
        nextObj.setAttribute("transform","translate("+nextX+","+nextY+")");
        targetID++;
        nextObj = svgdoc.getElementById("MI"+targetID);
    }
function init(evt)
    var nodenames, startnode, endnode, attr, i, j, k, l, m, nodesx, nodeex;
    collapsed[0] = new Array(%i);
    collapsed[1] = new Array(%i);
    for (i=0; i<%i; i++) {
        collapsed[0][i] = 0;
        collapsed[1][i] = 0;
    }
    for (i=0; i<%i; i++) {
	name[i] = "";
	clickStatus[i] = 0;
	redCount[i] = 0;
	salmonCount[i] = 0;
    }
    getSVGDoc(evt);
    //check which edges are printed from right to left
    paths = svgdoc.getElementsByTagName("path");
    revert = new Array(paths.length);
    for (j=0; j<paths.length; j++) {
	nodenames = paths.item(j).getAttribute("id").split("-");
	startnode = svgdoc.getElementById(nodenames[0]);
	attr = startnode.parentNode.attributes;
	for (i=0;i<attr.length;i++) {
	    if (attr.item(i).nodeName == "transform") {
		k = attr.item(i).nodeValue.indexOf("(");
		l = attr.item(i).nodeValue.indexOf(",");
		m = attr.item(i).nodeValue.indexOf(")");
		nodesx = parseFloat(attr.item(i).nodeValue.substring(k+1,l));
	    }
	endnode = svgdoc.getElementById(nodenames[1]);
	attr = endnode.parentNode.attributes;
	for (i=0;i<attr.length;i++) {
	    if (attr.item(i).nodeName == "transform") {
		k = attr.item(i).nodeValue.indexOf("(");
		l = attr.item(i).nodeValue.indexOf(",");
		m = attr.item(i).nodeValue.indexOf(")");
		nodeex = parseFloat(attr.item(i).nodeValue.substring(k+1,l));
	    }
	if (nodesx > nodeex) {
	    revert[j] = 1;
	} else {
	    revert[j] = 0;
    }
function setStatus(evt, color1, color2)
    var clickObj = evt.getTarget();
    var clickObjName = clickObj.getAttribute('id');
    //find i corresponding to the clicked object
    for (i=0; i<%i; i++) {
	if (name[i] == "") {
	    name[i] = clickObjName;
	    break;
	if (name[i] != clickObjName)
	    continue;
	break;
    }
    //toggle click status, color clicked object
    if (clickStatus[i] == 0) {
	clickStatus[i] = 1;
	clickObj.setAttribute("style","fill: "+color1);
    } else {
	clickStatus[i] = 0;
	clickObj.setAttribute("style","fill: "+color2);
    }
    //adjust color-counter
    if (color1 == 'red') {
	if (clickStatus[i] == 1) {
	    redCount[i]++;
	} else {
	    redCount[i]--;
    }
    if (color1 == 'salmon') {
	if (clickStatus[i] == 1) {
	    salmonCount[i]++;
	} else {
	    salmonCount[i]--;
    }
    if (clickStatus[i] == 0 && salmonCount[i] > 0) {
	clickObj.setAttribute("style","fill: salmon");
    }
function changeColor(evt, targetObjName, color1, color2)
    var clickObj = evt.getTarget();
    var clickObjName = clickObj.getAttribute('id');
    var targetObj = svgDocument.getElementById(targetObjName);
    //find i corresponding to the clicked object
    for (i=0; i<%i; i++) {
	if (name[i] != clickObjName)
	    continue;
	break;
    }
    //find j corresponding to the target object
    for (j=0; j<%i; j++) {
	if (name[j] == "") {
	    name[j] = targetObjName;
	    break;
	if (name[j] != targetObjName)
	    continue;
	break;
    }
    //adjust color-counter
    if (color1 == 'red') {
	if (clickStatus[i] == 1) {
	    redCount[j]++;
	} else {
	    redCount[j]--;
    }
    if (color1 == 'salmon') {
	if (clickStatus[i] == 1) {
	    salmonCount[j]++;
	} else {
	    salmonCount[j]--;
    }
function colorText(targetObjName, color)
    var targetObj = svgDocument.getElementById(targetObjName);
    //find i corresponding to the target object
    for (i=0; i<%i; i++) {
	if (name[i] != targetObjName)
	    continue;
	break;
    }
    //color text
    if (i == %i) {
	targetObj.setAttribute("style","fill: "+color);
	return;
    }
    if (redCount[i] == 0 && salmonCount[i] == 0) {
	targetObj.setAttribute("style","fill: "+color);
    }
    if (salmonCount[i] > 0) {
	if (color == 'red') {
	    targetObj.setAttribute("style","fill: red");
	} else {
	    if (redCount[i] > 0) {
		targetObj.setAttribute("style","fill: red");
	    } else {
		targetObj.setAttribute("style","fill: salmon");
	    }
    }
No edges!
[UNKNOWN] 
  [NAMES] 
  [TYPES] 
  [INDEX] 
[REROUTE] 
[POINTER] 
  (-:-)  
  (1:1)  
  (1:n)  
  (0:1)  
  (0:n)  
(1:0..1) 
GENERIC 
  INDEX 
AUGMENT 
 SPARSE 
 EXPAND 
REORDER 
%29s - 
No nodes!
 [TABLE]
[SCALAR]
%40s [%s]
OrZero
Scalar Groups : 
%2d - %35s
No groups!
--- Second Phase - linking the tables
--- Third Phase - reordering the connections
--- Fourth Phase -  connecting isolated nodes
--- Fifth Phase - checking for dependency relationships
--- Sixth Phase - checking for pointer relationships
  %c%c%s %-*s %-*s (%s)
  %c%c%s %-*s %s
%s%s:
compliances
# %s compliances (generated by smidump 0.4.8)
compliances with all included objects / notifications
This module does not define any management objects.  Instead, it
defines a set of textual conventions which may be used by other MIB
modules to define management objects.
Meaningful security considerations can only be written in the MIB
modules that define management objects.  This document has therefore
no impact on the security of the Internet.
# if you have any read-write and/or read-create objects, please
# describe their specific sensitivity or vulnerability.
# RFC 2669 has a very good example.
There are a number of management objects defined in this MIB module
with a MAX-ACCESS clause of read-write and/or read-create.  Such
objects may be considered sensitive or vulnerable in some network
environments.  The support for SET operations in a non-secure
environment without proper protection can have a negative effect on
network operations.  These are the tables and objects and their
sensitivity/vulnerability:
There are no management objects defined in this MIB module that have
a MAX-ACCESS clause of read-write and/or read-create.  So, if this
MIB module is implemented correctly, then there is no risk that an
intruder can alter or create any management objects of this MIB
module via direct SNMP SET operations.
# for all MIB modules you must evaluate whether any readable objects
# are sensitive or vulnerable (for instance, if they might reveal
# customer information or violate personal privacy laws such as
# those of the European Union if exposed to unathorized parties)
Some of the readable objects in this MIB module (i.e., objects with a
MAX-ACCESS other than not-accessible) may be considered sensitive or
vulnerable in some network environments.  It is thus important to
control even GET and/or NOTIFY access to these objects and possibly
to even encrypt the values of these objects when sending them over
the network via SNMP.  These are the tables and objects and their
sensitivity/vulnerability:
SNMP versions prior to SNMPv3 did not include adequate security.
Even if the network itself is secure (for example by using IPsec),
even then, there is no control as to who on the secure network is
allowed to access and GET/SET (read/change/create/delete) the objects
in this MIB module.
It is RECOMMENDED that implementers consider the security features as
provided by the SNMPv3 framework (see [RFC3410], section 8),
including full support for the SNMPv3 cryptographic mechanisms (for
authentication and privacy).
Further, deployment of SNMP versions prior to SNMPv3 is NOT
RECOMMENDED.  Instead, it is RECOMMENDED to deploy SNMPv3 and to
enable cryptographic security.  It is then a customer/operator
responsibility to ensure that the SNMP entity giving access to an
instance of this MIB module is properly configured to give access to
the objects only to those principals (users) that have legitimate
rights to indeed GET or SET (change/create/delete) them.
# united security considerations boilerplate (generated by smidump 0.4.8)
# %s security considerations boilerplate (generated by smidump 0.4.8)
generate security considerations boilerplate text
  %-*s # explain sensitivity
boilerplate
\p{IsBasicLatin}
%s{%d,%d}
(\p{IsBasicLatin})
([0-9A-Fa-f]{2})
([0-7]{3})
((0|1){8})
1d.1d.1d.1d%4d:2d
1d.1d.1d.1d/2d
(\d{1,3}.){3}\d{1,3}/\d{1,5}
1d.1d.1d.1d%4d
(\d{1,3}.){3}\d{1,3}%\d{1,10}
1d.1d.1d.1d
(\d{1,3}.){3}\d{1,3}
1d.1d.1d.1d:2d
(\d{1,3}.){3}\d{1,3}:\d{1,5}
2x:2x:2x:2x:2x:2x:2x:2x
2x:2x:2x:2x:2x:2x:2x:2x%4d
[0-9A-Fa-f]{2}
[0-9A-Fa-f]{2}:
[0-9A-Fa-f]{4}:
255a
%s)|(
255t
\p{IsBasicLatin}{0,1}
2d-1d-1d,1d.1d.1d,1a1d:1d
2d-1d-1d,1d:1d:1d.1d,1a1d:1d
4x.1x:1x:1x:1x:1x:1x.2d
%s(0|[1-9](([0-9]){0,%d}))
%s((0|[1-9](([0-9]){0,%d})
%s(%s{%d})
%s(%s
(%s){%u,%u})%s
%s(0|[1-9]([0-9]{0,%d}))
%s(0|[1-9]([0-9]{0,%d})
%s)*
%s){%u,%u}
%s%s)*%s
%s%s){%u,%u}%s
%s){0,1}
displayHint.c: Error: unknown display hint type
(\d{1,3}.){3}\d{1,3})%\d{1,10}:\d{1,5}
([\dA-Fa-f]{2}:){7}[\dA-Fa-f]{2}
([\dA-Fa-f]{2}:){7}[\dA-Fa-f]{2}%\d{1,10}
0a[2x:2x:2x:2x:2x:2x:2x:2x]0a:2d
\[([\dA-Fa-f]{2}:){7}[\dA-Fa-f]{2}\]:\d{1,5}
0a[2x:2x:2x:2x:2x:2x:2x:2x%4d]0a:2d
\[([\dA-Fa-f]{2}:){7}[\dA-Fa-f]{2}%\d{1,10}\]:\d{1,5}
\d{4}-\d{2}-\d{2},(\d{2}.){2}\d{2},\p{IsBasicLatin}\d{2}:\d{2}
\d{4}-\d{2}-\d{2},(\d{2}:){2}\d{2}(,[\+\-]\d{2}:\d{2}){0,1}
\d{4}-\d{2}-\d{2},(\d{2}:){2}\d{2},[\+\-]\d{2}:\d{2}
[0-9A-Fa-f]{8}.([0-9A-Fa-f]{2}:){5}[0-9A-Fa-f]{2}.\d{1,4}
smidump: Warning: unknown type of display-hint
%s){%u,%u})(0|[1-9](([0-9]){0,%d}))
;*3$"
smidump.debug
7zXZ
J8`e
\S//
%`>J
0eL{
Vp>C
,/18
'W-A
`T6[
3cDG
HBN;H.
'E+Sq
OJ1m(w
wUh91
nCEM
Wxx5w
.=T&
oGUT
GX{E
`6A:cEr
:4 v
sKWe
#fGyS
15S{ea
/QFu
r0#7I
kZZ&
VA{:
	Um[00
5.3DC
MDoXZb
P:/\p
[0	i
}aLDLt
-Eck$
i1~48
#s<E
S"u4
0Zc2
y'(Y
dzs&"
n)#>*
5f h
UoW^
HIe-5
cNLoQ
tMSH9
@lkit
wD$=
AP2>Q
?"%>
9+Q]k
v|BSqp!R
>3bf,
HK61
\T_2^q
3dLoi1
XI~i?
D53U
.shstrtab
.interp
.note.ABI-tag
.note.gnu.build-id
.gnu.hash
.dynsym
.dynstr
.gnu.version
.gnu.version_r
.rela.dyn
.rela.plt
.init
.text
.fini
.rodata
.eh_frame_hdr
.eh_frame
.init_array
.fini_array
.jcr
.data.rel.ro
.dynamic
.got
.data
.bss
.gnu_debuglink
.gnu_debugdata
