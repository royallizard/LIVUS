mP9A
	L	!
rUVW
)Vr8
l72%
	Gl.
E1:]
nD	BE
Z.kX
__gmon_start__
_fini
_ITM_deregisterTMCloneTable
_ITM_registerTMCloneTable
__cxa_finalize
_Jv_RegisterClasses
xdr_Ganglia_extra_data
xdr_string
xdr_Ganglia_value_types
xdr_enum
xdr_Ganglia_metadata_message
xdr_array
xdr_u_int
xdr_Ganglia_metric_id
xdr_bool
xdr_Ganglia_metadatadef
xdr_Ganglia_metadatareq
xdr_Ganglia_gmetric_ushort
xdr_u_short
xdr_Ganglia_gmetric_short
xdr_short
xdr_Ganglia_gmetric_int
xdr_int
xdr_Ganglia_gmetric_uint
xdr_Ganglia_gmetric_string
xdr_Ganglia_gmetric_float
xdr_float
xdr_Ganglia_gmetric_double
xdr_double
xdr_Ganglia_msg_formats
xdr_Ganglia_metadata_msg
xdr_Ganglia_value_msg
xdr_Ganglia_25metric
xdr_pointer
become_a_nobody
getpwnam
getuid
setgid
initgroups
setuid
err_quit
debug_msg
debug_level
stderr
__vfprintf_chk
fputc
set_debug_msg_level
get_debug_msg_level
update_pidfile
fopen
fscanf
fclose
umask
unlink
getpid
__fprintf_chk
getpgid
err_msg
__errno_location
strerror
slurpfile
read
realloc
err_ret
malloc
timediff
update_file
gettimeofday
skip_whitespace
__ctype_b_loc
skip_token
getenv
snprintf
dotconf_warning
__vsnprintf_chk
dotconf_substitute_env
memset
strlen
__strdup
strncat
dotconf_register_options
dotconf_callback
dotconf_continue_line
fgets
strcpy
dotconf_get_next_line
dotconf_get_here_document
__xstat
calloc
dotconf_invoke_command
dotconf_read_arg
dotconf_find_command
dotconf_set_command
sscanf
dotconf_free_command
dotconf_handle_command
dotconf_command_loop_until_error
dotconf_command_loop
dotconf_create
access
strncasecmp
dotconf_cleanup
dotconf_is_wild_card
dotconf_wild_card_cleanup
dotconf_find_wild_card
strncpy
dotconf_strcmp_from_back
dotconf_question_mark_match
dotconf_star_match
dotconf_handle_star
__strncpy_chk
opendir
readdir
closedir
__snprintf_chk
strstr
__strcat_chk
strcmp
__strcpy_chk
dotconf_handle_wild_card
dotconf_handle_question_mark
daemon_proc
stdout
fflush
fputs
__syslog_chk
err_quiet
ganglia_quiet_errors
err_verbose
err_sys
err_dump
abort
strtol
strchr
gexec_errno
strtod
llist_add
gexec_cluster_free
gexec_cluster
g_tcp_socket_connect
XML_ParserCreate
time
XML_SetElementHandler
XML_SetUserData
XML_GetBuffer
XML_ParseBuffer
llist_sort
XML_ParserFree
g_tcp_socket_delete
XML_GetErrorCode
XML_ErrorString
XML_GetCurrentLineNumber
datum_new
datum_free
hash_create
apr_pool_create_ex
apr_thread_rwlock_create
apr_pool_destroy
hash_get_flags
hash_set_flags
hashval
hash_keycmp
hash_insert
apr_thread_rwlock_wrlock
apr_thread_rwlock_unlock
hash_lookup
apr_thread_rwlock_rdlock
hash_delete
hash_destroy
apr_thread_rwlock_destroy
hash_walkfrom
hash_foreach
g_gethostbyname
inet_aton
gethostbyname_mutex
pthread_mutex_lock
pthread_mutex_unlock
g_gethostbyaddr
g_inetaddr_new
g_inetaddr_ref
g_inetaddr_unref
g_inetaddr_delete
g_inetaddr_get_port
g_inetaddr_set_port
g_inetaddr_is_multicast
g_inetaddr_get_interface_to
getsockname
g_inetaddr_list_interfaces
ioctl
llist_remove
llist_strncmp
llist_search
llist_print
my_inet_ntop
pthread_rdwr_init_np
pthread_mutex_init
pthread_cond_init
pthread_rdwr_rlock_np
pthread_cond_wait
pthread_rdwr_runlock_np
pthread_cond_signal
pthread_rdwr_wlock_np
pthread_rdwr_wunlock_np
pthread_cond_broadcast
g_tcp_socket_new
g_tcp_socket_server_new_interface
setsockopt
g_tcp_socket_server_new
g_tcp_socket_server_accept
__fdelt_chk
select
apr_sockaddr_info_get
apr_socket_create
apr_socket_opt_set
apr_socket_bind
apr_socket_close
apr_socket_addr_get
apr_sockaddr_vars_set
apr_sockaddr_ip_buffer_get
apr_inet_ntop
memmove
create_udp_server
create_tcp_server
apr_socket_listen
get_apr_os_socket
if_nametoindex
apr_gethostname
apr_socket_connect
create_udp_client
join_mcast
apr_os_sock_get
create_mcast_client
apr_mcast_hops
create_mcast_server
apr_strnatcasecmp
Ganglia_default_collection_groups
build_default_gmond_configuration
apr_pstrdup
apr_pstrcat
Ganglia_pool_create
libgmond_apr_lib_initialized
apr_initialize
apr_terminate
Ganglia_pool_destroy
Ganglia_gmond_config_create
cfg_tilde_expand
cfg_init
cfg_parse
cfg_parse_buf
Ganglia_udp_send_channels_create
cfg_size
apr_array_make
apr_array_push
cfg_getnsec
cfg_getstr
cfg_getint
cfg_getbool
Ganglia_udp_send_message
apr_socket_send
Ganglia_metric_create
apr_palloc
apr_table_make
Ganglia_metadata_send_real
apr_table_elts
__ctype_toupper_loc
strcasecmp
xdrmem_create
Ganglia_metadata_send
Ganglia_value_send_real
Ganglia_value_send
Ganglia_metric_send
Ganglia_metric_destroy
check_value
Ganglia_metric_set
Ganglia_metadata_add
apr_table_add
cstr_to_slope
slope_to_cstr
has_wildcard
cfg_error
strrchr
apr_temp_dir_get
apr_psprintf
apr_file_mktemp
fnmatch
cfg_include
apr_file_close
apr_file_puts
libapr-1.so.0
libdl.so.2
libnsl.so.1
libz.so.1
libpcre.so.1
libexpat.so.1
libconfuse.so.0
libpthread.so.0
libc.so.6
__cxa_atexit
__stack_chk_fail
_edata
__bss_start
_end
libganglia.so.0
GLIBC_2.3.2
GLIBC_2.0
GLIBC_2.1.3
GLIBC_2.2.3
GLIBC_2.15
GLIBC_2.4
GLIBC_2.1
GLIBC_2.3.4
GLIBC_2.3
4$t!
d$ [^_
UWVS
t$@e
d$,[^_]
UWVS
d$,[^_]
d$,[^_]
d$ [^_
[^_]
UWVS
[^_]
UWVS
[^_]
D$(v+
gfff
[^_]
UWVS
D$$1
[^_]
[^_]
d$,[^_]
d$,[^_]
UWVS
D$4e
L$L1
D$4)
+T$<
D$Le3
d$\[^_]
|$Le
D$l1
T$le3
d$|[^_]
UWVS
[^_]
d$,[^_]
d$,[^_]
UWVS
[^_]
d$,1
[^_]
UWVS
d$,[^_]
UWVS
d$,[^_]
[^_]
UWVS
D$(e
D$81
D$$th
[^_]
9L$4
9T$<
D$$<*t@<?t
UWVS
D$L1
L$Le3
d$\[^_]
UWVS
D$$e
[^_]
9L$4
T$89
[^_]
8Ou 
d$,[^_]
d$,[^_]
d$,[^_]
unre
solvf
unsp
ecif
[^_]
[^_]
[^_]
UWVS
UWVS
d$,[
d$,[
d$,[
d$,[^_]
[^_]
d$,[^_]
UWVS
t$@r
[^_]
d$,[^_]
UWVS
[^_]
UWVS
[^_]
2sW1
d$,[
UWVS
[^_]
[^_]
[^_]
d$,[^_]
9D$D
[^_]
[^_]
UWVS
L$,1
D$(f
T$,e3
d$<[^_]
1sV1
|$@e
D$,1
D$Df
T$,e3
d$0[^_
D$Df
t$@e
D$,1
L$,e3
d$0[^_
UWVS
D$<1
|$49|$
T$,s
L$<e3
d$L[^_]
UWVS
[^_]
UWVS
[^_]
UWVS
[^_]
D$,1
L$,e3
d$0[^_
D$,1
D$@f
L$,e3
d$4[_
UWVS
[^_]
t$Pe
L$,1
T$(uW
t$,e35
d$<[^_]
;D$$
|$\1
|$\e3=
d$l[^_]
T$,t@
[^_]
UWVS
D$|1
L$|e3
[^_]
UWVS
[^_]
UWVS
[^_]
d$,1
d$ [^_
UWVS
L$|1
D$ 9D$D
T$0u
L$|e3
[^_]
UWVS
D$Te
t$,1
t$,e35
d$<[^_]
UWVS
d$,[^_]
UWVS
[^_]
UWVS
|$ 1
[^_]
d$,[^_]
UWVS
[^_]
[^_]
<[t7~%<\t9<]
UWVS
D$ e
[^_]
gmon
d.tm
p.XX
XXXX
D$<u(
user '%s' does not exist
exiting. setgid %d error
exiting. setuid '%s' error
Must be root to setuid to "%s"
exiting. initgroups '%s', %d error
daemon already running: %s pid %ld
Error writing pidfile '%s' -- %s
slurpfile() open() error on file %s
slurpfile() read() error on file %s
slurpfile() read() buffer overflow on file %s
update_file() got an error from slurpfile() reading %s
$tIDC_INCLUDEPATH
%s:%ld: 
Unbalanced '{'
Unterminated here-document!
Unknown Config-Option: '%s'
%s%s%s
Include
IncludePath
[dotconf] Parse error. Unexpected end of file at line %ld in file %s
[emerg] could not stat currently read file (%s)
Missing argument to option '%s'
Error opening configuration file '%s'
Error occured while processing wildcard %c
Filename is '%s'
Cannot open %s for inclusion.
IncludePath is '%s'
Absolute filename too long (>%d)
Error occured while attempting to process %s for inclusion.
IncludePath is '%s'
: %s
CLUSTER
LOCALTIME
METRIC
cpu_num
load_one
load_five
load_fifteen
proc_run
proc_total
cpu_user
cpu_nice
cpu_system
cpu_idle
cpu_wio
gexec
Connected to socket %s:%d
Created the XML Parser
Got the XML Buffer
Read %d bytes of data
gexec_cluster() XML_ParseBuffer() error at line %d:
hash_create size = %zd
hash->size is %zd
Error initializing locks.
hash malloc error in hash_create()
hash->node malloc error. freeing hash.
hash->lock alloc error; freeing hash
lock pool failed, freeing hash.
tcp_listen() setsockopt() SO_REUSEADDR error
tcp_listen() setsockopt() SO_KEEPALIVE error
tcp_listen() setsockopt() TCP_NODELAY error
Warning: your operating system does not support IPV6_V6ONLY!
This means that you are also listening to IPv4 traffic on port %d
This IPv6=>IPv4 mapping may be a security risk.
/* Each metrics module that is referenced by gmond must be specified and
   loaded. If the module has been statically linked with gmond, it does
   not require a load path. However all dynamically loadable modules must
   include a load path. */
modules {
  module {
    name = "core_metrics"
  module {
    name = "cpu_module"
    path = "modcpu.so"
  module {
    name = "disk_module"
    path = "moddisk.so"
  module {
    name = "load_module"
    path = "modload.so"
  module {
    name = "mem_module"
    path = "modmem.so"
  module {
    name = "net_module"
    path = "modnet.so"
  module {
    name = "proc_module"
    path = "modproc.so"
  module {
    name = "sys_module"
    path = "modsys.so"
/* The old internal 2.5.x metric array has been replaced by the following
   collection_group directives.  What follows is the default behavior for
   collecting and sending metrics that is as close to 2.5.x behavior as
   possible. */
/* This collection group will cause a heartbeat (or beacon) to be sent every
   20 seconds.  In the heartbeat is the GMOND_STARTED data which expresses
   the age of the running gmond. */
collection_group {
  collect_once = yes
  time_threshold = 20
  metric {
    name = "heartbeat"
/* This collection group will send general info about this host*/
collection_group {
  collect_every = 60
  time_threshold = 60
  metric {
    name = "cpu_num"
    title = "CPU Count"
  metric {
    name = "cpu_speed"
    title = "CPU Speed"
  metric {
    name = "mem_total"
    title = "Memory Total"
  metric {
    name = "swap_total"
    title = "Swap Space Total"
  metric {
    name = "boottime"
    title = "Last Boot Time"
  metric {
    name = "machine_type"
    title = "Machine Type"
  metric {
    name = "os_name"
    title = "Operating System"
  metric {
    name = "os_release"
    title = "Operating System Release"
  metric {
    name = "location"
    title = "Location"
/* This collection group will send the status of gexecd for this host
   every 300 secs.*/
/* Unlike 2.5.x the default behavior is to report gexecd OFF. */
collection_group {
  collect_once = yes
  time_threshold = 300
  metric {
    name = "gexec"
    title = "Gexec Status"
/* This collection group will collect the CPU status info every 20 secs.
   The time threshold is set to 90 seconds.  In honesty, this
   time_threshold could be set significantly higher to reduce
   unneccessary  network chatter. */
collection_group {
  collect_every = 20
  time_threshold = 90
  /* CPU status */
  metric {
    name = "cpu_user"
    value_threshold = "1.0"
    title = "CPU User"
  metric {
    name = "cpu_system"
    value_threshold = "1.0"
    title = "CPU System"
  metric {
    name = "cpu_idle"
    value_threshold = "5.0"
    title = "CPU Idle"
  metric {
    name = "cpu_nice"
    value_threshold = "1.0"
    title = "CPU Nice"
  metric {
    name = "cpu_aidle"
    value_threshold = "5.0"
    title = "CPU aidle"
  metric {
    name = "cpu_wio"
    value_threshold = "1.0"
    title = "CPU wio"
  metric {
    name = "cpu_steal"
    value_threshold = "1.0"
    title = "CPU steal"
  /* The next two metrics are optional if you want more detail...
     ... since they are accounted for in cpu_system.
  metric {
    name = "cpu_intr"
    value_threshold = "1.0"
    title = "CPU intr"
  metric {
    name = "cpu_sintr"
    value_threshold = "1.0"
    title = "CPU sintr"
  */
collection_group {
  collect_every = 20
  time_threshold = 90
  /* Load Averages */
  metric {
    name = "load_one"
    value_threshold = "1.0"
    title = "One Minute Load Average"
  metric {
    name = "load_five"
    value_threshold = "1.0"
    title = "Five Minute Load Average"
  metric {
    name = "load_fifteen"
    value_threshold = "1.0"
    title = "Fifteen Minute Load Average"
/* This group collects the number of running and total processes */
collection_group {
  collect_every = 80
  time_threshold = 950
  metric {
    name = "proc_run"
    value_threshold = "1.0"
    title = "Total Running Processes"
  metric {
    name = "proc_total"
    value_threshold = "1.0"
    title = "Total Processes"
/* This collection group grabs the volatile memory metrics every 40 secs and
   sends them at least every 180 secs.  This time_threshold can be increased
   significantly to reduce unneeded network traffic. */
collection_group {
  collect_every = 40
  time_threshold = 180
  metric {
    name = "mem_free"
    value_threshold = "1024.0"
    title = "Free Memory"
  metric {
    name = "mem_shared"
    value_threshold = "1024.0"
    title = "Shared Memory"
  metric {
    name = "mem_buffers"
    value_threshold = "1024.0"
    title = "Memory Buffers"
  metric {
    name = "mem_cached"
    value_threshold = "1024.0"
    title = "Cached Memory"
  metric {
    name = "swap_free"
    value_threshold = "1024.0"
    title = "Free Swap Space"
collection_group {
  collect_every = 40
  time_threshold = 300
  metric {
    name = "bytes_out"
    value_threshold = 4096
    title = "Bytes Sent"
  metric {
    name = "bytes_in"
    value_threshold = 4096
    title = "Bytes Received"
  metric {
    name = "pkts_in"
    value_threshold = 256
    title = "Packets Received"
  metric {
    name = "pkts_out"
    value_threshold = 256
    title = "Packets Sent"
/* Different than 2.5.x default since the old config made no sense */
collection_group {
  collect_every = 1800
  time_threshold = 3600
  metric {
    name = "disk_total"
    value_threshold = 1.0
    title = "Total Disk Space"
collection_group {
  collect_every = 40
  time_threshold = 180
  metric {
    name = "disk_free"
    value_threshold = 1.0
    title = "Disk Space Available"
  metric {
    name = "part_max_used"
    value_threshold = 1.0
    title = "Maximum Disk Space Used"
include ("/etc/ganglia/conf.d/*.conf")
/* This configuration is as close to 2.5.x default behavior as possible
   The values closely match ./gmond/metric.h definitions in 2.5.x */
globals {
  daemonize = yes
  setuid = yes
  user = ganglia
  debug_level = 0
  max_udp_msg_len = 1472
  mute = no
  deaf = no
  allow_extra_data = yes
  host_dmax = 86400 /*secs. Expires (removes from web interface) hosts in 1 day */
  host_tmax = 20 /*secs */
  cleanup_threshold = 300 /*secs */
  gexec = no
  # By default gmond will use reverse DNS resolution when displaying your hostname
  # Uncommeting following value will override that value.
  # override_hostname = "mywebserver.domain.com"
  # If you are not using multicast this value should be set to something other than 0.
  # Otherwise if you restart aggregator gmond you will get empty graphs. 60 seconds is reasonable
  send_metadata_interval = 0 /*secs */
 * The cluster attributes specified will be used as part of the <CLUSTER>
 * tag that will wrap all hosts collected by this instance.
cluster {
  name = "unspecified"
  owner = "unspecified"
  latlong = "unspecified"
  url = "unspecified"
/* The host section describes attributes of the host, like the location */
host {
  location = "unspecified"
/* Feel free to specify as many udp_send_channels as you like.  Gmond
   used to only support having a single channel */
udp_send_channel {
  #bind_hostname = yes # Highly recommended, soon to be default.
                       # This option tells gmond to use a source address
                       # that resolves to the machine's hostname.  Without
                       # this, the metrics may appear to come from any
                       # interface and the DNS names associated with
                       # those IPs will be used to create the RRDs.
  mcast_join = 239.2.11.71
  port = 8649
  ttl = 1
/* You can specify as many udp_recv_channels as you like as well. */
udp_recv_channel {
  mcast_join = 239.2.11.71
  port = 8649
  bind = 239.2.11.71
  retry_bind = true
  # Size of the UDP buffer. If you are handling lots of metrics you really
  # should bump it up to e.g. 10MB or even higher.
  # buffer = 10485760
/* You can specify as many tcp_accept_channels as you like to share
   an xml description of the state of the cluster */
tcp_accept_channel {
  port = 8649
  # If you want to gzip XML output
  gzip_output = no
/* Channel to receive sFlow datagrams */
#udp_recv_channel {
#  port = 6343
/* Optional sFlow settings */
#sflow {
# udp_port = 6343
# accept_vm_metrics = yes
# accept_jvm_metrics = yes
# multiple_jvm_instances = no
# accept_http_metrics = yes
# multiple_http_instances = no
# accept_memcache_metrics = yes
# multiple_memcache_instances = no
Configuration file '%s' not found.
Your default configuration buffer failed to parse. Exiting.
udp_send_channel: bind and bind_hostname are mutually exclusive, both parameters can't be specified for the same udp_send_channel
Unable to join multicast channel %s:%d. Exiting
Unable to create UDP client for %s:%d. Often means there is no route to IP. Exiting.
udp_send_channel mcast_join=%s mcast_if=%s host=%s port=%d
  msg.Ganglia_metadata_msg_u.gfull.metric_id.name: %s
  msg.Ganglia_metadata_msg_u.gfull.metric_id.host: %s
wrong number of arguments to cfg_include()
unable to create a temporary file %s
failed to process include file %s
Parse error for '%s'
NULL
udp_send_channel
host
mcast_join
mcast_if
bind_hostname
SPOOF_HOST
SPOOF_HEARTBEAT
heartbeat
float
double
string
uint8
uint16
uint32
zero
positive
negative
both
derivative
unspecified
/dev/shm
%s/%s
include ('
processed include file %s
invalid include path
cluster
globals
udp_recv_channel
tcp_accept_channel
collection_group
include
modules
sflow
udp_port
accept_vm_metrics
accept_http_metrics
multiple_http_instances
accept_memcache_metrics
multiple_memcache_instances
accept_jvm_metrics
multiple_jvm_instances
module
language
enabled
params
param
value
metric
collect_once
collect_every
time_threshold
name_match
value_threshold
title
interface
timeout
family
inet4
gzip_output
retry_bind
buffer
default
allow
access
action
mask
daemonize
setuid
ganglia
debug_level
max_udp_msg_len
mute
deaf
allow_extra_data
host_dmax
host_tmax
cleanup_threshold
send_metadata_interval
module_dir
override_hostname
override_ip
tags
location
owner
latlong
;*2$"0
libganglia.so.0.0.0.debug
7zXZ
TXfn
gTxr2
9tIG%
"H*Y
8/lFF
wP\B
e8$|J
?)%6
0@:X n@
/wQj|
d`uVh('2
|r^N`
#cj.
)Y>}7
`B-Ux
.shstrtab
.note.gnu.build-id
.gnu.hash
.dynsym
.dynstr
.gnu.version
.gnu.version_r
.rel.dyn
.init
.plt
.plt.got
.text
.fini
.rodata
.eh_frame_hdr
.eh_frame
.init_array
.fini_array
.jcr
.data.rel.ro
.dynamic
.data
.bss
.gnu_debuglink
.gnu_debugdata
