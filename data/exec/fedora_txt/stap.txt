/lib64/ld-linux-x86-64.so.2
r@  
Q/qq(
lJHj
az	%
pM8$
libdw.so.1
__gmon_start__
_Jv_RegisterClasses
dwfl_module_addrdie
dwarf_func_inline_instances
dwfl_module_build_id
dwarf_linesrc
dwarf_highpc
dwarf_getsrclines
dwfl_standard_find_debuginfo
dwarf_haschildren
dwarf_getscopes_die
dwarf_onesrcline
dwfl_offline_section_address
dwarf_errmsg
dwfl_errmsg
dwfl_module_relocations
dwarf_haspc
dwarf_formsdata
dwarf_child
dwarf_attr
dwarf_decl_file
dwfl_begin
dwfl_module_relocation_info
dwfl_module_getsym
dwarf_lineaddr
dwarf_getsrc_die
dwarf_ranges
dwfl_end
dwarf_lowpc
dwarf_getsrc_file
dwarf_diename
dwarf_hasattr_integrate
dwfl_report_end
dwarf_offdie
dwfl_module_getdwarf
dwarf_getsrcfiles
dwfl_version
dwarf_filesrc
dwarf_hasattr
dwfl_report_begin
dwarf_getfuncs
dwfl_module_relocate_address
dwfl_module_info
dwarf_formref_die
dwarf_formstring
dwfl_module_getelf
dwarf_tag
dwarf_getelf
dwarf_dieoffset
dwfl_getmodules
dwarf_nextcu
dwfl_module_return_value_location
dwarf_decl_line
dwarf_attr_integrate
dwfl_report_offline
dwfl_errno
dwarf_func_inline
dwfl_addrmodule
dwarf_lineno
dwarf_formudata
dwfl_linux_kernel_find_elf
dwfl_module_getsymtab
dwarf_getscopes
dwfl_linux_kernel_report_offline
dwarf_getscopevar
dwarf_diecu
dwarf_getlocation_addr
dwarf_entrypc
dwarf_siblingof
libelf.so.1
elf_rawdata
gelf_getshdr
elf_nextscn
gelf_getehdr
elf_getshstrndx
elf_strptr
elf_getdata_rawchunk
libsqlite3.so.0
sqlite3_free_table
sqlite3_open
sqlite3_exec
sqlite3_errmsg
sqlite3_close
sqlite3_get_table
libstdc++.so.6
pthread_cancel
_ZTTSt18basic_stringstreamIcSt11char_traitsIcESaIcEE
_ZNKSt15basic_stringbufIcSt11char_traitsIcESaIcEE3strEv
_ZNSt18basic_stringstreamIcSt11char_traitsIcESaIcEED1Ev
_ZNSs4_Rep9_S_createEmmRKSaIcE
_ZTVN10__cxxabiv117__class_type_infoE
_ZSt9terminatev
_ZNKSs7compareEmmPKc
__cxa_guard_release
_ZSt4cerr
__cxa_call_unexpected
_ZSt29_Rb_tree_insert_and_rebalancebPSt18_Rb_tree_node_baseS0_RS_
_ZTVSt13runtime_error
_ZNSt8ios_base4InitD1Ev
_ZNSo9_M_insertImEERSoT_
_ZSt18_Rb_tree_incrementPSt18_Rb_tree_node_base
_ZSt18_Rb_tree_decrementPKSt18_Rb_tree_node_base
_ZNSo5tellpEv
_ZNSt13basic_filebufIcSt11char_traitsIcEE5closeEv
_ZTVSt14basic_ifstreamIcSt11char_traitsIcEE
_ZTVSt15basic_streambufIcSt11char_traitsIcEE
_ZNSi10_M_extractIlEERSiRT_
_ZNSt15basic_streambufIcSt11char_traitsIcEED2Ev
__gxx_personality_v0
_ZNSt13basic_filebufIcSt11char_traitsIcEE4openEPKcSt13_Ios_Openmode
_ZNSi10_M_extractImEERSiRT_
_ZNSt19basic_istringstreamIcSt11char_traitsIcESaIcEED1Ev
_ZNSt14basic_ofstreamIcSt11char_traitsIcEED1Ev
_ZNSo3putEc
_ZTVSt13basic_filebufIcSt11char_traitsIcEE
_ZNSt9basic_iosIcSt11char_traitsIcEE4initEPSt15basic_streambufIcS1_E
_ZNSs9_M_mutateEmmm
_ZTVN10__cxxabiv120__si_class_type_infoE
_Znwm
_ZNKSt5ctypeIcE13_M_widen_initEv
_ZStplIcSt11char_traitsIcESaIcEESbIT_T0_T1_ERKS6_S8_
_ZNSs7_M_leakEv
_ZTVSt19basic_ostringstreamIcSt11char_traitsIcESaIcEE
_ZSt3cin
__cxa_rethrow
_ZNSt12__basic_fileIcED1Ev
_ZNSs4_Rep10_M_destroyERKSaIcE
_ZNSo9_M_insertIlEERSoT_
_ZNSt9basic_iosIcSt11char_traitsIcEE5clearESt12_Ios_Iostate
__cxa_guard_abort
_ZTVN10__cxxabiv121__vmi_class_type_infoE
_ZNSs6appendEPKc
_ZNSt13runtime_errorC2ERKSs
_ZNKSs7compareEPKc
__cxa_throw
_ZNSs6assignERKSs
_ZNSs6assignEPKc
_ZNSt6localeC1Ev
_ZSt18_Rb_tree_decrementPSt18_Rb_tree_node_base
_ZNKSs5rfindEPKcmm
__cxa_pure_virtual
_ZSt4clog
_ZNSt3tr18__detail12__prime_listE
_ZNSo9_M_insertIbEERSoT_
_ZdlPv
_ZNSs4_Rep20_S_empty_rep_storageE
_ZNKSs5rfindEcm
_ZNKSs13find_first_ofEPKcmm
_ZNSolsEPFRSt8ios_baseS0_E
_ZTVSt18basic_stringstreamIcSt11char_traitsIcESaIcEE
__cxa_begin_catch
_ZTVSt14basic_ofstreamIcSt11char_traitsIcEE
_ZSt18_Rb_tree_incrementPKSt18_Rb_tree_node_base
_ZNKSt12__basic_fileIcE7is_openEv
_ZSt20__throw_length_errorPKc
_ZSt20__throw_out_of_rangePKc
_ZNSs6assignEPKcm
_ZNSt8ios_baseC2Ev
_ZNSsC1EPKcmRKSaIcE
_ZNSs6resizeEm
_ZSt19__throw_logic_errorPKc
_ZNSt15basic_stringbufIcSt11char_traitsIcESaIcEE7_M_syncEPcmm
_ZTVSt9basic_iosIcSt11char_traitsIcEE
_ZNSs9push_backEc
_ZNSs5clearEv
_ZNSirsERi
_ZNSo9_M_insertIyEERSoT_
_ZNSt13runtime_errorD1Ev
_ZSt7nothrow
_Znam
__cxa_guard_acquire
__cxa_allocate_exception
_ZNSt19basic_ostringstreamIcSt11char_traitsIcESaIcEED1Ev
_ZNSs7reserveEm
_ZNSs6resizeEmc
_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l
_ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_
_ZNSt6localeD1Ev
_ZTVSt15basic_stringbufIcSt11char_traitsIcESaIcEE
_ZTTSt19basic_istringstreamIcSt11char_traitsIcESaIcEE
_ZNSt13runtime_errorD2Ev
__dynamic_cast
_ZNSt9basic_iosIcSt11char_traitsIcEED2Ev
__cxa_end_catch
_ZTTSt14basic_ifstreamIcSt11char_traitsIcEE
_ZNKSs17find_first_not_ofEPKcmm
_ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc
_ZNSolsEPSt15basic_streambufIcSt11char_traitsIcEE
_ZNKSs7compareERKSs
_ZStlsIcSt11char_traitsIcESaIcEERSt13basic_ostreamIT_T0_ES7_RKSbIS4_S5_T1_E
_ZNKSt13runtime_error4whatEv
_ZStrsIcSt11char_traitsIcESaIcEERSt13basic_istreamIT_T0_ES7_RSbIS4_S5_T1_E
_ZNKSs6substrEmm
_ZNSt13basic_filebufIcSt11char_traitsIcEEC1Ev
_ZSt28_Rb_tree_rebalance_for_erasePSt18_Rb_tree_node_baseRS_
_ZNSt8ios_baseD2Ev
__cxa_free_exception
_ZdaPv
_ZNSsaSEc
_ZNSs6appendEmc
_ZNSs12_M_leak_hardEv
_ZNKSt3tr14hashISsEclESs
_ZNSsD1Ev
_ZNSi3getERc
_ZNSsC1ERKSsmm
_ZNSsC1EPKcRKSaIcE
_ZNSo5seekpESt4fposI11__mbstate_tE
_ZNSs7replaceEmmPKcm
_ZSt4cout
_ZStplIcSt11char_traitsIcESaIcEESbIT_T0_T1_EPKS3_RKS6_
_ZTVSt19basic_istringstreamIcSt11char_traitsIcESaIcEE
_ZSt7getlineIcSt11char_traitsIcESaIcEERSt13basic_istreamIT_T0_ES7_RSbIS4_S5_T1_ES4_
_ZNSs6appendERKSs
_ZNSo5flushEv
_ZSt16__throw_bad_castv
_ZNKSs4findEPKcmm
_ZnwmRKSt9nothrow_t
_ZNSsC1ERKSs
_ZSt17__throw_bad_allocv
_ZNSt8ios_base4InitC1Ev
_ZNSt13basic_filebufIcSt11char_traitsIcEED1Ev
_ZNKSs4findEcm
_ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_c
_ZNSt14basic_ifstreamIcSt11char_traitsIcEED1Ev
_ZdlPvRKSt9nothrow_t
_ZNSt13runtime_errorC1ERKSs
_ZNSolsEi
_ZNSt15basic_stringbufIcSt11char_traitsIcESaIcEED1Ev
_ZTISt13runtime_error
_ZNSs6appendEPKcm
_ZNSt9exceptionD2Ev
_ZTTSt14basic_ofstreamIcSt11char_traitsIcEE
_ZNSo9_M_insertIPKvEERSoT_
_ZTTSt19basic_ostringstreamIcSt11char_traitsIcESaIcEE
libm.so.6
ceilf
libgcc_s.so.1
_Unwind_Resume
libc.so.6
mkdtemp
fchmod
fnmatch
fopen
strncmp
optind
isalpha
regexec
getpwuid
__stack_chk_fail
unlink
mkdir
_exit
strpbrk
popen
getpid
kill
__assert_fail
mkstemp
isspace
strtol
isprint
fgets
strlen
__cxa_atexit
sigemptyset
isalnum
glob
__errno_location
read
memcmp
unsetenv
__fprintf_chk
sigaddset
memcpy
fclose
malloc
umask
getenv
regcomp
optarg
system
_obstack_newchunk
__snprintf_chk
getuid
fscanf
getopt_long
open_memstream
__fxstat
strtoull
__obstack_printf_chk
pclose
getcwd
gettimeofday
sigaction
rename
geteuid
__memcpy_chk
strverscmp
canonicalize_file_name
times
__cxa_finalize
__vasprintf_chk
__xstat
uname
memmove
_obstack_begin
access
strcmp
strerror
__asprintf_chk
__libc_start_main
write
globfree
basename
sysconf
ispunct
libpthread.so.0
_edata
__bss_start
_ZTV14literal_string
_ZTV20itrace_derived_probe
_ZTV11generic_dpgI18mark_derived_probeE
_ZTV26duplicate_function_remover
_ZTV21profile_derived_probe
_ZTV11probe_alias
_ZTV23alias_expansion_builder
_ZTV35delete_statement_symresolution_info
_ZTV10be_builder
__libc_csu_fini
_ZTV9indexable
_ZTV13never_builder
_ZTV5probe
_ZN6dwflpp11loc2c_errorEPvPKcz
_ZTV18tracepoint_builder
_ZTV38no_var_mutation_during_iteration_check
_ZTI11parse_error
_ZZN6dwflpp10setup_userESsbE18debuginfo_path_arr
_ZTV16logical_and_expr
_ZTV21hrtimer_derived_probe
_ZTV30tracepoint_derived_probe_group
_ZGVZN6dwflpp22iterate_over_cu_labelsESsP9Dwarf_DiePvPFvRKSsPKciS1_mP11dwarf_queryEE13function_name
_ZTV32delete_statement_operand_visitor
_ZN6dwflpp18loc2c_emit_addressEPvP7obstackm
_ZTV14itrace_builder
_ZZN6dwflpp10setup_userESsbE14debuginfo_path
_ZN14semantic_errorD1Ev
_ZTV21c_unparser_assignment
_ZTV11parse_error
_ZTV11generic_dpgI24tracepoint_derived_probeE
_ZTV13timer_builder
_ZTV11generic_dpgI25task_finder_derived_probeE
_ZTV12foreach_loop
_ZZN6dwflpp20translate_componentsEP7obstackPP8locationmRKSt6vectorISt4pairIN13target_symbol14component_typeESsESaIS9_EEP9Dwarf_DieSF_P15Dwarf_AttributeE16dwarf_error_flag
_ZTV16unary_expression
_ZTV27profile_derived_probe_group
_ZTV23c_tmpcounter_assignment
_ZTV11generic_dpgI20utrace_derived_probeE
_ZTV31functioncall_traversing_visitor
_ZZN6dwflpp12setup_kernelEbE16kernel_callbacks
_ZTV10assignment
_ZGVZN6dwflpp10setup_userESsbE17debuginfo_env_arr
_ZTV31task_finder_derived_probe_group
_ZTV21var_expanding_visitor
_ZTV12functiondecl
pending_interrupts
_ZTV6symbol
_ZTI14literal_number
_ZTV11generic_dpgI21profile_derived_probeE
_ZTI14semantic_error
_ZTV19never_derived_probe
_ZTV25varuse_collecting_visitor
_ZTV16return_statement
_ZTV18mark_derived_probe
_ZTV10base_query
_ZTV10expression
_ZTV11generic_dpgI16be_derived_probeE
_ZTV24mark_derived_probe_group
_ZZN6dwflpp12setup_kernelEbE18debuginfo_path_arr
_ZZN6dwflpp22iterate_over_cu_labelsESsP9Dwarf_DiePvPFvRKSsPKciS1_mP11dwarf_queryEE13function_name
_ZTV19typeresolution_info
_ZTV27dwarf_var_expanding_visitor
_ZTV11generic_dpgI20procfs_derived_probeE
_ZTV21derived_probe_builder
_ZSt3hexRSt8ios_base
_ZTV21perfmon_derived_probe
_ZTV21arrayindex_downcaster
_ZGVZN6dwflpp12setup_kernelEbE14debuginfo_path
_ZTV12print_format
_ZTV13derived_probe
_ZTV36delete_statement_operand_tmp_visitor
_ZTV23dead_assignment_remover
_ZTV14uprobe_builder
_ZTV20procfs_derived_probe
_ZTV26uprobe_derived_probe_group
_ZTV7stat_op
_ZTV12embeddedcode
_ZTV11generic_dpgI20itrace_derived_probeE
_ZZN6dwflpp10setup_userESsbE14user_callbacks
_ZTV7visitor
_ZTV14literal_number
_ZTV22be_derived_probe_group
_ZTV26procfs_derived_probe_group
_ZTV14expr_statement
__libc_csu_init
_ZGVZN6dwflpp12setup_kernelEbE17debuginfo_env_arr
_ZTV8array_in
_ZTV15logical_or_expr
_ZZN6dwflpp20translate_componentsEP7obstackPP8locationmRKSt6vectorISt4pairIN13target_symbol14component_typeESsESaIS9_EEP9Dwarf_DieSF_P15Dwarf_AttributeE17saved_dwarf_error
_ZZN6dwflpp20translate_componentsEP7obstackPP8locationmRKSt6vectorISt4pairIN13target_symbol14component_typeESsESaIS9_EEP9Dwarf_DieSF_P15Dwarf_AttributeE15func_call_level
_ZTV13dwarf_builder
_ZTV36delete_statement_typeresolution_info
_ZTV11generic_dpgI19timer_derived_probeE
_ZZN6dwflpp12setup_kernelEbE14debuginfo_path
_ZZN6dwflpp12setup_kernelEbE17debuginfo_env_arr
_ZTV7hist_op
_ZTV11generic_dpgI21hrtimer_derived_probeE
_ZTV16dwarf_cast_query
_ZTV12post_crement
_ZTV20uprobe_derived_probe
_ZTV19timer_derived_probe
_ZTV5block
_ZGVZN6dwflpp20translate_componentsEP7obstackPP8locationmRKSt6vectorISt4pairIN13target_symbol14component_typeESsESaIS9_EEP9Dwarf_DieSF_P15Dwarf_AttributeE17saved_dwarf_error
_ZTV20utrace_derived_probe
_ZTV22void_statement_reducer
_ZTV13concatenation
_ZGVZN6dwflpp10setup_userESsbE14debuginfo_path
_ZTV14next_statement
_ZTV17deep_copy_visitor
_ZTV6mapvar
_ZTV13target_symbol
_ZTV16delete_statement
_ZTV18traversing_visitor
_ZTV16be_derived_probe
_ZN11parse_errorD1Ev
_ZTV18symresolution_info
_ZTV10comparison
_ZTV17binary_expression
_ZTV26mark_var_expanding_visitor
_ZTV21dead_stmtexpr_remover
_ZTV6aggvar
_ZTV7vardecl
_ZTV19dwarf_derived_probe
_ZN6dwflpp32cu_inl_function_caching_callbackEP9Dwarf_DiePv
_ZTV3var
_ZTV19derived_probe_group
_ZTV28utrace_var_expanding_visitor
_ZTV25dwarf_derived_probe_group
_ZTI14literal_string
_ZTV10c_unparser
_ZTV11pre_crement
_ZTV8unparser
_ZTV12c_tmpcounter
_ZTV14utrace_builder
_ZTI5block
_ZTV32tracepoint_var_expanding_visitor
_ZTV21mutated_var_collector
_ZN6dwflpp28cu_function_caching_callbackEP9Dwarf_DiePv
_ZTV10symboldecl
_ZTV18ternary_expression
_ZTV14symbol_fetcher
_ZTV19stat_decl_collector
_ZTV8for_loop
_ZTV14update_visitor
_ZTV24tracepoint_derived_probe
_ZTV11dwarf_query
_ZTV25timer_derived_probe_group
_ZTV7cast_op
_ZTV26utrace_derived_probe_group
_ZTV12mark_builder
_ZTV11generic_dpgI20uprobe_derived_probeE
_ZTV6tmpvar
_ZTV19alias_derived_probe
_ZTV16throwing_visitor
_ZTI9statement
_ZTV18continue_statement
_ZZN6dwflpp20translate_componentsEP7obstackPP8locationmRKSt6vectorISt4pairIN13target_symbol14component_typeESsESaIS9_EEP9Dwarf_DieSF_P15Dwarf_AttributeE17dwarf_error_count
_ZTV28dwarf_cast_expanding_visitor
_ZTV26itrace_derived_probe_group
_ZZN6dwflpp10setup_userESsbE17debuginfo_env_arr
_ZTV15perfmon_builder
_ZSt3decRSt8ios_base
_ZN6dwflpp29global_alias_caching_callbackEP9Dwarf_DiePv
_ZTV27hrtimer_derived_probe_group
_ZTV9statement
_ZTV12functioncall
_ZTV15profile_builder
_ZTV15break_statement
_ZTV14procfs_builder
_ZTI7literal
_ZTV14null_statement
_ZTV29perfmon_var_expanding_visitor
_ZTV10arrayindex
_ZTV28procfs_var_expanding_visitor
_ZTV12if_statement
_ZTV16tracepoint_query
_ZTV14semantic_error
GCC_3.0
GLIBC_2.2.5
GLIBC_2.4
GLIBC_2.8
GLIBC_2.3.4
ELFUTILS_1.3
ELFUTILS_1.0
ELFUTILS_0.126
ELFUTILS_0.138
ELFUTILS_0.122
GLIBCXX_3.4.10
GLIBCXX_3.4.11
CXXABI_1.3
GLIBCXX_3.4.9
GLIBCXX_3.4
ATSubH
=7m1
ffff.
<$dH
D$(1
D$(dH3
l$ L
d$(L
l$0L
t$8L
|$@H
AWAVAUATUSH
t$,dH
D$H1
L$ H
t$ H
D$0H
\$@H
|$0H
\$8H)
tWf.
\$8H
|$0A
|$0H
D$CH
|$0H
|$0H
|$0H
AWAVAUATUH
L$0H
\$@H
D$(H
\$PH
D$8H
\$hH
\$(H
D$hH
L$X1
D$xH
\$HH
\$8H
\$`H
L$(L
T$HH
L$@H
D$8H
L$`I
T$pH
T$PH
|$pI
T$hL
|$PH
L$XH
@xH)
|$xH
T$0I
L9D$0L
|$`H
|$PH
T$hH
L$XH
\$8H
T$`I
L$PH
\$(H
T$HI
L$@H
[]A\A]A^A_
C8H+C0H
t>E1
C8H+C0A
l$0H
L$xH
|$xH
|$xI
T$ H
\$ H
D$ H
T$ L
E@I+E8H
L$ H
E@H)
\$ H
E8I+E0H
E8H)
L$hH
T$XH
L$8I
T$`H
L$pH
T$PH
L$(H
T$HH
L$@H
T$hH
L$XH
D$8H
AWAVAUATUSH
|$8H
t$XI
L$0dH
T$pH
L$0H
|$pH
|$pH
|$pH
|$pH
|$pH
L$pH
D$0H
|$pH
|$pH
t$pH
|$pH
|$pH
|$pH
T$pH
\$0H
T$01
|$0H
|$xH
D$(H
L$HH
|$8H
|$HH
|$PH
T$HH
t$PH
|$0H
|$0L
|$0L
(9l$8
L$XHc
9l$8
|$0H
L$0H9
|$0H
|$0H
T$@H
|$@H
D$ 1
|$PH
\$HH
L$`H
|$hH
H;D$8
D$PH
\$hH
\$xH
\$XH
L$8H)
t$xH
|$PH
t$PH
|$@H
L$XH
T$hH
T$HH
[]A\A]A^A_
D$(u
D$(u
|$pH
|$pH
|$pH
|$pH
t$pL
|$pf
|$pI
T$pH
|$pH
|$@H
t$@H
t$@H
|$@I
D$ H
D$HH
T$8H
t$8H
t$PH
t$HH
t$ H
D$ H
t$ H
|$@I
|$0H
t$0L
|$@H
=)x1
=wz1
|$pI
T$pH
|$pH
t$pH
|$pI
\$pL
|$pH
|$pI
\$pL
|$pH
t$pH
|$pI
T$pH
={t1
|$0H
=Kp1
|$0H
	v8E1
T$xH
|$(H
t$(I
='m1
|$(I
=}h1
l$0H
t$ H
|$ H
|$ H
l$0f
l$0H
T$@H
|$@H
t$@H
|$@H
=tf1
|$0L
6vFI
=Od1
|$@H
|$@H
L$ H
|$ H
=4c1
|$ I
|$`H
|$hL
t$`H
d$ L
l$(L
t$0H
|$ H
u H)
l$ H
l$ L
d$(L
l$0H
l$ H
l$ L
d$(L
l$0H
D$(1
u?L)
L$(dH3
0[]A\
\$(H
l$0L
d$8L
l$@L
t$HL
|$PH
AWAVAUI
ATUSH
%D^1
[]A\A]A^A_
=K]1
AWAVAUATI
[]A\A]A^A_
AWAVAUATI
[]A\A]A^A_
AWAVAUATI
[]A\A]A^A_
AWAVI
ATUSH
D$H1
d$0H
D$HdH3
X[]A\A]A^A_
l$(t
t*f.
5sY1
T$ M
|$ H
t*H9\$
ATUH
]0I9
 []A\
=[P1
=/P1
=_O1
= O1
=PN1
='N1
=WM1
fffff.
w0dH
fffff.
=YO1
ffff.
l$ L
d$(L
l$0L
t$8L
|$@H
l$ H
fffff.
AVAUATUH
[]A\A]A^A_
d$ L
l$(L
t$0H
d$ L
l$(L
t$0H
D$(1
T$(dH3
\$8H
l$@L
d$HL
l$PL
t$XL
|$`H
AVAUATUH
[]A\A]A^A_
D$(1
T$(dH3
\$8H
l$@L
d$HL
l$PL
t$XL
|$`H
l$ L
d$(L
l$0H
fff.
AWAVAUATUH
([]A\A]A^A_
=j<1
fff.
H;=T;1
\$(H
l$0L
d$8L
l$@L
t$HL
|$PH
-p71
=c61
=>61
d$ H
|$ H
\$@H
5U01
H;=^41
\$0H
\$pH
l$`H
|$`H
5Q.1
l$`I
H;=021
5Y-1
\$pH
t$`H
\$pL
l$`H
T$PH
|$XL
T$ H
t$pH
t$`H
t$ H
5|)1
=B-1
AWAVAUATI
=X*1
D$(I
D$0H
L$(H
D$ H
T$(E1
D$$H
L$PH
T$HH
T$xH
T$8H
L$ H
T$(H
Z8H)
D$pH
T$ H
|$PH
L$`H
D$HH
T$8H
D$0H
T$0H
T$@I
D$hH
L$@I
5b#1
R8H)
L$P1
T$pH
L$ H
L$HH
T$x1
\$ H
L$ H
L$ H
|$ H
L$0H
D$`H
t$ H
L$@H
T$hH
D$(H
|$ H
p8H+p0H
T$@H
L$0H
T$hH
AhL9
L$`H
|$ A
L$ H
|$XH
L$HH
T$xH
L$ H
L$PH
L$ H
L$pH
|$8A
\$0E
t$8H
\$ L
A9\$ t
D$ H
T$(A
L$0H
T$hH
AhL9
T$`I
|$PH
D$8I
T$8H
L$ I
L$pH
D$hH
T$ I
L$0I
|$PH
T$8H
T$`H
L$hI
D$@H
L$@I
D$@H
|$8H
\$ L
A9\$ 
t$8H
T$(L
T$(L
l$(H
L$(H
D$(H
[]A\A]A^A_
t$ H
t$ H
/ttH
D$(H
|$(H
T$(@
T$(@
D$(H
|$8H
|$(H
t$8H
|$8H
|$8H
|$8H
|$8H
|$8H
|$8H
|$8H
|$8H
|$8H
|$8H
|$8H
|$8H
|$8H
|$8H
|$8H
|$8H
|$8H
|$8H
|$8H
|$8H
|$8H
|$8H
|$8H
|$(H
|$ H
|$ H
L$ H
L$ H
L$HH
T$8H
L$ H
|$8H
=S	1
|$ H
T$8H
L$ H
AUATUSH
T$HH
t$7H
D$PH
T$XH
T$pH
D$8H
T$@H
D$`I
d$7L
\$ H
[]A\A]A^A_
T$(L
T$(H
T$(H
T$ H
t$xH;
T$xH
T$ H
T$ H
L$xH
T$pH
|$pH
D$ L9
T$8H
t$xH;
T$xH
T$xD
T$ H
T$8H
D$ L9
t$PH
t$XH
D$(H
|$pH
D$(u
D$(u
D$(u
D$(f
t$`H
t$hH
\$ H
l$(L
d$0H
H;=l
H;=c
\$ H
l$(L
d$0H
\$ H
l$(L
d$0H
D$(1
T$'H
H;=Z
T$&H
T$(dH3
\$0H
l$8L
d$@H
D$(1
T$&H
T$(dH3
\$8H
l$@L
d$HL
l$PH
T$'H
ATUH
D$(1
T$'H
T$&H
T$(dH3
0[]A\
D$(1
T$'H
"t(H
T$&H
T$(dH3
\$0H
l$8L
d$@L
l$HL
t$PH
fffff.
D$h1
|$ L
l$@H
l$0L
|$0H
|$@H
|$PH
|$ H
t$ L
T$hdH3
\$xH
D$(1
t	9X
T$(dH3
\$8H
l$@L
d$HL
l$PH
D$(1
t	9X
T$(dH3
\$8H
l$@L
d$HL
l$PH
AWAVAUATI
H;=,
D$XL
t$0H
D$PH
l$`H
|$`H
D$XH
[]A\A]A^A_
|$X1
|$X1
l$XL
D$XH
T$PH
H=?B
D$XH
|$0H
\$pH
\$@H
\$ H
AWAVAUATUSH
T$HL
T$ H
D$(H
u H;u(H
T$ H
[]A\A]A^A_
|$HH
|$HH
t$HH
D$ H
T$(H
t$ H
t$HH
D$`H
T$ H
D$xH
T$PH
T$XH
D$(H
T$0H
D$hH
T$pH
D$@H
u@H;uH
T$ H
T$PH
T$XH
|$(H
t$(H
|$0L
t$0H
u@H;uH
T$pH
T$hH
U8H9U@H
|$HH
|$HH
|$HH
D$0H
D$(H
T$ H
T$@H
wpI;wxH
T$(H
|$ H
t$ H
T$8H
|$HH
T$HH
t$HH
T$`H
T$xH
D$PH
T$ H
D$XH
T$(H
D$0H
T$hH
D$pH
T$@H
u@H;uH
T$PH
|$ H
t$ H
T$XH
|$(H
t$(H
|$0L
t$0H
u@H;uH
T$hH
T$pH
t$HH
|$HH
|$HH
|$hI
|$(I
|$ I
|$pI
|$HH
T$HH
D$(1
T$(dH3
\$0H
l$8L
d$@H
T$'H
T$&H
H;=A
l$ L
d$(L
l$0L
t$8L
|$@H
fff.
l$ L
d$(L
l$0H
D$ L
l$ L
d$(L
l$0H
AVAUATI
[]A\A]A^
AVAUATI
[]A\A]A^
fffff.
AVAUATI
[]A\A]A^
AVAUATI
[]A\A]A^
fffff.
AVAUATI
[]A\A]A^
AWAVAUATUH
D$H1
t$8H
H;t$
l$0H
T$GH
|$0H
l$ H
T$FH
|$ H
T$HdH3
X[]A\A]A^A_
AVAUATI
[]A\A]A^
AVAUATI
[]A\A]A^
AVAUATI
[]A\A]A^
AVAUATI
[]A\A]A^
AVAUATI
[]A\A]A^
\$ H
l$(L
d$0L
l$8L
t$@H
d$ L
l$(L
t$0H
|$ M
D$ H
fffff.
\$(H
l$0L
d$8L
l$@H
D$(1
T$'H
T$&H
H;=|
T$(dH3
\$8H
l$@L
d$HL
l$PH
AVAUI
ATUSH
D$X1
\$@H
T$WH
t$ H
D$8H
T$SH
l$8L
\$0H
T$VH
l$ H
T$UH
|$ H
H;="
T$TH
T$XdH3
`[]A\A]A^
D$X1
d$@H
T$WH
|$@L
T$VH
D$SL
t$0E1
T$8H
|$0H
w(H;w0
D$8H
\$ H
T$UH
|$ H
T$XdH3
\$hH
l$pL
d$xL
D$(1
T$(dH3
\$8H
l$@L
d$HL
l$PH
t$'H
T$hL
|$ M
H;s 
D$hH
l$PH
|$PH
l$@H
\$0H
5p~0
\$pH
t$ H
|$ H
\$`H
5(z0
\$(H
l$0L
d$8L
l$@H
fffff.
D$81
l$ H
T$7H
|$ H
H;u H
T$8dH3
\$HH
l$PL
d$XL
l$`L
t$hL
|$pH
=,y0
AVAUATI
l$pH
|$pH
l$`H
|$`H
H;=3w0
l$PH
|$PH
=cu0
D$H1
l$0H
\$@H
|$HH
w(H;w0H
l$HH
I;t$
D$HH
[]A\A]A^
\$ H
l$HH
T$HL
=Ko0
AVAUATUH
T$ H
D$@H
\$pH
t$(H;t$0
D$(H
D$(H
T$@H9T$H
t$@H
t$ H
EPI;w
|$ H
|$@H
[]A\A]A^A_
t$HH;t$Pt01
D$HH
D$H1
t$HH;t$P
D$HH
D$H1
t$(H;t$0t21
D$(H
D$(1
5"d0
t$ H
T$`L
|$ H
|$@H
AWAVAUATI
= f0
D$@L
\$pI
l$HH
|$pH
t$`A
D$(H
T$ H
D$0H
T$8H
D$HH
T$hH
D$XH
T$PL
|$`H
5r_0
T$(H
t$ L
upH;uxH
t$8A
T$ H
t$0L
[]A\A]A^A_
T$PH
=p^0
=qa0
D$81
l$ H
T$7H
|$ H
T$6H
="]0
T$5H
=J\0
T$8dH3
D$(L
\$HH
l$PL
d$XL
l$`H
D$X1
l$@H
T$WH
|$@H
l$0H
T$VH
|$0H
H;=#Z0
=rY0
l$ H
T$UH
T$TH
D$ H
T$SH
T$XdH3
D$(L
\$hH
l$pL
d$xL
D$81
l$ H
T$7H
|$ H
5>P0
T$6H
H;=CT0
T$5H
H;=}S0
T$8dH3
\$HH
l$PL
d$XL
l$`H
l$ H
l$ H
\$ H
l$(L
d$0L
l$8L
t$@H
D$(1
T$'H
5/H0
T$(dH3
\$0H
l$8L
d$@H
H+3H
4$H)
\$(H
l$0L
d$8L
l$@H
H+3H
4$H)
\$(H
l$0L
d$8L
l$@H
\$(H
l$0L
d$8L
l$@L
t$HL
|$PH
\$(H
l$0L
d$8L
l$@L
t$HL
|$PH
\$(H
l$0L
d$8L
l$@L
t$HL
|$PH
\$(H
l$0L
d$8L
l$@L
t$HL
|$PH
\$(H
l$0L
d$8L
l$@L
t$HL
|$PH
\$(H
l$0L
d$8L
l$@L
t$HL
|$PH
\$(H
l$0L
d$8L
l$@L
t$HL
|$PH
\$(H
l$0L
d$8L
l$@L
t$HL
|$PH
\$(H
l$0L
d$8L
l$@L
t$HL
|$PH
\$(H
l$0L
d$8L
l$@L
t$HL
|$PH
,)L)
\$(H
l$0L
d$8L
l$@L
t$HL
|$PH
\$(H
l$0L
d$8L
l$@L
t$HL
|$PH
\$(H
l$0L
d$8L
l$@L
t$HL
|$PH
AWAVAUI
ATUSH
[]A\A]A^A_
AWAVI
AUATUSH
D$(1
fffffff
D$'A
T$(dH3
8[]A\A]A^A_
H9T$
(H9T$
=8-0
H;l$
=w+0
=K+0
l$ H
AWAVI
ATUSH
D$H1
d$0H
D$0I
|$8H
D$HdH3
X[]A\A]A^A_
D$ H
l$(t
|$(H
D$ M
|$ H
=p'0
="'0
t+H9\$
|$(H
H;=3&0
5[!0
\$(H
l$0L
d$8L
l$@H
u^H)
AWAVAUATUSH
\$@H
d$@H
D$@H
l$PH
D$PH
D$@H
D$PH
D$XH
d$ H
T$?H
|$ H
H;=e 0
t$0H
D$0H
T$@H
T$PH
l$PH
d$@H
[]A\A]A^A_
t$=H
l$PH
d$@H
d$@H
AWAVAUATUSH
L$ H
D$(I
T$(H
l$pL
|$pH
l$`H
|$`H
H;=^
l$PH
d$0H
l$PH
D$0L
|$0H
|$pH
|$PH
D$pH
D$pA
|$pH
[]A\A]A^A_
d$@H
l$PH
D$@L
|$@H
H;=F
l$PH
|$pH
T$(H
T$ L
fff.
fff.
fff.
fff.
fff.
fff.
fff.
fff.
fff.
fff.
fff.
fff.
fff.
fff.
fff.
fff.
fff.
fff.
fff.
fff.
fffff.
fffff.
t"I90u
[]A\
fff.
fffff.
fffff.
fffff.
l$ L
~ dH
fffff.
~ dH
fffff.
~ dH
fffff.
l$ L
l$ L
fffff.
l$ L
l$ L
fffff.
l$ L
~XdH
fffff.
V dH
F(H)
[]A\
fff.
VhdH
FpH)
[]A\
[]A\
~ dH
fffff.
fffff.
fff.
l$ H
fffff.
l$ H
fff.
l$ H
fff.
l$ H
fff.
fffff.
l$ H
fffff.
d$ H
fff.
d$ L
l$(L
t$0H
l$ H
fffff.
l$ H
fffff.
AVAUATUH
H9p s
H;p scL
H9w w
uHH;H wVL
[]A\A]A^
c L;k8t
d$ H
fffff.
\$(H
l$0H
\$(H
l$0H
;stkH
<fto<dt[<ltG
fff.
t$ H
[]A\A]
ATUH
C(H+C H
C(H)
t>E1
C(H)
[]A\A]
C(H+C H
\$(H
[]A\A]
\$(H
[]A\A]
AWAVAUATI
GxH+GpH
CxH+CpH
[]A\A]A^A_
fff.
ATUH
[]A\A]A
[]A\A]
l$ H
AVAUI
L$@I
T$8H
T$8I
L$@H
T$8I
[]A\A]A^
fffff.
AWAVAUATUH
C(H)
[]A\A]A^A_
AWAVAUATUH
C(H)
[]A\A]A^A_
AWAVAUATUH
C0H+C(H
[]A\A]A^A_
C0L)
[]A\A]A^A_
X dH
](dH
d$ H
{@uaH
d$ L
C0H+C(H
d$ H
fffff.
l$ H
E(H+E H
c0H)
k(u(H
d$ L
l$(L
t$0H
l$ H
V dH
F(H)
T$ H
D$(H)
[]A\A]
fffff.
l$ H
t$ H
d$ H
d$ H
fff.
d$ H
fff.
d$ H
fff.
d$ H
fff.
d$ H
fff.
l$ H
d$ H
l$ H
d$ H
l$ H
d$ H
d$ H
l$ H
d$ H
l$ H
fffff.
l$ H
fffff.
l$ H
fffff.
l$ H
l$ H
l$ H
l$ H
l$ H
l$ H
l$ H
fffff.
d$ H
AWAVAUATUH
C(H)
{hu@H
[]A\A]A^A_A
{PH;{0
H;{XH
ChtUH
d$ H
l$ H
tCH;
f(t6H
\$ H
l$(L
d$0H
fffff.
E(H+E E1
c0H)
l$ L
d$(L
l$0L
t$8L
|$@H
VhdH
FpH)
T$hH
D$pH)
}PI;}0
I;}XI
EhtZH
[]A\A]
AUATUH
EpH)
EXH+EPH
EXH+EPH
E(H)
E@H)
[]A\A]
AVAUI
[]A\A]A^
AVAUI
ATUSH
{PH;{0
H;{XH
ChtGH
4$H)
[]A\A]A^
c H)
d$ L
l$(L
t$0H
AUATI
[]A\A]
[]A\A]
fff.
ATUH
{PH;{0
H;{XH
{PH;{0
H;{XH
{PH;{0
H;{XH
[]A\
}(E1
fffff.
{PH;{0
H;{XH
{PH;{0
H;{XH
[]A\
} E1
fffff.
l$ L
d$(L
l$0H
l$ L
d$(L
l$0H
d$ L
l$(L
t$0H
<$t+H
l$ H
l$ H
l$ H
l$ H
H;s tC1
H;s tC1
AWAVAUI
ATUSH
D$(1
E0I+E(H
fffffff
EpI+Eh1
]pH)
D$(dH3
[]A\A]A^A_
H;l$
AVAUATUSH
D$(1
G@I+G81
D$(dH3
[]A\A]A^A_
H;l$
fffff.
AVAUATUSH
D$(1
G@I+G81
D$(dH3
[]A\A]A^A_
H;l$
fffff.
H;=S
fffff.
H;='
fffff.
AWAVAUATI
D$hH
D$hH
\$(H
D$hH
[]A\A]A^A_
fffff.
AWAVI
AUATUSH
d$ H
D$xH
D$ H
D$ H
|$@H
D$ H
D$xH
D$(H
.I;n
(I;n
(I;n
|$PH
D$ H
D$xH
|$@H
|$XH
D$ H
[]A\A]A^A_
D$ H
D$ H
ATUH
 []A\f
M(Hc
AVAUATUH
d$%H
D$(1
D$%(
-Px/
D$%)
D$%[
D$%]
D$(dH3
0[]A\A]A^
=Kv/
AWAVI
ATUSH
D$h1
D$0H
D$0H
D$0H
D$(E
D$0H
D$0H
D$0H
l$@H
T$fH
|$@H
H;=xq/
D$0H
D$(	
|$0H
H;=6o/
T$hdH3
x[]A\A]A^A_
l$PH
T$gH
|$0H
\$ H
l$(L
d$0H
fff.
AWAVI
AUATUSH
k4D9
{@u@H
[]A\A]A^A_A
AWAVAUI
ATUH
E H)
[]A\A]A^A_
R H)
B H+B
[]A\A]
D$81
t$ H
t$0H
T$7H
|$ H
D$8dH3
\$HH
l$PL
d$XL
l$`L
t$hL
|$pH
=_e/
D$81
t$ H
t$0H
T$7H
|$ H
D$8dH3
\$HH
l$PL
d$XL
l$`L
t$hL
|$pH
=;c/
l$ L
d$(L
l$0H
fffff.
l$ L
d$(L
l$0H
fffff.
D$(1
D$(dH3
\$8H
l$@L
d$HL
l$PH
T$'H
T$&H
=S^/
}PH;}0
H;}XH
EhtdH
\$ H
l$(L
d$0H
v0dH
D$0I
D$ H)
D$ H)
[]A\A]
fffff.
E H+E
e I)
d$ L
l$(L
t$0H
AVAUATUH
{PH;{0
H;{XH
ChtOH
{PH;{0
H;{XH
ChtRH
[]A\A]A^
d$ L
l$(L
t$0H
F H)
|$0H
 []A\
fff.
tUH9
t|H;
\$(H
l$0L
d$8L
l$@H
t7H;
ATUH
 []A\
fff.
AUATUH
t$ H
D$(1
|$ H
D$(dH3
8[]A\A]
ATUH
D$(1
ChH;Cpt]I
L;cpt*H
ChL9
D$(dH3
0[]A\
H;=vP/
=gO/
D$H1
L$8H
L$ H
T$HdH3
\$PH
l$XL
d$`H
ATUH
[]A\
ATUH
[]A\
l$HI
\$(H
[]A\
[]A\
{PH;{0
H;{XH
ChtLH
l$ H
D$ L
l$ L
d$(L
l$0L
t$8L
|$@H
R H9
D$ L
l$ L
d$(L
l$0L
t$8L
|$@H
R H9
D$(1
H9U w
H9P rI
L$(dH3
0[]A\
H9P s
D$X1
V I9
$sxH
$H9P H
T$XdH3
\$`H
l$hL
d$pH
H9w 
P I9
$H9B s
AWAVAUATM
D$81
t)L9
N I9M s
L$8dH3
|$(L
d$ L
H[]A\A]A^A_
G0H9GPuBH
w0dH
w0dH
w0dH
G0H9GPuBH
G0H9GPuVH
ATUSH
[]A\A]A^
{PH;{0
H;{XH
ChtLH
{PH;{0
H;{XH
ChtMH
{PH;{0
H;{XH
ChtLH
{PH;{0
H;{XH
ChtLH
{PH;{0
H;{XH
ChtLH
W@dH
dH34%(
l$ L
d$(L
l$0L
t$8L
|$@H
v[L)
SHL)
G0H9GPuVH
\$(H
l$0L
d$8L
l$@L
t$HL
|$PH
_8dH
l$8H
D$0H
|$ H
[]A\
|$8H
=t$/
_8dH
l$8H
D$0H
H;=t$/
|$ H
[]A\
|$8H
D$`H
l$@I
\$8H
l$8H
|$ H
[]A\
|$8H
D$`H
l$@I
\$8H
l$8H
|$ H
[]A\
|$8H
H;=E
AUATI
D$`L
l$0I
\$(H9
l$(H
D$ H
[]A\A]
|$(H
AUATI
D$`L
l$0I
\$(H9
l$(H
D$ H
[]A\A]
|$(H
H;=s
H;=#
H;=3
H;=K
AWAVAUATUSH
o8dH
[]A\A]A^A_
H;=C
H;=c
AWAVAUATI
D$X1
l$ H
D$ I
|$ I
D$(A
D$,A
D$0A
D$4A
D$8A
|$@H
D$XdH3
h[]A\A]A^A_
<?L9
fffffff
fffffff
t8H9\$
H;=#
AWAVAUATUSH
\$@H
t$(dH
d$@H
D$@H
l$PH
D$PH
l$ H
D$@H
D$PH
D$XH
T$(H
d$0H
T$?H
|$0H
H;=#
D$@H
D$PH
T$ H
l$PH
d$@H
[]A\A]A^A_
T$ H
l$PH
d$@H
T$ H
l$PH
H;=C
H;=S
H;=S
} u1H
|$pH
d$ H
|$pH
fffff.
fffff.
fff.
l$ H
l$ H
fff.
fff.
AUATI
|$0H
[]A\A]A
[]A\A]
l$ H
l$ H
D$(1
D$(dH3
\$8H
l$@L
d$HL
l$PL
t$XL
|$`H
\$ H
l$(L
d$0H
D$81
|$0H
D$8dH3
AUATUH
D$H1
L9B s
L9B 
L9H s
t	L;F H
T$ L
D$ H
H9N s
t	L;F H
H9N s
S8H;V H
D$HdH3
X[]A\A]
L9@ s
t	L9@ H
T$0H
D$0H
D$(1
T$&H
T$(dH3
\$0H
l$8L
d$@H
T$'H
fffff.
w(dH
v8H)
SHH)
d$ L
l$(L
t$0H
l$0I
T$GH
D$H1
d$(A
|$ H
D$HdH3
\$XH
l$`L
d$hL
l$pH
fffff.
D$81
D$0H
D$(H
|$ H
l$0H
T$8dH3
ffffff.
fffff.
wPdH
H;wXt9H
<$t>H
AVAUATUH
w(dH
[]A\A]A^A_
H(M)
IXH)
@XH)
t%H9J
H9J H
AUATUH
[]A\A]
d$ L
fffff.
ATUH
D$(1
F H)
D$(dH3
0[]A\f
S H+S
s H+s
T$'H
fffff.
\$(H
l$0L
d$8L
l$@H
l$ H
d$(L
l$0L
AUATUSH
D$H1
D$0H
d$0H
T$0H9j
D$ L
t$ H
D$G 
D$HdH3
X[]A\A]A^A_
fff.
~#H9
fff.
AWAVAUI
ATUH
D$x1
l$`H
T$wH
t$PL
D$XA
D$XL
\$@L
D$8H
D$@H
D$ uVL;e
T$xdH3
[]A\A]A^A_
fffff.
\$(H
l$0H
u,H)
u=H)
u,H)
l$ H
d$(L
l$0L
AVAUATUSH
T$?H
D$0H
t$@H
D$ 1
D$PH
[]A\A]A^A_
 []A\
|$ H
fffff.
 []A\
|$ H
AWAVI
ATUSH
o dH
D$(1
D$ M)
H(H+H H
L;B H
D$ H
L$(dH3
8[]A\A]A^A_
P(H+P 
T$ H
D$ H
AUATUH
[]A\A]
d$ L
k(H+k I
AWAVAUATUSH
T$hH
L$pH
L$HH
D$ H
L$8H
|$(H
T$0H
t$`H
L$PH
L;|$ H
L$XH
L$@L
|$8H
|$8H
H9D$
H9P s
H;D$HH
t	H9P I
|$pH
T$xH
L9\$
L;|$ 
L$(H
L$ I
H9D$ 
t$ H
D$(H
T$(H
L$pH
l$(1
[]A\A]A^A_
L9T$
t$0H
T$PH
|$hH
|$PH
t$0H
T$XH
|$hH
|$XH
T$@L
|$0H
T$@L
|$PH
|$XH
AWAVI
AUATI
([]A\A]A^A_
AWAVAUI
ATUSH
[]A\A]A^A_
KPM)
r L;F
KhH)
SHH;sp
D$pH
t$pI
T$`I
d$PI
l$ L
l$0H
D$ H
d$ H
d$ H
d$ H
fff.
~ dH
l$ H
l$ H
l$ H
d$ H
d$ H
fff.
|$ H
d$ H
|$ H
d$ H
d$ H
AWAVAUATUH
D$0H
D$hH
D$pH
T$ H
D$(H
D$`I
\$(H
H;X v
H;X spL
t$`H
|$8H
D$0t
[]A\A]A^A_
47t,1
T$ H
ATUH
~@dH
{PH;{0
H;{XH
e@tSH
[]A\
H+C H
fff.
d$ H
D$CH
H+C H
D$ I
D$(I
d$ L
l$(L
t$0H
=U~.
H+C H
AUATI
D$(I
[]A\A]
H+C H
AWAVAUI
ATUH
H;s L
H;s L
([]A\A]A^A_
=Ey.
D$CH
H+E H
AUATI
D$(H
D$8H
D$@H
D$pH
D$xH
CxE1
[]A\A]
=9v.
H+C H
AUATI
D$(I
[]A\A]
H+C H
{PH;{0
H;{XH
e(tuH
D$(H
D$8H
D$@H
D$`H
D$pH
D$xH
H+C H
=io.
~@dH
{PH;{0
H;{XH
d$ H
H+C H
~(dH
{PH;{0
H;{XH
d$ H
H+C H
ATUH
{PH;{0
H;{XH
{PH;{0
H;{XH
[]A\
} E1
H+C H
AUATE1
{PH;{0
H;{XH
{PH;{0
H;{XH
e tQH
[]A\A]
D$ H
H+C H
=de.
AWAVAUATUH
T$$H
t$(dH
T$hH
t$hH
t$hH
L$hH
L$@H
L$XH
L$`H
L$HH
L$PH
L$xH
H;Y v
H9L$
H;Y rvH
H;Y v
H;Y s#D
T$$E
H;^ v
H94$t
H;^ 
L$0H
uPI;uX
T$0H
=|_.
T$pH)
L$hH
D$XH
D$hH
T$HH
L$pH
T$PH
D$xH
L$XH9
L$XE1
L$0H
L$`H
H;Y v
H9L$
H;Y 
H;Y v
H;Y s#D
D$$E
b0L;b8u;
L;b8t
t$@H
|$XH
|$XH
|$8H
|$`H
t$`H
|$HH
T$8H
t$HH
t$PH
t$@H
|$xH
T$xH
|$8A
|$8H
H;^ v
H94$t
H;^ 
L$8H
uXI;u`J
|$0J
T$8H
e M;e(u2
M;e(t'M
M;e(u
e8M;e@u7
M;e@t'M
M;e@u
t$HH
|$pH
|$pH
|$@H
|$xH
t$xH
|$PH
T$@H
t$PH
t$`H
t$HH
|$@A
|$@H
|$PH
|$`H
|$@H
L$PH
D$0H
T$8H
D$@H
T$XH
L$`H
D$xH
H;X v
H9D$
taH;X r[H
H;X v
H;X s
H;Z v
H;Z 
T$pH
T$xI
L$(L
T$pH
|$PH
|$0L
|$0H
|$8H
t$8H
|$@L
t$@L
|$@H
|$XH
T$XH
|$`H
t$`L
|$8H
|$HH
|$PH
[]A\A]A^A_
fffff.
AVAUATI
{PH;{0
H;{XH
|$(I
{PH;{0
H;{XH
H;h v
tbH;h r\H
[]A\A]A^
D$(I
D$8H
D$@H
D$`H
D$pH
D$xH
=fI.
D$(H
H+C H
AWAVAUI
ATUSH
l$PH
l$XL
H;l$`H
l$XH
l$XH
|$PH)
T$(H
T$@H
T$pH
T$0H
T$(H
T$HH
D$ H
FxH)
D$ H
D$8H)
D$<H)
[]A\A]A^A_
5FA.
|$PH
|$PH
|$@H
|$@H
t$@L
t$HH
t$0H
T$ H
|$0H
AVAUATUH
D$0H
T$0H
T$`H
D$pL
T$xH)
D$0I
D$ H
^0I9
H;|$`
^ tO
|$ I
t$ H
D$ H
H9D$
^ I9
H;|$`
H9D$
D$0H
D$`H9
|$8H
D$0t
[]A\A]A^A_
|$(I
t$(H
|$ H
t$ H
D$0H
|$ H
AWAVAUATI
D$HH
D$PH
[]A\A]A^A_
l$pH
|$PH;|$0
H;|$XH
D$PM
T$0H
H9T$PH
D$hH
T$hH
D$XH
D$PH
AWAVAUATI
|$ H+
T$0H
D$@L
T$HH)
l$xI
d$pH
|$PH;|$0
H;|$XH
D$htSH
D$PM
s H)
D$hH
T$hH
D$XH
D$PH
|$PH;|$0
H;|$XH
D$htCH
D$PM
D$hH
T$hH
D$XH
D$PH
D$0H9D$P
[]A\A]A^A_
AVAUATUH
|$ H
T$@H
D$PL
T$XH)
-q%.
|$`H;|$@
H;|$hH
D$`H
D$@H9D$`
[]A\A]A^
D$xH
T$xH
D$hH
D$`H
fffff.
AVAUATI
D$(1
D$(dH3
8[]A\A]A^A_
FpH+FhH
D$pI+D$hH
D$ H
T$hH
D$pA
T$hH
\$ H
H;u H
I+G H
fffff.
{PH;{0
H;{XL
l$ L
d$(L
l$0H
H+C H
AVAUATI
F(H+F H
D$ H
T$XH
D$ H
T$`H
D$8H
D$pH
T$(I+T$ H
T$ H
D$(A
T$ H
H;u H
[]A\A]A^A_
I+G H
H+G H
l$`H
|$PH
d$@L
t$@H
t$0H
|$PH
|$PH
T$_H
AWAVAUATI
|$0H
D$HH
H;\$
\$PH
|$<E
|$pI
|$XH
[]A\A]A^A_
t	D9
fffff.
v(dH
fff.
AVAUATUH
l$p1
|$ H+
T$0H
D$@L
T$HH)
|$PH;|$0
H;|$XH
D$PH
D$0H9D$P
] ubH
[]A\A]A^
D$hH
T$hH
D$XH
D$PH
|$pH
l$PL
t$PI
t$@I
l$ H
|$pH
l$`H
|$pH
o8dH
d$ H
l$ H
l$ H
WxdH
ATUH
[]A\
WxdH
WxdH
\$(H
l$0L
d$8L
l$@L
t$HL
|$PH
R0H)
t!A9
fffff.
AWAVAUATI
n8dH
R(H)
D$xH
dH34%(
([]A\A]A^A_
[]A\A]A^A_
C H)
\$(H
l$0L
d$8L
l$@L
t$HL
|$PH
P0H)
t!A9
AWAVI
AUATUSH
D$X1
D$XdH3
h[]A\A]A^A_
v0E1
H;|$ 
FpE1
CpH+ChH
l$0H
T$VH
l$@H
T$WH
fffff.
AUATUH
D$x1
|$PH;|$0
H;|$XH
D$PH
D$0H9D$P
D$xdH3
] u_H
[]A\A]
D$hH
T$hH
D$XH
D$PH
AVAUATUSH
D$H1
D$@1
D$ H
{PH;{0
H;{XH
t$(H
t$(H;t$0
D$(H
D$(I
T$ H
D$(H)
T$ H
|$ H
|$ H
D$HdH3
X[]A\A]A^A_
t$ I
H+C H
H+C H
|$ H
|$ H
l$ H
AWAVAUATUSH
D$LE
|$0H
T$(H
L$ H
T$0H
T$PH
t$hL
9\$LI
T$LH
T$ H
L$ H
D$0H
T$8H
T$LI
D$LL
L$ L
T$(A
T$LH
L$ L
t$`H
[]A\A]A^A_
D$8H+D$@H
L$ H
T$LH
L$0H
T$0H
D$0L
t$ L
L;$$u
t$LH
D$ H
L$0L
t$ L
L;$$u
t$LH
D$8H
D$0L
t$ L
L9$$u
t$LH
t$(H
T$ H
T$8L
D$LH
L$ H
T$(H
t$`H
|$ H
AVAUATUSH
L$ H)
L$@H
L$`H
L$pH
L$PH
L$@H
L$hH
L$XH
L$HL
L$8H
u	A9
T$8L
[]A\A]A^A_
|$`I
|$`H
t$hH
t$PH
T$XH
|$HH
t$HH
|$HH
|$PI
AWAVAUI
ATSH
[A\A]A^A_
L;` v
L;` 
L;` v
L;` 
@XM)
B0H+B(H
H;sxI
T$ I
H;r H
spH;sxH
H;p 
I;v H
L$0I
T$ I
T$ H
spH;sxH
t$ I;t$(I
spH;sxL
H;q I
H;sxI
AVAUATUSH
t$P1
D$@H
D$(H
D$ H
D$HH
D$0H
|$XH
D$Pt
D$PI
T$0H
|$8H
T$@H
|$(H
t$(H
t$ L
|$HH
[]A\A]A^A_
|$ H
|$ I
AWAVAUATUH
D$hH
D$0H
D$HH
D$pH
D$XH
D$ H
D$`L
VXH)
L$0I
H;D$0H
VpH)
|$8L
T$8H
|$HH
|$8H
~@M)
D$(D
{PH;{0
H;{XH
ChtWH
MhH)
t$ H
D$(D
D$xH
T$x1
T$(D
{PH;{0
H;{XH
Cht_H
M H)
t$ H
t$ H
D$(D
L$8H)
D$(D
L$PH)
T$`H
D$Du"H
[]A\A]A^A_
|$8H
T$(H
D$ H
D$0H
T$8H
D$HL;|$ 
D$ H
t$0H
H;Z v
t	H;Z H
T$HL
T$8L
|$0L
H9\$ u
H9\$ u
T$0H
D$8H
T$PH
D$ I
T$(L)
d$0I
D$HH
L9d$0L
t$ H
T$HH
|$ H
t$ L
|$XH
|$ L
fffff.
AVAUATUH
|$ H
T$@H
D$PL
T$XH)
|$`H;|$@
H;|$hH
D$`H
D$@H9D$`
[]A\A]A^
D$xH
T$xH
D$hH
D$`H
ATUH
[]A\
ATUH
[]A\
[]A\
AUATUH
([]A\A]
l$ H
[]A\
r0H9
D$ I
D$(L
l$ L
d$(L
l$0L
t$8L
|$@H
R H9
D$ I
D$(L
l$ L
d$(L
l$0L
t$8L
|$@H
R H9
D$(1
H9U w
H9P rI
L$(dH3
0[]A\
H9P s
D$X1
V I9
$sxH
$H9P H
T$XdH3
\$`H
l$hL
d$pH
H9w 
P I9
$H9B s
D$(1
H9U w
H9P rI
L$(dH3
0[]A\
H9P s
D$X1
V I9
$sxH
$H9P H
T$XdH3
\$`H
l$hL
d$pH
H9w 
P I9
$H9B s
G0H9GPuVH
{PH;{0
H;{XH
ChtLH
\$(H
l$0L
d$8L
l$@H
D$X1
T$ H
D$0H
{ H+T$
H+D$8H
D$HH+D$(H
t$ H
L$0H+L$8H
D$(H)
L$HL)
D$XdH3
`[]A\
5_{-
5zz-
l$ H
\$ H
l$(L
d$0H
w0dH
w0dH
l$ H
\$(H
l$0L
d$8L
l$@L
t$HL
|$PH
\$ H
l$(L
d$0H
~(dH
$t H
s8H;s@tL1
H+3H
4$H)
\$(H
l$0L
d$8L
l$@H
\$(H
l$0L
d$8L
l$@L
t$HL
|$PH
,)L)
\$(H
l$0L
d$8L
l$@L
t$HL
|$PH
d$ L
l$(L
t$0H
C0H9CPuUH
G0H9GPuBH
G0H9GPuVH
C0H9CPuBH
C0H9CPuUH
C0H9CPuBH
d$ L
l$(L
t$0H
u H)
D$(1
u?L)
L$(dH3
0[]A\
D$H1
T$HdH3
\$XH
l$`L
d$hL
l$pH
H9] 
 t(H
d$ L
l$(L
t$0H
u H)
D$(1
u?L)
L$(dH3
0[]A\
D$H1
T$HdH3
\$XH
l$`L
d$hL
l$pH
H9] 
D$(1
ulH)
T$(dH3
0[]A\
~ dH
uiH)
}Rf.
~ SH
d$ L
l$(L
t$0H
u H)
D$(1
u?L)
L$(dH3
0[]A\
D$H1
T$HdH3
\$XH
l$`L
d$hL
l$pH
H9] 
AWAVAUATUSH
D$h1
I9M s
U H9P8
D$PL
t$ L
d$`1
H;P v
H;P 
|$0H
D$ H
D$hdH3
x[]A\A]A^A_
AWAVI
AUATI
D$h1
t$8I
L$0H
D$PL
|$ H
l$`H
|$ L
D$ H
D$0H
L$0I
D$hdH3
x[]A\A]A^A_
W`dH
H+G H
W`dH
H+G H
W`dH
H+G H
W`dH
H+G H
W`dH
H+G H
W`dH
H+G H
W`dH
H+G H
W`dH
H+G H
W`dH
H+G H
ATUSH
d$pH
|$ H+
T$0H
D$@L
T$HH)
%A?-
|$PH;|$0
H;|$XH
D$PH
T$0H9T$PI
[]A\A]
D$hH
T$hH
D$XH
D$PH
v(dH
AWAVAUATUSH
D$h1
S(H)
D$hdH3
x[]A\A]A^A_
S(H+S H
B(D9
L9j0
d$`H
l$PL
\$ H
l$0H
D$ H
H;B8
H;B@
AVAUATI
t$PH
|$PH
D$XH)
|$PH
D$PH
d$pH
\$ L
D$ H
[]A\A]A^A_
T$ H
t$ H
|$PH
fffff.
=97-
ffff.
fff.
\$(H
l$0H
([]f
AUATI
[]A\A]
fffff.
oPdH
oPt+
[]A\
[]A\
fffff.
AVAUATI
I+D$
I+D$
T$h1
D$`H
T$HH
T$XH
D$@H
D$PH
D$ H
T$(H
D$0H
T$8H
D$pH
[]A\A]A^
T$0H
D$0H
[]A\A]
ffff.
D$81
D$0H
D$ H
H9\$0tHH
T$8dH3
\$@H
l$HL
d$PH
fff.
D$81
|$0H
D$8dH3
D$X1
|$0H
D$8H
D$XdH3
D$X1
|$0H
D$@H
D$XdH3
D$X1
|$0H
D$8H
D$XdH3
\$ H
l$(L
d$0H
\$ H
l$(L
d$0H
\$ H
l$(L
d$0H
\$ H
l$(L
d$0H
\$ H
l$(L
d$0H
fffff.
\$ H
l$(L
d$0H
fffff.
\$ H
l$(L
d$0H
fffff.
D$(1
T$'H
T$&H
D$(dH3
\$0H
l$8L
d$@H
fffff.
ATUH
D$81
T$5H
T$6H
d$ H
T$7H
D$8dH3
@[]A\
\$ H
l$(L
d$0H
ATUH
D$(1
H8H)
H93u
H;3u
T$'H
T$(dH3
0[]A\
H@H)
H;3u
H(H)
H;3u
fffff.
5PZ	
\$(H
l$0L
d$8L
l$@H
fff.
l$ H
l$ H
l$ H
d$ H
d$ H
5AU	
\$(H
l$0L
d$8L
l$@H
ffff.
ATUH
[]A\
D$(1
T$'H
D$(dH3
0[]A\
D$(1
T$'H
D$(dH3
0[]A\
AWAVAUATUSH
D$X1
D$ H
D$0H
D$(H
C0H+C(
|$0H
|$8L
l$HH
\$ L
|$0M
>|RH
>|6H
A;j8|
l$8H
|$0M
L$(H
|$0H
T$XdH3
h[]A\A]A^A_
@8;D$H
L$(H
|$0H
AWAVAUATUSH
|$ H
D$x1
D$8H
l$8L
t$PH
D$pH9l$
D$`H
t$pH
t$PH
E(H)
5c|	
5^|	
5D|	
5!|	
E(H+E H
H9l$
t$0L
D$xdH3
[]A\A]A^A_
5c{	
t$`H
t$PH
E(H)
5|z	
5Yz	
E(H+E H
5:z	
t$0L
ATUSH
5Ty	
5/z	
5!y	
([]A\A]
5)x	
fff.
ATUH
[]A\
5iw	
52w	
fff.
D$h1
d$PH
T$gH
5Qv	
D$hdH3
\$pH
l$xL
D$h1
d$PH
T$gH
D$hdH3
\$pH
l$xL
l$0I
T$GH
D$H1
d$(H
|$ H
D$HdH3
\$XH
l$`L
d$hL
l$pH
D$(L
[]A\
AWAVAUATUH
W(dH
D$81
5:p	
L$(f
H;X v
H9D$
H;X A
H;X v
H9D$
H;X A
H;X v
H9D$(
H;X 
5Ms	
D$ L
t$ H
D9t$
5Gm	
T$8dH3
D$8dH3
H[]A\A]A^A_
5il	
L$8dH3
[]A\A]A^A_
\$(H
l$0L
d$8L
l$@L
t$HL
|$PH
\$(H
l$0L
d$8L
l$@L
t$HL
|$PH
AVAUATUH
T$81
E0H+E(H
cHH)
L$8dH3
H[]A\A]A^A_
l$ H
T$7H
5[h	
50`	
V(dH
D$X1
B0H+B(H
d$@H
T$WH
58c	
D$0H
|$0H
D$XdH3
\$`H
l$hL
d$pH
5P^	
D$(1
T$'H
5Nz	
5)n	
D$(dH3
\$0H
l$8L
d$@L
l$HL
t$PH
fffff.
5C2	
5\d	
s(A;F
l$pH
5	c	
d$`H
|$PH
|$0H
d$(I
t$8H
|$0H
|$ H
V(dH
T$0H
5%]	
|$8H
|$0H
T$0H
5gT	
d$`H
T$0H
5z[	
5SW	
T$0H
57S	
|$0H
5FV	
=q?	
fffff.
fffff.
5G&	
5^S	
5)T	
5bc	
5_l	
t$0H
D$ H
D$(H
D$8I
t$@H
5X#	
D$pA
D$xA
D$|I
D$pH
5&O	
5pJ	
t$@L
5GN	
5<N	
\$ I
D$ A
D$(A
D$,I
D$0I
D$8I
D$@I
T$`H
5.V	
5SJ	
=QI	
5qD	
5RD	
l$@H
T$OH
l$PH
l$PH
D$PH
D$PI
D$XH
D$0H
T$ H
l$0I
D$PI
l$PH
l$PH
l$PH
AVAUATUSH
5+\	
5A\	
5_\	
5XA	
5RA	
5NA	
T$ H
D$8H
T$0H
T$@H
D$pH
T$HH
D$xH
T$XH
D$hH
T$`H
L$01
T$@H
T$8H
5|>	
5S;	
|$ H
T$xH
t$`H
|$HH
D$ I
H9D$ I
L9l$ 
D$ I
H9D$ H
t$hI
t$hH
T$0I
D$8H)
T$0I
D$8A
|$ H
5a9	
t$hH
D$0H
T$@H
T$8H
t$(H
L$8H
D$(H
H9T$(H
L$ H
L$PH
D$HH
T$(H
|$8L
5i7	
T$8I
D$@H)
|$ H
T$8I
D$@A
T$ I
D$(H)
T$ I
D$(A
|$hH
t$HH
5g5	
t$0H
5^5	
D$(H
H9T$(
[]A\A]A^A_
|$PH
T$pH
t$XH
|$HH
L$ H
L$PH
|$hL
T$hH
t$PH
|$HH
|$hH
|$hH
|$XH
|$PH
|$@H
|$ H
|$8H
D$0H
T$@H
T$8H
|$`H
D$0H
T$@H
T$8H
fffff.
AWAVI
AUATUSH
5}6	
d$`L
D$8H
D$(H
D$0H
D$pH
D$PH
D$@H
L;h v
H9D$
L;h @
L;h v
H9D$
L;h 
L;h v
H9D$8
L;h 
T$0H
5c+	
5-+	
|$ L
t$@H
5)&	
|$(L
5+*	
[]A\A]A^A_
|$ H
fffff.
D$(1
5o(	
T$(dH3
\$8H
l$@L
d$HL
l$PH
T$'H
vHdH
 []A\
\$(H
l$0L
d$8L
l$@H
5{.	
t$\I
AVAUATUSH
D$@H
T$pH
T$ H
t$`H
\$PL
5iZ	
l$0H
[]A\A]A^A_
D$pH
T$pH
T$ H
|$ H
D$(H
D$(H
D$(H
D$(L
D$(L
D$(H
D$(L
D$(H
D$(L
fffff.
\$ H
l$(L
d$0H
fff.
d$ H
51&	
t$`H
l$pH
l$PH
58[	
D$X1
t$0H
T$VH
l$ H
T$UH
D$@L
T$SH
5Kv	
T$TH
|$01
D$XdH3
\$hH
l$pL
d$xL
\$@H
T$WH
fffff.
W8dH
D$X1
l$ H
T$WH
d$0H
D$XdH3
\$`H
l$hL
d$pL
l$xL
d$0H
d$@L
d$0H
T$VH
5{$	
T$UH
AVAUATUH
g(dH
|$0L
B0H+B(H
l$PH
5qR	
[]A\A]A^
fffff.
5]'	
5T		
5I		
5bd	
AVAUATUSH
t$ H
T$ H
D$@H
T$(H
T$@H
|$P1
D$PL
|$PL
t$XI
D$xH
D$HH
D$8H
H9l$
T$8H
t$xH
D$(H
T$@I
[]A\A]A^A_
=q|,
l$`E
9\$`w
t$xH
D$HH
5rs,
D$(H
T$@H
D$(H
T$@I
AWAVAUATUSH
\$(I
l$0H
D$XH
[]A\A]A^A_
5P<	
5{		
5HF	
AWAVAUATUH
s8dH
D$8H
T$(H
T$8H
D$ H
t$hH
D$ H
T$ H
H9D$
=*],
D$(H
T$8I
[]A\A]A^A_
T$ H
H9D$
t$hH
T$@H
D$xH
D$@H
E8H)
F0H+F(H
F0H+F(H
|$0H
D$ L
T$ H
D$ L
t$pH
|$HH
D$ H
D$ H
5\N,
D$(H
T$8H
|$0H
AWAVAUATM
|$HH
t$xH
|$HH
H9D$xH
t$tH
D$0H
T$8L
D$PH
T$ H
D$hH
9D$@
D$(t
|$XH
5'-	
|$(H
|$HH
H+\$x
D$`H
|$H1
D$`H+D$xH
;X v
;X H
T$hH
|$8H
|$ H
H;N v
t	H;N H
T$(H
|$XH
[]A\A]A^A_
|$HH
T$`H
H;\$`
D$PI
l$81
D$hH
D$0H
T$ H
D$(I
;Z v
;Z H
|$8H
|$hH
T$0H
;X v
;X I
T$ H
D$(H
|$8H
|$@I
H9E s(H
u L+
t$XH
|$HL
t$xH
t$`H
9\$t
t$tH
|$XH
t$XI
|$0H
H+\$x
|$hH
|$ H
|$Hf
|$HH
AVAUATUSH
P I9
D$(H
D$HH
D$ H
D$0H
D$8H
D$PH
D$Pt
B0H+B(H
T$HH
|$ H
|$(H
T$(H
|$8H
T$8H
|$0H
t$0H
|$ H
T$@H
T$(H
|$8H
D$8H
D$(H
D$ H
[]A\A]A^A_
t"L;
t$0H
|$ H
T$(H
|$ H
|$8L
D$(H
|$0H
D$(u
D$(L
D$(f
|$ H
D$(H
AWAVAUATL
E@H)
B0H+B(H
l$PE1
B0H+B(H
|$0H
|$0H
[]A\A]A^A_
AWAVAUATUSH
$t!1
D$ H
|$(H
E0H+E(H
|$ H
5ey	
5-y	
x$Ic
D$8H
D$HH
D$@H
D$ H
D$PH
D$(H
|$(1
D$Pt
B0H+B(H
T$HH
|$8H
T$8H
|$ H
T$ H
|$@H
t$@H
t$0L
T$8H
|$ H
[]A\A]A^A_
|$@f
AWAVI
AUATUSH
oLdH
D$ H
D$ H
D$@L
D$@L
|$pH
d$`H
l$PH
T$ H
T$0L
D$0H
t$`H
t$pH
t$`H
[]A\A]A^A_
|$(I
AWAVAUATUH
n8dH
D$h1
E(H)
T$ 1
t$,L
D$hdH3
x[]A\A]A^A_
fff.
AWAVAUI
ATUSH
~ dH
B0H+B(H
D$0I
t$<L
B0H+B(H
|$(H
|$ H
[]A\A]A^A_
AWAVAUATUH
T$hH
t$pdH
D$x1
D$pH
E0H)
T$ 1
t$,L
D$xdH3
[]A\A]A^A_
fffff.
AWAVI
AUATUSH
T$pH
t$xdH
D$xH
E0H)
E0H)
[]A\A]A^A_
l$`H
AWAVAUATUH
T$0H
B0H+B(H
T$ H
D$(H
|$(H
T$(A
B0H+B(H
t$ H
|$8I
|$0I
[]A\A]A^A_
FpH)
l$@H
l$@H
t$LH
fffff.
AWAVAUATI
|$(H
|$8H
l$0H
t$<H
|$@H
[]A\A]A^A_
@0H)
@0H)
|$ I
|$(I
AWAVAUATUH
[]A\A]A^A_
E H+E
@0H)
D$01
t$<L
@0H)
d$PD
|$@I
|$0H
|$@H
|$0H
|$0H
ATUH
D$H1
|$@H
|$0H
D$HdH3
P[]A\
|$0H
fff.
AWAVAUI
ATUSH
F0H)
D$`1
t$lL
F0H)
[]A\A]A^A_
AVAUATUH
l$PL
t$\H
|$@I
|$0H
[]A\A]A^
T$0H
|$0H
fffff.
AWAVAUATUH
f8dH
|$8M
T$(H
F(I+T$ H+F H
T$81
T$`1
T$@H
T$0H
T$HH
T$@H
T$PH
T$ H
T$@H
T$PH
|$ H
t$ H
D$pH
D$xH
t$8L
D$ H
t$8H
|$0L
t$0H
|$0L
|$ H
l$HH
T$@H
T$ H
T$PH
T$XH
T$0H
|$0H
D$ H
t$PH
|$ H
t$ L
L$HL
L$@H
T$0H
\$(H)
T$ H
T$XH
|$0H
|$0H
t$PH
D$81
T$81
t$PH
T$81
[]A\A]A^A_
D$81
D$8L
D$8L
D$8u
D$8L
D$8t
D$8H
D$8f
D$8L
D$8H
|$ H
D$8L
D$8f
D$8I
|$@H
D$8I
D$`H
D$8f
|$0H
fffff.
AWAVAUATI
B0H)
U H)
D$P1
D$8H
D$@H
D$8H
D$HH
D$ H
D$(H
D$8H
T$HH
|$ H
|$(H
L$ H
t$(H
I;\$
D$`H
D$hH
D$pH
D$xH
S0H)
t$@H
I;\$
T$8H
|$(H
E H)
D$PH
t$8H
I;\$
D$`H
D$hH
D$pH
D$xH
t$8H
t$8H
[]A\A]A^A_
t$8H
T$8H
|$ f
|$(H
|$8H
D$PH
|$@H
|$pH
|$01
|$01
AWAVAUATUH
L9l$
u#H)
L9l$
T$0H
T$0H
T$0H
T$0H
T$(H
T$ L
|$0H
[]A\A]A^A_
T$0H
T$0H
T$0H
T$0H
T$0H
T$0H
T$0H
T$0H
T$0H
T$0H
T$0H
T$0H
T$0H
T$0H
AWAVAUATI
T$@H
T$ H
|$LH
T$0H
t$ L
|$01
t$ H
|$01
t$ L
T$ L
|$01
T$ L
t"M;
T$ H
|$01
|$01
|$01
|$01
|$01
T$ H
|$01
|$xH
D$@t
|$ H
[]A\A]A^A_
T$ L
B(H+B H
T$ L
|$01
|$01
5L'	
|$01
T$ H
B(H)
T$ L
T$ H
t$ H
|$01
T$0H
T$(H
t$ L
|$ I
AWAVAUATUH
l$ H
|$XH
D$ t
[]A\A]A^A_
H9D$
L9l$
B(H)
G H9A
G(H9A
B(H+B H
AWAVAUATUH
|$8H
|$@H
|$0H
[]A\A]A^A_
|$0H
fffff.
AWAVAUATUH
|$pH
|$HH
|$pH
l$xH9
|$pH
[]A\A]A^A_
|$pH
AWAVAUATUH
|$0L
B0H+B(H
|$ H
t$0I
t$@I
|$XH
D$ t
[]A\A]A^A_
|$ H
AWAVAUI
ATUH
T$(L
B(H+B H
[]A\A]A^A_
T$(L
B(H)
{ H9y
C(H9A
|$8H
L$8H
D$@H
|$0H
D$HH
|$(H
T$HH
|$ H
|$(H
L$ H
t$(H
|$8L
|$@L
t$0H
T$@H
|$0H
|$(H
L$@H
T$8H
L$(H
|$ H
EpH+EhA
t$(L
5rq+
L$PL
L$ H
|$ H
|$ H
|$ H
t$@H
t$8H
|$ H
L$(H
|$ H
|$(A
t$(H
|$ H
|$0H
|$ H
t$@H
|$@H
t$8H
T$ L
|$ H
|$ H
t$ H
|$ H
|$8H
|$8H
|$0I
|$ I
|$(I
|$0I
|$8I
|$(I
|$ H
ATUH
[]A\
[]A\
[]A\
[]A\
[]A\
[]A\
ATUH
[]A\f
F(H+F H
F(H)
G H9B
G(H9B
AVAUI
ATUH
[]A\A]A^
D$ I
D$(L
l$ L
d$(L
l$0L
t$8L
|$@H
R H9
D$(1
H9U w
H9P rI
L$(dH3
0[]A\
H9P s
D$X1
V I9
$sxH
$H9P H
T$XdH3
\$`H
l$hL
d$pH
H9w 
P I9
$H9B s
\$ H
l$(L
d$0L
l$8L
t$@H
AVAUI
C t?H
[]A\A]A^
;B A
D$(1
9U w
9P rJ
L$(dH3
0[]A\
9P s
D$X1
P A;
T$XdH3
\$`H
l$hL
d$pH
H9w 
$;P 
B A;
[]A\f
\$(H
l$0L
d$8L
l$@L
t$HL
|$PH
A;F8A
AWAVI
AUATUH
 t	H
[]A\A]A^A_
AWAVL
AUATUSH
{(trI9
[]A\A]A^A_
\$(H
l$0L
d$8L
l$@L
t$HL
|$PH
ATUH
t"f.
[]A\
l$ L
d$(L
l$0L
t$8L
|$@H
u H)
D$(1
u?L)
L$(dH3
0[]A\
D$H1
T$HdH3
\$XH
l$`L
d$hL
l$pH
H9] 
ATUH
t"f.
[]A\
AWAVAUI
ATUSH
l$@L
D$@H
D$@I
D$@H
D$HH
t$pM
D$`H9
|$hH
T$?H
|$0L
D$0L
D$@I
D$@H
l$@L
[]A\A]A^A_
|$hH
|$ L
D$ L
l$@L
l$@L
AWAVAUI
ATUSH
\$@H
l$@L
D$@H
%0)+
D$@I
D$@H
D$HH
t$pM
D$`H9
|$hH
T$?H
|$0L
D$0L
D$@I
D$@H
l$@L
[]A\A]A^A_
|$hH
|$ L
D$ L
l$@L
l$@L
AWAVAUI
ATUSH
T$(D
d$@L
d$HM
d$HL9
d$HI
d$HH
|$@I)
5%&+
|$@H
t$8L
T$0H
T$(H
t$0H
|$@L
l$`H
[]A\A]A^A_
d$pH
|$@H
AWAVAUATUH
|$0H
d$PL
d$XH
\$`H
d$XL9
d$XI
d$XH
|$PI)
l$pH
|$PH
T$(H
T$8H
T$ H
T$@H
t$8H
|$8H
t$8H
|$8H
t$8H
|$0L
[]A\A]A^A_
|$PL
T$@H
t$8H
|$8H
t$ H
t$@H
t$8H
T$HH
T$@L
T$ H
|$8H
|$PH
|$8I
|$8I
|$8I
|$8I
|$8I
|$8I
|$8I
|$8I
\$(H
l$0L
d$8L
l$@H
D$81
l$0H
T$8dH3
\$@H
l$HL
d$PL
l$XL
t$`H
D$81
l$0H
T$8dH3
\$@H
l$HL
d$PL
l$XL
t$`H
\$(H
l$0L
d$8L
l$@H
AWAVAUATI
l$ H
[]A\A]A^A_
D$@H
t$pH
l$`H
\$PL
l$0H
D$81
l$ H
T$7H
T$8dH3
\$HH
l$PL
d$XL
l$`H
AWAVAUATUSH
L$ H
D$(I
T$(H
|$pH
l$pH
l$`H
l$PH
d$0H
l$PH
D$0L
|$pH
D$pH
D$pA
[]A\A]A^A_
T$~H
d$@H
l$PH
D$@L
l$PH
|$pH
T$(H
T$ L
AWAVAUATUSH
L$ H
D$(I
T$(H
|$pH
l$pH
l$`H
l$PH
d$0H
l$PH
D$0L
|$pH
D$pH
D$pA
[]A\A]A^A_
T$~H
d$@H
l$PH
D$@L
l$PH
|$pH
T$(H
T$ L
AWAVAUATUSH
L$ H
D$(I
T$(H
|$pH
l$pH
l$`H
l$PH
d$0H
l$PH
D$0L
|$pH
D$pH
D$pA
[]A\A]A^A_
T$~H
d$@H
l$PH
D$@L
l$PH
|$pH
T$(H
T$ L
AWAVAUATUSH
L$ H
D$(I
T$(H
|$pH
l$pH
l$`H
l$PH
d$0H
l$PH
D$0L
|$pH
D$pH
D$pA
[]A\A]A^A_
T$~H
d$@H
l$PH
D$@L
l$PH
|$pH
T$(H
T$ L
AWAVAUATUSH
L$ H
D$(I
T$(H
|$pH
l$pH
l$`H
l$PH
d$0H
l$PH
D$0L
|$pH
D$pH
D$pA
[]A\A]A^A_
T$~H
d$@H
l$PH
D$@L
l$PH
|$pH
T$(H
T$ L
AWAVAUI
T$ E1
D$ H
D$0I
T$0L
D$(H
D$(H
D$pH
D$pH
D$(H
L$0H
T$ L
|$0H
T$ H
D$(I
L$(L
T$PH
D$PH
T$8H
L$(H
T$ L
[]A\A]A^A_
D$`H
D$`H
D$8H
D$(H
D$HH
|$0H
T$(L
D$Hf
T$0L
|$(H
D$HL
L$0L
D$HH
D$Hf
|$8H
D$HH
T$(L
D$h1
T$eH
t$PH
T$gH
l$@E1
T$hdH3
\$pH
l$xL
t$0H
T$fH
l$ E1
d$PH
l$@H
\$`L
d$PH
t$ H
T$0H
T$(L
l$pH
D$8f
D$8t
D$8t
D$8f
D$8H
D$8f
D$x1
T$uH
t$ H
T$vH
T$xdH3
t$`H
T$wH
l$PE
d$@H
\$0L
D$h1
l$Pt{L
d$@H
T$gH
T$hdH3
\$xH
d$0H
l$ H
t$ H
|$PH
l$@H
l$0L
|$PH
|$pH
d$`L
AVAUATI
D$pH
D$ I
T$ L
t$pH
D$`H
T$ H
l$PH
\$@H
[]A\A]A^A_
T$(L
T$ L
D$pH
T$ L
T$ L
D$8f
AWAVI
AUATUH
D$x1
t$0L
t$@H
|$0H
D$<H
D$@H
D$HH
D$PH
D$8I
D$<A
D$@I
D$HI
D$PI
D$XI
D$hI
D$xdH3
[]A\A]A^A_
D$ H
L$(H
|$0H
D$ H
|$@H
T$HH
T$(H
d$HI9
L$ H
Hk|$ H
\$(H9
t:H9\$(t@H
H9T$ f
fff.
O@dH
:H;w8s
:H9w8w
fffff.
fffff.
fff.
fffff.
fffff.
l$ L
d$(L
l$0H
l$ L
d$(L
l$0H
fffff.
fffff.
l$ H
ATUH
[]A\
[]A\
I+l$
[]A\
[]A\
ATUH
[]A\
[]A\
I+l$
[]A\
[]A\
ATUH
[]A\
fffff.
d$ H
d$ H
d$ H
d$ H
ATUH
gHdH
[]A\
[]A\
ATUSH
[]A\
[]A\
d$ H
d$ H
ATUH
[]A\
[]A\
fffff.
AUATUH
[]A\A]
[]A\A]
ATUH
D$(1
T$(dH3
8[]A\A]
AUATI
I+l$
[]A\A]
[]A\A]
ATUSH
[]A\
[]A\
AUATI
 []A\A]A^
[]A\f
D$(1
= L*
T$'H
T$&H
=uR*
5iR*
T$%H
=SR*
5GR*
T$$H
=1R*
5%R*
T$#H
T$"H
T$!H
T$ H
5{Q*
=eQ*
5YQ*
=CQ*
57Q*
=!Q*
=wP*
5kP*
=UP*
5IP*
=3P*
5'P*
5}O*
=gO*
5[O*
=EO*
59O*
D$(dH3
AVAUATI
[]A\A]A^
[]A\A]
w(dH
v8H)
SHH)
d$ L
l$(L
t$0H
[]A\A]
AUATI
t{E1
[]A\A]
ATUH
[]A\
ATUH
[]A\
[]A\A]
fff.
[]A\A]A^
g dH
d$ H
fffff.
g dH
d$ H
fffff.
D$h1
T$`1
$t71
T$hdH3
T$XH
T$ H
T$(H
T$0H
T$8H
T$@H
T$HH
T$PH
,$tz1
fff.
D$@H
D$`H
t$pH
l$PH
d$0H
T$(H
AVAUATUSH
g8dH
-F**
 []A\A]A^
D$81
L$ L
D$(D
T$7H
l$ I
T$8dH3
\$@H
l$HL
d$PL
l$XL
t$`H
=a'*
D$(H
=u%*
t$ H
{@E1
=H!*
T$(H
|$(1
t$ H
T$ H
|$ 1
t$(H
D$pH
T$(H
|$(1
t$ H
D$PH
T$(H
|$(1
t$ H
D$0H
T$(H
|$(1
t$ H
|$(1
ATUSH
D$h1
d$XH
L+l$XH
t$PH
\$@H
T$gH
H I9
t$PH
T$hdH3
p[]A\A]A^
D$XH
fffff.
o SH
[]A\f
o SH
[]A\f
&v.1
\$ H
l$(L
d$0H
D$X1
Q0tCH
D$XdH3
\$`H
l$hL
d$pL
l$xL
l$@H
T$UH
T$VH
d$0H
T$WH
\$ L
AWAVAUI
ATUSH
<Sv[
([]A\A]A^A_
LtOH
fffff.
D$81
t ~v
T$8dH3
\$HH
l$PL
d$XL
l$`H
fff.
AWAVAUATUH
D$h1
D$hdH3
x[]A\A]A^A_
\$PH
T$gH
l$@H
T$fH
d$0H
T$eH
t$PH
t$@H
t$0H
t$PH
t$@H
T$cH
t$ H
T$dH
t$0H
T$bH
D$(1
{PH;{0
H;{XH
{PH;{0
H;{XH
t$(I;t$0
D$(H
t$(dH34%(
\$8H
l$@L
d$HL
l$PL
t$XL
|$`H
T$'H
H+C H
u=H)
t$8I
t$ L
|$ L
uXH)
s@H;sHL
H(t;1
 []A\A]A^
AVAUATUSH
D$81
l$4L
T$8dH3
H[]A\A]A^A_
AWAVAUATE1
T$(H
T$8L
l$@dH
D$X1
D$0L
t$HL
|$WH
D$ f
l$HH
D$W<tt:<Tt6<W
D$ H
L$81
B@H+B8H
T$(H
T$XdH3
h[]A\A]A^A_
T$(H
d$ H
T$'H
D$(1
T$(dH3
\$8H
l$@L
d$HL
l$PH
AVAUI
ATUSH
T$ H
D$0H
{ H+T$
H+D$8H
D$HH+D$(H
|$ H
L$0H+L$8L
L$(H
SHH)
L$HL)
T$pH
{pH+T$`H+
H+D$xH
|$pH
D$`H
L$xH
[]A\A]A^
C@H)
t$`H
l$PL
t$@H
l$0L
t$ H
t$ H
t$ L
t$ L
l$pL
H+E H
C@H)
t$`H
l$PL
l$pL
t$@H
l$0L
l$ H
l$ H
|$ I
l$ H
l$ L
l$ f
AWAVAUI
g(UM
O0dH
D$h1
D$hdH3
x[]A\A]A^A_
d$@H
l$0L
d$`H
l$PL
d$ H
fffff.
AVAUATI
I;\$@u
|$8H
[]A\A]A^
AVAUATI
I;\$@u
|$8H
[]A\A]A^
AWAVAUATUSH
D$X1
|$(H
D$0H
D$@H
D$WH
D$8H
D$0H
L9d$
l$(M
D$@H
D$@H
L9d$
t$@H
|$@H
L9d$
D$XdH3
h[]A\A]A^A_
L9d$
L9d$
D$@H
D$@H
fffff.
C8H9C@
d$pL
t$PH
L$0E1
|$`H
D$ H
D$XH
}PH;}0
H;}XH
vpI;vx
D$XH
T$(H
\$0H
t$HH
fffff.
H;=o
l$ H
fff.
AWAVAUATI
\$`dH
l$ H
D$ H
D$(H
D$@H
D$HH
D$PH
D$XH
t$(H
t$ H
[]A\A]A^A_
ATUH
D$X1
p0H;p8
D$XdH3
h[]A\A]
H9N }
H9N H
l$0L
|$8H
|$8H
|$0H
l$ H
ATUH
D$X1
p0H;p8
D$XdH3
h[]A\A]
H9N }
H9N H
l$0L
|$8H
|$8H
|$0H
l$ H
AWAVAUM
T$@H
D$PL
T$XH)
}pH+
|$`H;|$@
H;|$hH
D$`M
D$@H9D$`
[]A\A]A^A_
D$xH
T$xH
D$hH
D$`H
AWAVAUM
T$@H
D$PL
T$XH)
}pH+
|$`H;|$@
H;|$hH
D$`M
D$@H9D$`
[]A\A]A^A_
D$xH
T$xH
D$hH
D$`H
l$@dH
d$ L
l$(L
t$0H
l$@dH
d$ L
l$(L
t$0H
D$81
H=?B
x	L9
T$6H
T$5H
d$ H
T$7H
D$8dH3
\$HH
l$PL
d$XL
l$`H
D$81
H=?B
x	L9
T$6H
T$5H
d$ H
T$7H
D$8dH3
\$HH
l$PL
d$XL
l$`H
T$ H
T$(H
D$0H
l$0H+
T$`H
D$pL
T$xH)
D$0H
}pH+
D$0H
D$(H
H;|$`
D$0H
D$`H9
|$8H
D$0t
[]A\A]A^A_
D$(H
D$(H
D$(L
D$(H
|$8H
D$(L
D$(H
D$(u
D$(L
D$(L
D$(u
D$(u
D$(u
T$ H
T$(H
D$0H
l$0H+
T$`H
D$pL
T$xH)
D$0H
}pH+
D$0H
D$(H
H;|$`
D$0H
D$`H9
|$8H
D$0t
[]A\A]A^A_
D$(H
D$(H
D$(L
D$(H
|$8H
D$(L
D$(H
D$(u
D$(L
D$(L
D$(u
D$(u
D$(u
T$'H
D$(1
T$(dH3
D$X1
T$XdH3
\$hH
l$pL
d$xL
t$@H
t$@H
\$0L
\$PI
=i|)
=Nx)
=t{)
AWAVAUATUH
uhE1
[]A\A]A^A_
=|x)
l$ H
D$ I
T$8H
T$@H
T$HH
D$(H
=-u)
l$ H
fff.
AWAVI
AUATI
t$(H
T$0H
|$0H
t$0L
D$pH
T$xH
T$xH
D$pH
T$(A
[]A\A]A^A_
t$0H
|$@H
t$0H
T$ H
T$@H
T$HH
T$XH
T$`H
T$PH
|$ H
|$@H
t$ H
u9E1
H1C(
|$ f
='g)
=`f)
|$HH
ATUH
D$81
T$6H
\$ H
|$ H
T$8dH3
@[]A\
T$7H
AVAUATI
D$x1
H;n v
H;n H
L$ H
L$(H
L$0H
D$xdH3
[]A\A]A^A_
T$@I
l$@H
H;j v
H;j H
D$ E1
t$pL
|$hH
l$hE1
t$pH
T$PI
l$PH
d$@H
T$PH
T$XH
\$0H
t$(L
t$(L
\$`H
t$(L
L$pH
t$(L
=FW)
=	W)
|$pH
t$`H
|$8H
l$@L
d$HH
l$PH
AUATI
D$81
T$6H
l$ H
|$ H
T$8dH3
H[]A\A]
T$7H
=jP)
AWAVAUATUSH
t$0H
|$@H
H;=zO)
T$0H
D$8H
T$pH
L$`L
T$HH
T$PH
L$XH
L$0H
L$(H;
t$(H
|$H1
D$(H
D$ H
L$`M
|$pH
H9=HM)
D$(H
T$0H
L$ H
D$ H
\$`I
=!L)
t$PL
L$8H
T$8H
L$(u
D$8H
L$(H
L$0H
T$8H
[]A\A]A^A_
T$8H
|$HH
|$@H
D$(1
D$(dH3
\$8H
l$@L
d$HL
l$PL
t$XL
|$`H
AWAVAUATUSH
D$`H
T$`H
D$hH)
T$`H
D$ H
L$8H
D$(H
L$HH
D$PH
L$0H
|$ H
T$8H
|$(H
|$0H
H9D$
|$`H
l$hH9
|$`H
[]A\A]A^A_
|$(H
=~>)
=U>)
|$0H
|$`H
AWAVAUATUH
D$pL
|$PE1
D$`H
D$ H
t$pH
|$pL
56<)
t$`H
|$`H
t$PH
|$PH
t$hH
l$@H
[]A\A]A^A_
=j8)
==8)
AWAVAUATUSH
|$ u-H
[]A\A]A^A_
D$ L
D$(H
D$0H
t$ L
l$PH
l$pH
AWAVAUATUH
D$X1
D$UL
t$@1
t$@H
|$@H
H;=%))
T$VH
l$0H
T$WH
D$XdH3
h[]A\A]A^A_
fffff.
AUATUH
D$(1
%L")
T$'H
D$(dH3
8[]A\A]
AWAVAUI
[]A\A]A^A_
|$pH
D$ H
D$`H
D$(H
D$0H
T$ H
|$pL
|$`H
H;D$
|$@L
t$PH
D$ H
D$(f
|$PH
|$@H
H;D$
=^	)
=5	)
AWAVAUATUSH
[]A\A]A^A_
D$(H
\$0E1
D$ H
D$8H
|$ H
H;D$
\$0L
t$(H
t$(L
t$(L
` M9
l$pH
l$PH
t$8H
fffff.
AWAVAUI
ATUSH
|$pH
D$ H
H;=k
t$pH
|$pH
H;=M
l$`H
l$@H
[]A\A]A^A_
ATUH
[]A\
fff.
AVAUATUH
D$(1
T$&H
T$'H
e(M9
eXM9
tdf.
D$(dH3
0[]A\A]A^
fffff.
AWAVAUATUH
D$X1
D$UL
t$@1
t$@H
|$@H
T$VH
l$0H
T$WH
D$XdH3
h[]A\A]A^A_
AWAVAUATUH
d$pH
d$PH
d$0H
[]A\A]A^A_
fffff.
AWAVAUATU1
D$H1
D$@H
l$ L
|$0H
D$GH
D$FH
t$0H
|$0H
|$ L
t$0H
t$0H
D$HdH3
X[]A\A]A^A_
AWAVAUI
ATUSH
D$8H
t$8H
t$(H
T$ H
C@H)
D$pH
t$8H
|$`H
t$PL
t$0H
l$hA
t$0H
[]A\A]A^A_
|$@H
I+E H
|$0I
|$0I
|$0I
|$0I
|$0I
AVAUATUSH
D$h1
D$`L
l$@1
D$PH
D$fH
D$ H
D$eH
D$(H
|$@L
l$0H
T$gH
t$PH
|$PH
t$PH
D$hdH3
x[]A\A]A^A_
fffff.
AWAVAUATUSH
D$X1
D$@L
l$0L
|$P1
D$VH
D$UH
|$0L
l$ H
T$WH
t$@H
|$@H
D$XdH3
h[]A\A]A^A_
AWAVAUATI
E@H)
t$(H
t$ H
D$HH
t$HI
t$ H
T$`I
D$PH
T$PH
T$PH
[]A\A]A^A_
D$`H
D$pH
|$PH
T$(H
D$0H
l$hH
I+D$ H
D$(H
D$PH
D$hH
T$hH
D$XI
D$PI
l$hf
|$ H
|$ H
AWAVAUI
D$'t
D$hI
T$hH
T$8H
D$0H
T$HH
D$(H
T$@H
D$PH
D$XI
D$hH;X
l$`L
T$'H
D$`H
D$8H
T$`H
T$0H
D$PH
\$PH9
[]A\A]A^A_
|$(L
t$(L
H;=k
D$0H
|$HH
D$0H
t$0H
t$(L
t$8L
D$0H
u(H;u0H
u(H;u0H
uqH)
|$@L
T$@H
|$@H
T$0H
s(H;s0H
D$XH
I+E H
|$PL
T$PH
|$PH
I+E H
T$XH
|$HI
|$(I
|$@I
|$PI
ATUH
D$X1
t$`H
T$PH
T$XdH3
`[]A\
D$0H
D$8H
D$@H
D$PH
D$(H
D$(H
D$0H
D$8H
D$@H
D$HH
t$`H
AWAVAUATUSH
D$ I
T$ H
l$pL
|$pH
l$PH
l$`H
d$0H
l$`H
D$0L
|$pH
D$pH
D$pA
[]A\A]A^A_
T$~H
d$@H
l$`H
D$@L
l$`H
D$(H
D$(H
D$(H
|$pH
D$(f
D$(H
D$(H
T$ H
D$(H
D$(L
D$(L
AVAUI
ATUSH
D$81
T$7H
t$hH
D$8dH3
@[]A\A]A^
AWAVAUATI
D$x1
<@t=<:
t$PH
D$PL
T$uH
l$@H
D$@H
T$xdH3
[]A\A]A^A_
l$0L
d$ L
T$wH
l$`H
D$`H
t$@dH
[]A\A]A^
t$@dH
[]A\A]A^
AWAVAUATI
5=u(
C@H)
5Gt(
t$ H
T$(H
D$pH
T$@H
t$HH
D$`H
T$(H
t$8H
t$ H
t$0H
t$0H
T$`I
D$PH
T$PH
T$PH
[]A\A]A^A_
57n(
D$PH
t$HH
T$8H
t$@H
T$ H
t$(H
\$hH
I+D$ H
D$(H
D$PH
D$hH
T$hH
D$XI
D$PI
|$0H
|$0H
|$ H
|$0H
|$0H
|$0H
D$(1
D$(dH3
\$0H
l$8L
d$@L
l$HL
t$PH
T$'H
AVAUE
ATUH
T$ H
L$<H
T$0L
5dk(
t$(L
|$ H
[]A\A]A^A_
t$ H
|$<E
t$<H
D$@H
l$@H+
T$pH
D$@H
}pH+
T$0H
D$@H
H;|$p
e t%
I;t$
D$@H
D$pH9
|$HH
|$hH
|$PH
|$8H
|$ H
|$HH
AVAUE
ATUH
T$ H
L$<H
T$0L
t$(L
|$ H
[]A\A]A^A_
t$ H
t$<H
D$@H
l$@H+
T$pH
D$@H
}pH+
T$0H
D$@H
H;|$p
e t%
I;t$
D$@H
D$pH9
|$HH
5<N(
|$hH
|$PH
|$8H
|$ H
|$HH
AVAUATM
t$ H
L$,L
L9,$
5CE(
[]A\A]A^A_
L9,$
5S=(
t$ H
t$,H
l$0L
D$0H
I;t$
5o?(
57?(
AWAVAUATUSH
t$PH
L$dL
D$hL
L$8H
-<5(
T$PH
t$XH
t$dH
t$HL
t$8H
t$XH
D$8L
D$HM
L$dH
t$PL
-o3(
t$XH
D$hH
T$8L
L$dI
t$PL
l$xH
[]A\A]A^A_
T$8H
L$HL
T$8H
T$8H
D$8H
t$XH
D$hH
T$8L
L$dE1
t$PL
D$ H
L$HL
fffff.
fffff.
D$(1
D$(dH3
\$0H
l$8L
d$@L
l$HL
t$PH
l$ H
fffff.
AVAUATUH
D$(1
l$ u
D$(dH3
0[]A\A]A^
T$'H
T$&H
AWAVAUI
ATUH
[]A\A]A^A_
T$pH
t	H9
L$(H
D$8H
T$hH
L$0H
T$8H9T$p
L$gH
D$PH
T$$H
L$xH
T$DH
D$(I
L$PL
D$XD
t$HH
T$hH
|$0H
H;=# (
;H |
t$DL
T$PH
L$XD
L$PH
t$HH
t$HI
t$HI
T$HH
T$HH
|$(A
|$0H
fffff.
AWAVAUATUH
D$x1
T$pL
D$pH9C 
D$xdH3
[]A\A]A^A_
L;f v
t	L;f H
T$@I
d$@H
L$ H
L$(H
L$0H
L;b v
L;b H
T$PI
d$PH
D$ E1
t$pL
|$hH
l$hE1
t$pH
AWAVM
ATUH
T$PH
t$@H
L$8dH
T$(H
L$8H
D$0H
T$PH
t$@M
|$0H
[]A\A]A^A_
T$8H
L$8H
T$8H
L$@L
l$@H
D$@L;
L$HH
D$0H
T$ I
L$hH
d$(H
D$XH
L$xf.
PRB1
|$HH
D$(H
L+d$(N
|$HH
T$ L
T$ t
D$pH
T$`M
L$hM
H;D$hI
L$8M
T$PH
t$@H
|$XH
D$0H
t$XH
|$xH
T$xL
|$xI
T$HH
D$XH
t$@H
T$0H
t$@H
d$@I
|$8H
D$0H
D$0f
D$0f
D$0H
D$0H
|$HH
D$0H
|$`H
|$xH
|$XH
t$XH
AVAUATM
t$ H
L$,L
L9,$
[]A\A]A^A_
L9,$
t$ H
\$,E
t$,H
D$0H
l$0H+
T$`H
D$pL
T$xH)
D$0H
}pH+
D$0H
I;t$
|$8H
AWAVAUATI
t$pL
\$pH
l$`H
|$p1
\$pH
\$pH
l$`I
T$ H
t$8M
l$0H
t$PH
\$pH
l$`H
\$pH
\$pH
l$`H
\$pH
\$pH
\$pH
\$pH
\$pH
\$pH
l$`H
\$pH
\$pH
t$pH
\$pH
l$`H
\$pH
t$`H
\$pH
l$`H
\$pH
\$pH
\$pH
\$pH
[]A\A]A^A_
|$`1
\$pH
\$pH
l$`I
T$ H
T$ H
|$PH
D$(H
t$pH
t$`H
t$PH
\$0H
l$PH
D$0H
\$pH
l$`H
l$`H
\$pH
\$pH
l$`H
l$`H
\$pH
\$pH
l$`H
\$pH
l$`H
\$pH
l$`H
\$@H
l$PH
D$@H
l$PI
t$`H
\$pH
l$`L
T$(H
T$ H
|$hH
\$pH
fffff.
AWAVAUI
ATUL
L$ L
uWH)
|$@L
S0E1
d$`H
[]A\A]A^A_
d$pL
\$PL
D$ H
T$ M
,$E1
d$`H
D$0L
T$(H
|$(H
|$(H
AWAVAUATI
|$0H
T$(H
D$ H
d$@H
T$<H
T$ H
T$8I
D$@H)
|$0L
\$`H
l$pH
D$ H
t$<H
t$XH
l$XH
|$0H
t$PH
\$PH
[]A\A]A^A_
D$ t+H
D$ f
D$ f
D$81
d$ H
T$7H
D$8dH3
\$@H
l$HL
d$PL
l$XL
t$`H
T$6H
AWAVAUATI
D$8I9D$@
T$8I9T$@
L$(H
D$0H
T$PH
L$XH
t$XH
|$0H
t$0H
T$HH
T$PH
t$HL
T$@L
t$8H
T$(D
D$ L
L$8M
L$(L
w(I;w0M
t$8H
D$8M
|$@H
D$@I
}PH;}0
H;}XH
s(H;s0L
[]A\A]A^A_
|$(H
D$8I9D$@
|$ E1
|$ H
t$ H
D$(H
T$0H
|$0L
t$0H
T$(H
t$8L
D$PH
D$`H
t$0H
T$(I
|$(H
T$ H
L$(H
t$PH
t$HH
T$0H
T$@H
t$0H
T$(L
t$8H
T$ H
L$(I
t$PL
t$HH
T$0H
T$@H
t$0H
T$(L
|$ H
t$8H
H+E H
t$pH
t$XL
D$PH
|$(f
|$8I
|$8I
|$8I
|$8I
|$8I
|$ I
|$8I
|$8I
|$8I
|$8I
|$8I
|$0I
|$(I
d$ H
d$ H
D$81
T$8dH3
\$@H
l$HL
d$PH
T$6H
l$ H
T$7H
AWAVAUATUH
D$x1
D$xdH3
[]A\A]A^A_
L;f v
L;f H
L$ H
L$(H
L$0H
T$@I
d$@H
L;b v
L;b H
T$PI
d$PH
D$ E1
t$pL
|$hH
l$hE1
t$pH
AWAVAUATUH
dH34%(
[]A\A]A^A_
t$PH
|$PH
t$@H
t$HH
|$@H
T$XH
t$@H
t$0H
|$ H
T$PH
t$ H
L$ H
|$ H
t$0H
T$(L
L$(L
D$ H
D$@H
|$@H
D$0H
t$@L
t$8H
ghtX
t$ H
|$ M
t$8I
|$`I
|$ H
D$hI
d$PH
\$(I
t$8H
D$ H
L$(H
|$8H
|$8H
d$0L
|$XI
d$0L
|$XH
D$ I
T$(I
T$0H
D$(H
L$(H
T$0I
D$ I
T$(H
L$0H
|$0H
t$HH
|$HH
T$0H
t$HH
t$@H
T$XH
T$ H
t$XI
L$ H
t$pH
t$XH
t$pI
t$ H
D$hL
T$hH
|$ H
t$XH
t$ H
T$xH
D$hH
L$`A
t$`H
T$0H
|$ H
t$pH
T$ H
L$@H
t$hH
D$@H
|$HH
t$XH
T$ H
|$ H
|$HH
t$ H
t$ H
D$(H
L$ H
D$`H
L$`H
t$ H
D$ H
T$(H
L$ H
t$ H
D$@H
L$ H
t$0H
t$@H
T$0H
L$(H
D$@H
T$ H
t$`H
L$0H
T$ A
t$(I
D$@H
|$0H
T$(I
t$ I
T$ H
t$HH
t$8H
|$8L
|$ I
|$(H
H9D$PH
|$8H
D$HH
|$pI
H+E H
t$(H
T$ I
|$ I
t$ H
|$ H
t$ L
H+E H
\$PL
t$8L
L$ L
|$ L
t$(I
D$hH
L$ H
D$ H
D$ H
L$ H
T$ H)
T$ H
t$0H
T$0H;w
T$0H
T$ H
t$ H
L$ H
t$0H
|$0H
t$ H
T$ H
L$(H
D$ H
L$0H
L$ H
D$ H
T$0H
|$ H
t$`H
L$ H
t$ H
t$@H
|$ H
T$0H
D$ I
T$(H
D$(H
D$(H
|$XH
|$XH
|$XH
|$XH
D$(f
|$ H
|$ H
|$`H
D$(f
D$(f
T$0H
D$(H
|$8H
|$8H
|$ H
|$@H
|$8H
|$8H
|$8H
|$@H
|$ H
|$ H
D$(f
|$hH
D$(f
|$ H
|$HH
|$@H
|$0H
AVAUATUSH
l$ H
T$7dH
D$81
|$ H
I;A8w
I;B8v
C@M)
T$8dH3
H[]A\A]A^A_
I;A8r
D$5M
S@H)
=k~'
t$6H
AUATI
D$81
D$8dH3
H[]A\A]
=Wy'
l$ H
T$7H
T$6H
T$5H
fffff.
AWAVAUATI
D$h1
\$PH
]8I;]@
D$0H
D$@H
D$fH
D$ H
D$gH
I;]@
t$@H
|$01
|$@L
|$0H
I;]@
D$hdH3
x[]A\A]A^A_
t$0H
t$@H
5$t'
=`r'
=cu'
fff.
AVAUE
ATUSH
D$ H
l$ H+
T$PH
D$`L
T$hH)
D$ H
}pH+
D$ H
|$pH;|$P
H;|$xH
D$pM
5mp'
57p'
5}o'
D$ H
D$PH9D$p
|$(H
D$ t
[]A\A]A^A_
58n'
5Fm'
5wm'
5}l'
5'l'
D$xH
D$pH
|$(H
AVAUE
ATUSH
D$ H
l$ H+
T$PH
D$`L
T$hH)
D$ H
}pH+
D$ H
|$pH;|$P
H;|$xH
D$pM
5;b'
5Wa'
D$ H
D$PH9D$p
|$(H
D$ t
[]A\A]A^A_
5X_'
5f^'
5G]'
D$xH
D$pH
|$(H
T$(H
D$ H
D$0H
l$0H+
T$`H
D$pL
T$xH)
D$0H
}pH+
t$ H
H;|$`
=`N'
D$0H
D$`H9
|$8H
D$0t
[]A\A]A^A_
|$8H
fffff.
AVAUI
ATUL
L$ H
T$8H
L$ L
L$HH
|$HH
L$HH
[]A\A]A^A_
T$(L
L$@H
D$PH
L$XH
T$(H
L$pH
D$`H
T$hH
L$xH
t$@L
t$PH
|$(H
|$(H
t$@H
t$(H
t$XH
t$pH
L$`H
|$HH
L$HH
t$@H
t$(H
t$hH
L$xH
|$(H
|$XH
|$xH
L$HH
|$xH
|$`H
|$xH
|$hH
|$`H
D$HH
T$(H
D$ H
D$0H
l$0H+
T$`H
D$pL
T$xH)
D$0H
}pH+
t$ H
H;|$`
D$0H
D$`H9
|$8H
D$0t
[]A\A]A^A_
|$8H
fffff.
AVAUATUSH
t$pH
|$pH
l$`H
|$`H
t$@H
l$PH
|$PH
|$@H
l$0H
|$0H
l$ H
|$ H
[]A\A]A^
=x&'
=H&'
=X%'
=(%'
=h$'
=8$'
=x#'
=H#'
=X"'
=("'
AVAUATUSH
D$81
5d '
57 '
T$7H
|$ L
T$5H
T$6H
D$8dH3
@[]A\A]A^
fffff.
AWAVAUATE
T$@H
D$PL
T$XH)
}pH+
H;=9
|$`H;|$@
H;|$hH
D$`M
D$@H9D$`
[]A\A]A^A_
D$xH
T$xH
D$hH
D$`H
AVAUATUSL
T$PH
t$HH
u*H)
T$0M
T$XH
H;=}
T$08T$ 
l$pL
L$ H
T$PH
t$HH
\$hH
[]A\A]A^A_
AWAVAUATE
T$@H
D$PL
T$XH)
}pH+
H;=I
|$`H;|$@
H;|$hH
D$`M
D$@H9D$`
[]A\A]A^A_
D$xH
T$xH
D$hH
D$`H
AUATUH
l$ L
D$81
|$ H
D$8dH3
H[]A\A]
AVAUATUSH
[]A\A]A^A_
AVAUI
ATUH
D$81
L$8dH3
H[]A\A]A^A_
M;P8w
M9P8s
D$ H
L$(H
D$ M
T$8dH3
D$ L
]A\A]A^A_H)
:L;G8s
:L9G8w
H8H9J8
ATUH
[]A\
l$HI
\$(H
[]A\
[]A\
ATUH
[]A\
ATUH
[]A\
AUATUH
t<E1
[]A\A]A^
[]A\
D$ I
D$(L
l$ L
d$(L
l$0L
t$8L
|$@H
R H9
D$(1
H9U w
H9P rI
L$(dH3
0[]A\
H9P s
D$ L
l$ L
d$(L
l$0L
t$8L
|$@H
R H9
D$ L
l$ L
d$(L
l$0L
t$8L
|$@H
;B @
l$ H
D$X1
V I9
$sxH
$H9P H
T$XdH3
\$`H
l$hL
d$pH
H9w 
P I9
$H9B s
l$ L
d$(L
l$0H
AWAVAUI
D$X1
D$XdH3
h[]A\A]A^A_
\$ L
D$ L
D$(H
D$0H
D$8H
\$ H
l$(L
d$0L
l$8L
t$@H
\$(H
l$0H
ATUH
[]A\f
ATUH
[]A\f
[]A\
[]A\
{PH;{0
H;{XH
ChtLH
\$(H
l$0L
d$8L
l$@H
T$ H
D$0H
{ H+T$
H+D$8H
D$HH+D$(H
|$ H
L$0H+L$8L
L$(H
SHH)
L$HL)
T$pH
{pH+T$`H+
H+D$xH
t$pH
D$`H
D$xH)
[]A\
[]A\
[]A\
}8H;x8r?H
H;y8snH
H;y8r
[]A\A]
w~sH
l$(H
\$ L
d$0H
\$ H
l$(L
d$0H
t@E1
\$ H
l$(L
d$0H
w dH
w dH
AUATI
l$ dH
D$(1
8L;G
L$(dH3
8[]A\A]
\$(H
l$0L
d$8L
l$@L
t$HL
|$PH
R H9
D$(1
H9U 
H9P |I
L$(dH3
0[]A\
H9P }
D$X1
V I9
$}xH
$H9P H
T$XdH3
\$`H
l$hL
d$pH
H9w 
P I9
$H9B }
\$(H
l$0L
d$8L
l$@L
t$HL
|$PH
R H9
D$(1
H9U 
H9P |I
L$(dH3
0[]A\
H9P }
D$X1
V I9
$}xH
$H9P H
T$XdH3
\$`H
l$hL
d$pH
H9w 
P I9
$H9B }
T$PH
L$XL
D$`H
L$hH
D$81
D$(H
D$$0
L$pH
T$xI
l$@H
d$PH
l$0L
D$pH
l$`H
D$xH
l$ L
H+3H
4$H)
\$(H
l$0L
d$8L
l$@H
AUATI
D$H1
T$FH
d$0H
T$GH
l$ H
T$HdH3
X[]A\A]
C0H9CPuBH
C0H9CPuWH
C0H9CPuWH
D$@H
D$pH
l$`H
l$PH
D$0H
tPH9
t'L9
H8H9J8r
[]A\A]
AUATUH
H8H9J8shI
,u#H
[]A\A]
AWAVAUATUH
T$ H
D$X1
D$ H
t$8H
T$0H
D$@~'f.
t$8H
T$@H+T$ A
<6L9|$0
T$8I
t$(L
D$ H
t$(L9
L$8H
L;t$H
D$ L
d$ M
T$@I
|$(L
|$ J
|$(L9
L$@H
L9t$0
D$XdH3
h[]A\A]A^A_
T$HL
D$0L
D$ H
d$ H
D$CH
T$ L
D$(1
L$ L
D$(dH3
\$8H
l$@L
d$HL
l$PL
t$XL
|$`H
D$(1
t$ E
D$(dH3
\$8H
l$@L
d$HL
l$PL
t$XL
|$`H
T$ H
T$ H
T$ H
l$ L
d$(L
l$0H
\$(H
l$0L
d$8L
l$@L
t$HL
|$PH
\$(H
l$0L
d$8L
l$@L
t$HL
|$PH
\$(H
l$0L
d$8L
l$@L
t$HL
|$PH
\$(H
l$0L
d$8L
l$@L
t$HL
|$PH
\$(H
l$0L
d$8L
l$@L
t$HL
|$PH
\$(H
l$0L
d$8L
l$@L
t$HL
|$PH
\$(H
l$0L
d$8L
l$@L
t$HL
|$PH
\$(H
l$0L
d$8L
l$@L
t$HL
|$PH
\$(H
l$0L
d$8L
l$@L
t$HL
|$PH
\$(H
l$0L
d$8L
l$@L
t$HL
|$PH
\$(H
l$0L
d$8L
l$@L
t$HL
|$PH
\$(H
l$0L
d$8L
l$@L
t$HL
|$PH
\$(H
l$0L
d$8L
l$@L
t$HL
|$PH
\$(H
l$0L
d$8L
l$@H
D$PM
\$ H
l$(L
d$0L
l$8L
t$@H
AVAUI
D$H1
tGM9
t&M9
H8H9J8r
t$HdH34%(
[]A\L)
A]A^A_H
D$0H
:L;G8w
:L9G8s
D$(H
:L;G8s
:L9G8w
t$(H+L$0L
D$(L
T$ L
T$ H
L$0I
D$(H
L$HdH3
L+D$(H
L$8H
[]A\A]A^A_L
q8H9p8r
D$HdH3
X[]A\A]A^A_
L$HdH3
D$HdH3
L$HdH3
\$ H
l$(L
d$0L
l$8L
t$@H
[]A\
[]A\
AWAVI
AUATUSH
t$(L
t$hH
d$`L
d$PH
l$hL
t$ H
l$@H
\$0H
|$(H
[]A\A]A^A_
|$(H
L$hI
|$(H
L$ H
|$(H
|$(H
\$(H
l$0L
d$8L
l$@L
t$HL
|$PH
w`dH
w`dH
ATUH
S(dH
D$81
S0E1
l$ H
T$6H
D$8dH3
@[]A\
=[k&
l$ H
T$7H
C0H9CPuWH
C0H9CPuBH
C0H9CPuBH
C0H9CPuWH
C0H9CPuBH
C0H9CPuWH
w`dH
w`dH
d$ L
l$(L
t$0H
u H)
D$(1
u?L)
L$(dH3
0[]A\
D$H1
T$HdH3
\$XH
l$`L
d$hL
l$pH
H9] 
uLH)
 []A\
\$(H
l$0L
d$8L
l$@L
t$HL
|$PH
u H)
D$(1
u?L)
L$(dH3
0[]A\
D$H1
T$HdH3
\$XH
l$`L
d$hL
l$pH
H9] 
d$ L
l$(L
t$0H
u H)
D$(1
u?L)
L$(dH3
0[]A\
D$H1
T$HdH3
\$XH
l$`L
d$hL
l$pH
H9] 
\$(H
l$0L
d$8L
l$@L
t$HL
|$PH
u H)
D$(1
u?L)
L$(dH3
0[]A\
D$H1
T$HdH3
\$XH
l$`L
d$hL
l$pH
H9] 
d$ L
l$(L
t$0H
u H)
D$(1
u?L)
L$(dH3
0[]A\
D$H1
T$HdH3
\$XH
l$`L
d$hL
l$pH
H9] 
d$ L
l$(L
t$0H
u H)
D$(1
u?L)
L$(dH3
0[]A\
D$H1
T$HdH3
\$XH
l$`L
d$hL
l$pH
H9] 
d$ L
l$(L
t$0H
u H)
d$ L
l$(L
t$0H
u H)
D$(1
u@I)
L$(dH3
0[]A\
D$H1
T$HdH3
\$XH
l$`L
d$hL
l$pH
H9] 
d$ L
l$(L
t$0H
u H)
D$(1
u?L)
L$(dH3
0[]A\
D$H1
T$HdH3
\$XH
l$`L
d$hL
l$pH
H9] 
AWAVA
AUATUSH
D$PH
D$(H
t$pH
l$`H
T$(L
d$@H
t$ L
\$0H
[]A\A]A^A_
D$ H
D$ u
D$ H
D$ L
D$ L
D$ L
AWAVAUATI
-X"&
[]A\A]A^A_
=T!&
C0H9CPuBH
C0H9CPuVH
AWAVAUATI
[]A\A]A^A_
AWAVAUATI
[]A\A]A^A_
[]A\
ATUH
[]A\
ATUH
[]A\
D$CH
ATUH
[]A\
AWAVI
AUATUSH
[]A\A]A^A_
AWAVAUATI
[]A\A]A^A_
w0dH
w0dH
AWAVAUI
ATUSH
[]A\A]A^A_
AWAVAUI
ATUSH
[]A\A]A^A_
AWAVI
ATUH
D$h1
d$ H
D$0H
D$8H
D$@H
D$HH
D$PH
D$X~OH
D$(L
D$0A
D$8I
D$@I
D$HI
D$PI
D$XI
D$hdH3
x[]A\A]A^A_
D$ H
D$(H
D$0H
D$8H
D$@H
d$@I9
D$gA
H9\$
H9D$
AVAUATI
D$81
l$ H
D$7H
|$ H
H;=@
I9D$
D$8dH3
H[]A\A]A^A_
AUATI
D$81
H;O(
YK$H
L$8dH3
T$(H
@[]A\A]A^
H1C(
H1C(
AWAVAUATI
l$@dH
D$X1
8H9W
T$XdH3
h[]A\A]A^A_
|$PL
t$0L
d$ L
D$8L
AWAVAUATUSH
T$HH
L$(H
T$ H
|$HH
D$@H
T$`H
D$XH
T$hH
D$pH
T$PH
D$xH
t$ H
D$0H
L$(H
H;=4
t$`H
t$XH
t$hH
|$PH
T$pH
L$(I
T$0H
[]A\A]A^A_
|$8H
|$81
t$xH
|$H1
|$81
|$81
|$PH
AWAVI
ATUH
d$ H
D$0H
D$8H
D$@H
D$HH
D$PH
D$XH
D$`H
D$pH
D$(L
D$0A
D$8I
D$@I
D$HI
D$PI
D$XI
D$`I
D$hI
D$pA
[]A\A]A^A_
D$ H
D$(H
D$0H
D$8H
D$@H
D$PH
L$XH
d$XI9
Hk|$
H9L$
t*H9\$
d$ H
d$ H
AWAVAUATL
D$(1
T$'L
H)D$
L$(dH3
8[]A\A]A^A_
H;="
AVAUATI
D$81
l$ H
D$7H
|$ H
I9D$
D$8dH3
H[]A\A]A^A_
AUATI
D$81
H;O(
YK$H
L$8dH3
T$(H
@[]A\A]A^
H1C(
H1C(
AWAVAUATI
8H9W
[]A\A]A^A_
t$@L
D$HL
D$PH
D$ H
D$XH
D$(H
D$`H
D$pH
T$xH
D$x1
\$PH
t$`L
d$@L
D$ H
l$0H
T$vL
T$xdH3
D$(H
D$(H
I1D$(
D$81
l$ H
T$7H
T$8dH3
\$HH
l$PL
d$XL
l$`H
\$ H
l$(L
d$0H
l$ H
l$ H
AVAUI
ATUH
D$h1
t$ H
D$:H
D$@H
D$HH
D$PH
D$X~qf
D$8I
D$9A
D$:A
D$@I
D$HI
D$PI
D$XI
D$hdH3
x[]A\A]A^A_
$tiH
D$ H
D$(H
D$0H
D$8H
D$@H
d$@I9
H9T$
H9\$
AWAVI
AUATUSH
[]A\A]A^A_
|$hH
|$HH
|$0H
[]A\
|$HH
|$0H
|$hH
|$HH
|$0H
[]A\
|$HH
|$0H
D$H1
l$@H
T$8H
D$8H
D$HdH3
\$XH
l$`L
d$hL
l$pL
t$xL
l$0H
T$(H
AUATI
l$pI
D$`I
t$PI
\$XH
l$`H
\$PL
|$PH
|$`H
|$pH
uTH)
l$@H
L$ H
D$(A
[]A\A]A^A_
H9D$
\$0H
|$HH
AWAVI
D$h1
\$0H
T$gH
D$@L
|$@H
T$XH
\$ H
T$fH
|$P1
H9H w
H9H ryI
H9\$X
|$@H
H;=A
D$hdH3
x[]A\A]A^A_
|$@1
AWAVAUI
ATUSH
T$`H
D$`H
T$pH
D$hH
T$XH
T$ H
T$PH
T$@H
t$pH
T$hH
|$XH
H9=7
D$@H
D$0H
T$0H
D$HH
T$0H
D$xH
T$8D
T$ H
H9=~
t$(H
D$`H
D$@XH
T$@H;P
[]A\A]A^A_
D$@L
T$@H
D$@H
T$@9Z
T$PH
|$8H
T$HH
|$0H
D$@H
T$@H
T$@H
|$XH
|$8H
|$0H
H;=_
D$ H
[]A\
|$ H
D$ H
[]A\
|$ H
H;=c
H;=3
D$(1
T$&H
D$(dH3
T$'H
D$(1
T$&H
H;=I
D$(dH3
T$'H
AWAVAUATUSH
\$@H
t$(dH
d$@H
D$@H
l$PH
D$PH
l$ H
D$@H
D$PH
D$XH
T$(H
d$0H
T$?H
D$@H
D$PH
T$ H
l$PH
d$@H
[]A\A]A^A_
T$ H
l$PH
d$@H
T$ H
l$PH
AWAVAUATI
D$h1
D$PH
D$PH
t$PH
|$PH
H;=n
T$hdH3
x[]A\A]A^A_
t$8L
l$@L
|$H1
\$`1
l$0H
t$`L
l$ H
AWAVAUATUSH
\$0H
d$0H
D$0H
l$@H
D$@H
D$0H
D$@H
D$HH
d$ H
T$/H
t$(H
D$(H
D$0H
D$@H
l$@H
d$0H
[]A\A]A^A_
l$@H
d$0H
l$@H
AWAVAUATUSH
\$@H
t$(dH
d$@H
D$@H
l$PH
D$PH
l$ H
D$@H
D$PH
D$XH
T$(H
d$0H
T$?H
D$@H
D$PH
T$ H
l$PH
d$@H
[]A\A]A^A_
T$ H
l$PH
d$@H
T$ H
l$PH
t$PH
D$(dH
L$'H
t$0L
$H9C uHH
d$ H
AWAVAUATM
T$XdH
|$xH
t$PH
D$ t
L$0H
T$`H
L$8H
T$hH
L$@H
D$pH
T$HH
5'|%
L$XH
T$ H
t$PH
|$ H
|$,H
|$xH
D$XH
|$PH
T$0L
L$`H
D$0H
D$8H
L$8I
T$hH
D$@H
T$@I
5/u%
L$pH
|$HI
=)v%
[]A\A]A^A_
t$PA
|$xH
T$XH
|$ H
L$@H
T$pH
|$HH
L$8I
T$hH
L$0I
T$`H
D$XH
|$PE1
5<r%
5?p%
L$pH
D$8H
T$hH
L$0H
L$`H
AWAVAUATI
|$8H
D$@L
5Nb%
D$@H
D$PH
L$PH
|$8H
[]A\A]A^A_
T$8L
T$8L
t$PH
|$`H
T$PH
T$XH
t$PH
T$@H
t$HL
T$8L
T$hL
|$pH
AWAVI
AUATUSH
|$0H
L$8L
L$HD
l$PL
D$81
D$(H
T$HL
D$@L
|$0H
[]A\A]A^A_
-bO%
T$8H
D$(H
T$@H
T$@H
D$HH
D$0H
D$0H
T$(L
D$0H
T$(H
|$(H
D$0L
D$0tY
D$0u
D$0L
D$0f
D$0u
D$0f
D$0f
T$HH
T$@L
D$(H
T$8L
D$0f
D$0f
AWAVAUM
T$hH
t$hL
H97H
|$ H
L$(H
D$8I
T$8L
l$@H
D$0H
L$0H
D$hH
t$XH
5cE%
[]A\A]A^A_
T$@H
L$8H
T$(H
T$ H
t$(L
T$0H
l$pH
|$8H
t$hH
t$0H
T$ L
T$@L
T$(L
5`=%
|$HH
L$(I
T$@H
L$8L
T$(H
T$@H
|$ H
AVAUATUSH
L$8L
|$0H
L$XM
D$@dH
D$(H
l$`L
D$(H
L$XM
T$ L
D$8I
L$XL
D$HH
|$0H
[]A\A]A^A_
T$0L
56/%
%1-%
D$(I
T$(H
t$ I
D$(H
D$8I
T$8L
d$0H
D$@H
D$HH
t$0H
D$HH
t$XH
T$8H
|$8L
t$8L
T$(L
T$@H
t$0L
T$HL
5,*%
T$@H
|$@H
D$HtfH
D$Ht
D$Hu
D$Hu
D$Ht
D$Ht
D$Hf
D$Hf
D$Hf
D$Hf
D$Hf
D$HL
D$HL
D$Hu
D$Hu
D$Hf
T$@H
T$8L
T$(L
D$Hf
D$Hf
D$Hf
D$Hf
H;= '%
C0H9CP
C0H9CPu|H
AVAUATUL
D$x1
d$`H
T$ H
T$XH
51(%
5O(%
l$PL
D$(I
D$`I
D$`I
|$(L
5j&%
D$XH
T$ M
D$xdH3
[]A\A]A^A_
5Y%%
5D%%
5!%%
D$`1
T$8H
\$@H
T$wH
|$(L
C0H9CPuxH
C0H9CPupH
C0H9CP
C0H9CPu|H
AWAVI
AUATUSH
[]A\A]A^A_
AUATUH
l$ H
T$7dH
D$81
L$ M
t"L;
L$ M
~|L;
D$8dH3
H[]A\A]A^A_
T$ I
t$6L
D$x1
l$PH
T$wH
l$`H
|$PH
l$@H
T$vH
t$0L
l$(tp1
D$xdH3
T$(H
l$`f
fff.
l$ L
d$(L
l$0L
t$8L
|$@H
l$ H
d$(L
l$0H
ffffff.
=s	%
D$CH
l$ H
d$(L
l$0H
D$X1
|$@H
T$VH
d$ H
T$WH
t$0H
t$@H
T$XdH3
\$hH
l$pL
d$xL
D$CH
fffff.
AWAVAUATUH
<$dH
[]A\A]A^A_
|$ H
D$PL
L$(H
D$0H
L$ H
t$8H
|$(H
L$0H
H;D$P
T$XH
T$8H
|$ H
D$@H
D$@H
|$ H
T$ H
H;\$ 
AWAVAUATUSH
t$ H
l$pH
l$`H
[]A\A]A^A_
D$0I
T$0L
L$ H
D$(H
D$8H
L$8H
T$PL
D$PH
L$(H
L$ H
T$0H
D$0I
T$0L
L$ H
D$(H
L$(H
L$ H
T$0H
D$@L
D$@L
|$8H
T$0H
T$0L
T$0L
AVAUATI
T$ H
|$ H
t$xH
t$hH
D$ H)
D$ A
t$hH
t$xH
t$XH
t$8L
[]A\A]A^A_
l$XL
t$hH
t$hH
D$PH
|$pH
t$`L
\$@H
AVAUATA
D$(1
t}E1
L;c(sWH
L;c(r
D;cXr
D$(dH3
[]A\A]A^A_L
D$(1
T$(dH3
8[]A\A]A^A_
D$(1
$t5H
T$(dH3
t$ H
\$ H
l$(L
d$0L
l$8L
t$@H
D$81
t$0H
T$8dH3
D$0uTH
\$@H
l$HL
d$PH
J$dH
E;J u
H;G 
U0Hc
h\trH
l$ L
d$(L
l$0H
AUATI
D$(1
D$(dH3
8[]A\A]A^A_
D$(1
T$(dH3
\$8H
l$@L
d$HL
l$PL
t$XL
|$`H
H;X0f
D$0H
BHt~M
AVAUI
H;C 
[]A\A]A^
T$7H
D$81
T$8dH3
D$7u
\$@H
l$HL
d$PH
ffffff.
AVAUATI
t$,dH
D$x1
t$pL
E0I9
E0L9
D$xdH3
[]A\A]A^A_
D$0L
|$ L
t$pL
|$ I
D$81
D$8dL3
H[]A\A]A^A_
u.piecesI
_~IH
D$(1
t$ H
T$ L
D$(dH3
\$8H
l$@L
d$HL
l$PL
t$XL
|$`H
ffff.
D$H1
D$HdL3
X[]A\A]A^A_
u.piecesH
D$(.p
D$ E
_~QH
D$(1
t$ H
T$ A
D$(dH3
\$0H
l$8L
d$@L
l$HL
t$PH
ffffff.
l$ L
d$(L
l$0H
L$@D
D$x1
t$pH
t$hH
D$hH
L$pH
T$pL
L$XH
D$XC
D$`H
T$pM
D$xdH3
T$hH
L$@D
D$x1
t$pH
t$hH
D$hH
L$pH
T$pA
D$xdH3
T$pL
L$XH
D$XC
D$`H
AWAVAUATUH
[]A\A]A^A_
H9T$x
t$(A
H;p vG
D$PH
T$XL
D$`L
L$hL
D$PL
T$pL
L$hL
D$`H
T$XH
LcY0D
\$HH
D$PH
T$XL
D$`L
L$hL
D$PL
T$pL
L$hL
D$`H
T$XH
x0Lc
H+T$xL
D$xH
t$xH
H;S v
Hcp0
D$PH
T$XdL
D$HH
l$xA
D$DH
L$PM
t$XH
|$HH
L$hH
T$pA
T$8H
L$0D
D$(H
L$0H
L$HH
D$hH
L$pE1
t$DH
L$xH
T$pH
L$xH
ffffff.
D$\H
D$`H
D$hdH
D$x1
D$xdH3
D$hD
D$\M
D$`H
T$xdH3
t$hH
D$`M
D$\1
u H)
T$HI
T$hH
t$`H
D$\I
T$ H
T$PL
T$Pu
T$xdH3
M H)
U H)
E H)
M H)
M H)
U H)
U H)
U H)
U H)
U H)
M H)
U H)
M H)
U H)
U H)
U H)
U H)
M H)
U H)
E H)
M H)
U H)
T$HL
D$8L
\$PL
T$HL
D$8D
L$PL
T$HH
L$PL
D$8H
D$@L
D$8D
\$PL
T$HL
L$PL
T$HL
D$@L
D$8D
\$PL
D$@L
D$8D
\$PL
D$@L
D$8D
L$PL
D$@L
D$8D
L$PL
D$@L
D$8D
\$PL
D$@L
D$8D
\$PL
D$@L
D$8D
L$PL
D$@L
D$8D
\$PL
D$@L
D$8D
\$PL
T$HL
T$HL
D$@L
D$8D
\$PL
L$PL
T$HL
D$@L
D$8D
\$PL
D$@L
D$8D
\$PL
T$HL
C0H9
C0H9
L$\I
T$PI
=e~$
5'~$
fff.
fffff.
fffff.
AVAUATUH
mXSH
d$pH
|$pL
t$`L
|$`H
t$PL
|$PH
t$@L
|$@H
t$0L
|$0H
l$ H
|$ H
[]A\A]A^
=7u$
=st$
=Ct$
ffffff.
AVAUATUSH
|$ H
t$ H
l$`L
d$P1
D$pH
T$(H
D$0H
|$PH
|$`H
|$pH
D9t$
[]A\A]A^A_
t$@H
|$@H
=Po$
=#o$
AWAVAUATUSH
l$pH
|$ H
t$8dH
T$pH
D$(H
T$(H
D$pH
D$pH
D$xH
D$0H
|$ 1
|$ L
D$pA
D$pH
D$ H
T$0H
T$nH
d$PH
\$`H
D$PL
|$PH
|$8H
|$`H
H;={k$
H9=Wk$
D$pH
T$(H
D$pH
[]A\A]A^A_
d$@H
\$`H
D$@L
|$@H
H;=xj$
\$`H
=Ki$
D$xuSH
T$(H
D$pH
=nh$
AWAVAUATUSH
T$ H
|$ L
t$ H
T$ H
T$(H
t$ H
C H)
H;D$
t$0H
|$0H
T$`L
D$PH
t$@H
|$@H
|$PH
|$`H
l$pH
|$pH
[]A\A]A^A_
=v^$
=4^$
|$ H
=L]$
= ]$
=c\$
=t[$
=H[$
=vZ$
=DZ$
fffff.
t$`L
d$PH
l$@dH
D$PH
l$@L
|$0H
D$ L
|$ H
|$0H
|$@H
|$PH
|$@H
|$PH
=YW$
=,W$
AWAVAUATUSH
D$81
l$ A
t$,A!
t$ A!
t$(A!
t$$A!
t$(A1
t$$1
D$8dH3
H[]A\A]A^A_
AWAVAUATA
=OS$
?~_H
D$PL
[]A\A]A^A_
D$PL
t$@H
D$X1
D$XdH3
=qP$
53P$
ffff.
DD$0H
l$ L
d$(L
l$0L
t$8L
|$@H
l$ L
d$(L
l$0L
t$8L
|$@H
T$ H
DT$xH
=yE$
T$ H
DT$xH
=YC$
D$(1
D$(dH3
\$0H
l$8L
d$@H
AWAVAUL
l$`dH
T$pH
|$`H
-yA$
d$@L
l$0L
t$PL
|$0H
|$@H
d$ L
T$ H
t$pH
|$ H
|$PH
|$pH
[]A\A]A^A_
-H>$
|$ 1
=v8$
-y;$
=Y9$
=~:$
=H:$
fff.
AVAUATUSH
|$(H
[]A\A]A^A_
|$HH
|$HH
|$0H
T$(H
L$(H
|$@H
T$`H
T$81
L$ H
T$PH
H;D$`
T$hH
H;P8|
ugH9P8
|$0H
|$0H
|$0H
H9P8
|$ L
|$8H
|$@H
L$8H
D$ H
T$PH
L$XH
H;D$`
T$hH
H;P8|
H9P8|:L
H9P8}
|$ L
|$ H
H+k0
T$(L
|$0H
|$0H
|$0H
|$0H
|$ L
=	.$
=U-$
|$@H
|$HH
|$0H
|$0H
|$0H
=\+$
AWAVL
l$PdH
D$x1
D$`L
|$PL
-.*$
-U)$
t$`H
l$0L
d$ L
|$@L
|$ H
|$0H
t$@H
t$@H
t$`H
|$`H
D$xdH3
[]A\A]A^A_
=N $
|$@H
|$`H
=R#$
=U"$
=C!$
d$ L
l$(L
t$0H
R8H9Q
AWAVAUATI
[]A\A]A^A_
=u#$
57#$
ffff.
\$ H
l$(L
d$0H
AWAVAUI
ATUH
D$h1
T$gI
D$PH
D$@H
T$fH
t$P1
T$eH
t$0H
|$0H
t$PI
d$ H
|$ H
|$@H
|$PH
T$hdH3
x[]A\A]A^A_
AWAVAUATUSH
|$@I
D$@1
l$0H
T$OH
\$ H
|$@H
|$ H
|$0H
T$@H
~zHc
|$@H
[]A\A]A^A_
T$?H
\$0L
t$0H
t$ L
|$ H
|$ H
|$0H
AWAVAUATI
D$(1
D$'L
I;|$
D$(dH3
8[]A\A]A^A_
AWAVAUATUH
[]A\A]A^A_
l$PH
|$PH
D$0H
D$0H
T$0L
\$0H;\$8
t$`L
|$pH
T$ H
|$pH
H;\$8
|$`H
ffff.
AVAUATUSH
D$H1
\$(H
D$$H
H9D$
t$(H
t$8H
\$0H
\$0A
t$8H
A8H)
A8H)
APH)
@PH)
|$0H
|$0H
\$8H
|$0H
|$0A
\$8H
D$HdH3
X[]A\A]A^A_
AWAVAUATUH
\$`H
|$(dH
d$`L
D$`H
D$`I
D$hI
t$ H
t$$H
T$_H
D$@H
l$PH
D$@H
|$@H
t$PH
|$PH
D$`I
d$`L
[]A\A]A^A_
T$0H
l$PH
D$0H
|$0H
l$PH
d$`L
AWAVAUATUSH
l$`H
|$(dH
d$`L
D$`H
D$`I
D$hI
t$ H
t$$H
t$ H
T$_H
T$@H
\$PH
D$@H
|$@H
t$PH
|$PH
D$`I
d$`L
[]A\A]A^A_
D$0H
\$PH
D$0H
|$0H
\$PH
d$`L
AWAVI
AUATUSH
|$(H
D$ H
T$ H
D$@H
l$PH
t$@L
l$PH
D$@L
|$@H
t$PH
|$(H
L$tH
T$`L
L$hL
|$PH
t$hL
l$tH
D$@H
T$ H
[]A\A]A^A_
t$0L
l$PH
D$0L
|$0H
l$PH
l$PI
T$ H
AWAVI
AUATUSH
|$(H
D$ H
T$ H
D$@H
l$PH
t$@L
l$PH
D$@L
|$@H
t$PH
|$(H
L$tH
T$`L
L$hL
|$PH
t$hL
l$tH
D$@H
T$ H
[]A\A]A^A_
t$0L
l$PH
D$0L
|$0H
l$PH
l$PI
T$ H
AWAVAUATUSH
t$`H
D$XH
T$DH
\$(H
D$0H
\$8H
D$`H
D$xH
D$lH
|$xH
|$`H
D$$H)
[]A\A]A^A_
AWAVAUATUSH
t$pH
D$\H
L$ H
D$PH
H9D$P
D$PH
L$PH
L$(H
L$`f
D$8H
D$@H
D$HH
D$pH
D$|H
|$pH
D$0H)
D$ H
L$PH
F8H)
D$0H
T$8H
D$@H
D$pH
L$ H
T$(H
D$|H
|$pH
D$ A
D$(H
F8H)
NPH)
T$0H
T$8H
T$@H
T$Hf.
D$pH
L$ H
T$(H
D$|H
|$pH
D$ A
D$(H
[PH)
L$ H
[]A\A]A^A_
fffff.
AWAVAUATUSH
D$pL
|$@L
D$ H
D$(H
D$0H
D$8f
l$@L
l$XL
T$|H
D$xH
D$LH
|$`H
|$XH
|$@H
|$pH
[]A\A]A^A_
AWAVAUATUSH
D$pL
|$@L
D$ H
D$(H
D$0H
D$8f
l$@L
l$XL
T$|H
D$xH
D$LH
|$`H
|$XH
|$@H
|$pH
[]A\A]A^A_
AWAVAUATUSH
D$pL
|$@L
D$ H
D$(H
D$0H
D$8f
l$@L
l$XL
T$|H
D$xH
D$LH
|$`H
|$XH
|$@H
|$pH
[]A\A]A^A_
AVAUATUSH
l$@H
t$pI
D$ H
D$(H
D$0H
D$8f
d$@L
d$XL
T$|H
D$xH
D$|H
|$`H
|$XH
|$@H
|$pH
[]A\A]A^A_
wpAUL
oHATUSH
d$0dH
D$X1
l$ L
l$@H
|$ H
|$0H
|$@H
|$HH
T$WH
T$VH
|$HH
|$HH
|$HH
|$HH
|$HH
|$HH
|$HH
|$HH
|$HH
|$@H
D$XdH3
`[]A\A]A^
l$ H
ffff.
D$(1
D$(dH3
\$8H
l$@L
d$HL
l$PH
D$(1
D$(dH3
\$8H
l$@L
d$HL
l$PH
fffff.
-YR#
%RR#
l$ L
t$(L
|$0H
basic_string::_S_construct NULL not valid
Too many interrupts received, exiting.
Copyright (C) 2005-2009 Red Hat, Inc. and others
This is free software; see the source for copying conditions.
Usage: stap [options] FILE         Run script in file.
   or: stap [options] -            Run script on stdin.
   or: stap [options] -e SCRIPT    Run given script.
   or: stap [options] -l PROBE     List matching probes.
   or: stap [options] -L PROBE     List matching probes and local variables.
   --         end of translator options, script options follow
   -p NUM     stop after pass NUM 1-5, instead of 
              (parse, elaborate, translate, compile, run)
   -v         add verbosity to all passes
   --vp {N}+  add per-pass verbosity [
   -k         keep temporary directory
   -u         unoptimized translation
   -w         suppress warnings
   -P         prologue-searching for function probes
   -b         bulk (percpu file) mode
   -s NUM     buffer size in megabytes, instead of 
   -I DIR     look in DIR for additional .stp script files
   -D NM=VAL  emit macro definition into generated C code
   -R DIR     look in DIR for runtime, instead of
   -r DIR     cross-compile to kernel with given build tree; or else
   -r RELEASE cross-compile to kernel /lib/modules/RELEASE/build, instead of
   -m MODULE  set probe module name, instead of 
   -o FILE    send script output to file, instead of stdout. This supports
              a subset of strftime(3) (%%,%C,%Y,%y,%m,%d,%e,%F,%H,%I,%j,%k,
              %l,%M,%S,%R,%T,%u,%w) for FILE.
   -c CMD     start the probes, run CMD, and exit when it finishes
   -x PID     sets target() to PID
   -F         run as on-file flight recorder with -o.
              run as on-memory flight recorder without -o.
   -S size[,n] set maximum of the size and the number of files.
   -d OBJECT  add unwind/symbol data for OBJECT file
   -t         collect probe timing information
   -q         generate information on tapset coverage
              overlook context of bad $ variables
Warning: failed to create systemtap data directory ("
Warning: failed to create cache directory ("
hVMvtp:I:e:o:R:r:m:kgPc:x:D:bs:uqwl:d:L:FS:
Listing (-l) mode implies pass 2.
Invalid pass number (should be 1-5).
Only one script can be given on the command line.
_abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789
Invalid module name (must only be composed of characters [_a-zA-Z0-9]).
/include/config/kernel.release
Invalid buffer size (should be 1-4095).
You can't specify multiple --kmap options.
Invalid --vp argument: it takes 1 to 5 digits.
Internal error parsing command arguments.
-M option is valid only for bulk (relayfs) mode.
You can't specify -M, -b and -o options together.
You can't specify -c and -x options together.
You can't specify --kelf and --kmap together.
WARNING: kernel release/architecture mismatch with host forces last-pass 4.
ERROR: cannot create temporary directory ("
' cannot be run directly as a session script.
Pass 1: parsed user script and 
Try again with another '--vp 1' option.
Try again with another '--vp 01' option.
Pass 3: translated to C into "
Try again with another '--vp 001' option.
Try again with another '--vp 0001' option.
Try again with another '--vp 00001' option.
Cleanup command failed, status: 
SystemTap translator/driver 
(version 
0.9.5
non-git sources
Options:
   -h         show help
   -V         show version
 [set]
   -g         guru mode
, in addition to
              
   --skip-badvars
main.cxx
a->alias_names.size() >= 1
second->locations.size() >= 1
# global embedded code
# globals
# functions
  # locals
# probes
/lib/modules/
/build
stap_
stapconf_
SYSTEMTAP_TAPSET
/usr/share/systemtap
/tapset
SYSTEMTAP_RUNTIME
/runtime
SYSTEMTAP_DIR
/.systemtap
"): 
, disabling cache support.
/cache
SYSTEMTAP_COVERAGE
basic_string::substr
basic_string::erase
Truncating module name to '
Module name cannot be empty.
Missing 
__TBD__
/boot/System.map-
A script must be specified.
Session arch: 
 release: 
TMPDIR
/tmp
/stapXXXXXX
Created temporary directory "
/*.stp
Searched '
found 
usage error: tapset file '
# parse tree dump
 library script(s) in 
usr/
sys/
real ms.
Pass 1: parse failed.  
Pass 2: analyzed script: 
 probe(s), 
 function(s), 
 embed(s), 
 global(s) in 
Pass 2: analysis failed.  
" in 
Pass 3: translation failed.  
Pass 4: compiled C into "
Pass 4: compilation failed.  
Copying 
Copy failed ("
" to "
Pass 5: starting run.
Pass 5: run completed in 
Pass 5: run failed.  
Keeping temporary directory "
rm -rf 
Running 
kelf
kmap
ignore-vmlinux
ignore-dwarf
void printscript(systemtap_session&, std::ostream&)
junk
embedded-code
keyword
unknown token
expected comparison operator
<input>
vector::_M_range_insert
 at 
parse error: 
	at: 
	saw: 
 EOF
bad lexical cast
kernel_v
kernel_vr
expected string literal
arch
expected '==' or '!='
01234567
command line argument index 
 out of range [1-
global
foreach
delete
while
continue
next
unexpected end-of-file
expected 'continue'
expected 'break'
expected 'next'
expected '%{'
expected number
expected 
 or 
expected '
expected 'global'
expected identifier
duplicate global name
array size out of range
@cast
@avg
@count
@sum
@min
@max
unknown statistic operator 
println
@hist_linear
@hist_log
parse.cxx
expected ',' or ')'
!hop != !sym
expected ',' or ']'
expected value
expected ')'
expected ':'
expected 'delete'
expected 'return'
expected identifier or '*'
expected '('
expected 'foreach'
multiple sort directives
expected 'in'
expected statement
expected '{'
expected 'function'
duplicate function name
expected 'string' or 'long'
expected 'probe'
Input file '
' is empty or missing.
 parse error(s).
expected 'while'
expected 'for'
expected ';'
expected 'if'
expression* parser::parse_symbol()
wildcard not allowed with order comparison operators
expected string literal as right value
expected number literal as right value
expected 'arch' or 'kernel_v' or 'kernel_vr'
             or comparison between strings or integers
invalid nested substitution of command line arguments
incomplete condition after '%('
expected '%?' marker for conditional
incomplete conditional - missing '%:' or '%)'
incomplete conditional - missing %)
found 'next' not in probe context
number invalid or out of range
expected literal string or number
embedded code in unprivileged script
only scalar globals can be initialized
base histogram operator where expression expected
unexpected comma-separated expression list
found 'return' not in function context
expected one of '. , ( ? ! { = +='
probe point alias name cannot be optional nor sufficient
expected probe point specifier
expected 'probe', 'global', 'function', or '%{'
11parse_error
delete 
return 
for (
staptree.h
!targets.empty()
clearok || dst
staptree.cxx
!active_lvalues.empty()
print_char
current_function
invalid element
avg(
count(
sum(
max(
hist_linear(
hist_log(
 if (
[...]
symbol without referent
# file 
global 
else 
vector::_M_fill_insert
i->type != conv_unspecified
!i->literal_string.empty()
inconsistent arity
curr.type == conv_literal
hist
foreach ([
] in 
 limit 
Failed to classify indexable
virtual update_visitor::~update_visitor()
T update_visitor::require(T, bool) [with T = indexable*]
T update_visitor::require(T, bool) [with T = symbol*]
T update_visitor::require(T, bool) [with T = hist_op*]
T update_visitor::require(T, bool) [with T = expression*]
T update_visitor::require(T, bool) [with T = arrayindex*]
T update_visitor::require(T, bool) [with T = statement*]
T update_visitor::require(T, bool) [with T = expr_statement*]
virtual void varuse_collecting_visitor::visit_embeddedcode(embeddedcode*)
void visitor::pop_active_lvalue()
void indexable::visit_indexable(visitor*)
void indexable::print_indexable(std::ostream&) const
void hist_op::print(std::ostream&) const
static std::vector<print_format::format_component, std::allocator<print_format::format_component> > print_format::string_to_components(const std::string&)
static std::string print_format::components_to_string(const std::vector<print_format::format_component, std::allocator<print_format::format_component> >&)
curr.type == conv_unspecified || curr.type == conv_literal
invalid or missing conversion specifier
trailing incomplete print format conversion
Expecting symbol or histogram operator
17deep_copy_visitor
14update_visitor
16throwing_visitor
25varuse_collecting_visitor
31functioncall_traversing_visitor
18traversing_visitor
11probe_alias
5probe
14next_statement
18continue_statement
15break_statement
16delete_statement
16return_statement
12if_statement
14expr_statement
14null_statement
12foreach_loop
8for_loop
5block
12embeddedcode
9statement
12functiondecl
7vardecl
10symboldecl
7hist_op
7stat_op
12print_format
12functioncall
10arrayindex
7cast_op
13target_symbol
6symbol
9indexable
10assignment
18ternary_expression
13concatenation
10comparison
8array_in
16logical_and_expr
15logical_or_expr
12post_crement
11pre_crement
16unary_expression
17binary_expression
14literal_number
14literal_string
10expression
7visitor
7literal
14semantic_error
 /* <- 
elaborate.cxx
derivations.size() > 0
derivations[0] == use
duplicate probe point pattern
vector::_M_insert_aux
Changing 
 reference to 
 reference
inappropriate
unresolved cast expression
Resolution problem with 
other
unresolved arity-
 global array 
no current probe/function
Eliding unused unary 
source: 
Eliding unused typecast 
semantic error: 
fd->name == name
where != s.functions.end()
WARNING: 
probe condition
 with type mismatch (
 vs. 
 type first inferred here (
e->type == pe_string
function call modifies var '
' during 'foreach' iteration
eliding unused function '
Eliding unused function 
Eliding unused binary 
eliding unused variable '
read-only local variable '
 in function 
read-only global variable '
Eliding assignment to 
alias component 
 contains illegal parameter
side-effect-free probe '
side-effect-free function '
Eliding unused print 
 with unresolved type
e->referent != 0
 uses invalid operator
 with invalid type 
array->referent != 0
false
wanted != pe_unknown
Flattening nested block 
(string)
(number)
(...)
pos <= loc->components.size()
 (follow:
wildcard '
' matched '
no match
Probe point 
 sufficient, skipped
 while resolving probe point 
="%#s"\n
=%#x\n
 @count=0x0\n
idx%d
"%#s"
no probes found
e->params.size() == 3
e->htype == hist_log
e->params.size() == 0
Expecting symbol or array index expression
Assignment to read-only histogram bucket
derived_probe with no locations
derived_probe with too many locations
invalid operand of delete expression
unresolved target-symbol expression
unresolved array in delete statement
probe condition must not reference undeclared global
invalid use of wildcard probe point component
probe condition must not reference function
' modified during 'foreach' iteration
Eliding side-effect-free foreach statement 
Eliding side-effect-free null statement 
Creating if statement from unused ternary expression 
Creating if statement from unused logical-and 
Eliding side-effect-free expression 
Creating if statement from unused logical-or 
Eliding side-effect-free for statement 
Eliding side-effect-free if statement 
Creating simple evaluation from if statement 
Inverting the condition of if statement 
Eliding unused local variable 
Eliding unused global variable 
 while registering probe alias 
Eliding side-effect-free function call 
unsupported assignment operator 
Unspecified conversion in print operator format string
Wrong number of args to formatted print operator
Eliding side-effect-free empty block 
Eliding side-effect-free singleton block 
probe point truncated at position 
probe point mismatch at position 
 didn't find any wildcard matches
 @count=%#x @min=%#x @max=%#x @sum=%#x @avg=%#x\n
probe condition must not modify any variables
probe condition must not include impure embedded-C
unable to infer statistic parameters for global '
multiple histogram types declared on '
Recursive loop in alias expansion of 
26duplicate_function_remover
22void_statement_reducer
21dead_stmtexpr_remover
23dead_assignment_remover
13derived_probe
19typeresolution_info
18symresolution_info
virtual update_visitor::~update_visitor()
virtual void typeresolution_info::visit_print_format(print_format*)
virtual void delete_statement_typeresolution_info::visit_symbol(symbol*)
virtual void typeresolution_info::visit_foreach_loop(foreach_loop*)
virtual void typeresolution_info::visit_functioncall(functioncall*)
virtual void typeresolution_info::visit_arrayindex(arrayindex*)
virtual void typeresolution_info::visit_symbol(symbol*)
virtual void typeresolution_info::visit_literal_string(literal_string*)
virtual void typeresolution_info::visit_literal_number(literal_number*)
void semantic_pass_opt6(systemtap_session&, bool&)
T update_visitor::require(T, bool) [with T = statement*]
T update_visitor::require(T, bool) [with T = expression*]
void semantic_pass_opt1(systemtap_session&, bool&)
functiondecl* symresolution_info::find_function(const std::string&, unsigned int)
virtual void symresolution_info::visit_arrayindex(arrayindex*)
virtual void symresolution_info::visit_foreach_loop(foreach_loop*)
void systemtap_session::print_token(std::ostream&, const token*)
virtual void stat_decl_collector::visit_hist_op(hist_op*)
bool alias_expansion_builder::checkForRecursiveExpansion(probe*)
void match_node::find_and_build(systemtap_session&, probe*, probe_point*, unsigned int, std::vector<derived_probe*, std::allocator<derived_probe*> >&)
derived_probe::derived_probe(probe*, probe_point*)
derived_probe::derived_probe(probe*)
T update_visitor::require(T, bool) [with T = logical_and_expr*]
36delete_statement_typeresolution_info
35delete_statement_symresolution_info
38no_var_mutation_during_iteration_check
21mutated_var_collector
19stat_decl_collector
14symbol_fetcher
23alias_expansion_builder
21derived_probe_builder
19alias_derived_probe
translate.h
tablevel == 0
translate.cxx
hop.htype == hist_linear
hop.params.size() == 3
hop.htype == hist_log
hop.params.size() == 0
/* null */;
c->actionremaining -= 
(void) 
((int64_t)
union {
invalid lvalue type
INT64
STRING
STAT
int64_t
string_t
Stat
cannot expand unknown type
expected numeric types
(int64_t)(0 
 (uint64_t)(
expected numeric condition
expected matching types
) ? (
) : (
expected string types
strncmp (
, MAXSTRINGLEN
unexpected type
cannot 'next' from function
unresolved symbol
unresolved symbol: 
static void function_
strlcat (
strlcpy (
static 
struct stat_data *
#ifdef STP_TIMING
#endif
cannot 'break' outside loop
#include "alloc.c"
#define VALUE_TYPE 
#define KEY
#include "pmap-gen.c"
#include "map-gen.c"
#undef VALUE_TYPE
#undef KEY
#include "map.c"
PMAP s_
rwlock_t s_
_lock;
atomic_t s_
_lock_skip_count;
#endif
#undef 
module_param_named (
, int64_t, 0);
module_param_string (
, MAXSTRINGLEN, 0);
expected numeric type
 locks 
write_unlock (& global.s_
_lock);
read_unlock (& global.s_
unlock_: ;
nothing
invalid reference to array
non-number <<< expression
_stp_pmap_clear (
_stp_map_clear (
_stp_stat_clear (
[0] = '\0';
string assignment operator 
lval.type() == pe_stats
rval.type() == pe_long
res.type() == pe_long
_stp_stat_add (
*error*
invalid post-mode operator
if (unlikely(!
)) {
_stp_mod64
_stp_div64
 (NULL, 
unknown macop for assignment
#define STAP_SESSION_ERROR 2
struct context {
atomic_t busy;
const char *probe_point;
int actionremaining;
unsigned nesting;
string_t error_buffer;
const char *last_error;
const char *last_stmt;
struct pt_regs *regs;
unsigned long *unwaddr;
int regparm;
va_list *mark_va_list;
const char * marker_name;
const char * marker_format;
void *data;
Stat *statp;
#ifdef STP_OVERLOAD
cycles_t cycles_base;
cycles_t cycles_sum;
c->statp = & time_
# needs_global_locks: 
_locals {
struct function_
/* no return value */
 __retvalue;
} function_
} locals [MAXNESTING];
#include "stat.c"
unsigned numtrylock = 0;
(void) numtrylock;
write
_trylock (& global.s_
_lock)
while (! 
ndelay (TRYLOCKDELAY);
atomic_inc (& skipped_count);
atomic_inc (& global.s_
_lock_skip_count);
goto unlock_
if (0) goto unlock_;
__tmp
pmap
unknown type of map
_stp_pmap_get_agg(
 >= 0)
 && (
 = _stp_
_new_
 == NULL) rc = -ENOMEM;
, HIST_NONE
, HIST_LINEAR
, HIST_LOG
ty == pe_stats
->hist))
->hist.buckets)
 type unsupported
cannot 'return' from probe
return type mismatch
l->__retvalue
need rvalue for assignment
unexpected reference to array
_stp_key_get_int64 (
); if (! v) v = ""; v; })
illegal key type
max(min(
c->last_stmt = 
operator not yet implemented
stap-symbols.h
#include 
SYSTEMTAP_DEBUGINFO_PATH
cannot open dwfl
dwfl_getmodules
modname.length() != 0
cannot create dwfl for 
& _stp_module_
#ifndef MAXNESTING
#define MAXNESTING 10
#ifndef MAXSTRINGLEN
#define MAXSTRINGLEN 128
#ifndef MAXACTION
#define MAXACTION 1000
#ifndef MAXTRYLOCK
#define MAXTRYLOCK MAXACTION
#ifndef TRYLOCKDELAY
#define TRYLOCKDELAY 100
#ifndef MAXMAPENTRIES
#define MAXMAPENTRIES 2048
#ifndef MAXERRORS
#define MAXERRORS 0
#ifndef MAXSKIPPED
#define MAXSKIPPED 100
#ifndef MINSTACKSPACE
#define MINSTACKSPACE 1024
#ifndef INTERRUPTIBLE
#define INTERRUPTIBLE 1
#ifndef STP_OVERLOAD_INTERVAL
#ifndef STP_NO_OVERLOAD
#define STP_OVERLOAD
#define STP_BULKMODE
#define STP_TIMING
#define STP_PERFMON
#include "runtime.h"
#include "regs.c"
#include "stack.c"
#include "regs-ia64.c"
#include "stat.c"
#include <linux/string.h>
#include <linux/timer.h>
#include <linux/sched.h>
#include <linux/delay.h>
#include <linux/profile.h>
#include <linux/random.h>
#include <linux/vermagic.h>
#include <linux/utsname.h>
#include <linux/version.h>
#include "loc2c-runtime.h" 
#ifndef read_trylock
static struct {
} global = {
systemtap_module_exit ();
MODULE_LICENSE("GPL");
 elided, duplicates 
static void 
_locals * __restrict__ l =
& c->locals[0].
(void) l;
CATCH_DEREF_FAULT ();
out:
_stp_print_flush();
dump_unwindsyms 
 index=
 base=0x
syments
Found build-id in 
, length 
, end at 0x
dwfl_module_relocations
_stext
dwfl_module_relocate_address
secname != __null
.dynamic
n == 0
.debug_frame
static uint8_t _stp_module_
_unwind_data[] = 
static struct _stp_symbol 
_symbols_
#ifdef STP_NEED_SYMBOL_DATA
  { 0x
_sections[] = {
.name = 
.symbols = _stp_module_
)/sizeof(struct _stp_symbol)
.path = 
.dwarf_module_base = 0x
.unwind_data = 
_unwind_data, 
.unwind_data_len = 
#else
.unwind_data = NULL,
.unwind_data_len = 0,
.unwind_hdr = NULL,
.unwind_hdr_len = 0,
.unwind_is_ehframe = 0,
.sections = _stp_module_
_sections
_sections)/
sizeof(struct _stp_section),
.build_id_bits = "
.build_id_len = 
.build_id_offset = 0x
.build_id_len = 0,
.notes_sect = 0,
.absolute
int holdon;
int i=0, j=0;
(void) i;
(void) j;
synchronize_sched();
do {
int i;
holdon = 0;
for (i=0; i < NR_CPUS; i++)
if (cpu_possible (i) && 
holdon = 1;
yield ();
} while (holdon);
_stp_pmap_del (
_stp_map_del (
_stp_stat_del (
unsupported deallocator for 
free_percpu (contexts);
if (likely (time_
const char *probe_point = 
const char *decl_location = 
if (stats->count) {
_stp_stat_del (time_
skipped probes: %d\n", 
int ctr;
, ctr);
{ int rc = 
size limit (
"; goto out; }}
exists
((uintptr_t)
) != (uintptr_t) 0)
 = _stp_stat_init (
unsupported stats type for 
unsupported initializer for 
_locals * 
#define CONTEXT c
#define THIS l
if (0) goto out;
} else {
c->nesting ++;
#define return goto out
#undef return
c->nesting --;
#undef CONTEXT
#undef THIS
int rc = 0;
const char *probe_point = "";
if (strcmp (release, 
rc = -EINVAL;
if (rc) goto out;
(void) probe_point;
if (contexts == NULL) {
if (rc) {
_stp_error ("global variable 
 allocation failed");
rwlock_init (& global.s_
_stp_print_kernel_info(
return rc;
top_
continue_
break_
if (! (
)) goto 
; /* dummy statement */
struct map_node *
Invalid indexing of histogram
({ char *v = 
if (!v) v = ""; v; })
_stp_map_start (
_stp_map_iter (
[0] ? 
 : NULL))
invalid length argument list
function actual argument copy
(void) 0;
c->locals[c->nesting+1]
.function_
.__retvalue;
invalid array reference
array index type mismatch
e->indexes.size() == 1
array index copy
 = _stp_stat_get (
if (unlikely (
 == NULL))
 || 
->count == 0) {
_stp_div64(NULL, 
->sum, 
->count)
->count
->sum
->min
->max
foreach limit
_stp_pmap_agg (
if (unlikely(NULL == 
_stp_map_sortn (
_stp_map_sort (
 = 0LL;
++ >= 
s->indexes.size() == 1
 = 0; 
++) { 
idx.size() == 1
idx[0].type() == pe_long
->histogram[
e->type == pe_stats
rvalue->type == pe_long
} else
_stp_stat_print_histogram (
%s\n
"\n"
deref_buffer (0, 
_stp_print_char (
_stp_print (
((int64_t)0LL)
_stp_printf (
_stp_snprintf (
, MAXSTRINGLEN, 
, (int)
, (char*)(uintptr_t)
+:.debug:/usr/lib/debug:build
hop.params[0] == sd.linear_low
hop.params[1] == sd.linear_high
hop.params[2] == sd.linear_step
indent > 0 || tablevel >= (unsigned)-indent
if (unlikely (c->actionremaining <= 0)) {
c->last_error = "MAXACTION exceeded";
array type is neither string nor long
array key is neither string nor long
cannot translate general cast expression
cannot translate general target-symbol expression
 (struct context * __restrict__ c);
_lock_skip_count = ATOMIC_INIT(0),
cannot 'continue' outside loop
attempt to use scalar where map expected
unknown lvalue type in assignment
non-stats left operand to <<< expression
non-number right operand to <<< expression
Cannot delete unknown expression type
post assignment on strings not supported
c->last_error = "division by 0";
assignment type not yet implemented
unsupported c_expression token type
typedef char string_t[MAXSTRINGLEN];
#define STAP_SESSION_STARTING 0
#define STAP_SESSION_RUNNING 1
#define STAP_SESSION_STOPPING 3
#define STAP_SESSION_STOPPED 4
static atomic_t session_state = ATOMIC_INIT (STAP_SESSION_STARTING);
static atomic_t error_count = ATOMIC_INIT (0);
static atomic_t skipped_count = ATOMIC_INIT (0);
static atomic_t skipped_count_lowstack = ATOMIC_INIT (0);
static atomic_t skipped_count_reentrant = ATOMIC_INIT (0);
static atomic_t skipped_count_uprobe_reg = ATOMIC_INIT (0);
static atomic_t skipped_count_uprobe_unreg = ATOMIC_INIT (0);
struct kretprobe_instance *pi;
static void *contexts = NULL; /* alloc_percpu */
&& (++numtrylock < MAXTRYLOCK))
if (unlikely (numtrylock >= MAXTRYLOCK)) {
iterating over unknown reference type
fetching aggregate of non-parallel map type
sd.type != statistic_decl::none
unexpected concatenation operator
({ char *v = _stp_key_get_str (
, (int64_t)64LL), (int64_t)0LL))
static struct _stp_module *_stp_modules [] = {
static unsigned _stp_num_modules = 
missing unwind/symbol data for module '
#ifndef MAXACTION_INTERRUPTIBLE
#define MAXACTION_INTERRUPTIBLE (MAXACTION * 10)
#define STP_OVERLOAD_INTERVAL 1000000000LL
#ifndef STP_OVERLOAD_THRESHOLD
#define STP_OVERLOAD_THRESHOLD 500000000LL
#define read_trylock(x) ({ read_lock(x); 1; })
static int probe_start (void) {
return systemtap_module_init () ? -1 : 0;
static void probe_exit (void) {
MODULE_DESCRIPTION("systemtap-generated probe");
static __cacheline_aligned Stat 
 (struct context * __restrict__ c) 
array locals not supported, missing global declaration?
unsupported local variable type
dwfl_module_relocate_address extra_offset
Found kernel _stext extra offset 0x
#if defined(STP_USE_DWARF_UNWINDER) && defined(STP_NEED_UNWIND_DATA)
#endif /* STP_USE_DWARF_UNWINDER && STP_NEED_UNWIND_DATA */
#endif /* STP_NEED_SYMBOL_DATA */
static struct _stp_section _stp_module_
.num_symbols = sizeof(_stp_module_
static struct _stp_module _stp_module_
#endif /* STP_USE_DWARF_UNWINDER && STP_NEED_UNWIND_DATA*/
.num_sections = sizeof(_stp_module_
static void systemtap_module_exit (void) {
if (atomic_read (&session_state) == STAP_SESSION_STARTING)
if (atomic_read (&session_state) == STAP_SESSION_RUNNING)
atomic_set (&session_state, STAP_SESSION_STOPPING);
#ifdef STAPCONF_SYNCHRONIZE_SCHED
atomic_read (& ((struct context *)per_cpu_ptr(contexts, i))->busy)) 
struct stat_data *stats = _stp_stat_get (time_
int64_t avg = _stp_div64 (NULL, stats->sum, stats->count);
_stp_printf ("probe %s (%s), hits: %lld, cycles: %lldmin/%lldavg/%lldmax\n",
probe_point, decl_location, (long long) stats->count, (long long) stats->min, (long long) avg, (long long) stats->max);
if (atomic_read (& skipped_count) || 
atomic_read (& error_count) || 
atomic_read (& skipped_count_reentrant)) {
_stp_warn ("Number of errors: %d, 
(int) atomic_read (& error_count), 
(int) atomic_read (& skipped_count));
ctr = atomic_read (& global.s_
if (ctr) _stp_warn ("Skipped due to global '%s' lock timeout: %d\n", 
ctr = atomic_read (& skipped_count_lowstack);
if (ctr) _stp_warn ("Skipped due to low stack: %d\n", ctr);
ctr = atomic_read (& skipped_count_reentrant);
if (ctr) _stp_warn ("Skipped due to reentrancy: %d\n", ctr);
ctr = atomic_read (& skipped_count_uprobe_reg);
if (ctr) _stp_warn ("Skipped due to uprobe register failure: %d\n", ctr);
ctr = atomic_read (& skipped_count_uprobe_unreg);
if (ctr) _stp_warn ("Skipped due to uprobe unregister failure: %d\n", ctr);
adding a value of an unsupported map type
; if (unlikely(rc)) { c->last_error = "Array overflow, check 
checking existence of an unsupported map type
 (struct context* __restrict__ c) {
& c->locals[c->nesting+1].function_
if (unlikely (c->nesting+2 >= MAXNESTING)) {
c->last_error = "MAXNESTING exceeded";
static int systemtap_module_init (void) {
const char* release = UTS_RELEASE;
_stp_error ("module release mismatch (%s vs %s)", 
if (_stp_module_check()) rc = -EINVAL;
atomic_set (&session_state, STAP_SESSION_STARTING);
if (sizeof (struct context) <= 131072)
contexts = alloc_percpu (struct context);
_stp_error ("percpu context (size %lu) allocation failed", sizeof (struct context));
 = _stp_stat_init (HIST_NONE);
, (num_online_cpus() * sizeof(struct context))
_stp_error ("probe %s registration error (rc %d)", probe_point, rc);
atomic_set (&session_state, STAP_SESSION_ERROR);
atomic_set (&session_state, STAP_SESSION_RUNNING);
expected arrayindex expression in stat_op of array
cannot delete histogram bucket entries
expected arrayindex expression in printed hist_op
unknown type of arg to print operator
expected arrayindex expression in iterated hist_op
expected arrayindex expression in indexed hist_op
getting a value from an unsupported map type
inconsistent iterator type in itervar::start()
inconsistent iterator type in itervar::next()
setting a value of an unsupported map type
cannot assign to histogram buckets
function argument type mismatch
c->locals[c->nesting+1].function_
if (unlikely(c->last_error)) goto out;
function actual argument evaluation
e->indexes[0]->type == pe_long
unexpected aggregate of non-statistic
unexpected aggregate of non-arrayindex
c->last_error = "empty aggregate";
c->last_error = "aggregation overflow in 
s->indexes[0]->referent->type == pe_long
statistic-valued array in rvalue context
c->last_error = "histogram index out of range";
unexpected reference to scalar
cannot print unknown expression type
cannot print a raw stats object
print format actual argument evaluation
void translator_output::assert_0_indent()
void emit_symbol_data(systemtap_session&)
int dump_unwindsyms(Dwfl_Module*, void**, const char*, Dwarf_Addr, void*)
virtual void c_unparser::visit_hist_op(hist_op*)
virtual std::string var::buckets() const
virtual std::string var::hist() const
void aggvar::declare(c_unparser&) const
void var::assert_hist_compatible(const hist_op&)
virtual void c_unparser::visit_functioncall(functioncall*)
virtual void c_tmpcounter::visit_functioncall(functioncall*)
virtual void c_unparser_assignment::visit_arrayindex(arrayindex*)
virtual std::string mapvar::buckets() const
virtual std::string mapvar::hist() const
virtual void c_unparser::visit_arrayindex(arrayindex*)
virtual void c_tmpcounter::visit_arrayindex(arrayindex*)
void c_unparser::load_map_indices(arrayindex*, std::vector<tmpvar, std::allocator<tmpvar> >&)
void c_tmpcounter::load_map_indices(arrayindex*)
virtual void c_unparser_assignment::visit_symbol(symbol*)
virtual void c_unparser::visit_symbol(symbol*)
virtual void c_tmpcounter::visit_array_in(array_in*)
virtual void delete_statement_operand_tmp_visitor::visit_arrayindex(arrayindex*)
virtual void delete_statement_operand_visitor::visit_symbol(symbol*)
virtual void c_unparser::visit_foreach_loop(foreach_loop*)
void c_unparser_assignment::c_assignop(tmpvar&, const var&, const tmpvar&, const token*)
void translator_output::indent(int)
std::ostream& translator_output::newline(int)
32delete_statement_operand_visitor
36delete_statement_operand_tmp_visitor
23c_tmpcounter_assignment
21c_unparser_assignment
12c_tmpcounter
10c_unparser
8unparser
3var
6tmpvar
6aggvar
21arrayindex_downcaster
6mapvar
tapsets.cxx
/* init tracepoint probes */
for (i=0; i<
; i++) {
for (j=i-1; j>=0; j--)
/* init marker probes */
probe_point = smp->pp;
for (j=i-1; j>=0; j--) {
_stp_close_procfs();
#else
/* ---- user probes ---- */
if (sups->return_p) {
#ifdef DEBUG_UPROBES
sup->spec_index = -1;
probe_point = sups->pp;
if (rc) break;
/* ---- itrace probes ---- */
cleanup_usr_itrace();
/* ---- task finder ---- */
stap_stop_task_finder();
j = 0;
if (!sdp->return_p)
if (sdp->return_p)
#ifdef __ia64__
if (sdp->return_p) {
if (kp->u.krp.nmissed)
if (kp->u.krp.kp.nmissed)
if (kp->u.kp.nmissed)
sdp->registered_p = 0;
probe_point = sdp->pp;
if (sdp->maxactive_p) {
kp->dummy.pre_handler = NULL;
if (rc == 0) {
if (rc != 0)
else sdp->registered_p = 1;
for (i = 0; i < 
if (spp->read_pp)
probe_point = spp->read_pp;
probe_point = spp->write_pp;
if (spp->write_pp)
/* ---- utrace probes ---- */
if (p->engine_attached) {
atomic_inc (&error_count);
c->cycles_sum = 0;
c->probe_point = 0;
if (c->last_stmt != NULL)
atomic_inc (& error_count);
_stp_exit ();
atomic_dec (&c->busy);
probe_epilogue:
#if INTERRUPTIBLE
preempt_enable_no_resched ();
local_irq_restore (flags);
unsigned long nsecs;
int64_t i = stp->intrv;
if (stp->rnd != 0) {
int64_t r;
r -= stp->rnd;
i += r;
i = stap_hrtimer_resolution;
ktime_set(i, nsecs);
struct timespec res;
probe_point = stp->pp;
, HRTIMER_MODE_REL);
unsigned i = stp->intrv;
if (stp->rnd != 0)
stp->timer_list.data = i;
<anonymous>
 Error: 
 isn't a struct/union
 union 
 is empty
if (stp->type != 
) continue;
/* rc = 0; */
memstream
if (0) goto deref_fault;
deref_fault:
  goto out;
dwarf_line_t::addr
never
inline
maxactive
process
mark
trace
label
insn
block
thread
timer
procfs
int64_t __tracepoint_arg_
 /* pc=
#if !INTERRUPTIBLE
unsigned long flags;
preempt_disable ();
local_irq_save (flags);
goto probe_epilogue;
#ifdef DEBUG_REENTRANCY
atomic_dec (& c->busy);
c->last_stmt = 0;
c->last_error = 0;
c->nesting = 0;
c->regs = 0;
c->unwaddr = 0;
c->probe_point = 
c->pi = 0;
c->regparm = 0;
c->marker_name = NULL;
c->marker_format = NULL;
c->statp = 0;
 .tgt={
 .pathname="
 .pid=0,
 .pathname=NULL,
 .pid=
 .callback=NULL,
 .vm_callback=&
 .pp="internal",
 .ph=NULL,
 .flags=(UDPF_NONE),
 .ops={ NULL },
 .events=0,
 .engine_attached=0,
dwarf_getlocation_addr failed
cannot get type: 
cannot get type of pointee: 
 debuginfo
missing process 
dwfl_report_end
mark_builder releasing cache
b1 && b2
#include <linux/marker.h>
pattern '
matches 
dwarf_getsrc_file
alternative line 
 rejected: nsrcs=
 accepted: fn=
 accepted: ifn=
.init.
.devexit.
.cpuinit.
.cpuexit.
.meminit.
.memexit.
 skipping - init/exit
 skipping - __kprobes
 skipping - blacklisted
.exit.
.devinit.
dwfl_addrmodule
dwfl_module_info
emit dwarf addr 0x
 => module 
 section 
 relocaddr 0x
dwfl_module_relocation_info
addr; })
%#lxUL
getshstrndx
(intptr_t)
(intptr_t)&
cannot find 
char *
long long
short
void
 const
 volatile
struct __va_list_tag*
va_list
|arch/.*/kernel/kprobes.c
|include/asm/io.h
|include/asm/bitops.h
|arch/.*/include/asm/io.h
|arch/.*/include/asm/bitops.h
|drivers/ide/ide-iops.c
atomic_notifier_call_chain
|default_do_nmi
|__die
|die_nmi
|do_debug
|do_general_protection
|do_int3
|do_IRQ
|do_page_fault
|do_sparc64_fault
|do_trap
|dummy_nmi_callback
|flush_icache_range
|ia64_bad_break
|ia64_do_page_fault
|ia64_fault
|io_check_error
|mem_parity_error
|nmi_watchdog_tick
|notifier_call_chain
|oops_begin
|oops_end
|program_check_exception
|single_step_exception
|sync_regs
|unhandled_fault
|unknown_nmi_error
|.*raw_.*lock.*
|.*read_.*lock.*
|.*write_.*lock.*
|.*spin_.*lock.*
|.*rwlock_.*lock.*
|.*rwsem_.*lock.*
|.*mutex_.*lock.*
|raw_.*
|.*seq_.*lock.*
|atomic_.*
|atomic64_.*
|get_bh
|put_bh
|.*apic.*|.*APIC.*
|.*softirq.*
|.*IRQ.*
|.*_intr.*
|__delay
|.*kernel_text.*
|get_current
|current_.*
|.*exception_tables.*
|.*setup_rt_frame.*
|.*preempt_count.*
|preempt_schedule
do_exit
|sys_exit
|sys_exit_group
x86_64
|__switch_to
i686
blacklist regexps:
blfn: 
blfn_ret: 
blfile: 
blacklist_func regcomp failed
blacklist_file regcomp failed
new_left == fcall
Symbol table error: Line 
 of symbol list from 
%llx %c %as [%as
Symbol table error: 
 -- 
missing 
write to marker '
' not permitted
' may not be used as array
invalid marker '
' use
$format
_mark_format_get
_mark_name_get
utrace target variable '
utrace '
' variable is read-only
_utrace_syscall_return
_utrace_syscall_nr
  0x
write to tracepoint '
invalid tracepoint '
$$name
$$parms
sprintf
!tsym->saved_conversion_error
=%#x
global alias cache 
 size 
' parameter '
': type:'
' name:'
perfmon-based probe
has_path || has_pid
expect single probe point
' in '
_event_types
tracepoint-based 
 tracepoint='
linux/skbuff.h
Pass 2: using cached 
func_is_inline ()
checking instances of inline 
selected function 
dwarf_getsrcfiles
selected source file '
dwarf_getsrclines
dwarf_highpc
prologue searching function '
dwarf_line_t::linesrc
dwarf_line_t::lineno
checking line record 0x
prologue found function '
 (naked)
 (tail-call?)
function cache 
 hit 
 match 
 vs 
stapprobe_
randomize
jiffies
msec
usec
nsec
unrecognized timer variant
2.6.17
interval value out of range
#include <
STAP_SESSION_RUNNING
c->marker_name = 
.__tracepoint_arg_
 = (int64_t)
(void) {
return register_trace_
(enter_tracepoint_probe_
(void) unregister_trace_
int (*reg)(void);
void (*unreg)(void);
/* ---- marker probes ---- */
const char * const name;
const char * const format;
const char * const pp;
} stap_marker_probes [
 .name=
 .format=
 .pp=
 .ph=&
smp->pp
c->marker_name = smp->name;
c->mark_va_list = args;
(*smp->ph) (c);
c->mark_va_list = NULL;
c->data = NULL;
/* ---- procfs probes ---- */
#include "procfs.c"
const char *path;
const char *read_pp;
const char *write_pp;
} stap_procfs_probes[] = {
 .path=
 .read_pp=
 .read_ph=&
 .read_pp=NULL,
 .read_ph=NULL,
 .write_pp=
 .write_ph=&
 .write_pp=NULL,
 .write_ph=NULL
int bytes = 0;
string_t strdata = {'\0'};
spp->read_pp
if (c->data == NULL)
c->data = &strdata;
(*spp->read_ph) (c);
if (off >= bytes)
*eof = 1;
bytes -= off;
if (bytes > count)
bytes = count;
*start = page;
return bytes;
spp->write_pp
count = MAXSTRINGLEN - 1;
(*spp->write_ph) (c);
return count;
struct hrtimer hrtimer;
const char *pp;
void (*ph) (struct context*);
int64_t intrv, rnd;
} stap_hrtimer_probes [
 .intrv=
 .rnd=
#ifdef STAPCONF_HRTIMER_REL
static int 
static enum hrtimer_restart 
int rc = HRTIMER_NORESTART;
rc = HRTIMER_RESTART;
stp->pp
(*stp->ph) (c);
 .vm_callback=NULL,
 .flags=(UDPF_BEGIN),
 .flags=(UDPF_THREAD_BEGIN),
 .flags=(UDPF_END),
 .flags=(UDPF_THREAD_END),
 .flags=(UDPF_SYSCALL),
 .ops={ },
bad utrace probe flag
(*p->ph) (c);
#ifdef UTRACE_ORIG_VERSION
c->regs = regs;
debug_task_finder_detach();
return UTRACE_DETACH;
return UTRACE_RESUME;
if (register_p) {
switch (p->flags) {
case UDPF_BEGIN:
if (process_p) {
case UDPF_THREAD_BEGIN:
if (! process_p) {
case UDPF_END:
case UDPF_THREAD_END:
case UDPF_SYSCALL:
case UDPF_SYSCALL_RETURN:
p->engine_attached = 1;
default:
__stp_tf_vm_cb
#include "task_finder.c"
UDPF_NONE,
UDPF_BEGIN,
UDPF_END,
UDPF_THREAD_BEGIN,
UDPF_THREAD_END,
UDPF_SYSCALL,
UDPF_SYSCALL_RETURN,
UDPF_NFLAGS
struct stap_utrace_probe {
struct utrace_engine_ops ops;
unsigned long events;
int engine_attached;
/* ---- dwarf probes ---- */
#if ! defined(CONFIG_KPROBES)
#error "Need CONFIG_KPROBES!"
 struct pt_regs *regs);
struct kprobe dummy;
} stap_dwarf_kprobes[
const unsigned return_p:1;
const unsigned maxactive_p:1;
unsigned registered_p:1;
const char 
stap_dwarf_probe 
const char * const 
stap_dwarf_probe *
section
const unsigned long address;
} stap_dwarf_probes[] = {
 .return_p=1,
 .maxactive_p=1,
 .maxactive_val=
 .address=(unsigned long)0x
 .module="
 .section="
 struct pt_regs *regs) {
kprobe_idx:0)
sdp->pp
(*sdp->ph) (c);
c->pi = inst;
#include <linux/uprobes.h>
#include "uprobes/uprobes.h"
#ifndef MULTIPLE_UPROBES
#define MULTIPLE_UPROBES 256
#ifndef MAXUPROBES
static struct stap_uprobe {
int spec_index;
} stap_uprobes [MAXUPROBES];
const char *pathname;
} stap_uprobe_specs [] = {
 .finder = {
 .pathname=
sups->pp
if (sup->spec_index < 0 ||
sup->spec_index >= 
) return;
(*sups->ph) (c);
int handled_p = 0;
int slotted_p = 0;
sup->spec_index = spec_index;
slotted_p = 1;
} else if (!register_p && 
sup->urp.u.pid = tsk->tgid;
sup->up.pid = tsk->tgid;
handled_p = 1;
if (! handled_p) {
if (! process_p) return 0;
if (vm_pgoff != 0) return 0;
#ifdef DEBUG_TASK_FINDER_VMA
 .single_step=
c->data = data;
if (register_p) 
struct stap_itrace_probe {
int single_step;
#include "itrace.c"
/* ---- timer probes ---- */
struct timer_list timer_list;
unsigned intrv, ms, rnd;
} stap_timer_probes [
 .ms=
STAP_SESSION_STARTING
(*fn) (c);
STAP_SESSION_STOPPING
STAP_SESSION_ERROR
static struct stap_be_probe {
void (*ph)(struct context*);
const char* pp;
int type;
} stap_be_probes[] = {
 .type=
$arg
:long
:string
:unknown
_perfmon_tvar_get
$counter
].reg_num;
l->__mark_arg
 = va_arg(*c->mark_va_list, 
deref_string (
, tmp_str, MAXSTRINGLEN); }
deref_fault: ;
int64_t 
string_t 
$value
_procfs_value_set
_procfs_value_get
CONTEXT->data
, MAXSTRINGLEN); /* pure */
strlcpy (THIS->__retvalue, 
, THIS->value, MAXSTRINGLEN);
' not found
_dwarf_tvar_get
_dwarf_tvar_set
type definition '
dwarf_entrypc
dwarf_lowpc
dwarf_ranges
, ignored 
 more
entry-pc lookup (
) = 0x
 (rc 
!q->has_statement_num
examining inline instance of 
selected inline instance of 
timer.profile
if (c->last_error == NULL) 
(void) self; (void) val;
parsed '
' -> func '
', file '
', line 
malformed specification '
<unknown>
unsupported type tag 
struct/union '
unsupported type (encoding 
THIS->value
THIS->__retvalue
cannot write to array address
invalid marker argument use
_mark_tvar_get
.__mark_arg
! has_absolute
 kernel
 module=
 process=
 reloc=
 section=
 pc=0x
has_kernel || has_module
module == TOK_KERNEL
querying entrypc 
 of instance of inline '
dwarf_getsrc_die
dwarf_lineno
multiple addresses for 
 (try 
bias == module_bias
shdr != __null
.probes
pdata != __null
_stapprobe1_
dwfl_getehdr
i?86
ppc64
s390x
ia64
armv*
 (code 
) mismatch with target 
focused on module '
 = [0x
, bias 0x
 ELF machine 
q->has_kernel
__kprobes_text_start
__kprobes_text_end
cannot index pointer
bad field '
' for array type
unresolved struct 
struct
no location for field '
<anonymous type>
' vs. base type 
cannot find type: 
: unexpected type tag 
cannot get type of field: 
) has no return value
_utrace_syscall_arg
$syscall
THIS->pointer
 $$name $$parms $$vars
' (alternatives:
tracepoint variable '
_tracepoint_tvar_get
;/* pure */
_tracepoint_tvar_set
 while searching for local '
unable to find local '
 near pc 
finding location for local '
' near address 0x
, module bias 0x
' (dieoffset: 
$$return
_dwarf_tvar_
_ctr
_dwarf_tvar_tid
$$locals
sprint
=%#x 
variable location problem: 
sys_ni_syscall
 -- ignoring 
name == TOK_KERNEL
Error: Cannot find vmlinux.
spec_type == function_alone
Error: Pattern '
  Please be more precise.
Warning: address 
 out of range for module 
marker-based 
 mark=
 fmt='
has_mark_str
/Module.markers
 cannot be opened: 
perfmon
command
need read/write component
perfmon requires an event
incomplete
rc = stap_tracepoint_probes[i].reg();
stap_tracepoint_probes[j].unreg();
/* deregister marker probes */
struct stap_marker_probe *smp = &stap_marker_probes[i];
marker_probe_unregister(smp->name, enter_marker_probe, smp);
rc = marker_probe_register(smp->name, smp->format, enter_marker_probe, smp);
struct stap_marker_probe *smp2 = &stap_marker_probes[j];
marker_probe_unregister(smp2->name, enter_marker_probe, smp2);
probe_point = "timer.profile";
#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,10)
rc = register_profile_notifier (& stap_profile_notifier);
rc = register_timer_hook (& enter_profile_probes);
for (j=0; j<MAXUPROBES; j++) {
struct stap_uprobe *sup = & stap_uprobes[j];
struct stap_uprobe_spec *sups = &stap_uprobe_specs [sup->spec_index];
if (sup->spec_index < 0) continue;
printk (KERN_INFO "-uretprobe spec %d index %d pid %d addr %p\n", sup->spec_index, j, sup->up.pid, (void*) sup->up.vaddr);
unregister_uretprobe (& sup->urp);
printk (KERN_INFO "-uprobe spec %d index %d pid %d addr %p\n", sup->spec_index, j, sup->urp.u.pid, (void*) sup->urp.u.vaddr);
unregister_uprobe (& sup->up);
mutex_destroy (& stap_uprobes_lock);
mutex_init (& stap_uprobes_lock);
struct stap_uprobe_spec *sups = & stap_uprobe_specs[i];
if (sups->finder.pathname) sups->finder.callback = & stap_uprobe_process_found;
else if (sups->pathname) sups->finder.vm_callback = & stap_uprobe_vmchange_found;
rc = stap_register_task_finder_target (& sups->finder);
rc = stap_start_task_finder();
#if defined(STAPCONF_UNREGISTER_KPROBES)
struct stap_dwarf_probe *sdp = & stap_dwarf_probes[i];
struct stap_dwarf_kprobe *kp = & stap_dwarf_kprobes[i];
if (! sdp->registered_p) continue;
stap_unreg_kprobes[j++] = &kp->u.kp;
unregister_kprobes((struct kprobe **)stap_unreg_kprobes, j);
stap_unreg_kprobes[j++] = &kp->u.krp;
unregister_kretprobes((struct kretprobe **)stap_unreg_kprobes, j);
stap_unreg_kprobes[j++] = &kp->dummy;
#if !defined(STAPCONF_UNREGISTER_KPROBES)
unregister_kretprobe (&kp->u.krp);
atomic_add (kp->u.krp.nmissed, & skipped_count);
_stp_warn ("Skipped due to missed kretprobe/1 on '%s': %d\n", sdp->pp, kp->u.krp.nmissed);
atomic_add (kp->u.krp.kp.nmissed, & skipped_count);
_stp_warn ("Skipped due to missed kretprobe/2 on '%s': %d\n", sdp->pp, kp->u.krp.kp.nmissed);
unregister_kprobe (&kp->u.kp);
atomic_add (kp->u.kp.nmissed, & skipped_count);
_stp_warn ("Skipped due to missed kprobe on '%s': %d\n", sdp->pp, kp->u.kp.nmissed);
#if !defined(STAPCONF_UNREGISTER_KPROBES) && defined(__ia64__)
unregister_kprobe (&kp->dummy);
unsigned long relocated_addr = _stp_module_relocate (sdp->module, sdp->section, sdp->address);
if (relocated_addr == 0) continue;
kp->u.krp.kp.addr = (void *) relocated_addr;
kp->u.krp.maxactive = sdp->maxactive_val;
kp->u.krp.maxactive = max(10, 4*NR_CPUS);
kp->u.krp.handler = &enter_kretprobe_probe;
kp->dummy.addr = kp->u.krp.kp.addr;
rc = register_kprobe (& kp->dummy);
rc = register_kretprobe (& kp->u.krp);
unregister_kprobe (& kp->dummy);
kp->u.kp.addr = (void *) relocated_addr;
kp->u.kp.pre_handler = &enter_kprobe_probe;
kp->dummy.addr = kp->u.kp.addr;
rc = register_kprobe (& kp->u.kp);
_stp_warn ("probe %s registration error (rc %d)", probe_point, rc);
bspcache(c->unwaddr, c->regs);
hrtimer_cancel (& stap_hrtimer_probes[i].hrtimer);
/* deregister tracepoint probes */
stap_tracepoint_probes[i].unreg();
struct stap_procfs_probe *spp = &stap_procfs_probes[i];
rc = _stp_create_procfs(spp->path, i);
_stp_procfs_files[i]->read_proc = &_stp_procfs_read;
_stp_procfs_files[i]->read_proc = NULL;
_stp_procfs_files[i]->write_proc = &_stp_procfs_write;
_stp_procfs_files[i]->write_proc = NULL;
_stp_procfs_files[i]->data = spp;
unregister_profile_notifier (& stap_profile_notifier);
unregister_timer_hook (& enter_profile_probes);
del_timer_sync (& stap_timer_probes[i].timer_list);
for (i=0; i<ARRAY_SIZE(stap_utrace_probes); i++) {
struct stap_utrace_probe *p = &stap_utrace_probes[i];
stap_utrace_detach_ops(&p->ops);
rc = stap_register_task_finder_target(&p->tgt);
struct stap_utrace_probe *p = &stap_utrace_probes[j];
struct stap_itrace_probe *p = &stap_itrace_probes[i];
#if defined(STP_TIMING) || defined(STP_OVERLOAD)
cycles_t cycles_atend = get_cycles ();
int32_t cycles_elapsed = ((int32_t)cycles_atend > (int32_t)cycles_atstart)
? ((int32_t)cycles_atend - (int32_t)cycles_atstart)
: (~(int32_t)0) - (int32_t)cycles_atstart + (int32_t)cycles_atend + 1;
if (likely (c->statp)) _stp_stat_add(*c->statp, cycles_elapsed);
cycles_t interval = (cycles_atend > c->cycles_base)
? (cycles_atend - c->cycles_base)
: (STP_OVERLOAD_INTERVAL + 1);
c->cycles_sum += cycles_elapsed;
if (interval > STP_OVERLOAD_INTERVAL) {
if (c->cycles_sum > STP_OVERLOAD_THRESHOLD) {
_stp_error ("probe overhead exceeded threshold");
c->cycles_base = cycles_atend;
if (unlikely (c->last_error && c->last_error[0])) {
_stp_softerror ("%s near %s", c->last_error, c->last_stmt);
_stp_softerror ("%s", c->last_error);
if (atomic_read (& error_count) > MAXERRORS) {
atomic_set (& session_state, STAP_SESSION_ERROR);
if (unlikely (atomic_read (& skipped_count) > MAXSKIPPED)) {
get_random_bytes(&r, sizeof(r));
r &= ((uint64_t)1 << (8*sizeof(r) - 1)) - 1;
r = _stp_mod64(NULL, r, (2*stp->rnd+1));
if (unlikely(i < stap_hrtimer_resolution))
nsecs = do_div(i, NSEC_PER_SEC);
hrtimer_get_res (CLOCK_MONOTONIC, &res);
stap_hrtimer_resolution = timespec_to_ns (&res);
struct stap_hrtimer_probe* stp = & stap_hrtimer_probes [i];
hrtimer_init (& stp->hrtimer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
stp->hrtimer.function = & enter_hrtimer_probe;
(void) hrtimer_start (& stp->hrtimer, 
i += _stp_random_pm(stp->rnd);
stp->ms ? msecs_to_jiffies(i) : i;
struct stap_timer_probe* stp = & stap_timer_probes [i];
init_timer (& stp->timer_list);
stp->timer_list.function = & enter_timer_probe;
stp->timer_list.expires = jiffies + 
add_timer (& stp->timer_list);
dwarf_tag(cu) == DW_TAG_compile_unit
 Error in obtaining type attribute for 
 Error in decoding type attribute for 
struct stap_be_probe* stp = & stap_be_probes [i];
enter_end_probe (stp->ph, stp->pp);
enter_error_probe (stp->ph, stp->pp);
enter_begin_probe (stp->ph, stp->pp);
struct context* __restrict__ c;
cycles_t cycles_atstart = get_cycles ();
if (unlikely ((((unsigned long) (& c)) & (THREAD_SIZE-1))
< (MINSTACKSPACE + sizeof (struct thread_info)))) {
atomic_inc (& skipped_count_lowstack);
if (atomic_read (&session_state) != 
c = per_cpu_ptr (contexts, smp_processor_id());
if (atomic_inc_return (& c->busy) != 1) {
atomic_inc (& skipped_count_reentrant);
_stp_warn ("Skipped %s due to %s residency on cpu %u\n", 
, c->probe_point ?: "?", smp_processor_id());
c->actionremaining = MAXACTION_INTERRUPTIBLE;
c->actionremaining = MAXACTION;
not accessible at this address
#error "Need CONFIG_MARKERS!"
#if ! defined(CONFIG_MARKERS)
 rejected: leaves selected fns
 guru mode enabled - ignoring blacklist
({ static unsigned long addr = 0; 
if (addr==0) addr = _stp_module_relocate ("%s","%s",%#lx); 
cannot relocate user-space dso (?) address
has_kernel || has_process || has_module
mi && mi->name && mi->name == TOK_KERNEL
blacklist_func_ret regcomp failed
Operator-assign expressions on target variables not implemented
 is not in correct format: address type name [module]
 contains no function symbols.
Warning: cannot read symbol table from 
/usr/bin/nm -n --defined-only 
Internal error reading symbol table from 
Warning: nm cannot read symbol table from 
 kernel/module debuginfo under '
' may not be used as a structure
invalid use of utrace target variable '
only "process(PATH_OR_PID).syscall.return" support $return.
only one write procfs probe can exist for procfs path "
only one read procfs probe can exist for procfs path "
tracepoint_builder releasing dwflpp
cannot get type of tracepoint '
found parameter for tracepoint '
invalid interval for jiffies timer
invalid randomize for jiffies timer
cannot parse header location for tracepoint '
missing entrypc dwarf line record for function '
frequency must be greater than 0
randomization value out of range
get_param (parameters, TOK_TRACE, tracepoint)
dw.function_name.compare(0, 10, "stapprobe_") == 0
/* ---- tracepoint probes ---- */
static void enter_tracepoint_probe_
static int register_tracepoint_probe_
static void unregister_tracepoint_probe_
static struct stap_tracepoint_probe {
} stap_tracepoint_probes[] = {
 .reg=&register_tracepoint_probe_
 .unreg=&unregister_tracepoint_probe_
static struct stap_marker_probe {
void (* const ph) (struct context *);
static void enter_marker_probe (void *probe_data, void *call_data, const char *fmt, va_list *args) {
struct stap_marker_probe *smp = (struct stap_marker_probe *)probe_data;
c->marker_format = smp->format;
static struct stap_procfs_probe {
void (*read_ph) (struct context*);
void (*write_ph) (struct context*);
static int _stp_procfs_read(char *page, char **start, off_t off, int count, int *eof, void *data) {
struct stap_procfs_probe *spp = (struct stap_procfs_probe *)data;
if (unlikely (atomic_inc_return (& skipped_count) > MAXSKIPPED)) {
bytes = strnlen(strdata, MAXSTRINGLEN - 1);
memcpy(page, strdata + off, bytes);
static int _stp_procfs_write(struct file *file, const char *buffer, unsigned long count, void *data) {
if (count > (MAXSTRINGLEN - 1))
_stp_copy_from_user(strdata, buffer, count);
/* ---- hrtimer probes ---- */
static unsigned long stap_hrtimer_resolution;
static struct stap_hrtimer_probe {
#ifndef STAPCONF_HRTIMER_GETSET_EXPIRES
#define hrtimer_get_expires(timer) ((timer)->expires)
#define hrtimer_set_expires(timer, time) (void)((timer)->expires = (time))
#define HRTIMER_MODE_REL HRTIMER_REL
enter_hrtimer_probe (struct hrtimer *timer) {
struct stap_hrtimer_probe *stp = container_of(timer, struct stap_hrtimer_probe, hrtimer);
if ((atomic_read (&session_state) == STAP_SESSION_STARTING) ||
    (atomic_read (&session_state) == STAP_SESSION_RUNNING)) {
hrtimer_set_expires(timer, ktime_add (hrtimer_get_expires(timer),
 .callback=&_stp_utrace_probe_cb,
 .ops={ .report_syscall_entry=stap_utrace_probe_syscall,  .report_death=stap_utrace_task_finder_report_death },
 .events=(UTRACE_EVENT(SYSCALL_ENTRY)|UTRACE_EVENT(DEATH)),
 .flags=(UDPF_SYSCALL_RETURN),
 .ops={ .report_syscall_exit=stap_utrace_probe_syscall, .report_death=stap_utrace_task_finder_report_death },
 .events=(UTRACE_EVENT(SYSCALL_EXIT)|UTRACE_EVENT(DEATH)),
static void stap_utrace_probe_handler(struct task_struct *tsk, struct stap_utrace_probe *p) {
static u32 stap_utrace_probe_syscall(struct utrace_attached_engine *engine, struct task_struct *tsk, struct pt_regs *regs) {
static u32 stap_utrace_probe_syscall(enum utrace_resume_action action, struct utrace_attached_engine *engine, struct task_struct *tsk, struct pt_regs *regs) {
struct stap_utrace_probe *p = (struct stap_utrace_probe *)engine->data;
if ((atomic_read (&session_state) != STAP_SESSION_STARTING) && (atomic_read (&session_state) != STAP_SESSION_RUNNING)) {
static int _stp_utrace_probe_cb(struct stap_task_finder_target *tgt, struct task_struct *tsk, int register_p, int process_p) {
struct stap_utrace_probe *p = container_of(tgt, struct stap_utrace_probe, tgt);
struct utrace_attached_engine *engine;
stap_utrace_probe_handler(tsk, p);
rc = stap_utrace_attach(tsk, &p->ops, p, p->events);
_stp_error("unhandled flag value %d at %s:%d", p->flags, __FUNCTION__, __LINE__);
stap_utrace_detach(tsk, &p->ops);
static struct stap_utrace_probe stap_utrace_probes[] = {
enum utrace_derived_probe_flags {
struct stap_task_finder_target tgt;
enum utrace_derived_probe_flags flags;
static int enter_kprobe_probe (struct kprobe *inst,
static int enter_kretprobe_probe (struct kretprobe_instance *inst,
static void * stap_unreg_kprobes[
static struct stap_dwarf_kprobe {
union { struct kprobe kp; struct kretprobe krp; } u;
static struct stap_dwarf_probe {
const unsigned short maxactive_val;
void (* const ph) (struct context*);
p->maxactive_val >= 0 && p->maxactive_val <= 32767
int kprobe_idx = ((uintptr_t)inst-(uintptr_t)stap_dwarf_kprobes)/sizeof(struct stap_dwarf_kprobe);
struct stap_dwarf_probe *sdp = &stap_dwarf_probes[
((kprobe_idx >= 0 && kprobe_idx < 
struct kretprobe *krp = inst->rp;
int kprobe_idx = ((uintptr_t)krp-(uintptr_t)stap_dwarf_kprobes)/sizeof(struct stap_dwarf_kprobe);
#if defined(CONFIG_UPROBES) || defined(CONFIG_UPROBES_MODULE)
#define MAXUPROBES (MULTIPLE_UPROBES * 
union { struct uprobe up; struct uretprobe urp; };
DEFINE_MUTEX(stap_uprobes_lock);
static struct stap_uprobe_spec {
struct stap_task_finder_target finder;
static void enter_uprobe_probe (struct uprobe *inst, struct pt_regs *regs) {
struct stap_uprobe *sup = container_of(inst, struct stap_uprobe, up);
static void enter_uretprobe_probe (struct uretprobe_instance *inst, struct pt_regs *regs) {
struct stap_uprobe *sup = container_of(inst->rp, struct stap_uprobe, urp);
static int stap_uprobe_change (struct task_struct *tsk, int register_p, unsigned long relocation, struct stap_uprobe_spec *sups) {
int spec_index = (sups - stap_uprobe_specs);
mutex_lock (& stap_uprobes_lock);
for (i=0; i<MAXUPROBES; i++) {
struct stap_uprobe *sup = & stap_uprobes[i];
if (register_p && sup->spec_index < 0) {
if (sup->spec_index == -1 && sup->up.kdata != NULL) continue;
else if (sup->spec_index == -2 && sup->urp.u.kdata != NULL) continue;
sup->spec_index == spec_index && 
((sups->return_p && sup->urp.u.pid == tsk->tgid && sup->urp.u.vaddr == relocation + sups->address) ||
(!sups->return_p && sup->up.pid == tsk->tgid && sup->up.vaddr == relocation + sups->address))) {
mutex_unlock (& stap_uprobes_lock);
printk (KERN_INFO "%cuprobe spec %d idx %d process %s[%d] reloc %p pp '%s'\n", 
(register_p ? '+' : '-'), spec_index, (slotted_p ? i : -1), tsk->comm, tsk->tgid, (void*) relocation, sups->pp);
if (register_p && slotted_p) {
sup->urp.u.vaddr = relocation + sups->address;
sup->urp.handler = &enter_uretprobe_probe;
rc = register_uretprobe (& sup->urp);
sup->up.vaddr = relocation + sups->address;
sup->up.handler = &enter_uprobe_probe;
rc = register_uprobe (& sup->up);
printk (KERN_WARNING "uprobe failed %s[%d] '%s' addr %p rc %d\n", tsk->comm, tsk->tgid, sups->pp, (void*)(relocation + sups->address), rc);
} else if (!register_p && slotted_p) {
sup->spec_index = (sups->return_p ? -2 : -1);
atomic_inc (register_p ? & skipped_count_uprobe_reg : & skipped_count_uprobe_unreg);
static int stap_uprobe_process_found (struct stap_task_finder_target *tgt, struct task_struct *tsk, int register_p, int process_p) {
struct stap_uprobe_spec *sups = container_of(tgt, struct stap_uprobe_spec, finder);
return stap_uprobe_change (tsk, register_p, 0, sups);
static int stap_uprobe_vmchange_found (struct stap_task_finder_target *tgt, struct task_struct *tsk, int map_p, char *vm_path, unsigned long vm_start, unsigned long vm_end, unsigned long vm_pgoff) {
if (vm_path == NULL || strcmp (vm_path, sups->pathname)) return 0;
if (vm_end <= vm_start + sups->address) return 0;
printk (KERN_INFO "vmchange pid %d map_p %d path %s vms %p vme %p vmp %p\n", tsk->tgid, map_p, vm_path, (void*) vm_start, (void*) vm_end, (void*) vm_pgoff);
printk (KERN_INFO "sups %p pp %s path %s address %p\n", sups, sups->pp, sups->pathname ?: "", (void*) sups->address);
return stap_uprobe_change (tsk, map_p, vm_start, sups);
 .callback=&_stp_itrace_probe_cb,
static int _stp_itrace_probe_cb(struct stap_task_finder_target *tgt, struct task_struct *tsk, int register_p, int process_p) {
struct stap_itrace_probe *p = container_of(tgt, struct stap_itrace_probe, tgt);
rc = usr_itrace_init(p->single_step, tsk->pid, p);
remove_usr_itrace_info(find_itrace_info(p->tgt.pid));
static struct stap_itrace_probe stap_itrace_probes[] = {
static void enter_itrace_probe(struct stap_itrace_probe *p, struct pt_regs *regs, void *data);
static void enter_itrace_probe(struct stap_itrace_probe *p, struct pt_regs *regs, void *data) {
static struct stap_timer_probe {
static void enter_timer_probe (unsigned long val) {
struct stap_timer_probe* stp = & stap_timer_probes [val];
    (atomic_read (&session_state) == STAP_SESSION_RUNNING))
mod_timer (& stp->timer_list, jiffies + 
/* ---- begin/end probes ---- */
static void enter_begin_probe (void (*fn)(struct context*), const char* pp) {
static void enter_end_probe (void (*fn)(struct context*), const char* pp) {
static void enter_error_probe (void (*fn)(struct context*), const char* pp) {
e->base_name.size() > 0 && e->base_name[0] == '$'
writes to $counter not permitted
target variables not available to perfmon probes
perfmon probe '$counter' variable may not be used as array
perfmon probe '$counter' variable may not be used as a structure
invalid use of perfmon probe '$counter' variable
THIS->__retvalue = _pfm_pmd_x[
 tmp_str = va_arg(*c->mark_va_list, 
invalid target symbol for procfs probe, $value expected
procfs target variable '$value' may not be used as array
procfs target variable '$value' may not be used as a structure
invalid use of procfs target variable '$value'
procfs $value variable is read-only in a procfs write probe
procfs $value variable cannot be read in a procfs read probe
!target_symbol_setter_functioncalls.empty()
write to typecast value not permitted
/* ---- profile probes ---- */
static void enter_all_profile_probes (struct pt_regs *regs) {
static int enter_profile_probes (struct notifier_block *self,
 unsigned long val, void *data) {
enter_all_profile_probes ((struct pt_regs *) data);
struct notifier_block stap_profile_notifier = {
 .notifier_call = & enter_profile_probes };
static int enter_profile_probes (struct pt_regs *regs) {
enter_all_profile_probes (regs);
' is being accessed instead of a member of the struct/union
typetag == DW_TAG_pointer_type
invalid marker argument number
write to marker parameter not permitted
marker argument may not be used as array
marker argument may not be used as a structure
THIS->__retvalue = CONTEXT->locals[0].
strlcpy (THIS->__retvalue, CONTEXT->locals[0].
invalid target symbol for marker, $argN, $name or $format expected
missing relocation base against
inconsistent relocation address
maxactive value out of range [0,
cannot probe .return of inline function '
function DIE lands on srcfile
inline instance DIE lands on srcfile
 does not match the beginning of a statement
has_function_str || has_statement_str
absolute statement probe in unprivileged script
 Error in obtaining type attribute for 
 Error in decoding DW_AT_type attribute for 
literal_stmt_for_return: finding return value for 
failed to retrieve return value location for 
unable to find return value near pc 
only "process(PATH_OR_PID).syscall" support $argN.
utrace target variable '$argN' may not be used as array
utrace target variable '$argN' may not be used as a structure
invalid use of utrace target variable '$argN'
invalid syscall argument number (1-6)
utrace '$argN' variable is read-only
only "process(PATH_OR_PID).syscall" and "process(PATH_OR_PID).syscall.return" probes support target symbols
invalid target symbol for utrace probe, $syscall, $return or $argN expected
literal_stmt_for_pointer: finding value for 
unable to find member for struct 
unable to find tracepoint variable '
invalid use of tracepoint variable '
write to tracepoint variable '
unable to find any scopes containing 
failed to retrieve location attribute for local '
failed to retrieve type attribute for local '
write to target variable not permitted
write to target variable not permitted in .return probes
Bad variable being substituted with literal 0
Warning: reading symbol table from 
  Consider using --kmap instead of --kelf.
' matches every instruction address in the symbol table,
some of which aren't even functions.
has_function_num || has_statement_num
 maps to no known compilation unit in module 
process pid must be greater than 1
dwarf_builder releasing kernel dwflpp
dwarf_builder releasing user dwflpp 
procfs path cannot start with a '/'
procfs path component cannot be empty
procfs path cannot be relative (and contain '.' or '..')
procfs path cannot end with a '/'
virtual update_visitor::~update_visitor()
virtual void uprobe_builder::build(systemtap_session&, probe*, probe_point*, const literal_map_t&, std::vector<derived_probe*, std::allocator<derived_probe*> >&)
virtual void itrace_builder::build(systemtap_session&, probe*, probe_point*, const std::map<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, literal*, std::less<std::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::pair<const std::basic_string<char, std::char_traits<char>, std::allocator<char> >, literal*> > >&, std::vector<derived_probe*, std::allocator<derived_probe*> >&)
T update_visitor::require(T, bool) [with T = statement*]
virtual void perfmon_var_expanding_visitor::visit_target_symbol(target_symbol*)
virtual void tracepoint_builder::build(systemtap_session&, probe*, probe_point*, const literal_map_t&, std::vector<derived_probe*, std::allocator<derived_probe*> >&)
int tracepoint_query::handle_query_func(Dwarf_Die*)
void dwflpp::focus_on_function(Dwarf_Die*)
void dwflpp::focus_on_cu(Dwarf_Die*)
virtual void tracepoint_var_expanding_visitor::visit_target_symbol(target_symbol*)
void tracepoint_var_expanding_visitor::visit_target_symbol_context(target_symbol*)
T update_visitor::require(T, bool) [with T = target_symbol*]
void tracepoint_var_expanding_visitor::visit_target_symbol_arg(target_symbol*)
void dwflpp::translate_final_fetch_or_store(obstack*, location**, Dwarf_Addr, Dwarf_Die*, Dwarf_Attribute*, bool, std::string&, std::string&, exp_type&)
std::string dwflpp::express_as_string(std::string, std::string, location*)
virtual void mark_builder::build(systemtap_session&, probe*, probe_point*, const literal_map_t&, std::vector<derived_probe*, std::allocator<derived_probe*> >&)
virtual void mark_var_expanding_visitor::visit_target_symbol(target_symbol*)
virtual void procfs_var_expanding_visitor::visit_target_symbol(target_symbol*)
void translator_output::assert_0_indent()
uprobe_derived_probe::uprobe_derived_probe(const std::string&, const std::string&, int, const std::string&, int, const std::string&, Dwarf_Addr, Dwarf_Addr, dwarf_query&, Dwarf_Die*)
virtual void utrace_var_expanding_visitor::visit_target_symbol(target_symbol*)
utrace_derived_probe::utrace_derived_probe(systemtap_session&, probe*, probe_point*, bool, std::string&, int64_t, utrace_derived_probe_flags)
void module_info::get_symtab(dwarf_query*)
void symbol_table::mark_dwarf_redundancies(dwflpp*)
info_status symbol_table::get_from_elf()
virtual void dwarf_builder::build(systemtap_session&, probe*, probe_point*, const literal_map_t&, std::vector<derived_probe*, std::allocator<derived_probe*> >&)
virtual void dwarf_derived_probe_group::emit_module_decls(systemtap_session&)
dwarf_derived_probe::dwarf_derived_probe(const std::string&, const std::string&, int, const std::string&, const std::string&, Dwarf_Addr, Dwarf_Addr, dwarf_query&, Dwarf_Die*)
virtual void dwarf_cast_expanding_visitor::visit_cast_op(cast_op*)
virtual void dwarf_var_expanding_visitor::visit_target_symbol(target_symbol*)
T update_visitor::require(T, bool) [with T = expression*]
Dwarf_Attribute* dwflpp::find_variable_and_frame_base(Dwarf_Die*, Dwarf_Addr, const std::string&, Dwarf_Die*, Dwarf_Attribute*)
virtual void var_expanding_visitor::visit_assignment(assignment*)
int query_module(Dwfl_Module*, void**, const char*, Dwarf_Addr, void*)
void dwflpp::focus_on_module(Dwfl_Module*, module_info*)
Dwarf_Addr lookup_symbol_address(Dwfl_Module*, const char*)
void dwarf_query::add_probe_point(const std::string&, const char*, int, Dwarf_Die*, Dwarf_Addr)
void dwarf_query::query_module_symtab()
void dwarf_query::query_module_dwarf()
Dwarf_Addr dwflpp::module_address_to_global(Dwarf_Addr)
void dwflpp::query_cu_containing_global_address(Dwarf_Addr, void*)
int query_cu(Dwarf_Die*, void*)
void dwflpp::collect_srcfiles_matching(const std::string&, std::set<const char*, std::less<const char*>, std::allocator<const char*> >&)
void dwflpp::resolve_prologue_endings(func_info_map_t&)
void dwflpp::function_line(int*)
int query_dwarf_func(Dwarf_Die*, base_query*)
void dwflpp::iterate_over_inline_instances(int (*)(Dwarf_Die*, void*), void*)
bool dwflpp::func_is_inline()
bool dwflpp::function_name_matches(std::string)
void dwflpp::function_die(Dwarf_Die*)
void dwflpp::function_file(const char**)
bool dwflpp::function_entrypc(Dwarf_Addr*)
int query_dwarf_inline_instance(Dwarf_Die*, void*)
int dwflpp::iterate_over_functions(int (*)(Dwarf_Die*, base_query*), base_query*, const std::string&, bool)
int dwflpp::iterate_over_globals(int (*)(Dwarf_Die*, void*), void*)
base_query::base_query(dwflpp&, const literal_map_t&)
21perfmon_derived_probe
29perfmon_var_expanding_visitor
13timer_builder
27hrtimer_derived_probe_group
21hrtimer_derived_probe
18tracepoint_builder
16tracepoint_query
32tracepoint_var_expanding_visitor
30tracepoint_derived_probe_group
24tracepoint_derived_probe
12mark_builder
26mark_var_expanding_visitor
24mark_derived_probe_group
18mark_derived_probe
14procfs_builder
28procfs_var_expanding_visitor
26procfs_derived_probe_group
20procfs_derived_probe
27profile_derived_probe_group
21profile_derived_probe
25timer_derived_probe_group
19timer_derived_probe
26uprobe_derived_probe_group
28utrace_var_expanding_visitor
26utrace_derived_probe_group
20utrace_derived_probe
26itrace_derived_probe_group
20itrace_derived_probe
31task_finder_derived_probe_group
28dwarf_cast_expanding_visitor
16dwarf_cast_query
27dwarf_var_expanding_visitor
21var_expanding_visitor
13dwarf_builder
11dwarf_query
25dwarf_derived_probe_group
20uprobe_derived_probe
19dwarf_derived_probe
22be_derived_probe_group
16be_derived_probe
11generic_dpgI21hrtimer_derived_probeE
10base_query
11generic_dpgI24tracepoint_derived_probeE
11generic_dpgI18mark_derived_probeE
11generic_dpgI20procfs_derived_probeE
11generic_dpgI21profile_derived_probeE
11generic_dpgI19timer_derived_probeE
11generic_dpgI20uprobe_derived_probeE
11generic_dpgI20utrace_derived_probeE
11generic_dpgI20itrace_derived_probeE
11generic_dpgI25task_finder_derived_probeE
19derived_probe_group
11generic_dpgI16be_derived_probeE
10be_builder
13never_builder
19never_derived_probe
15profile_builder
15perfmon_builder
14uprobe_builder
14utrace_builder
14itrace_builder
if $(CHECK_BUILD) $(SYSTEMTAP_RUNTIME)/
verifying that SystemTap's version of uprobes is up to date.
SystemTap's version of uprobes is out of date.
Warning: failed to create directory for querying tracepoints.
#define DECLARE_TRACE(name, proto, args) \
  void stapprobe_##name(proto) {}
#define DEFINE_TRACE(name, proto, args) \
  DECLARE_TRACE(name, TPPROTO(proto), TPARGS(args))
#endif /* CONFIG_TRACEPOINTS */
int init_module(void) { return 0; }
MODULE_DESCRIPTION("tracepoint query");
/bin/grep -q unregister_uprobe 
(re)building SystemTap's version of uprobes.
_KBUILD_CFLAGS := $(call flags,KBUILD_CFLAGS)
 if $(CC) $(1) -S -o /dev/null -xc /dev/null > /dev/null 2>&1; then echo "$(1)"; else echo "$(2)"; fi)
CHECK_BUILD := $(CC) $(KBUILD_CPPFLAGS) $(CPPFLAGS) $(LINUXINCLUDE) $(_KBUILD_CFLAGS) $(CFLAGS_KERNEL) $(EXTRA_CFLAGS) $(CFLAGS) -DKBUILD_BASENAME=\"
\" -Werror -S -o /dev/null -xc 
 ; then echo "$(2)"; else echo "$(3)"; fi)
 += -Iinclude2/asm/mach-default
autoconf-hrtimer-getset-expires.c
 += -include $(STAPCONF_HEADER)
EXTRA_CFLAGS += -ftime-report -Q
EXTRA_CFLAGS += -freorder-blocks
EXTRA_CFLAGS += -Wno-unused -Werror
Make sure kernel devel is installed.
 > /dev/null 2>&1
; then 
echo "#define 
; fi >> $@
ARCH
KBUILD_EXTMOD
CROSS_COMPILE
KBUILD_IMAGE
KCONFIG_CONFIG
INSTALL_PATH
unsetenv failed: 
 V=1
 >/dev/null
 -s >/dev/null 2>&1
Pass 4, preamble: 
/uprobes
 uprobes.ko
make -q -C 
As root, run "make -C 
/tracequery
/tracequery.ko
/Makefile
EXTRA_CFLAGS := -g
obj-m := tracequery.o
/tracequery.c
#include <linux/module.h>
#ifdef CONFIG_TRACEPOINTS
#include <linux/tracepoint.h>
#undef DECLARE_TRACE
#undef DEFINE_TRACE
/source/include/trace/*.h
trace_events.h
_event_types.h
#include <trace/
void cleanup_module(void) {}
make -C '
 M='
' modules
SYSTEMTAP_STAPRUN
/usr/bin/staprun
/Module.symvers
uprobes rebuild rc=
/Module.symvers 
/bin/cp 
set -x;
stap_check_gcc = $(shell 
stap_check_build = $(shell 
 if $(CHECK_BUILD) $(1) 
SYSTEMTAP_RUNTIME = "
EXTRA_CFLAGS
STAPCONF_HEADER := 
: $(STAPCONF_HEADER)
$(STAPCONF_HEADER):
	@echo -n > $@
autoconf-hrtimer-rel.c
STAPCONF_INODE_PRIVATE
autoconf-inode-private.c
STAPCONF_CONSTANT_TSC
autoconf-constant-tsc.c
STAPCONF_TSC_KHZ
autoconf-tsc-khz.c
STAPCONF_KTIME_GET_REAL
autoconf-ktime-get-real.c
STAPCONF_X86_UNIREGS
autoconf-x86-uniregs.c
STAPCONF_NAMEIDATA_CLEANUP
autoconf-nameidata.c
STAPCONF_UNREGISTER_KPROBES
autoconf-unregister-kprobes.c
STAPCONF_REAL_PARENT
autoconf-real-parent.c
STAPCONF_LINUX_UACCESS_H
autoconf-uaccess.c
STAPCONF_ONEACHCPU_RETRY
autoconf-oneachcpu-retry.c
STAPCONF_DPATH_PATH
autoconf-dpath-path.c
STAPCONF_SYNCHRONIZE_SCHED
autoconf-synchronize-sched.c
STAPCONF_TASK_UID
autoconf-task-uid.c
STAPCONF_VM_AREA
autoconf-vm-area.c
STAPCONF_PROCFS_OWNER
autoconf-procfs-owner.c
STAPCONF_ALLOC_PERCPU_ALIGN
autoconf-alloc-percpu-align.c
STAPCONF_FIND_TASK_PID
autoconf-find-task-pid.c
STAPCONF_KERNEL_STACKTRACE
autoconf-save-stack-trace.c
EXTRA_CFLAGS += -D 
EXTRA_CFLAGS += -I"
obj-m := 
Module directory 
 check failed: 
 -C "
make
" modules
 M="
%*s%s %s;
%*s{ // synthesized
%*s{ // DWARF expression:
 %#x
(%ld)
(%ld,%ld)
%*s%s = fetch_register (%u);
%*s{
%*s%s s%u
, s%u
%s%*s%s = s%u;
%*suint%lu_t %s;
frame_base
%s%*s}
loc2c.c
%*sunion {
%*schar bytes[%lu];
%*sstruct {
%*suint%lu_t p%lu;
%*suint%lu_t whole;
%*s} u;
%*scontainer_addr = addr;
container_addr
%*saddr = %s;
%*saddr += %s * %luUL;
%*saddr += %luUL * %luUL;
%*su.whole = %s;
store_deref (%lu, addr, %s); 
store_register (%u, %s);
%*s%s = u.whole;
%sint%u_t value = 
deref (%lu, addr);
deref (sizeof %s, addr);
fetch_register (%u);
%s = value; 
%*s%s = addr;
%*ss%u = addr;
%*ss%u = s%u;
%*s/* drop s%u*/
invalid skip target
%*ss%u = deref (%luUL, s%u);
%*ss%u = 
%*ss%u = %ldL;
%*ss%u = %s (s%u);
op_abs
%*ss%u = s%u %s s%u;
uintptr_t
%*ss%u = s%u + %luUL;
%*ss%u = frame_base + %ldL;
stack underflow
XXX DW_OP_push_object_address
unrecognized operation
multiple values left on stack
%*saddr += %ldL
register
DW_OP_piece
cannot handle offset into register in fetch
cannot get bit field parameters: %s
dwarf_tag (typedie) == DW_TAG_base_type || dwarf_tag (typedie) == DW_TAG_enumeration_type
cannot get byte_size attribute for type %s: %s
%*ss%u = fetch_register (%d);
%*s} pieces __attribute__ ((packed));
%*saddr = container_addr + %luUL;
single register too big for fetch/store ???
discontiguify of noncontiguous location not supported
cannot determine CU address size from %s: %s
dwarf_tag (typedie) == DW_TAG_array_type
cannot get byte_stride attribute array type %s: %s
cannot get element type of array type %s: %s
cannot get byte_size attribute for array element type %s: %s
confused about array element size
cannot dynamically index noncontiguous array
constant index is outside noncontiguous array
noncontiguous array splits elements
cannot index array stored in a register
constant index is outside array held in register
store_deref (sizeof %s, addr, %s); 
cannot handle offset into register in store
noncontiguous location for base store
store is larger than base integer types
dwarf_tag (typedie) == DW_TAG_pointer_type
noncontiguous location for base fetch
fetch is larger than base integer types
cannot take the address of a bit field
cannot take address of object in register
cannot take address of noncontiguous object
%*sstore_bitfield (tmp, %s, %lu, %lu);
%*sfetch_bitfield (%s, tmp, %lu, %lu);
%*ss%u = s%u, s%u = s%u, s%u = s%u;
%*ss%u = s%u, s%u = s%u, s%u = s%u, s%u = s%u;
conditional branches not supported
%*ss%u = deref (sizeof (void *), s%u);
%*ss%u = xderef (sizeof (void *), s%u, s%u);
%*ss%u = xderef (%luUL, s%u, s%u);
%*ss%u = (%s) s%u >> (%s)s%u;
%*ss%u = fetch_register (%u) + %ldL;
DW_OP_fbreg from DW_AT_frame_base
DW_OP_piece left multiple values on stack
register value must stand alone in location expression
extra operations after last DW_OP_piece
%s in DWARF expression [%Zu] at %lu (%#x: %ld, %ld)
required DW_AT_frame_base attribute not supplied
dwarf_getlocation_addr (form %#x): %s
DW_AT_frame_base not accessible at this address
static calculation depends on load-time address
offset outside available pieces
relative expression computed constant
cannot handle location expression
c_translate_array
c_translate_pointer_store
c_translate_pointer
base_byte_size
/.config
/.version
/include/linux/compile.h
/include/linux/version.h
/include/linux/utsrelease.h
/proc/self/exe
SYSTEMTAP_NLEVELS
/tracequery_
Pass 3: using cached 
Pass 4: using cached 
cache_mb_limit
Cache limit file 
 missing, creating default.
/*/*.ko
/*/*.h
Cache cleaning successful, removed entries: 
Cache cleaning skipped, no cache path.
HOME
'"'"'
.XXXXXX
(not-a-git-repository)
/.git/
git --git-dir="
" rev-parse HEAD 2>/dev/null
Unable to determine home directory
insert or ignore into counts values ('
update counts set compiled=compiled+
SELECT name FROM sqlite_master 
create table counts (file text, line integer, col integer, type text, name text, parent text, compiled integer, executed integer)
create unique index tokens on counts (file, line, col, type, name)
Error in statement: 
---- used probes-----
probe: 
unused_local: 
---- unused probes----- 
---- used functions----- 
---- unused functions----- 
unused_function: 
---- used globals----- 
globals: 
---- unused globals----- 
', '
'0', '0')
'0', '0'); 
 where (
file=='
' and 
line=='
col=='
type=='
name=='
WHERE type='index' AND name='
WHERE type='table' AND name='
Can't open database: 
counts
tokens
commit
libdwfl failure (
libdw failure (
zPLR
stap.debug
.shstrtab
.interp
.note.ABI-tag
.note.gnu.build-id
.gnu.hash
.dynsym
.dynstr
.gnu.version
.gnu.version_r
.rela.dyn
.rela.plt
.init
.text
.fini
.rodata
.eh_frame_hdr
.eh_frame
.gcc_except_table
.ctors
.dtors
.jcr
.data.rel.ro
.dynamic
.got
.data
.bss
.gnu_debuglink
